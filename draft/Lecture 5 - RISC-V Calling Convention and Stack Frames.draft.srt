1
00:00:00,810 --> 00:00:02,860
810,2640
Yep.|
好的。|

2
00:00:05,770 --> 00:00:07,510
90,390 390,780 1170,1500 1500,1680 1680,1830
Hey buddy, people hear what
嘿，大家都能听到我说话吗。

3
00:00:07,510 --> 00:00:09,190
1830,1920 1920,2280 2910,3150 3150,3510
I'm saying.| You're good,
|很好，能听到。

4
00:00:09,670 --> 00:00:13,060
3990,4530 5340,6180 6750,7080 7080,7260 7260,7380
good.| Awesome, I just want
|太棒了，我想和上周一样开始，

5
00:00:13,060 --> 00:00:14,440
7380,7440 7440,7560 7560,8010 8010,8400 8400,8760
to get started with similar

6
00:00:14,440 --> 00:00:15,340
8760,8850 8850,9240 9240,9390 9390,9540 9540,9660
to last week| where we
|上周，我们问了你一些 util 实验的问题，

7
00:00:15,340 --> 00:00:17,710
9660,9930 9930,10050 10050,10800 11820,12030
asked you about, the

8
00:00:17,710 --> 00:00:18,760
12030,12390 12390,12720 12720,12810 12810,12930 12930,13080
util lab,| I just want
|我想先问一下 syscall 实验的情况，

9
00:00:18,760 --> 00:00:19,690
13080,13140 13140,13260 13260,13590 13590,13710 13710,14010
to get started by asking

10
00:00:19,690 --> 00:00:20,560
14010,14070 14070,14220 14220,14310 14310,14520 14520,14880
a little bit about syscall

11
00:00:20,560 --> 00:00:22,030
14880,15240 15240,15450 15450,15600 15600,15750 15750,16350
lab,| since that was due
|因为那是周四到期的。

12
00:00:22,330 --> 00:00:24,140
16650,17280 17310,18210
on thursday.|
|

13
00:00:24,520 --> 00:00:26,140
120,480 480,570 570,930 930,1170 1170,1740
So if anybody just has
所以如果有人在实验中发现什么特别有趣的东西

14
00:00:26,320 --> 00:00:28,150
1920,2220 2220,2490 2490,3090 3090,3630 3630,3750
like something particularly interesting, they

15
00:00:28,150 --> 00:00:29,350
3750,3990 3990,4200 4200,4320 4320,4800 4800,4950
found about the lab| or
|或者

16
00:00:29,350 --> 00:00:30,430
4950,5010 5010,5400 5400,5700 5700,5820 5820,6030
a nasty bug that they
发现一个难缠的 bug ，

17
00:00:30,430 --> 00:00:32,080
6030,6630 6630,6900 7050,7350 7350,7410 7410,7680
found| or just a silly
|或者只是犯了一个愚蠢的错误，

18
00:00:32,080 --> 00:00:33,340
7680,8100 8100,8220 8220,8520 8520,8820 8820,8940
mistake they made,| anything you
|关于 syscall 实验，

19
00:00:33,340 --> 00:00:34,150
8940,9090 9090,9150 9150,9420 9420,9660 9660,9750
want to share about the
你有什么想要分享的吗？

20
00:00:34,150 --> 00:00:35,540
9750,10140 10140,10470 10470,10590 10590,10890
syscall lab to be.|
|

21
00:00:35,780 --> 00:00:36,900
120,300 300,360 360,750
That'd be great.|
那就太好了。
|

22
00:00:38,450 --> 00:00:40,370
330,630 630,990 990,1530 1530,1620 1620,2250
I somehow managed to delete
不知道什么原因，

23
00:00:40,370 --> 00:00:42,890
2250,2370 2370,2880 2880,3240 3900,4770
the part from, where
我删掉了 fork 中需要通过 mask 复制的部分

24
00:00:42,920 --> 00:00:44,240
4800,5100 5100,5640 5640,5820 5820,5940 5940,6120
from fork where you have

25
00:00:44,240 --> 00:00:45,470
6120,6240 6240,6630 6630,6840 6840,6900 6900,7350
to copy over the mask,|
|

26
00:00:45,470 --> 00:00:46,460
7350,7470 7470,7560 7560,7710 7710,7890 7890,8340
so I had that working
我让它工作了，然后我修改了其他东西，然后我测试了它。

27
00:00:46,460 --> 00:00:47,360
8340,8490 8490,8610 8610,8700 8700,8970 8970,9240
and then I change something

28
00:00:47,360 --> 00:00:48,470
9240,9630 9630,9750 9750,9900 9900,9960 9960,10350
else and then I tested

29
00:00:48,470 --> 00:00:49,860
10350,10950 10950,11370
it for.|
|

30
00:00:50,200 --> 00:00:51,400
120,480 480,780 780,870 870,1050 1050,1320
Your audio is like cutting
你的音频好像被断掉了。

31
00:00:51,400 --> 00:00:53,260
1320,1800 1800,1980 1980,2070 2070,2400 2430,3180
out.| Oh, it is sorry.
|哦，很抱歉。你能听到我说话吗。

32
00:00:53,970 --> 00:00:54,880
90,270 270,390 390,780
You hear me.|
|

33
00:00:58,060 --> 00:00:59,020
120,300 300,540 540,810
I hear you.|
我听到了。|

34
00:00:59,380 --> 00:01:02,710
120,480 510,1020 2850,3240 3240,3450
Oh, okay.| Yeah I
哦，好吧。|我想是这样。

35
00:01:02,710 --> 00:01:03,560
3450,3990
guess.|
|

36
00:01:03,680 --> 00:01:06,110
120,600 600,1170 1170,1350 1350,1950 1950,2550
So basically I deleted somehow
基本上我以某种方式删除了 mask 的复制，

37
00:01:06,140 --> 00:01:07,490
2580,2850 2850,3210 3210,3330 3330,3420 3420,3930
the copy of the mask|

38
00:01:07,490 --> 00:01:09,650
3930,4050 4050,4440 4560,5130 5160,5460 5460,6090
and then my my fork
然后我的 fork 就不能用了，

39
00:01:09,680 --> 00:01:11,690
6120,6570 6570,6810 6810,7350 7560,7920 7920,8130
didn't work anymore,| so then
|所以我就像，之前还是好的，现在怎么不能用了，

40
00:01:11,690 --> 00:01:12,380
8130,8190 8190,8310 8310,8490 8490,8700 8700,8820
I was just like I

41
00:01:12,380 --> 00:01:13,400
8820,9090 9090,9360 9360,9540 9540,9720 9720,9840
did that, how does it

42
00:01:13,400 --> 00:01:14,930
9840,10050 10050,10440 10680,11010 11010,11310 11310,11370
not work,| so spend a
|所以花了很多时间找出我做错了什么。

43
00:01:14,930 --> 00:01:16,250
11370,11580 11580,11670 11670,11940 11940,12360 12360,12690
lot of time figuring out

44
00:01:16,620 --> 00:01:18,000
120,390 390,480 480,750 750,1080 1110,1500
what I did wrong.| And
|我意识到我把那行删除了。

45
00:01:18,060 --> 00:01:19,470
1560,1740 1740,2280 2280,2340 2340,2580 2580,2970
I realized I just deleted

46
00:01:19,470 --> 00:01:20,760
2970,3150 3150,3360 3360,3510 3510,3900
that line from the.|
|

47
00:01:22,820 --> 00:01:24,230
120,270 270,570 570,780 780,1050 1050,1530
Is anybody having trouble hearing
有没有人听不到 Luca ，还是只是我这边。

48
00:01:24,230 --> 00:01:25,250
1530,1920 1920,2010 2010,2190 2190,2310 2310,2550
Luca, is that on my

49
00:01:25,250 --> 00:01:25,880
2550,2940
end.|
|

50
00:01:26,290 --> 00:01:27,130
90,240 240,420 420,570 570,720 720,930
I think its on your
我想是你那边。

51
00:01:27,130 --> 00:01:27,640
930,1170
end.|
|

52
00:01:28,000 --> 00:01:29,160
60,570 570,660 660,960
Yeah I'm fine.|
是的，我这边好的。|

53
00:01:32,290 --> 00:01:33,250
1590,1800 1800,2040 2040,2160 2160,2310 2310,2550
This must be on my
这一定是我这边的问题。

54
00:01:33,250 --> 00:01:34,300
2550,2910
end.|
|

55
00:01:56,320 --> 00:01:57,520
60,360 360,570 570,840 840,1020 1020,1260
Sorry, maybe that'll work better
抱歉，也许现在好了。

56
00:01:57,520 --> 00:01:59,280
1260,1710
now.|
|

57
00:02:02,760 --> 00:02:03,630
120,270 270,360 360,510 510,600 600,990
Can you hear me now,
你现在能听到我说话吗，好的，很好。

58
00:02:04,800 --> 00:02:07,260
2160,2550 2550,3690 3690,3720 3870,4170 4170,4620
okay great.| I was worried
|我还担心我说的。

59
00:02:07,260 --> 00:02:08,550
4620,4920 4920,5100 5100,5190 5190,5520 5520,5910
that I was just talking.|
|

60
00:02:08,550 --> 00:02:10,500
5910,6420 6420,6780 7380,7680 7680,7770 7770,7860
No, no seems to be
不，似乎是我这边的问题。

61
00:02:10,500 --> 00:02:12,260
7860,7980 7980,8190 8190,8490 8760,9360
on my end.| Alright.|
|好的。|

62
00:02:16,870 --> 00:02:19,270
270,1170 1890,2040 2040,2310 2310,2550 2550,2670
Awesome, will anybody else have
太棒了，还有没有人想分享关于 syscall 的任何事情。

63
00:02:19,270 --> 00:02:20,110
2670,2910 2910,3060 3060,3210 3210,3300 3300,3510
anything they'd like to share

64
00:02:20,110 --> 00:02:21,850
3510,3810 3810,4140 4170,4440 4440,5250
about you of syscall.|
|

65
00:02:24,190 --> 00:02:27,010
90,480 480,1170 1170,1890 1890,2310 2730,2910
Anything particularly interesting,| or was
有什么特别有趣的吗，|

66
00:02:27,010 --> 00:02:28,930
2910,3000 3000,3420 3450,3990 3990,4590 4590,4830
the lab absolutely horrendous| and
或者实验太难了，|你觉得我们应该把它从课程上删掉，再也不做了。

67
00:02:28,930 --> 00:02:29,560
4830,4920 4920,5070 5070,5160 5160,5310 5310,5460
you think we should cut

68
00:02:29,560 --> 00:02:30,700
5460,5550 5550,5700 5700,5760 5760,5850 5850,6600
it out of the class,

69
00:02:31,120 --> 00:02:32,400
120,510 510,630 630,720 720,1110
never do it again.|
|

70
00:02:33,430 --> 00:02:36,610
690,900 900,1080 1080,1620 2880,3690
I have something, apparently
我有一些东西，显然事情的顺序很重要，

71
00:02:36,610 --> 00:02:39,100
3690,4320 4320,4680 4680,4800 4800,5460 5490,6180
the order of things matters|
|

72
00:02:39,130 --> 00:02:40,480
6210,6330 6330,6390 6390,6480 6480,6900 6900,7560
which is a general statement,|
这是一个概括性的说明，|

73
00:02:40,780 --> 00:02:43,570
8400,9270 9360,9690 9690,10230 10230,10650
so I tried to
所以我试着理解 syscall 函数内的代码。

74
00:02:43,600 --> 00:02:47,080
10680,11640 11850,12120 12120,12510 12510,13530 13530,14160
determine the mass computation inside

75
00:02:47,080 --> 00:02:48,720
14160,14370 14370,14940 14940,15540
the syscall function.|
|

76
00:02:48,980 --> 00:02:51,050
120,750 750,1320 1320,1650 1650,1800 1800,2190
Before determining whether I actually
在理解之前，我需要先做 traceing 。

77
00:02:51,050 --> 00:02:52,400
2190,2550 2550,2670 2670,2880 2880,2970 2970,3540
needed to do the tracing.|
|

78
00:02:53,100 --> 00:02:54,960
180,420 420,1140 1200,1590 1590,1710 1710,2760
And so all the syscall
所有 syscall 都可能正确跟踪，除了那个 trace call 。

79
00:02:54,960 --> 00:02:57,540
2790,3000 3000,3360 3360,4050 4050,4620
we're getting correctly traced

80
00:02:57,570 --> 00:02:59,500
4650,5340 5370,5580 5580,5850 5850,6300
except that trace call.|
|

81
00:02:59,560 --> 00:03:01,390
120,270 270,420 420,870 900,1380 1380,1950
And I was really getting
我被这事弄得心烦意乱，

82
00:03:01,420 --> 00:03:03,100
1980,2580 2580,2760 2760,3060 3060,3390 3390,3660
disturbed by that,| until I
|直到 David 指出，

83
00:03:03,100 --> 00:03:03,940
3660,3840 3840,3900 3900,4080 4080,4380 4380,4500
think it was David who

84
00:03:03,940 --> 00:03:04,780
4500,4860 4860,5040 5040,5130 5130,5250 5250,5340
pointed out,| you know you
|应该在 trace 之后进行计算。

85
00:03:04,780 --> 00:03:06,340
5340,5460 5460,5580 5580,5640 5640,6240 6240,6900
should do the computation after

86
00:03:06,860 --> 00:03:08,990
120,300 300,630 780,1320 1800,2130 2130,2250
ou should trace.| Just like
|就像，这个很有意思。

87
00:03:08,990 --> 00:03:10,300
2250,2670 2880,3090 3090,3300
{} that's fun.|
|

88
00:03:10,790 --> 00:03:11,540
90,570
Alright,
好的，我很高兴你能捕捉到这一点。

89
00:03:13,150 --> 00:03:14,020
930,1260 1260,1500 1500,1560 1560,1620 1620,1800
I'm glad you were able

90
00:03:14,020 --> 00:03:16,420
1800,1920 1920,2190 2190,2550 3000,3960 3960,4200
to catch that.| Yeah order
|是的，顺序确实很重要，

91
00:03:16,420 --> 00:03:18,460
4200,4410 4410,4830 4860,5850 5850,5970 5970,6240
does matter,| especially for page
特别是对页表来说，你们会发现，顺序在那里也很重要，

92
00:03:18,460 --> 00:03:19,780
6240,6840 6840,7020 7020,7320 7320,7380 7380,7560
tables, you'll find I think

93
00:03:19,780 --> 00:03:21,640
7560,7710 7710,8370 8580,9090 9090,9300 9300,9420
that order matters there| as
|而且在整个课程中都很重要。

94
00:03:21,640 --> 00:03:23,080
9420,9900 9900,10080 10080,10470 10470,10770 10770,10860
well and generally throughout the

95
00:03:23,080 --> 00:03:23,920
10860,11580
class.|
|

96
00:03:24,090 --> 00:03:25,170
90,330 330,720 720,810 810,930 930,1170
Paying attention to the order
注意事物的顺序将是很重要的。

97
00:03:25,170 --> 00:03:26,220
1170,1260 1260,1530 1530,1620 1620,1710 1710,2220
of things will be important.|
|

98
00:03:28,140 --> 00:03:29,370
120,270 270,510 510,600 600,900 900,1350
It's good to not overwrite
最好不要覆盖页表中的内容。

99
00:03:29,370 --> 00:03:30,640
1350,1620 1620,1710 1710,1920 1920,2340
things in page table.|
|

100
00:03:31,630 --> 00:03:33,580
90,240 240,1050 1140,1470 1470,1770 1770,2040
I also had something which
我也有一些东西，实际上我仍然对此感到困惑。

101
00:03:33,580 --> 00:03:34,920
2040,2190 2190,2670 2670,3150
I'm actually still

102
00:03:34,950 --> 00:03:38,100
90,570 570,1110 2100,2700 2700,3240
confused about.| Well I
|我在内核代码中调试用了很多 print 语句。

103
00:03:38,370 --> 00:03:39,750
3510,3900 3900,3960 3960,4170 4170,4410 4410,4890
had a lot of debugging

104
00:03:39,750 --> 00:03:41,490
4890,5580 5580,5970 5970,6060 6060,6180 6180,6630
print statements in the kernel

105
00:03:41,490 --> 00:03:44,700
6630,7140 8010,8670 8700,9030 9030,9540 9540,9840
code.| I then ran the
|然后我把所有的位都设置好，运行 trace

106
00:03:44,700 --> 00:03:46,350
9840,10590 10590,10920 10920,11160 11160,11370 11370,11490
trace thing with all of

107
00:03:46,350 --> 00:03:48,120
11490,11670 11670,12000 12000,12660 13050,13260
the bits set,| so
|所以基本上跟踪所有的系统调用。

108
00:03:48,120 --> 00:03:50,310
13260,13650 13650,14490 14790,14970 14970,15090 15090,15450
basically tracing all the system

109
00:03:50,310 --> 00:03:51,400
15450,15990
calls.|
|

110
00:03:51,520 --> 00:03:52,540
120,930
And,
我想我看到了内核中很多 print 语句的跟踪，

111
00:03:52,870 --> 00:03:55,300
90,330 330,690 690,870 870,2340 2340,2520
I think I saw a

112
00:03:55,300 --> 00:03:57,550
2520,2790 2790,3420 3630,4350 4350,4650 4650,4770
lot of tracing for the

113
00:03:57,550 --> 00:03:59,200
4770,5040 5040,5730 5730,5910 5910,6030 6030,6420
print statements in the kernel,

114
00:03:59,200 --> 00:04:00,240
6420,6600 6600,7080
and then.|
|

115
00:04:00,410 --> 00:04:02,390
90,660 870,1080 1080,1260 1260,1380 1380,2070
Because and then I assumed
因为然后我假设我的 print 程序试图读取和写入控制台，

116
00:04:02,390 --> 00:04:04,430
2070,2460 2460,2790 2790,3330 3360,3720 3720,4110
that my print my print

117
00:04:04,430 --> 00:04:05,960
4110,4680 4680,5490
apps were

118
00:04:06,260 --> 00:04:08,000
120,510 510,900 900,1140 1140,1320 1320,1860
trying to read and write

119
00:04:08,120 --> 00:04:09,980
1980,2130 2130,2250 2250,2970 3000,3570 3570,3840
to the console,| but that
|但这确实会写入控制台，

120
00:04:09,980 --> 00:04:11,030
3840,3990 3990,4200 4200,4290 4290,4410 4410,4890
do write to the console,|
|

121
00:04:11,030 --> 00:04:13,160
4890,5100 5100,5640 5760,6060 6060,6270 6270,7020
but then I was wondering
但我想知道为什么。

122
00:04:13,670 --> 00:04:15,560
90,450 450,660 660,1260 1530,1800 1800,1980
why are we.| I guess,
|我想，我只是感到困惑，为什么我们可以在内核中使用 printf 。

123
00:04:15,560 --> 00:04:16,700
1980,2100 2100,2280 2280,2700 2700,2850 2850,3120
I'm just confused why we're

124
00:04:16,700 --> 00:04:18,320
3120,3540 3540,3660 3660,4170 4170,4740
able to use printf

125
00:04:18,320 --> 00:04:21,280
4740,4830 4830,4950 4950,5610
in the kernel.|
|

126
00:04:22,670 --> 00:04:23,990
210,510 510,630 630,870 870,1170 1170,1530
Yeah I'm not I haven't
我最近没有看过 printf 代码，

127
00:04:23,990 --> 00:04:25,520
1530,1770 1770,1860 1860,2190 2220,3060
looked at the printf

128
00:04:25,550 --> 00:04:27,260
3090,3810 3810,4380 4380,4530 4530,4620 4620,4800
code recently,| but I think
|但是我想有一个 printf.c 文件

129
00:04:27,260 --> 00:04:28,560
4800,4950 4950,5040 5040,5820
there's a file

130
00:04:28,630 --> 00:04:29,860
300,1320
printf.c|
|

131
00:04:29,860 --> 00:04:30,730
1320,1470 1470,1650 1650,1740 1740,1860 1860,2190
you might be a look
你可以看看。

132
00:04:30,730 --> 00:04:31,630
2190,2370 2370,2520 2520,2610 2610,2820 2820,3090
at if you want to.|
|

133
00:04:32,160 --> 00:04:32,920
240,7500
Um,
嗯，这里发生了什么，

134
00:04:34,430 --> 00:04:35,750
270,870 870,1020 1020,1170 1170,1410 1410,1590
here what was going on

135
00:04:35,750 --> 00:04:36,350
1590,1830 1830,1920 1920,1980 1980,2130 2130,2190
there,| so I think the
|我认为 printf 函数应该在那里实现。

136
00:04:36,350 --> 00:04:37,280
2190,2490 2490,2850 2850,3030 3030,3120
printf function should be

137
00:04:37,280 --> 00:04:38,620
3120,3660 3660,3780 3780,4110
implemented in there.|
|

138
00:04:39,530 --> 00:04:39,940
90,330
|
|

139
00:04:41,120 --> 00:04:42,110
120,360 360,570 570,750 750,1020 1020,1110
At least our version of
至少我们的版本是这样的

140
00:04:42,110 --> 00:04:43,430
1110,1320 1530,1860 1860,1980 1980,2130 2130,2430
it,| I don't know perhaps
|我不知道，也许其他人可能知道发生了什么。

141
00:04:43,430 --> 00:04:44,420
2430,2580 2580,2700 2700,3090
one of the

142
00:04:44,650 --> 00:04:45,250
90,300 300,330 330,540 540,600 600,690
what are some of the

143
00:04:45,250 --> 00:04:46,600
690,900 900,1110 1110,1440 1440,1620 1620,2040
other core staff might know.

144
00:04:47,370 --> 00:04:48,420
90,330 330,630 630,840
What's going on.|
|

145
00:04:49,270 --> 00:04:50,800
390,630 630,1140 1200,1740 1740,1860 1860,1920
And the printf in the
在跟踪的时候，内核中的 printf 不应该出现

146
00:04:50,800 --> 00:04:52,720
1920,2250 2250,2610 2610,2850 2850,3240 3240,3840
kernel shouldn't show up, as

147
00:04:52,750 --> 00:04:54,490
3870,4110 4110,4650 4650,5100 5130,5610
your traces,| because printf
|因为内核中的 printf 不调用任何系统调用。

148
00:04:54,490 --> 00:04:55,510
5610,5730 5730,5820 5820,6090 6090,6360 6360,6630
in the kernel doesn't call

149
00:04:55,510 --> 00:04:56,860
6630,6810 6810,7110 7110,7650
any system calls.|
|

150
00:04:58,000 --> 00:04:59,890
120,780 780,1050 1050,1230 1230,1470 1470,2010
Yeah that's what I thought
是啊，我也是这么想的，也许 tracing 不是从那里来的。

151
00:04:59,890 --> 00:05:02,710
2010,2790 3090,3330 3330,3960 4200,4470 4470,4830
maybe that maybe the tracing

152
00:05:02,710 --> 00:05:04,120
4830,4980 4980,5190 5190,5370 5370,5820
was not from that.|
|

153
00:05:04,680 --> 00:05:05,580
180,570 570,660 660,810 810,960 960,1080
Yeah I don't think it
是的，我不认为它来自内核中的 printf 。

154
00:05:05,580 --> 00:05:06,480
1080,1200 1200,1350 1350,1470 1470,1860 1860,1980
is from your printf in

155
00:05:06,480 --> 00:05:07,400
1980,2040 2040,2580
the kernel.|
|好吧。

156
00:05:08,240 --> 00:05:09,560
120,840
Okay.|
|好的，除非有人对SysCall有其他激烈的评论，

157
00:05:12,370 --> 00:05:15,460
810,1650 1800,2430 3000,3300 3300,3690 3690,3900
OK, well unless anybody has

158
00:05:15,460 --> 00:05:18,040
3900,4080 4080,4500 4530,5220 5220,5790 5790,6480
any other burning comments about

159
00:05:18,040 --> 00:05:19,360
6480,6930 6930,7020 7020,7350 7350,7470 7470,7800
syscall,| I think we can
|我想我们可以开始今天的讲座了，

160
00:05:19,630 --> 00:05:22,300
8070,8730 8730,9210 9210,9660 9840,10500 10500,10740
get started with lecture for

161
00:05:22,300 --> 00:05:24,190
10740,11250 11730,12120 12120,12210 12210,12570 12570,12630
today,| I'll be talking a
|我将稍微谈谈将C语言转换为汇编语言和处理器的过程，

162
00:05:24,190 --> 00:05:29,410
12630,12870 12870,13110 13140,14010 15030,15930 16680,17850
little bit about the process

163
00:05:29,410 --> 00:05:31,750
17850,18420 18420,18960 18960,19230 19230,19410 19410,20190
of converting C to assembly

164
00:05:31,750 --> 00:05:33,100
20190,20310 20310,21150 21150,21240 21240,21390 21390,21540
and processors,| and this is
|今天这更多的是一个实用的讲座，或者至少这是我们的目标，

165
00:05:33,100 --> 00:05:35,110
21540,21930 21960,22020 22020,22620 22620,23160 23160,23550
more of a practical lecture

166
00:05:35,110 --> 00:05:36,130
23550,23820 23820,23910 23910,24030 24030,24330 24330,24570
today or at least that's

167
00:05:36,130 --> 00:05:37,270
24570,24720 24720,25080 25080,25320 25320,25440 25440,25710
the aim,| so the goal
|所以这里的目标是让你们都熟悉。RISC-V，

168
00:05:37,270 --> 00:05:39,040
25710,26070 26070,26550 26760,27120 27120,27330 27330,27480
here is to get you

169
00:05:39,040 --> 00:05:41,380
27480,27960 27960,29040 29040,29640
all familiarized with.

170
00:05:41,450 --> 00:05:44,450
990,2190 2190,2310 2310,3090
RISC-V,| the processor,
|介绍了RISC-V的处理器、汇编语言和调用约定。

171
00:05:44,450 --> 00:05:46,790
3090,3210 3210,3690 3690,4500 4500,5010 5010,5430
the assembly language and calling

172
00:05:46,790 --> 00:05:49,340
5430,6390 6390,6750 6750,7500
conventions for RISC-V.|
|这将是非常重要的，

173
00:05:49,340 --> 00:05:50,600
7980,8160 8160,8280 8280,8400 8400,8490 8490,9240
And this will be important

174
00:05:50,600 --> 00:05:52,520
9240,9660 9900,10290 10290,10470 10470,10770 10770,11160
in,| not not super important
|对于页表来说不是特别重要

175
00:05:52,520 --> 00:05:54,560
11160,11310 11310,11580 11580,12030 12030,12480 12480,13200
for page table| but certainly
|但对于本周晚些时候将被指派的陷阱实验室来说肯定是这样的，

176
00:05:54,560 --> 00:05:56,030
13200,13620 13620,13710 13710,14130 14130,14460 14460,14670
for the traps lab which

177
00:05:56,030 --> 00:05:57,620
14670,15150 15210,15450 15450,15570 15570,15990 15990,16260
is will be assigned later

178
00:05:57,620 --> 00:05:58,610
16260,16470 16470,16740 16740,16890 16890,17040 17040,17250
this week,| this will be
|这对于调试和实现东西将是必不可少的，

179
00:05:58,610 --> 00:06:01,700
17250,17790 17790,18240 18360,19380 19380,19740 19740,20340
essential for debugging and implementing

180
00:06:01,700 --> 00:06:03,080
20340,20610 20610,20820 20820,20940 20940,21060 21060,21720
things,| because you'll be working
|因为您将非常密切地使用陷阱框架和堆栈之类的东西，

181
00:06:03,140 --> 00:06:05,300
21780,22110 22110,22680 22680,23130 23130,23430 23430,23940
quite intimately with trap frames

182
00:06:05,300 --> 00:06:06,740
23940,24150 24150,24630 24660,24930 24930,25170 25170,25380
and stack and things like

183
00:06:06,740 --> 00:06:08,450
25380,25800 26130,26400 26400,26640 26640,26880 26880,27090
that,| so that's the that's
|这就是今天的目标。

184
00:06:08,450 --> 00:06:09,140
27090,27240 27240,27300 27300,27390 27390,27660 27660,27780
kind of the goal for

185
00:06:09,140 --> 00:06:10,300
27780,28170 28170,28680
today.| And,
|而且，我的第一个目标是，

186
00:06:10,760 --> 00:06:12,860
120,480 480,840 840,1200 1200,1650 1650,2220
my first aim was to,|
|这可能是从6.004开始的一点回顾

187
00:06:12,950 --> 00:06:13,820
2310,2610 2610,2820 2820,2880 2880,2970 2970,3180
this might be a little

188
00:06:13,820 --> 00:06:15,860
3180,3360 3360,3630 3630,4230 4230,4950 4950,6390
bit of review from 6.004|
|或您过去可能学过的任何其他计算机体系结构主题课程，

189
00:06:15,860 --> 00:06:18,110
6390,7020 7110,7470
or any

190
00:06:18,110 --> 00:06:20,390
7470,7800 7800,8130 8130,8700 8700,9120 9120,9750
other computer architecture theme classes

191
00:06:20,390 --> 00:06:21,200
9750,9900 9900,10020 10020,10140 10140,10260 10260,10560
that you may have taken

192
00:06:21,200 --> 00:06:22,580
10560,10650 10650,10770 10770,11310 11400,11820 11820,11940
in the past,| but I
|但我只想简单回顾一下C语言，

193
00:06:22,580 --> 00:06:24,080
11940,12150 12150,12330 12330,12810 12840,13080 13080,13440
just want to go over

194
00:06:24,080 --> 00:06:26,390
13440,13980 13980,14220 14220,14550 14670,15600 15630,15750
briefly kind of see the

195
00:06:26,390 --> 00:06:28,370
15750,15990 15990,16980 17100,17400 17400,17520 17520,17730
C language,| how we get
|我们是如何进行组装的，也许还有一点关于处理器的知识。

196
00:06:28,370 --> 00:06:30,590
17730,17850 17850,18930 19110,19470 19680,19950
to assembly and maybe

197
00:06:30,590 --> 00:06:32,420
19950,20010 20010,20310 20310,20580 20580,21030 21030,21780
a little bit about processor.|
|所以，在整个过程中，当然在这节课的整个过程中，

198
00:06:32,420 --> 00:06:33,160
21780,22230
So,

199
00:06:33,700 --> 00:06:35,260
300,960 960,1050 1050,1320 1350,1560 1560,1860
throughout, and then of course

200
00:06:35,260 --> 00:06:36,550
1860,2130 2130,2250 2250,2670 2670,2910 2910,3150
throughout this lecture,| feel free
|如果你有任何问题，可以随时打断。

201
00:06:36,550 --> 00:06:38,350
3150,3270 3270,4080 4530,4680 4680,4950
to interrupt with any

202
00:06:38,350 --> 00:06:39,860
4950,5400 5400,5550 5550,5700 5700,6210
questions that you have.|
|所以，你知道，我们在C中有我们正常的主要函数。

203
00:06:41,050 --> 00:06:42,580
90,690 1290,1380 1380,1500 1500,1620
So, you know, we

204
00:06:42,580 --> 00:06:44,380
1620,1770 1770,1920 1920,2520 2520,2820 2820,3420
have our normal main functions

205
00:06:44,380 --> 00:06:45,620
3420,3570 3570,4380
in C.|
|你知道他们会做些什么，也许他们会打印一些东西。然后他们离开了。

206
00:06:45,700 --> 00:06:47,260
120,240 240,450 450,600 600,870 870,1680
You know they do something,

207
00:06:47,260 --> 00:06:49,380
1680,1920 1920,2070 2070,2400 2400,3480
maybe they print something.

208
00:06:49,800 --> 00:06:52,340
1020,1260 1260,1410 1410,2250
then they exit.|
|这一切看起来都很好，

209
00:06:53,680 --> 00:06:55,240
420,630 630,780 780,1020 1020,1590
And this all looks

210
00:06:55,240 --> 00:06:56,620
1980,2220 2220,2400 2400,2790 2790,3150 3150,3360
well and good,| but as
|但正如你们中的任何人从6.004开始就知道的，

211
00:06:56,620 --> 00:06:58,390
3360,3570 3570,3690 3690,4260 4470,4800 4800,5130
any of you are aware

212
00:06:58,390 --> 00:06:59,410
5130,5280 5280,6150
from 6.004,|
|处理器实际上并不理解C语言，

213
00:06:59,410 --> 00:07:02,530
6150,6780 6780,7080 7080,7620 7620,8730 8940,9270
processors don't actually understand the

214
00:07:02,530 --> 00:07:04,690
9270,9480 9480,10020 10020,10410 10410,10830 10830,11430
C language,| rather they understand
|相反，他们理解我们称之为汇编的东西，或者更具体地说，他们理解汇编的二进制编码，

215
00:07:04,690 --> 00:07:06,520
11430,11640 11640,11790 11790,12330 12420,12690 12690,13260
what we call a assembly

216
00:07:06,520 --> 00:07:08,230
13260,13620 13620,13860 13860,14430 14430,14550 14550,14970
or more specifically they understand

217
00:07:08,230 --> 00:07:09,880
14970,15030 15030,15480 15480,15900 15900,16080 16080,16620
the binary encoding of assembly,|
|所以今年我从SiFive板上圈出了一张真正的RISC-V处理器的图片，

218
00:07:10,150 --> 00:07:11,320
16890,17130 17130,17340 17340,17610 17610,17910 17910,18060
and so this year I've

219
00:07:11,320 --> 00:07:13,390
18060,18810 18960,19350 19350,19890 19890,20040 20040,20130
circled a picture of an

220
00:07:13,390 --> 00:07:15,250
20130,20520 20520,21090 21090,21780 21780,21990
actual RISC-V processor from

221
00:07:15,250 --> 00:07:17,230
21990,22050 22050,22680 22680,23160 23250,23970
a SiFive board,| and
|当我们说处理器是RISC-V时，

222
00:07:17,860 --> 00:07:19,270
120,420 420,570 570,810 810,930 930,1530
when we say a processor

223
00:07:19,270 --> 00:07:20,650
1530,1650 1650,2400 2400,2640 2640,2910
is RISC-V,| that means
|这意味着它理解RISC-V指令集，

224
00:07:20,650 --> 00:07:22,450
2910,3090 3090,3240 3240,4080 4080,4320 4320,5280
that it understands the RISC-V

225
00:07:22,450 --> 00:07:25,390
5280,5910 5910,6240 6480,7170 7200,7650
instruction set,| so every
|因此每个处理器具有相关联的ISA或指令。

226
00:07:25,390 --> 00:07:28,060
7650,8400 8400,8580 8580,8700 8700,9480 9480,10320
processor has an associated isa

227
00:07:28,060 --> 00:07:30,700
10320,10980 11580,12720
or instruction.|
|这就是一套说明。

228
00:07:31,010 --> 00:07:32,150
150,330 330,570 570,810 810,900 900,1290
And that's kind of the

229
00:07:32,150 --> 00:07:33,980
1290,1590 1590,1680 1680,2940
set of instructions.|
|这对处理器来说是有意义的，

230
00:07:34,890 --> 00:07:36,240
330,810 810,1110 1110,1410 1410,1500 1500,1680
That makes sense to that

231
00:07:36,240 --> 00:07:38,550
1680,2310 2310,2760 2820,3240 3240,3810 3810,3990
processor,| so every instruction has
|因此，每条指令都有相关的二进制编码或操作码。

232
00:07:38,550 --> 00:07:40,800
3990,4110 4110,4770 4770,5430 5430,6090 6090,6240
an associated binary encoding or

233
00:07:40,800 --> 00:07:42,080
6240,6300 6300,6510 6510,7020
an op code.|
|当处理器运行时

234
00:07:42,480 --> 00:07:44,280
180,360 360,510 510,600 600,1620 1650,1980
And when a processor is

235
00:07:44,280 --> 00:07:45,690
1980,2460 2460,2640 2640,2760 2760,3240 3240,3390
running| and it sees a
|它会看到一种特殊的编码，它知道该怎么做。

236
00:07:45,690 --> 00:07:47,790
3390,4080 4080,4740 4740,4920 4920,5280 5280,5490
particular encoding, it knows what

237
00:07:47,790 --> 00:07:49,600
5490,5550 5550,5940 6240,6540 6540,7020
to do.| And so,
|所以，你知道这块电路板上的处理器碰巧理解RISC-V汇编，这就是c代码要编译成的，

238
00:07:50,240 --> 00:07:51,590
120,270 270,360 360,570 570,1320 1320,1470
you know this processor on

239
00:07:51,590 --> 00:07:54,230
1470,1710 1710,2070 2070,2700 2700,3090 3090,4110
this board happens to understand

240
00:07:54,350 --> 00:07:56,480
4230,4740 4740,5490 5490,6030 6030,6360
the RISC-V assembly which

241
00:07:56,480 --> 00:07:58,100
6360,6810 6840,7140 7140,7350 7350,7800 7800,7980
is what c code is

242
00:07:58,100 --> 00:07:59,600
7980,8550 8550,8790 8790,8940 8940,9060 9060,9480
compiled to,| so the general
|所以让C代码真正在你的处理器上运行的一般过程，

243
00:07:59,600 --> 00:08:01,550
9480,9990 9990,10110 10110,10620 10680,11100 11100,11430
process of getting C code

244
00:08:01,550 --> 00:08:02,750
11430,11520 11520,11910 11910,12270 12270,12480 12480,12630
to actually run on your

245
00:08:02,750 --> 00:08:04,460
12630,13440 13500,13800 13800,13920 13920,14220 14220,14340
processor,| is we start with
|我们从C开始，然后编译成汇编语言，

246
00:08:04,460 --> 00:08:06,200
14340,14850 14910,15150 15150,15330 15330,15930 15930,16080
C, it gets compiled to

247
00:08:06,200 --> 00:08:07,910
16080,16830 16830,16980 16980,17130 17130,17310 17310,17790
assembly,| and there's some linking
|在这一步之间发生了一些联系，诸如此类的事情，

248
00:08:07,910 --> 00:08:09,230
17790,17940 17940,18150 18150,18330 18330,18630 18630,19110
and things like that happened

249
00:08:09,230 --> 00:08:10,550
19110,19440 19440,19530 19530,19830 19830,20010 20010,20430
between this step,| but that's
|但那不是一个编译器类，

250
00:08:10,760 --> 00:08:13,160
20640,21360 21360,21480 21480,21930 21930,22530 22590,23040
not a compilers class,| so
|这样，然后程序集就会被翻译成二进制。

251
00:08:13,160 --> 00:08:14,720
23040,23160 23160,23370 23370,23460 23460,24090 24090,24600
and then the assembly will

252
00:08:14,720 --> 00:08:16,900
24900,25230 25230,25620 25620,26550
then be translated

253
00:08:16,950 --> 00:08:18,750
90,510 510,1260 1260,1440 1440,1650 1650,1890
into binary.| And so this
|这就是你看到的对象或.o文件。

254
00:08:18,750 --> 00:08:21,400
1890,2220 2220,2820 2880,4260
is the object

255
00:08:21,860 --> 00:08:25,340
120,870 900,1680 1680,2790
or .o files

256
00:08:25,450 --> 00:08:26,620
90,300 300,450 450,750 750,1080 1080,1260
that you see.| So if
|因此，如果您在运行make之后注意过实验室目录中的内容，

257
00:08:26,620 --> 00:08:28,480
1260,1410 1410,1650 1650,1830 1830,2460 2460,3120
you've ever paid attention to

258
00:08:29,260 --> 00:08:31,180
3900,4320 4320,4980 4980,5160 5160,5520 5520,5820
what's inside of your lab

259
00:08:31,180 --> 00:08:32,980
5820,6450 6450,6780 6780,6990 6990,7260 7260,7620
directory after you run make,|
|您会看到一堆.o文件散落在各处

260
00:08:32,980 --> 00:08:34,390
8070,8340 8340,8640 8640,8730 8730,9030
you'll see a bunch

261
00:08:34,390 --> 00:08:36,160
9030,9180 9180,9660 9660,10080 10080,10380 10380,10800
of .o files lying around|
|这些是处理器能够理解的实际目标文件。

262
00:08:36,250 --> 00:08:37,150
10890,11100 11100,11310 11310,11340 11340,11430 11430,11790
and those are the actual

263
00:08:37,150 --> 00:08:39,370
11790,12150 12150,12540 12540,12780 12780,13140 13200,14010
object files that the processor

264
00:08:39,370 --> 00:08:40,340
14010,14790
understands.|
|而ASM文件，你们也看到了，

265
00:08:41,030 --> 00:08:42,320
210,390 390,540 540,990 990,1350 1350,1500
And the asm files, you've

266
00:08:42,320 --> 00:08:43,760
1500,1830 1830,2250 2610,2730 2730,2940
also seen,| you haven't
|你还没有写过任何东西，但是如果你回忆起SysCall的话，

267
00:08:43,760 --> 00:08:45,860
2940,3180 3180,3420 3420,3690 3690,4200 4350,5040
really written any, but if

268
00:08:45,860 --> 00:08:47,690
5040,5250 5250,5700 5700,5850 5850,6390 6390,7560
you recall from syscall,| usys.pl
|usys.pl被编译成名为usys.S的文件，

269
00:08:47,690 --> 00:08:49,370
7560,7710 7710,8430 8430,8550
is compiled to

270
00:08:49,370 --> 00:08:51,980
8550,8670 8670,9120 9120,9750 9780,11160
a file called usys.S,|
|因此.S文件是汇编语言，

271
00:08:52,040 --> 00:08:55,100
11220,11490 11490,11670 11670,12270 12270,13200 13440,14280
and so .S files are

272
00:08:55,310 --> 00:08:56,810
14490,14970 14970,15450 15450,15600 15600,15720 15720,15990
assembly language,| and so you've
|所以你已经看到，你肯定已经看到了一些RISC-V组件，如果你把RISC-V组件加倍

273
00:08:56,810 --> 00:08:58,640
15990,16650 16740,16980 16980,17340 17340,17640 17640,17820
seen you've certainly seen some

274
00:08:58,640 --> 00:08:59,780
17820,18270 18270,18750 18750,18870 18870,18960
RISC-V assembly and if

275
00:08:59,780 --> 00:09:01,220
18960,19080 19080,19260 19260,19650 19650,20160 20220,20400
you took double for| I
|我相信您也看过大量的汇编语言。

276
00:09:00,470 --> 00:09:02,510
20400,20760 20760,21330 21330,21690 21690,21930 21930,22020
believe you've also seen a

277
00:09:02,840 --> 00:09:04,610
22020,22140 22140,22440 22440,22560 22560,23040 23070,23790
good amount of assembly language.|
|一般来说，程序集看起来比C语言的结构化程度要低得多，

278
00:09:05,480 --> 00:09:07,820
120,330 330,840 840,1320 1410,1740 1740,2460
An assembly looks in general

279
00:09:07,820 --> 00:09:09,650
2880,3240 3240,3540 3540,4110 4110,4290
much less structured than

280
00:09:09,650 --> 00:09:10,910
4290,4740 4740,4950 4950,5160 5160,5340 5340,5550
C,| so you'll just see
|所以你会看到一行接一行的指令，

281
00:09:10,910 --> 00:09:12,770
5550,6000 6000,6270 6270,6630 6630,6870 6870,7410
line after line after line

282
00:09:12,920 --> 00:09:15,290
7560,8160 8190,9120 9120,9420 9420,9540 9540,9930
of instructions,| you'll see simple
|您将看到一些简单的东西，如添加MULT等等，等等，

283
00:09:15,290 --> 00:09:18,230
9930,10200 10200,10440 10470,11340 11820,12870
things like add mult,

284
00:09:19,440 --> 00:09:21,510
120,1080 1080,1290 1290,1560 1560,2010 2010,2190
etc, and so on and

285
00:09:21,510 --> 00:09:22,770
2190,2460 2460,2880 2880,3030 3030,3150 3150,3450
so forth,| and this doesn't
|这没有，没有很好的控制流，没有循环，

286
00:09:22,770 --> 00:09:26,130
3450,3900 3900,4500 4770,5790 5790,6300 6300,6810
have, no nice control flow,

287
00:09:26,130 --> 00:09:27,990
6810,6990 6990,7170 7170,8100 8130,8400 8400,8670
there's no loops,| there are
|有一些函数，但不是您在C语言中记得的那种意义上的函数，

288
00:09:27,990 --> 00:09:29,070
8670,9210 9210,9330 9330,9540 9540,9660 9660,9750
functions but not in the

289
00:09:29,070 --> 00:09:30,540
9750,10050 10050,10170 10170,10320 10320,10560 10560,11220
sense that you might remember

290
00:09:30,540 --> 00:09:32,220
11220,11400 11400,11820 11820,12000 12000,12240 12240,12900
from C,| we see labels
|我们看到的是标签，而不是真正的函数定义。

291
00:09:32,220 --> 00:09:34,020
12900,13110 13110,13650 13650,13770 13770,14190 14190,14700
as opposed to true function

292
00:09:34,020 --> 00:09:35,360
14700,15780
definitions.|
|

293
00:09:35,440 --> 00:09:35,960
0,60
|
|和汇编语言，所以它是一种低得多的语言

294
00:09:36,500 --> 00:09:37,970
180,360 360,420 420,930 930,1110 1110,1650
And the assembly, so it's

295
00:09:37,970 --> 00:09:39,080
1650,1680 1680,1980 1980,2280 2280,2670 2670,2760
a much lower language| and
|还有很多其他的语言也被编译成汇编语言，

296
00:09:39,080 --> 00:09:39,860
2760,2850 2850,2970 2970,3210 3210,3270 3270,3540
there are plenty of other

297
00:09:39,860 --> 00:09:41,390
3540,3990 3990,4110 4110,4230 4230,4560 4560,5070
languages that are also compiled

298
00:09:41,390 --> 00:09:43,460
5070,5160 5160,5760 5760,6300 6990,7140
to assembly,| so, the
|因此，同样的过程也适用于像C++这样的东西。

299
00:09:43,460 --> 00:09:45,470
7140,7500 7500,7920 7920,8250 8250,8640 8640,9150
same process holds true for

300
00:09:45,470 --> 00:09:47,600
9150,9450 9450,9660 9660,11280
things like C++.|
|嗯，你知道任何一种编译的语言，

301
00:09:47,780 --> 00:09:49,020
11460,12420
Um,

302
00:09:49,600 --> 00:09:50,920
120,240 240,510 510,780 780,1020 1020,1440
you know any any language

303
00:09:50,920 --> 00:09:52,810
1440,1680 1680,2430 2430,2790 2790,3030 3030,3330
that's compiled,| will go to
|将在基地使用相同的汇编语言。

304
00:09:52,810 --> 00:09:54,370
3330,3420 3420,3990 3990,4440 4440,4770 4770,4890
the same assembly language at

305
00:09:54,370 --> 00:09:55,240
4890,4980 4980,5640
the base.|
|这是让我们的计算机真正理解我们正在编写的C代码的基本过程，

306
00:09:56,700 --> 00:09:57,420
120,630
And,

307
00:09:58,080 --> 00:09:59,850
1050,1260 1260,1680 1680,1890 1890,1950
so that's kind of

308
00:09:59,850 --> 00:10:01,470
1950,2070 2070,2520 2520,3060 3060,3180 3180,3570
the basic process of getting

309
00:10:01,470 --> 00:10:04,140
3570,4050 4050,4740 4740,4890 4890,5250 5250,6240
our computer to actually understand

310
00:10:04,380 --> 00:10:05,610
6480,6750 6750,7020 7020,7380 7380,7560 7560,7710
the C code that we're

311
00:10:05,610 --> 00:10:07,620
7710,8310 8520,8760 8760,8940 8940,9360 9360,9720
writing,| but you'll notice that
|但您会注意到，我们指的是RISC-V组件。

312
00:10:07,650 --> 00:10:09,690
10110,10290 10290,10440 10440,11070 11070,11790
we've been referring to

313
00:10:10,110 --> 00:10:12,020
12570,13890
RISC-V

314
00:10:12,330 --> 00:10:14,640
270,1320 1560,2040 2040,2130 2130,2460 2460,2580
assembly.| Throughout the course and
|在整个课程中，处理器都是RISC-V，这是因为，这很重要，因为有许多不同类型的组装，所以您不太可能自己使用RISC-V，

315
00:10:14,640 --> 00:10:16,110
2580,2670 2670,3240 3240,3360 3360,4050
the processor is RISC-V

316
00:10:16,110 --> 00:10:18,090
4050,4170 4170,4440 4440,5160 5970,6030
and that's because, it

317
00:10:18,240 --> 00:10:19,380
6180,6420 6420,6780 6780,6930 6930,7080 7080,7320
it's important because there's many

318
00:10:19,380 --> 00:10:20,940
7320,7650 7650,7890 7890,7980 7980,8490 8490,8880
different kinds of assembly, so

319
00:10:20,940 --> 00:10:23,010
8880,9060 9060,9810 9810,10110 10110,10380 10380,10950
it's unlikely that you're using

320
00:10:23,010 --> 00:10:24,340
10950,12060
RISC-V

321
00:10:24,550 --> 00:10:26,350
30,840 840,990 990,1320 1350,1710 1710,1830
yourself,| like you're not going
|就像你不会在上面运行Linux一样，

322
00:10:26,350 --> 00:10:27,430
1830,1890 1890,2100 2100,2370 2370,2700 2700,2910
to be running Linux on

323
00:10:27,430 --> 00:10:30,070
2910,3150 3840,4860 4860,5190 5190,5550
it,| instead most modern
|相反，大多数现代计算机将在所谓的x86上运行，或者您有时会看到x86-64。

324
00:10:30,070 --> 00:10:32,050
5550,6300 6300,6480 6480,6930 6930,7320 7320,7530
computers will run on what's

325
00:10:32,050 --> 00:10:34,570
7530,7800 7800,8850 8880,9390 9390,9690 9690,10050
called x86 or you'll sometimes

326
00:10:34,570 --> 00:10:36,960
10050,10170 10170,10320 10320,12000
see is x86-64.|
|这是一个不同的ISA，

327
00:10:37,720 --> 00:10:39,250
0,360 360,690 690,1170 1170,1410 1410,1530
And this is this is

328
00:10:39,250 --> 00:10:41,320
1530,1650 1650,2070 2070,2940 3210,3540 3540,3600
a different ISA,| this is
|这是一个不同的指令集，

329
00:10:41,320 --> 00:10:42,490
3600,3690 3690,4020 4020,4470 4470,4650 4650,4770
a different instruction set,| it
|它看起来与RISC-V非常相似

330
00:10:42,490 --> 00:10:43,720
4770,4980 4980,5250 5250,5640 5640,5730 5730,6480
looks pretty similar to RISC-V|
|但这是你经常在你的个人电脑上看到的。

331
00:10:43,720 --> 00:10:45,040
6510,6840 6840,7050 7050,7140 7140,7320
but this is what

332
00:10:45,040 --> 00:10:46,570
7320,7470 7470,7830 7830,8520 8550,8730 8730,8850
you see in kind of

333
00:10:46,570 --> 00:10:48,600
8850,9090 9090,9480 9480,10080 10080,10620
your personal computers often.|
|所以，如果你使用英特尔，那么英特尔CPU实现了x86，我相信AMD。还有，做吧。

334
00:10:51,760 --> 00:10:53,680
120,420 420,540 540,690 690,1620
So if you use

335
00:10:53,680 --> 00:10:56,500
2040,2340 2340,3180 3180,3450 3450,3900 3900,5010
an Intel so Intel CPU's

336
00:10:56,500 --> 00:10:58,780
5010,5520 5520,6630 6870,7020 7020,7140 7140,7590
implement x86 and I believe

337
00:10:58,780 --> 00:11:00,240
7590,8400
AMD.

338
00:11:00,380 --> 00:11:04,010
120,540 540,960 1830,2550 3060,3300 3300,3750
also, do.| And this is
|这是

339
00:11:04,130 --> 00:11:05,040
3870,4320
|
|两者之间相对重要的区别它们并不像乍看起来那么相似

340
00:11:05,100 --> 00:11:07,590
120,750 750,1620 1620,2190 2190,2520 2520,2610
relatively important distinction between the

341
00:11:07,590 --> 00:11:08,550
2610,2820 2820,2940 2940,3210 3210,3450 3450,3570
two they're not quite as

342
00:11:08,550 --> 00:11:10,050
3570,3990 3990,4140 4140,4260 4260,4500 4500,5070
similar as they may look

343
00:11:10,080 --> 00:11:12,420
5100,5610 5610,6270 6420,6900 6900,7200 7200,7440
at first| and that comes
|这归结于这样一个事实，RISC-V就是我们所说的RISC，

344
00:11:12,420 --> 00:11:13,530
7440,7680 7680,7770 7770,7920 7920,8250 8250,8550
down to the fact that

345
00:11:13,530 --> 00:11:14,730
8550,9330 9330,9450 9450,9630 9630,9750
RISC-V is what we

346
00:11:14,730 --> 00:11:17,250
9750,10440 10650,11130 11130,11430 11580,12150 12150,12270
call as a risc,| the
|RISC-V的RISC部分指的是精简指令集。

347
00:11:17,250 --> 00:11:18,660
12270,12630 12630,12840 12840,12960 12960,13680
risc part of RISC-V

348
00:11:18,660 --> 00:11:21,660
13680,14250 14250,14850 15060,15420 15420,16050 16050,16680
refers to a reduced instruction

349
00:11:21,660 --> 00:11:22,260
16680,17010
set.|
|x86-64是所谓的CISC或复杂指令。

350
00:11:22,710 --> 00:11:25,740
210,840 1380,2940 2940,3240
And x86-64 is

351
00:11:25,740 --> 00:11:27,900
3240,3450 3450,3990 3990,4140 4140,5400
what's called a CISC

352
00:11:27,930 --> 00:11:31,040
5430,6330 6750,7440 7440,8160
or complex instructions.|
|这里有几个关键的不同之处，

353
00:11:34,570 --> 00:11:37,180
90,840 990,1230 1230,1320 1320,1890 1890,2700
And there's a couple of

354
00:11:37,180 --> 00:11:38,860
2700,2910 2910,3480 3480,3780 3780,4140 4140,4380
key differences here,| one is
|其中之一就是x86-64中存在的指令数量

355
00:11:38,860 --> 00:11:40,270
4380,4620 4620,4680 4680,5070 5070,5160 5160,5790
just the number of instructions

356
00:11:40,270 --> 00:11:42,070
5790,5940 5940,6060 6060,6570 6570,6930 6930,8160
that are present in x86-64|
|事实上，创作RISC-V的最大动机之一就是我们实际上有多少指令。

357
00:11:42,070 --> 00:11:43,240
8160,8280 8280,8520 8520,8640 8640,8760
in fact one of

358
00:11:43,240 --> 00:11:46,360
8760,8880 8880,9150 9150,10260 10290,11160 11160,11880
the big motivations for writing,

359
00:11:46,420 --> 00:11:48,910
12660,13500 13500,13770 13770,14190 14190,14970
for for making RISC-V

360
00:11:48,910 --> 00:11:52,060
15090,15750 15750,16470 16680,17400
was how many

361
00:11:52,060 --> 00:11:54,420
17580,18270 18270,18810 18810,19140 19140,19740
instructions, we actually have.|
|在情报手册里，有三本完整的书供参考。

362
00:11:54,940 --> 00:11:56,290
300,510 510,690 960,1470
in the intel

363
00:11:56,320 --> 00:11:58,060
1500,1740 1740,1800 1800,2580 2670,3030 3030,3240
kind of handbook, so for

364
00:11:58,060 --> 00:12:00,760
3240,3900 3900,4320 4320,4740 4740,5190 5190,5940
reference, there's three full books.|
|包括ISA和一些统计数据，

365
00:12:02,150 --> 00:12:05,450
210,900 960,1920 1920,2100 2100,2880 2880,3510
That encompass the ISA and

366
00:12:05,600 --> 00:12:08,180
3660,3990 3990,4830 4830,5010 5010,5280 5280,6240
some statistics,| I think there's
|我想新的说明书是以每月三个说明书的速度增加的。

367
00:12:08,270 --> 00:12:10,610
6330,7140 7140,7830 7830,7980 7980,8130 8130,8670
new instructions have been added

368
00:12:10,610 --> 00:12:14,060
8670,9270 9480,9810 9810,10320 10350,11280 11490,12120
at a rate of three

369
00:12:14,060 --> 00:12:15,720
12120,13650
instructions

370
00:12:15,940 --> 00:12:17,720
870,1110 1110,1740
per month.|
|自从添加了x86-64之后，它最早是在七十年代发布的，

371
00:12:18,720 --> 00:12:21,420
60,810 840,2040 2040,2190 2190,2760
Since x86-64 was added,

372
00:12:21,420 --> 00:12:23,400
2760,2850 2850,3540 3600,4020 4020,4560 4560,4740
it was first published in

373
00:12:23,400 --> 00:12:25,410
4740,4830 4830,5370 5370,5730 5730,6120 6120,6750
the seventies,| so I believe
|所以我相信大概有15000多条指示。在x86-64中。

374
00:12:25,410 --> 00:12:27,300
6750,6990 6990,7200 7200,7560 7560,7920
there's like north of

375
00:12:27,300 --> 00:12:29,660
8640,9690 9690,10800
15,000 instructions.

376
00:12:31,330 --> 00:12:33,360
90,540 540,1890
in x86-64.|
|而RISC-V则相反，

377
00:12:34,240 --> 00:12:35,500
420,870 870,1470 1470,1590 1590,1680
And RISC-V on the

378
00:12:35,500 --> 00:12:37,460
1680,1950 1950,2580
other hand,|
|RISC-V的程序集可以很好地包含在两个文档中。

379
00:12:37,570 --> 00:12:38,860
90,270 270,720 720,840 840,1080
the assembly for RISC-V

380
00:12:38,860 --> 00:12:40,240
1380,1500 1500,1590 1590,1980 1980,2460 2460,2760
can be nicely contained within

381
00:12:40,240 --> 00:12:42,200
2760,2970 2970,3690 3690,3840 3840,4200
two documents.| And so,
|所以，在某种程度上，

382
00:12:42,640 --> 00:12:43,750
480,750 750,960 960,1020 1020,1350 1350,1590
a kind of going off

383
00:12:43,750 --> 00:12:45,490
1590,1710 1710,2160 2250,2550 2550,2820 2820,3330
of that,| we don't expect
|我们不希望你们在这门课上记住每一条RISC-V指令，

384
00:12:45,490 --> 00:12:47,050
3330,3780 3780,3930 3930,4080 4080,4530 4530,4890
you in this course to

385
00:12:47,050 --> 00:12:49,390
4890,5790 5790,6060 6060,6570 6570,7230
memorize every single RISC-V

386
00:12:49,390 --> 00:12:51,640
7230,8070 8130,8700 8700,8850 8850,9060 9060,9480
instruction,| but if you are
|但是如果你感兴趣，或者你发现自己被一条具体的指令是什么或做了什么弄糊涂了，

387
00:12:51,640 --> 00:12:53,020
9480,10170 10170,10320 10320,10470 10470,10680 10680,10860
interested or you ever find

388
00:12:53,020 --> 00:12:54,190
10860,11220 11220,11670 11670,11760 11760,11940 11940,12030
yourself confused by what a

389
00:12:54,190 --> 00:12:57,250
12030,12480 12480,13290 13680,14160 14160,14370 14370,15090
specific instruction is or does,|
|如果您访问课程网站，我们会在“参考”选项卡下查看。

390
00:12:57,550 --> 00:12:58,660
15390,15750 15750,16080 16080,16230 16230,16320 16320,16500
if you go to the

391
00:12:58,660 --> 00:13:00,610
16500,16860 16860,17550 17790,18120 18120,18240 18240,18450
course website and we look

392
00:13:00,610 --> 00:13:02,840
18450,18930 18930,19320 19320,19920 19920,20550
under the references tab.|
|在RISC-V下，我们为您提供特权和非特权指令集的链接，

393
00:13:03,460 --> 00:13:04,780
120,540 540,1170 1170,1260 1260,1440
Under RISC-V we give

394
00:13:04,780 --> 00:13:06,040
1440,1590 1590,1710 1710,2100 2100,2370 2370,2700
you the links to both

395
00:13:06,040 --> 00:13:09,550
2700,2970 2970,3840 3930,4590 4590,5640 5640,6210
the privileged and unprivileged instruction

396
00:13:09,550 --> 00:13:11,260
6210,6720 6960,7380 7380,7620 7620,7740 7740,7920
sets,| so this is kind
|所以这是某种程度上的文件。

397
00:13:11,260 --> 00:13:12,840
7920,8040 8040,8160 8160,9210
of the document.|
|这给了你一大堆关于ISA的信息

398
00:13:12,870 --> 00:13:14,850
90,720 1200,1590 1590,1710 1710,1770 1770,2070
That gives you a whole

399
00:13:14,850 --> 00:13:16,020
2070,2340 2340,2430 2430,2940 2940,3150 3150,3240
bunch of information about the

400
00:13:16,020 --> 00:13:17,520
3240,3930 4020,4260 4260,4410 4410,4620 4620,4740
ISA| but you'll note that
|但是你会注意到像这样有240页，而这有135页，

401
00:13:17,520 --> 00:13:20,340
4740,4980 4980,5160 5160,5430 5430,6450 6450,7560
like this is 240 pages,

402
00:13:20,490 --> 00:13:22,800
7710,8220 8220,8400 8400,8460 8550,9600 9600,10020
and this is 135 pages,|
|所以它比x86指令集小得多，

403
00:13:22,800 --> 00:13:25,200
10020,10140 10140,10260 10260,11100 11100,11730 11730,12420
so it's significantly significantly smaller

404
00:13:25,230 --> 00:13:28,290
12450,13230 13770,13950 13950,14880 14910,15510
than the x86 instruction

405
00:13:28,290 --> 00:13:29,550
15510,15810 15840,16110 16110,16260 16260,16410 16410,16770
set,| that's one of the
|这是RISC-V的优点之一，

406
00:13:29,550 --> 00:13:31,500
16770,17070 17070,17370 17370,17910
nice things about,

407
00:13:31,860 --> 00:13:34,500
240,660 660,1440 1710,2460 2640,2880
about RISC-V,| so we
|因此，在RISC-V中，我们的指令较少

408
00:13:34,500 --> 00:13:35,620
2880,3780
have

409
00:13:36,120 --> 00:13:37,560
120,330 330,930 930,1050 1050,1560
in RISC-V we have

410
00:13:37,560 --> 00:13:40,350
2280,2790 2790,3960 3960,4170 4170,4350
fewer instructions| and not
|不仅说明更简单。

411
00:13:40,350 --> 00:13:41,720
4350,4620 4620,5160
only that

412
00:13:42,050 --> 00:13:43,960
90,270 270,930 930,1050 1050,1770
the instructions are simpler.|
|所以，我这么说的意思是。

413
00:13:44,340 --> 00:13:45,360
120,930
So,

414
00:13:45,860 --> 00:13:46,940
120,390 390,450 450,690 690,840 840,1200
what I mean by that

415
00:13:46,940 --> 00:13:47,940
1200,1350 1350,1800
is that.|
|在x86-64中有许多指令是通过指令实现的，它们指的是加法或乘法SUB之类的指令。

416
00:13:48,800 --> 00:13:51,320
60,330 330,450 450,720 720,1800 2070,2580
There are many instructions in

417
00:13:51,320 --> 00:13:53,150
2580,3690 3690,3840 3840,4260 4260,4410
x86-64 by instruction, that

418
00:13:53,150 --> 00:13:54,350
4410,4740 4740,4830 4830,5130 5130,5340 5340,5610
referring to something like add

419
00:13:54,350 --> 00:13:56,760
5610,5700 5700,6180 6180,6690
or mul sub.|
|在x86-64中，有很多指令，它们做的不仅仅是一件事，

420
00:13:57,020 --> 00:13:58,640
120,270 270,1260 1260,1470 1470,1740
In x86-64, there's plenty

421
00:13:58,640 --> 00:14:00,350
1740,1860 1860,2580 2580,2820 2820,3150 3150,3450
of instructions, that do more

422
00:14:00,350 --> 00:14:01,790
3450,3600 3600,3900 3900,4290 4290,4590 4590,4890
than one thing,| so they
|所以他们会执行一些复杂的操作，然后给出结果

423
00:14:01,790 --> 00:14:04,640
4890,5370 5370,5670 5670,6810 7350,7740
perform some complicated set

424
00:14:04,640 --> 00:14:06,140
7740,7860 7860,8760 8760,8850 8850,9000 9000,9240
of operations and then gets

425
00:14:06,140 --> 00:14:07,910
9240,9720 9750,9990 9990,10530 10530,10680 10680,11010
you the result| and that's
|RISC-V RISC-V指令的范围往往较小，但情况并非如此

426
00:14:07,910 --> 00:14:09,590
11010,11970 11970,12060 12060,12300 12300,12450 12450,13080
not the case with RISC-V

427
00:14:09,590 --> 00:14:11,960
13260,14070 14070,14790 14790,15060
RISC-V instructions tend

428
00:14:11,960 --> 00:14:13,490
15060,15180 15180,15540 15540,16050 16050,16140 16140,16590
to be smaller in scope|
|因此他们用更少的笔记周期来运行每条指令，

429
00:14:13,490 --> 00:14:14,570
16590,16710 16710,16800 16800,16890 16890,17250 17340,17670
and so they take notes

430
00:14:14,570 --> 00:14:15,980
17670,17910 17910,18360 18360,18510 18510,18840 18840,19080
less cycles to run each

431
00:14:15,980 --> 00:14:18,530
19080,19920 20010,20370 20370,20580 20580,21360
instruction,| then maybe x86-64
|那么也许x86-64就是，这只是设计者选择承担的一种权衡。

432
00:14:18,530 --> 00:14:19,640
21360,21960 22050,22260 22260,22440 22440,22530 22530,22740
is and this is just

433
00:14:19,640 --> 00:14:21,110
22740,22830 22830,23340 23340,23490 23490,23580 23580,24210
a trade-off that the designers

434
00:14:21,110 --> 00:14:23,000
24210,24540 24540,25020 25050,25320 25320,25380 25380,26100
chose to chose to undertake.|
|没有什么或者你知道没有规范的理由

435
00:14:23,270 --> 00:14:24,980
26910,27120 27120,27780
There's nothing

436
00:14:25,520 --> 00:14:26,840
120,330 330,480 480,600 600,810 810,1440
or you know there's no

437
00:14:28,320 --> 00:14:30,510
300,1170 1170,1620 1620,1920 1920,2040 2040,2490
canonical reason| why a reduced
|为什么精简指令集比复杂的归纳指令集更好，

438
00:14:30,510 --> 00:14:32,820
2490,3090 3090,3540 3540,3720 3720,4170 4170,4800
instruction set is better than

439
00:14:32,850 --> 00:14:34,980
4830,4980 4980,5460 5580,5760 5760,6360 6360,6960
you know a complex induction

440
00:14:34,980 --> 00:14:36,750
6960,7770 7770,8070 8070,8280 8280,8520 8520,8730
instruction set,| they each have
|它们各有其用途，以此类推

441
00:14:36,750 --> 00:14:39,390
8730,8940 8940,9330 9330,10170 11010,11190 11190,11370
their own uses, and so

442
00:14:39,390 --> 00:14:40,260
11370,11460 11460,11550 11550,11760 11760,12090 12090,12240
on and so forth| and
|与x86相比，RISC-V还有一个很酷的地方，那就是它是开源的。

443
00:14:40,260 --> 00:14:41,850
12240,12840 12840,13170 13170,13320 13320,13590 13590,14220
another cool thing about RISC-V

444
00:14:41,850 --> 00:14:44,400
14220,14400 14400,14880 14880,15270 15510,16380
as opposed to x86

445
00:14:44,400 --> 00:14:45,720
16380,16590 16590,17010 17400,17550 17550,17700
is that, this is

446
00:14:45,720 --> 00:14:47,160
17700,17940 17940,18630
open source.|
|因此，市面上仅有的开源指令集之一，

447
00:14:47,740 --> 00:14:50,470
60,810 990,1200 1200,1320 1320,1860 2310,2790
So one of the only

448
00:14:50,470 --> 00:14:53,080
2790,3150 3150,4020 4050,4680 4680,5190 5190,5400
open source instruction sets on

449
00:14:53,080 --> 00:14:54,130
5400,5460 5460,5940 5940,6090 6090,6210 6210,6450
the market,| so that means
|这意味着任何人都可以为RISC-V开发电路板

450
00:14:54,130 --> 00:14:55,690
6450,6900 6900,7080 7080,7500 7500,7590 7590,8010
anybody can develop a board

451
00:14:55,690 --> 00:14:57,520
8010,8190 8190,9000 9690,9840
for RISC-V| and
|它来自加州大学伯克利分校的一个研究项目，这就是RISC-V开始的地方

452
00:14:57,520 --> 00:14:58,570
9840,10380 10380,10620 10620,10710 10710,10800 10800,10890
it came out of a

453
00:14:58,570 --> 00:15:01,570
10890,11340 11340,12000 12000,12720 12840,13380 13380,13890
research project from UC Berkeley

454
00:15:01,570 --> 00:15:02,500
13890,14070 14070,14220 14220,14550 14550,14730 14730,14820
and so that's kind of

455
00:15:02,500 --> 00:15:04,270
14820,15120 15120,15300 15300,15600 15600,16170 16260,16590
where was RISC-V started| and
|从那时起，它得到了许多公司的支持和支持，

456
00:15:04,270 --> 00:15:05,260
16590,16800 16800,16980 16980,17130 17130,17280 17280,17580
since then it's been picked

457
00:15:05,260 --> 00:15:06,460
17580,17730 17730,17850 17850,18360 18360,18660 18660,18780
up and supported by a

458
00:15:06,460 --> 00:15:08,260
18780,19080 19080,19170 19170,20130 20460,20580
number of companies,| you
|你可以在网上找到这个列表，但是确实有很多大公司对支持开放指令集感兴趣。

459
00:15:08,260 --> 00:15:09,640
20580,20730 20730,21030 21030,21090 21090,21360 21360,21960
can find the list online

460
00:15:09,640 --> 00:15:10,540
21960,22080 22080,22260 22260,22530 22530,22770 22770,22860
but yeah there's tons of

461
00:15:10,540 --> 00:15:11,770
22860,23010 23010,23400 23400,23550 23550,23640 23640,24090
big companies that are interested

462
00:15:11,770 --> 00:15:13,270
24090,24180 24180,24600 24600,24720 24720,25170 25290,25590
in supporting an open a

463
00:15:13,270 --> 00:15:14,500
25590,26250 26250,26610
instruction set.|
|事实上，我认为最近SiFive宣布了一项

464
00:15:14,990 --> 00:15:16,400
150,330 330,900 930,1140 1140,1290 1290,1560
And actually I think quite

465
00:15:16,400 --> 00:15:17,810
1560,2010 2010,2130 2130,2340 2340,2430 2430,2970
recently there was an announcement

466
00:15:17,810 --> 00:15:19,820
2970,3330 3330,3810 3810,4620 4620,4980
made by SiFive| who
|他们可以说是RISC-V处理器的首屈一指的电路板制造商

467
00:15:19,820 --> 00:15:20,820
4980,5640
are

468
00:15:21,150 --> 00:15:22,740
30,420 420,510 510,630 630,1320 1320,1620
sort of the premier board

469
00:15:22,740 --> 00:15:25,110
1620,2430 2430,2550 2550,3090 3090,3990
manufacturer for RISC-V processors|
|他们将发布一款个人电脑板，该电路板将广泛采用RISC-V处理器，旨在为个人电脑运行Linux

470
00:15:25,260 --> 00:15:27,150
4140,4500 4500,4680 4680,5070 5070,5400
that they will be

471
00:15:27,150 --> 00:15:30,180
6030,6870 6870,7500 7680,8310 8310,8640 8640,9060
releasing a board for personal

472
00:15:30,180 --> 00:15:32,280
9060,9660 9660,9960 9960,10200 10200,10890 10890,11160
computers that should extensively a

473
00:15:32,280 --> 00:15:34,170
11160,11550 11550,12180 12180,12690 12690,12810 12810,13050
RISC-V processor designed to run

474
00:15:34,170 --> 00:15:36,060
13050,13350 13350,13500 13500,13830 13830,14460 14730,14940
Linux for personal computers| and
|我认为这是在过去一两周内发布的，也就是关于这件事的声明。

475
00:15:36,060 --> 00:15:37,680
14940,15030 15030,15390 15390,15870 15900,16170 16170,16560
I think that's been released

476
00:15:37,680 --> 00:15:38,580
16560,16650 16650,16740 16740,17130 17130,17340 17340,17460
in the last week or

477
00:15:38,580 --> 00:15:40,230
17460,17760 17760,18210 18210,18660 18660,18930 18930,19110
two, the announcement about it.|
|所以如果你很好奇是否发现了自己，你绝对知道我想在完成6.S081之后使用RISC-V，

478
00:15:40,530 --> 00:15:41,670
19770,20040 20040,20190 20190,20430 20430,20550
So if you're if

479
00:15:41,670 --> 00:15:43,410
20550,20670 20670,21180 21180,21300 21300,21690 21930,22290
you're curious if your find

480
00:15:43,410 --> 00:15:45,000
22290,22680 22680,22740 22740,22860 22860,23670 23670,23880
yourself you know absolutely I

481
00:15:45,000 --> 00:15:46,080
23880,24090 24090,24150 24150,24390 24390,24960
want to use RISC-V

482
00:15:46,080 --> 00:15:47,580
24960,25320 25320,25410 25410,25800 25800,26970
after I finish 6.S081,|
|希望到那时能有处理器可用，您可以在自己的计算机上运行Linux。

483
00:15:47,580 --> 00:15:49,410
27000,27690 27690,27840 27840,28050 28050,28290
hopefully by that time

484
00:15:49,410 --> 00:15:50,850
28290,28410 28410,28530 28530,28860 28860,29070 29070,29730
there will be a processor

485
00:15:50,850 --> 00:15:51,900
29730,30210 30210,30330 30330,30420 30420,30570 30570,30780
available that you can run

486
00:15:51,900 --> 00:15:53,520
30780,31080 31080,31530 31530,31680 31680,31830 31830,32400
Linux on your own computer.|
|但是即使在你的日常生活中，你最有可能使用的是精简的指令集，即使你没有意识到这一点，

487
00:15:55,080 --> 00:15:56,340
120,450 450,750 750,840 840,960 960,1380
But even in your day-to-day

488
00:15:56,340 --> 00:15:58,440
1380,1860 1860,1980 1980,2280 2280,2940 2970,3480
lives you're most likely using

489
00:15:58,440 --> 00:16:00,480
3480,3870 3870,4440 4440,4830 4830,5340 5340,5520
reduced instruction set even if

490
00:16:00,480 --> 00:16:01,920
5520,5640 5640,5850 5850,6300 6300,6450 6450,6960
you don't realize it,| so
|所以手臂组件，这就是A R M。

491
00:16:01,980 --> 00:16:03,580
7020,7710
the

492
00:16:03,740 --> 00:16:05,810
120,390 390,930 930,1350 1350,1950 1980,2190
ARM assembly, so that's A

493
00:16:05,810 --> 00:16:06,980
2190,2610 2610,3090
R M.|
|这也是精简的指令集。

494
00:16:07,000 --> 00:16:08,860
0,360 360,510 510,1140 1140,1440 1440,1860
This is also a reduced

495
00:16:08,860 --> 00:16:10,100
1860,2370 2370,2850
instruction set.|
|ARM由高通公司实现。

496
00:16:11,030 --> 00:16:14,510
450,1020 1020,1500 1500,2190 2190,3090 3090,3930
And ARM is implemented by

497
00:16:14,540 --> 00:16:15,800
3960,5010
Qualcomm.|
|骁龙系列处理器，

498
00:16:16,030 --> 00:16:17,740
150,570 570,660 660,1350 1350,1740 1740,1860
The the snapdragon series of

499
00:16:17,740 --> 00:16:19,810
1860,2910 3180,3450 3450,3600 3600,3750 3750,3930
processors,| so if you have
|所以如果你有一部安卓手机。您最有可能运行的是精简的指令集。

500
00:16:19,810 --> 00:16:21,360
3930,4050 4050,4560 4560,5250
an android phone.

501
00:16:22,740 --> 00:16:26,260
120,810 810,1740 2070,2580 2580,3420
You are most likely

502
00:16:26,790 --> 00:16:29,430
90,720 720,960 960,1530 1530,2250 2250,2730
running a reduced instruction set.|
|即使你用的是iOS，我想我也忘了它叫什么了，

503
00:16:30,200 --> 00:16:31,190
300,570 570,780 780,870 870,1020 1020,1290
And even if you're using

504
00:16:31,190 --> 00:16:34,370
1290,2100 2250,3810 3810,3900 3900,4290 4320,4470
ios, ios I think I

505
00:16:34,370 --> 00:16:35,150
4470,4740 4740,4860 4860,4950 4950,5130 5130,5250
forget what the name of

506
00:16:35,150 --> 00:16:36,800
5250,5640 5640,5790 5790,6150 6150,6390 6390,6900
it,| but Apple has some,
|但是苹果有一些，有一些版本的ARM，他们也在他们自己的处理器上实现，这些处理器运行在iPad，iPhone和大多数移动苹果设备上，

507
00:16:37,980 --> 00:16:40,320
120,390 390,660 660,1350 1350,2100 2100,2460
has some version of ARM,

508
00:16:40,320 --> 00:16:41,670
2460,2730 2730,3060 3060,3540 3540,3660 3660,3810
they also implement in their

509
00:16:41,670 --> 00:16:43,770
3810,3990 3990,4920 4950,5310 5310,5550 5550,5910
own processors that runs on

510
00:16:43,770 --> 00:16:46,890
5910,6750 6750,7590 7590,8100 8100,8550 8640,9030
ipads iphones and most mobile

511
00:16:46,890 --> 00:16:49,290
9030,9240 9240,9870 10080,10440 10440,11010 11010,11430
Apple devices,| so reduced instruction
|所以精简的指令集随处可见，

512
00:16:49,290 --> 00:16:50,430
11430,11700 11700,11880 11880,12210 12210,12390 12390,12570
sets are present all over

513
00:16:50,430 --> 00:16:51,210
12570,12690 12690,13020 13020,13140 13140,13230 13230,13350
the place,| and if you're
|如果你在现实世界中寻找RISC-V。你知道，在你的QEMU之外，

514
00:16:51,210 --> 00:16:53,100
13350,13680 13680,14280 14310,14640 14640,14910
looking for a RISC-V

515
00:16:53,100 --> 00:16:54,440
15240,15330 15330,15420 15420,15690 15690,16320
in the real world.

516
00:16:54,870 --> 00:16:56,010
480,600 600,690 690,1110 1110,1230
You know outside of

517
00:16:56,010 --> 00:16:57,460
1230,1440 1440,2400
your QEMU,|
|你可以在类似的集成设备中找到这一点。

518
00:16:58,170 --> 00:16:59,100
270,510 510,600 600,810 810,900 900,1200
you'll be able to find

519
00:16:59,100 --> 00:17:03,120
1200,1650 1650,2280 2520,3570 3690,4290 4290,5220
that in like integrated devices.|
|所以它是存在的，它当然不像x86-64那样无处不在，但它是，嗯。

520
00:17:03,890 --> 00:17:05,570
90,450 450,660 660,870 870,1470 1500,1770
So it is present, it's

521
00:17:05,570 --> 00:17:07,130
1770,2040 2040,2430 2430,2880 2880,3120 3120,3330
not as certainly not as

522
00:17:07,130 --> 00:17:09,290
3330,4050 4050,4290 4290,4620 4620,4830 4830,6270
ubiquitous as something like x86-64

523
00:17:09,290 --> 00:17:12,120
6330,6720 6720,7470 7470,8010
but it's, um.|
|是的，我认为苹果是，就像卢卡斯刚才说的，我认为苹果正在将Max转移到ARM。

524
00:17:12,540 --> 00:17:14,040
120,480 480,960 990,1350 1350,1470 1470,1620
Yes I yes I think

525
00:17:14,040 --> 00:17:15,900
1620,1920 1920,2370 2400,2700 2700,3210 3210,3480
Apple is, as Lucas just

526
00:17:15,900 --> 00:17:16,920
3480,3720 3720,3810 3810,4020 4020,4320 4320,4500
said I think Apple is

527
00:17:16,920 --> 00:17:17,720
4500,5040
moving

528
00:17:17,740 --> 00:17:19,390
60,660 660,990 990,1320 1320,1410 1410,1710
max to ARM.| I believe
|我相信情况也是如此，去年确实有一股精简指令集的热潮。

529
00:17:19,390 --> 00:17:20,950
1710,1920 1920,2160 2160,2280 2280,2730 2880,3270
that's also the case, there's

530
00:17:20,950 --> 00:17:22,300
3270,3510 3510,3660 3660,3960 3960,4320 4320,4620
been in last year's definitely

531
00:17:22,300 --> 00:17:23,620
4620,4710 4710,4800 4800,5130 5130,5610 5610,5940
been a push towards reduced

532
00:17:23,620 --> 00:17:25,660
5940,6450 6450,6960
instruction sets.|
|鉴于Intel ISA已经变得如此之大，以及Intel ISA如此之大的原因

533
00:17:25,960 --> 00:17:27,790
120,720 750,1080 1080,1470 1470,1770 1770,1950
Given given how big the

534
00:17:27,790 --> 00:17:29,530
1950,2310 2310,2790 2790,2940 2940,3450
Intel ISA has gotten

535
00:17:29,530 --> 00:17:30,610
3690,3810 3810,3900 3900,4170 4170,4380 4380,4770
and the reason why Intel

536
00:17:30,610 --> 00:17:31,690
4770,5160 5160,5280 5280,5490 5490,5730 5730,5850
ISA is so big| is
|是因为他们非常关心向后兼容性，

537
00:17:31,690 --> 00:17:33,910
5850,6090 6090,6510 7320,7680 7680,8070
because they're very concerned

538
00:17:33,910 --> 00:17:35,800
8070,8190 8190,8580 8580,9390 9390,9780 9780,9960
with backwards compatibility,| so if
|因此，如果您编写的现代英特尔处理器可以运行与3040年前编写的英特尔代码相同的指令，

539
00:17:35,800 --> 00:17:36,760
9960,10110 10110,10620
you write

540
00:17:36,870 --> 00:17:38,880
360,480 480,960 960,1440 1440,2100
a modern Intel processor

541
00:17:38,880 --> 00:17:41,100
2100,2280 2280,2730 2730,2850 2850,3240 3240,4320
can run the same instructions

542
00:17:41,130 --> 00:17:42,990
4350,4920 4950,5340 5340,5730 5730,6120 6120,6210
that Intel code from you

543
00:17:42,990 --> 00:17:45,270
6210,6420 6540,7410 7410,7650 7650,7980 7980,8490
know 3040 years ago was

544
00:17:45,300 --> 00:17:46,380
8520,8700 8700,8940 9300,9510 9510,9600
was written,| so they
|因此它们并不真正弃用任何指令，以保持向后兼容性，

545
00:17:46,380 --> 00:17:48,300
9600,9900 9900,10110 10110,10710 10710,10890 10890,11520
don't really deprecate any instructions

546
00:17:48,300 --> 00:17:49,440
11520,11610 11610,11700 11700,11820 11820,12270 12270,12660
so that they maintain backwards

547
00:17:49,440 --> 00:17:51,240
12660,13500 13620,13920 13920,14340 14340,14460
compatibility,| that RISC-V is
|RISC-V更现代，所以不用担心RISC-V也

548
00:17:51,240 --> 00:17:52,770
14460,14640 14640,15240 15600,15750 15750,15870 15870,15990
more modern, so it's not

549
00:17:52,770 --> 00:17:53,730
15990,16080 16080,16320 16320,16860 16860,16950
a worry RISC-V is

550
00:17:53,730 --> 00:17:55,740
16950,17400 17400,17550 17550,18000 18060,18720 18720,18960
also| if we jump back
|如果我们回到那些手册，

551
00:17:55,740 --> 00:17:58,050
18960,19050 19050,19290 19290,20220 20400,21270
to those manuals,| RISC-V
|RISC-V的独特之处在于它是分开的。所有的RISC-V处理器，嗯，所谓的基整数指令集。

552
00:17:58,050 --> 00:17:59,130
21270,21420 21420,21870 21870,22020 22020,22170 22170,22350
is unique in that it's

553
00:17:59,130 --> 00:18:00,740
22350,23040 23040,23160 23160,23760
divided we have.

554
00:18:01,010 --> 00:18:02,450
150,540 540,750 750,870 870,1140 1140,1590
What's called the base integer

555
00:18:02,450 --> 00:18:04,280
1590,2190 2190,2490 2490,2880 2880,3180 3180,3720
instruction set which all RISC-V

556
00:18:04,280 --> 00:18:07,080
3720,4740 5220,5790
processors, um.|
|如果我们有十五个的话。

557
00:18:07,340 --> 00:18:08,750
120,300 300,420 420,630 630,1050 1050,1530
If we have fifteen.| Gabriel
|加布里埃尔在聊天中问道，如果我们有15,000条指令，几乎不可能有效地输送它们，

558
00:18:08,750 --> 00:18:09,530
1530,1860 1860,1950 1950,2040 2040,2220 2220,2310
asks in the chat, if

559
00:18:09,530 --> 00:18:11,210
2310,2400 2400,2490 2490,3150 3150,3750 3750,3990
we have 15,000 instructions, it

560
00:18:11,210 --> 00:18:13,100
3990,4350 4350,4890 4890,4950 4950,5370 5370,5880
nearly impossible to efficiently pipeline

561
00:18:13,100 --> 00:18:14,270
5880,6180 6360,6720 6720,6780 6780,6900 6900,7050
them,| why do we need
|为什么我们需要这么多。

562
00:18:14,270 --> 00:18:15,710
7050,7170 7170,7440 7890,8220 8220,8310 8310,8490
so many.| Like I was
|就像我说的，出于向后兼容的原因，我们需要这么多

563
00:18:15,710 --> 00:18:16,670
8490,8760 8760,8850 8850,9090 9090,9210 9210,9450
saying we need so many

564
00:18:16,670 --> 00:18:18,530
9450,9570 9570,9960 9960,10620 10620,11130 11130,11310
for backwards compatibility reasons| it's
|这是由你自己决定的，你知道吗，你认为这是非常重要的吗？

565
00:18:18,530 --> 00:18:19,550
11310,11460 11460,11580 11580,11730 11730,11820 11820,12330
up to you to decide

566
00:18:19,550 --> 00:18:20,700
12330,12390 12390,12540 12540,12870 12870,13230
you know whether you

567
00:18:20,660 --> 00:18:22,340
60,600 600,870 870,1290 1290,1680
think that's super important|
|但是很多指令，我想很多也是吃，被简单的指令吃掉了

568
00:18:22,340 --> 00:18:23,870
1680,1800 1800,2100 2100,2160 2160,2400 2400,3210
but many of those instructions,

569
00:18:23,900 --> 00:18:24,560
3240,3420 3420,3540 3540,3600 3600,3810 3810,3900
I think a ton of

570
00:18:24,560 --> 00:18:25,760
3900,4020 4020,4140 4140,4410 4410,4890
them are also eat,

571
00:18:25,860 --> 00:18:27,750
60,390 390,570 570,810 810,1350 1350,1950
eaten up by simply instructions|
|这是他们自己的一类特殊的东西。

572
00:18:27,750 --> 00:18:29,220
1950,2190 2190,2250 2250,2430 2430,2880 3030,3420
which are their own kind

573
00:18:29,220 --> 00:18:30,870
3420,3480 3480,3900 3900,4290 4290,4410 4410,5070
of special class of things.|
|你不会，我从来没有见过英特尔汇编代码能充分利用15,000条指令，

574
00:18:31,850 --> 00:18:33,710
600,780 780,1200 1290,1590 1590,1950
You won't, I I

575
00:18:33,710 --> 00:18:35,330
1950,2370 2370,2640 2640,2850 2850,3180 3180,3570
I've never seen Intel assembly

576
00:18:35,330 --> 00:18:36,770
3570,3810 3810,3900 3900,4110 4110,4410 4410,5010
code that makes full uses

577
00:18:36,800 --> 00:18:37,880
5040,5340 5340,5730 5730,5910 5910,6030 6030,6120
full usage out of the

578
00:18:37,880 --> 00:18:39,680
6120,6750 6750,7320 7320,7440 7440,7770 7770,7920
15,000 instructions,| but mostly this
|但大多数情况下，这是出于向后兼容的需要，而且很简单。

579
00:18:39,680 --> 00:18:41,000
7920,8190 8190,8400 8400,8700 8880,9210 9210,9240
comes from a from a

580
00:18:41,000 --> 00:18:42,500
9240,9480 9480,9570 9570,9930 9930,10590 10590,10740
need for backwards compatibility and

581
00:18:42,500 --> 00:18:43,200
10740,11190
simply.|
|但就像我说的，RISC-V有一个所谓的基整数指令集。

582
00:18:43,520 --> 00:18:44,660
120,450 690,960 960,990 990,1110 1110,1260
But like I was saying

583
00:18:44,660 --> 00:18:46,160
1260,1410 1410,1950 1950,2520 2550,2760
the RISC-V has a

584
00:18:46,160 --> 00:18:47,510
2760,3000 3000,3180 3180,3300 3300,3660 3660,4110
what's called the base integer

585
00:18:47,510 --> 00:18:48,740
4110,4680 4680,5130
instruction set.|
|它包含所有正常的加乘运算，

586
00:18:49,030 --> 00:18:51,160
90,900 1230,1830 1830,2070 2070,2220
Which contains all of

587
00:18:51,160 --> 00:18:54,340
2220,2640 2670,3480 3480,3750 3750,4560 4590,5400
the normal add multiply things,|
|然后处理器可以选择实现许多其他模块，您可以在这里的旁边看到，

588
00:18:54,400 --> 00:18:56,230
5940,6090 6090,6390 6390,7050 7050,7290
and then processors can

589
00:18:56,230 --> 00:18:57,640
7290,7680 7680,7770 7770,8250 8250,8340 8340,8700
choose to implement a number

590
00:18:57,640 --> 00:18:58,990
8700,8790 8790,9060 9060,9690 9690,9900 9900,10050
of other modules which you

591
00:18:58,990 --> 00:19:00,130
10050,10200 10200,10440 10440,10800 10800,10860 10860,11190
can see along the side

592
00:19:00,130 --> 00:19:01,330
11190,11460 11460,11610 11610,11850 11850,12330 12330,12390
here,| it's probably impossible to
|可能不可能在屏幕上阅读，但是例如，如果您希望处理器知道支持单精度浮点标准扩展，

593
00:19:01,330 --> 00:19:03,220
12390,12750 13260,13470 13470,13620 13620,14040 14040,14280
read on your screen, but

594
00:19:03,220 --> 00:19:04,420
14280,14400 14400,15030 15030,15180 15180,15300 15300,15480
for example if you want

595
00:19:04,420 --> 00:19:06,700
15480,15570 15570,16470 16530,16980 16980,17220 17250,17760
a processor know that supports

596
00:19:06,700 --> 00:19:08,320
17760,18060 18060,18510 18510,18660 18660,18930 18930,19380
standard extension for single precision

597
00:19:08,320 --> 00:19:10,000
19380,19740 19740,20340 20460,20790 20790,20910 20910,21060
floating point,| then you can
|然后你就可以包含f模了。

598
00:19:10,000 --> 00:19:11,500
21060,21390 21390,21480 21480,21720 21720,22320
include the f module.|
|这使得RISC-V更容易支持向后兼容，

599
00:19:11,960 --> 00:19:13,220
120,420 420,570 570,810 810,960 960,1380
And this makes it easier

600
00:19:13,220 --> 00:19:14,480
1380,1500 1500,1950 1950,2070 2070,2640
for RISC-V to support

601
00:19:14,660 --> 00:19:18,140
2820,3840 3840,4590 4590,5370 5430,5850
backwards compatibility,| because if,
|因为如果你可以说我包含和支持哪组模块，

602
00:19:18,170 --> 00:19:19,490
6330,6510 6510,6630 6630,6870 6870,7290 7290,7650
you can just say what

603
00:19:19,490 --> 00:19:20,690
7650,7860 7860,8010 8010,8580 8580,8730 8730,8850
set of modules do I

604
00:19:20,690 --> 00:19:23,060
8850,9420 9420,9570 9570,10170 10320,11010 11040,11220
include and support,| and the
|编译器可以选择。

605
00:19:23,060 --> 00:19:25,000
11220,11790 11790,11970 11970,12450 12450,12870
compiler can choose.| Then,
|然后，反编译器可以说好的，你知道这个处理器告诉我它支持这些模块，

606
00:19:25,060 --> 00:19:26,680
120,960 960,1080 1080,1320 1320,1740
decompiler can say okay,

607
00:19:26,680 --> 00:19:28,240
1740,1800 1800,2100 2250,2700 2700,3210 3210,3300
you know this processor is

608
00:19:28,240 --> 00:19:29,260
3300,3570 3570,3690 3690,3780 3780,4110 4110,4320
telling me it supports these

609
00:19:29,260 --> 00:19:30,310
4320,4830 4830,4920 4920,4980 4980,5100 5100,5370
modules,| so I can only
|所以我只能用这些模块编译这段代码。

610
00:19:30,310 --> 00:19:31,480
5370,5820 5820,5940 5940,6240 6240,6360 6360,6540
compile this code with these

611
00:19:31,480 --> 00:19:32,300
6540,7170
modules.|
|好的，Bibik说似乎使用x86而不是RISC-V处理器的唯一优势是你可以获得的性能，

612
00:19:33,760 --> 00:19:35,800
120,510 510,1110 1110,1920 1950,2160
Okay, Bibik says it

613
00:19:35,800 --> 00:19:36,850
2160,2430 2430,2550 2550,2640 2640,2850 2850,3210
seems that the only advantage

614
00:19:36,850 --> 00:19:38,230
3210,3300 3300,3570 3570,4290 4290,4500 4500,4590
of using x86 instead of

615
00:19:38,230 --> 00:19:39,310
4590,5040 5040,5520 5520,5580 5580,5670
RISC-V processor is the

616
00:19:39,310 --> 00:19:40,180
5670,5850 5850,5910 5910,6330 6330,6450 6450,6540
kind of performance you can

617
00:19:40,180 --> 00:19:42,220
6540,6840 6990,7530 7530,7650 7650,8070 8280,8580
get,| however, that performance comes
|然而，这种性能是以巨大的成本、复杂性和潜在的安全性为代价的，

618
00:19:42,220 --> 00:19:43,390
8580,8670 8670,8910 8910,9330 9330,9660 9660,9750
as a massive cost and

619
00:19:43,390 --> 00:19:45,550
9750,10290 10290,10440 10440,10770 10770,11490 11550,11910
complexity and potential security,| my
|我的问题是为什么我们还在使用x86

620
00:19:45,550 --> 00:19:46,450
11910,12300 12300,12450 12450,12630 12630,12720 12720,12810
question is why are we

621
00:19:46,450 --> 00:19:48,100
12810,13020 13020,13320 13320,14070 14070,14370 14370,14460
still using x86| instead of
|而不是转向像RISC-V这样的东西。

622
00:19:48,100 --> 00:19:49,120
14460,14730 14730,14790 14790,15060 15060,15270
moving to something like

623
00:19:49,120 --> 00:19:49,820
15270,15840
RISC-V.|
|嗯，我可以很好地回答这个问题，世界是在x86上运行的，

624
00:19:49,970 --> 00:19:52,130
1050,1500 1500,1590 1590,1740 1740,2370
Well I'm a big

625
00:19:52,160 --> 00:19:53,210
2400,2730 2730,2970 2970,3090 3090,3360 3360,3450
answer that the world is

626
00:19:53,210 --> 00:19:55,970
3450,3750 3750,3930 3930,4800 4830,5760
run on x86,| for
|对于为什么RISC-V是相当现代的，我也没有一个很好的答案。

627
00:19:55,970 --> 00:19:57,170
6210,6420 6420,6720 6720,6960 6960,7110 7110,7410
I don't have a great

628
00:19:57,170 --> 00:19:58,910
7410,7740 7740,7950 7950,8400 8610,9150
answer for why RISC-V

629
00:19:58,910 --> 00:20:00,540
9150,9270 9270,9480 9480,9900 9900,10320
is pretty modern too.|
|因此，作为一个整体，世界几乎都运行在x86上，

630
00:20:00,740 --> 00:20:02,750
120,690 840,1590 1590,1950 1950,2070 2070,2130
So the world as a

631
00:20:02,750 --> 00:20:04,460
2130,2460 2460,2700 2700,3000 3000,3450 3450,3840
whole pretty much runs on

632
00:20:04,460 --> 00:20:06,170
3840,4590 4590,4770 4770,4920 4920,5100 5100,5550
x86,| so if you suddenly
|因此，如果您突然开始将您的处理器转换为RISC-V，

633
00:20:06,170 --> 00:20:10,340
5550,6090 6510,7260 7260,7830 8190,9330 9330,9720
start converting your processors to

634
00:20:10,340 --> 00:20:12,110
9720,10560 10560,11070 11070,11370 11370,11490
RISC-V,| you run the
|你会冒着失去对一堆重要事情的支持的风险，

635
00:20:12,110 --> 00:20:13,540
11490,11880 11880,12060
risk of,

636
00:20:14,080 --> 00:20:15,730
120,240 240,570 600,1110 1110,1620 1620,1770
you know losing support for

637
00:20:15,730 --> 00:20:17,320
1770,1860 1860,2100 2100,2220 2220,2790 2790,3360
a bunch of important things,|
|另外，英特尔在他们的处理器中确实做了一些有趣的事情，

638
00:20:17,380 --> 00:20:19,060
3420,3900 3900,4110 4110,4380 4380,4620 4620,5100
also there are like Intel

639
00:20:19,060 --> 00:20:21,310
5100,5430 5430,5730 5730,6360 6360,6870 6870,7350
does do interesting things within

640
00:20:21,310 --> 00:20:24,580
7350,7560 7560,8460 8550,9180 9180,9720 9720,10620
their processors,| like security wise,
|就像安全智慧一样，有Enclaves和Intel处理器，他们近年来一直在做一些事情，试图为您提供额外的安全性

641
00:20:24,610 --> 00:20:26,470
10650,10980 10980,11280 11280,12000 12000,12120 12120,12510
there are enclaves and Intel

642
00:20:26,470 --> 00:20:28,540
12510,13350 13350,13470 13470,13680 13680,13920 13920,14580
processors and there's things that

643
00:20:28,780 --> 00:20:30,070
14820,15150 15150,15240 15240,15600 15600,15750 15750,16110
they've been doing in recent

644
00:20:30,070 --> 00:20:31,510
16110,16470 16470,16590 16590,17010 17040,17190 17190,17550
years to try to try

645
00:20:31,510 --> 00:20:33,130
17550,17820 17820,18060 18060,18240 18240,18810 18840,19170
and give you extra added

646
00:20:33,130 --> 00:20:35,500
19170,19980 20190,20880 20910,21180 21180,21300 21300,21540
security| and some of those
|英特尔确实实现了一些超特定的指令，这些指令对于某些特定的计算来说是非常有效的。

647
00:20:35,500 --> 00:20:37,240
21540,22110 22110,22260 22260,22590 22590,22800 22800,23280
instructions that Intel does implement

648
00:20:37,240 --> 00:20:39,100
23280,23520 23520,23700 23700,24030 24030,24720 24840,25140
which are hyper specific can

649
00:20:39,100 --> 00:20:41,260
25140,25350 25350,25650 25650,26220 26220,26640 26640,27300
be really efficient for certain,

650
00:20:41,530 --> 00:20:43,080
27900,28980
computations.|
|所以他们有这么多指令，

651
00:20:43,250 --> 00:20:44,150
450,600 600,720 720,840 840,990
And so they have

652
00:20:44,150 --> 00:20:45,860
990,1170 1170,1350 1350,1980 1980,2250 2250,2700
so many instructions,| there's often
|你知道，通常情况下有一个完美的指示

653
00:20:45,860 --> 00:20:46,620
2700,2790 2790,3210
you know,

654
00:20:46,740 --> 00:20:48,180
60,270 270,690 690,1260 1260,1440 1440,1500
a perfect instruction for a

655
00:20:48,180 --> 00:20:49,530
1500,2190 2190,2340 2340,2490 2490,2640 2640,2850
situation| that may be more
|这可能比RISC-V中存在的更有效，

656
00:20:49,530 --> 00:20:50,680
2850,3390 3390,3750
efficient than

657
00:20:50,870 --> 00:20:52,670
90,540 540,960 960,1380 1380,1680 1680,2340
then what exists within RISC-V,|
|但一个更实际的答案是，RISC-V相对较新

658
00:20:52,670 --> 00:20:54,830
2430,3030 3030,3330 3330,3660 3660,4050
but a more practical

659
00:20:54,830 --> 00:20:55,730
4050,4350 4350,4440 4440,4560 4560,4950
answer is at RISC-V

660
00:20:55,730 --> 00:20:56,840
4950,5040 5040,5550 5550,5850 5850,5970 5970,6060
is relatively new| and we
|我们只是不知道，没有人真正为个人电脑制造处理器。

661
00:20:56,840 --> 00:20:58,340
6060,6210 6210,6540 6660,6840 6840,7290 7290,7560
just don't know, nobody's really

662
00:20:58,340 --> 00:21:00,350
7560,7920 7920,8550 8550,8700 8700,9030 9030,9570
making processors for personal computers.|
|我认为SiFive的发布是超级近期的，

663
00:21:00,350 --> 00:21:02,150
9570,9660 9660,9840 9840,10080 10260,10920 10920,11370
I think the SiFive announcement

664
00:21:02,150 --> 00:21:04,490
11370,11700 11700,12060 12060,12480 13320,13710
is super recent,| and
|他们可以说是第一批这样做的人，

665
00:21:04,520 --> 00:21:05,660
13740,14160 14160,14340 14340,14430 14430,14550 14550,14880
they're kind of the first

666
00:21:05,660 --> 00:21:06,650
14880,15150 15150,15240 15240,15360 15360,15630 15630,15870
people to be doing that,|
|因此，在实践层面上，这和无法运行英特尔所有的软件设计是我最好的答案。

667
00:21:06,650 --> 00:21:08,150
15870,16170 16200,16350 16350,16440 16440,16860 16860,17370
so on a practical level,

668
00:21:08,820 --> 00:21:10,560
120,660 660,900 900,1140 1140,1740 1740,1860
that and the inability to

669
00:21:10,560 --> 00:21:11,730
1860,2040 2040,2160 2160,2250 2250,2700 2700,3030
run all the software design

670
00:21:11,730 --> 00:21:14,070
3030,3210 3210,3720 4230,4830 4890,5100 5100,5370
for Intel is is my

671
00:21:14,070 --> 00:21:15,340
5370,5700 5700,6270
best answer.|
|所以我们现在聊了一会儿关于组装的事情，

672
00:21:16,210 --> 00:21:19,210
750,1440 1920,2220 2220,2610 3060,3390 3390,3750
So we've been now chatting

673
00:21:19,210 --> 00:21:20,710
3750,3810 3810,4020 4020,4320 4320,4710 4710,5250
a little bit about assembly,|
|所以我只想看看一些实际的汇编代码。

674
00:21:20,710 --> 00:21:21,970
5250,5370 5370,5430 5430,5640 5640,5940 5940,6510
so I just wanted to

675
00:21:22,090 --> 00:21:23,800
7350,7680 7680,7740 7740,8100 8100,8340
take a look at

676
00:21:23,800 --> 00:21:26,420
8340,8700 8700,9180 9180,9630 9630,10230
some actual assembly code.|
|下面是下面的C代码，

677
00:21:26,600 --> 00:21:30,320
120,450 450,1020 1020,1650 1650,2370 3420,3840
So here is the C

678
00:21:30,320 --> 00:21:31,730
3840,4200 4200,4350 4350,4650 4650,5100 5100,5250
code for what's below,| so
|这是一个简单的函数，它有一个累加器，

679
00:21:31,730 --> 00:21:32,930
5250,5400 5400,5520 5520,5580 5580,5940 5940,6450
this is a simple function

680
00:21:32,930 --> 00:21:34,610
6450,6540 6540,6720 6720,6810 6810,7620 7710,8130
that has an accumulator,| we
|我们从0循环到n，然后将a中从0到n的所有数字相加。

681
00:21:34,610 --> 00:21:36,440
8130,8550 8550,9030 9030,9360 9360,9480 9480,9960
loop from zero to n

682
00:21:36,440 --> 00:21:38,390
9960,10620 10710,11220 11220,11520 11520,11730 11730,11910
and we sum up all

683
00:21:38,390 --> 00:21:40,400
11910,12060 12060,12780 12780,13380 13410,13740 13740,13920
the numbers from a from

684
00:21:40,400 --> 00:21:41,300
13920,14220 14220,14310 14310,14580
zero to n.|
|然后返回该值，在其最简单的级别上，这是最简单的汇编类型，

685
00:21:41,960 --> 00:21:43,550
180,420 420,570 570,900 900,1080 1080,1770
And then return that value

686
00:21:43,760 --> 00:21:46,280
1980,2670 2670,3420 3420,3570 3570,4020 4020,4500
and at its simplest level,

687
00:21:46,280 --> 00:21:47,450
4500,4680 4680,4800 4800,4950 4950,5430 5430,5670
this is the easiest kind

688
00:21:47,450 --> 00:21:48,980
5670,5760 5760,6360 6360,6630 6630,6840 6840,7200
of assembly,| you can get
|你可以不用编译那个程序，

689
00:21:48,980 --> 00:21:50,510
7200,7350 7350,7470 7470,7980 7980,8190 8190,8730
out of compiling that program,|
|如果你真的走进你自己的电脑，写了C代码，并试图编译它，

690
00:21:50,720 --> 00:21:53,390
8940,9300 9300,9600 9600,10170 10170,10620 10650,11610
if you actually go into

691
00:21:53,390 --> 00:21:54,770
11610,12000 12000,12180 12180,12720 12720,12870 12870,12990
your own computer and you

692
00:21:54,770 --> 00:21:55,850
12990,13230 13230,13320 13320,13590 13590,13950 13950,14070
write the C code and

693
00:21:55,850 --> 00:21:56,930
14070,14160 14160,14340 14340,14460 14460,14910 14910,15150
you try to compile it,|
|你最终可能会得到一些看起来完全不同的东西。

694
00:21:56,930 --> 00:21:57,710
15150,15270 15270,15420 15420,15630 15630,15810 15810,15930
you will end up with

695
00:21:57,710 --> 00:22:00,020
15930,16470 16650,16980 16980,17310 17310,17760 17790,18240
something that likely looks quite

696
00:22:00,020 --> 00:22:01,160
18240,18690
different.|
|这是正确的，原因有很多，我们会看到其中的一些原因，还有一些是特定于编译器的，

697
00:22:01,420 --> 00:22:02,260
180,330 330,570 570,780 780,930 930,1020
And that's true for a

698
00:22:02,260 --> 00:22:03,580
1020,1440 1440,1560 1560,2040 2040,2160 2160,2340
variety of reasons, we have

699
00:22:03,580 --> 00:22:04,630
2790,2940 2940,3030 3030,3180 3180,3390
some of which we'll

700
00:22:04,630 --> 00:22:05,350
3390,3600 3600,3750 3750,3870 3870,4020 4020,4110
get to and some of

701
00:22:05,350 --> 00:22:07,570
4110,4350 4350,4440 4440,4860 4860,5520 5850,6330
which are compiler specific,| so
|所以现代编译器进行了大量的优化。

702
00:22:07,570 --> 00:22:10,300
6330,6750 6750,7410 7410,7800 7800,8520 8610,9060
modern compilers make a large

703
00:22:10,300 --> 00:22:12,080
9060,9330 9330,9420 9420,10740
number of optimizations.|
|当他们将你的C编译成汇编语言时使用它，所以你的汇编指令看起来可能会不同，

704
00:22:13,510 --> 00:22:14,860
90,390 390,570 570,780 780,930 930,1440
With it when they compile

705
00:22:14,860 --> 00:22:16,150
1440,1620 1620,1860 1860,2010 2010,2580 2580,2730
your C to assembly, and

706
00:22:16,150 --> 00:22:17,500
2730,2880 2880,3060 3060,3420 3420,3960 3960,4080
so your assembly instructions may

707
00:22:17,500 --> 00:22:19,870
4080,4290 4290,4740 4860,5220 5220,6000 6060,6450
look different,| for instance while
|例如，当您在gdb中调试时，您可能会遇到一些内容，告诉您某个变量已被优化，

708
00:22:19,870 --> 00:22:21,280
6450,6630 6630,7200 7200,7350 7350,7860
you're debugging in gdb,

709
00:22:21,280 --> 00:22:22,360
7860,7980 7980,8130 8130,8340 8340,8670 8670,8940
you may come across something

710
00:22:22,360 --> 00:22:23,230
8940,9060 9060,9330 9330,9480 9480,9630 9630,9810
that tells you that it's

711
00:22:23,230 --> 00:22:25,300
9810,10230 10230,10740 10740,10920 10920,11160 11160,11880
some variable has been optimized

712
00:22:25,300 --> 00:22:26,770
11880,12330 12630,12870 12870,13020 13020,13230 13230,13350
out,| and that means that
|这意味着编译器决定不需要该变量

713
00:22:26,770 --> 00:22:28,150
13350,13440 13440,13950 13950,14430 14430,14550 14550,14730
the compiler decided it didn't

714
00:22:28,150 --> 00:22:30,250
14730,14940 14940,15120 15120,15840 16590,16830
need that variable| and
|因此，这一点将有效地从项目中消失，

715
00:22:30,250 --> 00:22:32,440
16830,17100 17100,17490 17490,17820 17850,18450 18450,19020
so that'll be gone effectively

716
00:22:32,440 --> 00:22:34,270
19020,19200 19200,19290 19290,19950 20190,20490 20490,20850
from the program,| but yeah
|但是，是的，这是最直截了当的，我们是在移动t0中的价值，

717
00:22:34,270 --> 00:22:35,290
20850,21000 21000,21330 21360,21540 21540,21660 21660,21870
and it's at its most

718
00:22:35,290 --> 00:22:36,380
21870,22740
straightforward,

719
00:22:36,970 --> 00:22:39,520
270,510 510,1230 2040,2550 2550,2820
we're moving value that's

720
00:22:39,520 --> 00:22:40,510
2820,2970 2970,3480 3480,3570 3570,4530
in a0 the t0,|
|我们将0设置为0，然后我们只是将t0中的内容加到a0上，对于循环的每个迭代，直到t0达到零。

721
00:22:40,510 --> 00:22:42,280
4560,4860 4860,5190 5190,5580
we're setting a0

722
00:22:42,280 --> 00:22:44,080
5580,5640 5640,6240 6240,6450 6450,6960 7110,7380
to zero and then we

723
00:22:44,080 --> 00:22:46,390
7380,7920 8340,8670 8670,9180 9240,9540 9540,9690
are just adding what's in

724
00:22:46,390 --> 00:22:47,890
9690,10290 10290,10470 10470,11190
t0 to a0,

725
00:22:47,890 --> 00:22:48,880
11190,11370 11370,11610 11610,12060 12060,12150 12150,12180
for every iteration of a

726
00:22:48,880 --> 00:22:50,920
12180,12660 12690,13260 13260,13890 13890,14220
loop until t0 reaches

727
00:22:50,920 --> 00:22:51,520
14220,14640
zero.|
|这就是这篇文章的全部内容。

728
00:22:52,500 --> 00:22:53,370
180,330 330,510 510,630 630,810 810,1050
And that's all that's going

729
00:22:53,370 --> 00:22:54,630
1050,1200 1200,1290 1290,1410 1410,1740 1770,2310
on in this piece.| Amir,
|阿米尔，举起手来。

730
00:22:54,630 --> 00:22:55,580
2310,2460 2460,2670 2670,3090
your hands raised.|
|我想知道.section.text.global做什么。

731
00:22:57,460 --> 00:22:59,080
360,480 480,810 810,1230 1230,1590 1590,2790
I was wondering what .section

732
00:22:59,080 --> 00:23:01,540
2820,3690 3750,4440
.text .global

733
00:23:01,540 --> 00:23:02,400
4440,4800
do.|
|全局意味着您可以从其他文件中包含此内容，

734
00:23:02,420 --> 00:23:03,770
60,330 330,780 780,1050 1050,1230 1230,1410
A global means that you

735
00:23:03,770 --> 00:23:05,120
1410,1770 1770,2280 2280,2460 2460,2580 2580,2760
can include this from other

736
00:23:05,120 --> 00:23:07,280
2760,3450 3690,4260 4260,4470 4470,4590 4590,4920
files,| so if we actually
|所以如果我们真的跳进去了，让我们看看defs.h。

737
00:23:07,280 --> 00:23:10,820
4920,5220 5220,6300 7380,7620 7620,8460
hop into, let's see

738
00:23:11,630 --> 00:23:13,660
9270,10500
defs.h.|
|这是您将要使用的文件，如果您还没有，您将会非常熟悉，这基本上包括您可能想要使用的内核中的所有函数

739
00:23:14,220 --> 00:23:15,270
120,360 360,480 480,570 570,930 930,1170
This is the file that

740
00:23:15,270 --> 00:23:17,580
1170,1710 2820,3180 3180,3360 3360,3480
you're, will if you

741
00:23:17,580 --> 00:23:18,720
3480,3690 3690,4020 4020,4140 4140,4290 4290,4620
aren't already, you will become

742
00:23:18,720 --> 00:23:20,970
4620,4860 4860,5280 5280,5640 5640,6030 6030,6870
quite familiar with, this includes

743
00:23:20,970 --> 00:23:22,380
6870,7350 7350,7560 7560,7650 7650,7740 7740,8280
basically all of the functions

744
00:23:22,380 --> 00:23:23,370
8280,8550 8550,8610 8610,9030 9030,9150 9150,9270
within the kernel that you

745
00:23:23,370 --> 00:23:24,480
9270,9420 9420,9600 9600,9660 9660,9780 9780,10380
may want to be using|
|在这里，您知道我们可以看到，在我的，我的文件中，我已经包含了这些函数的定义

746
00:23:24,870 --> 00:23:27,510
10770,11520 12000,12390 12390,13050 13200,13410
and within here you

747
00:23:27,510 --> 00:23:28,470
13410,13620 13620,13740 13740,13890 13890,14130 14130,14370
know we can see that

748
00:23:28,470 --> 00:23:29,440
14370,14520 14520,15120
in my,

749
00:23:29,610 --> 00:23:31,440
90,360 360,900 900,1080 1080,1710 1710,1920
my file, I've included the

750
00:23:31,440 --> 00:23:33,600
1920,2610 2610,2700 2700,2910 2910,3690 3840,4080
definitions to these functions| and
|这样.global就可以确保这些函数可以从其他地方调用

751
00:23:33,600 --> 00:23:35,700
4080,4230 4230,4470 4470,5370 5370,5670 5670,6180
so that .global makes sure

752
00:23:35,700 --> 00:23:36,800
6180,6630
that,

753
00:23:37,080 --> 00:23:38,760
660,900 900,1230 1230,1410 1410,1800
that these these functions

754
00:23:38,760 --> 00:23:40,200
1800,1920 1920,2310 2340,2820 2820,2970 2970,3240
can be called from other

755
00:23:40,200 --> 00:23:42,570
3240,3990 4260,4620 4620,5370 5370,5610
places| and .text just
|而.text只是说这是代码。

756
00:23:42,570 --> 00:23:43,740
5610,5850 5850,5970 5970,6090 6090,6570
says this is code.|
|所以如果你回想一下书中的图3.4。

757
00:23:44,220 --> 00:23:46,020
120,450 450,630 630,750 750,1230 1230,1920
So if you recall from

758
00:23:46,020 --> 00:23:48,720
1920,2430 2430,3720 3720,3900 3900,3990 3990,4620
figure 3.4 in the book.|
|这就是如果我们去看那本书的话。

759
00:23:49,300 --> 00:23:50,890
660,840 840,1350 1350,1560 1560,1710
So that's if we

760
00:23:50,890 --> 00:23:52,820
1710,2490 2520,3420
go to,

761
00:23:53,430 --> 00:23:54,640
90,240 240,1170
the book.|
|我们进入页表进程地址空间，

762
00:23:56,380 --> 00:23:58,390
120,360 360,480 480,810 810,1470 1650,2130
And we go into page

763
00:23:58,390 --> 00:24:01,360
2130,3330 3360,3780 3780,4080 4080,4530 4710,5100
tables process address space,| so
|所以在这张图中，这和文本是一样的，也就是说代码。

764
00:24:01,360 --> 00:24:03,550
5100,5370 5370,6000 6030,6240 6240,6420 6420,7290
in here in this diagram,

765
00:24:03,730 --> 00:24:05,350
7470,7830 7830,7980 7980,8280 8280,8670 8970,9090
that's the same thing is

766
00:24:05,350 --> 00:24:06,640
9090,9480 9480,9600 9600,9780 9780,9960 9960,10380
text, so just means code.|
|这回答了你的问题。

767
00:24:09,440 --> 00:24:11,630
240,390 390,600 600,690 690,1050 1530,2430
That answer your question.| Thanks.|
|谢谢。|所以如果我们想跑，嗯。

768
00:24:14,810 --> 00:24:15,740
1650,1890 1890,2070 2070,2280 2280,2370 2370,2580
And so if we want

769
00:24:15,740 --> 00:24:17,560
2580,2640 2640,3330 3360,4020
to run, um.|
|假设我们有一些集会，

770
00:24:17,670 --> 00:24:18,600
90,360 360,510 510,660 660,840 840,1020
Let's say we have some

771
00:24:18,600 --> 00:24:20,640
1020,1950 2010,2370 2370,2460 2460,2700 2700,3060
assembly,| also if you ever
|另外，如果您发现自己对内核的外观感兴趣，

772
00:24:20,640 --> 00:24:23,520
3060,3360 3360,3990 4110,4950 4950,5670 5700,5940
find yourself interested in what

773
00:24:23,520 --> 00:24:25,410
5940,6060 6060,6510 6510,6810 6810,7320 7560,7830
the kernel looks like,| we
|我们可以进入，编译后可以查看kernel/kernel.asm文件。

774
00:24:25,410 --> 00:24:27,450
7830,8160 8160,8610 8610,9180 9180,9570 9570,9870
can go inside the, after

775
00:24:27,450 --> 00:24:29,250
9870,9990 9990,10710 10860,11190 11190,11520 11520,11670
you compile, you can look

776
00:24:29,250 --> 00:24:30,750
11670,11760 11760,11880 11880,12330
in the file

777
00:24:30,750 --> 00:24:32,500
12330,14250
kernel/kernel.asm.|
|这是xv6内核的完整汇编，

778
00:24:32,800 --> 00:24:33,910
120,480 480,690 690,810 810,930 930,1230
And this is the full

779
00:24:33,910 --> 00:24:37,360
1230,1440 1440,1800 2820,3780 3810,4530 4560,4680
kind of assembly for the

780
00:24:37,360 --> 00:24:38,200
4680,5220
kernel

781
00:24:38,980 --> 00:24:40,330
570,720 720,1470
of xv6,|
|左边的每个数字都是一个标签，它告诉您在内存中的哪个位置，此指令中的

782
00:24:40,330 --> 00:24:41,680
1470,1800 1800,2010 2010,2130 2130,2370 2370,2820
and each of these numbers

783
00:24:41,680 --> 00:24:43,660
2820,2970 2970,3090 3090,3420 3420,3960 4230,4800
on the left here is

784
00:24:43,660 --> 00:24:45,070
4800,4920 4920,5550 5550,5760 5760,6030 6030,6210
a label that tells you

785
00:24:45,070 --> 00:24:46,780
6210,6570 6570,6720 6720,7170 7170,7440 7440,7920
where in memory, this in

786
00:24:46,900 --> 00:24:48,790
8040,8250 8250,8730 8730,8880 8880,9300 9630,9930
this instruction will be| and
|这将会派上相当大的用场。

787
00:24:48,790 --> 00:24:49,870
9930,10050 10050,10170 10170,10380 10380,10740 10740,11010
that will come in quite

788
00:24:49,870 --> 00:24:50,680
11010,11430
handy.|
|所以这就是实际情况，嗯。

789
00:24:50,670 --> 00:24:51,870
30,240 240,360 360,660 660,750 750,1230
And so here is the

790
00:24:52,380 --> 00:24:54,000
1740,2070 2070,2190 2190,2670 2670,3180
here's the actual, um.|
|使用实际的汇编代码，您可以看到函数的标签以及是否声明，

791
00:24:54,840 --> 00:24:56,130
120,300 300,390 390,660 660,1050 1050,1410
Use the actual assembly code

792
00:24:56,130 --> 00:24:56,850
1410,1500 1500,1620 1620,1740 1740,1980 1980,2130
and you can see the

793
00:24:56,850 --> 00:24:59,280
2130,2850 2850,2970 2970,3090 3090,4140 4380,4560
labels for the functions and

794
00:24:59,280 --> 00:25:00,360
4560,4830 4830,5190 5190,5310 5310,5490 5490,5640
whether declared,| so this is
|这是，可以非常有用，因为我们正在调试代码，希望我能在一秒钟内展示这一点。

795
00:25:00,360 --> 00:25:02,190
5640,5850 5850,6030 6900,7320 7320,7470
this is, can be

796
00:25:02,190 --> 00:25:03,510
7470,7740 7740,7950 7950,8460 8460,8670 8670,8790
really really useful as we're

797
00:25:03,510 --> 00:25:04,980
8790,9210 9210,9660 9660,9810 9810,10140 10140,10260
debugging code and hopefully I'll

798
00:25:04,980 --> 00:25:05,850
10260,10350 10350,10500 10500,10590 10590,10830 10830,11130
be able to show that

799
00:25:06,150 --> 00:25:07,180
11430,11610 11610,11670 11670,12180
in a second.|
|但现在我们将跳回第一个函数sum_to

800
00:25:07,540 --> 00:25:09,460
420,780 780,900 900,1410 1680,2040 2040,2340
But for now we'll jump

801
00:25:09,460 --> 00:25:11,530
2340,2700 2700,3330 3330,3630 3630,3930 3930,4410
back to this first function,

802
00:25:11,530 --> 00:25:13,180
4410,5250 5430,5730 5730,5850 5850,6060
sum_to| and we'll just
|我们将看看如何在gdb中检查这一点，

803
00:25:13,180 --> 00:25:14,920
6060,6390 6390,6660 6660,6840 6840,7170 7170,7800
see how we can examine

804
00:25:14,920 --> 00:25:16,750
7800,8220 8250,8820 8820,8910 8910,9630
that inside of gdb,|
|所以第一步是我的两个窗户在这里。

805
00:25:16,780 --> 00:25:19,330
11310,11610 11610,11700 11700,11940 11940,12210
so the first step

806
00:25:19,330 --> 00:25:20,320
12210,12450 12450,12570 12570,12690 12690,12810 12810,13200
is I have my two

807
00:25:20,320 --> 00:25:22,510
13200,13680 13680,14340 14550,14970 14970,15060 15060,15390
windows here.| What's the difference
|.asm.s文件之间有什么不同。

808
00:25:22,510 --> 00:25:24,880
15390,15690 15720,15900 15900,16740 16740,17550
between .asm .S files.|
|嗯，不是百分之百确定，它们都是程序集我认为.asm文件包含了一堆没有包含在.S中的额外注释，

809
00:25:25,170 --> 00:25:26,220
90,900
Um,

810
00:25:27,150 --> 00:25:29,310
690,990 990,1050 1050,1290 1290,1770 2010,2850
not one hundred percent certain,

811
00:25:29,430 --> 00:25:31,110
2970,3330 3330,3780 3780,4320 4320,4440 4440,4650
they're both assembly I think

812
00:25:31,110 --> 00:25:32,700
4650,4860 4860,5970 5970,6240
the .asm file

813
00:25:32,700 --> 00:25:33,810
6240,6600 6600,6660 6660,6930 6930,7020 7020,7350
includes a bunch of extra

814
00:25:33,810 --> 00:25:35,490
7350,8040 8040,8280 8280,8490 8490,8940 8940,9030
annotations that aren't included in

815
00:25:35,490 --> 00:25:37,260
9030,9660 9930,10170 10170,10500 10500,10620 10620,10800
.S,| so usually when you
|所以通常当你把你的C代码编译成.S时，你会得到一些不包括所有行号之类的东西，

816
00:25:37,260 --> 00:25:39,030
10800,11250 11250,11400 11400,11610 11610,12030 12030,12570
compile your C code to

817
00:25:39,940 --> 00:25:41,110
0,630 630,750 750,900 900,1050 1050,1170
.S, you'll end up with

818
00:25:41,110 --> 00:25:42,940
1170,1860 1950,2190 2190,2460 2460,2760 2760,3000
something that doesn't include all

819
00:25:42,940 --> 00:25:44,140
3000,3240 3240,3480 3480,3870 3870,3990 3990,4200
those line numbers and things

820
00:25:44,140 --> 00:25:45,140
4200,4380 4380,4650 4650,4980
like that,| So,
|所以，如果你想知道我们是如何获得.asm文件的

821
00:25:45,630 --> 00:25:46,560
90,240 240,360 360,690 690,870 870,1020
if you're curious about how

822
00:25:46,560 --> 00:25:47,700
1020,1110 1110,1380 1380,1890 1890,2160
we get .asm file|
|我想Makefile会告诉你获得它的确切步骤。

823
00:25:47,700 --> 00:25:48,780
2160,2250 2250,2370 2370,2460 2460,3240
I think the makefile,

824
00:25:49,050 --> 00:25:50,460
4050,4230 4230,4440 4440,4800 4800,4920
will tell you the

825
00:25:50,460 --> 00:25:51,520
4920,5280 5280,5850
exact steps,

826
00:25:51,630 --> 00:25:53,460
150,540 540,630 630,810 810,1050
used to get that.|
|所以如果我们在航站楼，我们有两个，两个窗口，

827
00:25:55,960 --> 00:25:57,790
120,270 270,840 1020,1380 1380,1860 1860,1950
And so if we're in

828
00:25:57,790 --> 00:25:58,570
1950,2040 2040,2400 2400,2490 2490,2640 2640,2730
our terminal, we have our

829
00:25:58,570 --> 00:26:00,790
2730,3360 3660,3930 3930,4620 4740,4950
two, two windows,| so
|因此，首先要做的当然是启动并运行QEMU。

830
00:26:00,790 --> 00:26:01,690
4950,5040 5040,5310 5310,5430 5430,5490 5490,5850
the first thing to do

831
00:26:01,690 --> 00:26:04,360
5850,6060 6060,6150 6150,6630 7680,8520
is of course get

832
00:26:04,360 --> 00:26:06,360
8520,9120 9120,9300 9300,9420 9420,9960
QEMU up and running.|
|所以GDB。在gdb模式下启动，所以现在我们在这里冻结，然后我们可以启动gdb。

833
00:26:06,630 --> 00:26:08,120
90,540 540,1050
So gdb.

834
00:26:08,460 --> 00:26:10,110
60,660 660,1020 1020,1440 1440,1710
Started within gdb mode,

835
00:26:10,110 --> 00:26:11,850
1710,1830 1830,2010 2010,2520 2520,2880 2880,3450
so now we're frozen here

836
00:26:11,880 --> 00:26:12,870
3480,3750 3750,3870 3870,3960 3960,4080 4080,4470
and then we can start

837
00:26:12,870 --> 00:26:14,000
4470,5070
gdb.|
|弗兰斯教授上周展示的，我想有些人很兴奋，你输入Tui Enable，你会得到一个很好的窗口，这个窗口现在是空的，但在你调试时会很有用，

838
00:26:15,990 --> 00:26:17,640
150,360 360,780 780,1050 1050,1350 1350,1800
And what what what what

839
00:26:18,090 --> 00:26:20,220
2250,2700 2700,3060 3060,3510 3510,3900 3900,4380
professor Frans showed last week,

840
00:26:20,550 --> 00:26:21,750
5160,5490 5490,5610 5610,5760 5760,5910
which I think some

841
00:26:21,750 --> 00:26:23,490
5910,6120 6120,6570 6600,7140 7140,7260 7260,7650
people were excited, you typed

842
00:26:23,490 --> 00:26:25,170
7650,8160 8160,8730 8730,8880 8880,9090 9090,9330
tui enable, you get this

843
00:26:25,170 --> 00:26:26,910
9330,9840 9900,10440 10440,10620 10620,10740 10740,11070
nice window which is empty

844
00:26:26,910 --> 00:26:27,840
11070,11220 11220,11490 11490,11670 11670,11790 11790,12000
for now but will come

845
00:26:27,840 --> 00:26:29,580
12000,12360 12420,12870 12870,13440 13440,13620 13620,13740
in quite useful as you're

846
00:26:29,580 --> 00:26:31,260
13740,14310 14550,14910 14910,15030 15030,15180 15180,15420
debugging,| so we can set
|所以我们可以设置一个断点，我应该注意到所有这些代码都在内核中，没有一个在用户空间，

847
00:26:31,260 --> 00:26:32,610
15420,15510 15510,15780 15780,16170 16170,16650 16650,16770
a break point and I

848
00:26:32,610 --> 00:26:33,810
16770,16980 16980,17220 17220,17460 17460,17670 17670,17970
should note that all this

849
00:26:33,810 --> 00:26:35,460
17970,18540 18540,18840 18840,19140 19140,19530 19530,19620
code is living inside the

850
00:26:35,460 --> 00:26:36,330
19620,19950 19950,20130 20130,20190 20190,20340 20340,20490
kernel, none of this is

851
00:26:36,330 --> 00:26:37,680
20490,20610 20610,20850 20850,21330 21600,21780 21780,21840
in user space,| so we
|所以我们在设置断点时没有任何烦人的问题，

852
00:26:37,680 --> 00:26:38,370
21840,22050 22050,22170 22170,22320 22320,22410 22410,22530
don't have any of those

853
00:26:38,370 --> 00:26:40,170
22530,22860 22860,23340 23340,23580 23580,23820 23820,24330
annoying problems setting break points,|
|所以我可以在函数sum_to中设置一个断点，然后继续运行。

854
00:26:40,410 --> 00:26:41,010
24570,24750 24750,24810 24810,24930 24930,25110 25110,25170
so I can set a

855
00:26:41,010 --> 00:26:43,110
25170,25470 25470,25980 26250,26670 26700,26820 26820,27270
break point in the function

856
00:26:43,110 --> 00:26:44,940
27270,28140 28410,28740 28740,28920 28920,29100
sum_to and then just

857
00:26:44,940 --> 00:26:46,160
29100,29460 29460,30000
continue running.|
|现在就运行该函数，这样您在Tui中看到的第一个窗口就是源窗口。

858
00:26:47,300 --> 00:26:50,000
1200,1710 1710,1950 1950,2490 3210,3420 3420,3900
Run that function and now,

859
00:26:50,000 --> 00:26:52,010
4380,5040 5220,5400 5400,5700 5700,5910
so the first window

860
00:26:52,010 --> 00:26:53,120
5910,6030 6030,6210 6210,6540 6540,6720 6720,7380
that you see in tui

861
00:26:53,120 --> 00:26:55,880
7380,8070 8070,8580 8640,9240 9240,9780
is the source window.|
|是的，正如David所说，kernel.asm左边的那些数字真的很有用

862
00:26:57,270 --> 00:26:58,800
450,960 1020,1230 1230,1530 1530,1620
Yes, as David is

863
00:26:58,800 --> 00:27:00,360
1620,1920 1920,2460 2460,2760 2760,3060 3060,3180
saying those those numbers on

864
00:27:00,360 --> 00:27:01,380
3180,3300 3300,3600 3600,3690 3690,3990 3990,4830
the left of kernel .asm

865
00:27:01,380 --> 00:27:03,060
4830,5310 5400,5880
are really

866
00:27:03,060 --> 00:27:05,730
5880,6360 6360,6660 6660,7500 7530,8160 8160,8550
useful| when you're debugging things
|当你调试东西的时候，你得到一个地址，它会告诉你，所以你现在可以看到，即使在这里，我们也可以看到PC的程序在gdb里。是程序计数器，

867
00:27:05,730 --> 00:27:07,020
8550,8670 8670,8790 8790,8970 8970,9060 9060,9840
and you get an address

868
00:27:07,500 --> 00:27:08,370
10320,10620 10620,10830 10830,10950 10950,11040 11040,11190
it'll tell you, so you

869
00:27:08,370 --> 00:27:10,080
11190,11340 11340,11550 11550,12120 12150,12570 12570,12900
can see now even here

870
00:27:10,080 --> 00:27:10,800
12900,13020 13020,13170 13170,13380 13380,13530 13530,13620
we can see that the

871
00:27:10,800 --> 00:27:12,270
13620,14100 14100,14190 14190,14670 14670,14940 14940,15090
programs of PC here in

872
00:27:12,270 --> 00:27:13,200
15090,15750
gdb.

873
00:27:13,420 --> 00:27:14,800
120,390 390,480 480,810 810,1260 1260,1500
Is the program counter,| so
|所以我们可以看到这个地址是八零零，以此类推。

874
00:27:14,800 --> 00:27:15,910
1500,1650 1650,1800 1800,1950 1950,2160 2160,2610
we can see this address

875
00:27:15,910 --> 00:27:17,320
2610,2790 2790,3060 3060,3630 3630,3870 3870,4020
eight zero zero so on

876
00:27:17,320 --> 00:27:18,460
4020,4140 4140,4350 4350,4920
and so forth.|
|如果我们进入kernel.asm，

877
00:27:18,540 --> 00:27:20,370
510,780 780,930 930,1320 1320,1950
If we go into

878
00:27:20,370 --> 00:27:21,660
1950,2790,3240
kernel.asm,|
|我们搜索那个具体的地址，我们可以看到它是，

879
00:27:21,870 --> 00:27:22,950
3450,3660 3660,3780 3780,4170 4170,4320 4320,4530
and we search for that

880
00:27:22,950 --> 00:27:25,020
4530,5010 5010,5820 5850,6090 6090,6300 6300,6600
specific address, we can see

881
00:27:25,020 --> 00:27:26,140
6600,6780 6780,6990 6990,7470
that it's the,|
|嗯，它出现了两次，因为函数调用，

882
00:27:26,860 --> 00:27:28,540
120,750 810,1200 1200,1410 1410,1560 1560,1800
um, it comes up twice

883
00:27:28,540 --> 00:27:29,950
1800,2010 2010,2100 2100,2460 2460,2880 3000,3210
because the function call,| but
|但是如果我们看这里，这就是那个地址，它是SUM_TO函数的顶部。

884
00:27:29,950 --> 00:27:31,000
3210,3390 3390,3510 3510,3750 3750,4080 4080,4260
if we look here, this

885
00:27:31,000 --> 00:27:32,470
4260,4320 4320,4530 4530,5310 5400,5640 5640,5730
is that address, it's the

886
00:27:32,470 --> 00:27:33,370
5730,6000 6000,6120 6120,6210 6210,6630
top of the sum_to

887
00:27:33,370 --> 00:27:34,240
6630,7230
function.|
|所以如果你在任何时候看到这些东西，嗯，

888
00:27:34,760 --> 00:27:36,170
120,480 480,690 690,870 870,1290 1290,1530
So if you see any

889
00:27:36,170 --> 00:27:37,070
1530,1830 1830,1980 1980,2100 2100,2310 2310,2430
time you see one of

890
00:27:37,070 --> 00:27:39,050
2430,2940 2970,3660 3840,4020 4020,4110 4110,4410
these, um,| all the kernel
|所有内核地址看起来都像0x8000，有些数字。

891
00:27:39,050 --> 00:27:40,640
4410,4830 4830,4980 4980,5130 5130,5490 5490,6000
addresses will look something like

892
00:27:40,670 --> 00:27:42,080
6030,6240
a

893
00:27:42,080 --> 00:27:43,480
6240,8400
0x8000,

894
00:27:43,650 --> 00:27:45,340
630,870 870,1620
some numbers.|
|这些地址您可以直接跳转到kernel.asm并找到发生问题的确切装配线，

895
00:27:46,240 --> 00:27:48,730
180,1140 1140,2070 2070,2220 2220,2370 2370,2670
Those addresses you can jump

896
00:27:48,730 --> 00:27:50,410
2670,3000 3000,3360 3360,4230 4230,4350
straight into kernel.asm and

897
00:27:50,410 --> 00:27:52,570
4350,4650 4650,4740 4740,5370 5460,6300 6300,6510
find the exact line of

898
00:27:52,570 --> 00:27:53,710
6510,6900 6900,7080 7080,7170 7170,7530 7530,7650
assembly where the problem is

899
00:27:53,710 --> 00:27:54,670
7650,8130 8130,8250 8250,8370 8370,8490 8490,8610
occurring,| and then you can
|然后你可以相应地设置你的断点，

900
00:27:54,670 --> 00:27:56,050
8610,8790 8790,8910 8910,9120 9120,9360 9360,9990
set your break points accordingly,|
|但就目前而言，途易的顶部窗口是源窗口，

901
00:27:56,410 --> 00:27:58,120
10350,10710 10710,10800 10800,11220 11700,12060
but for now, the

902
00:27:58,120 --> 00:28:00,100
12060,12390 12390,12870 12870,13080 13080,13710 13710,14040
top window in tui is

903
00:28:00,100 --> 00:28:01,750
14040,14640 14640,14790 14790,14940 14940,15330 15360,15690
source,| and if we want
|如果我们想要具体查看组件，我们可以在GDB ASM中进行布局，

904
00:28:01,750 --> 00:28:03,790
15690,15870 15870,16110 16110,16530 16920,17580 17580,17730
to look at specifically the

905
00:28:03,790 --> 00:28:05,500
17730,18210 18210,18330 18330,18420 18420,18630 18630,19440
assembly we can do layout

906
00:28:05,950 --> 00:28:08,230
19890,20280 20280,21180 21180,21690 21990,22170
in gdb asm,| and
|这会给我们所有的组装说明

907
00:28:08,230 --> 00:28:09,520
22170,22650 22650,22830 22830,23160 23160,23370 23370,23460
that'll give us all of

908
00:28:09,520 --> 00:28:11,920
23460,23550 23550,24000 24000,24810 25080,25560
the assembly instructions| and,
|如果我们输入Layout reg，我们还可以查看寄存器，我们将得到汇编和寄存器

909
00:28:11,920 --> 00:28:13,060
25860,26010 26010,26130 26130,26700 26700,26940 26940,27000
we can also look at

910
00:28:13,060 --> 00:28:14,200
27000,27120 27120,27720 27720,27810 27810,27900 27900,28140
the registers if we type

911
00:28:14,200 --> 00:28:15,910
28140,28470 28470,28770 28770,28860 28860,29130 29130,29850
layout reg, we'll get assembly

912
00:28:16,180 --> 00:28:18,070
30120,30510 30510,31320 31560,31770 31770,31890 31890,32010
and registers| and if you
|如果你发现自己要浏览什么东西。

913
00:28:18,070 --> 00:28:19,660
32010,32190 32190,32640 32640,33120 33120,33270 33270,33600
find yourself what to scroll

914
00:28:19,660 --> 00:28:20,820
33600,33840 33840,34530
through things.|
|现在我们有三个窗口，我们需要指定哪个是焦点，

915
00:28:21,410 --> 00:28:22,220
90,330 330,450 450,540 540,660 660,900
Now that we have three

916
00:28:22,220 --> 00:28:23,420
900,1320 1320,1380 1380,1500 1500,1590 1590,2100
windows, we need to specify

917
00:28:23,420 --> 00:28:24,470
2100,2310 2310,2460 2460,2580 2580,3030 3030,3150
which one is focused,| so
|所以如果我想找所有的寄存器，我会聚焦reg。

918
00:28:24,470 --> 00:28:25,100
3150,3240 3240,3300 3300,3480 3480,3540 3540,3780
if I want to look

919
00:28:25,100 --> 00:28:26,120
3780,3930 3930,4050 4050,4110 4110,4680 4680,4800
for all the registers, I'm

920
00:28:26,120 --> 00:28:27,640
4800,4920 4920,4980 4980,5400 5400,5940
going to focus reg.|
|现在我的注意力集中在注册窗口上

921
00:28:28,000 --> 00:28:29,170
120,330 330,600 600,780 780,1170 1170,1290
And now my focus is

922
00:28:29,170 --> 00:28:30,400
1290,1440 1440,1530 1530,1980 1980,2340 2340,2520
on the register window| so
|所以我，移动箭头键或者滚动，你就可以开始滚动那个窗口了。

923
00:28:30,400 --> 00:28:30,920
2520,2790
I,

924
00:28:31,420 --> 00:28:32,680
0,390 390,480 480,750 750,1170 1170,1260
move the arrow keys or

925
00:28:32,680 --> 00:28:34,510
1260,1890 1980,2250 2250,2490 2490,2880 2880,3090
scroll you'll start scrolling that

926
00:28:34,510 --> 00:28:35,160
3090,3540
window.|
|现在，我们可以将注意力集中在装配窗口上。

927
00:28:35,660 --> 00:28:37,010
480,780 780,900 900,1050 1050,1440 1440,1830
Now we can focus on

928
00:28:37,520 --> 00:28:38,980
2340,2520 2520,2970 2970,3630
the assembly window.|
|一旦我们到了这里，我们就可以看到所有的东西，

929
00:28:39,580 --> 00:28:40,480
180,420 420,600 600,690 690,960 960,1080
And once we're here, we

930
00:28:40,480 --> 00:28:41,230
1080,1200 1200,1440 1440,1620 1620,1710 1710,1830
can see all of the

931
00:28:41,230 --> 00:28:43,300
1830,2400 3240,3450 3450,3690 3690,3900
things,| so let's see,
|让我们看看，我们可以在注册表注册窗口中看到，

932
00:28:43,300 --> 00:28:44,350
3900,4020 4020,4170 4170,4590 4590,4860 4860,4950
we can see in the

933
00:28:44,350 --> 00:28:46,180
4950,5610 5610,6120 6120,6540 6540,6630 6630,6780
registry register window,| we can
|我们可以看到t0包含该值，

934
00:28:46,180 --> 00:28:47,530
6780,6930 6930,7110 7110,7710 7710,8130
see that t0 contains

935
00:28:47,530 --> 00:28:49,060
8130,8370 8370,9090 9150,9450 9450,9540 9540,9660
this value,| we can see
|我们可以看到a0包含这个值。

936
00:28:49,060 --> 00:28:51,250
9660,9840 9840,10440 10440,10890 10890,11130 11130,11850
that a0 contains this value.|
|当我们一步一步走过集合时，我们可以看到，好的，t0刚刚得到了a0的值，也就是5，

937
00:28:51,840 --> 00:28:53,340
120,570 570,870 870,1020 1020,1350 1350,1620
And as we step through

938
00:28:53,340 --> 00:28:55,140
1620,1770 1770,2400 2400,2520 2520,2760 2760,3420
the assembly, we can watch,

939
00:28:55,170 --> 00:28:57,810
3450,3810 3810,4410 5430,6090
say OK, t0

940
00:28:57,810 --> 00:28:58,890
6090,6390 6390,6630 6630,6720 6720,7050 7050,7170
just got the value of

941
00:28:58,890 --> 00:29:00,240
7170,7650 7650,7800 7800,8040 8040,8430 8430,8520
a0 which was five,| and
|它很好地突出了已经改变的音域。

942
00:29:00,240 --> 00:29:02,100
8520,8850 8850,9180 9180,9840 9840,9900 9900,10380
it's nicely highlighted the register

943
00:29:02,100 --> 00:29:03,240
10380,10620 10620,11340
that's changed.|
|这里，我们可以记住，如果我们按Enter，我们会得到最近执行的指令，

944
00:29:03,280 --> 00:29:04,810
60,690 810,1170 1170,1260 1260,1380 1380,1590
Here and we can just

945
00:29:04,810 --> 00:29:06,130
1590,1860 1890,2370 2370,2640 2640,2730 2730,2910
keep remember if we push

946
00:29:06,130 --> 00:29:08,020
2910,3300 3300,3420 3420,3630 3630,4140 4230,4800
enter, we get the most

947
00:29:08,020 --> 00:29:09,880
4800,5250 5250,5790 5790,6420 6420,6540 6540,6660
recently executed instructions,| so we
|所以我们可以通过，我们将0设置为0，现在我们可以看着自己经历这个循环和一些值，

948
00:29:09,880 --> 00:29:11,680
6660,6900 6900,7110 7110,7740 7770,8220 8220,8460
can go through, we set

949
00:29:11,680 --> 00:29:13,150
8460,8850 8850,8970 8970,9660 9810,9930
a0 to zero and

950
00:29:13,150 --> 00:29:13,870
9930,10110 10110,10230 10230,10350 10350,10500 10500,10650
now we can just kind

951
00:29:13,870 --> 00:29:15,220
10650,10710 10710,11010 11010,11520 11520,11700 11700,12000
of watch ourselves go through

952
00:29:15,220 --> 00:29:17,740
12000,12210 12210,13020 13230,13710
this loop and

953
00:29:17,890 --> 00:29:20,170
30,360 360,510 510,600 600,1410 2160,2310
some of the values,| and
|然后这就像是一个完整的玩具功能。

954
00:29:20,170 --> 00:29:21,190
2310,2580 2580,2730 2730,2850 2850,3000 3000,3330
then this is like a

955
00:29:21,190 --> 00:29:23,100
3330,3840 3870,4020 4020,4440 4440,4980
complete {you,know} toy function.|
|那就继续过我们的生活吧

956
00:29:23,630 --> 00:29:26,720
570,930 930,1680 1920,2460 3330,3540 3540,3660
Then continue and live our

957
00:29:26,720 --> 00:29:27,590
3660,3990 3990,4110 4110,4200 4200,4320 4320,4530
lives| and if you're ever
|如果你想知道你设置了什么样的断点，或者你忘记了你在做什么，

958
00:29:27,590 --> 00:29:30,530
4530,5040 5040,5760 6630,7050 7050,7320 7320,7470
curious about what kind of

959
00:29:30,530 --> 00:29:31,820
7470,7770 7770,8160 8160,8340 8340,8640 8640,8760
break points, you've set or

960
00:29:31,820 --> 00:29:32,990
8760,8880 8880,9150 9150,9510 9510,9720 9720,9930
you lose track of what

961
00:29:32,990 --> 00:29:34,370
9930,10080 10080,10200 10200,10740 10920,11190 11190,11310
you were doing,| if you
|如果您键入INFO BREAK或BREAKPOINTS，您可以看到您在代码中所说的所有断点，

962
00:29:34,370 --> 00:29:37,040
11310,11580 11580,12360 12780,13470 13680,13980
type info break or

963
00:29:37,040 --> 00:29:38,990
13980,14880 15000,15330 15330,15480 15480,15930
breakpoints, you can see

964
00:29:38,990 --> 00:29:39,860
15930,16170 16170,16260 16260,16350 16350,16590 16590,16800
all of the break points

965
00:29:39,860 --> 00:29:40,550
16800,16890 16890,17040 17040,17250 17250,17340 17340,17490
that you said in your

966
00:29:40,550 --> 00:29:42,380
17490,18060 18330,18870 19110,19230 19230,19320
code,| and you can
|你甚至可以看到，这个断点已经被击中了一次

967
00:29:42,380 --> 00:29:43,520
19320,19560 19560,19920 19920,20100 20100,20280 20280,20460
even see okay, this break

968
00:29:43,520 --> 00:29:44,510
20460,20670 20670,20820 20820,21090 21090,21240 21240,21450
point has already been hit

969
00:29:44,510 --> 00:29:46,010
21450,21720 21720,22350 22560,22710 22710,22800 22800,22950
one time| and you get
|这样你就能得到很多有用的信息。

970
00:29:46,010 --> 00:29:48,140
22950,23160 23160,23250 23250,23580 23580,24450 24630,25080
lots of useful information doing

971
00:29:48,140 --> 00:29:48,800
25080,25500
that.|
|如果您不想拥有寄存器窗口，但您确实想查看寄存器INFO REG或INFO寄存器或I寄存器

972
00:29:49,410 --> 00:29:50,910
150,630 630,1140 1140,1410 1410,1560 1560,1650
If you don't want to

973
00:29:50,910 --> 00:29:52,080
1650,1830 1830,1890 1890,2340 2340,2730 2730,2820
have the register window, but

974
00:29:52,080 --> 00:29:53,130
2820,2940 2940,3270 3270,3450 3450,3540 3540,3870
you do want to look

975
00:29:53,130 --> 00:29:55,410
3870,4050 4050,4140 4140,5130 5520,6150
at the registers info

976
00:29:55,410 --> 00:29:57,450
6150,6750 6780,7140 7140,7380 7380,8040 8040,8190
reg or info registers or

977
00:29:57,450 --> 00:29:58,620
8190,8550 8550,8850 8850,9030 9030,9240 9240,9360
i registers| or any of
|或者众多gdb缩写中的任何一个都将调出注册窗口。

978
00:29:58,620 --> 00:30:00,880
9360,9720 9780,10560 10560,11370
the numerous gdb

979
00:30:00,980 --> 00:30:02,960
630,1500 1500,1890 1890,2100
shortenings will bring

980
00:30:02,960 --> 00:30:04,130
2100,2250 2250,2340 2340,2670 2670,3000
up the register window.|
|那么，有没有什么关于gdb的问题呢？

981
00:30:05,900 --> 00:30:07,910
780,1740 2130,2400 2400,2550 2550,2610 2610,2790
So with that is there

982
00:30:07,910 --> 00:30:09,050
2790,2970 2970,3090 3090,3210 3210,3420 3420,3930
any are there any questions

983
00:30:09,050 --> 00:30:11,480
3930,4320 4320,5280 5520,5880 5880,6300 6300,6360
about gdb.| Simple ones, I
|简单的问题，我知道已经有很多关于它的照片了，所以现在是问一些简单的问题的好时机，我会展示更多作为gdb的用法，

984
00:30:11,480 --> 00:30:13,280
6360,6510 6510,6690 6690,7080 7920,8160
know it's been, there's

985
00:30:13,280 --> 00:30:14,480
8160,8490 8520,8820 8820,8910 8910,9180 9180,9360
been lots of post some

986
00:30:14,480 --> 00:30:16,310
9360,9720 9720,10050 10050,10200 10200,10560 10860,11190
shots about it so now's

987
00:30:16,310 --> 00:30:17,000
11190,11250 11250,11370 11370,11610 11610,11700 11700,11880
a good time to just

988
00:30:17,000 --> 00:30:19,220
11880,12360 12540,12810 12810,13260 13260,13860 13890,14100
ask some straightforward well I'll

989
00:30:19,220 --> 00:30:21,230
14100,14220 14220,14580 14580,15180 15420,15960 15960,16110
be showing more usage as

990
00:30:21,230 --> 00:30:22,940
16110,16770 16980,17280 17280,17610 17610,17700 17700,17820
gdb,| what command did you
|您使用什么命令打开多个窗口。

991
00:30:22,940 --> 00:30:24,020
17820,18060 18060,18150 18150,18450 18450,18510 18510,18900
use to open the multiple

992
00:30:24,020 --> 00:30:25,220
18900,19380 19380,19530 19530,19680 19680,19920 19920,20610
windows.| So I use tmux,|
|所以我用tmux，|所以我可以从头开始展示，

993
00:30:25,220 --> 00:30:26,510
20700,20940 20940,21000 21000,21150 21150,21390
so I can show

994
00:30:26,510 --> 00:30:28,730
21390,21600 21600,21810 21810,22680 23430,23610
just from scratch,| if
|如果我们去这里，我会打开一个新的航站楼，所以这里只有一个空白的航站楼。

995
00:30:28,730 --> 00:30:30,140
23610,23790 23790,24120 24120,24570 24570,24750 24750,25020
we go here, I open

996
00:30:30,140 --> 00:30:31,730
25020,25080 25080,25230 25230,25920 26130,26340 26340,26610
a new terminal so here's

997
00:30:31,730 --> 00:30:33,080
26610,26760 26760,26820 26820,27150 27150,27720
just a blank terminal.|
|如果您键入emacs，这在雅典娜上是可用的。

998
00:30:33,730 --> 00:30:35,170
570,780 780,900 900,1350 1350,1860 1860,2010
If you typed emacs and

999
00:30:35,170 --> 00:30:36,580
2010,2130 2130,2250 2250,2730 2730,2910 2910,3420
this is available on athena.|
|嗯，我一会儿再回答下一个问题，

1000
00:30:37,150 --> 00:30:38,100
3990,4680
Um,

1001
00:30:40,110 --> 00:30:41,430
90,510 510,840 840,900 900,1080 1080,1410
I'll address the next question

1002
00:30:41,430 --> 00:30:42,660
1410,1500 1500,1560 1560,1980 2160,2400 2400,2640
in a second,| so now
|现在我在tmux，你可以从底部的这个绿色条看出

1003
00:30:42,660 --> 00:30:43,530
2640,2790 2790,2910 2910,3270 3270,3390 3390,3510
I'm in tmux, which you

1004
00:30:43,530 --> 00:30:45,240
3510,3630 3630,3930 3930,4170 4170,4770 4770,5220
can tell by this green

1005
00:30:45,240 --> 00:30:47,310
5220,5610 5610,5730 5730,5820 5820,6450 6630,7290
bar at the bottom| and
|如果你想通过几种方式在tmux中创建多个窗口，

1006
00:30:47,310 --> 00:30:48,810
7290,7440 7440,7590 7590,7980 7980,8370 8370,8790
if you want to get

1007
00:30:48,810 --> 00:30:49,680
8790,9030 9030,9180 9180,9240 9240,9480 9480,9660
so there's a couple ways

1008
00:30:49,680 --> 00:30:50,580
9660,9720 9720,9810 9810,9930 9930,10260 10260,10560
you can do multiple windows

1009
00:30:50,580 --> 00:30:52,230
10560,10680 10680,11790
in tmux,|
|如果是，则可以键入control-bc

1010
00:30:52,230 --> 00:30:53,220
12210,12450 12450,12960
if you're,

1011
00:30:53,300 --> 00:30:55,040
120,420 420,540 540,660 660,1110 1350,1860
so you can type control-b

1012
00:30:55,040 --> 00:30:57,230
1860,2490 2490,2970 3450,3870 3870,4050
c| and I know
|我知道有时候如果你习惯使用emacs会很有意义，

1013
00:30:57,230 --> 00:30:58,580
4050,4260 4260,4920 4920,5070 5070,5220 5220,5400
that sometimes if you're used

1014
00:30:58,580 --> 00:30:59,570
5400,5460 5460,5700 5700,6120 6120,6270 6270,6390
to using emacs that will

1015
00:30:59,570 --> 00:31:00,440
6390,6570 6570,6600 6600,6780 6780,6870 6870,7260
make a lot of sense,|
|但是不使用emacs的普通人，就是先按下控制键，然后按下b，然后按下自己的后奏曲上的c，

1016
00:31:00,440 --> 00:31:03,170
7260,7590 7770,9180 9180,9630 9630,9780 9780,9990
but normal people who don't

1017
00:31:03,170 --> 00:31:05,840
9990,10140 10140,10770 10830,11520 11550,12000 12000,12660
use emacs that's hitting control

1018
00:31:05,840 --> 00:31:07,190
12660,12750 12750,12960 12960,13500 13500,13740 13740,14010
and then b and then

1019
00:31:07,190 --> 00:31:08,480
14010,14400 14400,14790 14790,14940 14940,15060 15060,15300
hitting c on its own

1020
00:31:08,480 --> 00:31:09,950
15300,16080 16140,16470 16470,16590 16590,16770
afterwords,| that will get
|这会给你带来第二个窗口

1021
00:31:09,950 --> 00:31:11,180
16770,16920 16920,17010 17010,17370 17370,17820 17820,18000
you a second window| which
|然后，您可以使用控件b和p在它们之间导航，然后使用控件b和n进行上一步和下一步。

1022
00:31:11,180 --> 00:31:12,590
18000,18120 18120,18240 18240,18420 18420,18900 18900,19410
you can then navigate between

1023
00:31:12,590 --> 00:31:13,910
19410,19560 19560,20070 20070,20400 20400,20550 20550,20730
with control b and then

1024
00:31:13,910 --> 00:31:16,070
20730,21300 21360,21900 21900,22050 22050,22200 22350,22890
p, control b and n

1025
00:31:16,280 --> 00:31:17,750
23100,23310 23310,23490 23490,24000 24000,24120 24120,24570
to go previous and next.|
|是啊，大卫刚刚贴出了emacs的小抄，很有用

1026
00:31:17,810 --> 00:31:18,980
24630,24900 24900,25050 25050,25350 25350,25500 25500,25800
Yeah and David just posted

1027
00:31:18,980 --> 00:31:20,120
25800,25950 25950,26250 26250,26520 26520,26760 26760,26940
that emacs cheat sheet which

1028
00:31:20,120 --> 00:31:21,740
26940,27150 27150,27750 28170,28380 28380,28470 28470,28560
is useful| and if you
|如果你想拆分窗口，我认为它是控件b，然后百分号将会将它们，嗯，垂直地拆分，

1029
00:31:21,740 --> 00:31:22,850
28560,28740 28740,28800 28800,29160 29160,29250 29250,29670
want to split the windows

1030
00:31:22,850 --> 00:31:23,990
29670,29760 29760,29910 29910,30090 30090,30540 30540,30810
I think it's control b

1031
00:31:23,990 --> 00:31:25,370
30810,30900 30900,31170 31200,31320 31320,31770 31770,32190
and then the percent sign

1032
00:31:25,370 --> 00:31:27,380
32190,32310 32310,32640 32640,33090 33300,33960
will split them, um,

1033
00:31:27,900 --> 00:31:30,270
60,960 960,1170 1170,1770 1830,2250 2250,2430
vertically,| and then sign a
|然后签一个双引号，控件b和双引号会水平地将它们分开，

1034
00:31:30,270 --> 00:31:31,950
2430,2820 2820,3210 3210,3540 3540,3810 3810,4110
double, control b and double

1035
00:31:31,950 --> 00:31:34,060
4110,4620 4620,5040 5040,5430 5430,5970
quote will split them

1036
00:31:34,090 --> 00:31:36,370
360,1050 1800,2100 2100,2190 2190,2370
horizontally,| and so that's
|这就是我们如何得到它们的。

1037
00:31:36,370 --> 00:31:37,180
2370,2490 2490,2580 2580,2730 2730,2820 2820,3180
how we get them.| If
|如果我们处于这种状态，我们可以使用控件b和o在窗口之间跳转，

1038
00:31:37,180 --> 00:31:37,870
3180,3330 3330,3420 3420,3570 3570,3780 3780,3870
we're in this state, we

1039
00:31:37,870 --> 00:31:39,460
3870,4020 4020,4170 4170,4500 4500,4950 5130,5460
can use control b and

1040
00:31:39,460 --> 00:31:41,500
5460,5970 6120,6330 6330,6570 6570,6930 6930,7500
o to jump between our

1041
00:31:41,620 --> 00:31:44,440
7620,8370 8940,9120 9120,9810 10110,10350 10350,10440
windows,| so that's that's how
|这就是我为什么有多个窗口的原因

1042
00:31:44,440 --> 00:31:45,790
10440,10530 10530,10770 10770,11160 11160,11670 11670,11790
I got multiple windows| yeah
|是啊，我不在乎。

1043
00:31:45,790 --> 00:31:47,680
11790,11850 11850,11970 11970,12330
I don't care.|
|然后艾哈迈德问，为什么要再次显示汇编地址，而不是C行号。

1044
00:31:47,970 --> 00:31:49,770
330,540 540,990 1020,1530 1530,2130
And then Ahmed asked

1045
00:31:49,770 --> 00:31:51,720
2130,2490 2490,2760 2760,3180 3180,3570 3570,4080
why is displaying assembly addresses

1046
00:31:51,720 --> 00:31:53,010
4080,4500 4500,4860 4860,4920 4920,5130 5130,5370
again instead of C line

1047
00:31:53,010 --> 00:31:55,950
5370,5970 6420,6930 6960,7650 7650,8310
numbers.| So because the
|因为函数，所以如果我们回到汇编函数，这完全是在汇编语言中实现的，而不是用C++实现的

1048
00:31:55,950 --> 00:31:57,060
8310,9150
function,

1049
00:31:58,010 --> 00:31:59,060
750,960 960,1050 1050,1140 1140,1500 1500,1800
so if we go back

1050
00:31:59,060 --> 00:32:01,250
1800,2130 2130,2580 2610,3030 3030,3660 3720,3990
to the assembly function, this

1051
00:32:01,250 --> 00:32:02,930
3990,4110 4110,4530 4530,5040 5040,5130 5130,5670
is implemented entirely in assembly

1052
00:32:02,930 --> 00:32:03,740
5670,5850 5850,6030 6030,6150 6150,6330 6330,6480
and not at all in

1053
00:32:03,740 --> 00:32:04,970
6480,6960 7080,7350 7350,7440 7440,7530 7530,7710
C| and so there just
|所以没有任何与此相关的C行号。

1054
00:32:04,970 --> 00:32:06,500
7710,8010 8010,8250 8250,8820 8820,9030 9030,9240
aren't any associated C line

1055
00:32:06,500 --> 00:32:07,660
9240,9630 9630,9750 9750,10230
numbers for this.|
|如果我们要设置断点，那么如果您键入delete，您将删除所有断点，

1056
00:32:07,850 --> 00:32:10,940
1230,1680 1680,1830 1830,2220 2220,3180
If we were to

1057
00:32:10,940 --> 00:32:13,070
3180,3480 3480,3570 3570,3930 3930,4650 4800,5310
set a break point, so

1058
00:32:13,250 --> 00:32:14,120
5490,5670 5670,5760 5760,5970 5970,6360
if you type delete

1059
00:32:14,120 --> 00:32:14,780
6360,6420 6420,6510 6510,6780 6780,6900 6900,7020
you will delete all your

1060
00:32:14,780 --> 00:32:17,030
7020,7230 7230,7800 8220,8700 8700,8880 8910,9270
break points,| so I cleared
|所以我清理了旧的

1061
00:32:17,030 --> 00:32:17,840
9270,9330 9330,9570 9570,9840 9840,10020 10020,10080
the old one| if I
|如果我现在在演示一中设置一个断点，

1062
00:32:17,840 --> 00:32:19,400
10080,10320 10320,10830 10830,10860 10860,11220 11220,11640
now set a break point

1063
00:32:19,400 --> 00:32:20,840
11640,11940 11970,12330 12330,12750 12750,12870 12870,13080
in demo one,| so that's
|这是一个C断点，继续运行，

1064
00:32:20,840 --> 00:32:22,310
13080,13170 13170,13470 13470,13710 13710,14100 14370,14550
a C break point and

1065
00:32:22,310 --> 00:32:25,190
14550,15420 15900,16110 16110,16290 16290,16920 16980,17430
continue and run this,| now
|现在，如果我在这里输入Layout Split，我会得到C和程序集。

1066
00:32:25,190 --> 00:32:26,120
17430,17580 17580,17670 17670,17850 17850,18210 18210,18360
if I go here and

1067
00:32:26,120 --> 00:32:27,770
18360,18600 18600,18990 18990,19500 19530,19830 19830,20010
type layout split I'll get

1068
00:32:27,770 --> 00:32:29,300
20010,20100 20100,20520 20520,20760 20760,20880 20880,21540
the C and the assembly.|
|嗯，或者如果我只想要C源，我可以做布局源，然后我就到C。

1069
00:32:29,970 --> 00:32:31,020
90,450 450,660 660,750 750,870 870,1140
Um, or if I just

1070
00:32:31,020 --> 00:32:32,040
1140,1380 1380,1470 1470,1680 1680,2070 2070,2160
want to C source, I

1071
00:32:32,040 --> 00:32:33,090
2160,2280 2280,2400 2400,2730 2730,3090 3090,3210
can do layout source and

1072
00:32:33,090 --> 00:32:33,990
3210,3330 3330,3540 3540,3690 3690,3780 3780,4110
I'll just get to C.|
|所以这就是正在发生的事情，

1073
00:32:35,440 --> 00:32:36,640
420,630 630,1020 1260,1470 1470,1620
So that's that's what's

1074
00:32:36,640 --> 00:32:38,170
1620,1860 1860,2070 2070,2160 2160,2400 2400,3150
going on,| it's just a
|这只是一个奇怪的事实，它没有关联的C代码，所以我们看不到C行号。

1075
00:32:38,170 --> 00:32:39,190
3150,3480 3480,3600 3600,3720 3720,4020 4020,4170
quirk of the fact that

1076
00:32:39,190 --> 00:32:40,630
4170,4320 4320,4620 4620,4830 4830,5430 5430,5610
this doesn't have associated C

1077
00:32:40,630 --> 00:32:41,410
5610,5880 5880,6000 6000,6090 6090,6210 6210,6390
code and so we don't

1078
00:32:41,410 --> 00:32:43,100
6390,6570 6570,6840 6840,7050 7050,7560
see C line numbers.|
|关于gdb tmux的任何其他问题，诸如此类的问题。

1079
00:32:46,270 --> 00:32:47,950
90,330 330,810 810,990 990,1110 1110,1770
Any other any other questions

1080
00:32:47,980 --> 00:32:49,900
1800,2280 2280,3270
about gdb

1081
00:32:49,900 --> 00:32:50,960
3330,4590
tmux,

1082
00:32:51,400 --> 00:32:52,720
120,540 540,900 900,1080 1080,1170 1170,1440
and that sort of thing.|
|布局拆分就是用来调出源代码的这个额外窗口，然后完全组装起来的。

1083
00:32:53,080 --> 00:32:54,370
1800,2130 2130,2580 2580,2910 2910,3030 3030,3090
So layout split is the

1084
00:32:54,370 --> 00:32:55,360
3090,3330 3330,3510 3510,3600 3600,3930 3930,4080
one that you use to

1085
00:32:55,360 --> 00:32:56,980
4080,4350 4350,4590 4590,4920 4920,5310 5310,5700
bring up this extra window

1086
00:32:56,980 --> 00:32:58,420
5700,5880 5880,6030 6030,6450 6450,6540 6540,7140
of the source and assembling

1087
00:32:58,420 --> 00:33:00,130
7140,7350 7350,7920 7920,8340 8340,8580 8580,8850
so downright.| Yes yes, so
|是的，所以布局，{if，you，do}布局拆分可以得到源代码和汇编，

1088
00:33:00,130 --> 00:33:02,680
8850,9480 10380,10650 10650,11040 11040,11400
layout, {if,you,do} layout split

1089
00:33:02,680 --> 00:33:04,240
11400,11760 11760,11970 11970,12240 12270,12780 12780,12960
that'll get you source and

1090
00:33:04,240 --> 00:33:05,830
12960,13560 13560,13950 13950,14310 14310,14400 14400,14550
assembly,| layout source will get
|布局源将只为您提供源，

1091
00:33:05,830 --> 00:33:07,330
14550,14640 14640,14880 14880,15450 15450,15960 15960,16050
you just source,| asm will
|ASM将只为您提供组装

1092
00:33:07,330 --> 00:33:08,920
16050,16200 16200,16290 16290,16500 16500,17130 17250,17640
get you just assembly| and
|我想寄存器是它们自己的东西，你可以输入布局注册表。是啊，这会调出收银机，

1093
00:33:08,920 --> 00:33:10,090
17640,17730 17730,18330 18330,18420 18420,18600 18600,18810
the registers are their own

1094
00:33:10,090 --> 00:33:11,260
18810,19020 19020,19260 19260,19350 19350,19620 19620,19980
thing where you type layout

1095
00:33:11,260 --> 00:33:12,860
19980,20460 20460,20580 20580,20880 20880,21360
reg I think. Yeah,

1096
00:33:13,070 --> 00:33:13,880
90,270 270,420 420,660 660,810 810,900
that will bring up the

1097
00:33:13,880 --> 00:33:16,790
900,1560 1560,1860 2280,3240 3240,3540 3540,3810
registers,| but unfortunately I don't
|但不幸的是，除了在布局拆分中使用{info，reg}之外，我不知道有什么方法可以同时注册程序集和C代码。

1098
00:33:16,790 --> 00:33:17,750
3810,4200 4200,4290 4290,4380 4380,4620 4620,4770
know of a way to

1099
00:33:17,750 --> 00:33:18,580
4770,5280
get

1100
00:33:18,750 --> 00:33:20,190
90,210 210,630 630,780 780,1350 1350,1530
to register the assembly and

1101
00:33:20,190 --> 00:33:21,060
1530,1590 1590,1800 1800,2130 2130,2310 2310,2400
the C code all at

1102
00:33:21,060 --> 00:33:22,230
2400,2460 2460,2730 2730,3120 3120,3480 3480,3570
the same time outside of

1103
00:33:22,230 --> 00:33:24,180
3570,3930 3930,4740 4740,4890 4890,5220 5220,5520
using {info,reg} with layout split.|
|我有个问题，所以当我们把后断点设在右边的时候。

1104
00:33:24,990 --> 00:33:26,910
90,270 270,450 450,510 510,1050 1500,2010
I have a question, so

1105
00:33:26,940 --> 00:33:28,200
2040,2430 2430,2550 2550,2760 2760,2940 2940,3300
when we set the back

1106
00:33:28,200 --> 00:33:30,150
3300,3600 3600,4020 4020,4290 4320,4920 4920,5250
break point at line right.|
|恩。

1107
00:33:30,180 --> 00:33:30,980
5280,5790
um.|
|它显示类似的地址，在这种情况下，断点添加到0x80006354，任何指令可能具有多个，C中的任何代码行可能具有多个指令，

1108
00:33:31,090 --> 00:33:33,340
90,450 450,1050 1050,1260 1260,1950 1980,2340
It displays the address of

1109
00:33:33,340 --> 00:33:34,960
2340,2940 2970,3270 3270,3450 3450,3630 3630,3960
the like in this case

1110
00:33:34,960 --> 00:33:36,040
3960,4230 4230,4530 4530,4680 4680,4950 4950,5040
break point to add to

1111
00:33:36,040 --> 00:33:38,290
5040,7290
0x80006354,

1112
00:33:39,250 --> 00:33:41,110
8250,8700 8790,9060 9060,9660 9660,9900 9900,10110
what any instruction might have

1113
00:33:41,110 --> 00:33:44,170
10110,10950 11640,12150 12210,13080 13080,13170
multiple, any line of

1114
00:33:44,170 --> 00:33:45,550
13170,13470 13470,13590 13590,13890 13890,14370 14370,14550
code in C might have

1115
00:33:45,550 --> 00:33:47,650
14550,14970 14970,15900 15960,16230 16230,16470 16470,16650
multiple instructions,| so which one
|那么到底是哪一个出现了呢。

1116
00:33:47,650 --> 00:33:49,750
16650,17220 17670,18090 18210,18540 18540,18750
does show.| {I,think,it} shows
|{I，Think，It}显示了第一个。

1117
00:33:49,750 --> 00:33:50,720
18750,18840 18840,19110 19110,19320
the first one.|
|而是图-，要求启动途易的人，我想是途易启用不启用途易，对不起。

1118
00:33:51,510 --> 00:33:53,790
690,1020 1020,1830 1920,2640 2640,2970
And it's tu-, for

1119
00:33:53,790 --> 00:33:54,870
2970,3060 3060,3330 3330,3420 3420,3690 3690,4050
the person who asked to

1120
00:33:54,870 --> 00:33:57,180
4050,4410 4410,5340 5850,6180 6180,6360
start tui, it's I

1121
00:33:57,180 --> 00:33:58,890
6360,6510 6510,6630 6630,7170 7170,7740 7770,8070
think it's tui enable not

1122
00:33:58,890 --> 00:34:00,800
8070,8460 8460,8970 8970,9390
enable tui, sorry.|
|我想是的。

1123
00:34:01,070 --> 00:34:04,800
90,270 270,390 390,930 2550,3600
And I think yeah.|
|嗯。

1124
00:34:05,570 --> 00:34:06,000
210,270
Yeah.|
|是的，再一次，这里有一百张GDB和TMUX的小抄，所以如果你发现自己迷路了。

1125
00:34:08,450 --> 00:34:10,520
1470,2010 2010,2400 2400,2670 2670,2820
Yeah again there's a

1126
00:34:10,520 --> 00:34:12,050
2820,3270 3270,3570 3570,3870 3870,4110 4110,4350
hundred cheat sheets out here

1127
00:34:12,050 --> 00:34:14,450
4350,4680 4680,5400 5550,5940 5940,6450 6450,6750
for gdb and for tmux

1128
00:34:14,450 --> 00:34:15,140
6750,6840 6840,7110 7110,7230 7230,7290 7290,7440
as well so if you

1129
00:34:15,140 --> 00:34:16,760
7440,7710 7710,7890 7890,8250 8250,8670 8730,9060
ever find yourself lost.| I
|它，gdb甚至有自己的内置功能它自己的东西叫做合适的，

1130
00:34:16,760 --> 00:34:18,260
9060,9390 9420,10080 10080,10350 10350,10560
t-, gdb even has

1131
00:34:18,260 --> 00:34:19,780
10560,10680 10680,11010 11010,11880
its own inbuilt

1132
00:34:19,770 --> 00:34:22,350
1470,1950 1950,2160 2160,2400 2400,2610
it's own thing called

1133
00:34:22,350 --> 00:34:24,060
2610,3240 3810,4050 4050,4200 4200,4320
apropos,| so if you
|所以如果你想找合适的途易，

1134
00:34:24,060 --> 00:34:26,490
4320,4530 4530,4680 4680,5370 5370,6750
look for apropos tui,|
|它实际上会向您显示所有涉及Tui的命令。

1135
00:34:26,520 --> 00:34:28,080
6780,7200 7200,7560 7560,7830 7830,8100 8100,8340
it'll actually show you all

1136
00:34:28,080 --> 00:34:30,450
8340,8490 8490,8760 8760,9840 9870,10440
of the commands that

1137
00:34:30,450 --> 00:34:32,160
10710,11400 11400,12240
involve tui.|
|所以，是的，这可能非常有用，但也可能有一点令人不知所措。

1138
00:34:33,310 --> 00:34:35,350
90,720 780,1530 1710,2010 2010,2130
So yeah, this can

1139
00:34:35,350 --> 00:34:36,580
2130,2250 2250,2520 2520,3030 3030,3180 3180,3360
be quite useful, but it

1140
00:34:36,580 --> 00:34:37,390
3360,3480 3480,3750 3750,3870 3870,3960 3960,4170
can also be a little

1141
00:34:37,390 --> 00:34:39,720
4170,4380 4380,5190
bit overwhelming.|
|如果你这样做了，我想它会给你提供更多的信息。

1142
00:34:39,820 --> 00:34:40,930
120,330 330,450 450,570 570,750 750,1230
If you do I apropos

1143
00:34:40,930 --> 00:34:42,040
1230,1680 1680,1920 1920,2040 2040,2220 2220,2340
that it will give you

1144
00:34:42,040 --> 00:34:43,780
2340,2550 2550,2880 2880,3450 3450,3570 3570,4080
even more information I think.|
|嗯，我不记得了。我我自己不经常用它，

1145
00:34:44,610 --> 00:34:46,900
90,720 1110,1140 1170,1770 1770,2280
Um I don't remember.

1146
00:34:47,360 --> 00:34:48,410
120,360 360,720 720,930 930,1080 1080,1170
I I don't use it

1147
00:34:48,410 --> 00:34:49,820
1170,1470 1470,1920 1920,2070 2070,2460 2460,2580
often myself,| but if you
|但是如果您找到或忘记了在GBB中键入命令的确切方式

1148
00:34:49,820 --> 00:34:51,320
2580,2850 2850,3300 3450,3720 3720,3810 3810,4080
do find or if you

1149
00:34:51,320 --> 00:34:52,250
4080,4380 4380,4440 4440,4830 4830,4920 4920,5010
forget the exact way to

1150
00:34:52,250 --> 00:34:53,870
5010,5220 5220,5310 5310,5820 5820,6240 6240,6630
type the command in gbb|
|你不会觉得谷歌

1151
00:34:53,870 --> 00:34:54,470
6630,6720 6720,6810 6810,6990 6990,7110 7110,7230
and you don't feel like

1152
00:34:54,470 --> 00:34:56,630
7230,7620 7620,7710 7710,8280 8610,9150 9150,9390
google| and apropos will will
|恰如其分的会经常能够找到你正在寻找的东西，

1153
00:34:56,630 --> 00:34:58,040
9390,10080 10080,10230 10230,10410 10410,10530 10530,10800
often be able to find

1154
00:34:58,040 --> 00:34:59,300
10800,11220 11220,11340 11340,11460 11460,11760 11760,12060
exactly what you're looking for,|
|除了你要找的一大堆东西之外。

1155
00:34:59,300 --> 00:35:00,140
12060,12180 12180,12540 12540,12660 12660,12720 12720,12900
in addition to a whole

1156
00:35:00,140 --> 00:35:00,950
12900,13110 13110,13200 13200,13470 13470,13620 13620,13710
bunch of stuff you are

1157
00:35:00,950 --> 00:35:01,840
13710,14010 14010,14280
looking for.|
|

1158
00:35:02,240 --> 00:35:03,120
180,660
|
|是的，所以这实际上是非常有用的，gdb也有非常好的文档记录。

1159
00:35:04,260 --> 00:35:05,670
120,510 510,720 720,1230 1230,1320 1320,1530
Yeah, so this is actually

1160
00:35:05,670 --> 00:35:07,290
1530,1770 1770,1980 1980,2520 2520,2640 2640,3150
quite useful, gdb is extremely

1161
00:35:07,290 --> 00:35:08,910
3150,3360 3360,3900 3900,4020 4020,4290 4320,4770
well documented as well| so
|所以，嗯，是的，如果你发现自己迷路了，你知道的。谷歌是你的朋友。

1162
00:35:09,150 --> 00:35:10,590
5010,5400 5790,5910 5910,6180 6180,6270 6270,6450
um, yeah, if you ever

1163
00:35:10,590 --> 00:35:12,630
6450,6630 6630,6960 6960,7440 7980,8160 8160,8490
find yourself lost, you know.

1164
00:35:12,930 --> 00:35:14,380
90,570 570,630 630,750 750,1140
Google is your friend.|
|

1165
00:35:15,070 --> 00:35:16,240
330,1140
|
|所以现在我们有点过度组装和RISC-V以及诸如此类的东西

1166
00:35:16,800 --> 00:35:18,000
120,330 330,480 480,600 600,1110 1110,1320
So now that we've kind

1167
00:35:18,000 --> 00:35:20,220
1320,1410 1410,1560 1560,2130 2130,3000 3000,3540
of been over assembly and

1168
00:35:20,220 --> 00:35:22,050
3540,3930 3930,4860 4860,5190 5190,5370
and RISC-V and these

1169
00:35:22,050 --> 00:35:23,190
5370,5550 5550,5640 5640,6060 6120,6360 6360,6510
sort of things| I want
|我想更深入地了解一下你们在即将到来的实验中真正需要知道的细节

1170
00:35:23,190 --> 00:35:23,910
6510,6570 6570,6810 6810,6870 6870,7050 7050,7230
to dive a little bit

1171
00:35:23,910 --> 00:35:26,430
7230,7560 7560,7740 7740,7860 7860,8820 9060,9750
more into the specifics of

1172
00:35:26,430 --> 00:35:28,020
9750,10050 10050,10740 10740,10980 10980,11190 11190,11340
what you you really need

1173
00:35:28,020 --> 00:35:30,090
11340,11430 11430,11790 11790,12180 12180,12600 12900,13410
to know for the lab

1174
00:35:30,090 --> 00:35:32,250
13410,13740 13740,14130 14310,14580 14580,15060 15060,15570
coming up| and also it'll
|另外，这也是文件中的一小部分回顾

1175
00:35:32,250 --> 00:35:32,820
15570,15660 15660,15720 15720,15900 15900,16020 16020,16140
be a little bit of

1176
00:35:32,820 --> 00:35:34,050
16140,16470 16470,16650 16650,16740 16740,17220 17220,17370
review from the document| that
|当然，你们勤奋的学生为了准备这堂课已经通读了一遍。

1177
00:35:34,050 --> 00:35:36,300
17370,17580 17580,18180 18180,18570 18570,18990 18990,19620
you've of course, diligent students

1178
00:35:36,720 --> 00:35:38,760
20040,20430 20430,20910 20940,21750
read through thoroughly

1179
00:35:38,890 --> 00:35:41,200
810,1140 1140,1830 1830,1980 1980,2400
in preparation for this

1180
00:35:41,200 --> 00:35:42,240
2400,2910
lecture.|
|嗯，所以是的，这张桌子你们当然会非常熟悉

1181
00:35:42,700 --> 00:35:45,160
120,750 1320,1800 1800,1980 1980,2160 2160,2580
Um, so yeah, this table

1182
00:35:45,160 --> 00:35:46,270
2580,2730 2730,2820 2820,3150 3150,3450 3450,3690
will of course be a

1183
00:35:46,270 --> 00:35:47,860
3690,4140 4140,4530 4530,4650 4650,4800 4800,5280
wildly familiar to you all|
|从双四和你读到的来看，

1184
00:35:47,860 --> 00:35:50,500
5280,5910 6990,7440 7440,7740 7740,7920
and from from both

1185
00:35:50,500 --> 00:35:51,670
7920,8250 8250,8640 8640,8790 8790,8940 8940,9090
double four and from what

1186
00:35:51,670 --> 00:35:53,230
9090,9300 9300,9690 9780,10230 10230,10410 10410,10650
you've read,| and this is
|这是登记表

1187
00:35:53,230 --> 00:35:55,060
10650,10740 10740,11250 11250,11460 11460,12090 12090,12480
the table of registers| and
|而寄存器是CPU上预定义的处理器周围的小位置

1188
00:35:55,150 --> 00:35:59,200
12570,13470 13470,14130 14160,14760 14790,16110 16110,16620
registers are little locations on

1189
00:35:59,200 --> 00:36:02,110
16620,16860 16860,17760 17820,18540 18540,18630 18630,19530
the CPU around the processor

1190
00:36:02,640 --> 00:36:04,710
60,1050 1050,1350 1350,1470 1470,1680 1680,2130
predefined| that it can use
|它可以用来存储值，这一点很重要

1191
00:36:04,710 --> 00:36:06,870
2130,2400 2400,2880 2880,3600 3750,4140 4140,4290
to store values and this

1192
00:36:06,870 --> 00:36:09,600
4290,4380 4380,4830 4830,5400 5430,6060 6060,7020
is important| because assembly operations
|因为汇编操作，如果我们记得汇编代码，JET汇编不是在内存上操作，它是在寄存器上操作，所以当我们做加法时，当我们做减法时，我们就是在寄存器上操作。

1193
00:36:09,600 --> 00:36:10,590
7020,7440 7440,7560 7560,7830 7830,7950 7950,8010
if we remember from the

1194
00:36:10,590 --> 00:36:12,600
8010,8340 8340,8760 8910,9180 9180,9570 9600,10020
assembly code, the jet assembly

1195
00:36:12,600 --> 00:36:14,250
10020,10350 10350,10860 10860,11130 11130,11520 11520,11670
doesn't operate on memory, it

1196
00:36:14,250 --> 00:36:15,750
11670,12150 12150,12300 12300,12780 12780,12990 12990,13170
operates on register, so when

1197
00:36:15,750 --> 00:36:16,650
13170,13290 13290,13500 13500,13860 13860,13980 13980,14070
we do add when we

1198
00:36:16,650 --> 00:36:18,990
14070,14190 14190,14820 14910,15210 15210,15900 15900,16410
do subtract we're operating on

1199
00:36:18,990 --> 00:36:20,820
16410,17130
registers.|
|所以你经常看到的写组件的模式会有某种负荷，

1200
00:36:21,000 --> 00:36:22,050
120,330 330,510 510,690 690,810 810,1170
And so what you often

1201
00:36:22,050 --> 00:36:24,210
1170,1590 1590,1800 1800,1890 1890,2550 2580,3330
see as the pattern for

1202
00:36:24,240 --> 00:36:25,860
3360,3870 3870,4440 4440,4590 4590,4710 4710,4980
writing assembly is will have

1203
00:36:25,860 --> 00:36:27,270
4980,5220 5220,5490 5490,5640 5640,5700 5700,6390
some kind of a load,|
|所以我们要将一些值加载到寄存器中。

1204
00:36:27,510 --> 00:36:30,060
6630,6930 6930,7230 7230,7800 7800,8160 8160,9180
so we'll load some value

1205
00:36:30,550 --> 00:36:32,360
570,840 840,990 990,1740
to a register.|
|该值可以来自内存，也可以来自另一个寄存器。

1206
00:36:33,030 --> 00:36:34,560
90,780 810,1050 1050,1380 1380,1530 1530,1620
And that value can be

1207
00:36:34,560 --> 00:36:35,550
1620,1770 1770,2280 2280,2430 2430,2520 2520,2610
from memory, or it can

1208
00:36:35,550 --> 00:36:37,600
2610,2730 2730,2910 2910,3660 3660,4380
be from another register.|
|并且，这里泛指LOAD，而不是LOAD指令。

1209
00:36:38,340 --> 00:36:39,930
120,660 1140,1470 1470,1650
And, and here

1210
00:36:39,930 --> 00:36:40,950
1710,1980 1980,2070 2070,2310 2310,2400 2400,2730
referring to load in general,

1211
00:36:40,950 --> 00:36:43,020
2730,2910 2910,3000 3000,3210 3210,3780
not the load instruction.|
|然后我们会操作，所以我们会在寄存器上执行一些操作

1212
00:36:43,420 --> 00:36:45,060
120,360 360,570 570,750 750,1500
And then we'll operate,

1213
00:36:45,780 --> 00:36:47,970
60,300 300,690 690,1110 1110,1290 1290,2250
so we'll perform some operation

1214
00:36:48,090 --> 00:36:49,680
2370,2880 2880,2970 2970,3690 3690,3840 3840,3960
on the register| and then
|如果我们关心返回地址之外的操作结果，我们将，

1215
00:36:49,680 --> 00:36:50,520
3960,4080 4080,4200 4200,4470 4470,4710 4710,4800
if we care about the

1216
00:36:50,520 --> 00:36:52,170
4800,5130 5130,5190 5190,5400 5400,6000 6000,6450
result of that operation outside

1217
00:36:52,170 --> 00:36:54,150
6450,6540 6540,6900 6900,7380 7560,8010 8010,8430
the return address, we will,

1218
00:36:54,150 --> 00:36:54,940
8430,8970
|
|我们会把寄存器存储到某个地方，某个地方，

1219
00:36:55,000 --> 00:36:58,570
120,360 360,1320 1350,1920 1950,2940 2940,3690
we'll store that register to

1220
00:36:58,690 --> 00:36:59,600
3810,4500
somewhere,

1221
00:37:00,590 --> 00:37:01,460
90,270 270,480 480,810 810,960
to some locate,| they
|它们会将该寄存器存储到内存中某个位置或另一个寄存器

1222
00:37:01,460 --> 00:37:02,810
960,1140 1140,1380 1380,1560 1560,2070 2070,2310
will store that register to

1223
00:37:02,810 --> 00:37:06,080
2310,2520 2520,3360 3660,4080 4080,4890 4890,5580
some location in memory or

1224
00:37:06,920 --> 00:37:09,050
180,360 360,690 690,1260 1470,1680 1680,2310
to another register| and that's
|通常情况下，这就是事情的运作方式

1225
00:37:09,050 --> 00:37:10,580
2310,3030 3030,3120 3120,3270 3270,3480 3480,3840
generally the way things work|
|而寄存器是执行任何类型的计算或访问任何值的绝对最快的方式

1226
00:37:10,580 --> 00:37:12,560
3840,4500 4500,5010 5010,5070 5070,5220 5220,5820
and registers are the absolute

1227
00:37:12,560 --> 00:37:14,330
5820,6300 6300,6480 6480,6540 6540,7140 7230,7590
fastest way to perform any

1228
00:37:14,330 --> 00:37:16,010
7590,7770 7770,7830 7830,8670 9090,9270
sort of calculation or

1229
00:37:16,010 --> 00:37:17,420
9270,9330 9330,9870 9870,10080 10080,10560 10560,10680
to access any value| and
|这就是为什么使用它们很重要，也是为什么我们更喜欢使用寄存器而不是过度使用内存的原因，

1230
00:37:17,420 --> 00:37:20,000
10680,10890 10890,11400 12180,12390 12390,12990 12990,13260
that's why it's important to

1231
00:37:20,000 --> 00:37:21,680
13260,13500 13500,13800 13800,13920 13920,14280 14280,14940
use them and also why

1232
00:37:21,770 --> 00:37:24,230
15030,15330 15330,15840 15840,16200 16200,16920 16920,17490
we prefer using registers overusing

1233
00:37:24,230 --> 00:37:25,520
17490,17850 17850,18090 18090,18210 18210,18360 18360,18780
memory,| so if you remember
|如果你们还记得我们调用函数时的读数，所以你们可以看到，这里的寄存器是从0到7。

1234
00:37:25,520 --> 00:37:27,440
18780,19170 19290,19590 19590,20160 20250,20550 20550,20700
from the reading when we

1235
00:37:27,440 --> 00:37:28,730
20700,21030 21030,21600 21600,21690 21690,21840 21840,21990
call functions so you can

1236
00:37:28,730 --> 00:37:30,410
21990,22230 22230,22560 22560,22740 22740,23430 23430,24030
see here that registers a0

1237
00:37:30,410 --> 00:37:31,780
24030,24150 24150,24750
to seven.|
|一般来说，当我们谈到寄存器时，我们会用它们的ABI名称来指代它们，

1238
00:37:32,450 --> 00:37:34,670
210,840 1650,1830 1830,2190 2190,2310 2310,2430
And in general when we

1239
00:37:34,670 --> 00:37:37,310
2430,2670 2670,2940 2940,3600 3600,4170 4380,5070
speak about registers we we

1240
00:37:37,310 --> 00:37:38,780
5070,5430 5460,5850 5850,6300 6300,6390 6390,6540
will be referring to them

1241
00:37:38,780 --> 00:37:40,610
6540,6720 6720,6930 6930,7320 7320,7770
by their ABI name,|
|这不仅减少了混淆，而且只是一个标准，也是编写汇编代码的方式，

1242
00:37:40,820 --> 00:37:42,560
8580,9330 9330,9570 9570,9720 9720,10140 10140,10320
not only is it less

1243
00:37:42,560 --> 00:37:43,760
10320,10740 10740,10860 10860,11070 11070,11130 11130,11520
confusing, it's just a standard

1244
00:37:43,760 --> 00:37:44,540
11520,11640 11640,11760 11760,12030 12030,12150 12150,12300
and it's also the way

1245
00:37:44,540 --> 00:37:45,920
12300,12420 12420,12600 12600,12780 12780,13200 13200,13680
that you'll write assembly code,|
|这个，你知道，这些实际数字并不是特别重要，

1246
00:37:45,950 --> 00:37:47,400
14280,15030
This,

1247
00:37:47,530 --> 00:37:49,030
90,240 240,480 570,900 900,1140 1140,1590
you know, these these actual

1248
00:37:49,030 --> 00:37:50,920
1590,2100 2100,2190 2190,2430 2430,2820 2820,3480
numbers are not super important,|
|唯一有意义的情况是RISC-V指令的压缩版本

1249
00:37:50,980 --> 00:37:52,630
3540,4110 4110,4470 4470,4890 4890,5100 5100,5190
the only case where it

1250
00:37:52,630 --> 00:37:55,390
5190,5490 5490,6030 6030,6750 6780,7710 7740,7950
does matter is for the

1251
00:37:55,390 --> 00:37:57,310
7950,8520 8520,8880 8880,9000 9000,9870
compressed version of RISC-V

1252
00:37:57,310 --> 00:37:59,080
9870,10920 10920,11220 11220,11400 11400,11520 11520,11640
instructions| and if you want
|如果你想了解更多，请随意阅读，

1253
00:37:59,080 --> 00:38:00,130
11640,11700 11700,11850 11850,12030 12030,12330 12330,12690
to know more about that,

1254
00:38:00,190 --> 00:38:01,780
13410,13920 13920,14070 14070,14130 14130,14340
feel free to read

1255
00:38:01,780 --> 00:38:02,770
14340,14490 14490,14760 14760,14910 14910,14970 14970,15330
up about it,| the basic
|基本思想是RISC-V，普通指令是64位

1256
00:38:02,770 --> 00:38:04,510
15330,15960 15960,16140 16140,16350 16350,17070
idea is that RISC-V,

1257
00:38:04,890 --> 00:38:06,810
450,780 780,1290 1290,1410 1410,2010
normal instructions are 64

1258
00:38:06,810 --> 00:38:08,100
2010,2430 2430,2700 2700,2910 2910,3210 3210,3300
bits| but there's also a
|但是也有一个压缩版本，它的指令是16位的，我们使用的寄存器更少

1259
00:38:08,100 --> 00:38:09,720
3300,3750 3750,4140 4140,4350 4350,4830 4830,4920
compressed version, which instructions are

1260
00:38:09,720 --> 00:38:11,370
4920,5430 5430,5850 6030,6240 6240,6330 6330,6570
16 bits and we use

1261
00:38:11,370 --> 00:38:13,290
6570,6870 6870,7620 7740,7980 7980,8070 8070,8490
less registers| and the registers
|在这种情况下，我们使用的寄存器是8到15，这些是我们可以使用的寄存器，

1262
00:38:13,290 --> 00:38:14,580
8490,8640 8640,8880 8880,8970 8970,9210 9210,9780
we use in that case

1263
00:38:14,610 --> 00:38:17,430
9810,10980 11070,11430 11430,11850 11850,12420 12420,12630
are eight through fifteen those

1264
00:38:17,430 --> 00:38:18,150
12630,12690 12690,12780 12780,13140 13140,13290 13290,13350
are the registers that are

1265
00:38:18,150 --> 00:38:19,500
13350,13770 13770,13920 13920,14250 14370,14640 14640,14700
available to us,| so I
|所以我想有人有一个问题，为什么这个S1寄存器是x9

1266
00:38:19,500 --> 00:38:20,610
14700,14910 14910,15240 15240,15360 15360,15450 15450,15810
think somebody had a question

1267
00:38:20,610 --> 00:38:22,410
15810,16410 16470,16980 16980,17130 17130,17400 17400,17940
about why is this s1

1268
00:38:22,410 --> 00:38:24,360
17940,18660 18660,19320 19320,19560
register x9| why
|为什么它要与其他人的所有寄存器分开

1269
00:38:24,360 --> 00:38:26,280
19560,19770 19770,20100 20670,21300 21300,21480
is it, separated from

1270
00:38:26,280 --> 00:38:27,960
21480,21630 21630,21750 21750,21900 21900,22410 22410,23160
all of the other's registers|
|我猜这就是为什么。

1271
00:38:28,050 --> 00:38:29,520
23250,23880 23910,24120 24120,24420 24420,24540 24540,24720
and my guess is that

1272
00:38:29,520 --> 00:38:31,440
24720,24990 24990,25290
that's why.|
|我们将其与所有其他模块分开，因为它在压缩指令模式下可用，

1273
00:38:31,800 --> 00:38:32,940
120,450 450,570 570,960 960,1080 1080,1260
That we separated from all

1274
00:38:32,940 --> 00:38:34,050
1260,1380 1380,1560 1560,1800 1800,2160 2160,2370
the other ones because it's

1275
00:38:34,050 --> 00:38:37,050
2370,3180 3180,3660 3690,4320 4320,4860 4860,5370
available in compressed instruction mode,|
|而S2到11或不是。

1276
00:38:37,080 --> 00:38:38,670
5400,6180 6180,6510 6510,6630 6630,6990
whereas s2 to eleven

1277
00:38:38,670 --> 00:38:39,260
6990,7080 7080,7440
or not.|
|这就是我们的想法，这是一个压缩，但是在该寄存器之外将通过它们的API名称来引用

1278
00:38:40,220 --> 00:38:41,090
120,270 270,360 360,540 540,660 660,990
And so that's the idea,

1279
00:38:41,180 --> 00:38:42,590
1080,1560 1560,1860 1860,1920 1920,2370 2370,2490
that's that's a compress, but

1280
00:38:42,590 --> 00:38:44,330
2490,2820 2820,2880 2880,3210 3270,3990 3990,4230
outside of that register will

1281
00:38:44,330 --> 00:38:45,940
4230,4740 4740,5160 5160,5610
be referred to

1282
00:38:46,020 --> 00:38:48,210
120,570 600,1290 1380,1830 1830,2130 2160,2310
by their API name| and
|因此a0到a7用于函数自变量，

1283
00:38:48,210 --> 00:38:49,560
2310,2580 2580,3090 3090,3180 3180,3660
so a0 to a7

1284
00:38:49,560 --> 00:38:51,180
3660,3810 3810,4080 4080,4260 4260,4620 4620,5280
are used for function arguments,|
|但是如果我们有一个函数，它接受的参数超过8个，这些寄存器允许我们访问。

1285
00:38:51,270 --> 00:38:51,900
5370,5700 5700,5760 5760,5850 5850,5940 5940,6000
but if we have a

1286
00:38:51,900 --> 00:38:53,670
6000,6360 6360,6510 6510,6750 6750,7170 7170,7770
function that takes more than

1287
00:38:53,850 --> 00:38:55,200
7950,8220 8220,8430 8430,8940 8940,9090 9090,9300
the eight arguments that those

1288
00:38:55,200 --> 00:38:57,030
9300,9900 9900,10080 10080,10200 10200,10680 10680,11130
registers give us access to.|
|我们确实需要使用内存

1289
00:38:57,470 --> 00:38:58,580
90,540 540,720 720,930 930,1020 1020,1200
We do need to use

1290
00:38:58,580 --> 00:39:00,080
1200,1620 1620,1770 1770,2130 2520,2700
memory| but that's, this
|但那是，这在某种程度上说明了这样一个事实，当我们可以使用寄存器时，我们不想使用内存。

1291
00:39:00,080 --> 00:39:00,980
2700,2790 2790,2970 2970,3030 3030,3120 3120,3600
is kind of an illustration

1292
00:39:00,980 --> 00:39:01,550
3600,3690 3690,3750 3750,3990 3990,4080 4080,4170
of the fact that we

1293
00:39:01,550 --> 00:39:02,570
4170,4410 4410,4590 4590,4650 4650,4830 4830,5190
don't want to use memory

1294
00:39:02,570 --> 00:39:03,920
5190,5280 5280,5370 5370,5670 5670,5820 5820,6540
when we can use registers.|
|我们只是我们只用了一个内存，我们就得去。

1295
00:39:04,100 --> 00:39:05,570
360,540 540,990 1020,1200 1200,1530
We only we only

1296
00:39:05,570 --> 00:39:07,250
1530,2100 2190,2400 2400,2820 2820,2970 2970,3210
use a memory, we have

1297
00:39:07,250 --> 00:39:08,320
3210,3450
to.|
|这，这一栏，在我们讨论寄存器的时候，这也是非常重要的

1298
00:39:08,790 --> 00:39:10,320
210,420 420,660 660,1050 1050,1440 1440,1740
And this, this column here,

1299
00:39:10,320 --> 00:39:12,360
1740,1830 1830,2250 2250,2910 3600,3780
the saver column, this

1300
00:39:12,360 --> 00:39:14,220
3780,3900 3900,4380 4380,5070 5070,5490 5490,5640
is also extremely important when

1301
00:39:14,220 --> 00:39:16,260
5640,5760 5760,6240 6240,6810 6810,7260 7260,7680
we're discussing registers| caller versus
|呼叫方与被呼叫方已保存。

1302
00:39:16,260 --> 00:39:17,720
7680,8130 8130,8820
callee saved.|
|术语是我经常混淆它们，呼叫者和被呼叫者只有一个字母的区别，

1303
00:39:17,760 --> 00:39:20,940
0,510 1590,2220 2220,2640 2640,3180
And the terms are

1304
00:39:21,060 --> 00:39:23,940
3300,3870 3870,4410 4410,5100 5130,5850 5850,6180
I confuse them regularly, caller

1305
00:39:23,940 --> 00:39:25,080
6180,6300 6300,6660 6660,6840 6840,7050 7050,7320
and callee the only differ

1306
00:39:25,080 --> 00:39:27,360
7320,7470 7470,7710 7710,8190 8250,9030 9030,9600
by one letter,| the easiest
|我找到的记住它们的最简单方法是，调用者保存的寄存器在函数调用期间不会保留。

1307
00:39:27,360 --> 00:39:28,890
9600,9870 9870,10230 10440,10770 10770,11070 11070,11130
way that I've found to

1308
00:39:28,890 --> 00:39:31,110
11130,11520 11520,11790 11790,11940 11940,12390 12450,13350
remember them is that caller

1309
00:39:31,110 --> 00:39:34,240
13350,13890 13890,14850 14880,15420 15420,16260
saved registers are not

1310
00:39:34,410 --> 00:39:35,640
90,1110
preserved

1311
00:39:37,360 --> 00:39:38,740
420,1350
across

1312
00:39:39,830 --> 00:39:41,040
90,240 240,600 600,1110
a function call.|
|所以和被呼叫者，保存寄存器被保留。

1313
00:39:42,190 --> 00:39:45,580
90,810 1110,1590 1590,2100 2100,2460 2460,3480
So and callee, save registers

1314
00:39:46,800 --> 00:39:48,100
120,450 450,1170
are preserved.|
|我的意思是，调用者保存寄存器可以被函数重写，

1315
00:39:49,580 --> 00:39:51,200
0,270 270,360 360,720 720,900 900,1620
What I mean by this,

1316
00:39:52,120 --> 00:39:53,180
120,300 300,900
is that,

1317
00:39:54,500 --> 00:39:57,290
750,1020 1020,1560 1560,1920 1920,2850
a caller save register

1318
00:39:57,350 --> 00:40:00,920
2910,3360 3360,3630 3630,4710 4740,5550 5580,6480
can be overwritten by the

1319
00:40:00,950 --> 00:40:02,240
6510,7020 7020,7200 7200,7470 7470,7650 7650,7800
function,| so let's say I
|假设我有调用函数b的函数a，函数a使用的任何寄存器都是调用者保存的。

1320
00:40:02,240 --> 00:40:03,650
7800,7950 7950,8310 8310,8640 8640,8880 8880,9210
have function a which calls

1321
00:40:03,650 --> 00:40:05,900
9210,9600 9600,9930 10260,10680 10680,11190 11190,11460
function b, any registers being

1322
00:40:05,900 --> 00:40:07,310
11460,11880 11880,12030 12030,12480 12480,12720 12720,12870
used by function a that

1323
00:40:07,310 --> 00:40:08,860
12870,12990 12990,13560 13560,14250
are caller saved.|
|调用函数B可以在其被调用时覆盖，

1324
00:40:08,880 --> 00:40:10,680
0,540 540,750 750,1200 1200,1500 1500,1800
Call a function b can

1325
00:40:10,680 --> 00:40:12,240
1800,2400 2400,2580 2580,2640 2640,2850 2850,3360
overwrite when it gets called,|
|我认为回邮地址就是一个很好的例证。

1326
00:40:12,420 --> 00:40:13,350
3540,3840 3840,3960 3960,4140 4140,4200 4200,4470
and I think a good

1327
00:40:13,350 --> 00:40:15,090
4470,5070 5070,5220 5220,5640 5670,6090 6090,6210
illustration of this is the

1328
00:40:15,090 --> 00:40:16,340
6210,6570 6570,7200
return address.|
|因为您知道您可以看到呼叫者保存的回电地址。

1329
00:40:16,320 --> 00:40:17,670
0,780 780,960 960,1080 1080,1230 1230,1350
Because you know you can

1330
00:40:17,670 --> 00:40:19,050
1350,1560 1560,1710 1710,1800 1800,2190 2190,2730
see that the return addresses

1331
00:40:19,050 --> 00:40:20,300
2730,3150 3150,3780
caller saved.|
|这一点很重要，因为每个函数都需要使用返回地址，

1332
00:40:21,170 --> 00:40:23,150
210,540 540,750 750,1230 1230,1710 1740,2190
And that's important because every

1333
00:40:23,150 --> 00:40:24,860
2190,2880 2880,3360 3360,3450 3450,3810 3810,3900
function needs to use the

1334
00:40:24,860 --> 00:40:26,900
3900,4170 4170,4680 4770,5460 5490,5760 5760,5940
return address,| so when a
|因此，当a调用b时，能够覆盖返回地址中的值是很重要的，这就是为什么它的调用者保存的原因。

1335
00:40:26,900 --> 00:40:28,460
5940,6300 6300,6630 6630,6840 6840,7290 7290,7500
calls b it's important that

1336
00:40:28,460 --> 00:40:31,010
7500,7770 7770,7890 7890,8310 8310,8850 8880,10050
be be able to overwrite

1337
00:40:31,040 --> 00:40:32,030
10080,10260 10260,10650 10650,10710 10710,10800 10800,11070
the value in the return

1338
00:40:32,030 --> 00:40:33,560
11070,11520 11550,11880 11880,12060 12060,12240 12240,12600
address, hence why its caller

1339
00:40:33,560 --> 00:40:34,240
12600,13170
saved.|
|而被调用方保存的寄存器只是我们使用的约定，因此帧指针非常重要。

1340
00:40:34,340 --> 00:40:36,830
60,390 390,840 840,1230 1230,2160
And callee saved registers

1341
00:40:36,830 --> 00:40:38,360
2550,2730 2730,2940 3090,3510 3510,4080
are just are convention

1342
00:40:38,360 --> 00:40:40,370
4080,4230 4230,4380 4380,5160 5940,6090
that we use, the

1343
00:40:40,370 --> 00:40:41,990
6090,6390 6390,6810 6810,6960 6960,7560 7560,7710
frame pointer is important for

1344
00:40:41,990 --> 00:40:43,060
7710,7980 7980,8520
that reason.|
|这些寄存器会在函数调用之间保留，所以基本上调用者保存的任何寄存器，

1345
00:40:43,030 --> 00:40:45,430
1140,1500 1500,1830 1830,2100 2100,2430
And those are preserved

1346
00:40:45,430 --> 00:40:46,930
2430,2700 2700,3060 3060,3330 3330,3510 3510,3930
across function calls, so basically

1347
00:40:46,930 --> 00:40:48,250
3930,4110 4110,4530 4530,4650 4650,4740 4740,5250
any register that is caller

1348
00:40:48,250 --> 00:40:49,810
5250,5850 6000,6240 6240,6600 6600,6720 6720,6810
saved,| the function that is
|进行调用的函数需要担心这些寄存器，

1349
00:40:49,810 --> 00:40:50,950
6810,7200 7200,7290 7290,7590 7590,7830 7830,7950
making the call needs to

1350
00:40:50,950 --> 00:40:52,840
7950,8190 8190,8460 8460,8700 8700,9390 9540,9840
worry about those registers,| and
|如果它们是被调用的saver，则被调用的函数需要考虑如何保存这些寄存器中的值。

1351
00:40:52,840 --> 00:40:54,070
9840,9930 9930,10080 10080,10380 10380,11070
if they're callee saver,

1352
00:40:54,070 --> 00:40:55,150
11070,11190 11190,11550 11550,11640 11640,11790 11790,12150
the function that is being

1353
00:40:55,150 --> 00:40:56,890
12150,12690 12750,13170 13170,13290 13290,13560 13560,13890
called needs to worry about

1354
00:40:56,890 --> 00:40:58,240
13890,14370 14370,14430 14430,14850 14850,14970 14970,15240
preserving the value in those

1355
00:40:58,240 --> 00:40:59,020
15240,15930
registers.|
|再一次，你知道，我我经常混淆这两个，然后发现自己回到了这张桌子上，

1356
00:40:59,830 --> 00:41:01,210
150,360 360,690 690,750 750,1050 1140,1530
And again, you know I

1357
00:41:01,210 --> 00:41:03,280
1530,1920 2010,2670 2670,3090 3090,3210 3210,3600
I regularly confuse the two

1358
00:41:03,280 --> 00:41:05,240
3600,4020 4020,4260 4260,4710 4710,5280
and find myself returning

1359
00:41:05,230 --> 00:41:07,220
30,270 270,450 450,1110
to this table,|
|提醒我自己他们是做什么的。

1360
00:41:07,590 --> 00:41:09,660
90,750 900,1410 1410,1770 1770,1980 1980,2160
to remind myself about what

1361
00:41:09,660 --> 00:41:12,560
2160,2280 2280,2700 3660,4290 4290,4770
they do.| And so,
|所以，你知道，如果你记得读到的内容，

1362
00:41:12,670 --> 00:41:13,840
90,270 270,390 390,750 1020,1170 1170,1260
you know you if you

1363
00:41:13,840 --> 00:41:15,190
1260,1530 1530,1680 1680,1770 1770,2280 2310,2610
remember from the reading,| all
|所有这些寄存器都是64位宽，所以它们有64个位置可以放东西

1364
00:41:15,190 --> 00:41:17,320
2610,2700 2700,2880 2880,3660 3660,4020 4020,4740
of these registers are 64

1365
00:41:17,320 --> 00:41:18,760
4740,5160 5160,5700 5700,5820 5820,5940 5940,6180
bits wide, so they have

1366
00:41:18,760 --> 00:41:20,320
6180,6810 6810,7200 7200,7410 7410,7560 7560,7740
64 places where we can

1367
00:41:20,320 --> 00:41:23,260
7740,7980 7980,8520 8670,9780 9930,10200 10200,10680
put things| and the various
|并且基于调用约定使各种数据类型适合于这64位，

1368
00:41:23,260 --> 00:41:24,730
10680,10980 10980,11460 11460,11580 11580,12030 12030,12150
data types are made to

1369
00:41:24,730 --> 00:41:26,710
12150,12450 12450,12720 12720,12960 12960,13590 13590,14130
fit into those 64 bits

1370
00:41:26,800 --> 00:41:28,660
14220,15030 15030,15150 15150,15240 15240,15570 15570,16080
based on the calling convention,|
|所以如果我们有一个32位的整数，取决于它是不是扩展的，

1371
00:41:28,660 --> 00:41:29,200
16080,16260 16260,16380 16380,16470 16470,16560 16560,16620
so if we have a

1372
00:41:29,200 --> 00:41:31,180
16620,17040 17040,17160 17160,17820 18300,18600
32 bit integer, depending

1373
00:41:31,180 --> 00:41:32,230
18600,18690 18690,18870 18870,19350 19350,19590 19590,19650
on how it's whether or

1374
00:41:32,230 --> 00:41:33,940
19650,19830 19830,19980 19980,20160 20160,20970 21030,21360
not it's an extended,| {you,know}
|{您知道}我们将在该整数的前面添加0或1，以便将其设置为64位以放入这些寄存器。

1375
00:41:33,940 --> 00:41:34,930
21360,21510 21510,21720 21720,21900 21900,22260 22260,22350
we'll either add zeros or

1376
00:41:34,930 --> 00:41:36,040
22350,22860 22860,23070 23070,23160 23160,23400 23400,23460
ones to the front of

1377
00:41:36,040 --> 00:41:37,330
23460,23640 23640,23910 24660,24750
that integer, in

1378
00:41:37,330 --> 00:41:38,290
24750,24930 24930,24990 24990,25140 25140,25200 25200,25710
order to make it 64

1379
00:41:38,290 --> 00:41:39,100
25710,25950 25950,26040 26040,26250 26250,26340 26340,26520
bits to put in these

1380
00:41:39,100 --> 00:41:39,920
26520,27180
registers.|
|在我们继续之前，有没有人有关于登记簿或类似性质的问题。

1381
00:41:40,480 --> 00:41:41,860
120,390 390,690 690,840 840,1050 1050,1500
So before we move on,

1382
00:41:41,950 --> 00:41:43,720
1980,2130 2130,2490 2490,2790 2790,3360
does anybody have questions

1383
00:41:43,720 --> 00:41:46,760
3360,3960 4110,5310 5310,5760
about registers or

1384
00:41:46,810 --> 00:41:48,240
90,630 630,720 720,870 870,1290
things of that nature.|
|

1385
00:41:52,940 --> 00:41:53,420
0,390
|
|

1386
00:41:55,140 --> 00:41:55,700
0,330
|
|

1387
00:41:56,000 --> 00:41:56,480
60,390
|
|我有个问题，

1388
00:41:57,950 --> 00:41:59,360
240,600 600,750 750,840 840,1500
I have a question,|
|你能把一个返回值放在A1中吗？

1389
00:41:59,360 --> 00:42:01,400
1500,1740 1740,2250 2280,2790 2790,3300 3390,3540
can you have a can

1390
00:42:01,400 --> 00:42:02,540
3540,3660 3660,3900 3900,3960 3960,4290 4290,4680
you put a return value

1391
00:42:02,540 --> 00:42:04,080
4680,4950 4950,5910
in a1.|
|是的，这是个好问题。

1392
00:42:04,790 --> 00:42:06,050
540,960 960,1080 1080,1140 1140,1290
Yes, that's a good

1393
00:42:06,050 --> 00:42:08,750
1290,1740 1740,2460 3420,3540 3540,3990
question.| So, I think
|所以，我认为(在理论上)你可以，

1394
00:42:08,750 --> 00:42:11,720
3990,4560 4590,5760 5820,6330 6360,6600 6600,6960
{in,theory} you can,| the reason
|我们说a0到a1的原因是，如果函数返回128位的长整型，

1395
00:42:11,720 --> 00:42:13,400
6960,7710 7740,7950 7950,8220 8220,8640
why we say a0

1396
00:42:13,400 --> 00:42:15,080
8640,8820 8820,9510 9660,10200 10200,10320
to a1 is if

1397
00:42:15,080 --> 00:42:16,250
10320,10410 10410,10770 10770,11100 11100,11160 11160,11490
a function returns a long

1398
00:42:16,250 --> 00:42:18,770
11490,12000 12180,12540 12540,12630 12720,13680 13680,14010
long which is 128 bits,|
|所以，如果你记得，如果一个函数参数是100，那就不只是一个指针了。

1399
00:42:18,770 --> 00:42:20,210
14010,14430 14430,14640 14640,14790 14790,15270 15270,15450
so if you remember from

1400
00:42:20,210 --> 00:42:21,800
15450,15570 15570,16110 16320,16620 16620,16710 16710,17040
the reading if a function

1401
00:42:21,800 --> 00:42:23,120
17040,17670 17670,17760 17760,17820 17820,18210 18210,18360
argument is a hundred is

1402
00:42:23,120 --> 00:42:24,800
18360,18600 18600,18870 18870,19230 19230,19800
more than a pointer.|
|当我们引用[字符号]时，我们说的是64位，所以如果我们有两倍于指针字大小的东西。

1403
00:42:24,880 --> 00:42:26,140
60,300 300,570 810,1050 1050,1140 1140,1320
[We're done when we refer]

1404
00:42:26,140 --> 00:42:27,130
1320,1590 1590,1740 1740,1980 1980,2070 2070,2310
[to word sign], we're saying

1405
00:42:27,130 --> 00:42:28,720
2310,2820 2820,3240 3390,3660 3660,3810 3810,3900
64 bits, so if we

1406
00:42:28,720 --> 00:42:29,920
3900,4050 4050,4380 4380,4530 4530,4710 4710,5100
have something that is twice

1407
00:42:29,920 --> 00:42:30,970
5100,5190 5190,5520 5520,5610 5610,5730 5730,6150
the size of a pointer

1408
00:42:30,970 --> 00:42:31,660
6150,6570
word.|
|我们可以将其放入寄存器对中，因此同样的约定也适用于返回地址，如果我们有一个字指针两倍大小的东西，

1409
00:42:32,350 --> 00:42:33,970
720,1050 1050,1230 1230,1440 1440,1710
We can put that

1410
00:42:33,970 --> 00:42:35,650
1710,1800 1800,1920 1920,2370 2370,2910 3060,3390
in a register pair and

1411
00:42:35,650 --> 00:42:37,420
3390,4020 4080,4230 4230,4530 4530,4920 4920,5160
so the same convention holds

1412
00:42:37,420 --> 00:42:38,920
5160,5400 5400,5520 5520,5850 5850,6330 6330,6660
true for return addresses where

1413
00:42:38,920 --> 00:42:40,090
6660,6810 6810,6900 6900,7080 7080,7440 7440,7830
if we have something that's

1414
00:42:40,150 --> 00:42:41,680
7890,8100 8100,8460 8460,8670 9090,9420
the size of twice

1415
00:42:41,680 --> 00:42:42,910
9420,9750 9750,9870 9870,10230 10260,10500 10500,10650
pointer a word,| we can
|我们可以把它放在a0和a1中，并用它作为返回地址，

1416
00:42:42,910 --> 00:42:43,900
10650,10890 10890,11010 11010,11130 11130,11640
stick that in a0

1417
00:42:43,900 --> 00:42:45,040
11640,11910 11910,12420 12420,12630 12630,12780
and a1 and use

1418
00:42:45,040 --> 00:42:46,240
12780,12930 12930,13080 13080,13200 13200,13500 13500,13980
that as the return address,|
|我想如果你只试着往A1里放点东西，你会遇到问题的。

1419
00:42:46,330 --> 00:42:47,170
14070,14280 14280,14460 14460,14580 14580,14700 14700,14910
I think you'll run into

1420
00:42:47,170 --> 00:42:48,280
14910,15300 15300,15390 15390,15600 15600,15870 15870,16020
problems if you only try

1421
00:42:48,280 --> 00:42:48,970
16020,16110 16110,16260 16260,16530 16530,16620
to put something in

1422
00:42:48,970 --> 00:42:49,520
16620,17010
a1.|
|有道理，谢谢。

1423
00:42:49,880 --> 00:42:52,180
120,420 420,750 750,1290
Makes sense, thanks.|
|为什么寄存器不像连续的，

1424
00:42:55,040 --> 00:42:58,280
1500,2190 2190,2370 2370,3030 3120,4320
Why are the registers

1425
00:42:58,280 --> 00:43:00,470
4320,4650 4650,4830 4830,5550 5550,6030 6180,6510
not like continuous,| so why
|那么为什么像0和1分开。

1426
00:43:00,470 --> 00:43:01,580
6510,6690 6690,6960 6960,7470 7470,7620
is like a0 and

1427
00:43:01,580 --> 00:43:04,080
7620,8220 8400,9210 9210,9900
one separate from.|
|抱歉，不，这是一个很糟糕的例子，这就是为什么s1和s2是分开的，

1428
00:43:04,680 --> 00:43:06,030
660,990 990,1110 1110,1380 1380,1800 1800,2010
Sorry no that's a bad

1429
00:43:06,030 --> 00:43:07,920
2010,2460 2460,2730 2730,3030 3030,3630 3660,4380
example, that's why is s1

1430
00:43:07,920 --> 00:43:09,960
4380,4860 4860,5070 5070,5430 5430,5940
separate from s2,| why
|为什么中间的a是这样的，这有什么意义吗？

1431
00:43:09,960 --> 00:43:11,280
5940,6090 6090,6390 6390,6570 6570,7020 7050,7260
the a in between like

1432
00:43:11,280 --> 00:43:12,210
7260,7380 7380,7620 7620,7830 7830,8100 8100,8190
is there any point in

1433
00:43:12,210 --> 00:43:12,860
8190,8520
that.|
|是的，所以，我之前简短地提到了这一点，

1434
00:43:13,180 --> 00:43:14,860
120,330 330,690 1320,1440 1440,1800
Yeah, so, I mentioned

1435
00:43:14,860 --> 00:43:16,300
1800,1950 1950,2340 2340,2850 2850,3060 3060,3240
this briefly earlier,| but there
|但是有一个压缩的，这只是个猜测，我不我不确定

1436
00:43:16,300 --> 00:43:18,220
3240,3420 3420,3840 3870,4710 4830,5070 5070,5160
is a compressed, this is

1437
00:43:18,220 --> 00:43:19,210
5160,5250 5250,5670 5670,5700 5700,6060 6060,6150
a guess, I don't I

1438
00:43:19,210 --> 00:43:20,680
6150,6360 6360,6510 6510,6630 6630,7020 7170,7620
don't know for sure| but
|但是有一个压缩版本的RISC-V指令，它的大小是16位，而不是64位。

1439
00:43:20,680 --> 00:43:22,870
7620,7860 7860,7950 7950,8520 8520,9180 9180,9810
there's a compressed version of

1440
00:43:22,900 --> 00:43:25,690
9840,10140 10140,10860 10860,11700 11940,12630
the RISC-V instructions which

1441
00:43:25,690 --> 00:43:27,010
12630,12810 12810,13230 13230,13440 13440,13560 13560,13950
are 16 bits in size

1442
00:43:27,010 --> 00:43:28,720
13950,14100 14100,14520 14520,14610 14610,15390
as opposed to 64.|
|您可以使用它来尝试使您的代码在内存中占用更少的空间，

1443
00:43:28,920 --> 00:43:31,440
120,1230 1620,2040 2040,2190 2190,2400 2400,2640
And you would use that

1444
00:43:31,440 --> 00:43:32,700
2640,2700 2700,3180 3210,3570 3600,3780 3780,3900
to try to make your

1445
00:43:32,700 --> 00:43:33,660
3900,4140 4140,4350 4350,4470 4470,4770 4770,4860
code takes less space in

1446
00:43:33,660 --> 00:43:35,910
4860,5370 5610,6270 6390,6690 6690,6810 6810,7110
memory,| and when you use
|当你使用这16位指令时，你只能访问寄存器8到15，

1447
00:43:35,910 --> 00:43:37,590
7110,7350 7350,7800 7800,7980 7980,8610 8610,8790
those 16 bit instructions, you

1448
00:43:37,590 --> 00:43:40,050
8790,9120 9120,9540 9540,10290 10290,10440 10440,11250
only have accesses to registers

1449
00:43:40,260 --> 00:43:42,480
11460,11820 11820,12180 12180,13050 13200,13530 13530,13680
8 through 15,| so I
|所以我认为S1与S2到11是分开的，因为他们想要弄清楚，

1450
00:43:42,480 --> 00:43:44,190
13680,14070 14070,14640 14640,14790 14790,15390
think s1 is separate

1451
00:43:44,190 --> 00:43:45,750
15390,15750 15750,16140 16140,16290 16290,16950
from s2 to eleven

1452
00:43:45,870 --> 00:43:47,370
17070,17790 17790,18120 18120,18330 18330,18390 18390,18570
because they want to make

1453
00:43:47,370 --> 00:43:48,990
18570,18660 18660,18990 18990,19320 19320,19860 19920,20190
it clear,| that s1 is
|S1在压缩指令模式下可用，而2点到11点则不可用。

1454
00:43:48,990 --> 00:43:50,400
20190,20760 20760,20910 20910,21240 21240,21390 21390,21600
available to you in the

1455
00:43:50,430 --> 00:43:52,060
21630,22110 22110,22620 22620,23070
compressed instruction mode,

1456
00:43:52,070 --> 00:43:53,630
30,540 540,690 690,810 810,1140 1140,1590
whereas two to eleven aren't.|
|你知道我不知道他们为什么选x，x8{to，15}，

1457
00:43:54,500 --> 00:43:56,450
1080,1290 1290,1380 1380,1950 1950,2070
And the reason you

1458
00:43:56,450 --> 00:43:57,050
2070,2160 2160,2250 2250,2400 2400,2460 2460,2670
know I don't know why

1459
00:43:57,050 --> 00:43:58,180
2670,2790 2790,3150 3150,3690
they picked x,

1460
00:43:58,440 --> 00:44:00,960
120,360 360,720 720,1800 1920,2400 2400,2640
x eight {to,fifteen},| but I
|但我怀疑，只要看一堆代码，我们就会发现这些是最常用的寄存器。

1461
00:44:00,960 --> 00:44:02,490
2640,3150 3150,3390 3390,3720 3720,4110 4110,4170
suspect that just looked at

1462
00:44:02,490 --> 00:44:03,180
4170,4200 4200,4410 4410,4470 4470,4770 4770,4860
a bunch of code and

1463
00:44:03,180 --> 00:44:03,840
4860,4950 4950,5160 5250,5460 5460,5520
we're like these are

1464
00:44:03,840 --> 00:44:05,400
5520,5580 5580,5880 5880,6240 6240,6420 6420,7080
the most commonly used registers.|
|

1465
00:44:09,620 --> 00:44:10,540
0,660
|
|还有其他问题吗。

1466
00:44:17,140 --> 00:44:18,540
120,390 390,600 600,1290
Any other questions.|
|我有个问题。

1467
00:44:20,840 --> 00:44:22,490
0,270 270,420 420,450 450,960
I had a question.|
|除了帧指针之外，堆栈指针

1468
00:44:23,630 --> 00:44:25,640
90,720 720,870 870,1320 1320,1980 1980,2100
Besides the frame pointer, the

1469
00:44:25,640 --> 00:44:27,980
2100,2550 2550,2880 2880,3000 3000,3420 3600,4440
stack pointer at all| I
|我不知道为什么我们需要更多的被呼叫者储蓄器寄存器。

1470
00:44:28,010 --> 00:44:29,090
4470,4830 4830,4950 4950,5190 5190,5340 5340,5550
don't know why we would

1471
00:44:29,090 --> 00:44:32,120
5550,5910 5910,6270 6270,6840 7020,7830 7830,8580
need more callee saver registers.|
|但我们确实有一大堆这样的东西。

1472
00:44:32,460 --> 00:44:33,870
60,510 510,660 660,810 810,1290 1290,1470
But we do have like

1473
00:44:33,870 --> 00:44:34,840
1470,1560 1560,1860 1860,1950 1950,2190
a bunch of them.|
|是的，S1提升那些我相信只是为了让编译器或程序员使用它们的自由，

1474
00:44:35,420 --> 00:44:38,330
120,990 1080,1770 1770,2430 2430,3030
Yeah, the s1s to

1475
00:44:38,330 --> 00:44:40,070
3030,3750 3750,4050 4050,4170 4170,4440 4440,4770
elevens those are just for

1476
00:44:40,070 --> 00:44:41,390
4770,4830 4830,5130 5130,5370 5370,5580 5580,6090
I believe use their freedom

1477
00:44:41,390 --> 00:44:42,980
6090,6210 6210,6300 6300,7020 7080,7590 7590,7680
for the compiler or the

1478
00:44:42,980 --> 00:44:45,380
7680,8220 8220,8370 8370,8820 9870,10080
programmer to use,| so
|所以在某些情况下你可能想要，

1479
00:44:45,380 --> 00:44:46,010
10080,10320 10320,10470 10470,10530 10530,10620 10620,10710
there may be there are

1480
00:44:46,010 --> 00:44:47,390
10710,10980 10980,11340 11340,11550 11550,11700 11700,12090
certain cases where you want,|
|你想保证在你的函数之后仍然有一些东西存在，调用编译器可以选择使用s1到11来做这件事。

1481
00:44:47,600 --> 00:44:48,740
12300,12510 12510,12690 12690,12750 12750,13260 13260,13440
you want to guarantee that

1482
00:44:48,740 --> 00:44:50,900
13440,13800 13800,13920 13920,14160 14160,14790
something is still around

1483
00:44:50,930 --> 00:44:53,390
15630,16470 16620,16980 16980,17130 17130,17490 17490,18090
after after your function, call

1484
00:44:53,420 --> 00:44:55,400
18120,18630 18630,19290 19290,19500 19500,19950 19950,20100
the compiler can choose to

1485
00:44:55,400 --> 00:44:57,560
20100,20550 20550,21480 21510,21720 21720,22260
use s1 to eleven

1486
00:44:57,560 --> 00:44:58,440
22260,22410 22410,22590 22590,22920
to do that.|
|嗯，我手头上没有一个具体的例子来说明它在哪里是有用的，

1487
00:44:58,760 --> 00:44:59,680
120,780
Um,

1488
00:45:00,190 --> 00:45:01,870
90,270 270,540 540,750 750,1170 1470,1770
I don't have like on

1489
00:45:01,870 --> 00:45:03,340
1770,2070 2070,2130 2130,2670 2670,3150 3150,3240
hand, a specific example of

1490
00:45:03,340 --> 00:45:05,320
3240,3450 3450,3690 3690,4350 4470,4980
where that's useful,| but,
|但是，我肯定它会出现的。其中，具有{callee，save}值很重要。

1491
00:45:05,320 --> 00:45:06,640
5220,5580 5580,5820 5820,5910 5910,6150 6150,6540
I'm sure it shows up.

1492
00:45:07,330 --> 00:45:09,340
210,780 840,1170 1170,1260 1260,1860 1860,2220
where having a {callee,save} value

1493
00:45:09,340 --> 00:45:10,220
2220,2310 2310,2820
is important.|
|但这些基本上都是程序员或编译器选择使用的Ask 1到11。

1494
00:45:14,390 --> 00:45:15,890
30,240 240,390 390,450 450,930 930,1530
But these are basically basically

1495
00:45:15,890 --> 00:45:17,360
1530,1650 1650,2070 2070,2160 2160,2700 2700,3000
a programmer or compiler's choice

1496
00:45:17,360 --> 00:45:18,800
3000,3120 3120,3510 3720,4170 4170,4350 4350,4440
to use ask one to

1497
00:45:18,800 --> 00:45:19,500
4440,4860
eleven.|
|

1498
00:45:21,040 --> 00:45:21,440
60,390
|
|我要注意的是，这些浮点寄存器它们的浮点算术。据我所知，你们在这节课上不会看到他们，

1499
00:45:22,420 --> 00:45:23,710
120,420 420,600 600,840 840,960 960,1410
I should note that these

1500
00:45:23,710 --> 00:45:25,540
1410,1800 1800,2130 2130,2640 2640,2820 2820,3240
floating point registers their floating

1501
00:45:25,540 --> 00:45:27,920
3240,3510 3510,4230
point, arithmetic.

1502
00:45:28,480 --> 00:45:29,410
360,600 600,780 780,900 900,1050 1050,1290
As far as I'm aware

1503
00:45:29,410 --> 00:45:30,190
1290,1410 1410,1650 1650,1830 1830,1980 1980,2070
you won't see them in

1504
00:45:30,190 --> 00:45:32,140
2070,2250 2250,2970 3540,3780 3780,4020
this class,| and so
|所以你真的不需要担心他们。

1505
00:45:32,140 --> 00:45:33,190
4020,4380 4380,4620 4620,4830 4830,4950 4950,5070
you don't really need to

1506
00:45:33,190 --> 00:45:34,020
5070,5280 5280,5430 5430,5670
worry about them.|
|

1507
00:45:37,100 --> 00:45:37,500
60,330
|
|好的，我们开始稍微讨论一下函数调用

1508
00:45:38,550 --> 00:45:40,290
750,1320 1890,2010 2010,2100 2100,2490
Okay, so we started

1509
00:45:40,290 --> 00:45:43,110
2490,3060 3060,3210 3210,3540 3540,4020 4080,5310
talking a little bit about

1510
00:45:43,430 --> 00:45:46,910
420,840 840,1740 2040,2940
function calls| and,
|有了这些，我想让我们开始讨论堆栈。

1511
00:45:47,210 --> 00:45:48,140
3810,4050 4050,4170 4170,4470 4470,4530 4530,4740
so with that I want

1512
00:45:48,140 --> 00:45:50,380
4740,5040 5070,5550 5550,5820 5820,6720
to move us into

1513
00:45:50,610 --> 00:45:53,820
30,1050 1050,1440 1440,1560 1560,2130
discussion of the stack.|
|这就是我们谈论的堆栈，

1514
00:45:54,390 --> 00:45:56,000
210,480 480,720 720,1500
So this is

1515
00:45:56,600 --> 00:45:58,640
300,540 540,1170 1320,1770 1770,2130 2130,2340
this is we're talking about

1516
00:45:58,640 --> 00:46:00,820
2340,2460 2460,3120 3540,4260
the stack,| and
|堆栈，如果您像以前一样看到它，堆栈之所以重要，是因为它使我们的函数保持组织和正常运行

1517
00:46:01,100 --> 00:46:02,660
120,270 270,840 1080,1500 1500,1680
the stack, if you've

1518
00:46:02,660 --> 00:46:05,180
1680,1950 1950,2250 2280,2970 2970,3630 3660,4200
seen it like before the

1519
00:46:05,210 --> 00:46:06,590
4230,4920 4920,5100 5100,5190 5190,5490 5490,5610
reason why the stack is

1520
00:46:06,590 --> 00:46:08,960
5610,6240 6240,6750 6870,7080 7080,7470 7500,7980
important is it's what keeps

1521
00:46:08,960 --> 00:46:10,820
7980,8220 8220,9060
our functions

1522
00:46:11,200 --> 00:46:13,660
120,1110 1110,1470 1470,1950 1980,2430 2430,2580
organized and sane| and it's
|它允许函数工作，也是使返回工作的原因

1523
00:46:13,660 --> 00:46:15,220
2580,2730 2730,3420 3600,3900 3900,4140
what allows what makes

1524
00:46:15,220 --> 00:46:17,560
4140,4560 4560,5040 5520,5730 5730,5910 5910,6480
functions work, it's what makes

1525
00:46:17,560 --> 00:46:19,480
6480,6960 6960,7410 7410,7560 7560,7740 7740,8400
return work| and it's also
|这也是我们经常会发现自己保存登记簿之类的东西的地方。

1526
00:46:19,630 --> 00:46:21,340
8550,9300 9300,9720 9720,9840 9840,9990 9990,10260
where often we will find

1527
00:46:21,340 --> 00:46:24,400
10260,10950 10950,11550 11550,11940 11940,12780 12900,13320
ourselves saving our registers and

1528
00:46:24,400 --> 00:46:25,500
13320,13620 13620,13800 13800,14070
things like that.|
|恩。

1529
00:46:26,330 --> 00:46:27,400
150,870
Um.

1530
00:46:27,740 --> 00:46:28,240
60,420
|
|因此，在这里，我只给出了堆栈外观的一个非常简单的布局

1531
00:46:29,440 --> 00:46:30,400
120,840
So,

1532
00:46:31,720 --> 00:46:34,180
60,630 630,1080 1080,1650 1650,1950 1980,2520
here, I've given just a

1533
00:46:34,240 --> 00:46:38,020
2580,3030 3030,4320 4950,5850 5850,6000 6000,6360
pretty simple layout of what

1534
00:46:38,020 --> 00:46:39,700
6360,6420 6420,6870 6870,7200 7200,7650 7680,8040
the stack looks like| and
|因此，这里的每个框都是我们所说的堆栈框架。

1535
00:46:39,700 --> 00:46:41,980
8040,8160 8160,8550 8550,8700 8700,9540 9570,10320
so each of these boxes

1536
00:46:41,980 --> 00:46:43,750
10320,10890 10920,11280 11280,11460 11460,11580 11580,12090
here is what we refer

1537
00:46:43,750 --> 00:46:47,680
12090,12780 13080,13980 13980,14460 14460,15390
to as a stack

1538
00:46:47,680 --> 00:46:48,360
16020,16440
frame.|
|每次我们得到，都是由函数调用生成的。

1539
00:46:49,070 --> 00:46:51,380
270,810 840,1170 1170,1770 1770,1920 1920,2580
And every time we get,

1540
00:46:52,070 --> 00:46:53,870
480,810 810,1020 1020,1620 1620,1950
which are generated by

1541
00:46:53,870 --> 00:46:55,040
1950,2310 2310,2940
function calls.|
|每次我们调用一个函数时，该函数都会为其自身创建自己的堆栈框架，并使用该堆栈框架

1542
00:46:59,890 --> 00:47:02,440
1800,2250 2250,2490 2490,2580 2580,2820
Every time we call

1543
00:47:02,440 --> 00:47:04,840
2820,2910 2910,3570 3600,3990 3990,4740 4770,5220
a function that function makes

1544
00:47:04,840 --> 00:47:06,790
5220,5370 5370,6120 6150,6480 6480,6750 6750,7170
for itself its own stack

1545
00:47:06,790 --> 00:47:09,790
7170,7740 7890,8670 8940,9450 9450,10170
frame and which it

1546
00:47:09,790 --> 00:47:11,650
10170,10560 10560,11070 11070,11490 11490,11730 11730,12030
uses itself| and does that
|并且通过在堆栈指针周围移动来实现这一点，

1547
00:47:11,650 --> 00:47:13,810
12030,12300 12300,12720 12720,13410 13560,13830 13830,14190
by moving around the stack

1548
00:47:13,810 --> 00:47:15,670
14190,14730 14910,15330 15330,15660 15660,15750 15750,16050
pointer,| so here's the stack
|这是堆栈指针，记住堆栈非常重要。

1549
00:47:15,670 --> 00:47:17,740
16050,16710 16740,17160 17160,17370 17370,17670
pointer, and this is

1550
00:47:17,740 --> 00:47:19,630
18120,18690 18690,18930 18930,19290 19290,19380 19380,20010
it's very important to remember

1551
00:47:19,780 --> 00:47:21,120
20160,20550 20550,21390
with stacks.|
|我们从高地址开始，然后向下增长到低地址，

1552
00:47:21,740 --> 00:47:24,500
120,390 390,1290 1320,1560 1560,1860 1860,2880
We start from high addresses

1553
00:47:24,830 --> 00:47:27,080
3210,3420 3420,3570 3570,3990 3990,5280
and we grow downwards

1554
00:47:27,210 --> 00:47:29,310
90,870 900,1380 1380,1950 1950,2070 2070,2190
to low addresses,| so the
|所以堆栈总是向下增长。

1555
00:47:29,310 --> 00:47:31,640
2190,2610 2610,3090 3090,3570 3600,4350
stack grows down always.|
|所以你会看到堆栈点面积的运算通常是通过减法来完成的，我们想要在程序集中创建一个新的堆栈框架，

1556
00:47:31,860 --> 00:47:33,570
570,780 780,1290 1410,1800 1800,1950
And so you'll see

1557
00:47:33,570 --> 00:47:35,040
1950,2100 2100,2340 2340,2880 2880,3090 3090,3420
that the arithmetic for stack

1558
00:47:35,040 --> 00:47:37,260
3420,3690 3690,4560 4560,4950 4980,5400 5400,5640
point area is usually done

1559
00:47:37,260 --> 00:47:38,820
5640,6000 6000,6750 6750,6960 6960,7140 7140,7200
via subtraction, we want to

1560
00:47:38,820 --> 00:47:39,960
7200,7470 7470,7500 7500,7710 7710,8040 8040,8340
make a new stack frame

1561
00:47:40,330 --> 00:47:41,710
90,300 300,780 780,900 900,1200 1200,1470
in assemblies,| the stack grows
|堆栈向下增长，函数包含{i，see}的堆栈帧注册局部变量，

1562
00:47:41,710 --> 00:47:42,920
1470,2190
downwards,

1563
00:47:43,380 --> 00:47:45,150
180,420 420,810 810,1200 1200,1410 1410,1950
and stack frames for function

1564
00:47:45,150 --> 00:47:48,780
1950,2760 2940,3300 3300,4110 4110,4380 4380,5580
contain {I,see} registers local variables,|
|同样就像我说的，如果一个参数寄存器用完了，堆栈上会出现额外的参数，

1565
00:47:48,930 --> 00:47:50,760
6270,6690 6690,6930 6930,7440 7440,7560
also like I was

1566
00:47:50,760 --> 00:47:52,080
7560,7830 7830,8220 8220,8400 8400,8640 8640,8880
saying, if you run out

1567
00:47:52,080 --> 00:47:54,690
8880,9300 9330,9570 9570,10050 10050,10950 10980,11490
of a argument registers additional

1568
00:47:54,690 --> 00:47:55,680
11490,11970 11970,12060 12060,12240 12240,12360 12360,12480
arguments will show up on

1569
00:47:55,680 --> 00:47:56,940
12480,12570 12570,12990 13170,13350 13350,13440 13440,13740
the stack,| and so not
|因此不是因为堆栈帧都不是相同的大小，

1570
00:47:56,940 --> 00:47:58,050
13740,14010 14010,14280 14280,14520 14520,14610 14610,14850
as stack frames are not

1571
00:47:58,050 --> 00:47:59,460
14850,15030 15030,15090 15090,15360 15360,15930
all the same size,|
|尽管它们在这张图中，但事实并非如此，

1572
00:47:59,460 --> 00:48:00,210
16260,16530 16530,16650 16650,16740 16740,16920 16920,17010
even though they are in

1573
00:48:00,210 --> 00:48:01,380
17010,17130 17130,17760 17760,17940 17940,18090 18090,18180
this diagram, that's not the

1574
00:48:01,380 --> 00:48:03,090
18180,18780 18810,19200 19200,19530 19530,19650 19650,19890
case,| different functions have different
|不同的函数具有不同数量的局部变量、不同的寄存器等等，

1575
00:48:03,090 --> 00:48:05,340
19890,20190 20190,20520 20520,20820 20820,21720 21720,22140
numbers of local variables, different

1576
00:48:05,520 --> 00:48:07,410
22320,23100 23400,23760 23760,23910 23910,24030 24030,24210
registers so on and so

1577
00:48:07,410 --> 00:48:08,880
24210,24780 24870,25110 25110,25230 25230,25470 25470,25680
forth,| and so stack frames
|因此堆栈帧将具有不同的大小，

1578
00:48:08,880 --> 00:48:10,110
25680,25770 25770,25890 25890,26160 26160,26700 26700,26910
will be different sizes,| but
|但是有两件事是你绝对可以信赖的，

1579
00:48:10,110 --> 00:48:11,220
26910,27030 27030,27330 27330,27750 27750,27870 27870,28020
the two things that you

1580
00:48:11,220 --> 00:48:12,800
28020,28140 28140,28680 28680,29010 29010,29370
can definitely count on,|
|其中重要的是返回地址将总是在第一件事上，并且帧指针、前一帧帧指针也将出现在堆栈上的可预测位置，

1581
00:48:12,820 --> 00:48:14,380
60,360 360,450 450,1050 1050,1200 1200,1620
which are important is that

1582
00:48:14,500 --> 00:48:15,970
2130,2310 2310,2670 2670,3090 3090,3210
the return address will

1583
00:48:15,970 --> 00:48:17,260
3210,3480 3480,3780 3780,3930 3930,4050 4110,4500
always be on the first

1584
00:48:17,260 --> 00:48:18,880
4500,4890 4890,5130 5130,5220 5220,5490 5490,6120
thing and the frame pointer,

1585
00:48:19,120 --> 00:48:20,560
6630,6720 6720,7170 7170,7530 7530,7800
the previous frames frame

1586
00:48:20,560 --> 00:48:22,060
7800,8190 8190,8340 8340,8850 8850,9180 9180,9300
pointer is also going to

1587
00:48:22,060 --> 00:48:22,990
9300,9510 9510,9600 9600,9720 9720,9810 9810,10230
show up on the stack

1588
00:48:23,080 --> 00:48:25,570
10320,10680 10680,10740 10740,11250 11250,11940 12210,12810
at a predictable location,| so
|所以

1589
00:48:25,600 --> 00:48:26,520
12840,13500
|
|这里的两个重要寄存器{是，sp}，

1590
00:48:26,690 --> 00:48:28,460
90,240 240,540 540,990 990,1470 1470,1860
the two important registers here

1591
00:48:28,460 --> 00:48:30,080
1860,2730 2730,3090 3090,3210 3210,3330 3330,3480
{are,sp},| which you know as
|正如我们所讨论的，这是堆栈的底部。

1592
00:48:30,080 --> 00:48:31,970
3480,3600 3600,4140 4140,4380 4380,4830 4830,5370
we discussed is used for,

1593
00:48:32,000 --> 00:48:33,230
5730,5940 5940,6240 6240,6330 6330,6630
this is the bottom

1594
00:48:33,230 --> 00:48:34,280
6630,6690 6690,6780 6780,7380
of the stack.|
|或者通常你知道这是堆栈的位置，

1595
00:48:35,780 --> 00:48:37,520
180,660 660,840 870,1590 1590,1800 1800,1920
Or a generally you know

1596
00:48:37,520 --> 00:48:38,480
1920,2040 2040,2160 2160,2670 2670,2790 2790,2880
it's the location of the

1597
00:48:38,480 --> 00:48:40,550
2880,3390 3600,3930 3930,4200 4200,4830 4830,4950
stack,| and then fp is
|那么FP也是重要的寄存器

1598
00:48:40,550 --> 00:48:43,120
4950,5130 5130,5730 5790,6690
are also important

1599
00:48:43,310 --> 00:48:45,050
90,750 750,930 930,1140 1140,1530 1530,1830
register| and this points to
|这指向当前帧的顶部。

1600
00:48:45,050 --> 00:48:47,480
1830,1920 1920,2640 2670,3270 3270,4080
the top of current

1601
00:48:48,760 --> 00:48:49,720
120,840
frame.|
|这一点很重要，因为这意味着返回地址和前一FP将始终位于当前帧指针的固定位置。

1602
00:48:50,790 --> 00:48:52,410
150,360 360,570 570,630 630,1140 1140,1770
And this is important because

1603
00:48:52,440 --> 00:48:53,730
1800,2190 2190,2460 2460,2580 2580,2700 2700,3090
that means that the return

1604
00:48:53,730 --> 00:48:56,220
3090,3750 3780,4260 4260,4350 4350,4860 4860,5580
address and the previous fp

1605
00:48:56,250 --> 00:48:57,480
5610,5850 5850,6390 6390,6630 6630,6780 6780,6840
will always be at a

1606
00:48:57,480 --> 00:49:00,930
6840,7410 7440,8730 8910,9600 9600,9750 9750,10290
fixed location from the current

1607
00:49:00,930 --> 00:49:02,060
10290,10620 10620,11130
frame pointer.|
|因此，这意味着如果我想要找到我的返回地址，或者我想要找到上一帧，我总是可以通过查看当前帧指针来获得这些值

1608
00:49:02,400 --> 00:49:04,110
120,300 300,510 510,990 990,1500 1530,1830
So that means that if

1609
00:49:04,110 --> 00:49:05,040
1830,1920 1920,2130 2130,2250 2250,2610 2610,2760
I want to find my

1610
00:49:05,040 --> 00:49:06,210
2760,3060 3060,3510 3510,3660 3660,3750 3750,3930
return address or I want

1611
00:49:06,210 --> 00:49:07,650
3930,4020 4020,4290 4290,4380 4380,4800 4800,5370
to find the previous frame

1612
00:49:07,890 --> 00:49:09,060
5610,5760 5760,5940 5940,6420 6420,6690 6690,6780
I can always get to

1613
00:49:09,060 --> 00:49:11,550
6780,7170 7170,7950 7950,8370 8400,8910 8910,9270
those values by looking at

1614
00:49:11,550 --> 00:49:13,980
9270,9390 9390,9810 9810,10140 10140,10650 11370,11700
the current frame pointer| and
|我们之所以存储前一个帧指针，是为了让我们可以向后跳转，所以一旦这个函数返回，我们就可以把它移到FP中，突然，FP再次从指向这个堆栈框架，到现在指向这个堆栈框架。

1615
00:49:13,980 --> 00:49:15,030
11700,11790 11790,12090 12090,12300 12300,12450 12450,12750
the reason why we store

1616
00:49:15,030 --> 00:49:16,800
12750,12840 12840,13290 13290,13560 13560,14250 14310,14520
the previous frame pointer is

1617
00:49:16,800 --> 00:49:18,600
14520,14700 14700,15150 15150,15480 15480,15990 16020,16320
to allow us to jump

1618
00:49:18,600 --> 00:49:19,800
16320,16620 16620,16770 16770,16950 16950,17130 17130,17520
back so once this function

1619
00:49:19,800 --> 00:49:21,630
17520,18150 18240,18540 18540,18720 18720,19050 19050,19350
returns, we can move this

1620
00:49:21,630 --> 00:49:23,280
19350,19680 19680,20400 20430,20700 20700,20910 20910,21000
into fp and all of

1621
00:49:23,280 --> 00:49:25,200
21000,21090 21090,21510 21510,21990 21990,22560 22650,22920
a sudden fp again will

1622
00:49:25,200 --> 00:49:26,610
22920,23160 23160,23310 23310,23700 23700,23820 23820,24330
go from pointing to this,

1623
00:49:26,610 --> 00:49:28,060
24330,24570 24570,24900 24900,25500
this stack frame,

1624
00:49:28,110 --> 00:49:29,430
90,450 450,750 750,1110 1110,1200 1200,1410
to now pointing to this

1625
00:49:29,430 --> 00:49:31,140
1410,1710 1710,2070 2430,2700 2700,2910 2910,3120
stack frame.| So we use
|因此，我们使用帧指针来操作堆栈帧，并确保始终指向与正确函数相对应的堆栈帧。

1626
00:49:31,140 --> 00:49:32,880
3120,3240 3240,3540 3540,3990 3990,4200 4200,4860
the frame pointer to manipulate

1627
00:49:32,880 --> 00:49:34,470
4860,5070 5070,5430 5430,6030 6030,6270 6270,6450
our stack frames and make

1628
00:49:34,470 --> 00:49:35,610
6450,6690 6690,6780 6780,7170 7170,7470 7470,7590
sure we're always going to

1629
00:49:35,610 --> 00:49:39,510
7590,7950 7950,8940 9270,9930 10050,10530 10560,11490
one corresponding to the correct

1630
00:49:39,510 --> 00:49:40,400
11490,12090
function.|
|这就是事情的方式，事情是这样做的

1631
00:49:41,040 --> 00:49:41,970
180,360 360,630 630,870 870,1050 1050,1110
And that's that's kind of

1632
00:49:41,970 --> 00:49:43,500
1110,1260 1260,1590 2070,2310 2310,2550 2550,2640
how things how things are

1633
00:49:43,500 --> 00:49:46,530
2640,3060 3180,4230 4320,4830 4830,5220 5220,5670
done| and the these pieces
|堆栈的这些部分需要由汇编语言创建，所以你读到的调用约定文档中的所有内容都是由编译器有效实施的，

1634
00:49:46,530 --> 00:49:47,700
5670,5880 5880,5970 5970,6720
of the stack

1635
00:49:47,920 --> 00:49:49,300
420,630 630,690 690,840 840,1500
need to be created

1636
00:49:49,300 --> 00:49:52,120
1500,2190 2220,3030 3120,3360 3360,3480 3480,4320
by assembly and so everything's

1637
00:49:52,120 --> 00:49:54,070
4320,4680 4680,4770 4770,4950 4950,5340 5340,6270
everything in that calling conventions

1638
00:49:54,100 --> 00:49:56,230
6300,7230 7230,7380 7380,7620 7620,7830 7830,8430
document that you read about

1639
00:49:56,260 --> 00:49:59,950
8460,9060 9060,9810 9810,10740 10740,11430 11610,12150
that's all enforced by effectively

1640
00:49:59,950 --> 00:50:01,090
12150,12330 12330,12450 12450,13050 13050,13200 13200,13290
by the compiler,| so the
|所以编译器遵循调用约定，它生成堆栈帧，

1641
00:50:01,090 --> 00:50:03,730
13290,13920 13920,14580 14580,15120 15180,15450 15450,15930
compiler adheres to the calling

1642
00:50:03,730 --> 00:50:06,220
15930,16770 16830,17310 17310,17610 17610,17850 17850,18420
convention and it's what generates

1643
00:50:06,220 --> 00:50:07,540
18420,18540 18540,18900 18900,19170 19170,19290 19290,19740
the stack frame,| it generates
|它生成使堆栈框架看起来正确的汇编代码，

1644
00:50:07,540 --> 00:50:09,310
19740,19860 19860,20340 20340,20850 20910,21210 21210,21510
the assembly code that makes

1645
00:50:09,310 --> 00:50:10,900
21510,21660 21660,21990 21990,22350 22350,22590 22590,23100
our stack frames look correct,|
|所以通常在函数的顶部，你会看到所谓的函数序言。然后是函数体

1646
00:50:11,080 --> 00:50:13,000
23280,23670 23670,24330 24450,24810 24810,24900 24900,25200
so often at the top

1647
00:50:13,000 --> 00:50:14,170
25200,25320 25320,25440 25440,25980 25980,26160 26160,26370
of a function, you'll see

1648
00:50:14,170 --> 00:50:16,940
26370,26640 26640,27210 27480,27930 27930,28890
what's called a function

1649
00:50:17,100 --> 00:50:18,760
690,1590
prologue.

1650
00:50:21,300 --> 00:50:22,590
120,630 630,990 990,1140 1140,1290 1290,1410
And then there will be

1651
00:50:22,590 --> 00:50:24,180
1410,1530 1530,1860 1860,1980 1980,2070 2070,3000
the body of the function|
|然后会有一个尾声，在那之后会出现，

1652
00:50:24,450 --> 00:50:25,710
3270,3450 3450,3630 3630,3750 3750,3960 3960,4530
and then there will be

1653
00:50:26,110 --> 00:50:28,720
210,420 420,1440 1680,2310 2310,2640 2640,2820
an epilogue that shows up

1654
00:50:28,720 --> 00:50:30,040
2820,3120 3120,3510 3570,3840 3840,4020 4020,4140
after that,| so this is
|这有点像，汇编函数通常是这样的，我们现在来看一下，所以这里我有另一个函数SUM_THEN_DOUBLE，

1655
00:50:30,040 --> 00:50:31,180
4140,4440 4440,4590 4590,5040
kind of like,

1656
00:50:32,010 --> 00:50:34,620
90,450 450,870 900,1110 1110,1980
when a an assembly

1657
00:50:35,230 --> 00:50:37,240
90,810 810,960 960,1290 1290,1530 1530,2100
function will often look like

1658
00:50:37,360 --> 00:50:38,350
2220,2580 2580,2700 2700,2910 2910,2970 2970,3210
and we'll take a look

1659
00:50:38,350 --> 00:50:41,560
3210,3780 4590,5010 5760,6210 6210,6420
at, now, so here

1660
00:50:41,560 --> 00:50:43,480
6420,6540 6540,6660 6660,7020 7020,7620 8040,8520
I have another function sum_then_double,|
|所以你会注意到，[打扰一下]有些人没有任何这些东西，如果它是一个适当的功能，它就应该有

1661
00:50:43,480 --> 00:50:45,370
8520,8790 8790,9690 9690,10020 10020,10230
so you'll note that

1662
00:50:45,370 --> 00:50:46,630
10230,10560 10560,10950 10950,11070 11070,11220 11220,11910
[as excuse me] that some_to

1663
00:50:46,630 --> 00:50:48,610
11910,12210 12210,12750 12870,13380 13380,13470
not have any of

1664
00:50:48,610 --> 00:50:50,170
13470,13710 13710,14130 14130,14310 14310,14700 14850,15030
these things that it it

1665
00:50:50,170 --> 00:50:50,950
15030,15360 15360,15480 15480,15570 15570,15720 15720,15810
should if it was a

1666
00:50:50,950 --> 00:50:52,720
15810,16200 16200,16800 16920,17160 17160,17310 17310,17580
proper function| and this works
|这很好用，因为它足够简单，

1667
00:50:52,720 --> 00:50:54,220
17580,17970 17970,18240 18240,18390 18390,18720 18720,19080
fine because it's simple enough,|
|所以它的所有计算都是在0上进行的

1668
00:50:54,220 --> 00:50:55,090
19080,19320 19320,19440 19440,19650 19650,19860 19860,19950
so it does all of

1669
00:50:55,090 --> 00:50:57,100
19950,20100 20100,21000 21000,21360 21360,21960
its computations on a0|
|所以事情是这样的，事情很好，我们也不是，这是一种叶子功能，

1670
00:50:57,100 --> 00:50:58,220
21960,22110 22110,22230 22230,22470 22470,22740
and so things are,

1671
00:50:58,200 --> 00:50:59,400
0,420 420,510 510,900 900,1080 1080,1200
things are good and we're

1672
00:50:59,400 --> 00:51:00,510
1200,1410 1410,1710 1710,1860 1860,2160 2160,2310
also not it's a it's

1673
00:51:00,510 --> 00:51:02,070
2310,2400 2400,2610 2610,3180 3390,3870
a leaf function,| so,
|因此，您将看到术语叶函数，它是一个不调用另一个函数的函数

1674
00:51:02,460 --> 00:51:03,450
4260,4440 4440,4650 4650,4920 4920,5100 5100,5250
you'll see if you've seen

1675
00:51:03,450 --> 00:51:04,530
5250,5310 5310,5550 5550,5760 5760,6150 6150,6330
the term leaf function that's

1676
00:51:04,530 --> 00:51:05,580
6330,6390 6390,6720 6720,6840 6840,7170 7170,7380
a function that doesn't call

1677
00:51:05,580 --> 00:51:07,860
7380,7710 7710,8310 8700,9030 9030,9180 9180,9660
another function| and the functions
|这些函数的特殊之处在于它们不需要担心保存自己的返回地址

1678
00:51:07,860 --> 00:51:09,390
9660,9750 9750,10320 10320,10470 10470,10710 10710,11190
are special in that they

1679
00:51:09,630 --> 00:51:12,060
11430,11910 11910,12360 12360,12900 12900,13350 13350,13860
don't need to worry about

1680
00:51:12,060 --> 00:51:14,310
13860,14610 15210,15570 15570,15720 15720,16110
saving their own return

1681
00:51:14,310 --> 00:51:16,530
16110,16920 16920,17310 17310,17790 17790,18090 18090,18330
address| or saving really any
|或者真正保存任何呼叫者保存的寄存器。

1682
00:51:16,530 --> 00:51:18,360
18330,18420 18420,18510 18510,18930 18930,19320 19320,20160
of the caller saved registers.|
|因为他们会这样做，所以他们不会再进行另一个函数调用

1683
00:51:18,650 --> 00:51:21,680
30,1410 1680,1980 1980,2340 2340,2880 2910,3060
Because they're going to they're

1684
00:51:21,680 --> 00:51:22,520
3060,3240 3240,3360 3360,3420 3420,3630 3630,3900
not going to make another

1685
00:51:22,520 --> 00:51:23,570
3900,4290 4290,4530 4530,4680 4680,4770 4770,4950
function call| so they don't
|所以他们不需要那么小心，

1686
00:51:23,570 --> 00:51:25,160
4950,5130 5130,5220 5220,5550 5640,6030 6030,6540
have to be as careful,|
|另一方面，SOME_THEN_DOUBLE不是叶函数，

1687
00:51:25,400 --> 00:51:27,110
6780,7830 7830,8100 8100,8220 8220,8490
some_then_double on the other

1688
00:51:27,110 --> 00:51:28,550
8490,9030 9060,9360 9360,9660 9660,9720 9720,9930
hand is not a leaf

1689
00:51:28,550 --> 00:51:29,840
9930,10440 10440,10620 10620,10770 10770,10950 10950,11220
function,| so you can see
|所以你可以在这里看到，它叫做SUM_TO。

1690
00:51:29,840 --> 00:51:32,180
11220,11700 11700,11820 11820,12540
here, it calls,

1691
00:51:32,180 --> 00:51:32,980
13230,14100
sum_to.|
|所以它确实需要包括开场白，

1692
00:51:33,530 --> 00:51:35,120
510,780 780,1140 1200,1560 1560,1860 1860,2100
And so it does need

1693
00:51:35,120 --> 00:51:37,340
2100,2220 2220,2820 2820,3240 3330,3780 3780,4320
to include that that prologue,|
|所以我们在这里看到，我们正在从堆栈指针中减去16，

1694
00:51:37,340 --> 00:51:38,360
4320,4440 4440,4560 4560,4710 4710,4980 4980,5340
and so we see here

1695
00:51:38,360 --> 00:51:40,940
5340,5850 5940,6240 6240,6360 6360,7110 7110,7920
that we are subtracting 16

1696
00:51:40,940 --> 00:51:42,770
7920,8370 8370,8490 8490,8850 8850,9420 9450,9750
from the stack pointer,| so
|所以我们在堆栈上腾出空间，

1697
00:51:42,770 --> 00:51:44,270
9750,9930 9930,10290 10290,10800 10800,11010 11010,11250
we're making space on our

1698
00:51:44,270 --> 00:51:46,640
11250,11760 11970,12360 12360,13020 13020,13140 13140,13620
stack,| we're storing the return
|我们将某些_THEN_DOUBLE的返回地址存储在堆栈中，

1699
00:51:46,640 --> 00:51:49,190
13620,14190 14190,14370 14370,15570 15750,16170
address for some_then_double on

1700
00:51:49,190 --> 00:51:50,660
16170,16260 16260,16830 16950,17250 17250,17520 17520,17640
the stack,| and then we
|然后我们打电话给SUM_TO，

1701
00:51:50,660 --> 00:51:51,710
17640,17910 17910,18030 18030,18330 18330,18420 18420,19080
make our call to sum_to,|
|在此之后，此函数所做的全部工作就是调用sum_to，然后将结果加倍，

1702
00:51:51,710 --> 00:51:53,180
19320,19560 19560,19800 19800,20040 20040,20160
and after that all

1703
00:51:53,180 --> 00:51:54,350
20160,20580 20580,20910 20910,21150 21150,21240 21240,21330
this function does is it

1704
00:51:54,350 --> 00:51:55,670
21330,21600 21600,22200 22200,22350 22350,22650
calls sum_to and then

1705
00:51:55,670 --> 00:51:58,060
22650,23100 23100,23190 23190,23850
doubles the result,|
|将结果回合加倍一些_to

1706
00:51:58,080 --> 00:51:59,700
60,540 540,630 630,1080 1080,1470 1470,1680
doubles the result turn by

1707
00:51:59,700 --> 00:52:01,320
1680,2400 2580,2880 2880,3150 3150,3300
some_to| and here you
|在这里您可以看到结尾，所以我们将返回地址加载回ra，并删除堆栈框架，然后跳出函数。

1708
00:52:01,320 --> 00:52:03,210
3300,3450 3450,3900 3900,4380 4410,5040 5040,5190
can see the epilogue, so

1709
00:52:03,210 --> 00:52:04,240
5190,5340 5340,6000
we load

1710
00:52:04,820 --> 00:52:06,620
120,450 450,780 780,1200 1200,1560 1560,1920
the return address back in

1711
00:52:06,680 --> 00:52:09,020
1980,2340 2340,3270 3360,3930
to ra and

1712
00:52:09,020 --> 00:52:10,520
4320,4740 4740,4980 4980,5280 5280,5730 5730,5820
delete our stack frame and

1713
00:52:10,520 --> 00:52:11,870
5820,6060 6060,6630 6720,6960 6960,7050 7050,7170
then jump out of the

1714
00:52:11,870 --> 00:52:12,640
7170,7710
function.|
|

1715
00:52:12,670 --> 00:52:13,320
90,540
|
|所以我们可以运行它来确保它能达到我们预期的效果。

1716
00:52:13,850 --> 00:52:14,720
150,330 330,480 480,630 630,780 780,1020
And so we can run

1717
00:52:14,720 --> 00:52:16,250
1020,1440 1800,2100 2100,2280 2280,2460 2460,2550
that to make sure it

1718
00:52:16,250 --> 00:52:17,690
2550,2760 2760,2910 2910,3090 3090,3210 3210,3990
does what we would expect.|
|

1719
00:52:18,890 --> 00:52:19,580
270,330
|
|到这儿来。

1720
00:52:20,870 --> 00:52:22,620
150,420 420,1290
Go here.|
|我们{可以，运行}，所以如果我们运行demo2{或demo1}

1721
00:52:24,160 --> 00:52:26,110
840,1770 1980,2280 2280,2520 2520,2700 2700,2790
We {can,run}, so if we

1722
00:52:26,110 --> 00:52:27,910
2790,3000 3000,3960 3990,4590
run demo2 {or,demo1}|
|我们得出了总和为15的结果。

1723
00:52:27,910 --> 00:52:28,660
4590,4710 4710,4860 4860,4920 4920,5250 5250,5340
we got the result of

1724
00:52:28,660 --> 00:52:30,400
5340,6150 6180,6510 6510,6570 6570,6960 6960,7080
fifteen for the sum| and
|我会告诉你演示2只，只需要打个电话给一些人，然后再打个电话给你

1725
00:52:30,400 --> 00:52:31,210
7080,7200 7200,7380 7380,7470 7470,7590 7590,8250
I'll tell you that demo2

1726
00:52:31,210 --> 00:52:32,890
8250,8610 9060,9390 9390,9570
just, just call

1727
00:52:32,890 --> 00:52:34,840
9570,10410 10410,10560 10560,11190 11250,11520
some_then_double| and indeed you
|事实上，你知道，它很高兴地使某些_to返回的总和翻了一番。

1728
00:52:34,840 --> 00:52:37,360
11520,11640 11640,11760 11760,12450 12480,13380 13380,14040
know it happily doubles the

1729
00:52:37,570 --> 00:52:39,580
14250,14760 14760,15300 15300,15450 15450,16260
sum returned by some_to.|
|所以我有一个问题要问任何人，如果我们删除这个开场白和结束语，会发生什么，

1730
00:52:40,600 --> 00:52:42,550
120,480 750,1230 1230,1590 1590,1950 1950,2070
And so a question I

1731
00:52:42,550 --> 00:52:46,240
2070,2430 2430,2910 2910,3660 4530,5160 5160,5760
have for anybody what happens

1732
00:52:46,240 --> 00:52:49,840
5760,6090 6090,6750 6780,7710 7830,8370 8370,9360
if we delete this prologue

1733
00:52:50,200 --> 00:52:52,540
9720,10110 10110,10650 10770,11160 11160,11790 11790,12060
and epilogue,| what happens if
|如果我们只把它作为我们的函数，那么会发生什么呢，som_Then_Double。

1734
00:52:52,540 --> 00:52:54,370
12060,12240 12240,12510 12510,12750 12750,13320 13530,13890
we just have this as

1735
00:52:54,370 --> 00:52:56,020
13890,14040 14040,14610 14610,15420 15420,15540
our function, som_then_double.| Can
|有人能预测到会发生什么事吗？

1736
00:52:56,020 --> 00:52:57,010
15540,15810 15810,16200 16200,16350 16350,16470 16470,16530
anybody predict what's going to

1737
00:52:57,010 --> 00:52:57,700
16530,16980
happen.|
|我的意思是，一件事是SUM_THEN_DOUBLE不知道它应该返回到的返回地址，

1738
00:53:01,590 --> 00:53:02,550
90,240 240,450 450,660 660,900 900,1050
I mean one thing is

1739
00:53:02,550 --> 00:53:04,650
1050,1260 1260,2130 2130,2460 2460,3150
that sum_then_double wouldn't know

1740
00:53:05,110 --> 00:53:06,580
210,540 540,840 840,1230 1230,1440 1470,1680
the return address that it

1741
00:53:06,580 --> 00:53:08,500
1680,1950 1950,2400 2400,2820 3030,3240 3240,3600
should return to,| so upon
|因此，在调用一些_to时，这将覆盖返回地址为sum_Then_Double的

1742
00:53:08,500 --> 00:53:10,680
3600,4170 4170,5250
calling some_to,

1743
00:53:10,870 --> 00:53:12,040
210,510 510,690 690,810 810,1290 1290,1380
that's going to override the

1744
00:53:12,040 --> 00:53:13,720
1380,1770 1770,2280 2280,2430 2430,2640 2640,3510
return address to be sum_then_double's|
|在SUM_THEN_DOUBLE的末尾，它不会返回到最初的调用方。

1745
00:53:13,720 --> 00:53:14,830
3510,3630 3630,3720 3720,3930 3930,4170
at the end of

1746
00:53:15,500 --> 00:53:16,940
180,1020 1080,1290 1290,1440 1440,1620
sum_then_double, it's not going

1747
00:53:16,940 --> 00:53:18,020
1620,1710 1710,2040 2040,2160 2160,2400 2400,2700
to return to its original

1748
00:53:18,020 --> 00:53:18,500
2700,2940
caller.|
|没错，我们可以看到这就是事实。

1749
00:53:19,330 --> 00:53:21,280
30,480 480,1080 1170,1710 1710,1800 1800,1980
Yeah exactly, and we can

1750
00:53:21,280 --> 00:53:23,620
1980,2520 2730,3090 3090,3360 3360,3540 3540,4320
see that that's what happens.|
|再说一次，如果我们退出这个，退出这个

1751
00:53:23,650 --> 00:53:27,460
4350,5370 6240,6720 6720,7140 7140,7590 7680,8160
Again, so if we exit

1752
00:53:27,460 --> 00:53:29,440
8160,8310 8310,8430 8430,9330 9360,9810 9810,10140
out of this and exit

1753
00:53:29,440 --> 00:53:31,510
10140,10260 10260,10320 10320,11100 11880,12030 12030,12210
out of this| and we
|我们用我们的坏函数重新编译了NOW。

1754
00:53:31,510 --> 00:53:33,250
12210,13080 13080,13350 13350,13650 13650,13770 13770,13950
re-compile with now with our

1755
00:53:33,250 --> 00:53:35,340
13950,14370 14370,15060
broken function.|
|我们可以看看到底会发生什么，

1756
00:53:35,650 --> 00:53:36,580
90,270 270,450 450,690 690,750 750,1020
We can take a look

1757
00:53:36,580 --> 00:53:37,810
1020,1110 1110,1530 1530,1710 1710,1920 1920,2250
at exactly what's gonna happen,|
|因此，我们实际上可以为sum_Then_Double设置中断点。

1758
00:53:37,810 --> 00:53:39,640
2250,2460 2460,2610 2610,3000 3000,3570 3750,4080
so we can actually set

1759
00:53:39,640 --> 00:53:40,990
4080,4230 4230,4500 4500,4920 4920,5040 5040,6090
our break point for sum_then_double.|
|

1760
00:53:40,990 --> 00:53:42,500
5430,6090
|
|

1761
00:53:42,830 --> 00:53:43,760
150,720
|
|设置TUI并让它继续，所以我们现在运行演示2，

1762
00:53:45,290 --> 00:53:47,930
90,750 780,1110 1110,1500 1530,2730
And set up tui

1763
00:53:48,260 --> 00:53:49,400
3060,3300 3300,3450 3450,3540 3540,4050 4050,4200
and let it continue, so

1764
00:53:49,400 --> 00:53:50,870
4200,4350 4350,4620 4620,4920 4920,5670
we now run demo2,|
|好的，我们在SUM_THEN_DOUBLE。

1765
00:53:50,870 --> 00:53:52,760
5670,6060 6060,6210 6210,6420 6420,7560
okay we're at sum_then_double.|
|同样，这是一个仅限汇编的函数，所以我们将在汇编中查看它，

1766
00:53:53,280 --> 00:53:55,080
120,870 1050,1500 1500,1650 1650,1830 1830,1920
And again, this is an

1767
00:53:55,080 --> 00:53:57,180
1920,2400 2400,2670 2670,3210 3210,3690 3720,4020
assembly only function, so we're

1768
00:53:57,180 --> 00:53:57,810
4020,4140 4140,4200 4200,4380 4380,4440 4440,4650
going to want to look

1769
00:53:57,810 --> 00:53:59,970
4650,4830 4830,5010 5040,5460 5490,6330 6450,6810
at it in assembly,| so
|因此，我们将执行{Layout，ASM}布局寄存器，因为在这种情况下，寄存器中的内容很重要。

1770
00:53:59,970 --> 00:54:03,060
6810,7350 7350,7980 7980,8310 8310,9210 9450,9900
we'll do {layout,asm} layout reg

1771
00:54:03,060 --> 00:54:04,350
9900,10110 10110,10290 10290,10860 10860,11070 11070,11190
because it's important what's in

1772
00:54:04,350 --> 00:54:05,670
11190,11280 11280,11790 11790,11880 11880,12030 12030,12510
the registers in this case.|
|您将看到gdb知道一大堆额外的信息。

1773
00:54:06,620 --> 00:54:07,400
180,390 390,540 540,690 690,870 870,1380
And you'll see that gdb

1774
00:54:07,400 --> 00:54:08,570
1380,1620 1620,1680 1680,1860 1860,2130
knows a whole bunch

1775
00:54:08,570 --> 00:54:10,550
2130,2190 2190,2520 2520,3240 3450,3870 3870,4110
of extra information| and so
|所以我们可以看到，你可以看到目前的ra，

1776
00:54:10,550 --> 00:54:12,000
4110,4230 4230,4410 4410,4710 4710,5130
we can see that,

1777
00:54:13,770 --> 00:54:15,420
1170,1380 1380,1500 1500,1650 1650,1860
you can see that

1778
00:54:15,420 --> 00:54:17,130
1860,1950 1950,3000 3000,3120 3120,3240 3240,3570
ra currently,| so the return
|所以返回地址，当前指向演示2加18，

1779
00:54:17,130 --> 00:54:18,750
3570,3840 3840,4320 4320,4680 4680,4800 4800,5850
address, currently points to demo2

1780
00:54:18,750 --> 00:54:21,660
5880,6390 6420,6720 6720,7440 7500,8100
the plus eighteen,| so,
|因此，在点上有效地进入函数demo2。

1781
00:54:22,580 --> 00:54:23,870
120,300 300,600 600,1050 1050,1290 1290,1410
at points effectively into the

1782
00:54:23,870 --> 00:54:25,280
1410,1860 1860,2550
function demo2.|
|现在我们可以运行了，我们可以一步一步地检查我们的函数，看看会发生什么。

1783
00:54:26,180 --> 00:54:28,130
180,390 390,900 960,1290 1290,1470 1470,2130
And now we can run,

1784
00:54:28,160 --> 00:54:29,780
3120,3300 3300,3420 3420,3630 3630,3780
we can just kind

1785
00:54:29,780 --> 00:54:30,950
3780,3840 3840,4140 4140,4350 4350,4500 4500,4950
of step through our function

1786
00:54:30,950 --> 00:54:32,720
4950,5130 5130,5460 5460,5730 5730,6210
and see what happens.|
|我们调用了sum2，立即可以看到返回地址被sum2覆盖，现在指向sum_Then_Double加4，

1787
00:54:32,900 --> 00:54:35,660
1170,1620 1620,1980 1980,2880
We've called sum2

1788
00:54:35,690 --> 00:54:37,190
2910,3270 3270,3840 3840,3990 3990,4140 4140,4410
and immediately we can see

1789
00:54:37,190 --> 00:54:39,320
4410,4560 4560,4650 4650,5010 5010,5730 5760,6540
that the return address was

1790
00:54:39,320 --> 00:54:41,000
6540,7170 7170,7410 7410,8100 8100,8220
overwritten by sum2 to

1791
00:54:41,000 --> 00:54:42,500
8220,8460 8460,8820 8820,9030 9030,9720
now point to sum_then_double

1792
00:54:42,500 --> 00:54:44,210
9720,9990 9990,10380 10530,10920 10920,11130 11130,11430
plus four,| which makes sense,
|这就说得通了，你知道这就是我们所期望的

1793
00:54:44,210 --> 00:54:44,900
11430,11520 11520,11610 11610,11820 11820,11940 11940,12120
you know that's what we

1794
00:54:44,900 --> 00:54:46,340
12120,12630 12720,13080 13080,13170 13170,13290 13290,13560
expect| if we go back
|如果我们返回到我们的代码，我们调用sum2，因此sum2应该返回到这里。

1795
00:54:46,340 --> 00:54:47,480
13560,13800 13800,13920 13920,14280 14280,14370 14370,14700
into our code, we call

1796
00:54:47,480 --> 00:54:48,950
14700,15480 15540,15810 15810,15930 15930,16410
sum2 and so sum2

1797
00:54:48,950 --> 00:54:50,900
16410,16650 16650,17220 17400,17790
should return to

1798
00:54:50,930 --> 00:54:52,340
18150,18630
here.|
|现在我们可以一步一步地走过去，你知道的，等等，然后我们再回到。

1799
00:54:52,750 --> 00:54:54,460
210,360 360,870 900,1260 1260,1530 1530,1920
And now we can step

1800
00:54:54,460 --> 00:54:57,310
1920,2670 3090,3570 3570,3840 3840,4200 4200,4770
through you know so on

1801
00:54:57,370 --> 00:54:59,080
4830,5280 5310,6300
up and

1802
00:54:59,280 --> 00:55:01,020
0,270 270,390 390,570 570,960 960,1740
then we get back into.|
|哎呀，弄错了。

1803
00:55:03,550 --> 00:55:04,940
150,540
Oops,

1804
00:55:05,410 --> 00:55:09,120
90,630 930,1440 1440,2070
the wrong s.|
|好的，现在我们在这里，当SUM_THEN_DOUBLE正如阿米尔所指出的那样返回时

1805
00:55:14,490 --> 00:55:15,720
810,1110 1110,1290 1290,1560 1560,1680 1680,2040
Okay, so now we're here

1806
00:55:15,720 --> 00:55:17,040
2040,2130 2130,2370 2370,2550 2550,3360
and now when sum_then_double

1807
00:55:17,040 --> 00:55:19,260
3360,3960 4410,4680 4680,5160 5160,5310 5310,5580
returns as exactly as Amir

1808
00:55:19,260 --> 00:55:21,840
5580,5910 5910,6270 7140,7470 7470,7980 7980,8160
pointed out| its return, it
|它的返回地址，它没有恢复自己的返回地址，而是它的返回地址仍然是

1809
00:55:21,840 --> 00:55:23,130
8160,8370 8370,8610 8610,9090 9090,9210 9210,9450
has not restored its own

1810
00:55:23,130 --> 00:55:25,260
9450,9810 9810,10410 10530,10830 10830,11340 11340,11580
return address and instead its

1811
00:55:25,260 --> 00:55:26,220
11580,11850 11850,12150 12150,12240 12240,12480 12480,12540
return address is still the

1812
00:55:26,220 --> 00:55:27,750
12540,12780 12780,12930 12930,13110 13110,13560 13560,14070
one that was used by

1813
00:55:27,990 --> 00:55:28,880
14310,14850
|
|SUM_TO，所以我们将进入一个无限循环，在那里我们一遍又一遍地重复这个过程

1814
00:55:29,230 --> 00:55:31,090
90,1110 1170,1500 1500,1770 1770,1950
sum_to, and so we

1815
00:55:31,090 --> 00:55:33,100
1950,2340 2370,2910 2910,3420 3420,3540 3540,3960
will get into an infinite

1816
00:55:33,100 --> 00:55:35,350
3960,4500 4530,4800 4800,4950 4950,5580 5610,6210
loop where we just keep

1817
00:55:35,350 --> 00:55:36,940
6210,6690 6690,7110 7110,7500 7500,7590 7590,7800
doing this over and over

1818
00:55:36,940 --> 00:55:38,200
7800,7920 7920,8130 8130,8580 8790,8970 8970,9060
and over again| and we'll
|我们永远不会就此结束。

1819
00:55:38,200 --> 00:55:39,840
9060,9300 9300,9840 9840,10020 10020,10230
never terminate from it.|
|因此，我认为这很好地说明了为什么跟踪我们的呼叫者与被呼叫者保存的寄存器很重要

1820
00:55:39,900 --> 00:55:41,010
120,300 300,420 420,660 660,810 810,1230
And so this is I

1821
00:55:41,220 --> 00:55:42,150
1440,1950 1950,2070 2070,2130 2130,2220 2220,2370
think this is a good

1822
00:55:42,150 --> 00:55:43,890
2370,3030 3030,3180 3180,3420 3420,3630 3630,4110
illustration of why it's important

1823
00:55:43,890 --> 00:55:44,910
4110,4230 4230,4500 4500,4830 4830,4920 4920,5130
to keep track of our

1824
00:55:44,910 --> 00:55:47,520
5130,5670 5670,6090 6090,6510 6510,6900 6900,7740
caller versus callee saved registers|
|希望这也表明您可以使用某种gdb来调试这类问题，

1825
00:55:47,730 --> 00:55:49,020
7950,8190 8190,8520 8520,8670 8670,8940 8940,9240
and hopefully this also shows

1826
00:55:49,020 --> 00:55:50,790
9240,9330 9330,9480 9480,9780 10290,10800 10800,11010
that you can use kind

1827
00:55:50,790 --> 00:55:52,590
11010,11100 11100,11610 11610,11970 11970,12810
of gdb to debug

1828
00:55:53,000 --> 00:55:54,680
60,360 360,660 660,1110 1260,1530 1530,1740
these sorts of these sorts

1829
00:55:54,680 --> 00:55:56,450
1740,1830 1830,2250 2250,2370 2370,2790 2850,3510
of problems,| so let's restore
|所以让我们恢复我们曾经拥有的。

1830
00:55:56,450 --> 00:55:57,600
3510,3630 3630,3720 3720,4380
what we had.|
|我将进入其他一些演示来讲解。

1831
00:55:58,190 --> 00:55:59,900
150,480 480,660 660,960 960,1560 1560,1860
I will go into some

1832
00:55:59,900 --> 00:56:02,540
1860,2130 2130,2850 3120,3750 3750,4080 4080,4500
other demos to talk about

1833
00:56:04,370 --> 00:56:06,800
6330,6480 6480,7170 7200,7650 7740,8340 8340,8760
to illustrate a.| Somebody ask
|有人问我们为什么要减去16。

1834
00:56:06,800 --> 00:56:08,750
8760,9000 9000,9330 9330,9540 9540,10050 10050,10710
why are we subtracting 16.|
|这是为了给我们的堆栈框架留出空间，

1835
00:56:08,780 --> 00:56:10,640
10740,11250 11250,11640 11640,11880 11880,12300 12300,12600
That's to put space to

1836
00:56:10,670 --> 00:56:12,860
12630,12900 12900,13020 13020,13290 13290,13620 13890,14820
get our stack frame,| so
|所以这是从堆栈指针中减去16，

1837
00:56:12,920 --> 00:56:14,960
14880,15390 15390,15630 15630,16260 16260,16710 16710,16920
this is subtracting 16 from

1838
00:56:14,960 --> 00:56:16,310
16920,17010 17010,17370 17370,17940 17970,18150 18150,18270
the stack pointer,| so it's
|所以它基本上是在内存中向下移动。

1839
00:56:16,310 --> 00:56:17,510
18270,18570 18570,18660 18660,18990 18990,19410 19410,19470
moving it down basically in

1840
00:56:17,510 --> 00:56:18,380
19470,20040
memory.|
|将其向下移动，以便我们现在有空间容纳我们自己的堆栈帧，

1841
00:56:18,520 --> 00:56:20,560
1170,1680 1680,1770 1770,2070 2070,2160
Moving it down so

1842
00:56:20,560 --> 00:56:21,550
2160,2340 2340,2400 2400,2580 2580,2760 2760,3150
that we now have space

1843
00:56:21,550 --> 00:56:22,660
3150,3300 3300,3420 3420,3630 3630,3900 3900,4260
for our own stack frame,|
|然后我们就可以把东西贴在那里了。

1844
00:56:22,660 --> 00:56:23,560
4260,4380 4380,4470 4470,4620 4620,4890 4890,5160
then we can stick stuff

1845
00:56:23,560 --> 00:56:24,200
5160,5430
there.|
|因为在这一点上，事实上我们不想覆盖堆栈指针上的内容，

1846
00:56:24,360 --> 00:56:25,920
120,300 300,600 600,1470 1470,1680
So because at this

1847
00:56:25,920 --> 00:56:27,090
1680,1920 1920,1980 1980,2460 2460,2760 2760,2850
point, in fact that we

1848
00:56:27,090 --> 00:56:28,230
2850,3060 3060,3180 3180,3240 3240,3720 3720,3990
don't want to override what's

1849
00:56:28,230 --> 00:56:30,300
3990,4170 4170,4260 4260,4560 4560,5040
at the stack pointer,|
|为什么不是4，我只是，嗯，4，我们需要做16，因为指令是64。

1850
00:56:30,300 --> 00:56:31,980
6060,6390 6390,6660 6660,7140 7200,7440 7440,7740
why not 4, I is

1851
00:56:31,980 --> 00:56:33,480
7740,8220
just,

1852
00:56:33,790 --> 00:56:35,540
90,390 390,1650
well 4,

1853
00:56:36,890 --> 00:56:38,180
90,270 270,420 420,480 480,660 660,1380
we need to do 16

1854
00:56:38,180 --> 00:56:41,300
1380,1740 1740,2250 2250,2550 2550,3750
because instructions are 64.|
|是的，我想我们实际上不需要做16个，

1855
00:56:42,560 --> 00:56:44,780
1740,1890 1890,2040 2040,2250 2250,2340
Yeah I guess I

1856
00:56:44,780 --> 00:56:46,430
2340,2490 2490,2610 2610,3060 3150,3540 3570,3990
guess we wouldn't don't actually

1857
00:56:46,430 --> 00:56:48,560
3990,4500 4500,4590 4590,4770 4770,5610 5670,6120
need to do 16,| but
|但这通常是你会看到的，一般只会看到，我不认为你，你不能，你不能做4，因为你需要8。

1858
00:56:48,560 --> 00:56:50,300
6120,6360 6360,6960 6960,7260 7260,7440 7440,7860
that's generally what you'll see,

1859
00:56:51,060 --> 00:56:52,830
1110,1650 1650,2040 2040,2160 2160,2250
generally just see I

1860
00:56:52,830 --> 00:56:54,900
2250,2460 2460,2610 2610,3420 3600,4110 4110,4320
don't think yeah you, you

1861
00:56:54,900 --> 00:56:56,130
4320,4650 4650,4770 4770,5010 5010,5160 5160,5550
can't you can't do 4

1862
00:56:56,130 --> 00:56:57,920
5550,6330 6360,6480 6480,6690 6690,7170
because you need 8.|
|前面不管用，但我想你可以做指令大小。且寄存器的大小为64个，

1863
00:56:58,070 --> 00:56:59,030
90,420 420,660 660,870 870,990 990,1050
Before doesn't work, but I

1864
00:56:59,030 --> 00:57:01,910
1050,1200 1200,1290 1290,1380 1380,2010 3240,3930
think you could do the

1865
00:57:01,910 --> 00:57:03,100
3930,4410 4410,4950
instruction size.

1866
00:57:03,320 --> 00:57:03,980
180,330 330,420 420,690 690,750 750,840
And the size of the

1867
00:57:03,980 --> 00:57:06,590
840,1560 1560,1950 1950,2040 2040,2820 3120,3450
register registers are 64,| yeah,
|是的，那么惯例为什么你通常会看到16是因为如果我们跳回我们的文档，

1868
00:57:06,590 --> 00:57:07,760
3450,3600 3600,3750 3750,3930 3930,4080 4080,4620
and then so the convention

1869
00:57:07,760 --> 00:57:09,290
4620,4860 4860,5010 5010,5340 5340,5580 5580,6150
why you usually see 16

1870
00:57:09,290 --> 00:57:10,250
6150,6270 6270,6480 6480,6570 6570,6780 6870,7110
is because if we jump

1871
00:57:10,250 --> 00:57:11,870
7110,7350 7350,7440 7440,7530 7530,8160 8250,8730
back to our document,| usually
|通常我们有返回地址和帧指针，我们在这里不这样做，因为或者不是非常小心地处理我们的程序集。

1872
00:57:11,870 --> 00:57:13,160
8730,8970 8970,9150 9150,9210 9210,9510 9510,10020
we have the return address

1873
00:57:13,160 --> 00:57:15,140
10020,10290 10290,10500 10500,10770 10770,11220
and the frame pointer,

1874
00:57:15,140 --> 00:57:16,190
12000,12210 12210,12360 12360,12570 12570,12780 12780,13050
we're not doing that here

1875
00:57:16,190 --> 00:57:17,060
13050,13680
because

1876
00:57:17,460 --> 00:57:18,560
120,300 300,630
or being,

1877
00:57:19,040 --> 00:57:20,600
60,390 390,630 630,1080 1080,1320 1320,1620
not super careful with our

1878
00:57:20,600 --> 00:57:21,520
1620,2220
assembly.|
|所以通常情况下，如果我们看内部，我肯定如果我们看内核，我们就会明白这一点。

1879
00:57:22,240 --> 00:57:23,470
120,300 300,870 870,1020 1020,1230 1230,1350
So normally, if we if

1880
00:57:23,470 --> 00:57:25,660
1350,1440 1440,1680 1680,1980 3120,3540
we look in, I'm

1881
00:57:25,660 --> 00:57:26,350
3540,3690 3690,3840 3840,3930 3930,4110 4110,4230
sure if we look in

1882
00:57:26,350 --> 00:57:27,520
4230,4590 4590,4710 4710,5070 5070,5220 5220,5400
kernel at this and we'll

1883
00:57:27,520 --> 00:57:28,240
5400,5910
see.|
|是的，所以我们查看内核数据，我们发现它也是16，

1884
00:57:29,010 --> 00:57:29,910
270,600 600,780 780,900 900,1050 1050,1170
Yeah, so we look in

1885
00:57:29,910 --> 00:57:32,190
1170,1500 1500,1980 2940,3150 3150,3300 3300,3450
kernel data, we see it's

1886
00:57:32,190 --> 00:57:33,780
3450,3930 3930,4410 4410,4530 4530,4680 4680,5040
also 16,| this is generally
|这通常是您在编译器中看到的。

1887
00:57:33,780 --> 00:57:34,470
5040,5190 5190,5340 5340,5520 5520,5640 5640,5730
what you'll see with the

1888
00:57:34,470 --> 00:57:35,240
5730,6300
compiler.|
|嗯，好吧，现在我们可以了。

1889
00:57:37,970 --> 00:57:41,690
90,870 1260,1800 1890,2910 3240,3630 3630,3810
Um, OK, so now we

1890
00:57:41,690 --> 00:57:42,520
3810,4350
can.|
|在这之后。

1891
00:57:44,000 --> 00:57:45,560
120,510 510,1080
After this.|
|我们修复了我们的函数，现在我们可以查看一些C代码。

1892
00:57:46,680 --> 00:57:48,600
840,1020 1020,1290 1290,1440 1440,2100 2550,2760
We fix our function and

1893
00:57:48,600 --> 00:57:49,410
2760,3060 3060,3150 3150,3300 3300,3480 3480,3570
now we can look at

1894
00:57:49,410 --> 00:57:50,720
3570,3750 3750,3990 3990,4650
some C code.|
|好的，现在我们有演示4

1895
00:57:54,650 --> 00:57:56,420
90,420 420,540 540,810 810,930 930,1860
Alright, so here we have

1896
00:57:56,450 --> 00:57:58,670
1890,3210 3210,3630 3630,3840 3840,4110
demo4| which is just
|它基本上就是主函数的副本，

1897
00:57:58,670 --> 00:58:00,460
4110,4830
basically,

1898
00:58:00,690 --> 00:58:01,710
150,330 330,690 690,780 780,870 870,1170
a copy of a main

1899
00:58:01,710 --> 00:58:04,080
1170,1680 1680,1830 1830,2190 2220,3060 3060,3540
function,| like a imitation of
|类似于对main函数的模拟，所以我们有我们的args，它是一个字符串数组

1900
00:58:04,080 --> 00:58:06,720
3540,3660 3660,3990 3990,4680 4860,5670 5940,6180
the main function, so we

1901
00:58:06,720 --> 00:58:09,240
6180,6720 6750,7350 7380,8220 8460,8700
have our args, which

1902
00:58:09,240 --> 00:58:10,620
8700,8790 8790,8910 8910,9150 9150,9240 9240,10080
is an array of strings|
|我们有dummymain，它接受一些参数和参数字符串，然后为我们打印出来。

1903
00:58:10,740 --> 00:58:12,390
10200,10650 10650,10770 10770,11190 11190,11850
and we have dummymain

1904
00:58:12,390 --> 00:58:14,550
11850,12030 12030,12720 12990,13620 13620,13920 13920,14010
which takes a number of

1905
00:58:14,550 --> 00:58:16,800
14010,14790 14790,15120 15120,15240 15240,15750 15750,16260
arguments and the arguments string

1906
00:58:16,800 --> 00:58:18,180
16260,16650 16650,16890 16890,17130 17130,17370 17370,17640
and just print it out,

1907
00:58:18,360 --> 00:58:19,660
18210,18540 18540,18930
for us.|
|这就是所有的事情，这里发生的一切都很简单，

1908
00:58:20,130 --> 00:58:21,150
210,390 390,480 480,690 690,810 810,1230
And so that's all that's

1909
00:58:21,240 --> 00:58:22,830
1320,1680 1680,1830 1830,1980 1980,2370 2370,2910
that's all that's happening here

1910
00:58:22,950 --> 00:58:25,380
3030,3120 3120,3360 3360,4470 5250,5460
is pretty straightforward,| if
|如果我们在DummyMain中设置断点。

1911
00:58:25,380 --> 00:58:27,060
5460,5580 5580,6060 6090,6270 6270,6660 6660,7140
we set a break point

1912
00:58:27,060 --> 00:58:29,900
7140,7740 7860,9090
in dummymain.|
|然后跳过来，让。

1913
00:58:31,380 --> 00:58:35,200
180,690 690,1020 1020,1890 2430,2970
Then hop over, let.|
|好的，我们就继续我们开始这场比赛，

1914
00:58:35,620 --> 00:58:38,050
120,540 540,870 870,1080 1080,1950 2010,2550
Okay, we'll just continue and

1915
00:58:38,290 --> 00:58:40,210
2790,3150 3150,3450 3450,3960 3990,4320 4320,4710
we start this run down

1916
00:58:40,210 --> 00:58:41,950
4710,5340 5460,5850 5850,6000 6000,6150 6150,6450
for,| okay so we now
|好的，现在我们点击DummyMain。

1917
00:58:41,950 --> 00:58:42,860
6450,6570 6570,7170
we hit

1918
00:58:42,890 --> 00:58:44,480
570,1380
dummymain.|
|有几件重要的事情需要记住，

1919
00:58:45,080 --> 00:58:45,950
120,300 300,420 420,510 510,870 870,990
And there's a couple of

1920
00:58:45,950 --> 00:58:50,570
990,1770 1770,2610 2640,3540 3780,4770 4770,5610
important things to remember about,|
|您可以使用gdb来处理堆栈帧，

1921
00:58:51,560 --> 00:58:52,700
840,1050 1050,1170 1170,1260
that you can

1922
00:58:52,700 --> 00:58:54,020
1260,1440 1440,1800 1800,2010 2010,2310 2310,2580
use gdb for regarding stack

1923
00:58:54,020 --> 00:58:55,550
2580,2970 3150,3420 3420,3540 3540,3660 3660,4110
frames,| so if we type
|因此，如果我们再次键入{i，so}，这就是信息，如果我们键入i frame，我们可以看到一大堆关于当前堆栈帧的有用信息，

1924
00:58:55,550 --> 00:58:58,340
4110,5160 5160,5340 5340,5580 5580,6450
{i,so} again, that's info,

1925
00:58:58,340 --> 00:58:59,690
6900,7020 7020,7110 7110,7380 7380,7380 7380,8250
if we type i frame,

1926
00:58:59,810 --> 00:59:00,650
8370,8550 8550,8670 8670,8910 8910,9030 9030,9210
we can see a whole

1927
00:59:00,650 --> 00:59:03,320
9210,9510 9510,10080 10110,10560 10560,11370 11370,11880
bunch of useful information about

1928
00:59:03,320 --> 00:59:05,060
11880,11970 11970,12480 12480,12810 12810,13200 13350,13620
the current stack frame,| so
|所以我们可以看到我们在堆栈级别0，

1929
00:59:05,060 --> 00:59:05,750
13620,13710 13710,13860 13860,14070 14070,14220 14220,14310
we can see we're at

1930
00:59:05,750 --> 00:59:07,430
14310,14670 14670,14910 14910,15330 15330,15630 15630,15990
stack level zero,| level zero
|级别0意味着它(一个地球)在调用堆栈的下面，我们可以转到

1931
00:59:07,430 --> 00:59:09,260
15990,16560 16650,16980 16980,17400 17430,17670 17670,17820
means it's [a earth] is

1932
00:59:09,260 --> 00:59:10,550
17820,18270 18270,18390 18390,18480 18480,18750 18750,19110
down in the call stack

1933
00:59:10,550 --> 00:59:12,500
19110,19260 19260,19380 19380,19560 19560,20100 20610,21060
that we can go| and
|帧在这个地址。

1934
00:59:12,500 --> 00:59:13,910
21060,21180 21180,21840 21870,22080 22080,22260 22260,22470
the frame is at this

1935
00:59:13,910 --> 00:59:14,860
22470,23310
address.|
|程序计数器没问题，一切都很好，

1936
00:59:15,570 --> 00:59:17,610
450,720 720,1140 1140,1830 1920,2370 2370,2490
The program counter which is

1937
00:59:17,610 --> 00:59:18,570
2490,2760 2760,2970 2970,3150 3150,3330 3330,3450
okay, that's all well and

1938
00:59:18,570 --> 00:59:19,980
3450,4020 4080,4320 4320,4410 4410,4470 4470,4860
good,| we have a safe
|我们还有一个安全的程序计数器，

1939
00:59:19,980 --> 00:59:22,200
4860,5280 5280,5670 5670,5790 5790,6330 6510,7080
program counter as well,| and
|如果我们再次使用这个地址，并跳转到kernel.asm。

1940
00:59:22,200 --> 00:59:23,580
7080,7350 7350,7620 7650,7980 7980,8100 8100,8460
if we again if we

1941
00:59:23,610 --> 00:59:25,410
8490,8730 8730,8880 8880,9570 9840,10050 10050,10290
take this address and we

1942
00:59:25,410 --> 00:59:28,680
10290,10800 10830,11730 11880,13560
jump into kernel.asm.|
|我们搜索那个地址，我们确实可以，在demo4里面的那个地址，

1943
00:59:29,850 --> 00:59:31,410
150,360 360,720 720,840 840,1050 1050,1710
We search for that address,

1944
00:59:31,470 --> 00:59:34,380
1770,2100 2100,2280 2280,3300 3510,4140
we can indeed that,

1945
00:59:34,380 --> 00:59:37,360
4680,5070 5070,6000 6000,6750 6750,7290
that addresses inside of,

1946
00:59:38,360 --> 00:59:40,340
180,1020 1020,1350 1350,2010 2010,2160
inside of demo4,| which
|这正是我们希望程序返回的位置

1947
00:59:40,340 --> 00:59:42,050
2160,2310 2310,2700 2700,2910 2910,3090 3090,3870
is exactly where we expect

1948
00:59:42,080 --> 00:59:44,420
3900,4410 4410,5010 5010,5370 5370,5790 5790,6240
the program to return to|
|它是由这个地址的帧调用的

1949
00:59:44,690 --> 00:59:46,400
6510,7260 7260,7320 7320,7530 7530,8040 8040,8220
and it was called by

1950
00:59:46,400 --> 00:59:48,140
8220,8340 8340,8820 8820,8940 8940,9180 9180,9960
a frame at this address|
|源语言C，很高兴知道这一点，然后我们有参数列表，也是从这个地址开始的，

1951
00:59:48,170 --> 00:59:50,360
9990,10560 10560,10950 10950,11580 11610,11940 11940,12180
source language C, that's that's

1952
00:59:50,360 --> 00:59:52,130
12180,12720 12840,13230 13230,13560 13560,13770 13770,13950
nice to know and then

1953
00:59:52,130 --> 00:59:53,720
13950,14070 14070,14490 14490,14610 14610,15090 15090,15540
we have the argument list

1954
00:59:53,720 --> 00:59:56,030
15540,15900 15900,16260 16260,16590 16590,17280
also starts this address,|
|当然，在本例中，我们的大部分参数都在寄存器中

1955
00:59:56,030 --> 00:59:57,410
17850,17940 17940,18390 18870,19050 19050,19230
of course, in this

1956
00:59:57,410 --> 00:59:58,420
19230,19800
case,

1957
00:59:58,580 --> 00:59:59,210
120,270 270,390 390,570 570,630 630,750
we have most of our

1958
00:59:59,210 --> 01:00:01,940
750,1380 1410,1770 1770,2610 3360,3480
arguments in registers| and
|然后我们甚至可以看到args是什么，argc是3，argv是这个地址。

1959
01:00:01,940 --> 01:00:03,050
3480,3600 3600,3720 3720,3870 3870,4170 4170,4590
then we can even see

1960
01:00:03,050 --> 01:00:05,390
4590,4950 4950,5310 5310,5610 5610,5850 5850,6930
what args are we argc

1961
01:00:05,650 --> 01:00:08,200
90,780 780,1320 1320,1890 1890,2640
is three and argv

1962
01:00:08,200 --> 01:00:09,620
2640,2970 2970,3180 3180,3930
is this address.|
|如果我们想要更深入地研究一些东西，我们可以看看像info args这样的东西，

1963
01:00:10,440 --> 01:00:11,700
180,630 750,1080 1080,1170 1170,1380 1380,1440
And if we want a

1964
01:00:11,700 --> 01:00:14,010
1440,1830 1830,2640 2670,3270 3270,3660 3660,3750
more in-depth examine things we

1965
01:00:14,010 --> 01:00:15,420
3750,3930 3930,4200 4200,4320 4320,4620 4620,5160
can look at things like

1966
01:00:15,480 --> 01:00:17,000
5460,5910 5910,6570
info args,|
|它将告诉我们有关函数参数的信息，我们可以查看，

1967
01:00:17,680 --> 01:00:19,210
120,420 420,570 570,870 870,1050 1050,1650
which will tell us information

1968
01:00:19,210 --> 01:00:20,230
1650,1860 1860,2010 2010,2460 2460,2550 2550,2670
about the arguments to the

1969
01:00:20,230 --> 01:00:23,080
2670,3420 3630,4020 4020,4500 4500,4860 4860,5520
function, we can look at,|
|但更重要的是，我们可以键入回溯或bt works，

1970
01:00:23,200 --> 01:00:25,420
6060,6210 6210,6420 6420,7320 7560,7860
but more importantly we

1971
01:00:25,420 --> 01:00:26,830
7860,8160 8160,8670 8670,8760 8760,9000 9000,9960
can type we type backtrace

1972
01:00:26,830 --> 01:00:29,140
10170,10560 10560,11070 11070,11400 11400,11580
or bt works as

1973
01:00:29,140 --> 01:00:31,270
11580,12090 12300,12810 12810,13110 13110,13290 13290,13710
well,| we get a form
|我们得到了所有堆栈的表单回溯，

1974
01:00:31,270 --> 01:00:33,790
13710,14490 14490,15030 15060,15450 15450,15630 15630,16230
backtrace of all of the

1975
01:00:33,820 --> 01:00:35,770
16260,17100 17700,18120 18120,18210
stacks,| all of
|调用堆栈中的所有堆栈帧，

1976
01:00:35,770 --> 01:00:37,600
18210,18300 18300,18660 18660,19290 19350,19920 19920,20040
the stack frames from the

1977
01:00:37,600 --> 01:00:38,710
20040,20280 20280,20610 20610,20880 20880,21060 21060,21150
call stack,| so you can
|所以你可以看到一些可疑的事情在这里发生，

1978
01:00:38,710 --> 01:00:40,630
21150,21630 21630,21990 21990,22440 22440,22680 22680,23070
see something questionable happen here,|
|这就是我们调用系统调用的时候，然后我们到达userTrap函数，

1979
01:00:40,630 --> 01:00:41,590
23070,23310 23310,23460 23460,23610 23610,23970 23970,24030
that's when we invoke a

1980
01:00:41,590 --> 01:00:43,870
24030,24420 24420,24900 25830,26220 26220,26310
system call, then we

1981
01:00:43,870 --> 01:00:45,130
26310,26460 26460,26520 26520,26610 26610,27570
get to the usertrap

1982
01:00:45,130 --> 01:00:46,360
27570,28080 28110,28320 28320,28410 28410,28530 28530,29160
function,| then to the syscall
|然后转到syscall函数，然后转到sys_demo，然后转到demo4。

1983
01:00:46,360 --> 01:00:48,340
29160,29970 30030,30390 30390,30510 30510,31560
function, then to sys_demo,

1984
01:00:48,340 --> 01:00:50,710
31620,31980 31980,32070 32070,33150
then to demo4.|
|然后最后转到DummyMain

1985
01:00:51,510 --> 01:00:52,860
210,420 420,600 600,1140 1140,1260 1260,2040
And then finally to dummymain|
|如果我们想更深入地研究这些堆栈框架中的任何一个，

1986
01:00:52,860 --> 01:00:54,810
2910,3120 3120,3210 3210,3300 3300,3510
and if we want

1987
01:00:54,810 --> 01:00:56,340
3510,3690 3690,4590 4590,4800 4800,4890 4890,5040
to investigate any of these

1988
01:00:56,340 --> 01:00:58,620
5040,5370 5370,5820 5940,6570 6570,7050 7050,7320
stack frames more in-depth,| we
|我们可以做边框，然后在这边上画任何数字，

1989
01:00:58,650 --> 01:01:00,300
7350,7530 7530,7890 7890,8520 8520,8730 8730,9000
can do frame and then

1990
01:01:00,300 --> 01:01:02,460
9000,9390 9390,10110 10560,10800 10800,11160
whatever number is along

1991
01:01:02,460 --> 01:01:03,570
11160,11250 11250,11640 11640,11940 11940,12060 12060,12270
the side here,| so let's
|假设我想看看当syscall调用时我的堆栈框架是什么，{i，can}转到第3帧，

1992
01:01:03,570 --> 01:01:04,230
12270,12420 12420,12510 12510,12690 12690,12750 12750,12930
say I want to look

1993
01:01:04,230 --> 01:01:05,130
12930,12990 12990,13170 13170,13320 13320,13470 13470,13830
at what was my stack

1994
01:01:05,130 --> 01:01:07,350
13830,14370 14430,14910 14910,15690 15690,16050
frame when syscall called,

1995
01:01:07,350 --> 01:01:08,670
16050,16200 16200,16290 16290,16410 16410,16770 16770,17370
{I,can} go to frame three,|
|现在，在gdb内部，我正在查看堆栈框架，所以我输入info frame，我可以得到这个。

1996
01:01:08,940 --> 01:01:10,440
17640,17790 17790,17910 17910,18210 18750,19140
and so now, inside

1997
01:01:10,440 --> 01:01:11,400
19140,19200 19200,19650 19650,19830 19830,20100
of gdb, I'm looking

1998
01:01:11,400 --> 01:01:12,330
20100,20220 20220,20430 20430,20700 20700,20880 20880,21030
at that stack frame, so

1999
01:01:12,330 --> 01:01:14,130
21030,21210 21210,21510 21510,21840 21840,22380 22440,22830
I type info frame I

2000
01:01:14,130 --> 01:01:15,120
22830,22950 22950,23130 23130,23610
can get this.|
|这里我们得到了更多更多的信息，我们有一堆保存寄存器。

2001
01:01:15,700 --> 01:01:16,390
120,360 360,570 570,630 630,750 750,810
And here we get a

2002
01:01:16,390 --> 01:01:17,980
810,1020 1020,1440 1560,1920 1920,2100 2100,2400
lot more a lot more

2003
01:01:17,980 --> 01:01:19,210
2400,3060 3060,3180 3180,3330 3330,3390 3390,3630
information we have a bunch

2004
01:01:19,210 --> 01:01:21,300
3630,3720 3720,4110 4110,5400
of saves registers.|
|嗯，我们有一些局部变量，

2005
01:01:21,410 --> 01:01:23,870
150,930 1170,1380 1380,1920 1920,2190 2190,2610
Um, we have some local

2006
01:01:23,870 --> 01:01:25,760
2610,3810 3810,3900 3900,4110 4110,4290 4290,4500
variables,| we don't have any
|我们对这个函数没有任何参数，

2007
01:01:25,760 --> 01:01:27,800
4500,5100 5100,5190 5190,5400 5400,6180 6270,6540
arguments to this function,| we
|我们可以看到程序计数器应该跳回到哪里，

2008
01:01:27,800 --> 01:01:28,880
6540,6660 6660,6930 6930,7170 7170,7260 7260,7620
can see where the program

2009
01:01:28,880 --> 01:01:30,260
7620,8130 8130,8370 8370,8670 8670,8760 8760,9000
counter were supposed to jump

2010
01:01:30,260 --> 01:01:32,030
9000,9300 9300,9780 10260,10500 10500,10770
back to,| all kinds
|诸如此类的东西，所以如果你在调试东西，这是非常非常有用的

2011
01:01:32,030 --> 01:01:32,840
10770,10830 10830,11130 11130,11310 11310,11490 11490,11580
of things like that, so

2012
01:01:32,840 --> 01:01:34,100
11580,11730 11730,11820 11820,12120 12120,12420 12420,12840
this is super super useful

2013
01:01:34,100 --> 01:01:35,780
12840,13230 13320,13620 13620,13740 13740,14250 14250,14520
for if you're debugging things|
|事实上，它非常有用，我们让您实现自己的版本，远不如gdb告诉您的那样深入。

2014
01:01:35,780 --> 01:01:36,500
14520,14610 14610,14700 14700,14940 14940,15090 15090,15240
and in fact it's so

2015
01:01:36,500 --> 01:01:38,540
15240,15870 15900,16140 16140,16380 16380,16500 16500,17280
useful, we make you implement

2016
01:01:39,020 --> 01:01:41,630
17760,18000 18000,18240 18240,18930 18990,19950 19950,20370
your own version, nowhere near

2017
01:01:41,630 --> 01:01:42,560
20370,20610 20610,20700 20700,21000 21000,21090 21090,21300
as in depth as what

2018
01:01:42,560 --> 01:01:44,810
21300,21660 21660,22020 22020,22320 22470,22830 22830,23550
gdb tells you,| but we're
|但是我们在下一个实验中的练习之一是实现您自己的回溯助手函数

2019
01:01:44,960 --> 01:01:46,100
23700,23940 23940,24030 24030,24120 24120,24690 24690,24840
one of the exercises on

2020
01:01:46,100 --> 01:01:47,210
24840,24930 24930,25200 25200,25560 25560,25770 25770,25950
the next lab will be

2021
01:01:47,210 --> 01:01:48,950
25950,26100 26100,26610 26610,26790 26790,27180 27240,28320
to implement your own backtrace

2022
01:01:48,950 --> 01:01:50,960
28350,28710 28710,29220 29220,29430 29430,29700
helper function| for use
|供在实验室内调试时使用。

2023
01:01:50,960 --> 01:01:52,610
29700,30030 30030,30600 30600,30930 30930,31260 31260,31350
when debugging things inside the

2024
01:01:52,610 --> 01:01:53,500
31350,31740
lab.|
|因此回溯非常有用，

2025
01:01:54,110 --> 01:01:55,250
150,360 360,480 480,720 720,1290
And so back backtrace

2026
01:01:55,250 --> 01:01:56,990
1410,1920 1920,2190 2190,2730 2820,3030
is quite useful,| and
|然后如果我们输入帧0，我们就会返回到我们应该在的位置。

2027
01:01:56,990 --> 01:01:57,770
3030,3180 3180,3300 3300,3360 3360,3600 3600,3810
then if we type frame

2028
01:01:57,770 --> 01:01:59,240
3810,4290 4290,4380 4380,4530 4530,4800 4800,5280
zero, we go back to

2029
01:01:59,270 --> 01:02:00,740
5310,5730 5730,5880 5880,6180 6180,6690 6690,6780
where we were supposed to

2030
01:02:00,740 --> 01:02:01,240
6780,7020
be.|
|如果我们想要调查，你可能会注意到这不是很有帮助，

2031
01:02:02,900 --> 01:02:04,220
300,810 990,1170 1170,1290 1290,1500 1500,1620
And if we want to

2032
01:02:04,220 --> 01:02:05,780
1620,2070 2070,2190 2190,2400 2400,2790 2790,3180
investigate you probably noticed it's

2033
01:02:05,780 --> 01:02:07,070
3180,3390 3390,3750 3750,4290 4290,4350 4350,4470
not super helpful,| you know
|您知道argv是字符串数组形式的字符串

2034
01:02:07,070 --> 01:02:08,390
4470,4920 4920,5070 5070,5160 5160,5790
argv is a string

2035
01:02:08,540 --> 01:02:09,950
6720,6930 6930,7020 7020,7260 7260,7350
as an array of

2036
01:02:09,950 --> 01:02:11,180
7350,7860 7860,8040 8040,8250 8250,8370 8370,8580
strings| and so we just
|所以我们拿到了推荐人，我们拿到了地址

2037
01:02:11,180 --> 01:02:12,080
8580,8730 8730,8850 8850,9150 9150,9300 9300,9480
got a ref, we just

2038
01:02:12,080 --> 01:02:14,060
9480,9660 10020,10440 10440,11100 11160,11460
get an address| for
|如果我们想看看里面有什么，有几种方法可以做到这一点，

2039
01:02:14,060 --> 01:02:16,250
11460,11760 11760,12000 12000,12420 12420,13110 13380,13650
where that's actually stored and

2040
01:02:16,250 --> 01:02:16,940
13650,13800 13800,13860 13860,14040 14040,14100 14100,14340
if we want to look

2041
01:02:16,940 --> 01:02:17,720
14340,14430 14430,14730 14730,14850 14850,14970 14970,15120
at what's in there there's

2042
01:02:17,720 --> 01:02:18,620
15120,15180 15180,15420 15420,15660 15660,15720 15720,16020
a couple ways of doing

2043
01:02:18,620 --> 01:02:21,170
16020,16530 17370,17490 17490,18120 18120,18570
this,| the easiest is
|最简单的是，如果我们键入print，p表示打印

2044
01:02:21,200 --> 01:02:22,430
18990,19170 19170,19260 19260,19530 19530,19830
if we type print,

2045
01:02:22,430 --> 01:02:24,440
19830,20250 20250,20370 20370,20550 20550,21120 21450,21840
p is for print| and
|如果我们取消对地址的引用，

2046
01:02:24,440 --> 01:02:27,350
21840,22140 22140,22410 22410,22920 22950,24750
then if we dereference

2047
01:02:27,350 --> 01:02:28,370
24750,24900 24900,25320 25320,25410 25410,25560 25560,25770
the address,| so we go
|所以我们去看看外面的地址是什么，

2048
01:02:28,370 --> 01:02:29,780
25770,25980 25980,26070 26070,26310 26310,26460 26640,27180
look at what's out address,|
|我们这样做，你知道，正如你所预期的，我们得到了该数组的第一个元素，

2049
01:02:29,930 --> 01:02:32,390
27330,27750 27750,28260 28440,28980 29130,29640
we do that and,

2050
01:02:32,390 --> 01:02:33,140
29790,29910 29910,30030 30030,30240 30240,30360 30360,30540
you know, as you would

2051
01:02:33,140 --> 01:02:34,000
30540,31230
expect,

2052
01:02:34,720 --> 01:02:36,040
120,330 330,480 480,600 600,930 930,1440
we get the first element

2053
01:02:36,040 --> 01:02:37,810
1440,1590 1590,1800 1800,2220 2220,2790 2880,3210
of that array,| because when
|因为当它试图打印字符串时，

2054
01:02:37,810 --> 01:02:38,830
3210,3330 3330,3720 3720,3840 3840,4140 4140,4230
it tries to print a

2055
01:02:38,830 --> 01:02:40,780
4230,4680 4680,4950 4950,5310 5310,5850 5850,6180
string,| it'll go {as,C} says,
|它会一直运行，就像C}说的，它会一直运行，直到它达到空字符，

2056
01:02:40,780 --> 01:02:41,740
6180,6330 6330,6480 6480,6900 6900,6960 6960,7140
it'll go until it hits

2057
01:02:41,740 --> 01:02:43,450
7140,7260 7260,7470 7470,8250 8430,8760 8760,8850
the null character,| so we
|所以我们得到foo，它是数组中的第一个元素，

2058
01:02:43,450 --> 01:02:44,290
8850,9060 9060,9330 9330,9510 9510,9600 9600,9690
get foo which is the

2059
01:02:44,290 --> 01:02:45,190
9690,9930 9930,10170 10170,10230 10230,10320 10320,10590
first element in that array,|
|如果我们想要得到更多我们可以放在长度上的东西，

2060
01:02:45,190 --> 01:02:45,730
10590,10710 10710,10830 10830,10920 10920,11070 11070,11130
and if we want to

2061
01:02:45,730 --> 01:02:47,950
11130,11250 11250,11550 11550,12270 12330,12660 12660,13350
get more things we can

2062
01:02:47,980 --> 01:02:49,270
13380,13710 13710,13830 13830,13950 13950,14460 14490,14670
put in the length,| so
|所以如果我们这样做，然后是一个数字，它会上升到某个索引，然后我们可以在这里看到这两个字符串

2063
01:02:49,270 --> 01:02:49,880
14670,14790 14790,14880 14880,15030
if we do

2064
01:02:50,520 --> 01:02:51,300
600,750 750,840 840,900 900,1230 1230,1380
@ then a number, it'll

2065
01:02:51,300 --> 01:02:52,020
1380,1530 1530,1650 1650,1770 1770,1830 1830,2100
go up to a certain

2066
01:02:52,020 --> 01:02:53,580
2100,2820 3000,3180 3180,3360 3360,3480 3480,3660
index, so then we can

2067
01:02:53,580 --> 01:02:54,870
3660,3990 3990,4260 4260,4380 4380,4470 4470,4950
see both of the strings

2068
01:02:54,870 --> 01:02:58,230
4950,5490 5880,6900 7260,7800 7800,8190 8190,8310
here| and again gdb is
|同样，gdb非常聪明，所以我们甚至可以使用argc打印出整个参数数组。

2069
01:02:58,230 --> 01:02:59,760
8310,8580 8580,8970 8970,9360 9480,9720 9720,9840
quite smart, so we can

2070
01:02:59,760 --> 01:03:02,460
9840,10590 11430,11730 11730,12420 12420,12540
even use argc to

2071
01:03:02,460 --> 01:03:03,900
12540,12840 12840,13050 13050,13110 13110,13590 13590,13980
print out the whole argument

2072
01:03:03,900 --> 01:03:04,600
13980,14400
array.|
|所以所有的信息对你来说都是可用的，

2073
01:03:05,590 --> 01:03:06,370
390,600 600,750 750,930 930,990 990,1170
And so all of that

2074
01:03:06,370 --> 01:03:08,890
1170,2340 2370,2580 2580,3120 3120,3240 3240,3690
information is available to you,|
|你，不管你怎么想得到它，所以gdb{超能力，工具}。

2075
01:03:09,130 --> 01:03:11,650
3930,4530 5250,5760 5760,6270 6270,6450
you, however you want

2076
01:03:11,650 --> 01:03:12,520
6450,6540 6540,6690 6690,6870 6870,7110 7110,7380
to get it, so gdb

2077
01:03:12,520 --> 01:03:15,430
7380,7530 7530,8160 9090,9870 9870,10230
the {superpower,tool}.| Why does
|为什么gdb，对不起，为什么编译器有时会优化argc和argv，

2078
01:03:15,430 --> 01:03:17,260
10230,11160 11220,11580 11580,11790 11790,11940 11940,12060
gdb, sorry, why does the

2079
01:03:17,260 --> 01:03:20,050
12060,12600 12600,13140 13140,13860 13860,14220 14520,16320
compiler sometimes optimize out argc

2080
01:03:20,050 --> 01:03:22,060
16320,16470 16470,17160
and argv,|
|那正好是以前的事了。

2081
01:03:22,060 --> 01:03:23,140
17160,17370 17370,17550 17550,17880 17880,17940
that has happened to

2082
01:03:23,140 --> 01:03:25,300
17940,18090 18090,18630 19140,19770 19770,19920 19920,20100
be before.| Yeah that just
|是的，这只是意味着编译器找到了一种更有效的方法，

2083
01:03:25,300 --> 01:03:26,620
20100,20340 20340,20460 20460,20550 20550,21090 21090,21420
means that the compiler found

2084
01:03:26,620 --> 01:03:27,820
21420,21480 21480,21810 21810,22230 22230,22620
a more efficient way,|
|很可能它只是去掉了变量，并且正在进行所有的操作，

2085
01:03:28,000 --> 01:03:29,140
22800,23400 23400,23490 23490,23640 23640,23850 23850,23940
likely it just got rid

2086
01:03:29,140 --> 01:03:30,010
23940,24030 24030,24120 24120,24480 24480,24600 24600,24810
of the variable and it's

2087
01:03:30,010 --> 01:03:31,570
24810,25080 25080,25290 25290,25350 25350,25470 25470,26370
doing all of its operations,|
|您直接知道[VIA]寄存器可能在a0上执行其所有操作，

2088
01:03:31,810 --> 01:03:34,030
27150,27840 27840,27900 27900,28380 28410,28830
directly you know [VIA]

2089
01:03:34,030 --> 01:03:35,140
28830,29160 29160,29400 29400,29520 29520,29730 29730,29940
register might be doing all

2090
01:03:35,140 --> 01:03:36,070
29940,30000 30000,30090 30090,30600 30600,30750 30750,31290
of its operations on a0,|
|例如，它可能只是对返回地址进行所有计算。

2091
01:03:36,070 --> 01:03:37,560
31290,31410 31410,32100
for example,

2092
01:03:37,610 --> 01:03:38,540
390,510 510,720 720,900 900,1020
it might just be

2093
01:03:38,540 --> 01:03:39,890
1020,1320 1320,1470 1470,1620 1620,2250 2250,2370
doing all the computations on

2094
01:03:39,890 --> 01:03:41,000
2370,2460 2460,2760 2760,3300
the return address.|
|这是很常见的，如果你，如果它不是一个变量，你知道百分之百的必要。

2095
01:03:41,120 --> 01:03:42,170
120,330 330,540 540,870 870,990 990,1170
It's pretty common to see

2096
01:03:42,170 --> 01:03:43,520
1170,1470 1470,1680 1680,1980 1980,2190 2190,2520
something like that, if you,

2097
01:03:43,520 --> 01:03:45,470
3570,3810 3810,3930 3930,3990 3990,4470
if it's a variable

2098
01:03:45,470 --> 01:03:46,460
4470,4710 4710,5100 5100,5220 5220,5370 5370,5460
that's not you know a

2099
01:03:46,460 --> 01:03:47,460
5460,5760 5760,6210
hundred percent

2100
01:03:47,500 --> 01:03:50,080
60,1110 1620,1860 1860,2160 2400,2640
necessary.| If you know
|如果您知道我们不允许您控制编译器，

2101
01:03:50,080 --> 01:03:51,130
2640,2760 2760,2970 2970,3330 3330,3480 3480,3690
we don't let we don't

2102
01:03:51,130 --> 01:03:52,000
3690,3840 3840,3960 3960,4350 4350,4500 4500,4560
give you control over the

2103
01:03:52,000 --> 01:03:53,020
4560,5040 5040,5160 5160,5280 5280,5370 5370,5580
compiler,| but if you ever
|但如果你在日常生活中发现了这一点，

2104
01:03:53,020 --> 01:03:54,310
5580,5820 5820,5970 5970,6060 6060,6210 6210,6870
find that in your day-to-day,|
|您可以尝试将编译器的优化标志设置为零，

2105
01:03:54,460 --> 01:03:56,170
7020,7290 7290,7440 7440,7860 7860,8370 8370,8730
you can try setting the

2106
01:03:56,170 --> 01:03:58,480
8730,9630 9630,10230 10230,10410 10410,10500 10500,11040
optimization flag for the compiler

2107
01:03:58,480 --> 01:04:00,640
11040,11160 11160,11850 12510,12870 12870,13200
to zero,| but even
|但即使这样，你知道编译器会做的，我们会做的，我们会做一定程度的优化。

2108
01:04:00,640 --> 01:04:01,930
13200,13680 13710,13830 13830,13980 13980,14070 14070,14490
then you know the compiler

2109
01:04:01,930 --> 01:04:03,160
14490,14610 14610,14940 15150,15270 15270,15390 15390,15720
will do we'll do it,

2110
01:04:03,190 --> 01:04:03,940
15750,15870 15870,16020 16020,16230 16230,16440 16440,16500
we'll do some level of

2111
01:04:03,940 --> 01:04:04,880
16500,17220
optimization.|
|比比克，你的手举起来了。是的，地址是什么，除了你在Foo或Bar之前知道的1美元或2美元。

2112
01:04:05,550 --> 01:04:06,930
90,810 810,1050 1050,1350 1350,1470
Bibic, your hand is

2113
01:04:06,930 --> 01:04:07,500
1470,1860
raised.

2114
01:04:08,310 --> 01:04:12,180
90,1350 1620,2250 2250,2670 2700,3360 3360,3960
Yeah what's the address, besides

2115
01:04:12,180 --> 01:04:13,830
3960,4410 4410,5130 5130,5220 5220,5880
that $1 or $2

2116
01:04:13,830 --> 01:04:15,180
5880,6000 6000,6180 6180,6480 6480,6960
you know like before

2117
01:04:15,180 --> 01:04:17,580
6960,7380 7650,7800 7800,8160 8730,9360
foo or bar.| Dollar,
|美元，这个吗？

2118
01:04:17,670 --> 01:04:18,620
9450,9960
this?|
|是的，那么那个地址就是Foo所在的地址。

2119
01:04:18,870 --> 01:04:20,520
90,480 480,630 630,840 840,1020 1020,1740
Yeah, so what's that address

2120
01:04:20,610 --> 01:04:22,230
1830,2190 2190,2520 2520,2670 2670,3000 3000,3450
is that the address where

2121
01:04:22,260 --> 01:04:23,340
3480,3930 3930,4380
foo is.|
|可能是吧。

2122
01:04:23,640 --> 01:04:24,700
60,510 510,870
Probably yes.|
|但是，然后argv指向其他地址，这些地址不应该是相同的。

2123
01:04:25,990 --> 01:04:27,790
90,630 630,810 810,1470 1470,1890
But then argv points

2124
01:04:27,790 --> 01:04:29,350
1890,2040 2040,2250 2250,2490 2490,2820 2820,3450
to some other address shouldn't

2125
01:04:29,350 --> 01:04:30,660
3450,3720 3720,3840 3840,3930 3930,4260
those be the same.|
|所以艾尔夫在这个堆栈上，

2126
01:04:32,080 --> 01:04:33,190
120,390 390,1110 1110,1230
So argv is

2127
01:04:33,190 --> 01:04:36,400
1230,1410 1410,1740 1740,2850 3180,4080
on this stack,| and
|你知道，所以如果你看这些地址，我们可以看到它们在内核中，就在8000位。

2128
01:04:36,550 --> 01:04:37,810
210,420 420,870 900,1080 1080,1170 1170,1470
you know, so the reason

2129
01:04:37,810 --> 01:04:39,070
1470,2010 2040,2280 2280,2460 2460,2640 2640,2730
why, if you look at

2130
01:04:39,070 --> 01:04:40,390
2730,2970 2970,3570 3570,3720 3720,3870 3870,4050
these addresses, we can see

2131
01:04:40,390 --> 01:04:41,440
4050,4200 4200,4350 4350,4470 4470,4530 4530,5100
that they're in the kernel,

2132
01:04:41,710 --> 01:04:43,090
5790,6060 6060,6240 6240,6570
just by the

2133
01:04:43,090 --> 01:04:44,640
6570,8010
8000.|
|嗯，这是有道理的，因为我们静态地声明是正确的，所以在演示中，如果我走到这里，它们会在这里声明。

2134
01:04:44,760 --> 01:04:46,500
120,540 540,840 840,1080 1080,1410 1410,1860
Um, which makes sense because

2135
01:04:46,500 --> 01:04:49,200
1860,2220 2820,3450 3450,4020 4020,4260 4260,4560
we declared statically right, so

2136
01:04:49,200 --> 01:04:50,220
4560,4740 4740,5190 5190,5280 5280,5400 5400,5580
in demos, if I go

2137
01:04:50,220 --> 01:04:51,780
5580,5940 5940,6060 6060,6510 6510,6900
here they're declared here.|
|所以它们基本上位于内核的某个地方

2138
01:04:52,000 --> 01:04:53,020
120,330 330,420 420,570 570,990 990,1140
And so they're basically they're

2139
01:04:53,020 --> 01:04:54,460
1140,1440 1440,1830 1830,1950 1950,2010 2010,2580
sitting somewhere in the kernel|
|它们都是args或者argv是一系列的[汽车明星]

2140
01:04:54,820 --> 01:04:56,590
2940,3120 3120,3270 3270,3450 3450,4050 4050,4710
and they're all [cars] are

2141
01:04:56,860 --> 01:04:58,990
4980,5640 5640,5820 5820,6540 6780,6990 6990,7110
args or argv is an

2142
01:04:58,990 --> 01:05:00,250
7110,7410 7410,7500 7500,7800 7800,8250 8250,8370
array of [car stars]| and
|所以我想象每个元素都指向右边的字符串，

2143
01:05:00,250 --> 01:05:01,660
8370,8550 8550,8610 8610,9060 9060,9270 9270,9780
so I imagined each element

2144
01:05:01,980 --> 01:05:03,280
360,780 780,1230
points to

2145
01:05:04,320 --> 01:05:06,870
0,390 390,780 1110,1860 1860,2190 2190,2550
points to [disown] string right,|
|所以它是一个指针数组。

2146
01:05:07,020 --> 01:05:08,280
2700,3060 3450,3570 3570,3660 3660,3870 3870,3960
so it's an array of

2147
01:05:08,280 --> 01:05:09,080
3960,4560
pointers.|
|我明白了。

2148
01:05:10,420 --> 01:05:11,080
120,240 240,510
I see.|
|

2149
01:05:11,510 --> 01:05:12,000
90,360
|
|(不要尝试)和喜欢。

2150
01:05:17,060 --> 01:05:19,700
1200,1560 1560,1830 1830,1950 1950,2490
[Don't try] and like.|
|我对此也有一个问题，

2151
01:05:24,700 --> 01:05:25,780
120,300 300,720 720,840 840,900 900,1200
I also have a question

2152
01:05:25,780 --> 01:05:27,820
1200,1440 1440,1860 2160,2580 2640,3240
about this,| the dollar
|$3版本的阵列具有

2153
01:05:27,820 --> 01:05:29,040
3240,3570 3570,3960 3960,4140
three version of

2154
01:05:29,250 --> 01:05:32,160
270,900 900,1560 2130,2880 2880,3090 3090,3180
the array has| if I
|如果我看看这些地址，

2155
01:05:32,160 --> 01:05:34,080
3180,3570 3570,3690 3690,3900 3900,4710 4950,5100
look at these addresses,| the
|第一个后缀是38，

2156
01:05:34,080 --> 01:05:35,060
5100,5340 5340,5460 5460,5760
first one is

2157
01:05:35,180 --> 01:05:38,000
120,810 810,990 990,1830 2100,2250 2610,2940
suffixed by 38,| the second
|第二个后缀是40，

2158
01:05:38,000 --> 01:05:39,500
2940,3060 3060,3150 3150,3600 3600,3780 3780,4440
one is suffixed by 40,|
|第三个是48。

2159
01:05:39,650 --> 01:05:40,820
4590,4680 4680,4800 4800,5070 5070,5220 5220,5760
and the third one is

2160
01:05:40,970 --> 01:05:42,380
5910,7020
48.|
|这是不统一的，虽然三个参数的长度都是三个，

2161
01:05:42,500 --> 01:05:44,570
120,420 420,870 870,1170 1170,1830 1830,2190
Which is not uniform, even

2162
01:05:44,570 --> 01:05:46,100
2190,2580 2580,2700 2700,3030 3030,3150 3150,3720
though the length of each

2163
01:05:46,130 --> 01:05:48,290
3750,3810 3810,3960 3960,4230 4230,5070 5700,5910
of the three arguments is

2164
01:05:48,290 --> 01:05:50,270
5910,6330 6840,7080 7080,7530 7530,7740 7740,7890
three,| so why, why are
|那么为什么，为什么它们是不同的。

2165
01:05:50,270 --> 01:05:53,120
7890,7980 7980,8520 8760,9450 9630,10380 10380,10740
they different.| Um, not in
|嗯，不在我也不是百分之百确定，

2166
01:05:53,150 --> 01:05:54,290
10770,10890 10890,11040 11040,11070 11070,11340 11340,11910
I'm not a hundred percent

2167
01:05:54,380 --> 01:05:55,790
12000,12690 12690,12900 12900,13170 13170,13290 13290,13410
certain,| my guess is that
|我的猜测是，这是一次试图调整事情的尝试。

2168
01:05:55,790 --> 01:05:57,110
13410,13590 13590,13680 13680,13800 13800,14310 14310,14730
this is an attempt to

2169
01:05:57,110 --> 01:05:58,500
14730,15180 15180,15900
align things.|
|嗯，好的，所以要让他们保持合理的位置，

2170
01:05:58,700 --> 01:05:59,720
120,840
Um,

2171
01:06:00,050 --> 01:06:02,060
90,420 420,930 1410,1560 1560,1770 1770,2100
right, so to get them

2172
01:06:02,060 --> 01:06:05,000
2100,2250 2250,2370 2370,3210 3420,4140 4650,5040
on a reasonable alignment,| it
|在得克萨斯州，人们都在指着(向上)，这是统一的。

2173
01:06:05,000 --> 01:06:06,410
5040,5220 5220,5670 5670,5730 5730,6150 6150,6450
is uniform in Texas people

2174
01:06:06,410 --> 01:06:07,340
6450,6510 6510,6810 6810,7140
are pointing [up].|
|哦好的，现在就看，谢谢。

2175
01:06:08,430 --> 01:06:13,470
90,510 1710,2400 2400,3000 3060,4950 4950,5130
Oh yeah, yeah yeah see

2176
01:06:13,470 --> 01:06:16,260
5130,5250 5250,5670 6060,6450 6450,7080 7530,7920
it now right, thanks.| So
|所以有时你会看到东西[直]放在哪里很奇怪，可能有两个东西是奇怪的偏移量

2177
01:06:16,260 --> 01:06:17,460
7920,8040 8040,8460 8460,8610 8610,8790 8790,9120
you'll sometimes see where [straight]

2178
01:06:17,460 --> 01:06:19,590
9120,9360 9360,9780 9810,10110 10110,10290 10290,11250
things are laid out strangely

2179
01:06:19,650 --> 01:06:20,520
11310,11580 11580,11730 11730,11910 11910,11970 11970,12180
where there might be two

2180
01:06:20,520 --> 01:06:22,200
12180,12630 12630,12990 12990,13260 13260,13770 13770,13860
things as strange offsets| and
|这只是因为并不是所有的东西都是自然大小相同的。

2181
01:06:22,200 --> 01:06:23,550
13860,14070 14070,14460 14460,14700 14700,14880 14880,15210
that's just because not everything

2182
01:06:23,550 --> 01:06:25,740
15210,15450 15780,16500 16500,16590 16590,16860 16860,17400
is naturally the same sized.|
|好的，还有其他问题吗。

2183
01:06:26,300 --> 01:06:29,740
180,1950 2220,2460 2460,2670 2670,3390
Okay, any other questions.|
|

2184
01:06:30,900 --> 01:06:31,380
0,390
|
|

2185
01:06:36,450 --> 01:06:36,820
90,300
|
|好的，我们可以跳过这个系统。

2186
01:06:37,230 --> 01:06:39,510
30,600 1530,1650 1650,1770 1770,2310
Okay, we can skip

2187
01:06:39,510 --> 01:06:41,060
2310,2460 2460,2940
the system.|
|所以我们从gdb得到的另一个有用的函数，

2188
01:06:41,150 --> 01:06:43,370
90,720 750,990 990,1320 1320,1830 1830,2310
And so another useful function

2189
01:06:43,370 --> 01:06:46,250
2310,2490 2490,2670 2670,3120 3120,3780 3780,5190
that we get from gdb,|
|或者，它们不仅是断点，还是观察点

2190
01:06:46,460 --> 01:06:49,220
5400,6210 6660,7440 7440,7560 7560,7890 7890,8160
or, instead of just break

2191
01:06:49,220 --> 01:06:51,230
8160,8790 9270,9420 9420,9870 9870,10170
points, they're also watch

2192
01:06:51,230 --> 01:06:52,400
10170,10620 10620,10770 10770,10890 10890,11010 11010,11340
points| and we can also
|并且我们还可以设置有条件的中断点。

2193
01:06:52,400 --> 01:06:55,010
11340,11970 12150,12480 12480,13110 13110,13350 13350,13950
set a conditional break points.|
|所以，我将简单地回顾一下这一点。

2194
01:06:55,250 --> 01:06:56,360
14190,14820
So,

2195
01:06:57,770 --> 01:06:59,660
930,1530 1530,1890 1890,2460 2460,2640 2640,2820
I'll just briefly go over

2196
01:06:59,660 --> 01:07:01,000
2820,3360
that.|
|运行demo6以便我们可以设置，在此函数中，我们可以观察，所以我们可以设置观察点，

2197
01:07:02,160 --> 01:07:04,470
120,750 750,1740 2040,2280 2280,2430
Run demo6 so we

2198
01:07:04,470 --> 01:07:06,840
2430,2700 2700,3390 3600,4140 4140,4320 4320,4800
can set, inside this function,

2199
01:07:06,840 --> 01:07:08,070
4800,4920 4920,5310 5310,5790 5790,5910 5910,6030
we can watch so we

2200
01:07:08,070 --> 01:07:09,330
6030,6150 6150,6300 6300,6360 6360,6660 6660,7290
can set a watch point,|
|我想在这里你会看到的。

2201
01:07:09,540 --> 01:07:11,370
8340,8520 8520,8790 8790,9090 9090,9330
I think here you'll

2202
01:07:11,370 --> 01:07:13,360
9330,9870
see.|
|是的，在这里你会看到卢克所说的，我们看到一些已经被优化了，

2203
01:07:15,680 --> 01:07:16,670
120,330 330,510 510,780 780,960 960,1110
Yeah, so here you'll see

2204
01:07:16,670 --> 01:07:19,130
1110,1950 2040,2610 2610,2790 2790,3180 3180,3570
what Luke was talking about

2205
01:07:19,130 --> 01:07:20,720
3570,4200 4710,4860 4860,5010 5010,5160
where we see that

2206
01:07:20,720 --> 01:07:22,460
5160,5490 5490,5670 5670,5880 5880,6480 6480,6900
some has been optimized out,|
|可能是因为它就是{put，in}个零什么的。

2207
01:07:22,670 --> 01:07:24,170
7110,7620 7620,7920 7920,8100 8100,8340 8340,8610
likely because it's just {put,in}

2208
01:07:24,680 --> 01:07:25,920
9120,9150 9150,9600 9600,9720 9720,10080
a zero or something.|
|我们甚至可以在大会上看到这一权利，

2209
01:07:27,060 --> 01:07:27,990
120,360 360,480 480,720 720,930 930,1050
We can look even at

2210
01:07:27,990 --> 01:07:29,280
1050,1200 1200,1680 1680,1830 1830,2100 2100,2340
the assembly for this right,|
|这样我们就可以拆分布局了。

2211
01:07:29,280 --> 01:07:30,630
2340,2520 2520,2610 2610,2820 3030,3690
so we can layout

2212
01:07:31,470 --> 01:07:32,440
4530,5280
split.|
|事实上，我们可以看到，所有的一切都是在堆栈上完成的，

2213
01:07:32,980 --> 01:07:34,570
120,930 930,1410 1410,1470 1470,1560 1560,1710
And indeed, we can see

2214
01:07:34,570 --> 01:07:35,800
1710,1860 1860,2040 2040,2190 2190,2490
that all just being,

2215
01:07:36,480 --> 01:07:37,320
120,300 300,480 480,630 630,780 780,960
it's all just being done

2216
01:07:37,320 --> 01:07:38,220
960,1050 1050,1140 1140,1470 1470,1620 1620,1860
on the stack,| it looks
|在我看来。

2217
01:07:38,220 --> 01:07:39,060
1860,2040 2040,2130 2130,2400
like to me.|
|哦，不，这都是在S0，S0，1，3做的，

2218
01:07:40,280 --> 01:07:41,180
120,300 300,450 450,570 570,840 840,1020
Oh, no, it's always been

2219
01:07:41,180 --> 01:07:42,080
1020,1200 1200,1290 1290,1740 1740,2250
done in s0, s0

2220
01:07:42,080 --> 01:07:43,790
2250,2550 2550,3030 3240,3420 3420,3630
one three,| so here
|所以在这里你可以看到，编译器甚至决定使用质量安全寄存器

2221
01:07:43,790 --> 01:07:45,170
3630,3810 3810,3930 3930,4080 4080,4500
you can see the,

2222
01:07:47,060 --> 01:07:48,380
120,600 600,990 990,1200 1200,1290 1290,1440
compiler decided even to use

2223
01:07:48,380 --> 01:07:52,010
1440,1560 1560,1920 1920,2250 2250,2940 4470,5070
the quality safety registers| and
|这样我们就可以把东西设置得像我们在I上看的那样。

2224
01:07:52,040 --> 01:07:53,180
5100,5340 5340,5460 5460,5610 5610,5880 5880,6240
so we can set things

2225
01:07:53,180 --> 01:07:55,880
6240,6870 6870,7050 7050,7290 7290,8100 8100,8940
like we do watch on

2226
01:07:56,910 --> 01:07:57,980
690,1380
i.|
|好的，我们还没有声明i，因为我们不在里面，我们不在for循环里。

2227
01:07:58,360 --> 01:07:59,980
120,600 780,960 960,1200 1200,1560 1560,1740
Alright we haven't declared i

2228
01:07:59,980 --> 01:08:01,300
1740,1980 1980,2130 2130,2220 2220,2430 2430,3060
yet, cause we're not inside,

2229
01:08:02,760 --> 01:08:04,320
0,210 210,420 420,1200 1200,1350 1350,1560
we're not inside the for

2230
01:08:04,320 --> 01:08:06,940
1560,2280 2460,2820 2820,3270 3270,4080
loop.| So we step
|所以我们一步一步通过C指令，

2231
01:08:06,880 --> 01:08:08,560
0,360 360,450 450,660 660,1470 1470,1680
through the C instructions,| now
|如果我们为当地人提供信息，我们会看到我，

2232
01:08:08,560 --> 01:08:10,540
1680,1830 1830,1950 1950,2400 3060,3570 3570,3660
if we do information for

2233
01:08:10,540 --> 01:08:11,680
3660,3780 3780,4350 4350,4500 4500,4680 4680,4800
the locals, we see we

2234
01:08:11,680 --> 01:08:13,030
4800,5010 5010,5520 5550,5790 5790,5910 5910,6150
get i,| we can even
|我们甚至可以在SUM上观看观测点。所以现在，只要总和更改实际收到通知，

2235
01:08:13,030 --> 01:08:16,120
6150,6570 8040,8340 8340,8820 8820,9240
watch watch point on

2236
01:08:16,120 --> 01:08:17,460
9240,9900
sum.

2237
01:08:17,640 --> 01:08:19,410
120,480 480,810 810,1410 1410,1560 1560,1890
So now anytime that sum

2238
01:08:19,410 --> 01:08:22,320
1890,2790 2850,3210 3210,3630 3630,4230 4320,4800
changes will actually get a

2239
01:08:22,320 --> 01:08:24,510
4800,5730 5730,5880 5880,5970 5970,6090 6090,6990
notification,| so we can continue
|所以我们可以继续，然后我们会在这里删除，因为有些已经被删除了，所以我们不能我们不能实际观看它，

2240
01:08:24,810 --> 01:08:25,800
7290,7500 7500,8040
and then

2241
01:08:25,990 --> 01:08:27,160
90,360 360,510 510,600 600,960 960,1260
we'll get a delete here,

2242
01:08:27,160 --> 01:08:29,470
1260,1710 1710,2130 2130,2460 2460,2730 2730,3570
because some has been removed

2243
01:08:29,530 --> 01:08:30,610
3630,3840 3840,3930 3930,4320 4350,4500 4500,4710
so we can't we can't

2244
01:08:30,610 --> 01:08:32,110
4710,5040 5040,5280 5280,5580 6090,6210
actually watch it,| we
|我们甚至可以做一些事情，比如在某些TO上设置断点，

2245
01:08:32,110 --> 01:08:33,850
6210,6390 6390,6630 6630,6840 6840,7200 7200,7950
can even do things like

2246
01:08:33,880 --> 01:08:36,730
8220,8880 8880,9690 9900,10500 10500,11130
break point on some_to,|
|这是一个有条件的中断点，如果，好，让我们看看我现在是不是，所以我现在是1，

2247
01:08:36,730 --> 01:08:37,390
11130,11220 11220,11340 11340,11430 11430,11490
so this is a

2248
01:08:37,390 --> 01:08:40,060
11490,11970 11970,12210 12210,12810 13140,14010
conditional break point if,

2249
01:08:40,260 --> 01:08:42,000
180,450 450,720 720,990 990,1320 1320,1920
well, let's actually see was

2250
01:08:42,000 --> 01:08:43,650
1920,2160 2160,2790 2790,2940 2940,3210 3210,3570
i currently, so i currently

2251
01:08:43,650 --> 01:08:45,780
3570,4110 4170,4620 4620,5220 5250,5460 5460,5700
1,| let's say I think
|比方说，我觉得我的循环要断了，每当我5岁的时候，

2252
01:08:45,780 --> 01:08:47,310
5700,5850 5850,6180 6180,6330 6330,6900 6900,7230
my loop is breaking and

2253
01:08:47,310 --> 01:08:49,200
7230,7590 7590,7800 7800,7950 7950,8640 8730,9120
whenever i is 5,| well
|嗯，如果我想专门调试那个箱子，

2254
01:08:49,200 --> 01:08:50,250
9120,9210 9210,9330 9330,9540 9540,9600 9600,10170
if I want to specifically

2255
01:08:50,250 --> 01:08:52,050
10170,10590 10590,10860 10860,11550 11580,11820 11820,11970
debug that case,| I can
|如果我等于5，我可以在sum_to上设置一个断点。

2256
01:08:52,050 --> 01:08:53,500
11970,12150 12150,12210 12210,12510 12510,13260
set a break point

2257
01:08:53,580 --> 01:08:58,460
120,1530 2190,3360
on sum_to

2258
01:08:58,550 --> 01:09:02,040
90,900 930,1950 2310,2670 2670,3390
if i equal 5.|
|所以现在我们有了这个转折点，如果我们继续下去，

2259
01:09:02,850 --> 01:09:04,050
570,810 810,1290 1290,1410 1410,1590 1590,1770
So now we have this

2260
01:09:04,050 --> 01:09:05,340
1770,2070 2070,2580 2610,2850 2850,2940 2940,3060
break point, and if we

2261
01:09:05,340 --> 01:09:07,200
3060,3570 3570,4260 4290,4620 4620,4830 4830,4920
continue along,| we'll get to
|我们将获得SUM_TO，我们可以看到它实际上打印出了第一对值

2262
01:09:07,200 --> 01:09:09,390
4920,5850 6030,6810 6840,6960 6960,7110
sum_to, and we can

2263
01:09:09,390 --> 01:09:10,890
7110,7500 7500,7770 7770,7890 7890,8220 8220,8610
see that it actually printed

2264
01:09:10,890 --> 01:09:13,260
8610,9090 9210,9510 9510,9810 9810,10080 10080,10980
out the first couple values|
|所以我们现在只在SUM_TO上，如果我们达到了那个断点条件。

2265
01:09:13,320 --> 01:09:14,490
11040,11340 11340,11460 11460,11580 11580,11910 11910,12210
and so we only break

2266
01:09:14,490 --> 01:09:16,470
12210,12480 12480,12600 12600,13410 13620,14190
now on sum_to if

2267
01:09:17,480 --> 01:09:18,860
120,450 450,720 720,1170 1170,1290 1290,1500
if i if we hit

2268
01:09:18,860 --> 01:09:20,340
1500,1680 1680,1920 1920,2220 2220,2730
that break point condition.|
|也就是说，如果您想要调试代码的特定{edge，case}，它也会很有用

2269
01:09:21,280 --> 01:09:22,270
120,270 270,360 360,630 900,1110
And so that's, it

2270
01:09:22,270 --> 01:09:23,170
1110,1230 1230,1470 1470,1800 1800,1890 1890,2010
can be again can be

2271
01:09:23,170 --> 01:09:24,160
2010,2460 2460,2580 2580,2700 2700,2910 2910,3000
useful if you want to

2272
01:09:24,160 --> 01:09:25,870
3000,3450 3450,3900 3900,4470 4470,4590 4590,4710
debug specific {edge,cases} of your

2273
01:09:25,870 --> 01:09:27,580
4710,5220 5310,5700 5700,5970 5970,6270 6270,6420
code| and watch points can
|例如，如果你认为某些事情不应该改变，观察点可能会很有用，

2274
01:09:27,580 --> 01:09:29,830
6420,6540 6540,7290 7710,7920 7920,8070 8070,8670
be useful if for instance

2275
01:09:29,830 --> 01:09:30,880
8670,8820 8820,9000 9000,9120 9120,9450 9450,9720
you think that something shouldn't

2276
01:09:30,880 --> 01:09:32,710
9720,9840 9840,10650 10710,11040 11040,11190 11190,11550
be changing,| but you suspect
|但你怀疑是这样，或者你认为每次你改变某个变量都会出问题。

2277
01:09:32,710 --> 01:09:34,870
11550,11700 11700,11790 11790,12480 12510,13470 13500,13710
that it is or you

2278
01:09:34,870 --> 01:09:35,800
13710,13860 13860,13980 13980,14280 14280,14370 14370,14640
think that something is going

2279
01:09:35,800 --> 01:09:37,570
14640,15030 15030,15270 15270,15810 15840,16110 16110,16410
wrong every time you change

2280
01:09:37,570 --> 01:09:39,080
16410,16440 16440,16770 16770,17370
a certain variable.|
|这就是，这是它的一种用法。

2281
01:09:40,000 --> 01:09:41,170
240,390 390,510 510,840 840,1140 1140,1410
And so that's that's a

2282
01:09:41,170 --> 01:09:42,460
1410,1620 1620,1950 1950,2280 2280,2580 2580,2700
it's one one usage for

2283
01:09:42,460 --> 01:09:44,950
2700,3030 3870,4260 4620,4890 4890,5190
that.| And the last
|今天我最不想谈的就是struct，

2284
01:09:44,950 --> 01:09:45,580
5190,5310 5310,5370 5370,5520 5520,5580 5580,5820
thing I want to talk

2285
01:09:45,580 --> 01:09:48,400
5820,6270 6270,6780 6780,7080 7080,7830
about today is struct,|
|结构非常重要，它们会经常出现在实验室里

2286
01:09:48,400 --> 01:09:50,260
8640,9090 9090,9330 9330,10020 10050,10350 10350,10500
struct pretty important, they'll come

2287
01:09:50,260 --> 01:09:52,500
10500,10860 10890,11490
up in

2288
01:09:53,050 --> 01:09:55,690
90,390 390,510 510,990 990,1710 1950,2730
in the labs often| and
|还有。

2289
01:09:56,050 --> 01:09:57,240
3090,3780
also.|
|所以，有一个问题，我会简单介绍一下结构在内存中的布局方式。

2290
01:09:57,310 --> 01:09:59,230
90,510 510,720 720,1410 1560,1800 1800,2010
So, one ask I'll talk

2291
01:09:59,230 --> 01:10:00,310
2010,2040 2040,2250 2250,2400 2400,2880 2940,3090
a little bit about the

2292
01:10:00,310 --> 01:10:01,840
3090,3420 3420,3840 3840,4200 4200,4440 4440,4620
way structs are laid out

2293
01:10:01,840 --> 01:10:03,180
4620,4680 4680,5370
in memory.|
|所以一个结构基本上就是一个连续的记忆区域，

2294
01:10:03,750 --> 01:10:04,620
210,390 390,540 540,630 630,990 990,1080
And so a structure is

2295
01:10:04,620 --> 01:10:07,350
1080,1830 2820,3000 3000,3090 3090,3810
basically it's a continued

2296
01:10:07,350 --> 01:10:08,730
3810,4350 4350,4680 4680,4770 4770,5070 5070,5190
contiguous area of memory,| so
|所以如果我们有一些结构。

2297
01:10:08,730 --> 01:10:09,810
5190,5280 5280,5370 5370,5460 5460,5670 5670,6270
if we have some structure.|
|我们有一号场，二号场，三号场。

2298
01:10:11,510 --> 01:10:13,490
90,450 450,570 570,960 960,1500 1710,2070
And we have like field

2299
01:10:13,490 --> 01:10:15,800
2070,2610 2610,2970 2970,3420 3420,3750 3750,4380
one field two field three.|
|当我们创建该结构时，这些字段将成为一条紧挨着彼此的线。

2300
01:10:17,110 --> 01:10:18,220
30,300 300,420 420,630 630,810 810,1140
When we make that struct

2301
01:10:18,220 --> 01:10:19,000
1140,1350 1350,1650 1650,1710 1710,1830 1830,1920
those fields are going to

2302
01:10:19,000 --> 01:10:20,530
1920,2340 2370,2670 2670,3090 3090,3330 3330,3450
be a line next to

2303
01:10:20,530 --> 01:10:21,620
3450,3630 3630,4140
each other.|
|在内存中，你可以把它想象成一个数组，

2304
01:10:22,230 --> 01:10:23,340
210,360 360,750 750,870 870,1110 1110,1320
In memory, you can kind

2305
01:10:23,340 --> 01:10:24,750
1320,1410 1410,1590 1590,1680 1680,2160 2220,2730
of think of this like

2306
01:10:24,750 --> 01:10:26,070
2730,2820 2820,3450 3450,3630 3630,4050
an array,| but f1
|但是f1、f2、f3都可以是不同的类型。

2307
01:10:26,070 --> 01:10:27,030
4050,4410 4410,4860 4860,5010
f2 f3 can

2308
01:10:27,030 --> 01:10:28,380
5010,5160 5160,5280 5280,5580 5580,6090
all be different types.|
|而且，我们可以将它们作为函数传递，

2309
01:10:28,380 --> 01:10:31,830
0,690 2070,2400 2400,3030
And, we can

2310
01:10:31,830 --> 01:10:33,180
3450,3810 3810,3900 3900,4020 4020,4500 4500,4800
pass them as functions,| usually
|通常它们将它们作为参数传递给函数，通常它们通过引用传递，

2311
01:10:33,180 --> 01:10:34,800
4800,4950 4950,5730 5730,5820 5820,5910 5910,6420
they pass them as arguments

2312
01:10:34,800 --> 01:10:36,720
6420,6510 6510,7320 7350,7920 7920,8040 8040,8340
to functions, usually they pass

2313
01:10:36,720 --> 01:10:38,700
8340,8490 8490,9240 9330,9780 9780,10170 10170,10320
by reference,| so here I've
|所以在这里我用两个整数参数做了一个结构Person，

2314
01:10:38,700 --> 01:10:40,680
10320,10500 10500,10560 10560,10920 10920,11670 11760,12300
made a struct person with

2315
01:10:40,680 --> 01:10:43,620
12300,12540 12540,13110 13110,14040 14280,15030
two integer arguments,| and
|我正在传递它们，传递一个人作为辩论人，并打印出其中的一些信息，

2316
01:10:44,120 --> 01:10:46,010
120,450 450,840 840,1350 1650,2010
I'm passing them, passing

2317
01:10:46,010 --> 01:10:47,330
2010,2070 2070,2430 2430,2550 2550,2640 2640,3330
a person as an argument

2318
01:10:47,330 --> 01:10:50,780
3330,3990 4320,4980 5040,6060 6060,6420 6420,6780
person and printing out some

2319
01:10:50,780 --> 01:10:52,580
6780,6870 6870,7080 7080,7710 8160,8460 8460,8580
of that information,| so if
|所以如果我们跳进GDB

2320
01:10:52,580 --> 01:10:54,290
8580,8670 8670,8940 8940,9630 9630,10290
we hop into gdb|
|让我们删除所有的断点和观察点，

2321
01:10:54,290 --> 01:10:55,250
10290,10410 10410,10650 10650,10920 10920,11130 11130,11250
and let's delete all our

2322
01:10:55,250 --> 01:10:56,780
11250,11490 11490,11760 11760,11880 11880,12120 12120,12780
break points and watch points,|
|现在我们可以在“人”上设置一个转折点，

2323
01:10:56,990 --> 01:10:58,040
12990,13380 13380,13590 13590,13710 13710,13860 13860,14040
and now we can set

2324
01:10:58,040 --> 01:11:00,980
14040,14070 14070,14280 14280,14670 14670,15330 16320,16980
a break point at person,|
|这对你和第七个演示都有好处。

2325
01:11:01,680 --> 01:11:03,900
120,990 1230,1350 1350,1590 1590,1800 1800,2340
and it's good for you

2326
01:11:04,290 --> 01:11:07,040
2730,2940 2940,3480 3630,4140 4140,4800
and one seventh demo.|
|我们可以看到现在我们在这里，所以如果我们输入I frame，

2327
01:11:07,640 --> 01:11:08,540
0,240 240,360 360,570 570,690 690,900
We can see that now

2328
01:11:08,540 --> 01:11:09,320
900,1020 1020,1350 1350,1470 1470,1590 1590,1680
we're here and so if

2329
01:11:09,320 --> 01:11:11,240
1680,1770 1770,2100 2100,2100 2100,3060 3300,3600
we type i frame,| we
|我们可以看到，我们有一个论点p。

2330
01:11:11,240 --> 01:11:13,460
3600,3750 3750,4290 4290,5010 5040,5370 5370,5820
can see that we have

2331
01:11:13,460 --> 01:11:15,020
5820,6000 6000,6600 6600,7200
an argument p.|
|事实上，如果我们打印p，我们可以看到。

2332
01:11:15,310 --> 01:11:17,440
90,690 690,1350 1410,1830 1830,2040 2040,2220
And indeed, we can see

2333
01:11:17,440 --> 01:11:19,630
2220,2370 2370,2460 2460,2820 2850,3720 3750,4410
if we do print p.|
|如果我们能辨别出这个地址是Strt Person的话

2334
01:11:20,780 --> 01:11:22,010
120,630 630,720 720,870 870,1080 1080,1350
If we can even tell

2335
01:11:22,010 --> 01:11:23,750
1350,1500 1500,1650 1650,2070 2070,2760 2850,3090
that it's struct person at

2336
01:11:23,750 --> 01:11:27,470
3090,3270 3270,4050 5250,5940 6330,6510 6510,6810
this address| and we can
|如果我们解除对它的引用，我们就能做到，

2337
01:11:27,470 --> 01:11:28,850
6810,7020 7020,7110 7110,7800 7800,8190
if we dereference it,|
|gdb将确切地告诉我们它的id为1215，年龄为22岁的p看起来是什么样子。

2338
01:11:30,210 --> 01:11:31,200
90,600 600,720 720,960 960,1080
gdb will tell us

2339
01:11:31,200 --> 01:11:33,000
1080,1620 1620,1950 1980,2250 2250,2520 2520,2880
exactly what p looks like

2340
01:11:33,000 --> 01:11:34,960
2880,3030 3030,3210 3210,3510 3510,4560
it has id 1215,

2341
01:11:35,240 --> 01:11:36,700
60,450 450,1110
age 22.|
|只是为了展示一下东西是怎么摆放的。

2342
01:11:37,660 --> 01:11:38,860
420,780 780,960 960,1080 1080,1410 1410,1620
And just to show kind

2343
01:11:38,860 --> 01:11:40,960
1620,1680 1680,1920 1920,2340 2340,2850 3150,3720
of how things are laid

2344
01:11:40,960 --> 01:11:41,880
3720,4350
out.|
|你可以取这个地址，我们可以在这个地址看到，

2345
01:11:42,060 --> 01:11:43,800
120,300 300,480 480,780 780,1020 1020,1860
You can take this address

2346
01:11:43,800 --> 01:11:46,560
1860,2070 2070,2640 3690,4200 4200,4380 4380,4620
and we see at this

2347
01:11:46,560 --> 01:11:51,120
4620,5580 6120,6300 6300,6480 6480,7080
address,| if we look.|
|如果我们看的话。|我记得很清楚。

2348
01:11:51,870 --> 01:11:55,400
570,1470 2340,2970 2970,3810
I remember exactly.|
|{应该，是}。

2349
01:11:57,380 --> 01:11:58,960
1800,2340
{Should,be}.|
|所以如果我们再来一次，我们可以用这个来调试我们的结构。

2350
01:12:02,180 --> 01:12:03,470
1020,1260 1260,1380 1380,1680 1740,2130 2130,2310
So if we again so

2351
01:12:03,470 --> 01:12:04,400
2310,2430 2430,2610 2610,2850 2850,3120 3120,3240
we can use this to

2352
01:12:04,400 --> 01:12:06,960
3240,4050 4080,4500 4500,5700
debug our structures.|
|在代码中，我们可以这样看一下结构是怎么回事，

2353
01:12:07,900 --> 01:12:10,780
900,1350 1650,1950 1950,2070 2070,2940 3030,3780
In in the code, we

2354
01:12:11,020 --> 01:12:11,770
4020,4260 4260,4440 4440,4500 4500,4680 4680,4770
can take a look at

2355
01:12:11,770 --> 01:12:13,300
4770,4980 4980,5310 5310,5790
what's going on

2356
01:12:13,660 --> 01:12:15,550
120,570 570,1290 1290,1500 1500,1770 1800,2010
with structures this way,| so
|因此，gdb不仅是用于单步执行代码的超级强大的工具，

2357
01:12:15,550 --> 01:12:17,230
2010,2730 2820,3330 3330,3420 3420,3690
gdb is a super

2358
01:12:17,230 --> 01:12:19,270
3690,4140 4140,4560 4560,4800 4800,5160 5160,5730
powerful tool not just for

2359
01:12:19,420 --> 01:12:21,010
5880,6510 6510,6750 6750,7050 7050,7170 7170,7470
stepping through code,| but also
|而且还用于检查代码中所有类型的潜在问题部分

2360
01:12:21,010 --> 01:12:24,070
7470,7680 7680,8580 8910,9570 9570,10020 10020,10530
for examining all kinds of

2361
01:12:25,060 --> 01:12:26,890
11520,12180 12180,12780 12780,13140 13140,13230 13230,13350
potentially problematic pieces in your

2362
01:12:26,890 --> 01:12:28,900
13350,13890 13890,14250 14250,14550 14550,14640 14640,15360
code| and looking at arguments
|看看参数和堆栈框架之类的东西，

2363
01:12:28,900 --> 01:12:30,040
15360,15480 15480,15840 15840,16170 16170,16260 16260,16500
and stack frames and things

2364
01:12:30,040 --> 01:12:31,450
16500,16650 16650,16980 17310,17640 17640,17760 17760,17910
like that,| and this will
|这很有希望在下一个实验中有用。

2365
01:12:31,450 --> 01:12:33,220
17910,18240 18240,18750 18750,18900 18900,18990 18990,19680
be hopefully will be useful

2366
01:12:33,280 --> 01:12:34,740
19740,20070 20070,20130 20130,20430 20430,20970
in the next lab.|
|当您必须使用、使用堆栈框架和使用汇编代码时。

2367
01:12:35,270 --> 01:12:36,350
150,480 480,660 660,810 810,930 930,1230
When you have to work

2368
01:12:36,350 --> 01:12:38,480
1230,1650 2370,2610 2610,2910 2910,3360
with, with stack frames

2369
01:12:38,480 --> 01:12:39,900
3360,3540 3540,3750 3750,4170 4170,4560
and with assembly code.|
|这就是我今天想谈的主要内容。

2370
01:12:40,080 --> 01:12:42,360
60,840 960,1560 1590,1980 1980,2250 2250,2340
So that's that's mostly what

2371
01:12:42,360 --> 01:12:43,170
2340,2400 2400,2640 2640,2730 2730,2940 2940,3150
I wanted to talk about

2372
01:12:43,170 --> 01:12:44,460
3150,3450 3450,3930 4200,4320 4320,4440
today.| So, with the
|所以，在最后7分钟的演讲中，我将向你们提出任何其他问题。

2373
01:12:44,460 --> 01:12:47,040
4440,4770 4770,4980 4980,5280 5970,6450 6450,7020
last kind of seven minutes

2374
01:12:47,040 --> 01:12:48,840
7020,7410 7410,7890 7890,8460 8460,8730 8730,8820
of lecture, I'll open it

2375
01:12:48,840 --> 01:12:50,610
8820,9000 9000,9510 9780,10200 10200,10380 10380,10590
up to any any other

2376
01:12:50,610 --> 01:12:52,060
10590,11130 11130,11280 11280,11460 11460,11850
questions you guys have.|
|我有一个离题的问题，

2377
01:12:59,510 --> 01:12:59,990
90,240 240,330 330,390 390,480 480,570
I had a bit of

2378
01:12:59,990 --> 01:13:03,050
570,660 660,1260 1260,1830 2460,3270 3330,3630
a tangential question,| who is
|谁管理从C到各种指令集体系结构的编译器的创建，

2379
01:13:03,050 --> 01:13:05,150
3630,4050 4050,4590 4590,5010 5070,5610 5610,5730
who manages the creation of

2380
01:13:05,150 --> 01:13:07,250
5730,6450 6450,6930 7110,7260 7260,7590 7590,7830
compilers from to get from

2381
01:13:07,250 --> 01:13:09,200
7830,8220 8220,8370 8370,8970 9360,9780
C to various instruction

2382
01:13:09,200 --> 01:13:10,460
9780,10020 10020,10680 10680,10740 10740,10920 10920,11040
set architectures,| is that the
|指令集体系结构的创建者，就是这样的第三方。

2383
01:13:10,460 --> 01:13:11,900
11040,11670 11670,11850 11850,11940 11940,12300 12300,12480
creator of the instruction set

2384
01:13:11,900 --> 01:13:13,460
12480,13080 13080,13170 13170,13320 13320,13620 13620,14040
architecture, is the third parties

2385
01:13:13,460 --> 01:13:14,320
14040,14340 14340,14580
like that.|
|嗯，我相信不是指令集的创意，

2386
01:13:14,500 --> 01:13:17,620
120,900 1290,1470 1470,2460 2460,3030 3030,3240
Um, I believe that it

2387
01:13:17,620 --> 01:13:19,090
3240,3720 3720,4080 4080,4170 4170,4620 4620,4710
is not the creative the

2388
01:13:19,090 --> 01:13:20,740
4710,5250 5250,5580 5580,5910 5910,6060 6060,6360
instruction set,| so it's often
|所以通常是第三方，

2389
01:13:20,740 --> 01:13:22,540
6360,6420 6420,6720 6720,7320 8040,8160
a third party,| so
|所以你们会看到的两个大的C编译器指的是GCC，它是由GNU基金会和Clang llvm维护的，这是它自己的东西，

2390
01:13:22,540 --> 01:13:23,950
8160,8280 8280,8520 8520,8760 8760,8970 8970,9570
the two big C compilers

2391
01:13:23,950 --> 01:13:25,120
9570,9690 9690,9870 9870,10050 10050,10410 10410,10740
that you'll see refer to

2392
01:13:25,120 --> 01:13:27,550
10740,11640 11820,12150 12150,12270 12270,12930 12930,13170
GCC which is maintained by

2393
01:13:27,550 --> 01:13:28,600
13170,13320 13320,13590 13590,13740 13740,14220
I think the GNU

2394
01:13:28,600 --> 01:13:32,260
14220,15150 15570,16260 17010,17880
foundation and Clang

2395
01:13:32,260 --> 01:13:34,630
17880,18780 18930,19410 19410,19800 19800,20010 20010,20250
llvm, which is its own

2396
01:13:34,630 --> 01:13:36,220
20250,20610 20610,20970 20970,21090 21090,21420 21570,21840
thing,| so I think you
|所以我想你知道你可以发现我相信llvm甚至是开源的，

2397
01:13:36,220 --> 01:13:37,540
21840,21900 21900,22080 22080,22230 22230,22860 23010,23160
know you can find I

2398
01:13:37,540 --> 01:13:39,070
23160,23520 23520,24120 24120,24210 24210,24420 24420,24690
believe llvm is even open

2399
01:13:39,070 --> 01:13:40,720
24690,25140 25140,25350 25350,25560 25560,25710 25710,26340
source,| so you can find
|这样你就能找到

2400
01:13:40,840 --> 01:13:41,840
26460,27150
|
|你可以，你可以找到专门做这件事的代码，

2401
01:13:42,060 --> 01:13:42,870
120,300 300,420 420,600 600,690 690,930
you can, you can find

2402
01:13:42,870 --> 01:13:44,040
930,990 990,1290 1290,1740 1740,1860 1860,2100
the code specifically that does

2403
01:13:44,040 --> 01:13:45,570
2100,2490 2970,3330 3330,3450 3450,3630
this,| when a new
|当释放诸如RISC-V的新指令集时，

2404
01:13:45,570 --> 01:13:47,730
3630,4260 4260,4680 4680,4920 4920,5610 5610,5790
instruction set is released such

2405
01:13:47,730 --> 01:13:49,620
5790,5940 5940,6690 6780,7260 7260,7680
as RISC-V,| that calling
|该呼叫约定文档以及所有这些指令文档，

2406
01:13:49,620 --> 01:13:51,120
7680,8190 8190,8700 8700,8850 8850,9060 9060,9180
convention document as well as

2407
01:13:51,120 --> 01:13:53,040
9180,9420 9420,9510 9510,9900 9900,10410 10410,11100
all of those instruction documents,|
|我仔细考虑，我假设编译器设计者和指令集设计者之间有很高级别的合作。

2408
01:13:53,280 --> 01:13:54,750
11850,11850 11850,12330 12330,12690 12690,12810
I think carefully I

2409
01:13:54,750 --> 01:13:55,920
12810,13110 13110,13290 13290,13440 13440,13650 13650,13980
assume there's a high level

2410
01:13:55,920 --> 01:13:57,780
13980,14070 14070,14910 14910,15270 15270,15360 15360,15840
of cooperation between the compiler

2411
01:13:57,780 --> 01:13:59,220
15840,16380 16380,16470 16470,16560 16560,17070 17070,17280
designer and the instruction set

2412
01:13:59,220 --> 01:14:01,100
17280,17940
designer.|
|但简而言之，我相信是第三方干的，

2413
01:14:01,550 --> 01:14:03,110
90,360 360,930 930,930 1140,1440 1440,1650
But yeah a short answer

2414
01:14:03,110 --> 01:14:04,070
1650,1740 1740,2070 2070,2400 2400,2520 2520,2610
is I believe it's a

2415
01:14:04,070 --> 01:14:06,080
2610,3750 3750,3900 3900,4110 4110,4260 4260,4620
{third,party} who does it,| likely
|很可能需要指令集制作人员的大量合作。

2416
01:14:06,080 --> 01:14:08,150
4620,5100 5340,5700 5700,5910 5910,6000 6000,6690
with a lot of cooperation

2417
01:14:08,150 --> 01:14:08,960
6690,6840 6840,6960 6960,7230 7230,7290 7290,7500
from the people who make

2418
01:14:08,960 --> 01:14:10,520
7500,7560 7560,8010 8010,8250 8310,9060
the instruction set.| RISC-V
|RISC-V可能是，RISC-V可能是一个例外，因为它来自一个研究项目，

2419
01:14:10,520 --> 01:14:11,580
9060,9180 9180,9870
is probably,

2420
01:14:12,030 --> 01:14:12,840
90,570 570,750 750,840 840,900
RISC-V might be an

2421
01:14:12,840 --> 01:14:14,880
900,1830 1920,2310 2310,2610 2610,2700 2700,2940
exception where because it came

2422
01:14:14,880 --> 01:14:16,320
2940,3030 3030,3090 3090,3240 3240,3660 3660,4380
out of a research project,|
|他们也可能自己编写了编译器。

2423
01:14:16,440 --> 01:14:18,000
4500,4890 4890,5100 5100,5310 5310,5640 5640,6060
they may have written the

2424
01:14:18,060 --> 01:14:19,980
6120,6690 6690,6960 6960,7050 7050,7950
compiler for it themselves,

2425
01:14:20,050 --> 01:14:20,980
270,450 450,810
as well.|
|例如，我我不认为英特尔在GCC或LIVM有投入。

2426
01:14:21,410 --> 01:14:22,760
90,360 360,510 510,780 780,1050 1050,1440
I I don't think Intel

2427
01:14:22,760 --> 01:14:24,560
1440,1980 2010,2220 2220,2580 2580,2790 2790,3240
has for example has input

2428
01:14:24,590 --> 01:14:25,480
3270,3540
in

2429
01:14:25,850 --> 01:14:27,780
90,300 300,990 990,1170 1170,1830
In GCC or llvm.|
|其他问题。

2430
01:14:45,530 --> 01:14:46,840
90,390 390,1050
Other questions.|
|好的，谢谢你的收听，

2431
01:14:54,650 --> 01:14:58,790
1170,2010 2370,3510 3690,4260 4260,4950 4950,5310
Okay, well, thanks for listening,|
|那样的话，我想我们可以。你可以在这里结束演讲，

2432
01:14:58,790 --> 01:14:59,960
5310,5400 5400,5610 5610,5940 5940,6150 6150,6480
in that case I guess

2433
01:14:59,960 --> 01:15:01,180
6480,6630 6630,7410
we can.

2434
01:15:01,790 --> 01:15:03,260
90,270 270,960 960,1170 1170,1230 1230,1560
You can end the lecture

2435
01:15:03,260 --> 01:15:05,330
1560,2040 2100,2640 2880,3330 3330,3540 3540,3630
here,| a five minutes to
|还有5分钟，所以好好吃一顿睡觉吧。

2436
01:15:05,330 --> 01:15:07,340
3630,3990 3990,4380 4680,5130 5130,5370 5370,5640
spare, so have a nice

2437
01:15:07,340 --> 01:15:07,580
5640,5820
rest.
