1
00:00:00,450 --> 00:00:03,390
Okay, good afternoon, wherever you are.

2
00:00:04,070 --> 00:00:05,690
Um, can everybody hear me,

3
00:00:05,780 --> 00:00:07,580
quick sound check, make sure.

4
00:00:09,580 --> 00:00:10,390
Yeah you're fine.

5
00:00:10,540 --> 00:00:11,440
Good, thank you.

6
00:00:11,890 --> 00:00:15,640
So today we're going to talk about,

7
00:00:15,640 --> 00:00:17,500
I don't really have a specific agenda

8
00:00:17,500 --> 00:00:21,250
but basically the plan is to try to answer questions

9
00:00:21,310 --> 00:00:25,690
that you might have about these last lab or the previous labs.

10
00:00:26,330 --> 00:00:28,580
Um, so the approach I'm going to take,

11
00:00:28,910 --> 00:00:33,720
today, is, I'm gonna walk through the staff solutions.

12
00:00:34,620 --> 00:00:37,260
In particularly my own solutions,

13
00:00:37,710 --> 00:00:39,900
I'm going to discuss them

14
00:00:40,050 --> 00:00:42,780
and hopefully as we go through the staff solutions,

15
00:00:43,180 --> 00:00:45,400
um, you can jump in

16
00:00:45,400 --> 00:00:47,290
if I don't answer a particular question,

17
00:00:47,530 --> 00:00:50,440
um or, wait a little bit,

18
00:00:50,440 --> 00:00:53,230
because I put all the questions that you've asked

19
00:00:53,380 --> 00:00:55,630
at least before eleven am this morning,

20
00:00:55,750 --> 00:00:58,060
in the lecture notes at the bottom

21
00:00:58,090 --> 00:01:00,070
and we'll try to go through that.

22
00:01:03,240 --> 00:01:07,290
I'm gonna start with the pagetable lab,

23
00:01:07,750 --> 00:01:11,350
because most questions were about the pagetable lab,

24
00:01:11,800 --> 00:01:14,590
and partly because it was the hardest labs.

25
00:01:15,450 --> 00:01:18,330
Um, and so maybe a couple of comments

26
00:01:18,330 --> 00:01:22,230
before diving into the technical part of this,

27
00:01:22,560 --> 00:01:26,520
let's talk a little bit about the pagetable lab in general.

28
00:01:30,380 --> 00:01:33,050
And you know as you probably observed,

29
00:01:33,050 --> 00:01:35,090
you know it's actually a few lines of code,

30
00:01:39,920 --> 00:01:42,350
in terms of the solution,

31
00:01:42,440 --> 00:01:51,990
but, it unfortunately has, you know, had to debug problems.

32
00:01:55,160 --> 00:01:59,990
And, you know, there's one reason is that

33
00:01:59,990 --> 00:02:01,730
when actually bug shows up,

34
00:02:01,850 --> 00:02:05,150
you know the outcomes are pretty extreme

35
00:02:05,210 --> 00:02:06,560
like in the worst case,

36
00:02:06,800 --> 00:02:09,500
probably some of you observed that the worst case,

37
00:02:10,790 --> 00:02:13,490
QEMU stops or xv6 stops,

38
00:02:13,490 --> 00:02:17,090
there's no output being printed anymore, and that's it,

39
00:02:17,390 --> 00:02:20,930
you know it's your job to figure out actually what went wrong,

40
00:02:21,470 --> 00:02:24,620
in the best case you get sort of kernel panic,

41
00:02:25,020 --> 00:02:28,260
depending you know maybe just a starting point

42
00:02:28,260 --> 00:02:32,520
or for tracking down what the actual source of the problem is panic itself,

43
00:02:32,960 --> 00:02:34,520
it's probably related to something else,

44
00:02:34,520 --> 00:02:36,410
something the invariant that the kernel got broken,

45
00:02:36,500 --> 00:02:38,600
but you know somewhere out earlier,

46
00:02:38,600 --> 00:02:40,190
probably when you set up the pagetables,

47
00:02:40,190 --> 00:02:43,580
you did something wrong at the end causes panic to go off,

48
00:02:43,730 --> 00:02:46,130
you have to track down what's going on.

49
00:02:46,840 --> 00:02:50,710
So fewer lines of code, hard to debug problems,

50
00:02:50,890 --> 00:02:55,720
in produce a harsh environment, to debug.

51
00:02:56,360 --> 00:03:00,020
If you do in the kernel debugging or kernel programming,

52
00:03:00,020 --> 00:03:02,480
you know programming environment, debugging environment,

53
00:03:02,600 --> 00:03:04,700
is more, you know unforgiven,

54
00:03:05,450 --> 00:03:07,340
as Robert mentioned in the first lecture,

55
00:03:07,340 --> 00:03:10,780
is one of the hard parts about basically doing kernel programming.

56
00:03:12,900 --> 00:03:16,920
And that's you know just to make you feel better,

57
00:03:16,920 --> 00:03:18,120
this is not just hard for you,

58
00:03:18,120 --> 00:03:19,830
you know actually hard for your staff.

59
00:03:24,600 --> 00:03:26,220
Both in terms of helping you

60
00:03:26,220 --> 00:03:28,350
and actually you know we do these labs

61
00:03:28,350 --> 00:03:29,670
and we make similar problems,

62
00:03:29,850 --> 00:03:32,520
you know we probably have more experience at tracking bugs down,

63
00:03:32,760 --> 00:03:34,920
but you know they just, they do take time.

64
00:03:35,400 --> 00:03:36,960
Um, so we're helping you,

65
00:03:36,960 --> 00:03:41,210
you know the, tends to be hard too,

66
00:03:41,210 --> 00:03:43,520
because there's some small fragment of code,

67
00:03:43,520 --> 00:03:45,650
there's one detail something probably wrong

68
00:03:45,710 --> 00:03:48,530
and they're figuring out actually what little detail is,

69
00:03:48,560 --> 00:03:49,760
it's not easy.

70
00:03:50,040 --> 00:03:51,810
Of course some of the problems,

71
00:03:51,810 --> 00:03:53,550
we've seen before and we're recognizing,

72
00:03:53,550 --> 00:03:55,740
for example we didn't make the same mistake ourselves,

73
00:03:55,830 --> 00:03:58,260
but other ones you discovered

74
00:03:58,260 --> 00:04:00,870
all kinds of different ways of breaking the kernel,

75
00:04:00,930 --> 00:04:03,000
that we hadn't seen before.

76
00:04:03,940 --> 00:04:05,470
So this is just hard,

77
00:04:05,800 --> 00:04:09,850
I think this is, in our experience,

78
00:04:11,350 --> 00:04:14,380
this is historically always hard with virtual memory,

79
00:04:19,470 --> 00:04:23,580
so every time the first virtual memory lab comes around,

80
00:04:23,580 --> 00:04:26,610
either in 6.S081 or its predecessor in 6.828,

81
00:04:26,970 --> 00:04:28,710
it has been the case

82
00:04:28,710 --> 00:04:30,720
that you know that tends to be the hardest lab,

83
00:04:31,020 --> 00:04:33,930
of all the labs

84
00:04:33,930 --> 00:04:35,400
and you know for a number of reasons,

85
00:04:35,400 --> 00:04:37,080
one you know the harsh environment,

86
00:04:37,080 --> 00:04:39,870
you know the the bugs are spectacular

87
00:04:40,110 --> 00:04:43,440
and partly because you haven't done

88
00:04:43,440 --> 00:04:45,300
that much kernel programming experience yet,

89
00:04:45,300 --> 00:04:46,860
and so this is sort of the first lab

90
00:04:46,860 --> 00:04:48,060
with all those things come together.

91
00:04:48,740 --> 00:04:51,200
This year, we tried to make lab simpler,

92
00:04:51,200 --> 00:04:52,460
in fact, this is a new lab,

93
00:04:52,490 --> 00:04:54,680
a lab we did not have that lab.

94
00:04:54,980 --> 00:04:56,720
In the hopes that actually

95
00:04:56,720 --> 00:05:00,470
make this introduction or the transition into a virtual memory easier,

96
00:05:00,800 --> 00:05:03,170
in some ways I think it was successful,

97
00:05:03,170 --> 00:05:04,730
in other ways, you know it's still hard,

98
00:05:05,390 --> 00:05:06,260
so we don't really know,

99
00:05:06,260 --> 00:05:07,640
maybe about the easiest way

100
00:05:07,640 --> 00:05:10,670
of actually introducing virtual memory programming is.

101
00:05:11,170 --> 00:05:16,480
Lab, the lab next week, the lazy lab

102
00:05:16,510 --> 00:05:19,750
is actually a lab that used to be the first virtual memory lab.

103
00:05:20,180 --> 00:05:23,540
And my suspicion is that you'll find this year,

104
00:05:23,540 --> 00:05:26,300
lab easier than the students found it last year,

105
00:05:26,420 --> 00:05:30,110
because you now have much more background in virtual memory.

106
00:05:33,100 --> 00:05:36,430
Okay, so that's, there is a good point to stop,

107
00:05:36,430 --> 00:05:38,770
this was a couple high level points I wanted to make,

108
00:05:38,770 --> 00:05:42,700
before jumping into more technical with more details,

109
00:05:42,730 --> 00:05:45,940
so if you have any questions, is a great time to ask questions.

110
00:05:51,450 --> 00:05:52,920
Okay.

111
00:05:53,280 --> 00:05:57,730
Let's, quickly, you know some of you asked for this,

112
00:05:57,760 --> 00:06:02,980
very quick review exactly what you were what the setting is,

113
00:06:03,370 --> 00:06:07,820
and so, basically, the settings pagetables,

114
00:06:11,270 --> 00:06:16,440
and we have physical memory draw here, right side,

115
00:06:16,800 --> 00:06:22,260
you know the physical memory, consist of partly about devices,

116
00:06:23,920 --> 00:06:32,010
and they live above this 0x zero zero and many more zeros,

117
00:06:32,460 --> 00:06:34,710
and then here basically dram chips.

118
00:06:37,780 --> 00:06:39,370
And we know that

119
00:06:39,370 --> 00:06:44,650
QEMU actually puts the kernel, the kernel text data, right here,

120
00:06:45,730 --> 00:06:48,190
at the above 0x zero zero zero,

121
00:06:48,280 --> 00:06:49,540
so that's where the kernel lives,

122
00:06:49,660 --> 00:06:51,220
and one way it may be,

123
00:06:51,730 --> 00:06:54,130
earse this a little bit to use the kernel.

124
00:06:54,600 --> 00:06:56,430
And you know basically literally what it means,

125
00:06:56,430 --> 00:06:59,010
you know what this is what the kernel is user instructions,

126
00:07:01,850 --> 00:07:05,300
binary versions of the assembling instructions that you've seen,

127
00:07:05,480 --> 00:07:10,960
and there's also some data structures located at these addresses.

128
00:07:12,760 --> 00:07:14,800
Okay, so that's the memory part of it

129
00:07:14,830 --> 00:07:18,130
and then on the other side we got our CPU,

130
00:07:19,040 --> 00:07:20,390
that executes instructions.

131
00:07:20,960 --> 00:07:23,240
CPU has a bunch of internal state,

132
00:07:24,140 --> 00:07:26,030
and has some registers,

133
00:07:26,030 --> 00:07:30,500
you know whatever x0 or r0 blah blah blah,

134
00:07:30,680 --> 00:07:32,960
and you know maybe the program counter.

135
00:07:33,790 --> 00:07:36,100
And you know when xv6 starts,

136
00:07:36,100 --> 00:07:41,480
you know the program counter contains this value Ox8000.

137
00:07:44,920 --> 00:07:46,840
And that's the way you know,

138
00:07:46,840 --> 00:07:49,570
the CPU knows that basically look at that address

139
00:07:49,570 --> 00:07:51,280
to find you know the first instruction,

140
00:07:51,280 --> 00:07:53,620
it looks at the first instruction decode instruction

141
00:07:53,830 --> 00:07:56,650
and updates whatever CPU state that needs to be updated.

142
00:07:58,280 --> 00:08:01,160
You know pagetables and sort of component to it

143
00:08:01,250 --> 00:08:02,990
that you know the addresses you know

144
00:08:02,990 --> 00:08:09,360
the CPU orders or the instructions are part of the instructions,

145
00:08:09,420 --> 00:08:11,460
like you know jump to some particular address

146
00:08:11,760 --> 00:08:17,320
and those addresses are typically or most commonly or will be virtual addresses.

147
00:08:17,860 --> 00:08:23,410
And now there's virtual addresses, go to that [] is called the MMU.

148
00:08:24,160 --> 00:08:26,530
And then you translate into physical addresss,

149
00:08:27,840 --> 00:08:31,860
um, and that is allowing [] index into

150
00:08:32,010 --> 00:08:34,260
either the IO part of the memory

151
00:08:34,260 --> 00:08:36,000
or the DRAM part the memory.

152
00:08:40,040 --> 00:08:42,290
To control how this translation happens,

153
00:08:42,290 --> 00:08:44,390
you know there's this satp register,

154
00:08:46,570 --> 00:08:51,550
which contains the root of the pagetable

155
00:08:51,580 --> 00:08:53,170
of the current running page table.

156
00:08:53,470 --> 00:08:54,550
And if there's zero,

157
00:08:55,410 --> 00:08:57,990
then there's basically no translation going on

158
00:08:58,170 --> 00:09:01,770
and the virtual address is literally directly physical address,

159
00:09:01,800 --> 00:09:03,600
so when the processor actually starts up,

160
00:09:03,870 --> 00:09:05,760
there's no value in satp

161
00:09:05,760 --> 00:09:08,580
and when the program counter as an 0x...,

162
00:09:08,580 --> 00:09:11,430
you know basically the physical address is also []

163
00:09:11,520 --> 00:09:16,200
and basically [] the CPU fetches the instruction from that particular location.

164
00:09:17,260 --> 00:09:18,670
As soon as you know the,

165
00:09:19,720 --> 00:09:23,470
as soon as the satp actually contains a non zero value,

166
00:09:23,880 --> 00:09:28,920
then, you know, for example maybe so somewhere in here

167
00:09:28,920 --> 00:09:31,410
to draw them make something extended pictures a bit further,

168
00:09:31,740 --> 00:09:37,740
we know that the kernel actually has a maximum 128 megabytes.

169
00:09:38,350 --> 00:09:40,480
And so basically this is all free memory,

170
00:09:40,480 --> 00:09:44,080
from here to there is free memory

171
00:09:44,560 --> 00:09:49,300
and free memory is put on the list in kalloc.c

172
00:09:49,300 --> 00:09:50,200
as you've seen before.

173
00:09:50,940 --> 00:09:54,930
And, so somewhere in here is also the root pagetable

174
00:09:54,960 --> 00:09:56,910
for you know a kernel pagetable,

175
00:09:56,940 --> 00:09:58,440
so maybe here's some page,

176
00:09:58,860 --> 00:10:05,170
and that it's the root pagetable directory.

177
00:10:06,280 --> 00:10:08,770
As soon as we load that value

178
00:10:08,800 --> 00:10:11,410
the address of the physical address of that value

179
00:10:11,410 --> 00:10:14,290
into the satp address and register,

180
00:10:14,290 --> 00:10:21,260
let's say this maybe this addresses 0x7 you know f f blah blah,

181
00:10:21,260 --> 00:10:23,480
something just below one hundred twenty megabytes,

182
00:10:23,480 --> 00:10:25,250
so in that free space of memory

183
00:10:25,550 --> 00:10:28,190
below that address in satp,

184
00:10:28,630 --> 00:10:34,490
then, at that point you know the processor or MMU

185
00:10:34,640 --> 00:10:37,280
will use the root pagetables to actually

186
00:10:37,280 --> 00:10:40,130
do the translation from virtual to physical address.

187
00:10:41,670 --> 00:10:44,880
And you can think of this, this particular whole thing,

188
00:10:45,090 --> 00:10:47,310
sort of being a single sort of box,

189
00:10:47,310 --> 00:10:49,890
you know integrated you know, together.

190
00:10:51,860 --> 00:10:53,720
And you have questions about this high-level picture,

191
00:10:53,720 --> 00:10:57,270
before keep them going,

192
00:10:57,420 --> 00:10:59,610
so one of the key points to remember here is

193
00:10:59,610 --> 00:11:02,610
that the page statements themselves also live in memory.

194
00:11:08,500 --> 00:11:09,070
Okay.

195
00:11:11,090 --> 00:11:13,610
Okay, so let's jump down to,

196
00:11:14,520 --> 00:11:17,790
the first part of the pagetable lab,

197
00:11:17,790 --> 00:11:21,350
namely part one where you have to

198
00:11:21,350 --> 00:11:28,550
print the pagetable for the init program,

199
00:11:28,730 --> 00:11:35,640
and um, and you know explain it basically in terms of this figure three four

200
00:11:35,640 --> 00:11:37,710
and figure three four is right here.

201
00:11:39,980 --> 00:11:41,870
Figure three four,

202
00:11:41,870 --> 00:11:44,630
and this is figure three four shows the user address space,

203
00:11:44,780 --> 00:11:46,940
just let's look at the user address space for a second,

204
00:11:46,940 --> 00:11:49,160
before we are going to detail,

205
00:11:49,160 --> 00:11:50,600
so we have the text at the bottom,

206
00:11:50,600 --> 00:11:53,480
so this is the instructions of the program,

207
00:11:53,570 --> 00:11:55,550
starting address zero

208
00:11:55,550 --> 00:12:00,590
above the instructions are data, global variables, live there,

209
00:12:00,590 --> 00:12:03,170
then there's something called the guard page we'll talk about,

210
00:12:03,170 --> 00:12:06,320
and then it's the stack of the user program,

211
00:12:06,320 --> 00:12:08,810
so the kernel has its own stack,

212
00:12:08,810 --> 00:12:09,860
multiple stack

213
00:12:10,190 --> 00:12:12,020
user program has its own stack

214
00:12:12,230 --> 00:12:15,800
and buff again is basically what's called heap memory, free memory,

215
00:12:15,920 --> 00:12:20,450
you know we can get more memory using sbrk,

216
00:12:20,450 --> 00:12:25,210
so sbrk basically points to the top of the user address space,

217
00:12:25,210 --> 00:12:26,200
we want to grow it,

218
00:12:26,290 --> 00:12:29,740
we called sbrk system call to grow

219
00:12:29,770 --> 00:12:33,430
grow the top of the, to grow the bottom part,

220
00:12:33,430 --> 00:12:35,350
you know up into the heap,

221
00:12:35,830 --> 00:12:39,460
we also know that the top, there from the last lecture,

222
00:12:39,460 --> 00:12:40,600
that there are two pages,

223
00:12:40,600 --> 00:12:44,950
two special pages the trampoline and the trapframe page.

224
00:12:45,260 --> 00:12:48,170
And the trampoline page, you know contains the instructions to the basically,

225
00:12:48,170 --> 00:12:49,730
transition in and out of the kernel,

226
00:12:50,030 --> 00:12:54,140
the trapframe is a convenient place,

227
00:12:54,140 --> 00:12:59,330
you know to stores from state and when we jump into the kernel,

228
00:12:59,330 --> 00:13:01,400
because we need the kernel once use registers,

229
00:13:01,400 --> 00:13:02,420
we can use the registers,

230
00:13:02,420 --> 00:13:05,210
because the user space program still has some in use.

231
00:13:06,140 --> 00:13:08,270
I'm not gonna talk much about tramframe and trampoline at all,

232
00:13:08,270 --> 00:13:09,440
you know they are there.

233
00:13:10,340 --> 00:13:14,300
OK, so here this picture a little below,

234
00:13:14,300 --> 00:13:18,910
you know is actually there, printout from,

235
00:13:18,910 --> 00:13:21,640
when I run it, from init.

236
00:13:22,420 --> 00:13:26,380
This the first successful call of exec right,

237
00:13:26,380 --> 00:13:29,170
so we know that init code makes some system call exec,

238
00:13:29,410 --> 00:13:33,340
for the program init and just at the end of the exec,

239
00:13:33,340 --> 00:13:34,630
we're printing out that pagetable.

240
00:13:35,460 --> 00:13:38,340
And so a couple things that we, many things we can observe,

241
00:13:38,550 --> 00:13:40,530
about this particular pagetable,

242
00:13:40,770 --> 00:13:42,840
so first of all you know,

243
00:13:42,840 --> 00:13:46,800
we in addition to printing out the physical ptes

244
00:13:46,800 --> 00:13:49,200
and the physical address is also printing out the flags.

245
00:13:50,040 --> 00:13:53,070
And you can see here that here flag is one,

246
00:13:53,280 --> 00:13:55,110
and basically says this translation,

247
00:13:55,110 --> 00:14:00,060
or this, intermediate page is that similar here,

248
00:14:00,210 --> 00:14:02,250
you know is valid independent page,

249
00:14:02,250 --> 00:14:05,940
and this basically corresponds to the level two page

250
00:14:05,970 --> 00:14:08,370
and then the second one corresponds to the level....

251
00:14:12,110 --> 00:14:14,150
I'm sorry I just threw the arrows wrong,

252
00:14:14,150 --> 00:14:16,010
so that's why a pause for a second.

253
00:14:17,210 --> 00:14:20,030
At the top, this is the top level pagetable,

254
00:14:20,580 --> 00:14:24,210
this, you know points to this particular pagetable,

255
00:14:24,650 --> 00:14:28,250
and this points to that particular pagetable.

256
00:14:29,180 --> 00:14:32,900
Or that's the address, we're pointing to a sort of shorthand for saying,

257
00:14:33,140 --> 00:14:36,830
that is the base address for that particular page.

258
00:14:37,310 --> 00:14:41,420
And you know these pages 4096 bytes,

259
00:14:41,750 --> 00:14:43,730
it's size of page size,

260
00:14:43,790 --> 00:14:48,050
and so divided by 64 its going to get 512 entries.

261
00:14:49,200 --> 00:14:54,630
Okay so we'll see is the bottom part of this address space.

262
00:14:55,020 --> 00:15:01,720
You know, for init basically has actually all this, has three pages, only three pages,

263
00:15:02,080 --> 00:15:03,730
and we do a couple things

264
00:15:03,730 --> 00:15:06,550
that we can discern from the three pages.

265
00:15:06,840 --> 00:15:12,300
We know that the bottom page which basically corresponds to the virtual address zero,

266
00:15:12,450 --> 00:15:16,530
this physical address, you know eight seven six four zero.

267
00:15:17,080 --> 00:15:19,900
And you know from our previous picture,

268
00:15:19,900 --> 00:15:23,680
that is somewhere in that free memory,

269
00:15:23,860 --> 00:15:26,980
that the kernel has available to allocate pages from.

270
00:15:28,330 --> 00:15:30,970
And the final things you see the flags,

271
00:15:31,180 --> 00:15:32,830
we see the flags one f,

272
00:15:33,040 --> 00:15:38,080
so it means that read bit set,

273
00:15:38,080 --> 00:15:40,270
valid bit set, read bit set, w bit set, execute bit set and u bit set,

274
00:15:41,500 --> 00:15:45,280
so this page can contain both data and text,

275
00:15:45,570 --> 00:15:49,290
and these permissions allow the user program

276
00:15:49,320 --> 00:15:53,130
to execute instructions from or to the right memory,

277
00:15:53,340 --> 00:15:55,050
and do it from user space.

278
00:15:56,700 --> 00:15:58,620
Okay, so then maybe the most interesting question is

279
00:15:58,620 --> 00:15:59,910
like what's up with page one.

280
00:16:00,660 --> 00:16:02,220
And you know as a hint,

281
00:16:02,220 --> 00:16:05,070
you know see that page one only has f

282
00:16:05,070 --> 00:16:06,360
and not the u bit set.

283
00:16:06,850 --> 00:16:09,460
So, you know what is the page one.

284
00:16:11,880 --> 00:16:12,540
Anybody.

285
00:16:15,370 --> 00:16:16,690
Is it the guard page.

286
00:16:16,900 --> 00:16:18,970
Yeah, it's the guard page right.

287
00:16:19,360 --> 00:16:21,520
So the guard page is mapped,

288
00:16:21,580 --> 00:16:23,050
because it has a v in it,

289
00:16:23,050 --> 00:16:24,850
but it has not u bit set,

290
00:16:24,850 --> 00:16:27,670
so any user instruction that tries to,

291
00:16:27,700 --> 00:16:30,430
so if a user program runs off its stack,

292
00:16:30,430 --> 00:16:33,170
so the stack grows from the top down,

293
00:16:33,170 --> 00:16:34,910
so even if it actually has more,

294
00:16:35,540 --> 00:16:37,880
stack is big enough for 4096 are completely full,

295
00:16:38,030 --> 00:16:42,080
and then user program, you know puts something on the stack,

296
00:16:42,080 --> 00:16:44,840
stack on the [], it will grow into the guard page.

297
00:16:45,140 --> 00:16:46,880
And because the u bit is not set,

298
00:16:47,120 --> 00:16:50,720
we gotta get a page fault or a trap into the kernel,

299
00:16:51,020 --> 00:16:56,900
because the MMU cannot translate to address to,

300
00:16:56,930 --> 00:17:02,120
cannot address cannot translate any addresses on the guard page to physical address,

301
00:17:02,360 --> 00:17:05,150
because the [] not having a u bit

302
00:17:05,150 --> 00:17:06,500
basically forbids the translation.

303
00:17:08,560 --> 00:17:10,060
Okay, what is that page two.

304
00:17:15,740 --> 00:17:19,080
Any, Anybody.

305
00:17:19,710 --> 00:17:20,490
Stack?

306
00:17:20,550 --> 00:17:21,990
Yup, that's the stack page

307
00:17:22,470 --> 00:17:26,160
and so again the stack page for forty four thousand ninety six bytes

308
00:17:26,430 --> 00:17:29,760
and you'll see that's completely elaborate in terms of permissions.

309
00:17:30,290 --> 00:17:32,210
And it has you know everything,

310
00:17:32,630 --> 00:17:35,390
could we set it up tighter if we wanted to.

311
00:17:38,230 --> 00:17:42,100
Yeah I think you could disable the executive bit.

312
00:17:42,390 --> 00:17:45,960
Yeah, you probably could execute the x bit,}

313
00:17:46,230 --> 00:17:49,920
that would forbid run any program code on the stack.

314
00:17:50,750 --> 00:17:53,690
So if you generate code on the fly and put it on the stack,

315
00:17:53,690 --> 00:17:55,010
you wouldn't to be able to execute,

316
00:17:55,310 --> 00:17:56,900
you know that maybe probably a good thing.

317
00:17:57,710 --> 00:18:00,380
And so we could have been a little bit tighter.

318
00:18:01,350 --> 00:18:02,940
Okay, um.

319
00:18:03,820 --> 00:18:07,270
So that's basically the bottom part of this,

320
00:18:07,990 --> 00:18:09,400
the pagetable,

321
00:18:09,400 --> 00:18:11,920
so now let's look at the remaining entries,

322
00:18:12,070 --> 00:18:14,170
so basically only two remaining entries.

323
00:18:14,560 --> 00:18:18,850
And maybe the flag bits are the most telling part of this.

324
00:18:19,150 --> 00:18:27,930
So seven, you know means you know read write and valid work.

325
00:18:29,340 --> 00:18:33,790
And so what do we think, that one is

326
00:18:33,790 --> 00:18:35,440
and maybe I'll do the other one too,

327
00:18:35,860 --> 00:18:38,950
so b is I think one zero zero one,

328
00:18:38,950 --> 00:18:40,600
so presumably x and valid,

329
00:18:41,680 --> 00:18:43,990
so what do we think five eleven is.

330
00:18:48,890 --> 00:18:49,550
Anybody.

331
00:18:54,070 --> 00:18:56,560
The trampoline and trap page?

332
00:18:57,520 --> 00:19:02,410
Yeah so the, and probably five eleven is definitely trampoline correct,

333
00:19:02,410 --> 00:19:04,090
because it has the x bit set,

334
00:19:04,360 --> 00:19:05,470
so we must be executed

335
00:19:05,470 --> 00:19:08,680
or we're allowing instructions to be executed from that page.

336
00:19:08,910 --> 00:19:10,350
So that must be a trampoline

337
00:19:10,650 --> 00:19:15,380
and we're allowing read write you know to the to that page,

338
00:19:15,380 --> 00:19:16,820
so that's probably the trapframe page,

339
00:19:16,820 --> 00:19:21,240
because that's the one we used to restore and save registers in.

340
00:19:22,230 --> 00:19:26,790
Okay, one of the things, a important thing to note is

341
00:19:26,790 --> 00:19:29,580
there's no u bit right then,

342
00:19:29,580 --> 00:19:30,750
so what does that mean,

343
00:19:30,750 --> 00:19:34,230
that means that the user program can actually not execute the instructions,

344
00:19:34,500 --> 00:19:38,400
that are actually at five ten as a trampoline page,

345
00:19:38,900 --> 00:19:40,790
and can't be the write to that page.

346
00:19:41,300 --> 00:19:44,090
So only the kernel can execute instructions from there

347
00:19:44,090 --> 00:19:45,470
and it can only read and write.

348
00:19:47,510 --> 00:19:51,470
So basically like the kernel's gonna be doing this before the,

349
00:19:51,680 --> 00:19:53,810
while still using the user pagetable,

350
00:19:53,810 --> 00:19:54,920
right, that's kind of the point.

351
00:19:55,190 --> 00:19:58,310
Exactly as you know, Robert explained last lecture,

352
00:19:58,370 --> 00:20:01,100
this is like just for the transition from user to kernel,

353
00:20:01,100 --> 00:20:02,090
and before we jump to,

354
00:20:02,330 --> 00:20:06,200
before we load the kernel pagetable in satp register,

355
00:20:06,230 --> 00:20:07,310
we need a little bit of,

356
00:20:07,340 --> 00:20:10,250
you know the kernel needs a little bit of memory to actually do his job.

357
00:20:11,990 --> 00:20:12,560
Okay.

358
00:20:13,200 --> 00:20:13,980
So in a couple of things,

359
00:20:13,980 --> 00:20:16,680
then maybe interesting of this picture.

360
00:20:17,040 --> 00:20:20,640
Yeah, so we all in all these addresses go eight seven six three zero,

361
00:20:20,640 --> 00:20:22,290
eight six two, four, seven one of,

362
00:20:22,320 --> 00:20:24,630
these are all pages or memory

363
00:20:24,750 --> 00:20:28,470
in that range of kernel memory

364
00:20:28,470 --> 00:20:30,720
that is you know it's basically free, right.

365
00:20:31,260 --> 00:20:42,940
And are these addresses are contiguous in physical memory.

366
00:20:47,040 --> 00:20:47,700
Anybody.

367
00:20:49,270 --> 00:20:50,680
No they don't have to be.

368
00:20:51,430 --> 00:20:53,440
No, they don't have to be in the are, correct,

369
00:20:53,440 --> 00:20:56,320
you know look at this, you know seven six four zero zero,

370
00:20:56,320 --> 00:20:57,220
if it contiguous,

371
00:20:57,220 --> 00:21:01,270
the next address would have been eight seven six you know six five zero,

372
00:21:01,270 --> 00:21:02,080
and it isn't it.

373
00:21:02,680 --> 00:21:06,610
So there's you know one of the cool things about pagetables is

374
00:21:06,730 --> 00:21:10,480
that even though maybe you do virtual address space is contiguous,

375
00:21:10,510 --> 00:21:11,890
the physical address space

376
00:21:11,920 --> 00:21:15,700
or the physical pages that go along with a continuous virtual addresses

377
00:21:15,760 --> 00:21:17,620
are not don't have to be continuous.

378
00:21:17,880 --> 00:21:19,890
So this gives the kernel a lot of flexibility

379
00:21:19,980 --> 00:21:24,000
in terms of allocation and freeing pages.

380
00:21:25,050 --> 00:21:25,620
Okay.

381
00:21:26,910 --> 00:21:28,860
Any questions about this part one.

382
00:21:29,980 --> 00:21:30,850
I had a question.

383
00:21:30,970 --> 00:21:31,270
Yeah.

384
00:21:32,470 --> 00:21:34,900
Could you explain the sbrk a little,

385
00:21:35,020 --> 00:21:38,440
also if we are going to cover in a future lecture,

386
00:21:38,440 --> 00:21:40,840
then maybe we can like just a small.

387
00:21:40,870 --> 00:21:42,580
Yeah actually we, let me,

388
00:21:42,580 --> 00:21:44,020
I'm going to talk about it on Wednesday.

389
00:21:44,340 --> 00:21:46,710
And it actually will be the topic of the lazy lab.

390
00:21:47,320 --> 00:21:50,650
So let me maybe responed the question to Wednesday,

391
00:21:50,650 --> 00:21:53,830
and then that's not clear enough, please ask it again.

392
00:21:54,470 --> 00:21:55,520
Sounds good, thank you.

393
00:21:57,530 --> 00:21:59,840
So had a question.

394
00:22:00,170 --> 00:22:05,650
So, I remember that the book said

395
00:22:05,650 --> 00:22:09,610
trampoline and the trapframe were at the top of the address space.

396
00:22:11,140 --> 00:22:16,720
Right here, it stops at like the first the root pagetable

397
00:22:16,720 --> 00:22:19,870
indexes at two five five not five one one.

398
00:22:20,050 --> 00:22:22,510
Yeah brilliant question, very good, I'm glad you asked.

399
00:22:22,510 --> 00:22:26,290
I saw in the Q&A questions and I was planning to talk about it,

400
00:22:26,290 --> 00:22:27,070
but of course I've forgot.

401
00:22:27,540 --> 00:22:29,280
So yeah what's going on here,

402
00:22:29,310 --> 00:22:31,560
why is two five five not five eleven.

403
00:22:33,180 --> 00:22:37,590
Yeah, we always say the trampoline lives at the top of the address space,

404
00:22:37,590 --> 00:22:40,800
while the top of the address space where it is,

405
00:22:40,830 --> 00:22:45,030
you know point is actually entry five eleven of the top level directory,

406
00:22:45,690 --> 00:22:47,190
and it is only two five five.

407
00:22:49,400 --> 00:22:52,250
Anybody any ideas why this is the case.

408
00:22:52,610 --> 00:22:54,110
We said that one bit

409
00:22:54,320 --> 00:22:57,260
that we said we were gonna use we actually aren't using,

410
00:22:57,260 --> 00:23:00,260
because of sign extension problems is just makes it easier

411
00:23:00,260 --> 00:23:01,910
and we also don't need that memory.

412
00:23:02,480 --> 00:23:04,820
Yeah, so that's exactly the right answer,

413
00:23:04,820 --> 00:23:08,000
so this is basically stupid technicality,

414
00:23:08,210 --> 00:23:11,870
so the virtual addresses are in principle,

415
00:23:11,930 --> 00:23:14,060
I think 39 bits, right,

416
00:23:14,760 --> 00:23:19,260
and but we actually in xv6, only 38 of them,

417
00:23:20,260 --> 00:23:24,550
and as a result, you know the top of the MAXVA for us,

418
00:23:24,580 --> 00:23:27,160
it is basically the 255 entry.

419
00:23:28,080 --> 00:23:29,850
And the reason we don't use the 39 bits,

420
00:23:29,850 --> 00:23:32,940
is for no particular good reason,

421
00:23:33,150 --> 00:23:36,660
and then that basically if you have the thirty ninth bit set,

422
00:23:37,190 --> 00:23:42,140
then all the remaining bits in the 64 bit address have to be ones.

423
00:23:42,840 --> 00:23:44,910
And so we just didn't want to deal with this problem

424
00:23:44,910 --> 00:23:46,290
that if we ever set 39,

425
00:23:46,290 --> 00:23:49,800
we also have to set the forty forty first, forty second, forty third etc

426
00:23:49,830 --> 00:23:50,730
until the sixty fourth.

427
00:23:55,050 --> 00:23:57,210
So that's an explanation, that makes sense.

428
00:23:58,370 --> 00:23:58,760
Yeah.

429
00:24:00,010 --> 00:24:02,470
That's a very good observation though.

430
00:24:04,600 --> 00:24:09,370
So I also had a question about why is the text and data on the same page.

431
00:24:09,720 --> 00:24:11,280
Very good question, also.

432
00:24:11,370 --> 00:24:12,660
That seems stupid right,

433
00:24:12,660 --> 00:24:14,700
I mean why not put them on separate pages,

434
00:24:14,700 --> 00:24:17,340
so that you can actually set the permission, that's more carefully.

435
00:24:18,140 --> 00:24:20,240
And the main reason,

436
00:24:20,240 --> 00:24:22,820
we're doing that is for simplicity.

437
00:24:23,150 --> 00:24:25,340
Usually make exec more complicated

438
00:24:25,370 --> 00:24:27,380
and we wanted the simplest exec possible.

439
00:24:29,210 --> 00:24:35,050
So a real operating system would not have data and text in the same page,

440
00:24:35,140 --> 00:24:36,970
in fact we have to specify

441
00:24:36,970 --> 00:24:40,240
that if you look at the loader flag in the makefile

442
00:24:40,240 --> 00:24:42,940
you'll see that it has the -N option

443
00:24:42,940 --> 00:24:44,710
and that force is actually data and text

444
00:24:44,710 --> 00:24:48,160
to be in a contiguous not in separate pages.

445
00:24:53,530 --> 00:24:54,730
Any more questions about this.

446
00:24:55,480 --> 00:24:57,130
I had a follow up question,

447
00:24:57,130 --> 00:24:59,590
regarding the number of bits, we're using.

448
00:24:59,950 --> 00:25:02,860
So you said we're using just 38 bits,

449
00:25:03,430 --> 00:25:08,470
is it is like the hardware still provides for us to use 39 bits,

450
00:25:08,470 --> 00:25:12,730
but we are designing our operating system that we're using 38.

451
00:25:13,100 --> 00:25:13,520
Yeah.

452
00:25:14,160 --> 00:25:14,970
So we're basically

453
00:25:14,970 --> 00:25:19,680
if the machine had more ram two to thirty eight,

454
00:25:20,160 --> 00:25:22,170
we would not be able to use that ram.

455
00:25:22,710 --> 00:25:25,050
Now we're running we're assuming

456
00:25:25,050 --> 00:25:28,380
basically much less memory than two to thirty eight,

457
00:25:28,380 --> 00:25:29,700
so it's not a big deal for us.

458
00:25:30,290 --> 00:25:32,960
But the real operating system, we would have done better.

459
00:25:36,350 --> 00:25:37,580
So just pure for simplicity.

460
00:25:38,930 --> 00:25:41,210
We want to make it as easy for you as possible,

461
00:25:41,210 --> 00:25:43,340
by reading a few lines of code possible.

462
00:25:46,890 --> 00:25:47,490
Okay.

463
00:25:48,450 --> 00:25:49,650
Yeah, makes sense.

464
00:25:50,750 --> 00:25:54,650
Okay, so now, let's switch to part two.

465
00:25:55,610 --> 00:25:58,520
And so let's bring up, a picture,

466
00:25:58,520 --> 00:25:59,990
you probably have looked at a lot.

467
00:26:00,380 --> 00:26:02,810
The kernel address space right,

468
00:26:02,810 --> 00:26:05,300
on the left is virtual address space,

469
00:26:05,300 --> 00:26:06,950
on the right is physical memory,

470
00:26:07,440 --> 00:26:10,620
you know here are IO devices,

471
00:26:11,080 --> 00:26:14,110
and then from here on is you know DRAM,

472
00:26:16,090 --> 00:26:24,960
and you know and basically running into what actually one twenty 28 megabytes for us.

473
00:26:24,990 --> 00:26:26,010
Because we just assume that

474
00:26:26,010 --> 00:26:29,730
there's no more than 250 and one twenty eight megabytes of memory.

475
00:26:30,140 --> 00:26:32,630
And so this part of the physical memory is the free memory.

476
00:26:33,840 --> 00:26:35,940
And then from that, this was kernel,

477
00:26:36,270 --> 00:26:38,790
oops, I drew a little bit wrong.

478
00:26:39,510 --> 00:26:41,040
Let me be more careful,

479
00:26:41,430 --> 00:26:47,480
so, here we basically have kernel text and data.

480
00:26:48,160 --> 00:26:53,230
And then you know this memory above, basically memory that the kernel allocator has

481
00:26:53,350 --> 00:26:56,050
and from there we allocate memory for user programs,

482
00:26:56,050 --> 00:26:58,240
we allocate memory for pagetables, etc.

483
00:26:58,330 --> 00:26:59,620
Kernel allocates everything for them,

484
00:27:00,680 --> 00:27:01,910
until it runs out of memory,

485
00:27:01,910 --> 00:27:04,760
when it runs out it gets to one twenty eight megabyte

486
00:27:04,760 --> 00:27:07,400
and then it starts returning errors or system calls.

487
00:27:08,680 --> 00:27:09,220
Okay.

488
00:27:10,490 --> 00:27:16,340
Good, so let me pull off my first part correct,

489
00:27:16,340 --> 00:27:19,820
in some sense of this assignment it was part two of the assignment,

490
00:27:19,850 --> 00:27:27,080
was just to run with or copy the kernel pagetables,

491
00:27:27,080 --> 00:27:32,150
and every process has its own kernel pagetables.

492
00:27:33,060 --> 00:27:37,170
That was basically that's the assignment here,

493
00:27:37,170 --> 00:27:38,850
so let me for jumping into the code,

494
00:27:38,850 --> 00:27:40,200
let me actually see a couple things,

495
00:27:40,580 --> 00:27:42,320
more general things about it.

496
00:27:43,800 --> 00:27:45,180
So part two.

497
00:27:51,160 --> 00:27:56,260
And maybe the first question really to sort of get your head around is

498
00:27:56,260 --> 00:27:58,600
like you know in some ways you do something trivial right,

499
00:27:58,600 --> 00:28:00,100
we already have the kernel pagetable,

500
00:28:00,130 --> 00:28:01,900
we just have to make [] copies of it,

501
00:28:02,170 --> 00:28:04,150
for one copy for each particular process.

502
00:28:04,690 --> 00:28:07,990
You, you might say well you know how hard can it be,

503
00:28:08,050 --> 00:28:10,990
it turns out it was a little bit harder for a couple reasons.

504
00:28:11,400 --> 00:28:13,620
Some good ones, some less good ones,

505
00:28:14,440 --> 00:28:16,120
harder than it seems.

506
00:28:20,500 --> 00:28:22,600
And one reason is that

507
00:28:22,630 --> 00:28:28,290
you know xv6 code it's specialized,

508
00:28:28,590 --> 00:28:30,120
for one kernel pagetable.

509
00:28:39,080 --> 00:28:43,010
You know, you saw that in kvminit.

510
00:28:43,500 --> 00:28:48,240
Yeah, and so that makes it a little bit generalizing,

511
00:28:48,240 --> 00:28:49,590
you know it's a little bit of work,

512
00:28:49,590 --> 00:28:51,660
because you have to modify the xv6 code.

513
00:28:54,580 --> 00:28:57,550
kvminit as you also saw is not the full,

514
00:28:58,360 --> 00:29:02,080
for building pagetable for the kernel.

515
00:29:02,230 --> 00:29:04,390
There's also stuff in procinit,

516
00:29:04,710 --> 00:29:07,620
that actually adds mappings to the kernel pagetable.

517
00:29:08,010 --> 00:29:10,830
And there's even something in virtio_disk,

518
00:29:12,040 --> 00:29:14,560
the actually interacts, you know the kernel pagetable.

519
00:29:16,000 --> 00:29:18,850
So basically there's no one single place in the kernel,

520
00:29:18,850 --> 00:29:21,430
where actually the kernel pagetable actually is built.

521
00:29:22,450 --> 00:29:25,990
Then the third reason, why you know this is slightly complicated,

522
00:29:25,990 --> 00:29:27,640
because you also have to deal with cleanup.

523
00:29:29,200 --> 00:29:32,920
So there's the aspect of actually creating these copies,

524
00:29:32,980 --> 00:29:35,260
but when every time user process exit,

525
00:29:35,560 --> 00:29:39,880
we also have to clean up those pagetables that were in use,

526
00:29:40,000 --> 00:29:43,390
because we want to return them to the pool of free memory,

527
00:29:43,390 --> 00:29:44,650
so that we can use them later,

528
00:29:44,800 --> 00:29:46,870
so that we can keep on running processes.

529
00:29:48,340 --> 00:29:49,510
That's what happens there.

530
00:29:51,240 --> 00:29:52,740
And that makes things a little bit complicated,

531
00:29:52,740 --> 00:29:54,600
because we've got to be little careful,

532
00:29:54,600 --> 00:29:57,360
in actually freeing the kernel pagetable

533
00:29:57,390 --> 00:29:59,040
or copy of the kernel pagetable,

534
00:29:59,220 --> 00:30:00,390
but we certainly don't want to,

535
00:30:00,390 --> 00:30:03,450
you know, free memory that actually still in use,

536
00:30:03,450 --> 00:30:06,270
or page table entries are still used by other pagetables.

537
00:30:06,920 --> 00:30:08,150
So we gotta be careful there,

538
00:30:08,720 --> 00:30:12,860
and then, you know basically, it's easy to make a small error.

539
00:30:14,320 --> 00:30:16,840
You know pagetable, when your copy those pagetables.

540
00:30:17,370 --> 00:30:19,800
You know if you get a little thing,

541
00:30:19,800 --> 00:30:21,930
you know basically you get a hard hard bug.

542
00:30:24,300 --> 00:30:27,750
And one of the problems here is I said earlier is,

543
00:30:27,960 --> 00:30:30,690
the hard bug shows up much much later.

544
00:30:30,940 --> 00:30:32,470
You've built the kernel pagetable,

545
00:30:32,470 --> 00:30:34,540
are built copy of the kernel pagetable,

546
00:30:34,940 --> 00:30:38,090
all looks fine, you load loaded in satp,

547
00:30:38,390 --> 00:30:41,810
they may even maybe the kernel runs for a little while, and then panics.

548
00:30:42,480 --> 00:30:44,640
And it turns out you know the reason that panics,

549
00:30:44,640 --> 00:30:48,120
because you made some small mistake in the pagetable,

550
00:30:48,150 --> 00:30:49,560
long, long time ago.

551
00:30:49,990 --> 00:30:51,370
And so this is one reason why

552
00:30:51,370 --> 00:30:55,300
it makes you know makes life difficult for kernel programming.

553
00:30:56,950 --> 00:30:59,290
And you know and basically these hard bugs,

554
00:30:59,290 --> 00:31:02,110
basically are just time consuming to track down.

555
00:31:11,630 --> 00:31:13,520
Because of the point that you know happens,

556
00:31:13,610 --> 00:31:16,820
that's actually not the real cause of of the bug,

557
00:31:16,820 --> 00:31:18,350
but about you know the real cause,

558
00:31:18,350 --> 00:31:21,590
you know somewhere way earlier when you set up the pagetables.

559
00:31:23,840 --> 00:31:25,250
Okay, um.

560
00:31:26,310 --> 00:31:28,320
So it turns out,

561
00:31:28,500 --> 00:31:30,360
there are two approaches to go about it,

562
00:31:30,570 --> 00:31:35,480
you know to this lab which sort of two solution approaches.

563
00:31:38,850 --> 00:31:41,250
In fact, some of you have probably used a mixture of them,

564
00:31:41,610 --> 00:31:45,750
the one you know approach what call copy approach.

565
00:31:47,550 --> 00:31:51,330
And the copy approach basically literally makes a copy to the kernel pagetable,

566
00:31:51,840 --> 00:31:56,400
so every time you need a new kernel pagetable,

567
00:31:56,520 --> 00:31:58,800
you allocate pages for the pagetable,

568
00:31:58,800 --> 00:32:02,130
you fill them in etc, etc.

569
00:32:02,920 --> 00:32:09,150
And there's, that's one approach, the second approach is

570
00:32:09,180 --> 00:32:15,890
basically to share the kernel pagetable,

571
00:32:15,890 --> 00:32:18,200
and in this case, what you do is

572
00:32:18,200 --> 00:32:22,460
instead of trying to make a literally nice clean copy of the kernel pagetables,

573
00:32:22,700 --> 00:32:26,630
you share all the entries that are basically are going to be unmodified.

574
00:32:27,300 --> 00:32:29,010
You know from the assignment,

575
00:32:29,010 --> 00:32:32,610
that basically anything above CLINT to PLIC address,

576
00:32:32,610 --> 00:32:35,280
is actually going to be unchanged, unmodified,

577
00:32:35,310 --> 00:32:36,960
there's nothing you have to load there.

578
00:32:37,290 --> 00:32:38,910
In the part three,

579
00:32:39,060 --> 00:32:40,290
so you know what are basically,

580
00:32:40,440 --> 00:32:43,980
all the entries from above zero are probably identical,

581
00:32:44,130 --> 00:32:45,990
so you could share those entries, if you will.

582
00:32:47,020 --> 00:32:50,770
So that both approaches are actually perfectly fine.

583
00:32:51,080 --> 00:32:54,950
It's not abundantly clear, which one is the better one.

584
00:32:55,100 --> 00:32:57,890
My solution, take this approach.

585
00:32:58,240 --> 00:33:02,770
And I don't really have great justification for it

586
00:33:02,800 --> 00:33:06,970
other than maybe partially laziness.

587
00:33:07,210 --> 00:33:08,560
I didn't want to think too hard,

588
00:33:08,590 --> 00:33:10,210
what's in the kernel pagetable,

589
00:33:10,210 --> 00:33:13,000
and so I figured out all the things that are going to stay the same,

590
00:33:13,210 --> 00:33:14,710
why do you copy them over

591
00:33:14,710 --> 00:33:17,540
or you know copy the ptes over

592
00:33:17,690 --> 00:33:19,280
and then I have to think too hard about

593
00:33:19,280 --> 00:33:21,470
actually isn't that part of the kernel address space.

594
00:33:22,480 --> 00:33:25,570
And you know leads to short code,

595
00:33:25,570 --> 00:33:26,800
but you know I'm not sure actually

596
00:33:26,800 --> 00:33:28,900
shorter than, for example, the copy solution.

597
00:33:29,510 --> 00:33:31,130
But it's important to realize that basically

598
00:33:31,130 --> 00:33:35,390
there are two different ways of going about this particular problem.

599
00:33:35,990 --> 00:33:40,340
In either case, you know whatever approach you use,

600
00:33:40,340 --> 00:33:42,380
you know there's sort of an implementation strategy to it.

601
00:33:42,850 --> 00:33:45,130
And you know the implementation strategy that I use

602
00:33:45,130 --> 00:33:47,200
for almost any kernel program

603
00:33:47,200 --> 00:33:50,140
is to do everything in baby steps.

604
00:33:53,120 --> 00:33:55,880
So I might have, for general plan in my head

605
00:33:55,880 --> 00:33:57,440
about how I go over the whole,

606
00:33:57,440 --> 00:33:59,660
you know all the changes I want to make,

607
00:33:59,870 --> 00:34:01,880
but once I start making these changes,

608
00:34:01,910 --> 00:34:03,770
I do like one or two,

609
00:34:03,950 --> 00:34:06,350
and then make sure that those work first

610
00:34:06,350 --> 00:34:08,650
and then you know, keep going,

611
00:34:09,160 --> 00:34:11,080
and the other thing I do

612
00:34:11,080 --> 00:34:14,110
is mostly used as a strategy to keep the existing code,

613
00:34:17,750 --> 00:34:21,170
don't really modify certainly not initially,

614
00:34:21,380 --> 00:34:24,860
I just add code and switch to this new code

615
00:34:25,040 --> 00:34:26,780
and then the little baby steps

616
00:34:26,780 --> 00:34:27,770
and the reason I'm doing that is

617
00:34:27,770 --> 00:34:30,290
that I can easily compare old new code,

618
00:34:30,620 --> 00:34:33,260
and I always have a working old solution,

619
00:34:33,260 --> 00:34:34,790
that I can just roll back to,

620
00:34:35,000 --> 00:34:36,980
so in case some strange bugs happens,

621
00:34:36,980 --> 00:34:40,850
then I can go back maybe one step and then try again,

622
00:34:40,850 --> 00:34:43,580
so you figure out like I said were my reason was wrong.

623
00:34:44,540 --> 00:34:48,380
Basically you know baby steps what partly

624
00:34:48,380 --> 00:34:49,940
because these bugs are so hard to track down.

625
00:34:52,960 --> 00:34:58,150
Okay, let me switch to code,

626
00:34:58,300 --> 00:35:02,380
so maybe starting vm.c.

627
00:35:02,470 --> 00:35:07,870
So, the, here's the existing kvminit,

628
00:35:08,290 --> 00:35:11,410
and actually can everybody see the code?

629
00:35:14,650 --> 00:35:20,360
Okay, and, the assignment we are asked

630
00:35:20,360 --> 00:35:22,700
for correct is to make a copy of it

631
00:35:22,970 --> 00:35:26,420
and the way I do that is,

632
00:35:26,420 --> 00:35:28,040
let me see where that is.

633
00:35:39,820 --> 00:35:41,650
So here's my uvmcreate,

634
00:35:41,680 --> 00:35:43,330
that's just boring part,

635
00:35:43,330 --> 00:35:47,110
that's basically creating, allocating the top level page directory,

636
00:35:47,110 --> 00:35:49,240
also the l2 page directory.

637
00:35:49,760 --> 00:35:52,490
And then here's my kvm,

638
00:35:52,490 --> 00:35:55,070
the equivalent of kvminit.

639
00:35:55,520 --> 00:35:58,370
So I get the top of the page directory here,

640
00:35:58,910 --> 00:36:00,410
in this site.

641
00:36:00,710 --> 00:36:07,640
Then, basically I copy the top 511 entries from the kernel pagetable

642
00:36:07,640 --> 00:36:11,630
that was already set up by kvminit,

643
00:36:11,630 --> 00:36:15,320
and so that gives me most of the kernel pagetable.

644
00:36:15,630 --> 00:36:19,650
And then, I just have to map in all the devices

645
00:36:19,650 --> 00:36:25,270
that live in the zero entry,

646
00:36:25,300 --> 00:36:27,940
because zero entry, the entry that we're going to modify it later

647
00:36:27,940 --> 00:36:30,250
or we're going to map user pages into the bottom.

648
00:36:30,760 --> 00:36:34,330
And there's a couple devices that live in that in zero entry,

649
00:36:34,330 --> 00:36:39,040
those you know device needs to be added to the to this,

650
00:36:39,040 --> 00:36:42,760
per process pagetable, kernel page table.

651
00:36:44,140 --> 00:36:47,560
And so maybe I go back to this picture earlier.

652
00:36:51,260 --> 00:36:54,920
So let me put up the kernel pagetable again,

653
00:36:56,790 --> 00:37:01,440
maybe this picture as good as any,

654
00:37:01,440 --> 00:37:03,450
so if you think about my solution,

655
00:37:03,600 --> 00:37:10,950
basically these entries I just share with existing kernel pagetable,

656
00:37:11,250 --> 00:37:15,360
so I don't have to allocate any l1 or l2 or l0 levels,

657
00:37:15,540 --> 00:37:17,130
they already exists

658
00:37:17,130 --> 00:37:21,180
and the only thing I do is basically literally copy pte entry.

659
00:37:22,160 --> 00:37:27,500
So only the bottom part or the bottom entry that is the piece,

660
00:37:27,500 --> 00:37:32,480
I need to actually rebuild or copy explicitly instead of copying ptes.

661
00:37:32,850 --> 00:37:38,200
And that covers you know the bottom one gigabyte address space.

662
00:37:39,000 --> 00:37:42,330
In one page covers 4096.

663
00:37:45,930 --> 00:37:50,700
And so this you know this entry covers five twelve.

664
00:37:51,060 --> 00:37:53,370
But this has been two megabyte.

665
00:37:54,360 --> 00:37:55,770
And this is one gigabyte

666
00:37:56,280 --> 00:37:58,950
and basically only one of these entries, I need to fill it.

667
00:38:01,810 --> 00:38:02,530
That makes sense?

668
00:38:05,370 --> 00:38:08,760
So returning to my code and basically,

669
00:38:09,180 --> 00:38:11,220
that's all I do, kvmcreate.

670
00:38:12,090 --> 00:38:18,510
And in kv- my kvmfree is maybe not, maybe clean solution,

671
00:38:18,720 --> 00:38:20,820
but I take full advantage of the knowledge

672
00:38:20,820 --> 00:38:24,990
that I don't have to do anything from the entries one to 511

673
00:38:24,990 --> 00:38:26,400
in the top page level directory.

674
00:38:26,730 --> 00:38:28,920
The only entry to do anything about is

675
00:38:28,920 --> 00:38:33,450
the bottom entry of the kernel of the top level directory.

676
00:38:33,790 --> 00:38:36,730
That points to one l1 entry

677
00:38:36,730 --> 00:38:39,730
and that one l1 entry, I just need to go through

678
00:38:39,940 --> 00:38:44,470
and free old l2 or l0 entries.

679
00:38:45,010 --> 00:38:46,870
And then the ends you know free l1

680
00:38:46,870 --> 00:38:47,950
and then the kernel pagetable.

681
00:38:49,420 --> 00:38:53,290
And so that's my k- kvmfree and my kvmcreate.

682
00:38:54,050 --> 00:38:57,230
So that allows me to create a kernel pagetable process

683
00:38:57,230 --> 00:39:01,030
and then free once is when we're done.

684
00:39:02,360 --> 00:39:03,470
Sorry, quick question.

685
00:39:03,710 --> 00:39:05,180
Could you explain again,

686
00:39:05,180 --> 00:39:09,470
the reasoning for only using one to five twelve and not zero?

687
00:39:10,360 --> 00:39:10,900
Yes.

688
00:39:10,930 --> 00:39:14,110
Okay, so,

689
00:39:14,110 --> 00:39:17,470
maybe the easy thing to do actually let me go back through the picture here.

690
00:39:19,860 --> 00:39:22,470
So we have a kernel address space, correct.

691
00:39:26,240 --> 00:39:31,970
And you know this O x eight zero zero zero zero blah blah blah,

692
00:39:32,220 --> 00:39:33,180
in, um.

693
00:39:34,270 --> 00:39:38,560
What entry does O x zero fall into in the for the top level page directory.

694
00:39:46,150 --> 00:39:47,200
It's like, the.

695
00:39:49,340 --> 00:39:50,240
Zeroth entry?

696
00:39:50,540 --> 00:39:52,400
No, not to zeroth entry, right.

697
00:39:53,440 --> 00:39:56,680
So whatever you know what zero entry like this entry,

698
00:39:56,680 --> 00:39:58,570
how much does it cover this entry.

699
00:40:02,450 --> 00:40:03,320
How much address space,

700
00:40:03,320 --> 00:40:07,490
does this bottom entry of the zero entry of the top level page directory cover.

701
00:40:10,140 --> 00:40:12,690
I think CLINT is,

702
00:40:12,690 --> 00:40:16,740
it's free between zero and 0x2000.

703
00:40:17,730 --> 00:40:19,200
Yeah, so okay so maybe I'm going to,

704
00:40:19,200 --> 00:40:20,910
I think you're absolutely right direction,

705
00:40:20,910 --> 00:40:23,790
so the bottom entry copy one gigabyte, right.

706
00:40:24,750 --> 00:40:27,630
And we know like maybe I can.

707
00:40:29,630 --> 00:40:34,400
We saw the bottom entry one gigabyte which,

708
00:40:36,860 --> 00:40:39,620
in that one gigabyte just CLINT the PLIC, right,

709
00:40:40,380 --> 00:40:44,040
UART and VIRTIO_disk, I believe.

710
00:40:44,500 --> 00:40:51,340
And then KERNBASE actually already sits up in a higher entry, right.

711
00:40:51,340 --> 00:40:52,660
We can compute if we wanted to,

712
00:40:52,660 --> 00:40:54,700
we could take 0x eight zero correct,

713
00:40:54,700 --> 00:40:58,400
shifted twelve, shift nine, shift nine,

714
00:40:58,640 --> 00:41:03,200
and I I think I don't remember the top we have what is.

715
00:41:04,420 --> 00:41:06,940
Try to figure it out, if you want to actually maybe we'll try.

716
00:41:08,270 --> 00:41:10,430
This is always very risky to do in lecture,

717
00:41:10,430 --> 00:41:15,970
but, so, gdb.

718
00:41:16,240 --> 00:41:22,190
So let's go to layout, here's KERNBASE,

719
00:41:29,240 --> 00:41:31,760
so we could print.

720
00:41:32,800 --> 00:41:39,430
So shift is twelve, that gives us, that offset.

721
00:41:39,430 --> 00:41:40,000
Oops.

722
00:41:46,280 --> 00:41:51,280
Good as that, so then we'll shift that guy.

723
00:41:51,980 --> 00:41:53,240
I think you could see this.

724
00:41:54,600 --> 00:41:55,470
Nine.

725
00:41:56,740 --> 00:41:59,890
Right now is the next entry one more,

726
00:42:01,480 --> 00:42:02,440
so this entry two.

727
00:42:03,880 --> 00:42:04,570
Does it make sense.

728
00:42:06,270 --> 00:42:08,760
So we go back to our picture here.

729
00:42:11,260 --> 00:42:14,680
Basically KERNBASE is entry two,

730
00:42:15,400 --> 00:42:18,780
in the top of page directory, right.

731
00:42:18,780 --> 00:42:22,680
So and we know from the third part of the assignment,

732
00:42:22,680 --> 00:42:26,990
basically we don't really have to worry about anything above PLIC.

733
00:42:28,480 --> 00:42:32,260
And all that stuff falls actually entry zero.

734
00:42:34,390 --> 00:42:34,990
Okay?

735
00:42:36,560 --> 00:42:38,060
So that answer the earlier question.

736
00:42:39,620 --> 00:42:40,520
Yes, thank you.

737
00:42:42,860 --> 00:42:46,130
Okay, so now we the only thing we have left to do is,

738
00:42:46,130 --> 00:42:52,860
you know, double check where we got to call this function kvmcreate,

739
00:42:53,340 --> 00:42:59,910
and and you know that's going to be allocproc.

740
00:43:01,270 --> 00:43:03,720
So, and.

741
00:43:06,820 --> 00:43:07,240
Oops.

742
00:43:12,460 --> 00:43:14,470
Here where is the new process initialized,

743
00:43:14,470 --> 00:43:17,740
then you know I'm sure all of you is exactly the same way,

744
00:43:17,740 --> 00:43:21,820
you entry, you allocate when you declare field in the proc structure

745
00:43:22,120 --> 00:43:25,210
and basically the result of it is actually what we stick in the kernel pagetable.

746
00:43:27,080 --> 00:43:29,030
Okay, then we only the thing that we have to worry about,

747
00:43:29,030 --> 00:43:30,770
of course we need to use the pagetable,

748
00:43:31,150 --> 00:43:34,180
and so we need to look at the scheduler.

749
00:43:34,600 --> 00:43:37,300
Basically, the assignment more or less told you what to do

750
00:43:37,660 --> 00:43:41,530
which is you know before you switch to that user process,

751
00:43:41,530 --> 00:43:43,360
you need to switch the kernel pagetables,

752
00:43:43,720 --> 00:43:48,610
which basically means loading, you know, this process kernel pagetable in satp.

753
00:43:49,020 --> 00:43:54,060
And then when you're done switching in running the other process,

754
00:43:54,060 --> 00:43:55,770
you come back from running the other process

755
00:43:55,770 --> 00:43:57,540
and you're gonna go back and run the scheduler,

756
00:43:57,750 --> 00:44:00,480
you gotta switch back to the main kernel pagetable,

757
00:44:00,980 --> 00:44:02,930
the [] kernel pagetable,

758
00:44:02,930 --> 00:44:04,940
because that's the one that actually used by scheduler.

759
00:44:07,260 --> 00:44:08,790
And why do we need to do this switch,

760
00:44:09,030 --> 00:44:10,080
why is this important.

761
00:44:16,820 --> 00:44:17,480
Anybody?

762
00:44:19,820 --> 00:44:21,950
So it picks the right kernel pagetable,

763
00:44:22,460 --> 00:44:26,030
because the satp, when you go to the pagetable entries,

764
00:44:26,060 --> 00:44:26,930
it picks the right,

765
00:44:27,700 --> 00:44:29,980
it picks the right pagetable to pick from.

766
00:44:30,770 --> 00:44:36,870
Yeah, hold on or something more than a second.

767
00:44:40,210 --> 00:44:43,780
Yeah, so okay, so when we stop.

768
00:44:44,210 --> 00:44:46,130
Okay, let me another way to ask this question,

769
00:44:46,520 --> 00:44:48,470
when is this kernel pagetable freed.

770
00:44:52,000 --> 00:44:53,590
When the user process is done,

771
00:44:53,590 --> 00:44:55,000
so if we didn't switch,

772
00:44:55,000 --> 00:44:56,380
that would mean that that,

773
00:44:56,770 --> 00:45:00,430
we could be using a pagetable of a process that was being freed,

774
00:45:00,430 --> 00:45:02,260
so the pagetable was freed,

775
00:45:02,470 --> 00:45:05,470
so we don't want to be dependent on the process were not running right now.

776
00:45:05,710 --> 00:45:09,520
Yeah, exactly, we can never free the page table of the process that's currently running.

777
00:45:10,400 --> 00:45:12,410
So we have to have some plan,

778
00:45:12,440 --> 00:45:16,250
you know to actually free process at the point that they're not running anymore.

779
00:45:16,860 --> 00:45:19,500
And you know the wait system call is our way out,

780
00:45:19,500 --> 00:45:22,260
basically wait calls look if there's any children

781
00:45:22,260 --> 00:45:25,020
that are are not you know that can be cleaned up.

782
00:45:25,350 --> 00:45:26,520
And then they cleans them up.

783
00:45:27,190 --> 00:45:29,830
And that means that basically,

784
00:45:29,950 --> 00:45:33,340
when the parent process switch over process,

785
00:45:33,340 --> 00:45:36,460
we're going to make absolutely sure that you know that,

786
00:45:36,860 --> 00:45:39,830
the pagetable that is loaded in the satp register,

787
00:45:40,040 --> 00:45:42,350
is not you know one of the,

788
00:45:42,530 --> 00:45:46,090
is not that process you know pagetable will actually currently free.

789
00:45:47,030 --> 00:45:49,700
You know it could be the case there's no process running at all right

790
00:45:50,150 --> 00:45:52,520
and so the scheduler basically has its own pagetable,

791
00:45:52,790 --> 00:45:55,250
sort of all processes can actually be cleaned up.

792
00:45:59,410 --> 00:46:00,070
That makes sense?

793
00:46:05,860 --> 00:46:07,450
I'm sorry, I had a question,

794
00:46:07,480 --> 00:46:12,490
is it that you're mapping the C L I N T

795
00:46:12,970 --> 00:46:16,270
into the new process kernel pagetables?

796
00:46:18,030 --> 00:46:18,750
Why?

797
00:46:18,840 --> 00:46:23,610
Because I think the assignment says like I only have to,

798
00:46:24,000 --> 00:46:28,710
user process, you will not be bigger than CLINT is that it.

799
00:46:29,460 --> 00:46:33,110
When I map both the PLIC and the CLINT, right,

800
00:46:33,110 --> 00:46:35,540
and so but I think the assignment told us that,

801
00:46:36,020 --> 00:46:37,430
so what is the lowest one.

802
00:46:37,460 --> 00:46:41,700
I think there PLIC is the lowest one,

803
00:46:41,700 --> 00:46:42,840
and this [] told us,

804
00:46:42,840 --> 00:46:47,590
that the user process will not be bigger than the PLIC address.

805
00:46:47,590 --> 00:46:48,190
Okay.

806
00:46:50,940 --> 00:46:51,900
Just to make it easy,

807
00:46:51,960 --> 00:46:52,800
we could then,

808
00:46:53,490 --> 00:46:55,230
want to make it as easy as possible for you

809
00:46:55,230 --> 00:46:57,810
clear you could have done a better if you wanted to.

810
00:46:59,260 --> 00:47:02,470
But you know that was the simplest thing to do.

811
00:47:03,500 --> 00:47:05,750
So you have to make a few modifications to get it to work.

812
00:47:11,640 --> 00:47:12,660
Any further questions?

813
00:47:13,700 --> 00:47:14,660
I have a question,

814
00:47:15,740 --> 00:47:20,570
is it possible that you can copy zero to five twelve

815
00:47:20,600 --> 00:47:22,190
and then every time you switch,

816
00:47:22,190 --> 00:47:25,580
so you're still using like the global root pagetable

817
00:47:25,610 --> 00:47:28,820
except you only copy the first root page table,

818
00:47:29,480 --> 00:47:31,820
and every time you switch a process,

819
00:47:31,820 --> 00:47:35,960
you copy over the user's addresses over to.

820
00:47:36,290 --> 00:47:36,980
Yeah.

821
00:47:36,980 --> 00:47:38,270
Is that possible to do.

822
00:47:39,040 --> 00:47:40,720
In principle I think you could do something like that,

823
00:47:40,720 --> 00:47:44,050
so instead of basically doing when you allocate a process and free it,

824
00:47:44,050 --> 00:47:47,110
you could do to dynamically during this scheduler switch.

825
00:47:47,920 --> 00:47:52,450
Um, seems complicated.

826
00:47:53,270 --> 00:47:55,100
That might be more costly,

827
00:47:55,100 --> 00:47:58,910
because that means that every time you switch between two processes,

828
00:47:58,910 --> 00:48:02,240
you may have to make a copy of parts of the kernel pagetable.

829
00:48:02,870 --> 00:48:06,170
And so that might be turn to perform,

830
00:48:06,170 --> 00:48:07,250
it's not an ideal thing.

831
00:48:07,640 --> 00:48:11,150
The assignment didn't really say anything about it,

832
00:48:11,180 --> 00:48:14,090
you might have timed out in usertests, if you did that.

833
00:48:18,070 --> 00:48:19,240
Yeah I was just wondering,

834
00:48:19,240 --> 00:48:20,350
because I tried that approach,

835
00:48:20,350 --> 00:48:22,450
and it was a bad experience,

836
00:48:22,480 --> 00:48:23,890
I was wondering if that was possible.

837
00:48:23,890 --> 00:48:27,520
I can imagine, but I I think it's in principle possible,

838
00:48:27,520 --> 00:48:30,850
you could allocate a new page table correctly and switch every time,

839
00:48:31,980 --> 00:48:33,390
and free it when you switch out.

840
00:48:38,820 --> 00:48:39,720
I don't think it's simple,

841
00:48:39,720 --> 00:48:41,850
but you know in principle it's possible I think.

842
00:48:43,410 --> 00:48:45,960
Perhaps some other modifications to xv6.

843
00:48:48,760 --> 00:48:49,630
Any other questions?

844
00:48:56,660 --> 00:48:57,920
Of course the other change that,

845
00:48:57,920 --> 00:48:59,720
of course have to make is usertrapret,

846
00:48:59,810 --> 00:49:00,890
you got to make sure that

847
00:49:00,890 --> 00:49:05,310
actually you run with the the processes kernel page table.

848
00:49:07,390 --> 00:49:07,960
Okay?

849
00:49:09,390 --> 00:49:10,980
Okay, so let's switch them to,

850
00:49:10,980 --> 00:49:12,510
I guess part three.

851
00:49:15,420 --> 00:49:21,800
To switch back to actually here.

852
00:49:24,470 --> 00:49:25,340
Okay, so,

853
00:49:25,340 --> 00:49:28,160
actually that's maybe not a helpful picture.

854
00:49:30,620 --> 00:49:31,610
Okay, part three.

855
00:49:36,820 --> 00:49:39,460
So basically what our plan is,

856
00:49:39,460 --> 00:49:43,250
we have our kernel pagetable as before,

857
00:49:43,790 --> 00:49:47,480
and you know we have the PLIC entry sitting somewhere.

858
00:49:48,420 --> 00:49:49,830
And what we're gonna do is,

859
00:49:49,830 --> 00:49:53,400
we're gonna use you know everything below PLIC,

860
00:49:53,690 --> 00:49:58,320
to actually store the user pagetable,

861
00:49:58,380 --> 00:50:01,740
we're going to map the user pagetable into all the user program,

862
00:50:01,740 --> 00:50:03,990
the user program actually in the kernel pagetable,

863
00:50:05,180 --> 00:50:05,870
in the bottom.

864
00:50:09,240 --> 00:50:10,560
And that's the goal,

865
00:50:10,590 --> 00:50:12,600
and what's the first question to ask,

866
00:50:12,600 --> 00:50:15,360
you know why the [] do that.

867
00:50:16,180 --> 00:50:18,340
Is there any you know any advantage of it

868
00:50:18,340 --> 00:50:20,830
and you know I think maybe the,

869
00:50:20,860 --> 00:50:22,510
it may be a easy way

870
00:50:22,510 --> 00:50:25,970
to see why it might be interesting

871
00:50:26,150 --> 00:50:28,220
is to [] compare to copyin.

872
00:50:28,930 --> 00:50:31,000
The new copyin and the old copyin.

873
00:50:32,790 --> 00:50:37,270
So, if you know what happens in the copyin,

874
00:50:37,270 --> 00:50:42,760
it correctly, copyin copies data from the user space into the kernel address space.

875
00:50:43,590 --> 00:50:51,240
Um, and but you know if the kernel has does not have the user address map,

876
00:50:51,760 --> 00:50:57,470
basically the kernel has to do this page the time, correct,

877
00:50:57,470 --> 00:51:00,350
because the pages in virtual address space may be continuous

878
00:51:00,350 --> 00:51:02,450
with the physical address space, they're not continuous.

879
00:51:02,990 --> 00:51:04,910
And basically with the kernel does in copyin,

880
00:51:04,910 --> 00:51:10,590
it basically translates the virtual user address into physical address.

881
00:51:11,490 --> 00:51:16,110
Since the kernel has all physical memory mapped with identity mapping,

882
00:51:16,320 --> 00:51:21,030
the physical address is also a valid kernel virtual address

883
00:51:21,270 --> 00:51:24,260
and then it basically moves whatever part of that page,

884
00:51:24,260 --> 00:51:26,690
physical page needs to be copied that actually copies it.

885
00:51:27,960 --> 00:51:29,460
And so if data structure,

886
00:51:29,460 --> 00:51:33,150
for example spans, you know, two page boundary,

887
00:51:33,150 --> 00:51:36,390
like for example, the sysinfo struct may be used in lab two,

888
00:51:36,390 --> 00:51:39,060
maybe spans a pagetable boundary,

889
00:51:39,300 --> 00:51:41,010
it will copy like maybe you know

890
00:51:41,010 --> 00:51:43,530
some bytes from the first physical page

891
00:51:43,620 --> 00:51:46,290
and then some bytes from the second physical page.

892
00:51:48,160 --> 00:51:48,820
Does it make sense.

893
00:51:52,180 --> 00:51:53,950
That's what the kernel copyin does,

894
00:51:54,010 --> 00:51:56,590
and the goal was basically to get them into a new copyin,

895
00:51:57,850 --> 00:52:04,650
where the kernel program didn't really have to worry about the physical layout,

896
00:52:04,650 --> 00:52:06,990
basically off the user address space.

897
00:52:07,430 --> 00:52:09,350
And this new copyin,

898
00:52:09,350 --> 00:52:10,850
you know we see we basically do nothing,

899
00:52:10,850 --> 00:52:13,040
literally nothing else, just copy,

900
00:52:13,360 --> 00:52:17,620
do, you know, from the user addresses straight into the kernel.

901
00:52:18,020 --> 00:52:20,720
And we don't really have to call walk anymore,

902
00:52:20,930 --> 00:52:22,730
because we can rely on the,

903
00:52:22,730 --> 00:52:24,170
we set up that the pagetables correctly,

904
00:52:24,170 --> 00:52:26,690
now the pagetable hardware will do the walk for us.

905
00:52:27,330 --> 00:52:27,690
Right.

906
00:52:28,710 --> 00:52:30,450
And so that was the goal,

907
00:52:30,960 --> 00:52:35,190
and so that makes life of kernel programmers are a little bit easier,

908
00:52:35,220 --> 00:52:37,740
on any other advantages to this approach.

909
00:52:45,120 --> 00:52:46,770
Is it also more performance,

910
00:52:46,770 --> 00:52:50,280
because the hardware is gonna do the walking and not software.

911
00:52:51,090 --> 00:52:52,620
Yeah, one way to,

912
00:52:52,620 --> 00:52:54,600
I think their performance implications for sure,

913
00:52:54,780 --> 00:52:56,850
one way to think about this is that

914
00:52:57,210 --> 00:53:00,330
in copyin correct, if the kernel data structure

915
00:53:00,330 --> 00:53:06,340
or data data that we copied from user space to kernel spaces big,

916
00:53:06,340 --> 00:53:09,270
we have to do that you know page at a time, right,

917
00:53:09,270 --> 00:53:11,910
in every page, we have to call this function walkaddr,

918
00:53:11,910 --> 00:53:13,680
and then there's the internal walking.

919
00:53:14,250 --> 00:53:18,810
And so, this might actually be a reasonable expenses expensive.

920
00:53:19,650 --> 00:53:21,450
What examples are there examples of

921
00:53:21,450 --> 00:53:25,800
where the kernel copies a lot of data from user space.

922
00:53:33,340 --> 00:53:36,730
Which system call might copy a ton of data from user space.

923
00:53:38,550 --> 00:53:39,180
Write?

924
00:53:39,600 --> 00:53:41,070
Yeah write, write, you're right,

925
00:53:41,070 --> 00:53:47,470
you can give an arbitrary, an arbitrary buffer of arbitrary size.

926
00:53:47,760 --> 00:53:51,240
And you know the kernel [] may have to copy this into,

927
00:53:51,240 --> 00:53:54,120
for example, the file system or into a pipe.

928
00:53:54,810 --> 00:53:57,000
And that could be a reasonable expensive.

929
00:54:00,180 --> 00:54:01,950
You gotta think what is another advantage,

930
00:54:01,950 --> 00:54:03,390
if the user,

931
00:54:03,660 --> 00:54:06,450
we didn't explore that in this assignment,

932
00:54:06,450 --> 00:54:09,730
we should we could have one another advantage.

933
00:54:13,060 --> 00:54:14,620
So if you think about,

934
00:54:14,740 --> 00:54:16,450
some of these, this code here correct,

935
00:54:16,450 --> 00:54:18,850
when it takes a structure out of user space,

936
00:54:19,160 --> 00:54:22,010
it copies the whole structure into kernel space.

937
00:54:22,880 --> 00:54:25,610
If user space is mapped into the kernel pagetable,

938
00:54:25,610 --> 00:54:26,570
do we have to do that.

939
00:54:31,630 --> 00:54:34,210
For example, if we have to update one field of the structure.

940
00:54:46,830 --> 00:54:51,440
So if data structure is just mapped into the kernel address space right,

941
00:54:51,440 --> 00:54:53,570
then we can usually read and write,

942
00:54:53,570 --> 00:54:56,180
you know with store instruction through that particular data structure,

943
00:54:56,180 --> 00:54:57,620
we can use update one field.

944
00:54:58,320 --> 00:54:59,670
Unlike the kernel now does,

945
00:54:59,670 --> 00:55:04,170
basically it copies the structure from kernel space to user space,

946
00:55:04,170 --> 00:55:06,390
and then maybe back out using copyout.

947
00:55:07,110 --> 00:55:09,780
And so we map the user space into,

948
00:55:09,780 --> 00:55:11,610
the user program into the kernel address space,

949
00:55:11,640 --> 00:55:14,250
we can just manipulate it much more freely

950
00:55:14,280 --> 00:55:16,170
than the way we do it now.

951
00:55:18,620 --> 00:55:19,370
Does that make sense,

952
00:55:19,370 --> 00:55:23,930
in terms of motivation, why many kernels actually have this particular structure

953
00:55:23,930 --> 00:55:28,610
where they map bottom part of the user,

954
00:55:28,790 --> 00:55:32,600
were to map the user program into the bottom part of the kernel address space.

955
00:55:39,260 --> 00:55:39,830
Okay?

956
00:55:44,750 --> 00:55:48,290
Okay, so so let's see, look at my code

957
00:55:48,320 --> 00:55:51,800
and and so you understand what actually.

958
00:55:52,980 --> 00:55:57,090
I I guess so there's basically one function, that is the key,

959
00:55:57,270 --> 00:56:01,620
you know assume we were building somewhere valid user pagetable,

960
00:56:01,620 --> 00:56:02,400
and then we just have to

961
00:56:02,400 --> 00:56:07,500
map entries from the user pagetable into the kernel pagetable,

962
00:56:07,960 --> 00:56:10,720
the processes kernel pagetables,

963
00:56:10,720 --> 00:56:13,390
that function kvmmapuser exactly does this.

964
00:56:13,930 --> 00:56:16,090
And it's pretty boring,

965
00:56:16,090 --> 00:56:20,440
the main couple interesting points to point out in work,

966
00:56:20,440 --> 00:56:28,550
yeah yeah that's the same sort of interfaces to uvmalloc whatever

967
00:56:28,610 --> 00:56:30,110
or basically if you know

968
00:56:30,110 --> 00:56:33,320
you go from the old size up to the new size page at a time.

969
00:56:33,980 --> 00:56:34,610
Yeah.

970
00:56:35,190 --> 00:56:39,270
You find the upte,

971
00:56:39,300 --> 00:56:45,760
you know the pointer to the pte for that particular virtual address

972
00:56:45,760 --> 00:56:47,080
in the user page table.

973
00:56:48,000 --> 00:56:50,610
And so we look at the,

974
00:56:51,200 --> 00:56:53,150
if you look at the picture

975
00:56:53,150 --> 00:56:54,680
that we had a little while back,

976
00:56:54,680 --> 00:56:56,840
you know look at this picture.

977
00:56:57,410 --> 00:56:59,750
Basically, what this is going to return correct is,

978
00:56:59,960 --> 00:57:01,640
we're going to walk the user pagetable

979
00:57:01,640 --> 00:57:04,610
and we'll find for example the upte

980
00:57:04,820 --> 00:57:07,010
that maps in that particular virtual address

981
00:57:07,010 --> 00:57:10,010
where we basically pointer to that entry into the pagetable,

982
00:57:14,740 --> 00:57:16,060
and that's what walk does.

983
00:57:16,600 --> 00:57:21,010
And so if thing is mapped, it's not

984
00:57:21,010 --> 00:57:22,810
that must mean at least the answer is

985
00:57:22,810 --> 00:57:25,840
just to check, double check that actually the map is there.

986
00:57:26,520 --> 00:57:28,530
We check this valid,

987
00:57:28,920 --> 00:57:31,320
there's debugging help in some sense,

988
00:57:31,320 --> 00:57:33,420
you know we should be the case that is valid.

989
00:57:34,070 --> 00:57:36,530
And then I do the same thing in the kernel pagetable,

990
00:57:37,010 --> 00:57:41,030
I look up that virtual address also in the process of kernel pagetable,

991
00:57:41,090 --> 00:57:43,940
but I call this time walk with one,

992
00:57:44,030 --> 00:57:46,910
so it actually allocates intermediate pages if necessary.

993
00:57:48,460 --> 00:57:52,450
Then once I got the pointer to the kernel pte,

994
00:57:52,630 --> 00:57:55,450
I just copy the user pte into the kernel pte.

995
00:57:56,730 --> 00:58:00,360
So probably a lot of you called mappages.

996
00:58:00,620 --> 00:58:04,910
But I just copied directly the pte into the kernel pte

997
00:58:05,150 --> 00:58:07,340
and of course I gotta disable some bits

998
00:58:07,340 --> 00:58:09,530
which we'll talk about in a second,

999
00:58:09,560 --> 00:58:12,680
but, the essence of it is,

1000
00:58:12,680 --> 00:58:15,380
I just copy the kernel page pte entries.

1001
00:58:16,730 --> 00:58:17,780
And so that means that,

1002
00:58:17,780 --> 00:58:21,920
for example the physical memory for the user program is shared,

1003
00:58:22,100 --> 00:58:25,120
between kernel space and user space.

1004
00:58:28,140 --> 00:58:30,030
Okay, does that make sense.

1005
00:58:32,940 --> 00:58:36,090
Okay, so in terms of switching up some bits

1006
00:58:36,150 --> 00:58:39,780
a little bit more than necessary,

1007
00:58:39,780 --> 00:58:41,490
but I switch off the execute bit,

1008
00:58:41,490 --> 00:58:43,410
I I switch off the write bit,

1009
00:58:43,780 --> 00:58:47,530
is copyin only needs to read never writes to it

1010
00:58:47,530 --> 00:58:48,670
or copyout does that.

1011
00:58:49,170 --> 00:58:52,260
And then, you have to switch up u bit.

1012
00:58:52,780 --> 00:58:57,580
And that is a sort of RISC-V specific thing,

1013
00:58:57,580 --> 00:58:59,530
that if you're running in kernel mode,

1014
00:58:59,880 --> 00:59:03,600
and you've been u bit is set in the pte entry,

1015
00:59:03,630 --> 00:59:06,750
the kernel can actually not access that particular page.

1016
00:59:08,140 --> 00:59:10,630
In fact you can,

1017
00:59:10,660 --> 00:59:12,970
this is almost a choice,

1018
00:59:13,000 --> 00:59:15,430
you can also actually program the RISC-V hardware,

1019
00:59:15,550 --> 00:59:18,820
that basically in kernel mode and ignores the u bit.

1020
00:59:19,720 --> 00:59:24,910
And um, but xv6 doesn't do that,

1021
00:59:25,150 --> 00:59:26,680
so you have to switch up the u bit.

1022
00:59:30,880 --> 00:59:31,990
Any questions about the u bit,

1023
00:59:31,990 --> 00:59:34,120
because the required number of you asked about it.

1024
00:59:40,510 --> 00:59:43,180
So is this done just to make sure

1025
00:59:43,180 --> 00:59:47,650
that the kernel doesn't do anything bad to user memory.

1026
00:59:48,160 --> 00:59:50,470
Yeah, so why is this the case why is this,

1027
00:59:50,470 --> 00:59:52,960
you know, so the question is like is this for debugging reasons,

1028
00:59:52,960 --> 00:59:55,180
or is there sort of isolation reasons to do so.

1029
00:59:55,860 --> 00:59:59,070
And, I think this is mostly for debugging reasons.

1030
00:59:59,450 --> 01:00:02,150
Because the kernel is in full control anyway, right,

1031
01:00:02,510 --> 01:00:04,940
kernel can change the satp register,

1032
01:00:04,940 --> 01:00:08,180
as well it can disable paging as it wants to,

1033
01:00:08,180 --> 01:00:11,840
so it's not like you know the user space is protected from the kernel,

1034
01:00:12,020 --> 01:00:15,170
I think it's mostly to basically help kernel development,

1035
01:00:15,170 --> 01:00:16,940
for example xv6 case correct,

1036
01:00:16,970 --> 01:00:21,320
unmodified xv6 should never be reference user page period.

1037
01:00:22,130 --> 01:00:25,400
Um, and um, and so that you know,

1038
01:00:26,200 --> 01:00:29,890
and basically this just helps if you happen to do

1039
01:00:29,890 --> 01:00:32,890
that by accident anyway you would get immediately page fault

1040
01:00:32,890 --> 01:00:34,630
and you know a kernel panic

1041
01:00:34,630 --> 01:00:36,310
and it will help the kernel debug,

1042
01:00:36,620 --> 01:00:38,480
developer to debug the kernel.

1043
01:00:41,420 --> 01:00:42,080
Does that makes sense.

1044
01:00:44,970 --> 01:00:45,990
Yeah, thank you.

1045
01:00:47,950 --> 01:00:49,840
I have a follow up question to that,

1046
01:00:51,010 --> 01:00:53,950
I think the part about the user bit makes sense,

1047
01:00:53,980 --> 01:00:57,040
but what about the write and execute bits.

1048
01:00:57,400 --> 01:00:58,030
Yeah.

1049
01:00:59,070 --> 01:01:01,680
So does the execute bit have to be on?

1050
01:01:07,090 --> 01:01:08,680
What does the kernel do with this page?

1051
01:01:12,060 --> 01:01:13,320
The only read from, right,

1052
01:01:13,320 --> 01:01:14,670
the only thing the only instruction

1053
01:01:14,670 --> 01:01:17,190
that basically grabs data from this pages,

1054
01:01:17,190 --> 01:01:18,690
memmove instruction and copyin.

1055
01:01:20,660 --> 01:01:23,390
So it only it does execute load instructions from it,

1056
01:01:23,960 --> 01:01:27,430
or loads values from that particular page

1057
01:01:27,850 --> 01:01:29,650
and the page should only contain data.

1058
01:01:30,180 --> 01:01:33,450
And so there's no reason that the kernel should be writing to that page

1059
01:01:33,480 --> 01:01:35,910
and so it has to be conservative,

1060
01:01:35,940 --> 01:01:37,140
I disabled the write bit.

1061
01:01:37,760 --> 01:01:40,670
And there should be confirmed never executed instruction from that page,

1062
01:01:40,910 --> 01:01:42,650
so I disable the execute bit too.

1063
01:01:43,410 --> 01:01:46,380
Again, this is mostly I think for debugging reasons,

1064
01:01:46,650 --> 01:01:49,020
not for isolation reasons.

1065
01:01:52,190 --> 01:01:53,540
OK, makes sense, thanks.

1066
01:02:00,760 --> 01:02:03,550
Okay, so now the only thing we need to do,

1067
01:02:03,550 --> 01:02:04,720
is basically there's a bunch of places

1068
01:02:04,720 --> 01:02:07,720
where this code is being where this function is being called.

1069
01:02:08,360 --> 01:02:11,900
And we need to look at these places where call

1070
01:02:11,900 --> 01:02:13,280
to understand what's going on,

1071
01:02:13,830 --> 01:02:15,150
or how to use,

1072
01:02:15,150 --> 01:02:17,130
and I think maybe one of the interesting ones

1073
01:02:17,130 --> 01:02:18,840
that you know numbers of you asked about

1074
01:02:19,330 --> 01:02:20,770
is fork.

1075
01:02:22,400 --> 01:02:24,230
And exactly we talk about both of them.

1076
01:02:27,170 --> 01:02:29,480
The first fork,

1077
01:02:34,140 --> 01:02:37,860
so here's call to fork

1078
01:02:38,310 --> 01:02:41,610
or to call to kvmmapuser in fork.

1079
01:02:42,120 --> 01:02:44,670
And it takes the n-,

1080
01:02:44,910 --> 01:02:48,630
so the main question I think the most of you ask is,

1081
01:02:48,780 --> 01:02:52,650
why does it have to be the new process kernel pagetable,

1082
01:02:53,030 --> 01:02:57,020
why does it have to copy from the new process pagetable

1083
01:02:57,020 --> 01:03:00,890
instead of from maybe the current process pagetable,

1084
01:03:00,890 --> 01:03:03,710
because it's anyway an identical going forward,

1085
01:03:03,710 --> 01:03:05,390
basically does it just replicates the,

1086
01:03:06,910 --> 01:03:08,770
user part of the pagetable

1087
01:03:08,770 --> 01:03:13,250
and so why can't we use the current pagetable for doing that.

1088
01:03:16,520 --> 01:03:18,380
Why actually turns out the case,

1089
01:03:18,380 --> 01:03:20,390
you actually have to use the new,

1090
01:03:20,950 --> 01:03:25,630
you know the child's user part of the child user pagetable.

1091
01:03:26,060 --> 01:03:27,050
Why is that the case.

1092
01:03:36,380 --> 01:03:38,780
Move you note what bug you get.

1093
01:03:44,270 --> 01:03:45,620
When you get a remap error.

1094
01:03:46,550 --> 01:03:49,280
You go, maybe not remap error maybe that too,

1095
01:03:49,370 --> 01:03:53,030
but I'm thinking of is not the remap one.

1096
01:03:56,210 --> 01:03:57,470
Number of you tried it out,

1097
01:03:57,740 --> 01:03:59,300
what was your personal experience.

1098
01:04:06,770 --> 01:04:09,530
Anybody on the call who tried this out?

1099
01:04:10,630 --> 01:04:13,960
I remember what they resulting experiences,

1100
01:04:16,430 --> 01:04:19,730
I think the resulting and I did not have the bug with,

1101
01:04:19,730 --> 01:04:22,520
I think the resulting experience is that somewhere in usertest.

1102
01:04:22,990 --> 01:04:25,990
A particular usertest and do a lot of forking and executing,

1103
01:04:26,170 --> 01:04:27,190
you're going to get a problem,

1104
01:04:27,750 --> 01:04:31,680
and you get an error,

1105
01:04:32,010 --> 01:04:36,480
in the error, the thing that goes wrong is that,

1106
01:04:36,820 --> 01:04:39,850
if you copy from the parent process,

1107
01:04:40,440 --> 01:04:43,830
if the parent process exits before the child process does,

1108
01:04:44,450 --> 01:04:50,570
then the parent process page table will be completely clean up, right,

1109
01:04:50,570 --> 01:04:51,530
as we saw before,

1110
01:04:51,950 --> 01:05:00,550
and then the child still has pointers to the parent process pagetable

1111
01:05:00,910 --> 01:05:03,100
and so basically you're gonna,

1112
01:05:03,400 --> 01:05:10,420
basically pages in this child process pagetable have been [treat]

1113
01:05:10,450 --> 01:05:11,800
and they're still used,

1114
01:05:11,800 --> 01:05:13,600
as a result in all kinds of bad behavior,

1115
01:05:13,600 --> 01:05:16,650
because the kernel wanted free the page

1116
01:05:16,650 --> 01:05:18,540
actually writes ones in it everywhere,

1117
01:05:19,080 --> 01:05:20,400
for debugging reasons

1118
01:05:20,670 --> 01:05:22,080
and so now basically you have

1119
01:05:22,080 --> 01:05:26,250
invalid you know ptes sitting in your kernel pagetable.

1120
01:05:29,090 --> 01:05:29,840
Does that make sense.

1121
01:05:37,950 --> 01:05:39,630
Okay, one more.

1122
01:05:40,700 --> 01:05:43,100
You can do to look at exec.c.

1123
01:05:43,900 --> 01:05:48,800
In my solutions, are pretty straightforward,

1124
01:05:48,800 --> 01:05:51,080
always made no modifications to exec.

1125
01:05:51,410 --> 01:05:53,660
The only modification away,

1126
01:05:53,660 --> 01:05:56,480
of course you know the first thing for, you know, part one,

1127
01:05:56,880 --> 01:05:58,170
and then here for part three,

1128
01:05:58,380 --> 01:06:04,420
which is basically mapping the new user pagetable into the kernel pagetable.

1129
01:06:04,720 --> 01:06:06,160
Exec basically does,

1130
01:06:06,160 --> 01:06:09,490
we built a new user address space

1131
01:06:09,730 --> 01:06:13,600
and you know there's one line copies of new user address space into the kernel pagetable.

1132
01:06:15,540 --> 01:06:16,170
And that's it.

1133
01:06:21,300 --> 01:06:22,110
Any questions.

1134
01:06:27,110 --> 01:06:28,640
So, hope in the meantime,

1135
01:06:28,970 --> 01:06:33,720
I've answered many of the questions that you submitted,

1136
01:06:33,750 --> 01:06:36,990
we can look and see which ones,

1137
01:06:37,050 --> 01:06:38,550
there were a couple more questions

1138
01:06:38,550 --> 01:06:39,810
that I haven't talked about yet.

1139
01:06:40,430 --> 01:06:42,290
So maybe we can look at those

1140
01:06:42,290 --> 01:06:44,600
or unless you have questions right away.

1141
01:06:46,990 --> 01:06:51,600
Um, don't we modify the growproc as well?

1142
01:06:51,780 --> 01:06:54,420
Yes, there are a couple more changes are necessary,

1143
01:06:55,970 --> 01:06:59,090
you know in sbrk or growproc.

1144
01:06:59,950 --> 01:07:05,280
There's a, I had a line right here,

1145
01:07:05,580 --> 01:07:10,350
similar style and there's presumably a similar change in.

1146
01:07:11,830 --> 01:07:13,030
Again I might be it actually,

1147
01:07:13,030 --> 01:07:14,170
usually in it of course,

1148
01:07:14,500 --> 01:07:15,910
it probably has to change.

1149
01:07:17,650 --> 01:07:23,230
Because you have to map that one page from the init code into the,

1150
01:07:23,230 --> 01:07:25,030
the kernel pagetable for you in that process.

1151
01:07:26,730 --> 01:07:28,110
Because the first process is special.

1152
01:07:35,560 --> 01:07:38,530
Okay so I'm gonna walk through some of the questions here

1153
01:07:38,530 --> 01:07:40,270
and I put them on the screen,

1154
01:07:40,270 --> 01:07:41,380
so you can helpful see them.

1155
01:07:41,800 --> 01:07:45,130
Actually I don't have to [] read them out completely.

1156
01:07:45,470 --> 01:07:47,030
I think the first question is a question

1157
01:07:47,030 --> 01:07:51,290
that came up quite a bit about the pte_u bit flag,

1158
01:07:51,380 --> 01:07:53,090
I think we've covered this,

1159
01:07:53,570 --> 01:07:55,490
we also cover the fact

1160
01:07:55,490 --> 01:07:56,480
that it's not malicious,

1161
01:07:56,480 --> 01:07:58,190
but it's mostly for debugging reasons.

1162
01:08:00,850 --> 01:08:02,470
Similar question about like,

1163
01:08:02,830 --> 01:08:05,440
well if you're supervisor mode, can you do anything,

1164
01:08:05,530 --> 01:08:07,990
because you can switch the satp,

1165
01:08:07,990 --> 01:08:09,100
you can, um.

1166
01:08:09,450 --> 01:08:10,800
And the answer is yes,

1167
01:08:10,920 --> 01:08:13,440
also possible and so it really

1168
01:08:13,440 --> 01:08:15,030
you know this u bit is not about

1169
01:08:15,540 --> 01:08:18,180
the user program being protected from the kernel,

1170
01:08:18,180 --> 01:08:21,990
was really as a flag to help the kernel developer

1171
01:08:21,990 --> 01:08:22,830
and build the kernel.

1172
01:08:24,500 --> 01:08:27,380
One other specific RISC-V question,

1173
01:08:27,500 --> 01:08:30,590
which is why are they in trapframe proc.h,

1174
01:08:30,590 --> 01:08:33,980
the register should have been a in the strange order.

1175
01:08:34,370 --> 01:08:36,920
And the reason that is,

1176
01:08:37,190 --> 01:08:39,680
I think we mentioned this a little while ago,

1177
01:08:39,680 --> 01:08:41,690
in the previous lecture,

1178
01:08:41,720 --> 01:08:46,010
basically there's something that's called the RISC-V compressed instruction set,

1179
01:08:46,280 --> 01:08:48,080
that has a set of fewer registers.

1180
01:08:48,400 --> 01:08:53,530
And, so you have to have more compact encoding of instructions.

1181
01:08:53,990 --> 01:08:57,740
And um, this strange ordering reflects the fact

1182
01:08:57,740 --> 01:09:00,830
that they're basically to there's the compressed version,

1183
01:09:01,130 --> 01:09:02,330
which is some set of registers,

1184
01:09:02,330 --> 01:09:03,980
and then sort of a compressed version,

1185
01:09:03,980 --> 01:09:05,090
which is what we're using,

1186
01:09:05,180 --> 01:09:06,740
it has a complete set of registers.

1187
01:09:07,440 --> 01:09:12,630
And the compression version, for example has s1 and s0,

1188
01:09:12,930 --> 01:09:14,130
s0 and one,

1189
01:09:14,130 --> 01:09:15,630
but not s2 to s11.

1190
01:09:17,380 --> 01:09:18,520
So that's the main reason.

1191
01:09:26,880 --> 01:09:29,100
I think I went through most of these questions,

1192
01:09:29,100 --> 01:09:30,210
but if you see a question,

1193
01:09:30,210 --> 01:09:31,920
that I should have covered and it didn't,

1194
01:09:32,130 --> 01:09:33,600
please interrupt me

1195
01:09:33,600 --> 01:09:35,670
or if you ask a question I haven't covered yet,

1196
01:09:38,050 --> 01:09:40,720
please ask me.

1197
01:09:40,720 --> 01:09:42,970
These questions are basically in order that submitted them,

1198
01:09:43,000 --> 01:09:44,020
so these were.

1199
01:09:48,270 --> 01:09:50,220
Okay, here maybe.

1200
01:09:50,960 --> 01:09:51,710
So here's a question,

1201
01:09:51,710 --> 01:09:53,720
do operating system using hierarchical pagetables

1202
01:09:53,720 --> 01:09:55,100
ever to set up the pagetable pages,

1203
01:09:55,100 --> 01:09:58,010
so that the lower parts of the hierarchy, are these part shared.

1204
01:09:58,560 --> 01:10:01,230
And, you clearly saw my solution correct,

1205
01:10:01,230 --> 01:10:04,210
I share the entries one to five eleven

1206
01:10:04,630 --> 01:10:06,070
and so this is a standard trick,

1207
01:10:06,360 --> 01:10:08,070
and lots of operating systems do that.

1208
01:10:17,830 --> 01:10:20,170
I think we talked a little bit about this particular issue

1209
01:10:20,170 --> 01:10:23,440
that is important that you switch to this main kernel pagetable,

1210
01:10:23,440 --> 01:10:25,150
because scheduler,

1211
01:10:25,420 --> 01:10:29,050
there might be no user processes to run at all anymore,

1212
01:10:29,310 --> 01:10:31,620
in the scheduler of course still needs a pagetable,

1213
01:10:31,890 --> 01:10:33,900
so it runs with the main kernel pagetable.

1214
01:10:36,590 --> 01:10:37,550
Question in the chat.

1215
01:10:37,850 --> 01:10:39,260
Yeah go ahead.

1216
01:10:39,290 --> 01:10:41,270
What is there when you pull up the chat.

1217
01:10:55,110 --> 01:10:55,860
I can read it.

1218
01:10:56,040 --> 01:10:56,880
Yeah I got it.

1219
01:10:56,880 --> 01:10:59,040
So I think you know okay so the question is,

1220
01:10:59,040 --> 01:11:00,960
note the RISC privilege specs saying

1221
01:11:00,960 --> 01:11:02,760
that part of the separation is to prevent bugs

1222
01:11:02,760 --> 01:11:06,630
that allow user program to make the kernel jump to arbitrary code in user space.

1223
01:11:07,200 --> 01:11:09,240
Yes, that's a good point,

1224
01:11:09,540 --> 01:11:13,530
yeah, so you know you can debate here,

1225
01:11:13,530 --> 01:11:16,680
one of these is an isolation property or kernel debugging property.

1226
01:11:16,970 --> 01:11:18,350
Clearly, the kernel should never

1227
01:11:18,350 --> 01:11:23,090
jump into any part of the address, the user address space directly,

1228
01:11:23,450 --> 01:11:28,400
until you know I view this as a tool

1229
01:11:28,400 --> 01:11:31,400
to help the kernel debug or catch those kinds of bugs.

1230
01:11:33,080 --> 01:11:39,050
And some reasons why xv6 we also disable or set the u bit.

1231
01:11:39,400 --> 01:11:42,460
And don't allow the kernel to refer to any pages,

1232
01:11:43,050 --> 01:11:48,630
that protects us, you know you did reference ever user address,

1233
01:11:49,070 --> 01:11:51,020
that the kernel would actually fault.

1234
01:12:02,480 --> 01:12:06,200
I think I've covered the scheduler point, too.

1235
01:12:12,520 --> 01:12:14,170
So here's a question,

1236
01:12:14,170 --> 01:12:15,820
how are pipes implemented in

1237
01:12:15,820 --> 01:12:18,280
and choose change to pagetable implemented the pgtlb lab

1238
01:12:18,280 --> 01:12:19,390
effect this implementation.

1239
01:12:19,940 --> 01:12:24,200
Um, so pipes are basically a buffering memory in the kernel.

1240
01:12:24,630 --> 01:12:27,210
And write, when you write your pipe,

1241
01:12:27,210 --> 01:12:28,560
basically calls copyin,

1242
01:12:28,880 --> 01:12:32,420
and copyin copy the bytes from user space into the pipe,

1243
01:12:32,960 --> 01:12:36,050
and in some ways you know the whole part of the pgtbl lab,

1244
01:12:36,050 --> 01:12:38,510
basically streamline that code.

1245
01:12:39,220 --> 01:12:42,430
So you don't have to do many walks,

1246
01:12:42,430 --> 01:12:45,530
when you actually you're write from user space into the pipe.

1247
01:12:49,150 --> 01:12:51,040
This is a question I think a lot of people ask,

1248
01:12:51,040 --> 01:12:52,990
you know like, why did uvmfree and freewalk,

1249
01:12:52,990 --> 01:12:54,250
originally panic at a leaf.

1250
01:12:54,760 --> 01:12:57,700
And the reason is that,

1251
01:12:57,730 --> 01:12:59,680
you know we put that in there,

1252
01:12:59,680 --> 01:13:02,200
because it broke, that was an indication

1253
01:13:02,200 --> 01:13:04,210
that an area in the xv6 would be broken,

1254
01:13:04,750 --> 01:13:07,360
that's the invariant for unmodified xv6,

1255
01:13:07,750 --> 01:13:09,070
in this particular case,

1256
01:13:10,380 --> 01:13:11,340
that is not true,

1257
01:13:11,340 --> 01:13:14,010
and so, you have to basically get rid of the panic.

1258
01:13:14,360 --> 01:13:16,700
And realized that it was not important to panic,

1259
01:13:16,700 --> 01:13:18,080
therefore, you should not get it there.

1260
01:13:21,770 --> 01:13:23,570
I think we talked quite a bit about,

1261
01:13:23,570 --> 01:13:25,040
why vm copy new's,

1262
01:13:25,040 --> 01:13:27,620
why the new vm copy is good one.

1263
01:13:34,300 --> 01:13:36,310
Okay, here's another question,

1264
01:13:36,520 --> 01:13:39,700
let's see this may be an interesting,

1265
01:13:39,970 --> 01:13:42,610
one question was asked for more design question.

1266
01:13:43,010 --> 01:13:46,040
I need help have that picture.

1267
01:13:46,590 --> 01:13:49,680
We look at the kernel address space where we limited,

1268
01:13:51,130 --> 01:13:51,790
,

1269
01:13:52,270 --> 01:13:55,870
we limited user address user programs can be bigger

1270
01:13:56,200 --> 01:13:58,690
user programs can grow through the CLINT address, no further.

1271
01:14:00,000 --> 01:14:03,750
Let's say we actually wanted to grow all the way to here.

1272
01:14:04,680 --> 01:14:05,580
How could we do that,

1273
01:14:05,640 --> 01:14:06,390
what what,

1274
01:14:06,720 --> 01:14:09,570
how should we change the design that would allow that.

1275
01:14:18,250 --> 01:14:18,970
Anybody.

1276
01:14:23,390 --> 01:14:26,240
Could we remap the stuff,

1277
01:14:26,420 --> 01:14:29,540
like CLINT PLIC and UART.

1278
01:14:31,310 --> 01:14:32,450
Yeah, where would you map that,

1279
01:14:32,570 --> 01:14:34,220
so where if you want to do,

1280
01:14:34,580 --> 01:14:36,470
free up basically that part of the address space,

1281
01:14:36,470 --> 01:14:37,640
where what could you do.

1282
01:14:38,940 --> 01:14:41,970
Map into like a custom thing,

1283
01:14:41,970 --> 01:14:43,920
before KERNBASE and after,

1284
01:14:43,950 --> 01:14:47,490
like before PHYSTOP, and after KERNBASE.

1285
01:14:48,050 --> 01:14:50,930
Yeah, or maybe it's better to after PHYSTOP,

1286
01:14:51,110 --> 01:14:52,940
here's a huge amount of free space.

1287
01:14:53,360 --> 01:14:55,130
Like address space isn't used like this,

1288
01:14:55,130 --> 01:14:57,110
from here to there is basically used for physical memory.

1289
01:14:57,620 --> 01:14:59,360
And we basically could setup mappings here,

1290
01:14:59,360 --> 01:15:01,810
for example we could put the UART here,

1291
01:15:03,720 --> 01:15:04,410
UART0,

1292
01:15:04,410 --> 01:15:06,030
we can put just about PHYSTOP page,

1293
01:15:06,030 --> 01:15:07,140
and basically set up a mapping

1294
01:15:07,140 --> 01:15:11,250
that maps in that particular physical address, right,

1295
01:15:11,250 --> 01:15:13,560
then now will free up this mapping

1296
01:15:13,800 --> 01:15:15,570
and we could use it for user space,

1297
01:15:15,720 --> 01:15:17,760
so similarly we could do that for UART0

1298
01:15:17,760 --> 01:15:20,040
or VIRTIO_disk, for PLIC and CLINT.

1299
01:15:21,420 --> 01:15:22,470
And real kernels do that.

1300
01:15:24,730 --> 01:15:25,420
Does that make sense.

1301
01:15:37,000 --> 01:15:38,890
Is it isn't that problematic though,

1302
01:15:38,890 --> 01:15:42,280
cause we would want the same same mapping

1303
01:15:42,280 --> 01:15:46,540
as the original kernel pagetable has.

1304
01:15:48,200 --> 01:15:51,950
Well, we have to do it in every every kernel pagetable,

1305
01:15:51,950 --> 01:15:52,970
we have copies,

1306
01:15:52,970 --> 01:15:55,310
we have to map it everywhere at that particular location.

1307
01:16:00,400 --> 01:16:01,210
I'm not sure that is,

1308
01:16:01,210 --> 01:16:03,040
not sure I answered your question,

1309
01:16:03,040 --> 01:16:05,030
but I don't think that's a problem.

1310
01:16:05,800 --> 01:16:09,580
I see, so you do that mapping also in the original.

1311
01:16:09,730 --> 01:16:12,070
Yeah we have to do those in the original one.

1312
01:16:15,760 --> 01:16:18,430
It does easier if the whole kernel uniformly

1313
01:16:18,430 --> 01:16:21,460
thinks about UART0 sitting at the top.

1314
01:16:28,850 --> 01:16:30,200
You know, a number of people ask

1315
01:16:30,200 --> 01:16:32,690
why do we map the kernel stacks high up.

1316
01:16:37,190 --> 01:16:38,210
What is the reason for that.

1317
01:16:38,300 --> 01:16:43,320
Like in procinit, we map these kernel stacks high up

1318
01:16:43,350 --> 01:16:44,850
and if you did the copy approach,

1319
01:16:44,850 --> 01:16:47,470
you actually have to modify procinit,

1320
01:16:47,470 --> 01:16:50,130
actually copy over that mapping.

1321
01:16:51,550 --> 01:16:54,610
And why sitting in up high virtual address space?

1322
01:16:59,940 --> 01:17:00,600
Anybody?

1323
01:17:09,300 --> 01:17:13,980
Is it specifically because the the stacks in RISC-V grow downwards,

1324
01:17:13,980 --> 01:17:15,510
so you place it high in the address space,

1325
01:17:15,510 --> 01:17:17,310
that it has space to grow downwards.

1326
01:17:17,780 --> 01:17:21,200
Yeah, how much this direction how much page does it have to grow downwards?

1327
01:17:25,650 --> 01:17:27,990
That shouldn't matter, because it's just one page, right.

1328
01:17:28,140 --> 01:17:29,100
Yeah it's only one page,

1329
01:17:29,100 --> 01:17:31,710
so what happens if you grow on one page?

1330
01:17:37,200 --> 01:17:39,780
You run into the guard page, correct.

1331
01:17:40,600 --> 01:17:42,160
And the guard page not mapped

1332
01:17:42,580 --> 01:17:44,170
and so the kernel will panic,

1333
01:17:44,540 --> 01:17:47,210
which is better than actually writing over its data structures.

1334
01:17:48,950 --> 01:17:50,240
So the reason it's high up is

1335
01:17:50,270 --> 01:17:52,370
because we put a guard page below it.

1336
01:17:52,460 --> 01:17:55,490
Is there actually any physical memory associated with that guard page.

1337
01:17:59,400 --> 01:17:59,880
No.

1338
01:18:00,180 --> 01:18:02,640
No, there's no physical memory associated with the guard page,

1339
01:18:02,730 --> 01:18:05,070
so that's one of the cool things about putting it high

1340
01:18:05,490 --> 01:18:07,140
is that we can put a guard page below it

1341
01:18:07,260 --> 01:18:09,570
that actually doesn't really consume any physical memory.

1342
01:18:12,690 --> 01:18:13,260
Okay.

1343
01:18:13,930 --> 01:18:14,620
Does that make sense.

1344
01:18:17,080 --> 01:18:22,890
Also, basically the stack staff page will be physical somewhere,

1345
01:18:22,890 --> 01:18:24,000
but the guard page won't.

1346
01:18:24,360 --> 01:18:24,960
Exactly.

1347
01:18:26,780 --> 01:18:29,060
Again, one of the cool things you can do with virtual memory.

1348
01:18:30,090 --> 01:18:32,790
Is it possible to overshoot the guard page.

1349
01:18:32,820 --> 01:18:34,230
That's a great question,

1350
01:18:34,470 --> 01:18:36,360
you know one of one for example is

1351
01:18:36,360 --> 01:18:37,800
you know, you allocated the guar-,

1352
01:18:37,800 --> 01:18:39,450
a buffer on the stack

1353
01:18:39,450 --> 01:18:44,010
that actually is [] bigger than the guard page, correct,

1354
01:18:44,010 --> 01:18:47,310
and sort of goes into the next kernel stack page.

1355
01:18:48,070 --> 01:18:49,900
And yeah you would have a serious bug.

1356
01:18:50,510 --> 01:18:52,880
Most likely you will run into that anyway,

1357
01:18:52,910 --> 01:18:55,790
because you would use the first entries that buffer,

1358
01:18:56,120 --> 01:18:58,280
and then you will get the page fault.

1359
01:19:00,640 --> 01:19:01,690
When you get lucky.

1360
01:19:02,600 --> 01:19:06,620
So this is not a bulletproof kernel debugging technique,

1361
01:19:06,830 --> 01:19:10,190
but it has proved to be extremely effective.

1362
01:19:13,070 --> 01:19:13,760
Great question.

1363
01:19:18,980 --> 01:19:19,850
Any more questions.

1364
01:19:20,500 --> 01:19:22,390
We'll go back to the list.

1365
01:19:23,600 --> 01:19:24,770
See, we have a couple more minutes

1366
01:19:24,770 --> 01:19:26,360
and then actually we have one more minute.

1367
01:19:27,160 --> 01:19:28,600
I have a question,

1368
01:19:29,170 --> 01:19:33,910
so once we have our kernel pagetable for the processes,

1369
01:19:33,970 --> 01:19:39,590
does that mean that in the trap code,

1370
01:19:39,590 --> 01:19:42,440
we don't need to switch pagetables.

1371
01:19:42,880 --> 01:19:46,960
I think the great question, a good design question,

1372
01:19:46,960 --> 01:19:48,910
and the answer is yes, you don't need it right,

1373
01:19:48,910 --> 01:19:52,820
because, the main reason that

1374
01:19:52,820 --> 01:19:54,620
the kernel or in trampoline code,

1375
01:19:54,620 --> 01:19:55,610
we go through all this trouble

1376
01:19:55,610 --> 01:19:57,410
is because we have to copy the user,

1377
01:19:57,870 --> 01:20:01,110
we have to switch from the kernel pagetable to the user pagetable,

1378
01:20:01,110 --> 01:20:05,040
the user pagetable or a pagetable doesn't have the rest of the kernel map.

1379
01:20:05,710 --> 01:20:09,460
Um, and so, downside.

1380
01:20:09,580 --> 01:20:11,770
Wait, I'm not sure that's true,

1381
01:20:11,770 --> 01:20:14,710
because the kernel needs to have the user block,

1382
01:20:14,890 --> 01:20:16,660
user flag on set.

1383
01:20:17,450 --> 01:20:19,880
Yeah, okay so there's a couple of points I wanted to make,

1384
01:20:20,240 --> 01:20:24,860
so in principle, you could simplify,

1385
01:20:24,860 --> 01:20:25,700
let me put it this way,

1386
01:20:25,880 --> 01:20:27,470
you can simplify entry and exit,

1387
01:20:27,650 --> 01:20:31,130
if you have a single pagetable that maps the user in the kernel

1388
01:20:31,130 --> 01:20:32,150
in a single pagetable,

1389
01:20:32,150 --> 01:20:33,770
because then you don't have to switch,

1390
01:20:33,980 --> 01:20:36,800
you will have to make a couple more modifications to xv6

1391
01:20:36,800 --> 01:20:37,550
to make that happen.

1392
01:20:38,260 --> 01:20:39,610
But in principle you could

1393
01:20:39,610 --> 01:20:43,600
and in fact Linux until very recently used,

1394
01:20:43,630 --> 01:20:45,310
you know this sort of strategy

1395
01:20:45,310 --> 01:20:52,030
of where the kernel and the user code are sitting in a single pagetable,

1396
01:20:52,400 --> 01:20:54,410
in relying on basically u bit,

1397
01:20:54,740 --> 01:20:56,120
you know to make sure that the,

1398
01:20:56,510 --> 01:21:02,420
the user program couldn't actually modify any kernel pages.

1399
01:21:02,880 --> 01:21:05,820
And the entry exit code in that case is slightly simpler,

1400
01:21:05,850 --> 01:21:07,620
because you don't have to switch pagetables

1401
01:21:07,620 --> 01:21:09,060
when you enter or leave the kernel.

1402
01:21:10,040 --> 01:21:12,770
One thing that happened with

1403
01:21:12,770 --> 01:21:14,090
for example the meltdown attack,

1404
01:21:14,090 --> 01:21:18,650
if you might have [] side channel attack,

1405
01:21:18,930 --> 01:21:21,930
in response to the actually side channel attack,

1406
01:21:22,200 --> 01:21:25,080
Linux switch or as another mode of running,

1407
01:21:25,080 --> 01:21:27,600
there are two modes of running, one's called kpti mode.

1408
01:21:28,190 --> 01:21:31,730
And in that mode, basically that reflects basically what xv6 does.

1409
01:21:32,080 --> 01:21:34,390
We're having a separate pagetable for the kernel

1410
01:21:34,390 --> 01:21:36,730
and a separate pagetable for user space.

1411
01:21:40,800 --> 01:21:43,380
But I still don't understand why that's that works,

1412
01:21:43,380 --> 01:21:48,810
so let's say the per user process and the kernel use the same pagetable

1413
01:21:49,080 --> 01:21:52,680
if the user memory has to have the user bit set,

1414
01:21:52,920 --> 01:21:55,980
the kernel will not be able to access that user memory right.

1415
01:21:56,010 --> 01:22:00,510
OK, the.

1416
01:22:00,510 --> 01:22:03,780
Okay, on Intel processors that is not the rule,

1417
01:22:04,290 --> 01:22:06,480
so for example, Intel processors, if u bit set,

1418
01:22:06,480 --> 01:22:08,520
the kernel could still write and read that page.

1419
01:22:08,960 --> 01:22:10,820
Oh, that's just a RISC-V thing.

1420
01:22:10,910 --> 01:22:13,130
And even on the RISC-V, you can change it,

1421
01:22:13,510 --> 01:22:15,730
there's a bit in the sstatus register,

1422
01:22:15,880 --> 01:22:18,070
you can set that to some bit

1423
01:22:18,310 --> 01:22:19,090
and if you set that

1424
01:22:19,090 --> 01:22:21,040
then basically in kernel mode,

1425
01:22:21,160 --> 01:22:22,600
the u bit is ignored.

1426
01:22:23,250 --> 01:22:27,540
Okay so you're telling me that there's just one bit in this [] processor

1427
01:22:27,540 --> 01:22:29,400
that made me stay up four hours later.

1428
01:22:29,460 --> 01:22:32,610
Yes, I'm very sorry about that,

1429
01:22:32,610 --> 01:22:34,560
I should have known that.

1430
01:22:34,560 --> 01:22:38,100
When you report,

1431
01:22:38,100 --> 01:22:40,110
it reminded me of a bug,

1432
01:22:40,110 --> 01:22:41,520
that I actually had during the summer,

1433
01:22:41,520 --> 01:22:42,510
it was exactly that bug,

1434
01:22:43,510 --> 01:22:44,920
but I forgot about it.

1435
01:22:46,910 --> 01:22:47,870
So my apology for that.

1436
01:22:48,290 --> 01:22:49,370
No, it's okay,

1437
01:22:49,370 --> 01:22:51,770
it was a, it was fun figuring it out for sure,

1438
01:22:51,770 --> 01:22:53,510
but I at some point I was just like

1439
01:22:53,510 --> 01:22:56,900
okay like either I'm crazy or something completely wrong,

1440
01:22:56,900 --> 01:22:57,950
so I'm just gonna go to sleep

1441
01:22:57,950 --> 01:22:59,210
and submit this piazza post

1442
01:22:59,210 --> 01:23:01,280
and hopefully when I wake up, someone will answer,

1443
01:23:01,580 --> 01:23:03,050
fortunately that was the case,

1444
01:23:03,050 --> 01:23:06,170
so I was able to just continue [write off] when I when I did.

1445
01:23:08,260 --> 01:23:10,990
Okay so I think we ran overtime a little bit,

1446
01:23:11,020 --> 01:23:13,660
hopefully this was helpful

1447
01:23:13,690 --> 01:23:16,660
and reaffirm things with virtual memory.

1448
01:23:17,010 --> 01:23:18,240
I think it's important to do,

1449
01:23:18,240 --> 01:23:21,480
because we're going to get three more labs involving virtual memory.

1450
01:23:22,010 --> 01:23:23,780
And my hope is that,

1451
01:23:23,780 --> 01:23:27,770
after this one you know there's going to be easier than this experience.

1452
01:23:29,420 --> 01:23:30,860
Can I ask something very quick?

1453
01:23:30,950 --> 01:23:33,890
Yeah yeah I'm I'm staying on,

1454
01:23:33,890 --> 01:23:36,020
so everybody wants to stay on and ask more questions,

1455
01:23:36,020 --> 01:23:37,160
please feel free to do,

1456
01:23:37,160 --> 01:23:39,320
so if you need to go to the next class, please go.

1457
01:23:40,620 --> 01:23:43,410
So basically, in all the labs,

1458
01:23:43,410 --> 01:23:44,520
like there's a lot of mention of,

1459
01:23:44,520 --> 01:23:47,280
like oh we, this might be useful in future labs,

1460
01:23:47,280 --> 01:23:50,430
but we never actually use any of the code that we write,

1461
01:23:50,460 --> 01:23:53,350
like what's what's the plan on that,

1462
01:23:53,350 --> 01:23:56,050
like should we just import our code from a previous lab

1463
01:23:56,050 --> 01:23:58,300
or like I don't want to because what if it's bug,

1464
01:23:58,300 --> 01:24:00,220
I don't wanna you know impact the next lab.

1465
01:24:00,660 --> 01:24:02,250
Yeah, so, one reason we don't do it,

1466
01:24:02,250 --> 01:24:04,620
you know why, why the build labs don't build on each other,

1467
01:24:04,620 --> 01:24:06,090
even though they could,

1468
01:24:06,090 --> 01:24:07,770
is to avoid basic dependencies,

1469
01:24:07,770 --> 01:24:09,360
like if you had a bug in earlier lab,

1470
01:24:09,360 --> 01:24:11,460
that was not exposed by usertests

1471
01:24:11,580 --> 01:24:12,720
or any of other tests,

1472
01:24:12,900 --> 01:24:14,820
but will be exposed to that new lab,

1473
01:24:14,820 --> 01:24:16,140
then you know be painful.

1474
01:24:16,680 --> 01:24:20,160
The reason I'm mentioning that is

1475
01:24:20,160 --> 01:24:22,410
that basically the real thing what's going on,

1476
01:24:22,410 --> 01:24:25,050
is we're going to do more stuff with pagetables.

1477
01:24:25,570 --> 01:24:29,440
For example, this lab looks at simplifying copyin,

1478
01:24:29,560 --> 01:24:33,490
later labs, we look at change to sbrk,

1479
01:24:33,550 --> 01:24:38,260
basically we're far gonna to the changes you made to the kernel for his lab.

1480
01:24:38,860 --> 01:24:41,260
But you know the fact that you've been thinking about

1481
01:24:41,260 --> 01:24:44,290
kernel pagetable user page tables so much, will help you.

1482
01:24:45,060 --> 01:24:49,290
Plus, it really helps you experience debugging these kinds of problems,

1483
01:24:49,740 --> 01:24:51,360
due to incorrect pagetables.

1484
01:24:52,800 --> 01:24:54,090
Okay I just want to make sure

1485
01:24:54,120 --> 01:24:55,650
that it's not like I'm missing out,

1486
01:24:55,650 --> 01:24:59,700
because I didn't copy over my xargs code from lab one or something.

1487
01:24:59,760 --> 01:25:02,460
Decided to purpose that the labs were not dependent on each other.

1488
01:25:04,570 --> 01:25:06,220
Okay, thanks, see you on wednesday.

1489
01:25:06,550 --> 01:25:07,090
Wednesday.

1490
01:25:12,470 --> 01:25:16,430
I had a follow up on my question about mapping,

1491
01:25:16,430 --> 01:25:20,840
mapping using the modification from the pagetable lab,

1492
01:25:20,960 --> 01:25:23,780
would it be then needed to

1493
01:25:23,870 --> 01:25:29,910
have the trampoline maps in the user pagetables.

1494
01:25:30,760 --> 01:25:34,510
Okay so I haven't really thought this through.

1495
01:25:34,810 --> 01:25:37,210
So if you've kernels, let's say the kernel exits,

1496
01:25:37,210 --> 01:25:39,460
so let's say we have join one single pagetable

1497
01:25:39,460 --> 01:25:41,260
as one here shown, correct.

1498
01:25:41,760 --> 01:25:46,200
And, we're jumping out of the kernel through userret.

1499
01:25:46,630 --> 01:25:51,280
In our goal is to we're still running in kernel mode,

1500
01:25:51,280 --> 01:25:54,220
so this page certainly accessible, correct, in by the kernel.

1501
01:25:54,220 --> 01:25:55,300
The guard page,

1502
01:25:55,800 --> 01:25:56,250
I'll show you,

1503
01:25:56,250 --> 01:25:57,720
do not the guard page, when I'm saying

1504
01:25:57,870 --> 01:25:59,190
the trampoline pages there,

1505
01:26:01,040 --> 01:26:05,180
and presumably somewhere,

1506
01:26:05,180 --> 01:26:09,110
we need to map maybe the.

1507
01:26:11,670 --> 01:26:14,670
Well, the user trapframe,

1508
01:26:14,670 --> 01:26:17,370
we don't really have access to anyway,

1509
01:26:17,430 --> 01:26:18,780
because we're running kernel mode,

1510
01:26:18,780 --> 01:26:20,700
we know where it sits in the proc structure,

1511
01:26:20,700 --> 01:26:21,930
or we can get it.

1512
01:26:22,580 --> 01:26:24,440
So I think we can just exit.

1513
01:26:25,820 --> 01:26:27,530
And when you return,

1514
01:26:28,410 --> 01:26:30,540
the user code can just run,

1515
01:26:30,570 --> 01:26:32,250
you know we of course the u bit is.

1516
01:26:36,640 --> 01:26:38,230
But u bit is always set pages

1517
01:26:38,230 --> 01:26:40,000
that actually sit in the user space,

1518
01:26:40,000 --> 01:26:40,990
so that's fine too,

1519
01:26:41,290 --> 01:26:43,420
so when we enter the kernel back in,

1520
01:26:43,450 --> 01:26:44,980
we're still with this pagetable,

1521
01:26:44,980 --> 01:26:48,280
that pagetable already has all the kernel that mapped.

1522
01:26:48,540 --> 01:26:50,970
And we can just you know copy, you know the registers

1523
01:26:50,970 --> 01:26:53,280
that we need to save into the proc structure directly.

1524
01:26:54,320 --> 01:26:58,220
Instead of having to go through separate page

1525
01:26:58,220 --> 01:26:59,300
with the proc structure in it.

1526
01:27:00,410 --> 01:27:03,380
So I believe the change will be pretty straightforward.

1527
01:27:05,070 --> 01:27:07,710
Okay I see, thank you.

1528
01:27:07,800 --> 01:27:09,960
Of course, I could be wrong.

1529
01:27:11,040 --> 01:27:14,190
Yeah I'm now gonna try it now.

