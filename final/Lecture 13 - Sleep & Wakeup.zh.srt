1
00:00:05,470 --> 00:00:08,080
好的，我要开始了，

2
00:00:08,140 --> 00:00:09,640
有人能听到我说话吗？

3
00:00:10,750 --> 00:00:11,290
是的，声音很大，而且清楚。

4
00:00:12,270 --> 00:00:14,550
好的，那么今天我的计划是，

5
00:00:14,550 --> 00:00:16,320
首先，我想花几分钟

6
00:00:16,320 --> 00:00:21,600
重新强调上周课程中关于线程切换的一些观点，

7
00:00:21,600 --> 00:00:23,760
因为它们是重要的观点，

8
00:00:23,760 --> 00:00:28,500
我会用这节课的大部分时间讨论一个称为协作的东西，

9
00:00:29,130 --> 00:00:32,850
它是 xv6 休眠唤醒机制的大的术语，

10
00:00:33,000 --> 00:00:36,030
我要特别谈一下唤醒丢失的问题。

11
00:00:36,900 --> 00:00:42,810
好的，有一点我想再提一下，

12
00:00:46,620 --> 00:00:51,570
是 xv6 当有东西调用 swtch ，

13
00:00:51,570 --> 00:00:54,570
要从一个线程切换到另一个线程，

14
00:00:54,720 --> 00:00:57,420
通常从内核线程到调度器线程，

15
00:00:57,630 --> 00:01:05,070
它总是在预先获取这个进程的锁。

16
00:01:06,050 --> 00:01:09,410
所以进程获取这个锁调用 swtch ，

17
00:01:09,710 --> 00:01:11,780
它总是切换到调度器，

18
00:01:11,780 --> 00:01:13,700
而调度器释放那个锁。

19
00:01:14,730 --> 00:01:19,620
事实上，顺序是这样的，

20
00:01:19,680 --> 00:01:22,680
或者一个进程因为某种原因想要休眠，

21
00:01:22,680 --> 00:01:24,660
它让出 CPU 等待某些东西，

22
00:01:24,840 --> 00:01:26,670
它会获取自己的锁，

23
00:01:26,700 --> 00:01:28,530
设置自己的状态，

24
00:01:30,660 --> 00:01:32,250
这里有很多状态，

25
00:01:32,250 --> 00:01:34,230
我们上周看到的，

26
00:01:34,260 --> 00:01:39,360
将状态从运行中设置为可运行，

27
00:01:39,660 --> 00:01:41,490
然后调用 swtch ，

28
00:01:41,850 --> 00:01:44,820
或者调用 sched 来调用 swtch 。

29
00:01:45,910 --> 00:01:53,320
这个 swtch 是将线程切换到调度器线程，

30
00:01:53,900 --> 00:01:56,750
与之前调用 swtch 一样，

31
00:01:56,750 --> 00:01:59,390
这个调度器线程返回。

32
00:02:00,390 --> 00:02:10,960
然后调度器线程释放这个进程的锁，

33
00:02:10,960 --> 00:02:12,910
让出CPU 。

34
00:02:16,370 --> 00:02:20,510
这样做的原因，只是重复一下，是因为，

35
00:02:22,130 --> 00:02:25,010
获取进程上的锁

36
00:02:25,010 --> 00:02:27,890
会阻止不同核心的调度器，

37
00:02:27,980 --> 00:02:33,080
在这个时间点上查看，

38
00:02:33,080 --> 00:02:37,880
然后说，这个线程是可运行的，并试图运行它，

39
00:02:38,120 --> 00:02:40,880
因为每个其他核心也许运行一个调度器循环，

40
00:02:41,330 --> 00:02:45,150
它不断地在进程表上循环，

41
00:02:45,180 --> 00:02:46,650
寻找可运行的线程，

42
00:02:46,740 --> 00:02:49,740
所以它们中的任何一个都可能看到这个线程是可运行的，

43
00:02:50,010 --> 00:02:52,260
如果我们没有获取进程锁，

44
00:02:52,530 --> 00:02:54,450
所以我们获得进程锁意味着，

45
00:02:54,450 --> 00:02:57,930
其他调度器，在查看进程状态之前，

46
00:02:58,080 --> 00:02:59,520
必须取得它的锁。

47
00:02:59,520 --> 00:03:01,290
所以我们知道这次获得之后，

48
00:03:01,350 --> 00:03:03,120
没有其他线程会查看该锁。

49
00:03:03,240 --> 00:03:05,460
我们不能在这里放弃锁，

50
00:03:05,460 --> 00:03:08,010
我们不能在调用 swtch 之前放弃锁，

51
00:03:08,010 --> 00:03:09,870
也就是说，这个线程获取锁，

52
00:03:09,870 --> 00:03:10,920
但它不能放弃它，

53
00:03:11,130 --> 00:03:12,300
因为如果我们这么做了，

54
00:03:12,300 --> 00:03:14,250
那么在我们放弃之后，

55
00:03:14,340 --> 00:03:18,750
某个其他核心的调度器可能会开始运行这个进程，

56
00:03:18,780 --> 00:03:22,530
即使那个线程当前正在这个核心上运行。

57
00:03:22,960 --> 00:03:26,860
让两个核心运行相同的线程，使用相同的堆栈，

58
00:03:26,860 --> 00:03:30,680
会造成瞬间的崩溃。

59
00:03:31,980 --> 00:03:34,860
所以，进程获取锁，

60
00:03:34,890 --> 00:03:36,450
在调用 swtch 时释放它，

61
00:03:36,450 --> 00:03:40,890
不同的线程，即调度器线程释放锁，

62
00:03:40,920 --> 00:03:45,030
在这个线程完全停止使用其自己的堆栈之后，

63
00:03:45,060 --> 00:03:51,310
这时另一个内核的调度器运行这个线程是可以的，

64
00:03:51,310 --> 00:03:53,770
因为线程现在不再运行，

65
00:03:54,070 --> 00:03:56,950
并且已经放弃了处理器。

66
00:03:58,920 --> 00:04:00,720
好的，这是很重要的一点，

67
00:04:01,050 --> 00:04:02,820
它几分钟后会出来，

68
00:04:02,820 --> 00:04:04,200
这是诸多限制之一，

69
00:04:04,200 --> 00:04:07,650
在 sleep wakeup 协同机制的设计上。

70
00:04:09,040 --> 00:04:14,720
关于 swtch 持有 p->lock ，有什么问题吗？

71
00:04:19,200 --> 00:04:20,310
是的，如果。

72
00:04:20,920 --> 00:04:21,490
是的。

73
00:04:21,580 --> 00:04:23,710
当我们有多个核心时，

74
00:04:23,770 --> 00:04:27,820
它们能看到相同的锁的唯一原因是，

75
00:04:27,820 --> 00:04:31,600
因为只有一个共享的物理内存系统，是吗？

76
00:04:31,840 --> 00:04:32,800
这是正确的。

77
00:04:33,610 --> 00:04:36,250
那么，有没有这样的实现，

78
00:04:36,250 --> 00:04:38,380
其中有奇怪的文件系统，

79
00:04:38,380 --> 00:04:40,510
可以保证这一逆境，

80
00:04:40,510 --> 00:04:41,320
这样我们就可以使用锁。

81
00:04:43,510 --> 00:04:49,130
如果你买两台计算机，那么它们不会共享内存，对吧，

82
00:04:49,190 --> 00:04:51,980
所以，一种方式是如果你购买两台计算机，

83
00:04:51,980 --> 00:04:53,390
这样它们就不会共享内存，

84
00:04:53,390 --> 00:04:55,580
我们就不会有任何这些问题了。

85
00:04:57,020 --> 00:05:00,610
只是从处理器芯片的角度来看，

86
00:05:00,610 --> 00:05:04,780
如今，单个处理器芯片上总是有多个核心，

87
00:05:04,780 --> 00:05:10,720
所以，硬件被构建为让多个核心共享相同的内存系统。

88
00:05:12,340 --> 00:05:13,960
我明白了，谢谢。

89
00:05:17,750 --> 00:05:20,940
好的，这是一点。

90
00:05:22,540 --> 00:05:23,440
还有一点，

91
00:05:23,470 --> 00:05:25,480
我还没有提到，

92
00:05:25,480 --> 00:05:28,780
与一个事实有关，

93
00:05:29,080 --> 00:05:36,490
在 xv6 中，进程在调用 swtch 时不允许持有任何其他锁。

94
00:05:36,950 --> 00:05:41,180
进程调用 swtch 时需要持有 p->lock ，

95
00:05:41,720 --> 00:05:45,320
但当它调用 swtch 时，禁止持有任何其他锁，

96
00:05:45,350 --> 00:05:47,090
所以这是另一个重要的限制，

97
00:05:47,090 --> 00:05:49,100
关于很多东西的设计，

98
00:05:49,100 --> 00:05:51,700
包括休眠是如何工作的。

99
00:05:51,730 --> 00:05:54,280
让我来描述一下这件事的理由，

100
00:05:54,280 --> 00:06:04,220
这是当你调用 swtch 时，没有其他的锁。

101
00:06:07,980 --> 00:06:12,120
这个方案说明了为什么这条规则必须强制执行，

102
00:06:12,120 --> 00:06:13,440
这是一条规则，

103
00:06:14,020 --> 00:06:17,340
如果你扩展，

104
00:06:17,340 --> 00:06:19,800
你是开发 xv6 内核的程序员，

105
00:06:19,800 --> 00:06:22,950
必须遵守这条规则以及其他一些规则。

106
00:06:24,340 --> 00:06:26,050
那么这条规则的正确性，

107
00:06:26,080 --> 00:06:30,460
假设我们有进程一，有进程一的内核线程，

108
00:06:30,610 --> 00:06:32,830
它会获取一些锁，

109
00:06:33,560 --> 00:06:35,750
这并不稀奇，只是一些锁，

110
00:06:35,750 --> 00:06:39,320
可能它正在使用磁盘或使用 uart 控制台，

111
00:06:39,320 --> 00:06:41,090
并且获取一些锁。

112
00:06:41,680 --> 00:06:43,960
假设它发生了，

113
00:06:44,470 --> 00:06:48,190
通过调用 swtch 或 yield 或 sched 或其他方法放弃了 CPU ，

114
00:06:48,190 --> 00:06:49,840
但是仍然持有这把锁。

115
00:06:50,570 --> 00:06:53,270
所以现在 p1 持有锁，

116
00:06:53,270 --> 00:06:55,010
持有锁，但是并没有运行。

117
00:06:56,310 --> 00:06:58,050
想象一下，

118
00:06:58,050 --> 00:07:00,450
我们在一台只有一个核心的机器上。

119
00:07:01,600 --> 00:07:02,950
所以只有一个核心，

120
00:07:03,130 --> 00:07:06,220
进程一调用 swtch ，转移调度器，

121
00:07:06,220 --> 00:07:09,850
调度器看到进程二的内核线程在等待运行，

122
00:07:10,090 --> 00:07:11,980
所以调度器切换进程，

123
00:07:12,010 --> 00:07:14,800
开始运行进程二，切换到进程二，

124
00:07:15,100 --> 00:07:16,870
假设进程二，不管出于什么原因，

125
00:07:16,870 --> 00:07:20,770
或许它还想使用磁盘或 uart 之类的东西，

126
00:07:20,890 --> 00:07:23,980
它对同一个锁调用 acquire ，

127
00:07:27,700 --> 00:07:30,490
所以我们第二次获取这把锁，

128
00:07:30,640 --> 00:07:32,830
这是同一把锁。

129
00:07:33,360 --> 00:07:34,980
当然，锁已经持有了，

130
00:07:34,980 --> 00:07:36,240
所以这个 acquire 拿不到它，

131
00:07:36,360 --> 00:07:37,860
这些是自旋锁，

132
00:07:37,890 --> 00:07:40,320
所以，这会导致，

133
00:07:40,350 --> 00:07:44,400
进程二内部的 acquire 会在一个循环中，

134
00:07:44,400 --> 00:07:46,740
旋转等待锁被释放。

135
00:07:47,280 --> 00:07:48,720
而且 acquire 不会返回，

136
00:07:48,750 --> 00:07:50,370
既然 acquire 不会返回，

137
00:07:50,430 --> 00:07:52,530
进程二不能，没有机会，

138
00:07:52,530 --> 00:07:56,130
即使它愿意在完成的时候让出 CPU ，

139
00:07:56,250 --> 00:07:57,420
它没有机会这样做，

140
00:07:57,420 --> 00:08:00,600
因为 acquire 在锁释放之前不会返回。

141
00:08:00,810 --> 00:08:03,270
但是唯一能释放锁的方法是，

142
00:08:03,270 --> 00:08:06,870
如果进程一恢复执行，

143
00:08:06,870 --> 00:08:12,670
并且可能稍后，它是正确的，没有严重的 bug ，

144
00:08:12,820 --> 00:08:17,170
它会打算释放这个锁，

145
00:08:17,170 --> 00:08:18,370
但这还没有发生，

146
00:08:18,910 --> 00:08:20,200
因为它调用了 swtch ，

147
00:08:20,230 --> 00:08:22,630
而进程二正在旋转，等待这个锁，

148
00:08:22,630 --> 00:08:24,820
所以这是一个死锁，

149
00:08:25,700 --> 00:08:30,980
这会导致系统冻结。

150
00:08:34,570 --> 00:08:36,580
我描述这个的上下文是，

151
00:08:36,580 --> 00:08:39,280
一台只有一个 CPU ，一个核心，

152
00:08:39,880 --> 00:08:41,620
你可以想象，

153
00:08:41,620 --> 00:08:46,980
使用多个锁将导致相同类型的死锁，

154
00:08:47,010 --> 00:08:48,750
在一台有多个核心的机器上。

155
00:08:49,980 --> 00:08:54,180
所以，在 xv6 中有一个普遍的限制，

156
00:08:54,180 --> 00:08:59,120
不能在 swtch 时持有锁。

157
00:09:01,060 --> 00:09:02,320
对于这条规则，有什么问题吗？

158
00:09:06,720 --> 00:09:07,230
聊天中有个问题，罗伯特。

159
00:09:07,950 --> 00:09:12,540
能否有一个定时器中断，切换到 p1 来解决死锁？

160
00:09:12,840 --> 00:09:15,360
好吧，那么，确实是这样，

161
00:09:15,360 --> 00:09:18,810
所以所有这些东西都运行在内核中，

162
00:09:18,810 --> 00:09:22,650
acquire release 都是内核代码，

163
00:09:22,650 --> 00:09:23,820
不是运行在用户空间中，

164
00:09:23,820 --> 00:09:27,060
但确实定时器中断可能会发生，

165
00:09:27,090 --> 00:09:33,690
而且 xv6 允许定时器中断发生，

166
00:09:33,690 --> 00:09:37,440
在运行内核代码，系统调用代码时，

167
00:09:37,500 --> 00:09:41,160
事实上，如果你查看内核陷阱代码，

168
00:09:41,160 --> 00:09:42,780
或者不管在 trap.c 里的什么，

169
00:09:42,870 --> 00:09:45,450
你会看到，如果发生定时器中断，

170
00:09:45,450 --> 00:09:47,970
当 xv6 执行内核时，

171
00:09:47,970 --> 00:09:49,200
它会调用 yield 。

172
00:09:49,480 --> 00:09:52,120
所以如果定时器中断发生，

173
00:09:52,240 --> 00:09:54,070
当我们在这里运行 acquire 时，

174
00:09:54,490 --> 00:09:58,280
那么我们就会得救，

175
00:09:58,280 --> 00:10:00,650
因为我们调用 yield ，返回到这里，

176
00:10:00,650 --> 00:10:03,470
希望 p1 恢复并最终释放锁，

177
00:10:03,500 --> 00:10:08,630
然而，由于上一节课已经解释过的原因，

178
00:10:08,690 --> 00:10:13,820
acquire 在开始等待锁之前关闭中断，

179
00:10:13,820 --> 00:10:16,070
出于其他原因，

180
00:10:16,070 --> 00:10:20,600
不能承受在我们持有锁的同时发生中断，

181
00:10:20,630 --> 00:10:22,940
因为那会导致另一种死锁。

182
00:10:23,340 --> 00:10:29,150
它是中断处理程序，需要获取锁，

183
00:10:29,510 --> 00:10:34,270
这个 acquire 可能是刚刚获得的，

184
00:10:34,450 --> 00:10:36,640
所以，如果你查看 xv6 中的 acquire 代码，

185
00:10:36,790 --> 00:10:40,240
你会看到它做的第一件事就是关闭中断，然后旋转

186
00:10:40,390 --> 00:10:44,140
你可能会想，为什么它不是旋转，然后关闭中断，

187
00:10:44,140 --> 00:10:47,380
原因是这将允许短时间内发生，

188
00:10:47,380 --> 00:10:50,710
锁被持有，但是中断没有被禁用，

189
00:10:50,950 --> 00:10:54,730
再一次，如果这个时间段发生设备中断，可能会导致死锁。

190
00:10:55,260 --> 00:10:56,130
所以，不幸的是，

191
00:10:56,130 --> 00:10:59,220
这是另一个要求我们关闭中断，

192
00:10:59,220 --> 00:11:00,750
当我们旋转等待锁时，

193
00:11:00,810 --> 00:11:03,420
防止定时器中断关闭，

194
00:11:03,420 --> 00:11:06,870
并且防止了进程二回到进程一。

195
00:11:07,970 --> 00:11:08,720
这是个好问题。

196
00:11:11,060 --> 00:11:11,870
好的，另一个问题，

197
00:11:11,870 --> 00:11:14,780
我可以重复一下如何避免死锁吗？

198
00:11:19,440 --> 00:11:22,800
在 xv6 中通过禁止这个来避免死锁，

199
00:11:24,150 --> 00:11:29,720
xv6 代码不允许获取 p->lock 以外的任何锁，

200
00:11:29,750 --> 00:11:31,040
然后调用 swtch ，

201
00:11:31,250 --> 00:11:32,570
如果你看一下 swtch 的代码，

202
00:11:32,570 --> 00:11:35,010
在 swtch 里有一些检查，

203
00:11:35,010 --> 00:11:39,240
检查除了 p->lock 之外没有锁被持有。

204
00:11:40,020 --> 00:11:42,150
所以问题是这个代码，

205
00:11:43,000 --> 00:11:45,370
如果它发生在 xv6 内核中，将是非法的。

206
00:11:45,370 --> 00:11:47,470
很容易造成死锁，

207
00:11:47,710 --> 00:11:48,520
所以这是被禁止的。

208
00:11:50,190 --> 00:11:51,240
这回答了这个问题吗？好的。

209
00:11:54,920 --> 00:11:55,850
还有其他问题吗？

210
00:12:01,580 --> 00:12:03,740
好的，记住这条规则，

211
00:12:03,740 --> 00:12:07,970
以及预先在 swtch 中持有 p->lock ，

212
00:12:08,000 --> 00:12:09,500
因为它们会再次出现，

213
00:12:09,590 --> 00:12:12,410
在我们讨论睡眠和唤醒是如何工作的时候。

214
00:12:15,160 --> 00:12:23,650
好的，新主题，协调，

215
00:12:29,370 --> 00:12:36,220
就是 sleep/wakeup 。

216
00:12:40,450 --> 00:12:41,830
我们听说过很多关于锁的事，

217
00:12:41,830 --> 00:12:44,020
锁在某些情况下是很棒的，

218
00:12:44,020 --> 00:12:47,290
不同的线程不必担心，

219
00:12:47,290 --> 00:12:49,960
而不必担心或考虑其他线程在做什么，

220
00:12:50,260 --> 00:12:51,550
我们持有锁并共享数据，

221
00:12:51,640 --> 00:12:54,220
这意味着我们不必担心这种可能性，

222
00:12:54,220 --> 00:12:58,060
其他的锁是或不是使用这些数据，

223
00:12:58,060 --> 00:13:01,240
因为锁导致一次只发生一件事，

224
00:13:01,630 --> 00:13:04,270
但是当你编写线程化代码时，

225
00:13:04,300 --> 00:13:09,940
也有某些情况，你需要等待特定的事件，

226
00:13:09,940 --> 00:13:12,430
你希望不同的线程进行交互。

227
00:13:14,530 --> 00:13:18,180
比如，假设我们有管道，

228
00:13:18,180 --> 00:13:20,040
我们有读取者和写入者，

229
00:13:20,040 --> 00:13:21,840
如果我正在读取管道，

230
00:13:22,360 --> 00:13:24,370
而当前在管道中没有要读取的内容，

231
00:13:24,550 --> 00:13:28,780
我希望能够等待任何其他进程将数据写入管道，

232
00:13:28,780 --> 00:13:32,200
我想等待管道不是空的事件。

233
00:13:32,620 --> 00:13:37,560
同样的，如果我正在读取磁盘，或正在写入磁盘，

234
00:13:41,650 --> 00:13:42,640
如果我在读取磁盘，

235
00:13:42,640 --> 00:13:45,190
然后我希望告诉磁盘控制器，

236
00:13:45,190 --> 00:13:47,620
请读取磁盘上的某个块，

237
00:13:47,740 --> 00:13:49,720
可能需要很多毫秒，

238
00:13:49,840 --> 00:13:53,290
在磁盘完成读取完成之前需要很长时间，

239
00:13:53,290 --> 00:13:55,120
特别是如果它必须寻找和旋转，

240
00:13:56,200 --> 00:14:00,280
正在读取的进程需要等待这个特定事件，

241
00:14:00,430 --> 00:14:02,590
我们希望等待磁盘读取完成。

242
00:14:05,330 --> 00:14:07,610
同样地，你可能已经注意到，

243
00:14:07,610 --> 00:14:12,410
当你编程的时候， unix 程序可以进行 wait 系统调用。

244
00:14:12,950 --> 00:14:14,570
而 wait 所做的是，

245
00:14:14,570 --> 00:14:18,500
它使调用进程等待，直到它的任意子进程退出，

246
00:14:18,530 --> 00:14:22,070
所以，这里我们故意让父进程等待，

247
00:14:22,100 --> 00:14:24,830
等待某种由另一个进程引起的事件。

248
00:14:25,490 --> 00:14:30,020
所以，这些都是进程需要等待事件的情况，

249
00:14:30,020 --> 00:14:33,260
通常是 IO 或另一进程，

250
00:14:33,290 --> 00:14:37,610
表示发生一些特殊的事情。

251
00:14:39,190 --> 00:14:41,950
协调是一种工具，

252
00:14:41,950 --> 00:14:44,830
帮助我们解决这类问题，

253
00:14:44,980 --> 00:14:47,440
或者实现这些要求，

254
00:14:47,830 --> 00:14:50,200
而且协调是很基础的，

255
00:14:50,200 --> 00:14:54,520
就像锁一样，协调是另一个基本工具，

256
00:14:54,520 --> 00:14:56,470
用于编写线程化程序，

257
00:14:56,470 --> 00:14:58,190
并且它总是出现。

258
00:14:59,520 --> 00:15:06,930
好的，那么，我们怎么让一个进程或一个线程等待这种事件，

259
00:15:07,140 --> 00:15:12,210
一种可能的非常简单的方法是，

260
00:15:12,210 --> 00:15:14,800
就是忙等待循环，

261
00:15:15,770 --> 00:15:17,030
你可以想象。

262
00:15:18,570 --> 00:15:20,430
我们马上就会把它当作一个坏想法扔掉，

263
00:15:20,430 --> 00:15:23,520
但是假设我们想要从管道中读取，

264
00:15:23,580 --> 00:15:26,130
我们在管道读取函数中编写了一个循环，

265
00:15:26,130 --> 00:15:31,510
也就是 while 管道缓冲器是空的，

266
00:15:33,050 --> 00:15:39,070
我们什么都不会做，

267
00:15:39,130 --> 00:15:42,220
现在我们在这个循环中的旋转，

268
00:15:42,340 --> 00:15:45,070
直到另一个线程或另一个核心

269
00:15:45,130 --> 00:15:47,320
写入缓冲区，使其不为空，

270
00:15:47,320 --> 00:15:48,340
然后这个循环就会结束，

271
00:15:48,340 --> 00:15:49,990
然后我们会返回数据，

272
00:15:50,020 --> 00:15:52,120
或者无论我们如何处理这些数据。

273
00:15:56,700 --> 00:15:57,990
所以，你可以想象这样编写代码，

274
00:15:57,990 --> 00:15:59,670
实际上有一点，

275
00:15:59,790 --> 00:16:02,460
可能像这样有很少的代码，

276
00:16:02,460 --> 00:16:07,920
如果你知道你等待的事情极有可能发生，

277
00:16:07,920 --> 00:16:09,750
十分之一微秒，

278
00:16:09,750 --> 00:16:12,810
这种等待可能是最好的方式，

279
00:16:13,110 --> 00:16:17,610
所以，对于一些设备硬件通常是这样完成的。

280
00:16:18,520 --> 00:16:20,530
当你要求设备硬件执行某些操作时，

281
00:16:20,530 --> 00:16:24,490
你知道它总是会在很短的时间内完成这项任务，

282
00:16:25,870 --> 00:16:29,170
只是在一个短的循环里，可能是正确的选择。

283
00:16:29,200 --> 00:16:32,200
但是，如果这可能需要很多毫秒长的时间，

284
00:16:32,200 --> 00:16:33,730
或者你不知道时间有多长，

285
00:16:33,940 --> 00:16:35,920
可能需要 10 分钟，

286
00:16:35,920 --> 00:16:40,270
在任何进程写入管道之前，

287
00:16:40,330 --> 00:16:43,030
那么我们就不想在那里旋转，浪费 CPU 时间，

288
00:16:43,060 --> 00:16:47,890
它可以用来找到更多的 π 的数字或其他有用的东西，

289
00:16:48,190 --> 00:16:51,010
相反，我们想放弃 CPU 。

290
00:16:52,060 --> 00:16:56,320
我们想要像 swtch 一样放弃 CPU ，

291
00:16:56,350 --> 00:17:00,730
但在我们关心的事件发生时重新获得 CPU ，

292
00:17:00,790 --> 00:17:04,060
这种协调是一种技术，

293
00:17:04,060 --> 00:17:10,030
放弃 CPU ，直到条件出现，我们等待的事件发生。

294
00:17:10,620 --> 00:17:14,280
再一次， sleep/wakeup ，

295
00:17:14,280 --> 00:17:16,800
有多种不同的协调原语，

296
00:17:16,800 --> 00:17:18,630
在很多年中，人们发明的。

297
00:17:20,200 --> 00:17:24,070
xv6 与许多 Unix 的风格相同，

298
00:17:24,640 --> 00:17:26,260
使用一种 sleep/wakeup 的东西。

299
00:17:27,290 --> 00:17:30,580
好的，在这样的背景下，

300
00:17:30,580 --> 00:17:36,940
我想切换到查看 xv6 的代码。

301
00:17:41,940 --> 00:17:45,810
好的，我刚分享了我的屏幕，

302
00:17:45,930 --> 00:17:49,800
如果屏幕共享起作用了，请让我知道。

303
00:17:50,460 --> 00:17:53,250
好的，我已经为这次课程做了准备，

304
00:17:53,580 --> 00:17:58,620
重写了 UART 驱动程序中的一些代码，

305
00:17:58,650 --> 00:18:04,770
这是 xv6 用来从控制台读写字符的串行驱动程序，

306
00:18:05,580 --> 00:18:07,290
所以我写了这个 uartwrite 函数，

307
00:18:07,290 --> 00:18:12,210
当像 shell 这样的程序打印提示符或产生任何其他输出时，

308
00:18:12,990 --> 00:18:14,790
会使用一个 write 系统调用，

309
00:18:14,790 --> 00:18:17,580
在我稍微修改的 xv6 版本中，

310
00:18:17,610 --> 00:18:21,270
write 系统调用以 uartwrite 的调用结束，

311
00:18:21,360 --> 00:18:22,560
在 uart 驱动中，

312
00:18:22,560 --> 00:18:29,040
将这个循环中的字符逐个写入 uart 硬件。

313
00:18:31,740 --> 00:18:35,970
这是以一种经典的设备驱动程序风格编写的。

314
00:18:37,480 --> 00:18:40,570
你会在许多设备驱动程序中看到这样的代码。

315
00:18:41,920 --> 00:18:44,620
好的，这里发生的一件事是，

316
00:18:44,620 --> 00:18:50,260
uart 硬件一次只能接受一个字符进行传输，

317
00:18:50,530 --> 00:18:52,210
所以这段代码需要查看的，

318
00:18:52,330 --> 00:18:54,700
通常你有很多想要写入的字符，

319
00:18:55,420 --> 00:18:57,400
它可以向 uart 硬件写入字符，

320
00:18:57,790 --> 00:18:59,530
它需要等待 uart 硬件

321
00:18:59,530 --> 00:19:01,780
是的，我已经把那个字符发送完了，

322
00:19:01,780 --> 00:19:02,740
我准备好接受一个新的字符了，

323
00:19:02,740 --> 00:19:04,990
然后驱动可以写入一个新的，

324
00:19:05,640 --> 00:19:07,830
下一个要输出的的新的字符，

325
00:19:08,160 --> 00:19:11,970
因为这个硬件运行起来非常慢，

326
00:19:12,000 --> 00:19:14,670
可能每秒只有一千个字符，

327
00:19:14,850 --> 00:19:18,720
我们在字符之间等待的时间可能非常长，

328
00:19:18,780 --> 00:19:21,750
以毫秒为单位，在现代计算机上是很长的时间，

329
00:19:21,750 --> 00:19:25,650
可能是十亿个，百万个机器周期，

330
00:19:26,250 --> 00:19:27,870
这可以做大量的工作，

331
00:19:27,870 --> 00:19:30,690
所以，我们不希望只是旋转，

332
00:19:30,720 --> 00:19:33,330
等待 uart 完成每个字符的发送。

333
00:19:33,710 --> 00:19:35,480
我们想要有更好的方式，

334
00:19:35,630 --> 00:19:41,400
事实上，像大多数操作系统一样， xv6 有更好的方式，

335
00:19:41,460 --> 00:19:47,910
uart 硬件在完成发送每个字符后引发中断，

336
00:19:48,120 --> 00:19:50,910
所以我们不仅仅有这个写入例程，

337
00:19:51,510 --> 00:19:53,730
我们将看到 uart 驱动程序有一个中断例程，

338
00:19:53,880 --> 00:19:56,040
我认为会调用 trap.c ，

339
00:19:56,040 --> 00:20:00,420
当 uart 硬件发出中断通知已完成时，

340
00:20:00,420 --> 00:20:03,520
中断例程检查 uart ，

341
00:20:03,520 --> 00:20:07,090
读取 uart 硬件中的一个内存映射寄存器，

342
00:20:07,480 --> 00:20:10,450
查找表示已经完成发送的标志，

343
00:20:10,510 --> 00:20:13,030
应该是 LSR_TX_IDLE 标志，

344
00:20:13,180 --> 00:20:14,740
如果设置了这个标志，

345
00:20:14,800 --> 00:20:20,230
那么中断例程在内存中设置该标志，

346
00:20:21,020 --> 00:20:22,850
然后调用这个 wakeup 调用，

347
00:20:23,000 --> 00:20:26,210
这将调用 uartwrite ，

348
00:20:26,270 --> 00:20:27,830
不管 uartwrite 是哪个线程，

349
00:20:27,830 --> 00:20:30,830
从这里的睡眠中恢复过来，

350
00:20:30,980 --> 00:20:34,040
并尝试发送新字符。

351
00:20:34,930 --> 00:20:36,070
所以流程是这样的，

352
00:20:37,020 --> 00:20:39,030
如果线程需要等待某些东西，

353
00:20:39,030 --> 00:20:42,300
在这里，我们需要等待 uart 硬件

354
00:20:42,300 --> 00:20:43,980
能够接受新字符，

355
00:20:44,010 --> 00:20:48,120
通常调用 sleep ，并等待特定条件，

356
00:20:48,270 --> 00:20:51,690
当条件满足时，

357
00:20:51,960 --> 00:20:55,620
实现该条件的代码调用 wakeup 。

358
00:20:56,210 --> 00:20:57,980
所以这些 sleep 和 wakeup 是成对的。

359
00:20:58,890 --> 00:21:01,620
sleep 会查看实现情况，

360
00:21:01,620 --> 00:21:03,240
sleep 会做很多事情，

361
00:21:03,240 --> 00:21:06,840
然后调用 swtch 来放弃 CPU 。

362
00:21:08,800 --> 00:21:10,690
需要注意的一件事是，

363
00:21:10,690 --> 00:21:14,170
wakeup 和 sleep 必须以某种方式联系在一起，

364
00:21:14,200 --> 00:21:16,180
就是我们调用 wakeup ，

365
00:21:16,210 --> 00:21:20,380
我们只想唤醒等待特定事件的线程，

366
00:21:20,380 --> 00:21:21,760
我们[意识到]已经发生，

367
00:21:21,940 --> 00:21:24,490
所以 sleep 和 wakeup 都有这个参数，

368
00:21:25,010 --> 00:21:27,590
它被称为睡眠通道，

369
00:21:27,830 --> 00:21:34,250
这里 wakeup 支持同样的值，我们传给 sleep 的值，

370
00:21:34,280 --> 00:21:36,920
sleep 和 wakeup 不会真的查看，

371
00:21:37,010 --> 00:21:38,660
不在乎这些是什么，

372
00:21:38,660 --> 00:21:41,030
它们在这里只取 64 位的值，

373
00:21:41,030 --> 00:21:42,200
它们不在乎它们是什么，

374
00:21:43,010 --> 00:21:44,870
唯一发生的事情是，

375
00:21:46,170 --> 00:21:54,600
当我们在特定的睡眠通道，等待通道上睡眠时，

376
00:21:55,500 --> 00:21:59,010
我们希望 wakeup 传递与此相同的值，

377
00:21:59,010 --> 00:22:02,940
表示它想要唤醒哪些睡眠者。

378
00:22:06,020 --> 00:22:07,760
关于这个接口，有什么问题吗？

379
00:22:08,000 --> 00:22:09,050
好的。

380
00:22:10,570 --> 00:22:12,490
所以有一个问题需要确认，

381
00:22:12,490 --> 00:22:16,530
进程不是对每个写入的字符唤醒。

382
00:22:20,550 --> 00:22:21,810
好的，让我看看，

383
00:22:21,870 --> 00:22:26,430
在这个为了演示而改写的驱动程序中，

384
00:22:27,570 --> 00:22:29,760
每个字符都有一个中断，

385
00:22:29,910 --> 00:22:33,660
所以 uartwrite 的工作方式是

386
00:22:33,690 --> 00:22:34,890
对于每个字符，

387
00:22:34,890 --> 00:22:38,310
在这个 while 中，对于缓冲区中要写入的每个字符，

388
00:22:38,520 --> 00:22:41,910
我们在这个循环中等待，

389
00:22:42,090 --> 00:22:44,850
直到 uart 准备好接受另一个字符，

390
00:22:45,060 --> 00:22:46,680
我们再写入一个字符，

391
00:22:47,340 --> 00:22:49,500
我们把这个完成标志设置为 0 ，

392
00:22:50,250 --> 00:22:55,260
返回，在 sleep 中等待，知道完成标志为 1 。

393
00:22:55,970 --> 00:23:00,080
然后，在 uart 发送完这个字符之后，

394
00:23:00,140 --> 00:23:03,800
它会中断，并且中断例程完成标志设置为 1 ，并进行唤醒，

395
00:23:03,800 --> 00:23:07,210
所以，这里有一个 sleep wakeup ，

396
00:23:07,210 --> 00:23:09,580
对于每个字符的循环的迭代中，

397
00:23:10,900 --> 00:23:16,930
uart 实际上有能力发送一些数量，

398
00:23:16,930 --> 00:23:20,280
比如 4 个或 16 个或更多字符，

399
00:23:20,280 --> 00:23:21,450
所以，更高效的驱动程序

400
00:23:21,450 --> 00:23:28,230
在这个循环的每次迭代中向 uart 传递 16 个字符，

401
00:23:28,410 --> 00:23:30,540
每 16 个字符有一个中断，

402
00:23:30,690 --> 00:23:34,560
并且更高速的设备，比如以太网驱动器，

403
00:23:35,050 --> 00:23:38,110
通常每个中断接收多得多的字节。

404
00:23:39,890 --> 00:23:41,780
好的。

405
00:23:42,320 --> 00:23:47,450
好的，这只是接口概况的展示。

406
00:23:48,140 --> 00:23:51,200
sleep 和 wakeup 很好用，

407
00:23:51,200 --> 00:23:54,530
它们好用的一个原因是，它们相对灵活，

408
00:23:54,920 --> 00:23:57,350
sleep wakeup 并不关心 uart 是什么。

409
00:23:58,880 --> 00:23:59,540
是的，你可以。

410
00:24:00,730 --> 00:24:02,950
你不必告诉 sleep 你在等什么，

411
00:24:02,950 --> 00:24:04,840
不必告诉 wakeup 发生了什么事，

412
00:24:04,930 --> 00:24:09,280
你只需要使用匹配的睡眠通道 64 位值。

413
00:24:10,790 --> 00:24:16,520
然而， sleep 接口有一个有趣的属性，

414
00:24:16,670 --> 00:24:18,770
我们要在这里传递一个锁，

415
00:24:18,830 --> 00:24:22,160
第二个参数，这个锁参数，

416
00:24:22,460 --> 00:24:29,090
为什么 sleep 需要第二个参数，背后有一个很大的故事。

417
00:24:30,480 --> 00:24:33,480
我会解释这是怎么回事，

418
00:24:33,510 --> 00:24:36,600
但更高层次的画面是，

419
00:24:36,600 --> 00:24:40,920
这似乎是不可能的，

420
00:24:41,310 --> 00:24:47,940
设计一种完全不知道你要等待的是什么的 sleep 。

421
00:24:50,420 --> 00:24:52,850
很难写出一种通用的 sleep ，

422
00:24:52,850 --> 00:24:56,090
它只是在睡眠，等待一些特定的事件，

423
00:24:56,390 --> 00:24:57,920
这很危险，

424
00:24:57,920 --> 00:25:00,110
我们稍后会看到，称为 lost wakeups ，

425
00:25:00,140 --> 00:25:02,480
每种协调机制，

426
00:25:02,480 --> 00:25:04,880
必须以某种方式处理这种问题。

427
00:25:06,360 --> 00:25:10,500
而 sleep 接口，我们必须传入一个锁，

428
00:25:10,500 --> 00:25:14,160
是一种有点丑陋的实现，

429
00:25:14,190 --> 00:25:16,800
以某种方式泄漏到接口中，

430
00:25:16,800 --> 00:25:18,000
我稍后会解释。

431
00:25:22,080 --> 00:25:22,920
好的，我会解释，

432
00:25:22,920 --> 00:25:23,460
有一个问题，

433
00:25:23,460 --> 00:25:26,220
为什么我们需要完成标志和睡眠通道？

434
00:25:26,250 --> 00:25:28,140
我会抓住这个问题，

435
00:25:28,230 --> 00:25:30,870
在五分钟或十分钟后解释这个问题。

436
00:25:32,000 --> 00:25:38,150
好的，在解释为什么 sleep 要用这个锁之前，

437
00:25:38,360 --> 00:25:41,560
我想讨论一下，

438
00:25:41,560 --> 00:25:45,850
如果我们有一个更简单的 sleep 会有什么影响，

439
00:25:46,210 --> 00:25:49,960
它不需要额外的锁参数。

440
00:25:51,130 --> 00:25:52,180
所以。

441
00:25:59,180 --> 00:26:00,080
好的，那么。

442
00:26:05,390 --> 00:26:08,360
这里的主题是 lost wakeups ，

443
00:26:12,040 --> 00:26:16,930
这是现在要描述的问题。

444
00:26:17,320 --> 00:26:21,020
所以，假设接口只是

445
00:26:21,020 --> 00:26:30,250
sleep 在任意的通道上，没有第二个参数，在没有第二自变量的该任意信道值上，

446
00:26:31,570 --> 00:26:33,250
这个不能正常工作，

447
00:26:33,250 --> 00:26:35,380
所以我把这叫做 broken_sleep 。

448
00:26:37,560 --> 00:26:39,930
你可以想象，

449
00:26:39,960 --> 00:26:41,580
如果我们不是更清楚地知道这一点，

450
00:26:41,670 --> 00:26:51,790
这样的 sleep 可以简单地将进程状态设置为这个特殊的休眠值，

451
00:26:51,790 --> 00:26:55,210
表示不想继续运行了，我在等待一个特定的事件，

452
00:26:55,660 --> 00:26:58,540
如果你看一下 sleep 的 xv6 实现，

453
00:26:58,540 --> 00:27:00,610
你会看到它还做了其他事情，

454
00:27:01,480 --> 00:27:05,050
我们需要记录这个特殊的睡眠通道值，

455
00:27:05,540 --> 00:27:10,640
这样将来的 wakeup 调用就可以意识到我们在等待的东西，

456
00:27:10,640 --> 00:27:14,290
wakeup 为我们唤醒，

457
00:27:14,290 --> 00:27:17,320
你可以想象 sleep 被打破，

458
00:27:17,350 --> 00:27:19,150
它只做了这些，

459
00:27:19,180 --> 00:27:24,300
我想你也必须获取这个进程的锁。

460
00:27:25,890 --> 00:27:27,630
当然，然后[] wakeup 。

461
00:27:34,280 --> 00:27:36,740
这是关于 wakeup 是如何工作的，

462
00:27:36,740 --> 00:27:38,240
我们想唤醒所有的线程，

463
00:27:38,240 --> 00:27:41,960
它们正在等待，使用了特定的信道值调用 sleep ，

464
00:27:42,140 --> 00:27:43,520
所以我们只是，

465
00:27:43,520 --> 00:27:48,240
for each p 和进程表，

466
00:27:51,530 --> 00:27:57,630
如果状态是睡眠状态，

467
00:28:00,790 --> 00:28:05,920
它睡眠在我们要唤醒的信道上，

468
00:28:13,990 --> 00:28:17,880
然后将状态设置为可运行的，

469
00:28:22,230 --> 00:28:25,860
实际上模块[]，这就是 wakeup 所做的。

470
00:28:29,410 --> 00:28:33,340
好吧，这个替补的[]会更好，

471
00:28:33,340 --> 00:28:35,200
如果 sleep 和 wakeup 都这么简单。

472
00:28:37,060 --> 00:28:39,490
让我来演示一下，

473
00:28:45,500 --> 00:28:46,550
让我来演示一下。

474
00:28:55,060 --> 00:28:58,030
在我回到 xv6 代码之前，

475
00:28:58,390 --> 00:28:59,740
让我来概述一下，

476
00:28:59,740 --> 00:29:03,280
你将如何在 uart 驱动程序中使用这个 sleep 和 wakeup ，

477
00:29:03,280 --> 00:29:05,350
在某种程度上，是我们已经看到的情况的重复，

478
00:29:05,350 --> 00:29:08,200
但是使用这个稍微简单一点的接口。

479
00:29:08,700 --> 00:29:10,620
你会有。

480
00:29:11,140 --> 00:29:14,170
驱动完成这个，有完成标志，

481
00:29:15,570 --> 00:29:17,970
然后 uartwrite ，

482
00:29:22,740 --> 00:29:29,160
对于缓冲区中的每个字符，

483
00:29:32,060 --> 00:29:35,450
然后检查完成标志，

484
00:29:35,480 --> 00:29:42,510
还没有完成，就去睡觉，

485
00:29:44,880 --> 00:29:50,460
然后传递一个信道，不管是 tx_chan 还是别的，

486
00:29:51,410 --> 00:29:52,430
其实并不重要。

487
00:29:52,520 --> 00:29:56,780
好的，然后我们将 c 发送给 uart ，

488
00:29:57,430 --> 00:30:01,510
并将 done 设置为 0 。

489
00:30:03,030 --> 00:30:10,240
然后，中断例程将其完成标志设置为真，

490
00:30:10,830 --> 00:30:11,490
当然还有 wakeup 。

491
00:30:13,660 --> 00:30:19,470
所以，这就是我们如何使用这种简化的 broken_sleep 。

492
00:30:19,680 --> 00:30:21,390
好的，这其实是 broken_sleep 。

493
00:30:22,400 --> 00:30:26,090
这里，缺少的是锁，

494
00:30:27,280 --> 00:30:33,020
所以，实际上，两个例程，

495
00:30:33,020 --> 00:30:36,890
写入例程和中断例程的都必须使用锁。

496
00:30:37,920 --> 00:30:40,140
其中一个原因是，

497
00:30:40,320 --> 00:30:42,600
这个完成标志，任何时候我们共享数据时，

498
00:30:42,630 --> 00:30:44,730
我们都需要对共享数据加锁，

499
00:30:45,510 --> 00:30:46,830
另一个原因是，

500
00:30:47,010 --> 00:30:48,690
实际上我没有把它放在这里，

501
00:30:48,690 --> 00:30:51,960
但是中断例程和写入例程

502
00:30:51,990 --> 00:30:55,200
都需要访问 uart 硬件本身，

503
00:30:55,260 --> 00:30:56,880
通常这是一个错误，

504
00:30:56,910 --> 00:30:58,590
除非你非常非常聪明，

505
00:30:59,370 --> 00:31:01,470
让两个线程

506
00:31:01,680 --> 00:31:06,090
同时读写内存映射硬件寄存器是错误的，

507
00:31:06,690 --> 00:31:10,080
所以，我们需要在这两个子例程中都设置一个锁，

508
00:31:10,080 --> 00:31:20,690
为了避免对完成标志竞争访问和对硬件的竞争访问。

509
00:31:21,140 --> 00:31:23,720
所以问题是我们应该把锁放在哪里。

510
00:31:25,050 --> 00:31:28,260
在中断例程中很容易做到，

511
00:31:28,260 --> 00:31:30,510
我们在开始就加锁，

512
00:31:31,290 --> 00:31:34,320
不管是什么锁，我想它叫 uart_tx_lock 或别的什么，

513
00:31:34,320 --> 00:31:35,730
然后我们在最后解锁。

514
00:31:36,880 --> 00:31:39,850
所以中断例程只是获取一个锁并释放它，

515
00:31:40,090 --> 00:31:43,780
难题是如何在 uart 例程中放置锁。

516
00:31:45,330 --> 00:31:47,860
一种可能是，

517
00:31:47,860 --> 00:31:49,810
uartwrite 可以持有的锁

518
00:31:49,810 --> 00:31:53,920
对于发送每个字符的整个序列。

519
00:31:54,450 --> 00:32:03,350
所以，我们可以在这里获取锁，在这里释放锁。

520
00:32:06,200 --> 00:32:10,370
所以，加锁和解锁在处理每个字符的开头和结尾，

521
00:32:11,150 --> 00:32:13,580
那么为什么这肯定行不通呢。

522
00:32:22,680 --> 00:32:24,180
其中一个原因是

523
00:32:24,180 --> 00:32:27,220
我们走出这个循环的唯一方法是，

524
00:32:27,220 --> 00:32:29,890
中断例程将完成标志设置为 1 ，

525
00:32:30,100 --> 00:32:34,600
但是如果我们在整个序列中持有这个锁，

526
00:32:34,750 --> 00:32:36,580
中断例程也需要锁，

527
00:32:36,670 --> 00:32:39,400
所以它会在这里旋转等待锁，

528
00:32:39,490 --> 00:32:42,130
因为我们持有锁，

529
00:32:42,250 --> 00:32:44,800
并且在设置完成之前不会释放它，

530
00:32:44,830 --> 00:32:48,820
但是完成标志只能在中断例程获得锁时才能设置，

531
00:32:49,000 --> 00:32:52,300
所以我们不能简单地持有锁

532
00:32:53,590 --> 00:32:57,010
在发送每个字符的整个序列中。

533
00:33:00,070 --> 00:33:02,230
好的，那么另一种可能是，

534
00:33:02,230 --> 00:33:04,450
这里的令人讨厌的问题是

535
00:33:04,450 --> 00:33:07,180
uartwrite 持有锁，

536
00:33:07,180 --> 00:33:10,840
在它希望中断进程发生的时候，

537
00:33:10,870 --> 00:33:12,100
就在这里，

538
00:33:12,100 --> 00:33:15,370
我们需要中断例程执行的唯一时间是，

539
00:33:15,800 --> 00:33:16,880
就在这一点上，

540
00:33:17,060 --> 00:33:18,560
其他时间持有锁也没有问题，

541
00:33:18,800 --> 00:33:22,220
所以另一种可能是在开始时获得锁，

542
00:33:22,220 --> 00:33:26,840
因为我们需要保护对这个共享变量 done 的访问，

543
00:33:26,960 --> 00:33:33,900
但在调用 sleep 前释放它，

544
00:33:34,140 --> 00:33:38,130
这给了中断例程机会执行并将完成标志设置为 1 ，

545
00:33:38,130 --> 00:33:42,180
然后我们会在 sleep 返回后重新获取它。

546
00:33:43,470 --> 00:33:45,720
然后我们回到开始，再检查一遍，

547
00:33:45,720 --> 00:33:46,560
我们又拿到了锁。

548
00:33:50,100 --> 00:33:53,490
好的，让我修改驱动程序来做这件事。

549
00:33:58,940 --> 00:34:00,350
我们会看到，好的。

550
00:34:01,740 --> 00:34:03,570
看看后果是什么。

551
00:34:06,050 --> 00:34:07,340
好的。

552
00:34:08,020 --> 00:34:10,600
所以我们所说的 sleep ，我们想要，

553
00:34:10,900 --> 00:34:12,490
你可以看到，这个代码所做的，

554
00:34:13,210 --> 00:34:16,120
在开始时获取锁，并在结束时释放它，

555
00:34:16,300 --> 00:34:19,210
并且中断例程也获取和释放。

556
00:34:19,330 --> 00:34:22,540
建议是我们要做两件事，

557
00:34:22,540 --> 00:34:29,170
一个是，我们要探索为什么我的 broken_sleep 方法，

558
00:34:29,290 --> 00:34:33,100
它只使用一个参数，

559
00:34:33,130 --> 00:34:34,180
为什么不能工作。

560
00:34:34,180 --> 00:34:37,420
所以为了正确地进行使用锁，

561
00:34:37,420 --> 00:34:38,770
我们调用 broken_sleep ，

562
00:34:38,770 --> 00:34:43,600
但是我们在这里释放锁，

563
00:34:44,570 --> 00:34:48,120
并在 sleep 返回后重新获得它。

564
00:34:53,730 --> 00:34:56,790
这个 broken_sleep 所做的就是，

565
00:34:56,790 --> 00:34:58,710
我写在白板上的东西，

566
00:34:58,710 --> 00:35:01,950
也就是，它将状态设置为睡眠，

567
00:35:01,950 --> 00:35:06,210
并将信道设置为 tx_chan 参数，

568
00:35:06,330 --> 00:35:07,740
然后调用 swtch 。

569
00:35:09,810 --> 00:35:12,340
好的，让我们看看会发生什么。

570
00:35:21,020 --> 00:35:24,170
哦，看看这个，真的成功了，

571
00:35:24,170 --> 00:35:27,530
所以 init 正在打印，它是 init 启动消息，

572
00:35:27,530 --> 00:35:29,990
它成功地写下了几个字符，

573
00:35:29,990 --> 00:35:31,400
但是似乎卡住了。

574
00:35:33,160 --> 00:35:35,140
如果我输入一个字符，

575
00:35:35,140 --> 00:35:36,850
我输入一个句号，

576
00:35:38,110 --> 00:35:44,080
通过输入句号，输出重新启动了，

577
00:35:44,680 --> 00:35:47,410
也许我运行 ls 会产生更多的输出，

578
00:35:47,410 --> 00:35:53,280
糟糕， ls 也输出几个字符，然后就停了，

579
00:35:53,280 --> 00:35:56,250
但是如果我输入一些东西，我输入 x ，

580
00:35:57,120 --> 00:36:00,670
将重新启动 ls ，它将继续运行。

581
00:36:02,060 --> 00:36:02,630
所以。

582
00:36:05,170 --> 00:36:06,460
你觉得这是怎么回事？

583
00:36:08,170 --> 00:36:09,790
所以你想提出一个理论。

584
00:36:20,960 --> 00:36:23,960
这个问题肯定与我刚刚更改的代码有关，

585
00:36:24,170 --> 00:36:25,250
那么发生了什么。

586
00:36:33,790 --> 00:36:36,340
好的，这里的问题是，

587
00:36:36,340 --> 00:36:41,350
我的新代码释放了锁，

588
00:36:41,940 --> 00:36:43,530
在这里释放了锁，

589
00:36:43,590 --> 00:36:49,010
然后在这里，中断发生了，

590
00:36:49,010 --> 00:36:50,690
因为一旦你释放锁，

591
00:36:50,960 --> 00:36:53,030
首先，会重新启用中断，

592
00:36:53,030 --> 00:36:54,740
所以，在这个 CPU 上，中断可能发生，

593
00:36:54,740 --> 00:36:55,790
这是一台多核心机器，

594
00:36:55,790 --> 00:36:59,860
所以中断可以在任何核心上进行，

595
00:37:00,160 --> 00:37:05,740
所以几乎可以肯定，在这我标记的这一点上发生的是，

596
00:37:05,740 --> 00:37:11,200
在其他核心上， UART 中断正在执行，

597
00:37:11,590 --> 00:37:13,480
它在 acquire 上，

598
00:37:14,090 --> 00:37:17,030
等待其他核心上的锁。

599
00:37:19,350 --> 00:37:20,580
所以当我释放了锁，

600
00:37:20,580 --> 00:37:23,580
另一个核心将获得锁，

601
00:37:23,970 --> 00:37:28,650
会看到 uart 已经完成了字符的发送，

602
00:37:29,340 --> 00:37:33,120
它将把这个传输完成标志设置为 1 ，

603
00:37:33,900 --> 00:37:34,650
太棒了，

604
00:37:34,860 --> 00:37:38,100
然后它使用 tx_chan 调用 wakeup 。

605
00:37:39,130 --> 00:37:41,110
这也很好，除了，

606
00:37:42,090 --> 00:37:46,770
因为写入线程仍在释放和 broken_sleep 之间执行，

607
00:37:47,130 --> 00:37:49,440
写线程还没有进入睡眠，

608
00:37:49,770 --> 00:37:53,340
所以，中断例程调用的 wakeup

609
00:37:53,370 --> 00:37:55,500
并没有唤醒任何东西，

610
00:37:55,530 --> 00:37:57,540
因为没有什么东西睡眠在那个信道上。

611
00:37:58,680 --> 00:38:05,040
然后，写入线程将继续调用这个 broken_sleep

612
00:38:05,040 --> 00:38:09,960
这将将状态设置为睡眠，并设置睡眠信道，

613
00:38:10,020 --> 00:38:13,050
但是中断已经发生，并且 wakeup 已经被调用，

614
00:38:13,080 --> 00:38:17,070
所以这个睡眠，什么都不会唤醒，

615
00:38:17,430 --> 00:38:18,540
因为唤醒已经发生了。

616
00:38:20,270 --> 00:38:22,520
这就是所谓的丢失唤醒问题。

617
00:38:24,860 --> 00:38:29,120
关于为什么或如何发生这种情况，有什么问题吗？

618
00:38:39,330 --> 00:38:42,660
是的，是不是一直都是这样，

619
00:38:42,690 --> 00:38:45,630
一旦东西丢失了，

620
00:38:45,630 --> 00:38:48,300
一旦 wakeup 丢失了，

621
00:38:48,300 --> 00:38:52,230
在下一次，所有被缓冲的东西都会被丢弃。

622
00:38:52,830 --> 00:38:57,360
好的，这完全取决于发生了事情的细节。

623
00:38:57,420 --> 00:38:59,850
在这种情况下，它只是，

624
00:39:00,620 --> 00:39:03,020
这是一种意外，

625
00:39:03,680 --> 00:39:08,150
我输入某些内容会导致输出恢复，

626
00:39:08,270 --> 00:39:12,980
我输入会导致输出得到修复，

627
00:39:13,040 --> 00:39:16,640
原因是 uart 只有一种中断，

628
00:39:16,640 --> 00:39:19,570
它调用相同的中断例程，

629
00:39:19,600 --> 00:39:24,100
无论是信号输入还是信号完成输出，

630
00:39:24,580 --> 00:39:26,740
所以，当我输入内容时，

631
00:39:26,950 --> 00:39:29,980
会调用 uart 中断例程，

632
00:39:30,190 --> 00:39:34,180
而 uart 将其作为输入已经到达的信号，

633
00:39:34,180 --> 00:39:36,880
但实际上 xv6 中的中断例程，

634
00:39:37,090 --> 00:39:43,870
注意到这段代码需要写入，

635
00:39:44,140 --> 00:39:48,010
如果 uart 准备好发送另一个字符，

636
00:39:48,010 --> 00:39:50,350
它总是调用 wakeup ，

637
00:39:50,900 --> 00:39:54,470
虽然刚才可能已经调用过 wakeup 了，

638
00:39:54,740 --> 00:39:55,760
所以这在某种程度上是偶然的，

639
00:39:55,760 --> 00:39:58,910
我输入字符导致重启，

640
00:39:59,090 --> 00:40:02,780
有时候，如果有丢失的唤醒，

641
00:40:02,810 --> 00:40:06,620
幸运地话，有时它们会以这种方式修复自己，

642
00:40:06,620 --> 00:40:08,030
而有时它们不会，

643
00:40:08,120 --> 00:40:11,930
如果 uart 具有分开的接收和发送中断例程，

644
00:40:11,930 --> 00:40:14,550
那就没有办法摆脱这件事了。

645
00:40:16,040 --> 00:40:17,030
这回答了你的问题吗？

646
00:40:17,360 --> 00:40:18,410
好的，谢谢。

647
00:40:22,940 --> 00:40:23,510
好的。

648
00:40:24,170 --> 00:40:24,980
所以。

649
00:40:25,160 --> 00:40:26,030
好的，请继续。

650
00:40:26,210 --> 00:40:30,320
tx_done 位的作用是什么？

651
00:40:31,820 --> 00:40:32,960
哦， tx_done 位，

652
00:40:33,110 --> 00:40:36,140
你是说这个标志 tx_done ，

653
00:40:36,590 --> 00:40:43,430
这是中断例程与 uartwrite 通信的一种方式。

654
00:40:44,000 --> 00:40:48,050
先前传输的字符已经完成，

655
00:40:48,260 --> 00:40:51,710
uartwrite 可以继续传输下一个字符，

656
00:40:52,010 --> 00:40:53,420
所以它是一小段，

657
00:40:54,320 --> 00:40:59,090
中断例程到 uartwrite 的一个小通信标志。

658
00:41:03,430 --> 00:41:07,090
因为如果它会睡眠，

659
00:41:07,120 --> 00:41:09,520
然后，当它醒来时，它会知道，

660
00:41:10,100 --> 00:41:13,220
可能是 uart 中断唤醒了它，

661
00:41:13,400 --> 00:41:19,270
所以可能已经设置了 tx_done 位，

662
00:41:19,300 --> 00:41:20,500
但如果我们没有它，

663
00:41:20,920 --> 00:41:22,720
所以我想我是说，

664
00:41:23,050 --> 00:41:27,790
wakeup 应该知道它是由 uart 中断引起的。

665
00:41:28,000 --> 00:41:29,800
好的，这是你提问的另一种方式，

666
00:41:29,800 --> 00:41:31,930
为什么这里会有个 while 循环，

667
00:41:33,540 --> 00:41:34,140
而不是仅仅。

668
00:41:34,140 --> 00:41:35,940
好的，我想回答了我的问题，

669
00:41:36,060 --> 00:41:37,830
我想问题的答案是，

670
00:41:37,830 --> 00:41:40,440
因为 uart 中断有两个目的。

671
00:41:40,440 --> 00:41:41,220
好的。

672
00:41:42,040 --> 00:41:43,330
是的，

673
00:41:43,330 --> 00:41:45,760
一般说来，你的问题的答案是

674
00:41:45,760 --> 00:41:49,570
更笼统的回答的一个具体例子，

675
00:41:51,520 --> 00:41:56,830
事实证明这不是实际的，

676
00:41:56,860 --> 00:42:01,300
让睡眠和唤醒保证精确，

677
00:42:01,300 --> 00:42:02,890
也就是说，如果 sleep 返回，

678
00:42:02,890 --> 00:42:06,250
那么可以肯定，无论你等待的是什么都已经发生了。

679
00:42:06,340 --> 00:42:11,170
举个例子，假设我们有两个进程，

680
00:42:11,170 --> 00:42:14,560
它们同时试图写入 uart ，

681
00:42:14,590 --> 00:42:16,210
它们都在 uartwrite ，它们可以，

682
00:42:16,210 --> 00:42:19,390
因为在一个写完一个字符之后，它会休眠，

683
00:42:19,660 --> 00:42:22,810
释放锁，

684
00:42:22,900 --> 00:42:25,330
然后另一个可以进入循环

685
00:42:25,330 --> 00:42:28,510
并等待，直到 uart 不忙。

686
00:42:29,120 --> 00:42:31,190
它们可能最终都会睡眠，

687
00:42:31,430 --> 00:42:33,470
并且当 uart 中发生中断时，

688
00:42:33,470 --> 00:42:34,730
可以再接受一个字符，

689
00:42:34,730 --> 00:42:36,590
它们都会被唤醒，

690
00:42:36,590 --> 00:42:39,620
但只有一个能真正写入这个字符。

691
00:42:40,270 --> 00:42:41,740
这个 while 循环。

692
00:42:42,180 --> 00:42:46,800
事实上，我相信在 xv6 中的每个 sleep 都会出现 while 循环，

693
00:42:46,800 --> 00:42:48,420
就是因为这个问题，

694
00:42:48,690 --> 00:42:49,800
你可能醒来了，

695
00:42:49,800 --> 00:42:52,950
但实际上有人拿走了你等待的东西，

696
00:42:52,950 --> 00:42:54,180
所以你得再睡眠一次，

697
00:42:54,360 --> 00:42:56,830
这种情况随处可见。

698
00:42:59,600 --> 00:42:59,990
好的。

699
00:42:59,990 --> 00:43:00,620
谢谢。

700
00:43:00,830 --> 00:43:01,310
好的。

701
00:43:03,000 --> 00:43:04,230
我有个问题。

702
00:43:04,900 --> 00:43:05,200
好的。

703
00:43:05,230 --> 00:43:09,700
所以看起来我们只看到一次丢失的唤醒，

704
00:43:10,000 --> 00:43:13,060
因为只要我们按下键输入一个字符，

705
00:43:13,060 --> 00:43:16,330
剩下的输出就都出来了，

706
00:43:16,510 --> 00:43:19,270
我们不是应该看到多个丢失的唤醒吗，

707
00:43:19,480 --> 00:43:20,740
为什么没有再发生一次。

708
00:43:21,220 --> 00:43:22,390
哦，它是这样的，

709
00:43:22,390 --> 00:43:23,530
让我来运行这个，

710
00:43:23,530 --> 00:43:24,430
我要运行 readme ，

711
00:43:24,460 --> 00:43:25,630
我要执行 cat README ，

712
00:43:25,630 --> 00:43:27,130
这是几千字节，

713
00:43:27,310 --> 00:43:30,850
所以，糟糕，我已经输入一些东西了。

714
00:43:31,570 --> 00:43:32,950
我想我们已经有一个字符，

715
00:43:33,040 --> 00:43:34,660
我要输入一个句号，

716
00:43:35,370 --> 00:43:38,040
我们又多了几个字符，然后它又卡住了。

717
00:43:38,680 --> 00:43:41,320
我要再输入一个句号，另外几个字符。

718
00:43:41,890 --> 00:43:45,820
每次我输入句号，会引起输入的中断，

719
00:43:46,470 --> 00:43:47,880
然后唤醒这个进程，

720
00:43:47,880 --> 00:43:50,520
它可以再写出几个字符，然后再挂起来。

721
00:43:51,060 --> 00:43:52,590
另一个丢失的唤醒。

722
00:43:53,930 --> 00:43:57,080
是的，错过了，有道理。

723
00:43:57,410 --> 00:43:58,430
是的，所以我输入句号，

724
00:43:58,430 --> 00:44:01,310
每次丢失的唤醒都会得到几个字符，

725
00:44:01,310 --> 00:44:04,130
因为丢失的唤醒需要这个巧合，

726
00:44:04,130 --> 00:44:08,090
中断已经发生了，并且等待获取锁，

727
00:44:08,690 --> 00:44:09,440
正是这样，

728
00:44:10,200 --> 00:44:12,660
我们经常会遇到这样的巧合，但并不总是。

729
00:44:15,650 --> 00:44:16,220
好的。

730
00:44:17,260 --> 00:44:21,970
好的，我们的目标是避免这个丢失唤醒的问题，

731
00:44:21,970 --> 00:44:24,910
通过消除这个窗口，

732
00:44:25,540 --> 00:44:28,330
在 release(&uart_tx_lock) 之间，

733
00:44:28,330 --> 00:44:29,740
我们必须释放它，

734
00:44:29,740 --> 00:44:32,620
因为中断需要这个锁，

735
00:44:32,620 --> 00:44:34,090
所以我们必须释放锁。

736
00:44:34,840 --> 00:44:36,610
但是，我们想要消除这个窗口

737
00:44:36,610 --> 00:44:41,830
在释放锁和进程将自己标记为睡眠中，

738
00:44:42,250 --> 00:44:45,430
所以中断的 wakeup 可以看到进程处于睡眠状态，

739
00:44:45,430 --> 00:44:48,160
真正唤醒它，而不会丢失唤醒。

740
00:44:48,970 --> 00:44:51,460
所以我们要消除这个窗口。

741
00:44:53,570 --> 00:44:57,860
要做到这一点，会使睡眠接口变得更复杂，

742
00:44:58,160 --> 00:45:05,500
所以，回到原来可以工作的 sleep ，

743
00:45:05,500 --> 00:45:07,000
我称为可工作的 sleep ，

744
00:45:07,120 --> 00:45:12,000
人们解决这个问题的方式是

745
00:45:12,000 --> 00:45:13,710
就是 sleep 需要，

746
00:45:13,710 --> 00:45:16,200
即使 sleep 并不知道你在等什么，

747
00:45:16,500 --> 00:45:19,260
它需要你在等待一些东西，

748
00:45:19,410 --> 00:45:21,870
另外，还需要一个锁，

749
00:45:21,930 --> 00:45:24,570
保护你等待的任何东西。

750
00:45:25,710 --> 00:45:27,990
所以它需要有一个睡眠状态，

751
00:45:28,910 --> 00:45:30,170
它并不知道，

752
00:45:30,590 --> 00:45:34,790
睡眠状态是 tx_done 等于 1 ，

753
00:45:35,450 --> 00:45:36,920
sleep 不知道睡眠状态是什么，

754
00:45:36,920 --> 00:45:39,860
但是它需要有一个锁，

755
00:45:39,860 --> 00:45:43,550
保护睡眠状态，也就是 uart_tx_lock ，

756
00:45:43,820 --> 00:45:47,630
当你检查状态时，是持有锁的，

757
00:45:47,630 --> 00:45:49,700
你一直持有锁直到调用 sleep ，

758
00:45:50,030 --> 00:45:52,070
然后把锁传递给 sleep 。

759
00:45:52,430 --> 00:45:55,490
在接口层面上， sleep 保证的是

760
00:45:55,490 --> 00:46:00,350
它会原子地使进程睡眠并释放锁，

761
00:46:00,650 --> 00:46:05,120
作为一种，至少是一对不可分割的行动，

762
00:46:05,120 --> 00:46:07,700
至少对于 wakeup 来说是这样的。

763
00:46:09,000 --> 00:46:12,200
所以， wakeup 不会再看到这种情况，

764
00:46:12,200 --> 00:46:15,710
你释放了锁，但是进程没有睡眠，

765
00:46:16,160 --> 00:46:20,210
sleep 释放锁，进入睡眠状态是原子的。

766
00:46:23,110 --> 00:46:26,710
这里的规则是必须有一个条件，

767
00:46:27,220 --> 00:46:29,620
必须有一个保护条件的锁，

768
00:46:29,860 --> 00:46:31,720
当你调用 sleep 时，必须持有锁，

769
00:46:31,720 --> 00:46:32,890
你必须把锁传递给 sleep ，

770
00:46:32,890 --> 00:46:39,070
另外，当你调用 wakeup 时，也必须持有锁。

771
00:46:39,640 --> 00:46:42,790
当你调用 wakeup 时，需要持有这个条件锁，

772
00:46:42,790 --> 00:46:47,080
所以这些都是程序员最好遵守的规则，

773
00:46:47,110 --> 00:46:49,660
如果想要使用 sleep 和 wakeup 编写正确的代码。

774
00:46:52,790 --> 00:46:53,330
好的。

775
00:46:55,790 --> 00:46:59,090
让我们来看看 sleep 和 wakeup ，

776
00:46:59,150 --> 00:47:00,890
试着发现它们是如何

777
00:47:01,070 --> 00:47:04,130
使用这个额外信息和这些规则，

778
00:47:04,550 --> 00:47:06,230
以避免丢失的唤醒。

779
00:47:06,380 --> 00:47:07,670
首先我想看一下 wakeup ，

780
00:47:10,130 --> 00:47:12,050
wakeup 并不令人惊讶，

781
00:47:12,530 --> 00:47:14,690
它遍历整个进程表，

782
00:47:15,050 --> 00:47:17,720
它锁定每个进程，

783
00:47:17,930 --> 00:47:20,600
还记得吗，在进程加锁之后，

784
00:47:20,600 --> 00:47:23,090
你不能查看加锁进程的状态，

785
00:47:23,390 --> 00:47:24,710
它锁定每个进程，

786
00:47:25,010 --> 00:47:26,810
如果进程处于睡眠状态，

787
00:47:27,320 --> 00:47:32,360
而且睡眠的信道跟传递给 wakeup 的信道一样，

788
00:47:32,880 --> 00:47:36,420
然后 wakeup 将进程的状态更改为可运行，

789
00:47:36,660 --> 00:47:38,520
然后释放进程的锁。

790
00:47:40,400 --> 00:47:41,780
这里没有什么令人惊讶的地方。

791
00:47:42,960 --> 00:47:46,110
我们忽略我的 broken_sleep ，

792
00:47:46,110 --> 00:47:47,760
而是查看原来的 sleep ，

793
00:47:47,970 --> 00:47:49,800
这里是 sleep 的实现，

794
00:47:52,820 --> 00:47:54,890
现在，有这个新的 lock 参数。

795
00:47:56,690 --> 00:48:01,910
所以我们知道 sleep 必须释放条件锁，

796
00:48:01,940 --> 00:48:03,260
这是它的第二个参数，

797
00:48:03,260 --> 00:48:04,190
我们知道它必须释放它，

798
00:48:04,190 --> 00:48:07,390
因为中断例程必须能够获取，

799
00:48:07,420 --> 00:48:10,540
所以我们知道在 sleep 中某个地方释放锁，

800
00:48:10,540 --> 00:48:12,850
实际上，这是那个释放锁的地方，

801
00:48:13,090 --> 00:48:14,380
当然，我们会担心，

802
00:48:14,620 --> 00:48:18,040
在我们在这一点解锁之后，

803
00:48:18,310 --> 00:48:23,320
可能会调用 wakeup 并且唤醒该进程，

804
00:48:23,350 --> 00:48:25,810
所以为了唤醒这个进程，

805
00:48:25,810 --> 00:48:27,760
不过，我们还没有标记为睡眠，

806
00:48:27,760 --> 00:48:31,600
所以我们不能让 wakeup 执行。

807
00:48:33,550 --> 00:48:34,210
糟糕。

808
00:48:34,270 --> 00:48:38,260
让 wakeup 在这个 release 之后执行，即使我们已经释放。

809
00:48:38,260 --> 00:48:40,330
所以为了避免这种情况发生，

810
00:48:40,330 --> 00:48:42,280
在释放条件锁之前，

811
00:48:42,310 --> 00:48:47,020
sleep 会获取将要睡眠的进程的锁。

812
00:48:47,470 --> 00:48:55,360
如果你还记得， wakeup 必须在持有条件锁的情况下调用，

813
00:48:55,360 --> 00:48:57,160
并且它获取，

814
00:48:57,490 --> 00:48:59,200
如果要唤醒进程，

815
00:48:59,200 --> 00:49:02,050
它首先必须等待获取进程锁。

816
00:49:04,400 --> 00:49:07,310
所以在这段时间里，

817
00:49:07,310 --> 00:49:12,890
在 uartwrite 检查状态之前，

818
00:49:13,160 --> 00:49:16,250
当我们在这里调用 sched 时，

819
00:49:16,580 --> 00:49:22,730
这个线程始终持有条件锁和 p->lock 中的一个。

820
00:49:23,910 --> 00:49:27,390
我回到 uart ，想强调这一点，

821
00:49:27,420 --> 00:49:32,210
uartwrite 在这里获取状态锁，

822
00:49:32,510 --> 00:49:36,140
并将状态锁一直持有到它调用 sleep ，

823
00:49:36,530 --> 00:49:38,180
所以它获得状态锁，

824
00:49:38,570 --> 00:49:40,190
在持有条件锁的情况下检查，

825
00:49:40,340 --> 00:49:42,680
在持有状态锁的情况下调用 sleep ，

826
00:49:42,920 --> 00:49:45,590
所以 wakeup 现在什么都做不了，

827
00:49:45,590 --> 00:49:47,960
因为它甚至不允许调用 wakeup ，

828
00:49:48,080 --> 00:49:50,690
直到调用者拥有条件锁，

829
00:49:50,690 --> 00:49:52,520
所以 wakeup 肯定不是现在执行，

830
00:49:53,540 --> 00:49:55,580
我们还持有锁，我们调用 sleep ，

831
00:49:57,110 --> 00:50:00,160
sleep 释放了条件锁，

832
00:50:00,160 --> 00:50:03,820
但首先获取进程锁。

833
00:50:06,030 --> 00:50:07,380
如果你还记得，

834
00:50:07,530 --> 00:50:08,160
糟糕，

835
00:50:10,050 --> 00:50:13,260
调用 wakeup 使用条件锁，

836
00:50:13,530 --> 00:50:15,720
在我们释放它之后。

837
00:50:16,530 --> 00:50:18,840
抱歉，在我们释放条件之后，

838
00:50:18,840 --> 00:50:19,890
wakeup 可以被调用，

839
00:50:19,920 --> 00:50:22,500
但是 wakeup 不会看到这个进程，

840
00:50:22,500 --> 00:50:24,600
直到它拥有我们持有的进程锁。

841
00:50:24,600 --> 00:50:26,580
好的，所以 wakeup 仍然没有被执行。

842
00:50:30,900 --> 00:50:34,140
获取进程锁，释放条件锁，

843
00:50:34,170 --> 00:50:35,820
在持有进程锁的同时，

844
00:50:35,820 --> 00:50:40,230
把进程标记为睡眠在这个信道上，

845
00:50:40,590 --> 00:50:43,470
然后调用 sched ，它会调用 swtch ，

846
00:50:43,500 --> 00:50:46,350
我们仍然持有进程锁，所以 wakeup 没有做任何事情，

847
00:50:46,560 --> 00:50:47,700
如果你还记得，

848
00:50:47,700 --> 00:50:52,260
从这个线程切换到调度程序线程，

849
00:50:52,500 --> 00:50:55,320
调度器例程在调用 swtch 返回后，

850
00:50:55,380 --> 00:50:59,580
释放最近运行的进程锁。

851
00:50:59,920 --> 00:51:03,250
所以，在这里，在调度器中时，

852
00:51:03,280 --> 00:51:07,360
wakeup 可以获取这个进程的 p->lock ，

853
00:51:07,600 --> 00:51:12,170
注意到它睡眠在这个信道上，

854
00:51:12,170 --> 00:51:13,670
并将它的状态设置为唤醒。

855
00:51:14,110 --> 00:51:17,710
所以我们保证了规则的效果，

856
00:51:17,710 --> 00:51:20,560
当你调用 sleep 时，必须持有条件锁，

857
00:51:20,560 --> 00:51:22,090
sleep 知道这个锁，

858
00:51:22,090 --> 00:51:25,540
并且只有在获取 p->lock 之后才释放它，

859
00:51:25,720 --> 00:51:28,680
而 wakeup 需要持有这两个锁，

860
00:51:29,010 --> 00:51:30,480
为了[考虑]这个进程，

861
00:51:30,690 --> 00:51:33,900
意味着我们不会再失去一个 wakeup ，

862
00:51:34,140 --> 00:51:36,720
所以我们解决了丢失唤醒的问题。

863
00:51:39,050 --> 00:51:40,700
我意识到有些[关联]，

864
00:51:41,330 --> 00:51:43,100
对于这里的事情，有什么问题吗？

865
00:52:02,910 --> 00:52:07,890
好的，请随时提问。

866
00:52:09,480 --> 00:52:14,100
好的，我们看到这个案例

867
00:52:14,100 --> 00:52:19,810
其中使用 sleep 和 wakeup ，并避免了丢失唤醒，

868
00:52:20,140 --> 00:52:23,140
在 xv6 中还有很多其他的版本，

869
00:52:23,200 --> 00:52:27,580
特别是，我们在等待的条件，

870
00:52:28,030 --> 00:52:30,220
是发生中断，

871
00:52:30,220 --> 00:52:34,360
表明硬件已经准备好做下一件事，

872
00:52:35,680 --> 00:52:40,260
也有一些时候内核代码调用 sleep

873
00:52:40,290 --> 00:52:42,930
为了等待其他的线程做一些事情，

874
00:52:43,110 --> 00:52:45,330
在概念上并没有什么不同，

875
00:52:45,330 --> 00:52:47,190
但可能感觉有点不同，

876
00:52:47,190 --> 00:52:49,800
例如，在管道代码中，

877
00:52:50,680 --> 00:52:52,030
如果你查看 piperead ，

878
00:52:56,210 --> 00:53:00,500
这里有一堆东西，你可以忽略，

879
00:53:00,500 --> 00:53:05,460
但是管道中的的读系统调用，最终调用 piperead ，

880
00:53:05,610 --> 00:53:08,520
这里有一把锁保护管道，

881
00:53:08,550 --> 00:53:13,490
而这就是条件锁，

882
00:53:13,880 --> 00:53:18,380
piperead 需要等待，直到有数据缓冲在管道中，

883
00:53:18,530 --> 00:53:22,940
那个条件是数据就绪，

884
00:53:22,940 --> 00:53:26,390
是 nwrite 大于 nread ，

885
00:53:26,390 --> 00:53:28,340
也就是写入的字节多于读取的字节，

886
00:53:28,670 --> 00:53:36,010
当这不是真的， piperead 在 sleep 上，等待那种条件，

887
00:53:36,100 --> 00:53:39,910
然后传入这个管道锁，

888
00:53:39,970 --> 00:53:42,790
条件锁到 sleep 中，

889
00:53:44,150 --> 00:53:45,950
为了防止丢失唤醒。

890
00:53:45,950 --> 00:53:47,750
所以你可能丢失唤醒的原因是，

891
00:53:47,750 --> 00:53:49,520
在不同的核心上，

892
00:53:50,580 --> 00:53:52,710
在文件的上面一点，

893
00:53:52,710 --> 00:53:53,640
在另一个核心上，

894
00:53:53,730 --> 00:53:58,170
可能有其他线程，刚刚调用了 pipewrite ，

895
00:53:58,530 --> 00:54:02,810
它会将字节添加到管道缓冲区，

896
00:54:02,810 --> 00:54:09,090
最后在 piperead 等待的信道上调用 wakeup ，

897
00:54:09,330 --> 00:54:14,580
我们想要避免读取者检查的风险，

898
00:54:15,180 --> 00:54:19,740
注意到这里没有字节可读，并且调用 sleep ，

899
00:54:19,770 --> 00:54:23,700
我们不想让另一个核心上的 pipewrite 在这里睡眠，

900
00:54:25,220 --> 00:54:29,300
增加字节，唤醒我们，在我们进入睡眠之前，

901
00:54:29,300 --> 00:54:30,350
会是一次丢失的唤醒。

902
00:54:31,600 --> 00:54:34,060
这把锁，

903
00:54:34,060 --> 00:54:37,030
sleep 很小心地释放它，

904
00:54:38,540 --> 00:54:41,360
防止写入者睡眠，

905
00:54:41,420 --> 00:54:43,220
在检查条件和睡眠之间，

906
00:54:43,280 --> 00:54:44,990
因为写入者也必须获得锁。

907
00:54:48,670 --> 00:54:51,700
对于你们来说，

908
00:54:53,610 --> 00:54:57,060
有人问到关于包裹 sleep 和 while 循环的问题，

909
00:54:57,300 --> 00:55:02,670
pipereed 和 pipewrite 都是在一段时间内睡眠的例子，

910
00:55:03,330 --> 00:55:09,220
比如，这是 piperead 等待数据出现的循环，

911
00:55:09,220 --> 00:55:11,320
等待管道缓冲器为非空，

912
00:55:11,770 --> 00:55:13,630
这个 sleep 被包裹在一个循环中，

913
00:55:13,720 --> 00:55:16,020
再说一次，原因是，

914
00:55:16,140 --> 00:55:20,790
完全可以有多个进程读取相同的管道，

915
00:55:21,120 --> 00:55:23,970
所以，如果写入着向管道写入一个字节，

916
00:55:24,420 --> 00:55:26,130
那里只有一个字节，

917
00:55:26,190 --> 00:55:27,660
写入者会调用 wakeup ，

918
00:55:28,660 --> 00:55:33,310
这将唤醒所有正在读取该管道的多个进程，

919
00:55:33,340 --> 00:55:35,230
但是管道中只有一个字节，

920
00:55:35,500 --> 00:55:40,420
所以其中一个进程会首先被唤醒，

921
00:55:40,480 --> 00:55:42,880
它会首先从睡眠中醒来。

922
00:55:43,000 --> 00:55:44,290
这提醒了我，

923
00:55:44,290 --> 00:55:47,170
关于 sleep ，还有一件重要的事情我忘了说，

924
00:55:49,170 --> 00:55:51,840
这是 sleep 做的最后一件事，

925
00:55:51,840 --> 00:55:52,770
我们来看一下，

926
00:55:55,980 --> 00:55:57,330
这里是，

927
00:55:57,920 --> 00:55:58,400
抱歉，

928
00:55:58,550 --> 00:55:59,780
这里是 sleep 的结尾，

929
00:55:59,900 --> 00:56:03,650
sleep 做的最后一件事是获取条件锁，

930
00:56:03,890 --> 00:56:06,710
所以，你必须在持有条件锁的情况下调用 sleep ，

931
00:56:06,920 --> 00:56:09,440
sleep 在返回之前重新获取它。

932
00:56:10,850 --> 00:56:14,510
好的，这意味着，

933
00:56:14,510 --> 00:56:15,800
如果有一群读者，

934
00:56:15,800 --> 00:56:17,750
有一个字节被写入管道，

935
00:56:17,750 --> 00:56:19,550
有一群读者被唤醒，

936
00:56:19,550 --> 00:56:22,100
其中一个会成功，

937
00:56:22,220 --> 00:56:26,510
其中一个线程成功获取这个锁，

938
00:56:27,000 --> 00:56:30,000
其他线程会等待并睡眠，旋转等待锁，

939
00:56:30,270 --> 00:56:33,600
一个幸运的睡眠进程将会返回，

940
00:56:33,600 --> 00:56:34,560
它会回到这个检查上，

941
00:56:34,560 --> 00:56:38,040
p->nwrite 比 nread 大 1 ，

942
00:56:38,160 --> 00:56:39,180
所以有数据可读，

943
00:56:39,180 --> 00:56:40,140
它会跳出循环，

944
00:56:40,140 --> 00:56:41,370
将读取一个字节，

945
00:56:41,520 --> 00:56:42,840
现在缓冲区里什么都没有了，

946
00:56:43,020 --> 00:56:45,540
释放锁，然后返回，

947
00:56:45,600 --> 00:56:48,180
现在下一个线程被唤醒，

948
00:56:48,660 --> 00:56:52,410
它的 sleep 能够重新获得状态锁，

949
00:56:52,590 --> 00:56:57,350
它的 sleep 将返回，重新检查循环条件，

950
00:56:57,350 --> 00:57:00,860
但是现在 nread 等于 nwrite ，

951
00:57:01,040 --> 00:57:04,700
所以这个线程和任何其他等待的线程将返回睡眠状态。

952
00:57:04,880 --> 00:57:07,010
这里再次强调，

953
00:57:07,010 --> 00:57:10,460
为什么几乎每次调用 sleep ，

954
00:57:10,490 --> 00:57:13,190
都必须包裹在一个重新检查条件的循环中。

955
00:57:18,360 --> 00:57:22,350
关于管道使用 sleep ，有什么问题吗？

956
00:57:33,670 --> 00:57:40,300
好的， sleep wakeup 接口规则有点复杂。

957
00:57:41,420 --> 00:57:44,870
因为你需要透露睡眠时在等待什么，

958
00:57:44,870 --> 00:57:47,000
你必须告诉锁，并遵守一些规则，

959
00:57:48,500 --> 00:57:50,360
这有时是令人讨厌的。

960
00:57:50,630 --> 00:57:53,090
另一方面， sleep 和 wakeup 是相当灵活的，

961
00:57:53,090 --> 00:57:56,450
部分原因是，它们不需要真正理解条件本身，

962
00:57:56,630 --> 00:57:59,030
只需要一个条件，一个锁，

963
00:57:59,270 --> 00:58:03,110
还有其他一些级别稍高的方案，

964
00:58:03,290 --> 00:58:05,480
还有其他的协调，比如 semaphore ，

965
00:58:05,480 --> 00:58:07,760
你从今天的阅读材料中读到的，

966
00:58:08,000 --> 00:58:11,030
其中接口不是那么复杂，

967
00:58:11,030 --> 00:58:13,700
比如信号量，你不必告诉信号量有关锁的信息，

968
00:58:15,100 --> 00:58:19,000
并且信号量的调用者不必担心丢失唤醒，

969
00:58:19,030 --> 00:58:21,010
信号量的内部实现，

970
00:58:21,160 --> 00:58:23,830
就像你们在今天的阅读材料中看到的，

971
00:58:23,830 --> 00:58:28,120
信号量的内部实现担心丢失唤醒。

972
00:58:28,120 --> 00:58:33,070
因为接口专用于这些递增递减计数器，

973
00:58:34,560 --> 00:58:38,040
处理丢失唤醒的需要不会显示到接口中。

974
00:58:38,640 --> 00:58:40,770
所以信号量稍微简单一些，

975
00:58:40,770 --> 00:58:41,910
尽管它们不那么普遍，

976
00:58:42,180 --> 00:58:45,420
如果你没有一个计数，

977
00:58:45,420 --> 00:58:46,710
你不是在等待计数，

978
00:58:46,710 --> 00:58:51,730
那么信号量不一定会对你非常有帮助。

979
00:58:52,240 --> 00:58:56,470
所以，我说 sleep 和 wakeup 会更普遍一些。

980
00:59:00,440 --> 00:59:01,970
好的。

981
00:59:02,980 --> 00:59:05,230
所以有了 sleep 和 wakeup 的经验，

982
00:59:05,290 --> 00:59:10,180
我想谈谈 xv6 面临的另一种挑战，

983
00:59:10,180 --> 00:59:11,860
它与 sleep 和 wakeup 有关，

984
00:59:12,880 --> 00:59:15,970
那就是如何关闭线程。

985
00:59:16,000 --> 00:59:18,910
每个线程系统，线程最终都需要退出，

986
00:59:18,910 --> 00:59:22,090
我们需要清理它们的状态，释放它们的堆栈，

987
00:59:22,300 --> 00:59:25,750
在 xv6 上，当一个进程退出时，

988
00:59:26,550 --> 00:59:28,320
我们需要释放它的用户内存，

989
00:59:28,320 --> 00:59:31,200
释放它的页表，释放它的 trapframe ，

990
00:59:31,410 --> 00:59:36,780
将进程表中的插槽标记为可重用。

991
00:59:37,140 --> 00:59:39,480
所以，典型的清理要求是，

992
00:59:39,480 --> 00:59:40,980
一堆东西需要释放，

993
00:59:41,310 --> 00:59:48,010
当线程退出或被杀死时。

994
00:59:48,190 --> 00:59:51,040
但是这里有两个大问题，

995
00:59:51,100 --> 00:59:53,830
与线程退出或杀死线程有关，

996
00:59:53,830 --> 00:59:55,900
其一，我们不能仅仅伸手，

997
00:59:55,900 --> 01:00:01,360
我们通常不能伸手，单方面摧毁另一个线程，

998
01:00:01,780 --> 01:00:02,920
问题是，

999
01:00:02,920 --> 01:00:06,070
其他线程可能正在另一个核心上执行，

1000
01:00:06,070 --> 01:00:07,270
并使用其堆栈，

1001
01:00:07,270 --> 01:00:11,170
可能要将寄存器保存在结构上下文中或其他什么，

1002
01:00:11,530 --> 01:00:15,100
另一个线程，如果它在内核中，可能持有锁，

1003
01:00:15,100 --> 01:00:19,450
它可能正在对内核数据结构进行一些复杂的更新，

1004
01:00:19,780 --> 01:00:22,000
如果我们只是简单地强行中止它，

1005
01:00:22,000 --> 01:00:23,650
并停止，杀死在它的[轨道]上，

1006
01:00:23,770 --> 01:00:28,840
那么它可能已经完成了对一些内核数据的部分更新，

1007
01:00:29,050 --> 01:00:31,120
但我们在它完成之前强行中止了。

1008
01:00:31,920 --> 01:00:38,560
所以，我们不能承受这些事情发生。

1009
01:00:39,820 --> 01:00:43,810
另一个问题是，即使线程调用 exit ，

1010
01:00:43,810 --> 01:00:46,180
不是决定要杀死，

1011
01:00:46,180 --> 01:00:48,280
而是自己决定要退出，

1012
01:00:49,180 --> 01:00:52,090
它具有在执行时使用的资源，

1013
01:00:52,090 --> 01:00:55,600
比如它的堆栈，和在进程表中的插槽，

1014
01:00:55,810 --> 01:00:58,150
当它还在执行时，

1015
01:00:58,650 --> 01:01:02,670
它可能不能释放还在使用的资源。

1016
01:01:03,800 --> 01:01:07,100
所以我们需要一种方法让线程，

1017
01:01:07,190 --> 01:01:08,720
对于最后几个资源，

1018
01:01:08,720 --> 01:01:10,790
释放对执行至关重要的东西，

1019
01:01:10,790 --> 01:01:12,140
即使线程需要它们，

1020
01:01:12,530 --> 01:01:14,450
即使只是执行任何代码。

1021
01:01:16,560 --> 01:01:18,690
好的，记住这两个问题，

1022
01:01:18,780 --> 01:01:23,000
xv6 实际上有两个东西，

1023
01:01:23,000 --> 01:01:26,840
关于停止线程或进程，

1024
01:01:26,930 --> 01:01:28,700
一个是退出，另一个是杀死。

1025
01:01:28,730 --> 01:01:30,350
那么，我们先来看一下退出。

1026
01:01:31,160 --> 01:01:33,560
我会查看 proc.c 中用于退出的代码，

1027
01:01:34,810 --> 01:01:38,780
这是 exit 系统调用所调用的。

1028
01:01:41,480 --> 01:01:44,150
退出最终要做的，

1029
01:01:44,150 --> 01:01:46,490
从外部接口上了解，

1030
01:01:46,490 --> 01:01:49,550
它会释放进程内存和页表，

1031
01:01:49,550 --> 01:01:51,170
关闭打开的文件，

1032
01:01:51,740 --> 01:01:54,050
我们也知道有一个 wait 调用，

1033
01:01:54,050 --> 01:01:56,030
可能是父进程创造的，

1034
01:01:56,030 --> 01:02:00,710
exit 最终也必须唤醒父进程，

1035
01:02:01,580 --> 01:02:06,260
所以我们要在 exit 代码中查看这些东西。

1036
01:02:06,710 --> 01:02:09,140
所以你可以看到一些这样的东西，

1037
01:02:09,140 --> 01:02:12,320
比如 exit 关闭打开的文件，

1038
01:02:12,320 --> 01:02:13,820
这可能非常复杂，

1039
01:02:13,820 --> 01:02:17,150
因为文件系统关闭文件，

1040
01:02:17,150 --> 01:02:19,250
涉及到比如引用计数的东西。

1041
01:02:21,070 --> 01:02:22,120
我们还没到那一步，

1042
01:02:22,120 --> 01:02:22,780
但我们会看到，

1043
01:02:22,930 --> 01:02:25,140
这需要相当多的工作。

1044
01:02:25,140 --> 01:02:29,610
但是当你调用 exit 时，进程会继续并关闭它自己的文件。

1045
01:02:30,950 --> 01:02:32,840
它也会做一些类似的事情，

1046
01:02:32,840 --> 01:02:36,710
它具有当前工作目录的记录，

1047
01:02:36,710 --> 01:02:38,540
就是当你是使用 cd 时会变的目录，

1048
01:02:38,540 --> 01:02:43,130
它需要在将该引用释放到文件系统中。

1049
01:02:43,750 --> 01:02:46,930
然后，还有其他一些讨厌的事情发生，

1050
01:02:46,960 --> 01:02:48,700
这与事实有关，

1051
01:02:48,700 --> 01:02:51,370
如果进程退出，

1052
01:02:51,370 --> 01:02:53,650
但它有自己的子进程，

1053
01:02:54,200 --> 01:02:59,120
这些子进程由初始进程继承，

1054
01:02:59,150 --> 01:03:00,290
因为事实证明，

1055
01:03:00,290 --> 01:03:01,430
我们几分钟后就会看到，

1056
01:03:01,430 --> 01:03:07,070
每个退出的进程，都有来自父进程的对应的等待，

1057
01:03:07,070 --> 01:03:11,230
这完成了退出过程中的一些步骤，

1058
01:03:11,920 --> 01:03:15,610
所以如果我退出，我的子进程需要等待，

1059
01:03:15,610 --> 01:03:17,080
我是它们的父进程，我不会等待它们，

1060
01:03:17,080 --> 01:03:17,950
因为我已经退出了。

1061
01:03:18,130 --> 01:03:20,500
所以这里有一段代码，

1062
01:03:20,500 --> 01:03:24,730
exit 重新给退出进程的子进程设置父进程，

1063
01:03:24,730 --> 01:03:26,200
这样它们的父进程就是 init ，

1064
01:03:26,200 --> 01:03:27,820
它的进程 ID 是 1 。

1065
01:03:29,970 --> 01:03:33,780
最后，一个进程唤醒它的父进程，

1066
01:03:34,170 --> 01:03:36,780
可能在睡眠并等待，

1067
01:03:39,500 --> 01:03:43,840
并将自己的状态设置为僵尸状态，

1068
01:03:44,950 --> 01:03:46,000
我们还没有，

1069
01:03:46,580 --> 01:03:47,480
但我们稍后会看到，

1070
01:03:47,480 --> 01:03:51,680
这个进程还没有完全释放所有的资源，

1071
01:03:52,040 --> 01:03:54,830
所以它没有准备好重新使用，

1072
01:03:55,190 --> 01:03:57,080
我们想要在一个位置结束，

1073
01:03:57,080 --> 01:04:01,730
这个进程所有的状态可以由 fork 重用，

1074
01:04:02,000 --> 01:04:04,670
被另一个不相关的 fork 使用。

1075
01:04:05,100 --> 01:04:06,630
但我们还没到那一步，

1076
01:04:06,750 --> 01:04:08,820
稍后我们会看到为什么，

1077
01:04:08,820 --> 01:04:10,680
我们把状态设为僵尸状态，

1078
01:04:11,760 --> 01:04:14,940
然后我们还没做完，

1079
01:04:14,940 --> 01:04:16,470
我们还没有释放这个进程，

1080
01:04:16,530 --> 01:04:19,410
我们只是跳到调度器中，

1081
01:04:20,200 --> 01:04:25,880
还没有完全释放我们的资源。

1082
01:04:27,730 --> 01:04:28,630
好的。

1083
01:04:29,440 --> 01:04:31,300
所以这里的故事还在继续，

1084
01:04:31,330 --> 01:04:34,210
这里僵尸进程不会运行，

1085
01:04:34,210 --> 01:04:36,700
调度器仅运行可运行的进程，

1086
01:04:36,700 --> 01:04:38,890
这个进程没有释放，

1087
01:04:38,920 --> 01:04:40,870
因为这是状态等于未使用，

1088
01:04:40,990 --> 01:04:42,730
但它肯定不会再运行了，

1089
01:04:42,760 --> 01:04:43,930
因为在僵尸状态中，

1090
01:04:43,930 --> 01:04:47,980
所以对于调度器，现在运行的是其他东西。

1091
01:04:49,740 --> 01:04:53,460
我们从关于退出和等待的描述中知道，

1092
01:04:53,520 --> 01:04:56,940
在 Unix 中，如果进程退出，

1093
01:04:56,940 --> 01:05:00,330
那么它的父进程调用 wait ，

1094
01:05:00,330 --> 01:05:03,480
wait 将返回信号通知父进程，

1095
01:05:03,480 --> 01:05:05,790
它的一个子进程退出了，

1096
01:05:05,970 --> 01:05:08,010
所以我们可以查看 wait 的实现。

1097
01:05:12,770 --> 01:05:16,940
wait 的实现也是一个大的循环，

1098
01:05:16,940 --> 01:05:21,230
但是当进程调用 wait 时，

1099
01:05:21,680 --> 01:05:23,990
它扫描进程表，

1100
01:05:25,560 --> 01:05:31,380
查找父进程为当前进程的进程，

1101
01:05:34,400 --> 01:05:36,260
特别是查找这样的进程，

1102
01:05:36,260 --> 01:05:39,350
它的父进程是当前进程并且处于僵尸状态，

1103
01:05:39,380 --> 01:05:42,110
那就是它们走到这一步，

1104
01:05:42,110 --> 01:05:45,230
在退出或即将完成退出。

1105
01:05:47,280 --> 01:05:49,980
所以现在我们发现这调用 wait 系统调用，

1106
01:05:49,980 --> 01:05:52,500
找到已退出的子进程。

1107
01:05:54,930 --> 01:06:02,190
我不知道你是否记得 exit 可以返回这个 32 位的退出状态，

1108
01:06:02,190 --> 01:06:04,710
让父进程，剩下的代码可以收集这些信息，

1109
01:06:05,040 --> 01:06:08,970
然后是父进程调用 freproc ，

1110
01:06:09,300 --> 01:06:13,290
完成了最后一部，释放进程的资源。

1111
01:06:13,380 --> 01:06:14,730
所以我们来看一下 freproc ，

1112
01:06:15,670 --> 01:06:19,030
这是最后一次关闭，这是很难处理的，

1113
01:06:19,030 --> 01:06:23,500
如果退出进程在执行时被释放，

1114
01:06:24,520 --> 01:06:28,720
它冻结 trapframe ，冻结用户页表，

1115
01:06:29,260 --> 01:06:32,770
如果我们释放内核堆栈，

1116
01:06:32,800 --> 01:06:37,540
现有进程的内核堆栈也将在这里释放，

1117
01:06:37,810 --> 01:06:44,340
但是由于堆栈保护页，

1118
01:06:44,340 --> 01:06:49,680
我们没有释放内核堆栈，无论何时释放内核堆栈，我们都不会免费，

1119
01:06:50,280 --> 01:06:53,940
但是这些东西在退出时都是一种潜在的痛苦，

1120
01:06:54,520 --> 01:06:57,970
当正在运行的退出进程由父进程释放时。

1121
01:07:00,610 --> 01:07:01,810
这里需要注意的一件事是，

1122
01:07:01,810 --> 01:07:06,750
wait 不仅是为了父进程方便，

1123
01:07:06,750 --> 01:07:09,150
它们想知道子进程什么时候退出，

1124
01:07:09,390 --> 01:07:12,780
wait 实际上是退出进程的关键部分，

1125
01:07:12,780 --> 01:07:16,710
在 Unix 中，这是一个需要，

1126
01:07:16,920 --> 01:07:21,240
wait 对应于每个退出的进程，

1127
01:07:21,240 --> 01:07:25,800
这就是为什么当进程退出其子进程时，

1128
01:07:26,040 --> 01:07:28,050
某种程度上给了 init ，

1129
01:07:28,630 --> 01:07:31,120
它们成为了 init 的子进程，

1130
01:07:31,240 --> 01:07:35,260
当 init 在循环中调用 wait 时，

1131
01:07:35,500 --> 01:07:37,780
因为每个进程都要等待，

1132
01:07:37,780 --> 01:07:42,880
让父进程可以调用 freproc 并完成资源释放，

1133
01:07:42,880 --> 01:07:44,230
然后当它完全完成的时候，

1134
01:07:44,860 --> 01:07:50,410
如果父进程完成释放所有退出进程资源，

1135
01:07:51,040 --> 01:07:53,470
将子进程状态设置为未使用，

1136
01:07:53,470 --> 01:07:59,890
现在 fork 或将来调用 fork 可以重用该进程槽。

1137
01:08:03,760 --> 01:08:04,660
有什么问题吗？

1138
01:08:07,890 --> 01:08:10,770
哦，我有个关于 sleep 的问题，

1139
01:08:10,920 --> 01:08:16,320
所以在 sleep 中，我们。

1140
01:08:17,500 --> 01:08:19,720
是的，当我们，

1141
01:08:20,860 --> 01:08:23,390
哦，抱歉，不是 sleep ，而是 exit 。

1142
01:08:23,390 --> 01:08:24,500
我想说的是 exit ，是的。

1143
01:08:28,340 --> 01:08:30,560
是的，为什么我们，

1144
01:08:31,450 --> 01:08:37,450
为什么我们要在重新分配父进程前[抓住]最初的父进程，

1145
01:08:37,480 --> 01:08:38,740
这是必须的吗。

1146
01:08:42,000 --> 01:08:47,900
这是[]代码，处理一种可能性，

1147
01:08:47,960 --> 01:08:54,530
进程和父进程同时退出的情况。

1148
01:08:55,670 --> 01:08:57,680
还有一些，

1149
01:08:58,800 --> 01:09:03,510
尽管最初的，不关心进程退出，

1150
01:09:03,810 --> 01:09:05,970
它的父进程等待它，一切都很好，

1151
01:09:06,780 --> 01:09:09,390
但它可能是进程退出的父进程，

1152
01:09:09,480 --> 01:09:11,460
并且它的父进程同时退出，

1153
01:09:11,460 --> 01:09:16,230
所以当我们试图唤醒父进程，告诉它我们已经退出时，

1154
01:09:16,260 --> 01:09:17,940
那个父进程已经退出了。

1155
01:09:18,460 --> 01:09:21,700
这里有很多这样的代码，

1156
01:09:22,420 --> 01:09:25,800
我觉得我一年前是明白的，

1157
01:09:25,800 --> 01:09:28,080
但现在不再明白了，

1158
01:09:28,110 --> 01:09:33,420
是关于处理这种罕见的父进程和子进程同时退出的情况。

1159
01:09:33,960 --> 01:09:36,240
如果不是因为这个，

1160
01:09:36,330 --> 01:09:37,980
那么这一切都会非常简单，

1161
01:09:37,980 --> 01:09:39,780
进程有一个父进程，

1162
01:09:39,930 --> 01:09:43,110
它只需要在这里唤醒它的父进程。

1163
01:09:45,660 --> 01:09:48,380
而且，我们不会，

1164
01:09:48,470 --> 01:09:51,170
它是对于父进程和子进程同时退出的。

1165
01:09:51,780 --> 01:09:54,420
子进程可以唤醒父进程。

1166
01:09:54,450 --> 01:09:56,010
好的，我明白了，谢谢。

1167
01:09:56,040 --> 01:09:58,170
抱歉，我不能解释更多了。

1168
01:09:59,510 --> 01:10:00,830
我有一个简短的问题，

1169
01:10:01,370 --> 01:10:07,550
为什么我们要在唤醒父进程之后将进程状态设置为僵尸状态，

1170
01:10:07,700 --> 01:10:09,620
我们想在此之前这么做。

1171
01:10:09,860 --> 01:10:15,450
哦，是的，是因为我们获得了，

1172
01:10:16,170 --> 01:10:19,710
现有进程获取了自己进程锁，

1173
01:10:19,980 --> 01:10:22,230
父进程不能看到这个进程。

1174
01:10:22,760 --> 01:10:25,850
我们在这里获得了自己的锁，

1175
01:10:25,850 --> 01:10:27,020
然后我们调用 sched ，

1176
01:10:27,020 --> 01:10:34,160
父进程需要等待子进程的锁，也就是 p->lock ，

1177
01:10:34,550 --> 01:10:37,070
这意味着在这个获取

1178
01:10:37,130 --> 01:10:43,280
和我们调用 sched 之后，调度器线程释放 p->lock 之间，

1179
01:10:43,340 --> 01:10:48,280
在这块代码中，父进程不能看到这个进程。

1180
01:10:48,310 --> 01:10:48,790
好的。

1181
01:10:48,940 --> 01:10:51,490
所以这些东西的顺序并不重要，

1182
01:10:51,490 --> 01:10:54,710
事实上，如果我们没有锁，

1183
01:10:55,350 --> 01:10:56,880
也有可能其他的。

1184
01:10:57,240 --> 01:11:03,790
在大多数情况下，如果我们不持有锁，任何顺序都不会起作用。

1185
01:11:06,530 --> 01:11:09,620
不管怎样，是的，因为我们有一把锁，顺序无关紧要，

1186
01:11:09,620 --> 01:11:10,760
因为父进程看不到。

1187
01:11:11,120 --> 01:11:11,930
理解了。

1188
01:11:19,020 --> 01:11:20,190
好的。

1189
01:11:21,980 --> 01:11:26,810
好的，我想强调的技巧是，

1190
01:11:29,150 --> 01:11:33,200
在很大程度上，子进程没有，

1191
01:11:33,620 --> 01:11:35,660
最终，子进程并没有释放所有的资源，

1192
01:11:35,660 --> 01:11:37,790
因为它不能，因为它仍在执行，

1193
01:11:37,790 --> 01:11:41,480
取而代之的是一些其他线程，也就是父线程

1194
01:11:41,630 --> 01:11:47,270
来释放执行所需的资源，

1195
01:11:47,780 --> 01:11:49,370
所以这是一种技巧，

1196
01:11:49,370 --> 01:11:53,810
让我们极大地简化了退出。

1197
01:11:56,080 --> 01:12:00,270
好的，我最后要看的是 kill ，

1198
01:12:00,690 --> 01:12:04,290
你知道 kill 系统调用，

1199
01:12:04,290 --> 01:12:08,250
在 Unix 中，可以调用 kill 系统调用，

1200
01:12:08,520 --> 01:12:11,040
传递另一个进程的进程 id ，

1201
01:12:11,280 --> 01:12:12,570
目标是，

1202
01:12:12,660 --> 01:12:16,920
导致另一个进程，目标进程停止执行。

1203
01:12:17,510 --> 01:12:20,030
如果我们一不小心，

1204
01:12:20,030 --> 01:12:23,750
这有风险，特别是如果内核中执行的其他进程，

1205
01:12:24,560 --> 01:12:28,370
这个风险可能在几分钟前就提到了，

1206
01:12:28,370 --> 01:12:32,240
你想杀死的进程的内核线程，

1207
01:12:32,240 --> 01:12:34,340
可能正在更新一些东西，

1208
01:12:34,340 --> 01:12:37,190
比如，更新文件系统，创建文件，

1209
01:12:37,250 --> 01:12:40,190
我们不能直接杀死它，

1210
01:12:40,190 --> 01:12:45,710
因为这将使一些多步骤操作只完成一半。

1211
01:12:46,200 --> 01:12:51,930
现在，我们知道 kill 不能真正停止目标进程，

1212
01:12:52,350 --> 01:12:56,850
事实上，在 xv6 中，在 Unix 中也是如此，

1213
01:12:56,970 --> 01:13:00,090
kill 几乎不会做什么事情，

1214
01:13:01,050 --> 01:13:04,800
它扫描进程表，查找目标进程 id ，

1215
01:13:04,860 --> 01:13:11,110
只是在进程的进程结构中设置这个标志，

1216
01:13:12,000 --> 01:13:16,140
而且，如果它处于睡眠状态，调用到可运行，

1217
01:13:16,140 --> 01:13:17,400
从睡眠中唤醒，

1218
01:13:17,400 --> 01:13:19,080
它所做的就是设置这个标志，

1219
01:13:19,110 --> 01:13:23,610
它不会停止另一个进程的执行或任何类似的操作。

1220
01:13:26,490 --> 01:13:29,910
kill 是非常温和的，

1221
01:13:30,790 --> 01:13:33,730
游戏是，

1222
01:13:33,730 --> 01:13:37,690
目标进程在内核代码中，

1223
01:13:37,690 --> 01:13:40,420
在那里会安全地停止执行，

1224
01:13:41,170 --> 01:13:45,100
另一个进程检查它自己的终止标志，

1225
01:13:45,130 --> 01:13:46,090
如果设置了，

1226
01:13:46,180 --> 01:13:51,580
其他进程会自动退出，调用 exit 函数，

1227
01:13:52,240 --> 01:13:56,300
你可以在 trap.c 上看到其中的一些点，

1228
01:13:56,690 --> 01:14:00,560
实际上，你可以在 trap.c 中看到所有的点，

1229
01:14:01,400 --> 01:14:02,870
所以，如果我们在 usertrap 中，

1230
01:14:02,870 --> 01:14:06,590
在实际执行系统调用之前，

1231
01:14:06,620 --> 01:14:08,570
如果进程已被终止，

1232
01:14:08,840 --> 01:14:11,810
或者如果在这个进程调用了 kill ，

1233
01:14:12,050 --> 01:14:14,510
然后进程调用 exit 并离开。

1234
01:14:15,180 --> 01:14:18,030
这是内核中的一个点，没有持有任何锁，

1235
01:14:18,030 --> 01:14:19,740
它没有在做任何事情，

1236
01:14:20,190 --> 01:14:25,050
所以，进程是安全的，只需退出并调用 exit 。

1237
01:14:26,230 --> 01:14:31,450
在 usertrap 末尾有一个类似的检查。

1238
01:14:33,920 --> 01:14:39,360
所以，在系统调用之后，进程还会检查它是否被终止，

1239
01:14:39,420 --> 01:14:44,190
实际上，这段代码会执行，

1240
01:14:44,430 --> 01:14:47,610
即使进程被中断打断，

1241
01:14:47,610 --> 01:14:49,890
比如，定时器中断关闭，

1242
01:14:50,160 --> 01:14:52,830
然后，这段代码会执行，

1243
01:14:52,830 --> 01:14:55,140
我们会看到这个进程已被终止，

1244
01:14:55,140 --> 01:14:56,430
然后这个进程将会退出。

1245
01:14:59,350 --> 01:15:00,970
所以，这意味着，

1246
01:15:00,970 --> 01:15:05,320
kill 的意思是，

1247
01:15:05,320 --> 01:15:09,100
kill 的作用不是直接停止其他进程，

1248
01:15:09,650 --> 01:15:10,820
而更像是，

1249
01:15:11,030 --> 01:15:14,900
如果用户空间中的其他进程，

1250
01:15:14,900 --> 01:15:17,420
然后下一次它进行系统调用时，

1251
01:15:18,500 --> 01:15:19,610
它会退出，

1252
01:15:20,300 --> 01:15:22,490
或者下一次定时器中断发生时，

1253
01:15:22,490 --> 01:15:26,240
当目标进程执行其他用户代码时，

1254
01:15:26,360 --> 01:15:29,060
如果它被定时器中断或其他中断中断，

1255
01:15:29,210 --> 01:15:30,920
那么它也会退出。

1256
01:15:30,920 --> 01:15:32,660
所以，这里可能会有明显的延迟，

1257
01:15:32,660 --> 01:15:38,480
在一个进程调用 kill 和另一个进程实际退出。

1258
01:15:39,440 --> 01:15:42,620
事情就是这样的。

1259
01:15:44,420 --> 01:15:45,980
虽然有一个中间问题，

1260
01:15:45,980 --> 01:15:49,490
如果进程没有在自己的用户空间，

1261
01:15:49,490 --> 01:15:51,350
而是在进行系统调用中，

1262
01:15:53,180 --> 01:15:54,320
它被杀死，

1263
01:15:54,650 --> 01:15:56,240
我们需要做些什么特别的事情吗？

1264
01:15:57,110 --> 01:15:59,840
可能会出现这种情况的原因是，

1265
01:15:59,840 --> 01:16:03,540
假设进程正在从控制台读取，

1266
01:16:03,600 --> 01:16:05,550
读取你输入的下一个字符，

1267
01:16:05,550 --> 01:16:07,830
你可能知道明天都不会输入另一个字符。

1268
01:16:08,440 --> 01:16:11,380
这是可以的，如果你终止进程，

1269
01:16:11,380 --> 01:16:14,020
它实际上在明天之前就消失了。

1270
01:16:15,970 --> 01:16:20,290
所以，在 xv6 的很多点上。

1271
01:16:20,290 --> 01:16:23,710
当进程在睡眠中，

1272
01:16:24,320 --> 01:16:26,000
xv6 会安排，

1273
01:16:26,000 --> 01:16:29,420
如果它在内核中睡眠时被杀死，

1274
01:16:29,990 --> 01:16:31,580
它实际上会退出。

1275
01:16:31,730 --> 01:16:33,920
让我来展示一下这个机制，

1276
01:16:34,760 --> 01:16:37,340
首先要看的就是 kill 本身。

1277
01:16:39,020 --> 01:16:43,160
你可以看到，如果目标进程处于睡眠状态，

1278
01:16:43,720 --> 01:16:45,640
然后 kill 会将状态设置为可运行，

1279
01:16:45,940 --> 01:16:48,190
这意味着即使它调用了 sleep ，

1280
01:16:48,750 --> 01:16:50,070
调度器现在也会运行它，

1281
01:16:50,100 --> 01:16:52,320
它会简单地从睡眠中恢复过来。

1282
01:16:52,800 --> 01:16:56,850
所以让我们来看看一个真正重要的地方，

1283
01:16:56,850 --> 01:17:02,010
在管道代码中，如果进程处于睡眠状态，等待读取管道，

1284
01:17:05,190 --> 01:17:08,970
它被杀死， kill 设置从睡眠到可运行，

1285
01:17:09,060 --> 01:17:10,770
回到这个循环的顶部，

1286
01:17:11,310 --> 01:17:13,440
如果在管道中没有数据，

1287
01:17:13,440 --> 01:17:15,630
在管道中仍然没有数据，

1288
01:17:15,780 --> 01:17:21,720
现在， piperead 会检查进程是否已被终止，

1289
01:17:21,840 --> 01:17:22,890
如果它已经被杀死，

1290
01:17:22,890 --> 01:17:24,120
不是再次睡眠，

1291
01:17:24,300 --> 01:17:28,410
piperead 会返回一个错误，并不重要，

1292
01:17:28,440 --> 01:17:33,540
但我们要回到的是这个系统调用，

1293
01:17:33,540 --> 01:17:35,880
因为我们在系统调用中，

1294
01:17:36,400 --> 01:17:41,230
管道最终返回系统调用，

1295
01:17:41,470 --> 01:17:45,310
然后 usertrap 再次检查 p->killed ，

1296
01:17:45,430 --> 01:17:46,300
现在可以退出了。

1297
01:17:46,810 --> 01:17:49,700
所以，对于 sleep 来说，

1298
01:17:49,790 --> 01:17:55,280
我们知道[逃脱]是可以的，当它被杀死，

1299
01:17:55,640 --> 01:17:58,310
这些循环检查 killed 标志，

1300
01:17:58,340 --> 01:18:01,610
但也有 sleep 这样是不可以的，

1301
01:18:02,060 --> 01:18:03,680
对一个要退出的进程，

1302
01:18:03,680 --> 01:18:05,120
如果它在睡眠状态下被杀死。

1303
01:18:05,990 --> 01:18:10,580
比如，如果某个进程正在更新磁盘上的文件系统，

1304
01:18:10,580 --> 01:18:11,750
要创建新文件，

1305
01:18:11,930 --> 01:18:14,450
现在不是时候，

1306
01:18:14,600 --> 01:18:16,520
即使它在睡眠等待磁盘，

1307
01:18:16,520 --> 01:18:19,970
对于一个进程来说，现在不是退出的时候，

1308
01:18:19,970 --> 01:18:20,720
因为它已经被杀死，

1309
01:18:20,720 --> 01:18:23,120
我们要完成完整的文件系统操作，

1310
01:18:23,240 --> 01:18:25,460
只有在那时进程才可以退出，

1311
01:18:25,790 --> 01:18:27,230
所以你可以看到这个，

1312
01:18:27,350 --> 01:18:28,340
我们已经看过了，

1313
01:18:28,340 --> 01:18:33,200
但我将在磁盘驱动程序中展示。

1314
01:18:33,960 --> 01:18:35,820
睡眠循环的一个例子，

1315
01:18:35,880 --> 01:18:37,380
不会检查 killed ，

1316
01:18:37,590 --> 01:18:38,520
看那里,

1317
01:18:40,720 --> 01:18:42,310
所以在这里，这是 sleep ，

1318
01:18:42,730 --> 01:18:48,230
进程等待磁盘完成读取磁盘块，

1319
01:18:48,290 --> 01:18:50,060
它绝对不会检查 killed ，

1320
01:18:50,750 --> 01:18:53,360
因为它想要完成它，

1321
01:18:53,360 --> 01:18:54,860
也许在创建文件的过程中，

1322
01:18:54,860 --> 01:18:56,870
涉及多个磁盘读取和写入，

1323
01:18:57,020 --> 01:18:59,420
想要完成整个文件系统操作，

1324
01:18:59,600 --> 01:19:00,860
整个系统调用，

1325
01:19:01,250 --> 01:19:03,770
然后才检查 p->killed 并退出。

1326
01:19:06,990 --> 01:19:08,280
有什么问题吗？

1327
01:19:10,820 --> 01:19:11,870
我有一个问题，

1328
01:19:11,870 --> 01:19:15,290
为什么 kill 允许以这种方式，

1329
01:19:15,530 --> 01:19:18,320
为什么进程不会杀死所有其他的进程，

1330
01:19:18,320 --> 01:19:21,790
你可以自己运行。

1331
01:19:25,140 --> 01:19:28,140
你知道，如果你在麻省理工学院的 Athena 分时机器上这样做，

1332
01:19:28,140 --> 01:19:29,460
可能会把你赶出学校。

1333
01:19:31,490 --> 01:19:34,820
是的，但是为什么允许这样做呢？

1334
01:19:34,940 --> 01:19:39,950
在 xv6 允许，因为 xv6 是一个玩具操作系统，

1335
01:19:39,950 --> 01:19:44,300
它只是

1336
01:19:44,960 --> 01:19:51,820
在 xv6 中，任何与权限有关的东西都不存在，

1337
01:19:52,360 --> 01:19:54,610
在 Linux 或真正的操作系统中，

1338
01:19:55,150 --> 01:19:57,580
每个进程都有一个用户 id ，

1339
01:19:57,910 --> 01:20:02,650
对应于执行该进程的人类用户，

1340
01:20:02,710 --> 01:20:07,330
一些系统调用使用进程的用户 id

1341
01:20:07,330 --> 01:20:10,030
检查允许哪些进程执行此操作，

1342
01:20:10,450 --> 01:20:15,760
所以在 Linux 中，你会在这里看到一个额外的检查，

1343
01:20:15,790 --> 01:20:21,250
就是调用进程必须具有相同的用户 id ，

1344
01:20:21,340 --> 01:20:23,080
与想要杀死的进程一样，

1345
01:20:23,290 --> 01:20:24,700
否则是不允许的。

1346
01:20:25,730 --> 01:20:28,490
而且，至少在分时背景下，

1347
01:20:29,170 --> 01:20:30,460
我们有多个用户，

1348
01:20:30,460 --> 01:20:32,320
我们不希望他们杀死彼此的进程，

1349
01:20:32,410 --> 01:20:35,410
这或多或少可以防止人们，

1350
01:20:35,440 --> 01:20:39,040
使其难以杀死其他人的进程。

1351
01:20:41,090 --> 01:20:42,320
好的，我明白了，谢谢。

1352
01:20:45,400 --> 01:20:47,740
init 进程是否会退出？

1353
01:20:48,770 --> 01:20:50,210
让我找找。

1354
01:20:54,430 --> 01:20:57,580
是的，如果 fork 失败，退出，

1355
01:20:57,640 --> 01:21:00,610
然而，这个问题的真正答案是否定的，

1356
01:21:00,610 --> 01:21:03,430
其目的是 init 永远不会退出，

1357
01:21:03,760 --> 01:21:05,110
它们只是在这个循环中，

1358
01:21:05,500 --> 01:21:09,950
一遍又一遍地调用 wait ，

1359
01:21:10,340 --> 01:21:15,800
如果 init 退出，我认为这是系统中的致命错误，系统将崩溃。

1360
01:21:16,360 --> 01:21:19,330
内核中的某个地方有代码，可能在 exit 中。

1361
01:21:19,940 --> 01:21:20,870
检查一下 exit 。

1362
01:21:30,240 --> 01:21:33,150
是的，在这里， exit ，在 exit 的开头，

1363
01:21:33,330 --> 01:21:37,230
如果当前进程是是 init 进程，那就是一个 panic 。

1364
01:21:37,860 --> 01:21:41,690
因为，这个系统最终会陷入停顿，

1365
01:21:41,690 --> 01:21:42,710
如果没有 init ，

1366
01:21:42,740 --> 01:21:45,290
因为这样就没有什么东西收集，

1367
01:21:45,320 --> 01:21:48,380
没有什么东西调用 wait 对于那些退出的进程，

1368
01:21:48,380 --> 01:21:50,690
并且没有任何东西可以完成进程的释放，

1369
01:21:50,690 --> 01:21:52,400
慢慢地，我们的进程耗尽了，

1370
01:21:52,400 --> 01:21:55,810
那就是另一个错误了。

1371
01:21:56,940 --> 01:21:58,230
我们必须有 init 。

1372
01:21:58,700 --> 01:21:59,780
所以真正的答案是不，

1373
01:21:59,780 --> 01:22:01,430
它确实不能被允许退出，

1374
01:22:02,260 --> 01:22:02,980
最好不要退出。

1375
01:22:08,750 --> 01:22:09,290
好的。

1376
01:22:12,580 --> 01:22:13,480
还有其他问题吗？

1377
01:22:16,280 --> 01:22:18,500
这是另一个问题，

1378
01:22:18,770 --> 01:22:22,160
所以，我们在这节课上还没有谈到太多，

1379
01:22:22,160 --> 01:22:27,460
但看看关闭操作系统会发生什么或需要发生什么。

1380
01:22:28,480 --> 01:22:29,380
被拔掉电源。

1381
01:22:30,840 --> 01:22:31,320
好的。

1382
01:22:31,350 --> 01:22:32,310
好的。

1383
01:22:32,340 --> 01:22:33,360
是的。

1384
01:22:33,870 --> 01:22:36,270
是的，这很复杂，

1385
01:22:36,270 --> 01:22:37,740
这取决于你运行的是什么，

1386
01:22:37,740 --> 01:22:41,990
如果你在，如果机器当前什么都不做，

1387
01:22:42,650 --> 01:22:47,510
好的，这个问题的部分答案是，

1388
01:22:47,510 --> 01:22:49,640
文件系统最终，

1389
01:22:50,610 --> 01:22:53,130
因为文件系统是永久性的，

1390
01:22:53,430 --> 01:22:56,970
文件系统会从一个重启到另一个重启。

1391
01:22:57,790 --> 01:23:00,940
我们需要让文件系统保持良好的状态，

1392
01:23:01,060 --> 01:23:04,930
所以，如果我们正在对文件系统进行某些更新，

1393
01:23:04,930 --> 01:23:06,130
比如创建文件，

1394
01:23:06,160 --> 01:23:09,910
然后我们想要关闭系统或者停电之类的，

1395
01:23:09,910 --> 01:23:13,090
我们绝对需要一个策略来确保，

1396
01:23:14,340 --> 01:23:17,010
尽管我们正在对文件系统进行一些复杂的更新，

1397
01:23:17,010 --> 01:23:19,680
我们不会把它留在文件系统中，

1398
01:23:20,010 --> 01:23:25,950
我们不会在磁盘文件系统结构中公开任何损坏的不变量，

1399
01:23:26,100 --> 01:23:29,100
因为文件实际上只是一种在磁盘上的数据结构。

1400
01:23:29,750 --> 01:23:32,720
所以有很多这样的，

1401
01:23:33,320 --> 01:23:35,990
一些机制来确保，

1402
01:23:35,990 --> 01:23:38,900
如果你关机了或者停电了或者谁知道会发生什么，

1403
01:23:39,170 --> 01:23:43,670
我们可以恢复磁盘上的文件系统。

1404
01:23:45,030 --> 01:23:46,620
对于其他，不是为了这个，

1405
01:23:49,100 --> 01:23:52,700
那么，你是不是要做一些特殊的事情来关机，

1406
01:23:52,730 --> 01:23:55,100
取决于你正在运行什么进程，

1407
01:23:55,190 --> 01:23:58,280
如果你正在运行某个重要的服务器，一台数据库服务器，

1408
01:23:58,280 --> 01:24:01,730
许多其他计算机依赖，并从网络上访问，

1409
01:24:02,210 --> 01:24:06,530
答案可能是你不被允许关机，

1410
01:24:06,530 --> 01:24:10,490
因为你提供的服务对很多其他计算机都很重要。

1411
01:24:11,080 --> 01:24:12,850
如果你的计算机没有执行任何操作。

1412
01:24:15,200 --> 01:24:16,760
那你就可以把它关掉，

1413
01:24:16,940 --> 01:24:19,170
它会停止执行，

1414
01:24:20,040 --> 01:24:21,180
没有什么可做的，

1415
01:24:21,270 --> 01:24:23,280
真的，也许你问题的答案是，

1416
01:24:24,360 --> 01:24:25,410
如果你想关闭计算机，

1417
01:24:25,410 --> 01:24:27,270
确保文件系统状态良好，

1418
01:24:27,300 --> 01:24:30,270
然后停止执行指令，就好了。

1419
01:24:31,730 --> 01:24:32,240
好的。

1420
01:24:32,240 --> 01:24:34,010
有道理，是的，谢谢。

1421
01:24:37,090 --> 01:24:37,930
还要别的吗？

1422
01:24:41,980 --> 01:24:44,020
哦，抱歉，我还有一个问题，

1423
01:24:44,020 --> 01:24:46,960
那么这个信号量接口是什么。

1424
01:24:48,740 --> 01:24:50,000
关于 p 和 v 。

1425
01:24:53,330 --> 01:24:57,080
所以，只有这两个函数？

1426
01:24:57,650 --> 01:24:59,360
嗯，是的。

1427
01:25:00,100 --> 01:25:02,470
是的， xv6 实际上没有信号量，

1428
01:25:02,470 --> 01:25:05,110
但是书中的信号量，我想它只是 p 和 v ，

1429
01:25:05,170 --> 01:25:09,310
信号量对象有两个方法 p 和 v 。

1430
01:25:11,010 --> 01:25:13,080
好的，我明白了，谢谢。

1431
01:25:13,110 --> 01:25:13,560
好的。

1432
01:25:20,600 --> 01:25:21,410
还要别的吗？

1433
01:25:25,170 --> 01:25:25,830
好的。

