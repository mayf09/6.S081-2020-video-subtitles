1
00:00:00,810 --> 00:00:02,640
Yep.

2
00:00:05,770 --> 00:00:07,960
Hey buddy, people hear what I'm saying.

3
00:00:07,960 --> 00:00:10,210
You're good, good.

4
00:00:11,020 --> 00:00:15,070
Awesome, I just want to get started with similar to last week

5
00:00:15,070 --> 00:00:18,400
where we asked you about, the util lab,

6
00:00:18,400 --> 00:00:20,920
I just want to get started by asking a little bit about syscall lab,

7
00:00:20,920 --> 00:00:23,890
since that was due on Thursday.

8
00:00:24,520 --> 00:00:29,200
So if anybody just has like something particularly interesting, they found about the lab

9
00:00:29,200 --> 00:00:31,030
or a nasty bug that they found

10
00:00:31,030 --> 00:00:32,920
or just a silly mistake they made,

11
00:00:32,920 --> 00:00:36,410
anything you want to share about the syscall lab to be， [that'd be great.]

12
00:00:38,450 --> 00:00:45,470
I somehow managed to delete the part from where from fork where you have to copy over the mask,

13
00:00:45,470 --> 00:00:49,490
so I had that working and then I change something else and then I tested it for.

14
00:00:50,200 --> 00:00:51,880
Your audio is like cutting out.

15
00:00:51,880 --> 00:00:54,660
Oh, it is sorry, you hear me.

16
00:00:58,060 --> 00:00:58,750
I hear you.

17
00:00:59,380 --> 00:01:00,280
Oh, okay.

18
00:01:00,820 --> 00:01:03,250
Yeah I guess.

19
00:01:03,680 --> 00:01:07,490
So basically I deleted somehow the copy of the mask

20
00:01:07,490 --> 00:01:10,910
and then my my fork didn't work anymore,

21
00:01:11,120 --> 00:01:14,000
so then I was just like I did that, how does it not work,

22
00:01:14,240 --> 00:01:17,580
so spend a lot of time figuring out. What I did wrong.

23
00:01:17,610 --> 00:01:20,400
And I realized I just deleted that line from the.

24
00:01:22,820 --> 00:01:25,640
Is anybody having trouble hearing Luca, is that on my end.

25
00:01:26,290 --> 00:01:27,370
I think its on your end.

26
00:01:28,000 --> 00:01:28,900
Yeah I'm fine.

27
00:01:32,290 --> 00:01:33,610
This must be on my end.

28
00:01:56,320 --> 00:01:57,970
Sorry, maybe that'll work better now.

29
00:02:02,760 --> 00:02:06,330
Can you hear me now, okay great.

30
00:02:06,330 --> 00:02:08,550
I was worried that I was just talking.

31
00:02:08,550 --> 00:02:11,130
No, no, seems to be on my end.

32
00:02:11,400 --> 00:02:12,000
Alright.

33
00:02:16,870 --> 00:02:21,850
Awesome, will anybody else have anything they'd like to share about you of syscall.

34
00:02:24,190 --> 00:02:25,990
Anything particularly interesting,

35
00:02:25,990 --> 00:02:28,690
or was the lab absolutely horrendous

36
00:02:28,690 --> 00:02:32,110
and you think we should cut it out of the class, never do it again.

37
00:02:33,430 --> 00:02:40,480
I have something, apparently the order of things matters which is a general statement,

38
00:02:40,780 --> 00:02:48,460
so I tried to determine the mass computation inside the syscall function.

39
00:02:48,980 --> 00:02:52,400
Before determining whether I actually needed to do the tracing.

40
00:02:53,100 --> 00:02:59,220
And so all the syscall we're getting correctly traced except that trace call.

41
00:02:59,560 --> 00:03:02,500
And I was really getting disturbed by that,

42
00:03:02,500 --> 00:03:04,480
until I think it was David who pointed out,

43
00:03:04,480 --> 00:03:10,040
you know you should do the computation after [you should trace] just like that's fun.

44
00:03:10,790 --> 00:03:14,770
Alright. I'm glad you were able to catch that.

45
00:03:15,220 --> 00:03:17,050
Yeah order does matter,

46
00:03:17,080 --> 00:03:22,120
especially for page tables, you'll find I think that order matters there as well

47
00:03:22,120 --> 00:03:26,220
and generally throughout the class, paying attention to the order of things will be important.

48
00:03:28,140 --> 00:03:30,360
It's good to not overwrite things in page table.

49
00:03:31,630 --> 00:03:35,970
I also had something which I'm actually still confused about.

50
00:03:36,120 --> 00:03:42,000
Well I had a lot of debugging print statements in the kernel code.

51
00:03:42,870 --> 00:03:47,520
I then ran that trace thing with all of the bits set,

52
00:03:47,610 --> 00:03:50,850
so basically tracing all the system calls.

53
00:03:51,520 --> 00:03:59,860
And, I think I saw a lot of tracing for the print statements in the kernel, and then.

54
00:04:00,410 --> 00:04:09,110
Because and then I assumed that my print my print apps were trying to read and write to the console,

55
00:04:09,140 --> 00:04:11,030
but that do write to the console,

56
00:04:11,030 --> 00:04:14,840
but then I was wondering why are we.

57
00:04:15,110 --> 00:04:19,190
I guess, I'm just confused why we're able to use printf in the kernel.

58
00:04:22,670 --> 00:04:26,840
Yeah I'm not I haven't looked at the printf code recently,

59
00:04:26,840 --> 00:04:29,860
but I think there's a file printf.c

60
00:04:29,860 --> 00:04:31,630
you might be a look at if you want to.

61
00:04:32,160 --> 00:04:35,990
Um, here what was going on there,

62
00:04:35,990 --> 00:04:38,270
so I think the printf function should be [implemented in there].

63
00:04:41,120 --> 00:04:42,320
At least our version of it,

64
00:04:42,530 --> 00:04:48,120
I don't know perhaps one of the what are some of the other core staff might know what's going on.

65
00:04:49,270 --> 00:04:53,530
And the printf in the kernel shouldn't show up as your traces,

66
00:04:53,530 --> 00:04:56,530
because printf in the kernel doesn't call any system calls.

67
00:04:58,000 --> 00:04:59,890
Yeah that's what I thought,

68
00:04:59,890 --> 00:05:03,700
maybe that maybe the tracing was not from that.

69
00:05:04,680 --> 00:05:07,080
Yeah I don't think it is from your printf in the kernel.

70
00:05:08,240 --> 00:05:08,960
Okay.

71
00:05:12,370 --> 00:05:18,490
OK, well unless anybody has any other burning comments about syscall,

72
00:05:18,490 --> 00:05:22,810
I think we can get started with lecture for today.

73
00:05:23,290 --> 00:05:32,710
I'll be talking a little bit about the process of converting C to assembly and processors,

74
00:05:32,710 --> 00:05:35,380
and this is more of a practical lecture today

75
00:05:35,380 --> 00:05:36,640
or at least that's the aim,

76
00:05:36,640 --> 00:05:43,550
so the goal here is to get you all familiarized with RISC-V

77
00:05:43,550 --> 00:05:49,340
the processor, the assembly language and calling conventions for RISC-V.

78
00:05:49,340 --> 00:05:50,600
And this will be important,

79
00:05:50,600 --> 00:05:53,390
in not not super important for page table,

80
00:05:53,390 --> 00:05:58,100
but certainly for the traps lab which is will be assigned later this week,

81
00:05:58,100 --> 00:06:01,970
this will be essential for debugging and implementing things,

82
00:06:01,970 --> 00:06:07,160
because you'll be working quite intimately with trap frame and stack and things like that,

83
00:06:07,490 --> 00:06:09,530
so that's the that's kind of the goal for today.

84
00:06:09,530 --> 00:06:12,860
And, my first aim was to,

85
00:06:12,950 --> 00:06:17,030
this might be a little bit of review from 6.004

86
00:06:17,030 --> 00:06:21,950
or any other computer architecture theme classes that you may have taken in the past,

87
00:06:22,040 --> 00:06:26,240
but I just want to go over briefly kind of see

88
00:06:26,270 --> 00:06:29,570
the C language, how we get to assembly

89
00:06:29,750 --> 00:06:32,420
and I'm maybe a little bit about processor.

90
00:06:32,420 --> 00:06:36,070
So, throughout, and then of course throughout this lecture,

91
00:06:36,070 --> 00:06:39,610
feel free to interrupt with any questions that you have.

92
00:06:41,050 --> 00:06:45,340
So, you know, we have our normal main functions in C.

93
00:06:45,700 --> 00:06:51,930
You know they do something, maybe they print something, then they exit.

94
00:06:53,680 --> 00:06:56,050
And this all looks well and good,

95
00:06:56,050 --> 00:06:59,410
but as any of you are aware from 6.004

96
00:06:59,410 --> 00:07:03,280
processors don't actually understand the C language,

97
00:07:03,280 --> 00:07:06,520
rather they understand what we call a assembly

98
00:07:06,520 --> 00:07:09,880
or more specifically they understand the binary encoding of assembly,

99
00:07:10,150 --> 00:07:13,300
and so this here I've circled a picture of

100
00:07:13,300 --> 00:07:16,420
an actual RISC-V processor from a SiFive board,

101
00:07:16,510 --> 00:07:20,140
and when we say a processor is RISC-V

102
00:07:20,140 --> 00:07:23,980
that means that it understands the RISC-V instruction set,

103
00:07:24,220 --> 00:07:30,460
so every processor has an associated ISA or instruction.

104
00:07:31,010 --> 00:07:33,800
And that's kind of the set of instructions,

105
00:07:34,890 --> 00:07:36,870
that makes sense to that processor,

106
00:07:36,870 --> 00:07:41,580
so every instruction has an associated binary encoding or an op code.

107
00:07:42,480 --> 00:07:44,760
And when a processor is running

108
00:07:44,760 --> 00:07:48,240
and it sees a particular encoding, it knows what to do.

109
00:07:48,540 --> 00:07:56,150
And so, you know this processor on this board happens to understand the RISC-V assembly

110
00:07:56,150 --> 00:07:58,910
which is what C code is compiled to,

111
00:07:58,910 --> 00:08:03,920
so the general process of getting C code to actually run on your processor is,

112
00:08:03,920 --> 00:08:06,950
we start with C, it gets compiled to assembly,

113
00:08:06,950 --> 00:08:09,950
and there's some linking and things like that happened between this step

114
00:08:09,950 --> 00:08:12,650
but that's we are not a compiler class,

115
00:08:12,710 --> 00:08:18,120
so and then the assembly will then be translated into binary,

116
00:08:18,120 --> 00:08:26,110
and so this is the object or .o files that you see.

117
00:08:26,110 --> 00:08:32,980
so if you've ever paid attention to what's inside of your lab directory after you run make qemu,

118
00:08:32,980 --> 00:08:36,160
you'll see a bunch of .o files lying around

119
00:08:36,250 --> 00:08:40,150
and those are the actual object files that the processor understands.

120
00:08:41,030 --> 00:08:43,070
And the asm files, you've also seen,

121
00:08:43,100 --> 00:08:47,210
you haven't really written any, but if you recall from syscall,

122
00:08:47,210 --> 00:08:51,980
usys.pl is compiled to a file called usys.S

123
00:08:52,040 --> 00:08:56,270
and so .S files are assembly language,

124
00:08:56,270 --> 00:08:59,570
and so you've seen you've certainly seen some RISC-V assembly

125
00:08:59,570 --> 00:09:00,980
and if you took 6.004

126
00:09:01,040 --> 00:09:04,610
I believe you've also seen a good amount of assembly language.

127
00:09:05,480 --> 00:09:10,100
An assembly looks in general much less structured than C,

128
00:09:10,100 --> 00:09:14,480
so you'll just see line after line after line of instructions,

129
00:09:14,480 --> 00:09:22,200
you'll see simple things like add mult etc, and so on and so forth,

130
00:09:22,200 --> 00:09:27,420
and this doesn't have no nice control flow, there's no loops,

131
00:09:27,450 --> 00:09:31,140
there are functions but not in the sense that you might remember from C,

132
00:09:31,140 --> 00:09:35,100
we see labels as opposed to true function definitions.

133
00:09:36,500 --> 00:09:38,990
And the assembly, so it's a much lower language

134
00:09:38,990 --> 00:09:42,080
and there are plenty of other languages that are also compiled to assembly,

135
00:09:42,080 --> 00:09:47,600
so, the same process holds true for things like C++.

136
00:09:47,780 --> 00:09:51,910
Um, you know any any language that's compiled

137
00:09:51,910 --> 00:09:55,120
will go to the same assembly language at the base.

138
00:09:56,700 --> 00:10:01,080
And, so that's kind of the basic process of

139
00:10:01,080 --> 00:10:06,210
getting our computer to actually understand the C code that we're writing,

140
00:10:06,420 --> 00:10:13,380
but you'll notice that we've been referring to RISC-V assembly.

141
00:10:13,620 --> 00:10:16,110
Throughout the course and the processor is RISC-V

142
00:10:16,110 --> 00:10:20,550
and that's because, it it's important because there's many different kinds of assembly,

143
00:10:20,550 --> 00:10:25,360
so it's unlikely that you're using RISC-V yourself,

144
00:10:25,360 --> 00:10:27,670
like you're not going to be running Linux on it,

145
00:10:27,760 --> 00:10:36,520
instead most modern computers will run on what's called x86 or you'll sometimes see is x86-64.

146
00:10:37,720 --> 00:10:42,370
And this is this is a different ISA, this is a different instruction set,

147
00:10:42,370 --> 00:10:44,200
it looks pretty similar to RISC-V,

148
00:10:44,230 --> 00:10:48,340
but this is what you see in kind of your personal computers often.

149
00:10:51,760 --> 00:10:54,820
So if you use an Intel

150
00:10:54,820 --> 00:11:01,220
so Intel CPU's implement x86 and I believe AMD also do.

151
00:11:02,090 --> 00:11:07,800
And [this is] relatively important distinction between the two,

152
00:11:07,800 --> 00:11:11,250
they're not quite as similar as they may look at first

153
00:11:11,400 --> 00:11:17,130
and that comes down to the fact that RISC-V is what we call as a RISC,

154
00:11:17,130 --> 00:11:21,990
the RISC part of RISC-V refers to a reduced instruction set.

155
00:11:22,710 --> 00:11:30,660
And x86-64 is what's called a CISC or complex instructions.

156
00:11:34,570 --> 00:11:38,260
And there's a couple of key differences here,

157
00:11:38,260 --> 00:11:42,640
one is just the number of instructions that are present in x86-64,

158
00:11:42,640 --> 00:11:50,230
in fact one of the big motivations for writing, for for making RISC-V was

159
00:11:50,230 --> 00:11:54,220
how many instructions we actually have.

160
00:11:54,940 --> 00:12:00,760
In the Intel kind of handbook, so for reference, there's three full books,

161
00:12:02,150 --> 00:12:06,770
that encompass the ISA and some statistics,

162
00:12:06,770 --> 00:12:17,560
I think there's new instructions have been added at a rate of three instructions per month.

163
00:12:18,720 --> 00:12:24,030
Since x86-64 was added, it was first published in the seventies,

164
00:12:24,030 --> 00:12:33,130
so I believe there's like north of 15,000 instructions in x86-64.

165
00:12:34,240 --> 00:12:37,210
And RISC-V on the other hand,

166
00:12:37,570 --> 00:12:41,170
the assembly for RISC-V can be nicely contained within two documents.

167
00:12:41,170 --> 00:12:44,320
And so, a kind of going off of that,

168
00:12:44,410 --> 00:12:50,230
we don't expect you in this course to memorize every single RISC-V instruction,

169
00:12:50,290 --> 00:12:52,330
but if you are interested

170
00:12:52,330 --> 00:12:57,250
or you ever find yourself confused by what a specific instruction is or does,

171
00:12:57,550 --> 00:12:59,710
if you go to the course website

172
00:12:59,950 --> 00:13:02,710
and we look under the references tab,

173
00:13:03,460 --> 00:13:10,060
under RISC-V we give you the links to both the privileged and unprivileged instruction sets,

174
00:13:10,300 --> 00:13:16,710
so this is kind of the document that gives you a whole bunch of information about the ISA,

175
00:13:16,800 --> 00:13:22,800
but you'll note that like this is 240 pages, and this is 135 pages,

176
00:13:22,800 --> 00:13:28,590
so it's significantly significantly smaller than the x86 instruction set,

177
00:13:28,620 --> 00:13:33,060
that's one of the nice things about, about RISC-V,

178
00:13:33,330 --> 00:13:39,960
so we have in RISC-V we have fewer instructions

179
00:13:39,960 --> 00:13:43,730
and not only that, the instructions are simpler.

180
00:13:44,340 --> 00:13:47,540
So, what I mean by that is that,

181
00:13:48,800 --> 00:13:52,580
there are many instructions in x86-64 by,

182
00:13:52,580 --> 00:13:56,450
for example, that referring to something like add or mul sub.

183
00:13:57,020 --> 00:14:01,190
In x86-64 there's plenty of instructions, that do more than one thing,

184
00:14:01,190 --> 00:14:07,430
so they perform some complicated set of operations and then gets you the result

185
00:14:07,430 --> 00:14:13,490
and that's not the case with RISC-V RISC-V instructions tend to be smaller in scope,

186
00:14:13,490 --> 00:14:18,860
and so they take less cycles to run each instruction then maybe x86-64 is

187
00:14:18,950 --> 00:14:23,000
and this is just a trade-off that the designers chose to chose to undertake.

188
00:14:23,270 --> 00:14:29,640
There's nothing or you know there's no canonical reason

189
00:14:29,640 --> 00:14:36,090
why I reduced instruction set is better than you know a complex induction instruction set,

190
00:14:36,090 --> 00:14:40,110
they each have their own uses, and so on and so forth

191
00:14:40,110 --> 00:14:46,650
and another cool thing about RISC-V as opposed to x86 is that, this is open source,

192
00:14:47,740 --> 00:14:53,620
so one of the only open source instruction sets on the market,

193
00:14:53,620 --> 00:14:56,680
so that means anybody can develop a board for RISC-V

194
00:14:56,860 --> 00:15:01,570
and it came out of a research project from UC Berkeley

195
00:15:01,570 --> 00:15:03,850
and so that's kind of where was RISC-V started

196
00:15:03,940 --> 00:15:07,810
and since then it's been picked up and supported by a number of companies,

197
00:15:07,960 --> 00:15:09,640
you can find the list online,

198
00:15:09,640 --> 00:15:14,290
but yeah there's tons of big companies that are interested in supporting an open instruction set.

199
00:15:14,990 --> 00:15:19,460
And actually I think quite recently there was an announcement made by SiFive

200
00:15:19,460 --> 00:15:25,110
who are sort of the premier board manufacturer for RISC-V processors,

201
00:15:25,260 --> 00:15:30,780
that they will be releasing a board for personal computers

202
00:15:30,780 --> 00:15:35,580
that should extensively a RISC-V processor designed to run Linux for personal computers

203
00:15:35,850 --> 00:15:40,230
and I think that's been released in the last week or two, the announcement about it.

204
00:15:40,530 --> 00:15:43,800
So if you're if you're curious if your find yourself

205
00:15:43,800 --> 00:15:48,090
you know absolutely I want to use RISC-V after I finish 6.S081,

206
00:15:48,120 --> 00:15:51,330
hopefully by that time there will be a processor available

207
00:15:51,330 --> 00:15:53,520
that you can run Linux on your own computer.

208
00:15:55,080 --> 00:15:56,820
But even in your day-to-day lives,

209
00:15:56,820 --> 00:16:01,410
you're most likely using reduced instruction set even if you don't realize it,

210
00:16:01,410 --> 00:16:06,710
so the ARM assembly, so that's A R M,

211
00:16:07,000 --> 00:16:09,850
this is also a reduced instruction set。

212
00:16:11,030 --> 00:16:18,790
And ARM is implemented by Qualcomm, the the snapdragon series of processors.

213
00:16:19,060 --> 00:16:29,430
So if you have an android phone, you are most likely running a reduced instruction set.

214
00:16:30,200 --> 00:16:35,540
And even if you're using ios, ios I think I forget what the name of it,

215
00:16:35,540 --> 00:16:40,320
but Apple has some has some version of ARM,

216
00:16:40,320 --> 00:16:42,780
they also implement in their own processors

217
00:16:42,810 --> 00:16:47,730
that runs on ipads iphones and most mobile Apple devices,

218
00:16:47,940 --> 00:16:50,880
so reduced instruction sets are present all over the place,

219
00:16:50,880 --> 00:16:54,180
and if you're looking for a RISC-V in the real world,

220
00:16:54,870 --> 00:16:57,180
you know outside of your QEMU

221
00:16:58,170 --> 00:17:03,120
you'll be able to find that in like integrated devices.

222
00:17:03,890 --> 00:17:10,070
So it is present, it's not as certainly not as ubiquitous as something like x86-64

223
00:17:10,130 --> 00:17:11,810
but it's um.

224
00:17:12,540 --> 00:17:19,000
Yes I yes I think Apple is as Lucas just said I think Apple is moving Mac to ARM.

225
00:17:19,000 --> 00:17:20,410
I believe that's also the case,

226
00:17:20,560 --> 00:17:25,360
there's been in last year's definitely been a push towards reduced instruction sets.

227
00:17:25,960 --> 00:17:29,530
Given given how big the Intel ISA has gotten.

228
00:17:29,530 --> 00:17:31,930
And the reason why Intel ISA is so big is because

229
00:17:31,930 --> 00:17:35,230
they're very concerned with backwards compatibility.

230
00:17:35,230 --> 00:17:36,460
So if you write.

231
00:17:36,870 --> 00:17:41,100
A modern Intel processor can run the same instructions

232
00:17:41,130 --> 00:17:45,720
that Intel code from you know 30 40 years ago was was written,

233
00:17:45,720 --> 00:17:50,280
it so they don't really deprecate any instructions so that they maintain backwards compatibility,

234
00:17:50,400 --> 00:17:53,730
that RISC-V is more modern, so it's not a worry RISC-V is.

235
00:17:53,730 --> 00:17:57,000
Also if we jump back to those manuals,

236
00:17:57,180 --> 00:17:59,820
RISC-V is unique in that it's divided,

237
00:17:59,820 --> 00:18:06,650
we have what's called the base integer instruction set which all RISC-V processors, um.

238
00:18:07,340 --> 00:18:08,270
If we have fifteen.

239
00:18:08,270 --> 00:18:09,440
Gabriel asks in the chat,

240
00:18:09,440 --> 00:18:13,400
if we have 15,000 instructions, it nearly impossible to efficiently pipeline them,

241
00:18:13,580 --> 00:18:14,660
why do we need so many.

242
00:18:15,110 --> 00:18:18,350
Like I was saying we need so many for backwards compatibility reasons,

243
00:18:18,350 --> 00:18:22,340
it's up to you to decide you know whether you think that's super important.

244
00:18:22,340 --> 00:18:27,750
But many of those instructions I think a ton of them are also [] by simply instructions

245
00:18:27,750 --> 00:18:30,870
which are their own kind of special class of things.

246
00:18:31,850 --> 00:18:34,610
You won't I I I've never seen

247
00:18:34,610 --> 00:18:39,080
Intel assembly code that makes full uses full usage out of the 15,000 instructions,

248
00:18:39,080 --> 00:18:42,950
but mostly this comes from a from a need for backwards compatibility and simply.

249
00:18:43,520 --> 00:18:48,530
But like I was saying the RISC-V has a what's called the base integer instruction set,

250
00:18:49,030 --> 00:18:54,340
which contains all of the normal add multiply things,

251
00:18:54,400 --> 00:18:58,630
and then processors can choose to implement a number of other modules,

252
00:18:58,630 --> 00:19:00,400
which you can see along the side here,

253
00:19:00,400 --> 00:19:02,980
it's probably impossible to read on your screen,

254
00:19:02,980 --> 00:19:05,410
but for example if you want a processor,

255
00:19:05,470 --> 00:19:09,280
you know that supports standard extension for single precision floating point,

256
00:19:09,400 --> 00:19:11,260
then you can include the F module.

257
00:19:11,960 --> 00:19:16,430
And this makes it easier for RISC-V to support backwards compatibility,

258
00:19:16,430 --> 00:19:22,010
because if, you can just say what set of modules do I include and support

259
00:19:22,160 --> 00:19:24,290
and the compiler can choose.

260
00:19:24,290 --> 00:19:29,770
Then, compiler can say okay, you know this processor is telling me it supports these modules,

261
00:19:29,770 --> 00:19:32,110
so I can only compile this code with these modules.

262
00:19:33,760 --> 00:19:35,560
Okay, Bibik says

263
00:19:35,590 --> 00:19:39,160
it seems that the only advantage of using x86 instead of RISC-V processor

264
00:19:39,160 --> 00:19:40,480
is the kind of performance you can get,

265
00:19:40,630 --> 00:19:45,130
however, that performance comes as a massive cost and complexity and potential security,

266
00:19:45,190 --> 00:19:47,710
my question is why are we still using x86,

267
00:19:47,710 --> 00:19:49,480
instead of moving to something like RISC-V.

268
00:19:49,970 --> 00:19:54,560
Well, a big answer that the world is run on x86,

269
00:19:54,590 --> 00:19:58,160
for I I don't have a great answer for why.

270
00:19:58,370 --> 00:20:00,080
RISC-V is pretty modern too.

271
00:20:00,740 --> 00:20:05,210
So the world as a whole pretty much runs on x86,

272
00:20:05,210 --> 00:20:11,180
so if you suddenly start converting your processors to RISC-V,

273
00:20:11,180 --> 00:20:17,320
you run the risk of, you know losing support for a bunch of important things,

274
00:20:17,380 --> 00:20:22,420
also there are like Intel does do interesting things within their processors,

275
00:20:22,510 --> 00:20:27,310
like security wise, there are enclaves on Intel processors

276
00:20:27,310 --> 00:20:30,430
and there's things that they've been doing in recent years

277
00:20:30,430 --> 00:20:33,940
to try to try and give you extra added security

278
00:20:34,150 --> 00:20:37,240
and some of those instructions that Intel does implement

279
00:20:37,240 --> 00:20:42,940
which are hyper specific can be really efficient for certain, computations.

280
00:20:43,250 --> 00:20:45,140
And so they have so many instructions,

281
00:20:45,140 --> 00:20:48,870
there's often you know, a perfect instruction for a situation

282
00:20:48,870 --> 00:20:53,120
that may be more efficient than then what exists within RISC-V,

283
00:20:53,210 --> 00:20:55,220
but a more practical answer is

284
00:20:55,220 --> 00:20:56,630
at RISC-V is relatively new

285
00:20:56,630 --> 00:21:00,350
and we just don't know, nobody's really making processors for personal computers,

286
00:21:00,350 --> 00:21:03,260
I think the SiFive announcement is super recent,

287
00:21:03,440 --> 00:21:06,650
and they're kind of the first people to be doing that.

288
00:21:06,650 --> 00:21:12,420
so on a practical level, that and the inability to run all the software design for Intel

289
00:21:12,930 --> 00:21:14,970
is is my best answer.

290
00:21:16,210 --> 00:21:20,710
So we've been now chatting a little bit about assembly,

291
00:21:20,710 --> 00:21:25,690
so I just wanted to take a look at some actual assembly code.

292
00:21:26,600 --> 00:21:31,580
So here is the C code for what's below,

293
00:21:31,580 --> 00:21:34,100
so this is a simple function that has an accumulator,

294
00:21:34,190 --> 00:21:36,440
we loop from zero to n

295
00:21:36,440 --> 00:21:41,060
and we sum up all the numbers from from zero to n,

296
00:21:41,960 --> 00:21:43,550
and then return that value.

297
00:21:43,760 --> 00:21:48,140
And at its simplest level, this is the easiest kind of assembly,

298
00:21:48,140 --> 00:21:50,510
you can get out of compiling that program,

299
00:21:50,720 --> 00:21:56,930
if you actually go into your own computer and you write the C code and you try to compile it,

300
00:21:56,930 --> 00:22:00,470
you will end up with something that likely looks quite different.

301
00:22:01,420 --> 00:22:03,280
And that's true for a variety of reasons,

302
00:22:03,280 --> 00:22:06,760
we have a some of which we'll get to and some of which are compiler specific,

303
00:22:07,090 --> 00:22:11,980
so modern compilers make a large number of optimization,

304
00:22:13,510 --> 00:22:16,000
With it when they compile your C to assembly,

305
00:22:16,000 --> 00:22:18,160
and so your assembly instructions may look different,

306
00:22:18,280 --> 00:22:21,280
for instance while you're debugging in gdb

307
00:22:21,280 --> 00:22:25,750
you may come across something that tells you that it's some variable has been optimized out,

308
00:22:26,050 --> 00:22:30,010
and that means that the compiler decided it didn't need that variable

309
00:22:30,010 --> 00:22:33,370
and so that'll be gone effectively from the program,

310
00:22:33,610 --> 00:22:41,230
but yeah and it's at its most straightforward, we're moving value that's in a0 the t0,

311
00:22:41,260 --> 00:22:42,940
we're setting a0 to zero

312
00:22:42,940 --> 00:22:47,890
and then we are just adding what's in t0 to a0,

313
00:22:47,890 --> 00:22:51,340
for every iteration of a loop until t0 reaches zero.

314
00:22:52,500 --> 00:22:54,060
And that's all that's going on in this piece.

315
00:22:54,090 --> 00:22:55,410
Amir, your hands raised.

316
00:22:57,460 --> 00:23:01,900
I was wondering what .section .text .global do.

317
00:23:02,420 --> 00:23:05,810
A global means that you can include this from other files,

318
00:23:06,050 --> 00:23:12,860
so if we actually hop into, let's see defs.h.

319
00:23:14,220 --> 00:23:19,740
This is the file that you're will, if you aren't already, you will become quite familiar with,

320
00:23:19,740 --> 00:23:24,480
this includes basically all of the functions within the kernel that you may want to be using

321
00:23:24,870 --> 00:23:28,470
and within here you know we can see that,

322
00:23:28,470 --> 00:23:33,210
in my my file, I've included the definitions to these functions,

323
00:23:33,360 --> 00:23:40,950
and so that .global makes sure that, that these these functions can be called from other places

324
00:23:41,220 --> 00:23:43,530
and .text just says this is code.

325
00:23:44,220 --> 00:23:48,720
So if you recall from figure 3.4 in the book,

326
00:23:49,300 --> 00:23:54,510
so that's if we go to the book,

327
00:23:56,380 --> 00:24:00,790
and we go into page tables process address space,

328
00:24:00,970 --> 00:24:06,640
so in here in this diagram, that's the same thing is text, so just means code.

329
00:24:09,440 --> 00:24:10,250
That answer your question?

330
00:24:10,730 --> 00:24:11,630
Thanks.

331
00:24:14,810 --> 00:24:17,180
And so if we want to run, um.

332
00:24:17,670 --> 00:24:19,530
Let's say we have some assembly,

333
00:24:19,590 --> 00:24:24,900
also if you ever find yourself interested in what the kernel looks like,

334
00:24:25,140 --> 00:24:31,830
we can go inside the, after you compile you can look in the file kernel/kernel.asm.

335
00:24:32,800 --> 00:24:40,330
And this is the full kind of assembly for the kernel of xv6,

336
00:24:40,330 --> 00:24:44,410
and each of these numbers on the left here is a label

337
00:24:44,410 --> 00:24:48,160
that tells you where in memory, this in this instruction will be

338
00:24:48,490 --> 00:24:50,290
and that will come in quite handy.

339
00:24:50,670 --> 00:24:53,820
And so here is the here's the actual,

340
00:24:54,840 --> 00:24:59,910
use the actual assembly code and you can see the labels for the functions and whether declared,

341
00:24:59,910 --> 00:25:04,380
so this is this is, can be really really useful as we're debugging code

342
00:25:04,380 --> 00:25:06,900
and hopefully I'll be able to show that in a second.

343
00:25:07,540 --> 00:25:12,370
But for now we'll jump back to this first function, sum_to

344
00:25:12,550 --> 00:25:16,750
and we'll just see how we can examine that inside of gdb,

345
00:25:16,780 --> 00:25:21,460
so the first step is I have my two windows here.

346
00:25:21,670 --> 00:25:24,670
What's the difference between .asm .S files?

347
00:25:25,170 --> 00:25:29,310
Um, not a hundred percent certain,

348
00:25:29,430 --> 00:25:30,780
they're both assembly,

349
00:25:30,780 --> 00:25:36,120
I think the .asm file includes a bunch of extra annotations that aren't included in .S,

350
00:25:36,390 --> 00:25:40,570
so usually when you compile your c code to .S,

351
00:25:40,570 --> 00:25:44,590
you'll end up with something that doesn't include all those line numbers and things like that.

352
00:25:44,590 --> 00:25:47,700
So, if you're curious about how we get asm file,

353
00:25:47,700 --> 00:25:52,530
I think the makefile will tell you the exact steps used to get that.

354
00:25:55,960 --> 00:26:00,460
And so if we're in our terminal, we have our two two windows,

355
00:26:00,580 --> 00:26:05,800
so the first thing to do is of course get QEMU up and running.

356
00:26:06,630 --> 00:26:10,110
So gdb, started within gdb mode,

357
00:26:10,110 --> 00:26:13,470
so now we're frozen here and then we can start gdb,

358
00:26:15,990 --> 00:26:20,220
and what what what what professor Frans showed last week.

359
00:26:20,550 --> 00:26:22,980
Which I think some people were excited,

360
00:26:22,980 --> 00:26:26,280
you typed UI, enable you get this nice window

361
00:26:26,280 --> 00:26:30,150
which is empty for now but will come in quite useful as you're debugging,

362
00:26:30,390 --> 00:26:32,010
so we can set a break point

363
00:26:32,010 --> 00:26:37,170
and I should note that all this code is living inside the kernel, none of this is in user space,

364
00:26:37,440 --> 00:26:40,170
so we don't have any of those annoying problems setting break points,

365
00:26:40,410 --> 00:26:45,840
so I can set a break point in the function sum_to and then just continue running.

366
00:26:47,300 --> 00:26:55,880
Run that function and now, so the first window that you see in tui is the source window.

367
00:26:57,270 --> 00:27:03,540
Yes, as David is saying those those numbers on the left of kernel .asm are really useful

368
00:27:03,540 --> 00:27:08,130
when you're debugging things and you get an address it'll tell you,

369
00:27:08,130 --> 00:27:09,300
so you can see now,

370
00:27:09,330 --> 00:27:14,560
even here we can see that the programs of PC here in gdb, is the program counter,

371
00:27:14,560 --> 00:27:18,220
so we can see this address eight zero zero so on and so forth.

372
00:27:18,540 --> 00:27:24,240
If we go into kernel.asm and we search for that specific address,

373
00:27:24,270 --> 00:27:25,890
we can see that it's the,

374
00:27:26,860 --> 00:27:29,620
um, it comes up twice because the function call,

375
00:27:29,740 --> 00:27:33,970
but if we look here, this is that address, it's the top of the sum_to function.

376
00:27:34,760 --> 00:27:37,580
So if you see any time you see one of these,

377
00:27:37,610 --> 00:27:45,180
um all the kernel addresses will look something like a 0x8000 some numbers.

378
00:27:46,240 --> 00:27:50,290
Those addresses you can jump straight into kernel.asm

379
00:27:50,290 --> 00:27:54,190
and find the exact line of assembly where the problem is occurring,

380
00:27:54,190 --> 00:27:56,050
and then you can set your break points accordingly,

381
00:27:56,410 --> 00:28:00,700
but for now, the top window in tui is source,

382
00:28:00,700 --> 00:28:07,390
and if we want to look at specifically the assembly we can do layout in gdb asm,

383
00:28:07,390 --> 00:28:11,920
and that'll give us all of the assembly instructions and,

384
00:28:11,920 --> 00:28:14,830
we can also look at the registers if we type layout reg,

385
00:28:14,830 --> 00:28:17,380
we'll get assembly and registers

386
00:28:17,620 --> 00:28:20,590
and if you find yourself what to scroll through things,

387
00:28:21,410 --> 00:28:24,350
now that we have three windows, we need to specify which one is focused,

388
00:28:24,350 --> 00:28:27,260
so if I want to look for all the registers, I'm going to focus reg.

389
00:28:28,000 --> 00:28:30,220
And now my focus is on the register window

390
00:28:30,220 --> 00:28:34,960
so I move the arrow keys or scroll you'll start scrolling that window.

391
00:28:35,660 --> 00:28:38,810
Now we can focus on the assembly window.

392
00:28:39,580 --> 00:28:41,800
And once we're here, we can see all of the things,

393
00:28:42,040 --> 00:28:45,940
so let's see, we can see in the registry register window,

394
00:28:45,940 --> 00:28:48,490
we can see that t0 contains this value,

395
00:28:48,550 --> 00:28:51,250
we can see that a0 contains this value.

396
00:28:51,840 --> 00:28:55,140
And as we step through the assembly, we can watch,

397
00:28:55,170 --> 00:29:00,150
say OK, t0 just got the value of a0 which was five,

398
00:29:00,150 --> 00:29:03,060
and it's nicely highlighted the register that's changed.

399
00:29:03,280 --> 00:29:09,640
Here and we can just, keep remember if we push enter we get the most recently executed instructions,

400
00:29:09,640 --> 00:29:12,880
so we can go through, we set a0 to zero

401
00:29:13,030 --> 00:29:19,270
and now we can just kind of watch ourselves go through this loop and some of the values,

402
00:29:20,020 --> 00:29:22,840
and then this is like a complete you know [] function.

403
00:29:23,630 --> 00:29:27,050
Then continue and live our lives

404
00:29:27,050 --> 00:29:31,700
and if you're ever curious about what kind of break points you've set

405
00:29:31,700 --> 00:29:33,800
or you lose track of what you were doing,

406
00:29:33,980 --> 00:29:37,940
if you type info break or breakpoints,

407
00:29:38,060 --> 00:29:41,120
you can see all of the break points that you set in your code,

408
00:29:41,390 --> 00:29:45,410
and you can even see okay, this break point has already been hit one time

409
00:29:45,620 --> 00:29:48,560
and you get lots of useful information doing that.

410
00:29:49,410 --> 00:29:54,390
If you don't want to have the register window, but you do want to look at the registers,

411
00:29:54,510 --> 00:29:58,110
info reg or info registers or i registers

412
00:29:58,110 --> 00:30:04,130
or any of the numerous gdb shortenings will bring up the register window.

413
00:30:05,900 --> 00:30:10,400
So with that is there any are there any questions about gdb?

414
00:30:10,640 --> 00:30:15,320
Simple ones, I know it's been, there's been lots of post some [] about it,

415
00:30:15,320 --> 00:30:18,380
so now's a good time to just ask some straightforward,

416
00:30:18,380 --> 00:30:21,890
well I'll be showing more usage as gdb.

417
00:30:22,100 --> 00:30:24,500
What command did you use to open the multiple windows?

418
00:30:24,500 --> 00:30:25,730
So I use tmux,

419
00:30:25,820 --> 00:30:27,800
so I can show just from scratch,

420
00:30:27,920 --> 00:30:32,840
if we go here, I open a new terminal, so here's just a blank terminal.

421
00:30:33,730 --> 00:30:36,580
If you type tmux and this is available on Athena.

422
00:30:37,150 --> 00:30:42,000
Um, I'll answer the next question in a second,

423
00:30:42,180 --> 00:30:46,470
so now I'm in tmux, which you can tell by this green bar at the bottom

424
00:30:46,650 --> 00:30:52,230
and if you want to get so there's a couple ways you can do multiple windows in tmux,

425
00:30:52,230 --> 00:30:55,670
if you're, so you can type control-b c

426
00:30:55,670 --> 00:31:00,440
and I know that sometimes if you're used to using emacs that will make a lot of sense,

427
00:31:00,440 --> 00:31:03,950
but normal people who don't use emacs

428
00:31:04,010 --> 00:31:09,260
that's hitting control and then b and then hitting c on its own afterwords,

429
00:31:09,320 --> 00:31:11,000
that will get you a second window

430
00:31:11,000 --> 00:31:14,480
which you can then navigate between with control b and then p,

431
00:31:14,540 --> 00:31:17,750
control b and n to go previous and next.

432
00:31:17,810 --> 00:31:20,930
Yeah and David just posted that tmux cheatsheet which is useful

433
00:31:21,350 --> 00:31:22,850
and if you want to split the windows,

434
00:31:22,850 --> 00:31:28,800
I think it's control b and then the percent sign will split them, um, vertically,

435
00:31:28,800 --> 00:31:35,050
and then sign a double control b and double quote will split them horizontally,

436
00:31:35,800 --> 00:31:36,820
and so that's how we get them.

437
00:31:36,820 --> 00:31:42,370
If we're in this state, we can use control b and o to jump between our windows,

438
00:31:42,940 --> 00:31:45,670
so that's that's how I got multiple windows.

439
00:31:45,670 --> 00:31:47,410
Yeah [].

440
00:31:47,970 --> 00:31:53,610
And then Ahmed asked why is displaying assembly addresses again instead of C line numbers.

441
00:31:53,670 --> 00:31:56,790
So because the function.

442
00:31:58,010 --> 00:32:00,920
So if we go back to the assembly function,

443
00:32:00,980 --> 00:32:04,220
this is implemented entirely in assembly and not at all in C

444
00:32:04,340 --> 00:32:07,490
and so there just aren't any associated C line numbers for this.

445
00:32:07,850 --> 00:32:12,410
If we were to set a break point,

446
00:32:12,560 --> 00:32:15,560
so if you type delete you will delete all your break points,

447
00:32:15,980 --> 00:32:20,510
so I cleared the old one if I now set a break point in demo one,

448
00:32:20,510 --> 00:32:24,680
so that's a C break point and continue and run this,

449
00:32:24,740 --> 00:32:29,300
now if I go here and type layout split I'll get the C and the assembly.

450
00:32:29,970 --> 00:32:33,990
Um, or if I just want to C source, I can do layout source and I'll just get to C.

451
00:32:35,440 --> 00:32:37,090
So that's that's what's going on,

452
00:32:37,090 --> 00:32:39,040
it's just a quirk of the fact

453
00:32:39,040 --> 00:32:42,580
that this doesn't have associated C code and so we don't see C line numbers.

454
00:32:46,270 --> 00:32:52,720
Any other any other questions about gdb tmux, and that sort of thing.

455
00:32:53,080 --> 00:32:55,360
So layout split is the one that you use to

456
00:32:55,360 --> 00:32:59,200
bring up this extra window of the source and assembling so on right.

457
00:32:59,200 --> 00:33:04,840
Yes yes, so layout if you do layout split that'll get you source and assembly,

458
00:33:04,840 --> 00:33:06,730
layout source will get you just source,

459
00:33:06,730 --> 00:33:08,410
asm will get you just assembly.

460
00:33:08,530 --> 00:33:12,160
And the registers are their own thing where you type layout, reg I think.

461
00:33:12,160 --> 00:33:14,540
Yeah, that will bring up the registers,

462
00:33:14,540 --> 00:33:17,600
but unfortunately I don't know of a way

463
00:33:17,600 --> 00:33:21,780
to get to register the assembly and the C code all at the same time

464
00:33:21,780 --> 00:33:24,180
outside of using info reg with layout split.

465
00:33:24,990 --> 00:33:30,150
I have a question, so when we set the back breakpoint at line right.

466
00:33:30,180 --> 00:33:30,690
Um,

467
00:33:31,090 --> 00:33:38,290
it displays the address of the like in this case breakpoint to add to 0x80006354,

468
00:33:39,250 --> 00:33:46,900
what any instruction might have multiple, any line of code in C might have multiple instructions,

469
00:33:46,960 --> 00:33:49,090
so which one does show.

470
00:33:49,210 --> 00:33:50,320
I think it shows the first one.

471
00:33:51,510 --> 00:33:56,670
And it's tu-, for the person who asked to start tui,

472
00:33:56,670 --> 00:34:00,210
it's I think it's tui enable, not enabled tui, sorry.

473
00:34:01,070 --> 00:34:04,580
And I think yeah.

474
00:34:05,570 --> 00:34:05,630
Yeah.

475
00:34:08,450 --> 00:34:14,450
Yeah again there's a hundred cheatsheets out here for gdb and for tmux,

476
00:34:14,450 --> 00:34:16,370
as well so if you ever find yourself lost.

477
00:34:16,430 --> 00:34:23,400
I t-, gdb even has its own inbuilt it's own thing called apropos,

478
00:34:23,550 --> 00:34:26,490
so if you look for apropos tui,

479
00:34:26,520 --> 00:34:31,980
it'll actually show you all of the commands that involve tui.

480
00:34:33,310 --> 00:34:39,460
So yeah, this can be quite useful, but it can also be a little bit overwhelming.

481
00:34:39,820 --> 00:34:43,780
If you do apropos -v that it will give you even more information I think.

482
00:34:44,610 --> 00:34:49,160
Um I don't remember, I I don't use it often myself.

483
00:34:49,160 --> 00:34:53,870
But if you do find or if you forget the exact way to type the command in gdb

484
00:34:53,870 --> 00:34:54,860
and you don't feel like google

485
00:34:54,860 --> 00:34:59,300
and apropos's will will often be able to find exactly what you're looking for,

486
00:34:59,300 --> 00:35:01,520
in addition to a whole bunch of stuff you are looking for.

487
00:35:04,260 --> 00:35:08,430
Yeah, so this is actually quite useful, gdb is extremely well documented as well,

488
00:35:08,460 --> 00:35:13,980
so um, yeah, if you ever find yourself lost, you know, google is your friend.

489
00:35:16,800 --> 00:35:22,740
So now that we've kind of been over assembly and and RISC-V and these sort of things,

490
00:35:22,800 --> 00:35:25,500
I want to dive a little bit more into the specifics

491
00:35:25,740 --> 00:35:30,810
of what you you really need to know for the lab coming up

492
00:35:30,990 --> 00:35:33,900
and also it'll be a little bit of review from the document

493
00:35:33,900 --> 00:35:41,710
that you've of course, diligent students read through thoroughly in preparation for this lecture.

494
00:35:42,700 --> 00:35:47,860
Um, so yeah, this table will of course be a wildly familiar to you all

495
00:35:47,860 --> 00:35:52,270
and from from both 6.004 and from what you've read,

496
00:35:52,360 --> 00:35:54,670
and this is the table of registers

497
00:35:54,670 --> 00:36:03,630
and registers are little locations on the CPU around the processor predefined

498
00:36:03,630 --> 00:36:07,410
that it can use to store values and this is important,

499
00:36:07,410 --> 00:36:11,340
because assembly operations if we remember from the assembly code,

500
00:36:11,490 --> 00:36:15,360
the assembly doesn't operate on memory, it operates on register,

501
00:36:15,360 --> 00:36:20,580
so when we do add when we do subtract we're operating on registers.

502
00:36:21,000 --> 00:36:25,320
And so what you often see as the pattern for writing assembly

503
00:36:25,320 --> 00:36:32,080
is will have some kind of a load, so we'll load some value to a register.

504
00:36:33,030 --> 00:36:37,320
And that value can be from memory, or it can be from another register.

505
00:36:38,340 --> 00:36:43,020
And, and here referring to load in general, not the load instruction.

506
00:36:43,420 --> 00:36:49,410
And then we'll operate, so we'll perform some operation on the register,

507
00:36:49,410 --> 00:36:53,100
and then if we care about the result of that operation outside the return address,

508
00:36:53,280 --> 00:37:01,310
we will, we'll store that register to somewhere, to some locate,

509
00:37:01,310 --> 00:37:08,000
they will store that register to some location in memory or to another register

510
00:37:08,210 --> 00:37:10,580
and that's generally the way things work

511
00:37:10,580 --> 00:37:17,300
and registers are the absolute fastest way to perform any sort of calculation or to access any value

512
00:37:17,300 --> 00:37:20,540
and that's why it's important to use them

513
00:37:20,540 --> 00:37:24,590
and also why we prefer using registers overusing memory,

514
00:37:24,590 --> 00:37:28,340
so if you remember from the reading when we call functions

515
00:37:28,340 --> 00:37:31,490
so you can see here that registers a0 to seven.

516
00:37:32,450 --> 00:37:40,610
And in general when we speak about registers we we will be referring to them by their ABI name,

517
00:37:40,820 --> 00:37:43,760
not only is it less confusing, it's just a standard

518
00:37:43,760 --> 00:37:45,920
and it's also the way that you'll write assembly code,

519
00:37:45,950 --> 00:37:50,920
this, you know, these these actual numbers are not super important,

520
00:37:50,980 --> 00:37:58,360
the only case where it does matter is for the compressed version of RISC-V instructions

521
00:37:58,360 --> 00:38:02,350
and if you want to know more about that, feel free to read up about it,

522
00:38:02,350 --> 00:38:07,230
the basic idea is that RISC-V, normal instructions are 64 bits,

523
00:38:07,230 --> 00:38:10,650
but there's also a compressed version, which instructions are sixteen bits

524
00:38:10,830 --> 00:38:17,220
and we use less registers and the registers we use in that case are eight through fifteen,

525
00:38:17,220 --> 00:38:19,050
those are the registers that are available to us.

526
00:38:19,170 --> 00:38:24,120
So I think somebody had a question about why is this s1 register x9,

527
00:38:24,120 --> 00:38:27,960
why is it, separated from all of the other's registers?

528
00:38:28,050 --> 00:38:30,990
And my guess is that that's why,

529
00:38:31,800 --> 00:38:37,050
that we separated from all the other ones because it's available in compressed instruction mode,

530
00:38:37,080 --> 00:38:39,120
whereas s2 to eleven or not.

531
00:38:40,220 --> 00:38:42,470
And so that's the idea, that's that's a compress,

532
00:38:42,470 --> 00:38:48,030
but outside of that register will be referred to by their ABI name

533
00:38:48,060 --> 00:38:51,180
and so a0 to a7 are used for function arguments,

534
00:38:51,270 --> 00:38:52,650
but if we have a function that takes

535
00:38:52,650 --> 00:38:57,030
more than the eight arguments that those registers give us access to,

536
00:38:57,470 --> 00:38:59,000
we do need to use memory

537
00:38:59,000 --> 00:39:01,370
but that's, this is kind of an illustration of the fact

538
00:39:01,370 --> 00:39:03,920
that we don't want to use memory when we can use registers.

539
00:39:04,100 --> 00:39:07,490
We only we only use a memory, we have to.

540
00:39:08,790 --> 00:39:11,490
And this, this column here, the saver column,

541
00:39:11,670 --> 00:39:14,070
this is also extremely important

542
00:39:14,070 --> 00:39:17,400
when we're discussing registers caller versus callee saved.

543
00:39:17,760 --> 00:39:23,610
And the terms are I confuse them regularly,

544
00:39:23,610 --> 00:39:25,950
caller and callee, the only differ by one letter,

545
00:39:26,010 --> 00:39:29,700
the easiest way that I've found to remember them is

546
00:39:29,700 --> 00:39:40,850
that caller saved registers are not preserved, across a function call,

547
00:39:42,190 --> 00:39:47,850
so and callee saved registers are preserved.

548
00:39:49,580 --> 00:39:52,900
What I mean by this, is that,

549
00:39:54,500 --> 00:40:01,460
a caller saved register can be overwritten by the function,

550
00:40:01,460 --> 00:40:04,370
so let's say I have function a which calls function b,

551
00:40:04,700 --> 00:40:08,690
any registers being used by function a that are caller saved.

552
00:40:08,880 --> 00:40:12,240
Call function b can overwrite when it gets called,

553
00:40:12,420 --> 00:40:16,080
and I think a good illustration of this is the return address.

554
00:40:16,320 --> 00:40:20,100
Because you know you can see that the return addresses caller saved.

555
00:40:21,170 --> 00:40:25,640
And that's important because every function needs to use the return address,

556
00:40:25,730 --> 00:40:27,590
so when a calls b,

557
00:40:27,590 --> 00:40:32,480
it's important that b is able to overwrite the value in the return address,

558
00:40:32,510 --> 00:40:34,130
hence why its caller saved.

559
00:40:34,340 --> 00:40:39,440
And callee saved registers are just are convention that we use,

560
00:40:39,620 --> 00:40:42,800
the frame pointer is important for that reason.

561
00:40:43,030 --> 00:40:46,330
And those are preserved across function calls,

562
00:40:46,330 --> 00:40:48,850
so basically any register that is caller saved,

563
00:40:49,000 --> 00:40:52,390
the function that is making the call needs to worry about those registers,

564
00:40:52,540 --> 00:40:54,070
and if they're callee saved,

565
00:40:54,070 --> 00:40:58,930
the function that is being called needs to worry about preserving the value in those registers.

566
00:40:59,830 --> 00:41:03,280
And again, you know I I regularly confuse the two

567
00:41:03,280 --> 00:41:10,200
and find myself returning to this table, to remind myself about what they do.

568
00:41:11,160 --> 00:41:14,860
And so, You know you if you remember from the reading,

569
00:41:14,890 --> 00:41:18,280
all of these registers are 64 bits wide,

570
00:41:18,280 --> 00:41:21,100
so they have 64 places where we can put things

571
00:41:21,250 --> 00:41:28,660
and the various data types are made to fit into those 64 bits based on the calling convention,

572
00:41:28,660 --> 00:41:30,400
so if we have a 32 bit integer,

573
00:41:30,490 --> 00:41:33,550
depending on how it's whether or not it's an extended,

574
00:41:33,610 --> 00:41:36,490
you know will either add zeros or ones to the front of that integer,

575
00:41:36,490 --> 00:41:39,760
in order to make it 64 bits to put in these registers.

576
00:41:40,480 --> 00:41:41,860
So before we move on,

577
00:41:41,950 --> 00:41:48,010
does anybody have questions about registers or things of that nature.

578
00:41:57,950 --> 00:41:59,360
I have a question,

579
00:41:59,360 --> 00:42:03,770
can you have a-, can you put a return value in a1.

580
00:42:04,790 --> 00:42:06,500
Yes, that's a good question.

581
00:42:06,500 --> 00:42:11,090
So, I think in theory you can,

582
00:42:11,120 --> 00:42:14,960
the reason why we say a0 to a1 is

583
00:42:14,960 --> 00:42:18,770
if a function returns a long long which is 128 bits,

584
00:42:18,770 --> 00:42:24,560
so if you remember from the reading if a function argument is a hundred is more than a pointer-word.

585
00:42:24,880 --> 00:42:28,060
We're, when we refer to word sign, we're saying 64 bits,

586
00:42:28,210 --> 00:42:31,390
so if we have something that is twice the size of a pointer-word,

587
00:42:32,350 --> 00:42:35,170
we can put that in a register pair

588
00:42:35,320 --> 00:42:38,590
and so the same convention holds true for return addresses

589
00:42:38,590 --> 00:42:42,490
where if we have something that's the size of twice pointer-word,

590
00:42:42,520 --> 00:42:46,240
we can stick that in a0 and a1 and use that as the return address,

591
00:42:46,330 --> 00:42:49,270
I think you'll run into problems if you only try to put something in a1.

592
00:42:49,880 --> 00:42:51,050
Makes sense, thanks.

593
00:42:55,040 --> 00:42:59,510
Why are the registers not like continuous,

594
00:42:59,510 --> 00:43:03,860
so why is like a0 and one separate from?

595
00:43:04,680 --> 00:43:06,480
Sorry no that's a bad example,

596
00:43:06,480 --> 00:43:09,450
that's why is s1 separate from s2,

597
00:43:09,450 --> 00:43:12,540
why the a in between like is there any point in that.

598
00:43:13,180 --> 00:43:15,910
Yeah, so, I mentioned this briefly earlier,

599
00:43:15,910 --> 00:43:20,080
but there is a compressed, this is a guess I don't I don't know for sure,

600
00:43:20,230 --> 00:43:24,760
but there's a compressed version of the RISC-V instructions

601
00:43:25,000 --> 00:43:28,450
which are 16 bits in size as opposed to 64.

602
00:43:28,920 --> 00:43:34,170
And you would use that to try to make your code takes less space in memory,

603
00:43:34,410 --> 00:43:41,850
and when you use those 16 bit instructions, you only have accesses to registers 8 through 15,

604
00:43:42,000 --> 00:43:45,750
so I think s1 is separate from s2 to eleven,

605
00:43:45,870 --> 00:43:47,790
because they want to make it clear,

606
00:43:47,790 --> 00:43:53,630
that s1 is available to you in the compressed instruction mode, whereas two to eleven aren't.

607
00:43:54,500 --> 00:44:00,120
And the reason you know I don't know why they picked x, x8 to 15,

608
00:44:00,240 --> 00:44:03,090
but I suspect that just looked at a bunch of code

609
00:44:03,090 --> 00:44:05,400
and we're like these are the most commonly used registers.

610
00:44:17,140 --> 00:44:18,310
Any other questions?

611
00:44:20,840 --> 00:44:22,490
I had a question.

612
00:44:23,630 --> 00:44:26,960
Besides the frame pointer, the stack pointer at all,

613
00:44:27,140 --> 00:44:32,120
I don't know why we would need more callee saved registers.

614
00:44:32,460 --> 00:44:34,590
But we do have like a bunch of them.

615
00:44:35,420 --> 00:44:40,070
Yeah, the s1 to elevens those are just for,

616
00:44:40,070 --> 00:44:44,120
I believe use their freedom for the compiler or the programmer to use,

617
00:44:44,360 --> 00:44:47,390
so there may be there are certain cases where you want,

618
00:44:47,600 --> 00:44:52,790
you want to guarantee that something is still around after after your function,

619
00:44:52,790 --> 00:44:58,220
call the compiler can choose to use s1 to eleven to do that.

620
00:44:58,760 --> 00:45:04,450
Um, I don't have like on hand, a specific example of where that's useful,

621
00:45:04,570 --> 00:45:06,640
but, I'm sure it shows up,

622
00:45:07,330 --> 00:45:09,940
where having a callee saved value is important.

623
00:45:14,390 --> 00:45:19,220
But these are basically basically a programmer or compiler's choice to use s1 to eleven.

624
00:45:22,420 --> 00:45:27,040
I should note that these floating point registers their floating point, arithmetic,

625
00:45:28,480 --> 00:45:31,090
as far as I'm aware, you won't see them in this class,

626
00:45:31,360 --> 00:45:33,790
and so you don't really need to worry about them.

627
00:45:38,550 --> 00:45:45,140
Okay, so we started talking a little bit about function calls,

628
00:45:45,440 --> 00:45:53,820
and so with that I want to move us into discussion of the stack.

629
00:45:54,390 --> 00:45:59,420
So this is This is we're talking about the stack,

630
00:45:59,840 --> 00:46:04,610
and the stacked, if you've seen it like before,

631
00:46:04,640 --> 00:46:07,730
the reason why the stack is important is

632
00:46:07,850 --> 00:46:13,030
it's what keeps our functions organized and sane,

633
00:46:13,060 --> 00:46:18,490
and it's what allows what makes functions work, it's what makes return work

634
00:46:18,490 --> 00:46:25,150
and it's also where often we will find ourselves saving our registers and things like that.

635
00:46:26,330 --> 00:46:27,050
Um.

636
00:46:29,440 --> 00:46:39,310
So, here, I've given just a pretty simple layout of what the stack looks like,

637
00:46:39,340 --> 00:46:48,100
and so each of these boxes here is what we refer to as a stack frame.

638
00:46:49,070 --> 00:46:54,860
And every time we get, which are generated by function calls.

639
00:46:59,890 --> 00:47:03,190
Every time we call a function

640
00:47:03,220 --> 00:47:07,360
that function makes for itself its own stack frame

641
00:47:07,510 --> 00:47:14,350
and which it uses itself and does that by moving around the stack pointer,

642
00:47:14,530 --> 00:47:16,330
so here's the stack pointer,

643
00:47:16,360 --> 00:47:19,630
and this is it's very important to remember.

644
00:47:19,780 --> 00:47:29,070
With stacks, we start from high addresses and we grow downwards. Too low addresses,

645
00:47:29,070 --> 00:47:31,470
so the stack grows down always.

646
00:47:31,860 --> 00:47:38,370
And so you'll see that the arithmetic for stack pointer is usually done via subtraction,

647
00:47:38,370 --> 00:47:41,020
we want to make a new stack frame in assemblies,

648
00:47:41,020 --> 00:47:42,430
the stack grows downwards.

649
00:47:43,380 --> 00:47:48,780
And stack frames for function contain I see registers local variables,

650
00:47:48,930 --> 00:47:51,030
also like I was saying,

651
00:47:51,030 --> 00:47:56,190
if you run out of argument registers additional arguments will show up on the stack,

652
00:47:56,370 --> 00:47:59,460
and so not as stack frames are not all the same size,

653
00:47:59,460 --> 00:48:01,980
even though they are in this diagram, that's not the case,

654
00:48:02,010 --> 00:48:04,920
different functions have different numbers of local variables

655
00:48:04,920 --> 00:48:07,980
different registers so on and so forth,

656
00:48:08,070 --> 00:48:09,900
and so stack frames will be different sizes.

657
00:48:09,900 --> 00:48:12,570
But the two things that you can definitely count on,

658
00:48:12,820 --> 00:48:17,650
which are important is that the return address will always be on the first thing

659
00:48:17,650 --> 00:48:20,950
and the frame pointer, the previous frames frame pointer

660
00:48:20,950 --> 00:48:24,700
is also going to show up on the stack at a predictable location,

661
00:48:24,970 --> 00:48:29,330
so the two important registers here are sp,

662
00:48:29,330 --> 00:48:33,980
which you know as we discussed is used for, this is the bottom of the stack.

663
00:48:35,780 --> 00:48:38,990
Or generally you know it's the location of the stack,

664
00:48:39,200 --> 00:48:49,480
and then fp is are also important register and this points to the top of current frame.

665
00:48:50,790 --> 00:48:51,780
And this is important,

666
00:48:51,780 --> 00:48:56,220
because that means that the return address and the previous fp

667
00:48:56,250 --> 00:49:01,770
will always be at a fixed location from the current frame pointer.

668
00:49:02,400 --> 00:49:05,790
So that means that if I want to find my return address

669
00:49:05,790 --> 00:49:07,650
or I want to find the previous frame,

670
00:49:07,890 --> 00:49:12,930
I can always get to those values by looking at the current frame pointer

671
00:49:13,650 --> 00:49:16,800
and the reason why we store the previous frame pointer is

672
00:49:16,800 --> 00:49:18,900
to allow us to jump back,

673
00:49:18,900 --> 00:49:22,680
so once this function returns we can move this into fp

674
00:49:22,710 --> 00:49:23,790
and all of a sudden

675
00:49:23,790 --> 00:49:30,090
fp again will go from pointing to this, this stack frame, to now pointing to this stack frame.

676
00:49:30,450 --> 00:49:34,050
So we use the frame pointer to manipulate our stack frames

677
00:49:34,050 --> 00:49:40,110
and make sure we're always going to one corresponding to the correct function.

678
00:49:41,040 --> 00:49:43,920
And that's that's kind of how things how things are done

679
00:49:44,040 --> 00:49:50,830
and the these pieces of the stack need to be created by assembly

680
00:49:50,920 --> 00:49:56,230
and so everything's everything in that calling conventions document that you read about

681
00:49:56,260 --> 00:50:00,850
that's all enforced by effectively by the compiler,

682
00:50:00,850 --> 00:50:06,970
so the compiler adheres to the calling convention and it's what generates the stack frame,

683
00:50:06,970 --> 00:50:10,900
it generates the assembly code that makes our stack frames look correct,

684
00:50:11,080 --> 00:50:18,570
so often at the top of a function, you'll see what's called a function prologue.

685
00:50:21,300 --> 00:50:24,180
And then there will be the body of the function

686
00:50:24,450 --> 00:50:29,410
and then there will be an epilogue that shows up after that,

687
00:50:29,470 --> 00:50:37,240
so this is kind of like, when an assembly function will often look like.

688
00:50:37,360 --> 00:50:38,920
And we'll take a look at,

689
00:50:39,100 --> 00:50:43,660
now, so here I have another function sum_then_double,

690
00:50:43,660 --> 00:50:49,270
so you'll note that [] that sum_to not have any of these things

691
00:50:49,270 --> 00:50:51,940
that it it should if it was a proper function

692
00:50:52,060 --> 00:50:54,220
and this works fine because it's simple enough,

693
00:50:54,220 --> 00:50:57,100
so it does all of its computations on a0

694
00:50:57,100 --> 00:51:01,380
and so things are, things are good and we're also not it's a it's a leaf function,

695
00:51:01,590 --> 00:51:04,350
so, you'll see if you've seen the term leaf function

696
00:51:04,350 --> 00:51:06,510
that's a function that doesn't call another function,

697
00:51:06,900 --> 00:51:08,910
and the functions are special in that

698
00:51:08,910 --> 00:51:15,120
they don't need to worry about saving their own return address

699
00:51:15,120 --> 00:51:18,360
or saving really any of the caller saved registers.

700
00:51:18,650 --> 00:51:23,150
Because they're going to they're not going to make another function call,

701
00:51:23,150 --> 00:51:25,160
so they don't have to be as careful,

702
00:51:25,400 --> 00:51:29,060
sum_then_double on the other hand is not a leaf function,

703
00:51:29,060 --> 00:51:32,720
so you can see here, it calls sum_to.

704
00:51:33,530 --> 00:51:37,340
And so it does need to include that that prologue,

705
00:51:37,340 --> 00:51:42,440
and so we see here that we are subtracting 16 from the stack pointer,

706
00:51:42,470 --> 00:51:44,780
so we're making space on our stack,

707
00:51:44,990 --> 00:51:49,850
we're storing the return address for sum_then_double on the stack,

708
00:51:49,970 --> 00:51:52,100
and then we make our call to sum_to,

709
00:51:52,340 --> 00:51:55,220
and after that all this function does is it calls sum_to

710
00:51:55,220 --> 00:52:00,420
and then doubles the result, doubles the result turn by sum_to,

711
00:52:00,600 --> 00:52:03,060
and here you can see the epilogue,

712
00:52:03,060 --> 00:52:07,970
so we load the return address back in to ra

713
00:52:08,060 --> 00:52:12,410
and delete our stack frame and then jump out of the function.

714
00:52:13,850 --> 00:52:17,690
And so we can run that to make sure it does what we would expect.

715
00:52:20,870 --> 00:52:22,010
Go here.

716
00:52:24,160 --> 00:52:27,910
We can run, so if we run demo2 or demo1

717
00:52:27,910 --> 00:52:30,280
we got the result of fifteen for the sum,

718
00:52:30,280 --> 00:52:33,730
and I'll tell you that demo2 just, just call sum_then_double

719
00:52:33,730 --> 00:52:39,580
and indeed you know it happily doubles the sum returned by sum_to.

720
00:52:40,600 --> 00:52:44,140
And so a question I have for anybody

721
00:52:45,010 --> 00:52:51,130
what happens if we delete this prologue and epilogue,

722
00:52:51,250 --> 00:52:55,900
what happens if we just have this as our function, sum_then_double.

723
00:52:55,900 --> 00:52:57,460
Can anybody predict what's going to happen.

724
00:53:01,590 --> 00:53:07,720
I mean one thing is that sum_then_double wouldn't know the return address that it should return to,

725
00:53:07,930 --> 00:53:14,170
so upon calling sum_to, that's going to override the return address to be sum_then_double's,

726
00:53:14,170 --> 00:53:18,260
at the end of sum_then_double, it's not going to return to its original caller.

727
00:53:19,330 --> 00:53:23,620
Yeah exactly and we can see that that's what happens.

728
00:53:23,650 --> 00:53:30,400
Again, so if we exit out of this and exit out of this

729
00:53:31,180 --> 00:53:34,360
and we re-compile with now with our broken function.

730
00:53:35,650 --> 00:53:37,810
We can take a look at exactly what's gonna happen,

731
00:53:37,810 --> 00:53:41,650
so we can actually set our break point for sum_then_double.

732
00:53:45,290 --> 00:53:49,250
And set up tui and let it continue,

733
00:53:49,250 --> 00:53:50,870
so we now run demo2,

734
00:53:50,870 --> 00:53:52,760
okay we're at sum_then_double.

735
00:53:53,280 --> 00:53:56,370
And again, this is an assembly only function,

736
00:53:56,370 --> 00:53:59,490
so we're going to want to look at it in assembly,

737
00:53:59,610 --> 00:54:03,060
so we'll do layout asm layout reg,

738
00:54:03,060 --> 00:54:05,670
because it's important what's in the registers in this case.

739
00:54:06,620 --> 00:54:09,680
And you'll see that gdb knows a whole bunch of extra information

740
00:54:09,890 --> 00:54:15,420
and so we can see that, you can see that,

741
00:54:15,420 --> 00:54:21,000
ra currently, so the return address, currently points to demo2 the plus eighteen,

742
00:54:21,060 --> 00:54:25,010
so, it points effectively into the function demo2.

743
00:54:26,180 --> 00:54:28,130
And now we can run,

744
00:54:28,160 --> 00:54:32,210
we can just kind of step through our function and see what happens.

745
00:54:32,900 --> 00:54:35,660
We've called sum_to

746
00:54:35,690 --> 00:54:40,880
and immediately we can see that the return address was overwritten by sum_to,

747
00:54:40,880 --> 00:54:43,160
to now point to sum_then_double plus four,

748
00:54:43,310 --> 00:54:45,410
which makes sense, you know that's what we expect,

749
00:54:45,500 --> 00:54:47,060
if we go back into our code,

750
00:54:47,060 --> 00:54:51,410
we call sum_to and so sum_to should return to here.

751
00:54:52,750 --> 00:54:57,820
And now we can step through you know so on up

752
00:54:57,850 --> 00:55:01,020
and then we get back into.

753
00:55:03,550 --> 00:55:07,390
Oops, the wrong s.

754
00:55:14,490 --> 00:55:15,720
Okay, so now we're here

755
00:55:15,720 --> 00:55:19,950
and now when sum_then_double returns as exactly as Amir pointed out

756
00:55:20,820 --> 00:55:24,090
its return, it has not restored its own return address

757
00:55:24,210 --> 00:55:30,250
and instead its return address is still the one that was used by sum_to,

758
00:55:30,310 --> 00:55:33,640
and so we will get into an infinite loop

759
00:55:33,670 --> 00:55:37,720
where we just keep doing this over and over and over again

760
00:55:37,930 --> 00:55:39,370
and we'll never terminate from it.

761
00:55:39,900 --> 00:55:42,960
And so this is I think this is a good illustration of

762
00:55:42,960 --> 00:55:47,520
why it's important to keep track of our caller versus callee saved registers

763
00:55:47,730 --> 00:55:49,020
and hopefully this also shows

764
00:55:49,020 --> 00:55:55,190
that you can use kind of gdb to debug these sorts of these sorts of problems,

765
00:55:55,190 --> 00:55:57,320
so let's restore what we had.

766
00:55:58,190 --> 00:56:05,690
I will go into some other demos to talk about to illustrate.

767
00:56:05,780 --> 00:56:08,750
Somebody ask why are we subtracting 16.

768
00:56:08,780 --> 00:56:11,660
That's to put space to get our stack frame,

769
00:56:11,930 --> 00:56:15,980
so this is subtracting 16 from the stack pointer,

770
00:56:16,010 --> 00:56:18,080
so it's moving it down basically in memory.

771
00:56:18,520 --> 00:56:22,660
Moving it down so that we now have space for our own stack frame,

772
00:56:22,660 --> 00:56:23,830
then we can stick stuff there.

773
00:56:24,360 --> 00:56:29,280
So because at this point, in fact that we don't want to override what's at the stack pointer,

774
00:56:29,730 --> 00:56:35,350
why not 4 I is just well 4,

775
00:56:36,890 --> 00:56:40,550
we need to do 16 because instructions are 64.

776
00:56:42,560 --> 00:56:48,050
Yeah I guess I guess we wouldn't don't actually need to do 16,

777
00:56:48,110 --> 00:56:52,740
but that's generally what you'll see generally just see,

778
00:56:52,740 --> 00:56:57,750
I don't think yeah you, you can't you can't do 4 because you need 8.

779
00:56:58,070 --> 00:57:02,930
So 4 doesn't work, but I think you could do the instruction size,

780
00:57:03,320 --> 00:57:05,960
and the size of the register registers are 64,

781
00:57:06,260 --> 00:57:09,620
yeah, and then so the convention why you usually see 16 is because

782
00:57:09,620 --> 00:57:15,140
if we jump back to our document, usually we have the return address and the frame pointer,

783
00:57:15,140 --> 00:57:21,200
we're not doing that here because or being [not super careful] with our assembly.

784
00:57:22,240 --> 00:57:24,100
So normally, if we if we look in,

785
00:57:24,100 --> 00:57:25,810
I'm sure,

786
00:57:25,810 --> 00:57:28,030
if we look in kernel at this and we'll see.

787
00:57:29,010 --> 00:57:33,150
Yeah, so we look in kernel data we see it's also 16,

788
00:57:33,150 --> 00:57:35,040
this is generally what you'll see with the compiler.

789
00:57:37,970 --> 00:57:42,230
Um, OK, so now we can.

790
00:57:44,000 --> 00:57:44,960
After this.

791
00:57:46,680 --> 00:57:50,490
We fix our function and now we can look at some C code.

792
00:57:54,650 --> 00:57:57,770
Alright, so here we have demo4

793
00:57:57,770 --> 00:58:02,220
which is just basically, a copy of main function,

794
00:58:02,220 --> 00:58:05,220
like a imitation of the main function,

795
00:58:05,400 --> 00:58:10,620
so we have our args, which is an array of strings

796
00:58:10,740 --> 00:58:12,390
and we have dummymain

797
00:58:12,390 --> 00:58:16,800
which takes a number of arguments and the arguments string

798
00:58:16,800 --> 00:58:19,470
and just print it out, for us.

799
00:58:20,130 --> 00:58:24,390
And so that's all that's that's all that's happening here is pretty straightforward,

800
00:58:24,630 --> 00:58:29,010
if we set a break point in dummymain,

801
00:58:31,380 --> 00:58:34,170
then hop over, let.

802
00:58:35,620 --> 00:58:40,840
Okay, we'll just continue and we start this run demo4,

803
00:58:40,960 --> 00:58:44,180
okay so we now we hit dummymain.

804
00:58:45,080 --> 00:58:50,570
And there's a couple of important things to remember about,

805
00:58:51,560 --> 00:58:54,410
that you can use gdb for regarding stack frames,

806
00:58:54,590 --> 00:58:58,340
so if we type i so again, that's info,

807
00:58:58,340 --> 00:59:04,640
if we type i frame, we can see a whole bunch of useful information about the current stack frame,

808
00:59:04,790 --> 00:59:06,770
so we can see we're at stack level zero,

809
00:59:06,770 --> 00:59:10,550
level zero means it's [] is down in the call stack

810
00:59:10,550 --> 00:59:14,750
that we can go and the frame is at this address.

811
00:59:15,570 --> 00:59:19,140
The program counter which is okay, that's all well and good,

812
00:59:19,200 --> 00:59:21,450
we have a saved program counter as well,

813
00:59:21,630 --> 00:59:28,680
and if we again if we take this address and we jump into kernel.asm.

814
00:59:29,850 --> 00:59:31,410
We search for that address,

815
00:59:31,470 --> 00:59:40,190
we can indeed that that addresses inside of inside of demo4,

816
00:59:40,190 --> 00:59:44,420
which is exactly where we expect the program to return to

817
00:59:44,690 --> 00:59:48,140
and it was called by a frame at this address

818
00:59:48,170 --> 00:59:49,760
source language C,

819
00:59:49,790 --> 00:59:51,740
that's that's nice to know

820
00:59:51,740 --> 00:59:56,030
and then we have the argument list also starts this address,

821
00:59:56,030 --> 01:00:01,070
of course, in this case, we have most of our arguments in registers

822
01:00:01,190 --> 01:00:04,070
and then we can even see what args are,

823
01:00:04,070 --> 01:00:09,490
we argc is three and argv is this address.

824
01:00:10,440 --> 01:00:13,920
And if we want a more in-depth examine things

825
01:00:13,920 --> 01:00:16,830
we can look at things like info args,

826
01:00:17,680 --> 01:00:23,080
which will tell us information about the arguments to the function, we can look at,

827
01:00:23,200 --> 01:00:29,650
but more importantly we can type we type backtrace or bt works as well,

828
01:00:29,860 --> 01:00:34,660
we get a full backtrace of all of the stacks,

829
01:00:34,690 --> 01:00:38,170
all of the stack frames from the call stack,

830
01:00:38,170 --> 01:00:40,630
so you can see something questionable happen here,

831
01:00:40,630 --> 01:00:42,460
that's when we invoke a system call,

832
01:00:42,850 --> 01:00:45,640
then we get to the usertrap function,

833
01:00:45,670 --> 01:00:47,530
then to the syscall function,

834
01:00:47,590 --> 01:00:50,710
then to sys_demo then to demo4.

835
01:00:51,510 --> 01:00:53,340
And then finally to dummymain

836
01:00:54,210 --> 01:00:58,350
and if we want to investigate any of these stack frames more in-depth,

837
01:00:58,350 --> 01:01:03,240
we can do frame and then whatever number is along the side here,

838
01:01:03,240 --> 01:01:07,350
so let's say I want to look at what was my stack frame when syscall called,

839
01:01:07,350 --> 01:01:08,670
I can go to frame three,

840
01:01:08,940 --> 01:01:12,180
and so now, inside of gdb, I'm looking at that stack frame,

841
01:01:12,180 --> 01:01:14,910
so I type info frame I can get this.

842
01:01:15,700 --> 01:01:18,640
And here we get a lot more a lot more information

843
01:01:18,640 --> 01:01:20,980
we have a bunch of saves registers.

844
01:01:21,410 --> 01:01:25,070
Um, we have some local variables,

845
01:01:25,070 --> 01:01:27,440
we don't have any arguments to this function,

846
01:01:27,530 --> 01:01:31,040
we can see where the program counter were supposed to jump back to,

847
01:01:31,160 --> 01:01:32,750
all kinds of things like that,

848
01:01:32,750 --> 01:01:35,780
so this is super super useful for if you're debugging things,

849
01:01:35,780 --> 01:01:37,130
and in fact it's so useful,

850
01:01:37,160 --> 01:01:43,580
we make you implement your own version, nowhere near as in depth as what gdb tells you,

851
01:01:43,730 --> 01:01:46,820
but we're one of the exercises on the next lab

852
01:01:46,820 --> 01:01:50,480
will be to implement your own backtrace helper function,

853
01:01:50,480 --> 01:01:53,000
for use when debugging things inside the lab.

854
01:01:54,110 --> 01:01:56,690
And so back backtrace is quite useful,

855
01:01:56,780 --> 01:02:00,980
and then if we type frame zero, we go back to where we were supposed to be.

856
01:02:02,900 --> 01:02:04,670
And if we want to investigate,

857
01:02:04,670 --> 01:02:06,890
you probably noticed it's not super helpful,

858
01:02:06,890 --> 01:02:10,460
you know argv is a string as an array of strings

859
01:02:10,460 --> 01:02:13,700
and so we just got a ref, we just get an address,

860
01:02:13,760 --> 01:02:17,570
for where that's actually stored and if we want to look at what's in there,

861
01:02:17,570 --> 01:02:19,130
there's a couple ways of doing this,

862
01:02:19,250 --> 01:02:23,720
the easiest is if we type print, p is for print,

863
01:02:24,050 --> 01:02:27,920
and then if we dereference the address,

864
01:02:27,920 --> 01:02:29,780
so we go look at what's at address,

865
01:02:29,930 --> 01:02:32,390
we do that and,

866
01:02:32,390 --> 01:02:36,820
you know, as you would expect, we get the first element of that array,

867
01:02:36,820 --> 01:02:39,280
because when it tries to print a string,

868
01:02:39,280 --> 01:02:42,850
it'll go as C says, it'll go until it hits the null character,

869
01:02:43,030 --> 01:02:45,190
so we get foo which is the first element in that array,

870
01:02:45,190 --> 01:02:49,060
and if we want to get more things we can put in the length,

871
01:02:49,090 --> 01:02:51,150
so if we do @ then a number,

872
01:02:51,150 --> 01:02:52,740
it'll go up to a certain index,

873
01:02:52,920 --> 01:02:55,410
so then we can see both of the strings here

874
01:02:55,800 --> 01:02:58,890
and again gdb is quite smart,

875
01:02:58,890 --> 01:03:04,320
so we can even use argc to print out the whole argument array.

876
01:03:05,590 --> 01:03:08,890
And so all of that information is available to you,

877
01:03:09,130 --> 01:03:13,360
you, however you want to get it, so gdb the superpower tool.

878
01:03:14,290 --> 01:03:16,780
Why does gdb sorry,

879
01:03:16,780 --> 01:03:22,360
why does the compiler sometimes optimize out argc and argv,

880
01:03:22,360 --> 01:03:23,830
that has happened to be before.

881
01:03:24,340 --> 01:03:27,820
Yeah that just means that the compiler found a more efficient way,

882
01:03:27,820 --> 01:03:31,570
likely it just got rid of the variable and it's doing all of its operations,

883
01:03:31,810 --> 01:03:36,490
directly you know [] register might be doing all of its operations on a0,

884
01:03:36,490 --> 01:03:40,820
for example, it might just be doing all the computations on the return address.

885
01:03:41,120 --> 01:03:42,980
It's pretty common to see something like that,

886
01:03:42,980 --> 01:03:48,550
if you if it's a variable that's not you know a hundred percent necessary.

887
01:03:48,790 --> 01:03:52,480
If you know we don't let we don't give you control over the compiler,

888
01:03:52,480 --> 01:03:54,310
but if you ever find that in your day-to-day,

889
01:03:54,460 --> 01:03:59,290
you can try setting the optimization flag for the compiler to zero,

890
01:03:59,530 --> 01:04:04,660
but even then you know the compiler will do will do it, we'll do some level of optimization.

891
01:04:05,550 --> 01:04:07,320
Bibic your hand is raised.

892
01:04:08,310 --> 01:04:16,380
Yeah what's the address, besides that $1 or $2 you know like before foo or bar.

893
01:04:16,620 --> 01:04:18,180
Dollar, this?

894
01:04:18,870 --> 01:04:23,160
Yeah, so what's that address is that the address where foo is.

895
01:04:23,640 --> 01:04:24,450
Probably yes.

896
01:04:25,990 --> 01:04:30,160
But then argv points to some other address shouldn't those be the same.

897
01:04:32,080 --> 01:04:34,810
So argv is on this stack,

898
01:04:35,140 --> 01:04:39,910
and you know, so the reason why, if you look at these addresses,

899
01:04:39,910 --> 01:04:44,350
we can see that they're in the kernel, just by the 8000.

900
01:04:44,760 --> 01:04:48,900
Um, which makes sense because we declared statically right,

901
01:04:48,900 --> 01:04:51,540
so in demos, if I go here they're declared here.

902
01:04:52,000 --> 01:04:54,460
And so they're basically they're sitting somewhere in the kernel

903
01:04:54,820 --> 01:05:00,130
and they're all [] stars argc or argv is an array of [] stars

904
01:05:00,130 --> 01:05:06,870
and so I imagined each element points to points to its own string right,

905
01:05:07,020 --> 01:05:08,880
so it's an array of pointers.

906
01:05:10,420 --> 01:05:10,810
I see.

907
01:05:17,060 --> 01:05:18,350
[]

908
01:05:24,700 --> 01:05:26,440
I also have a question about this,

909
01:05:26,470 --> 01:05:31,860
the $3 version of the array has

910
01:05:31,860 --> 01:05:33,690
if I look at these addresses

911
01:05:33,930 --> 01:05:36,890
the first one is suffixed by 38,

912
01:05:37,160 --> 01:05:39,500
the second one is suffixed by 40

913
01:05:39,650 --> 01:05:42,080
and the third one is 48.

914
01:05:42,500 --> 01:05:48,710
Which is not uniform, even though the length of each of the three arguments is three,

915
01:05:49,220 --> 01:05:50,900
so why, why are they different.

916
01:05:51,140 --> 01:05:55,070
Um, not in I'm not a hundred percent certain,

917
01:05:55,070 --> 01:05:58,280
my guess is that this is an attempt to align things.

918
01:05:58,700 --> 01:06:04,100
Um, right, so to get them on a reasonable alignment,

919
01:06:04,610 --> 01:06:07,100
it is uniform in hex as, people are pointing out.

920
01:06:08,430 --> 01:06:15,420
Oh yeah, yeah yeah see it now right, thanks.

921
01:06:15,870 --> 01:06:19,590
So you'll sometimes see where strange things are laid out strangely

922
01:06:19,650 --> 01:06:22,110
where there might be two things as strange offsets

923
01:06:22,110 --> 01:06:25,740
and that's just because not everything is naturally the same sized.

924
01:06:26,300 --> 01:06:29,510
Okay, any other questions.

925
01:06:37,230 --> 01:06:40,620
Okay, we can skip the fifth demo.

926
01:06:41,150 --> 01:06:46,250
And so another useful function that we get from gdb,

927
01:06:46,460 --> 01:06:51,680
instead of just break points, they're also watch points

928
01:06:51,680 --> 01:06:55,010
and we can also set a conditional break points.

929
01:06:55,250 --> 01:07:00,200
So, I'll just briefly go over that.

930
01:07:02,160 --> 01:07:06,840
Run demo6 so we can set inside this function,

931
01:07:06,840 --> 01:07:09,330
we can watch so we can set a watch point,

932
01:07:09,540 --> 01:07:12,720
I think here you'll see.

933
01:07:15,680 --> 01:07:22,460
Yeah, so here you'll see what Luke was talking about where we see that some has been optimized out,

934
01:07:22,670 --> 01:07:25,640
likely because it's just being a zero or something.

935
01:07:27,060 --> 01:07:29,280
We can look even at the assembly for this right,

936
01:07:29,280 --> 01:07:32,220
so we can layout split.

937
01:07:32,980 --> 01:07:37,830
And indeed, we can see that all just being, It's all just being done on the stack,

938
01:07:37,830 --> 01:07:38,760
it looks like to me.

939
01:07:40,280 --> 01:07:43,190
Oh, no, it's always been done in s0 s0 one three,

940
01:07:43,400 --> 01:07:49,880
so here you can see the, compiler decided even to use the callee saved registers

941
01:07:51,410 --> 01:07:57,600
and so we can set things like we do watch on i.

942
01:07:58,360 --> 01:07:59,980
Alright we haven't declared i,

943
01:07:59,980 --> 01:08:05,040
yet because we're not inside we're not inside the for loop.

944
01:08:05,220 --> 01:08:08,350
So we step through the C instructions,

945
01:08:08,350 --> 01:08:12,400
now if we do information for the locals, we see we get i,

946
01:08:12,430 --> 01:08:16,780
we can even watch watch point on sum.

947
01:08:17,640 --> 01:08:23,250
So now anytime that sum changes will actually get a notification,

948
01:08:23,250 --> 01:08:27,160
so we can continue and then we'll get a delete here,

949
01:08:27,160 --> 01:08:31,480
because some has been moved so we can't we can't actually watch it,

950
01:08:31,600 --> 01:08:37,030
we can even do things like break point on sum_to,

951
01:08:37,030 --> 01:08:44,190
so this is a conditional break point if, well, let's actually see was i currently, so i currently 1,

952
01:08:44,250 --> 01:08:48,720
let's say I think my loop is breaking and whenever i is 5,

953
01:08:48,810 --> 01:08:51,630
well if I want to specifically debug that case,

954
01:08:51,660 --> 01:09:01,850
I can set a break point on sum_to if i equal 5.

955
01:09:02,850 --> 01:09:06,540
So now we have this break point, and if we continue along,

956
01:09:06,570 --> 01:09:13,260
we'll get to sum_to, and we can see that it actually printed out the first couple values

957
01:09:13,320 --> 01:09:20,090
and so we only break now on sum_to if if i if we hit that break point condition.

958
01:09:21,280 --> 01:09:26,380
And so that's, it can be again can be useful if you want to debug specific edge cases of your code

959
01:09:26,470 --> 01:09:28,450
and watch points can be useful

960
01:09:28,870 --> 01:09:33,640
if for instance you think that something shouldn't be changing, but you suspect that it is

961
01:09:33,670 --> 01:09:38,530
or you think that something is going wrong every time you change a certain variable.

962
01:09:40,000 --> 01:09:42,790
And so that's that's a it's one one usage for that.

963
01:09:43,630 --> 01:09:47,590
And the last thing I want to talk about today is struct,

964
01:09:47,860 --> 01:09:54,670
struct pretty important, they'll come up in in the labs often

965
01:09:54,910 --> 01:09:56,740
and also.

966
01:09:57,310 --> 01:10:02,590
So, what as, I'll talk a little bit about the way structs are laid out in memory.

967
01:10:03,750 --> 01:10:08,610
And so a structure is basically it's a continued contiguous area of memory,

968
01:10:08,610 --> 01:10:09,810
so if we have some structure.

969
01:10:11,510 --> 01:10:15,800
And we have like field one field two field three.

970
01:10:17,110 --> 01:10:18,220
When we make that struct

971
01:10:18,220 --> 01:10:22,770
those fields are going to be align next to each other in memory,

972
01:10:22,770 --> 01:10:25,470
you can kind of think of this like an array,

973
01:10:25,470 --> 01:10:28,110
but f1 f2 f3 can all be different types.

974
01:10:28,380 --> 01:10:32,880
And, we can pass them [] functions,

975
01:10:32,880 --> 01:10:37,620
usually they pass them as arguments to functions, usually they pass by reference,

976
01:10:37,710 --> 01:10:42,420
so here I've made a struct person with two integer arguments,

977
01:10:42,660 --> 01:10:47,990
and I'm passing them, passing a person as an argument person

978
01:10:48,320 --> 01:10:51,710
and printing out some of that information,

979
01:10:52,160 --> 01:10:54,290
so if we hop into gdb

980
01:10:54,290 --> 01:10:56,780
and let's delete all our break points and watch points,

981
01:10:56,990 --> 01:11:00,980
and now we can set a break point at printPerson,

982
01:11:01,680 --> 01:11:06,360
and it's continue and run seventh demo.

983
01:11:07,640 --> 01:11:10,700
We can see that now we're here and so if we type i frame,

984
01:11:10,940 --> 01:11:14,840
we can see that we have an argument p.

985
01:11:15,310 --> 01:11:19,630
And indeed, we can see if we do print p,

986
01:11:20,780 --> 01:11:24,710
If we can even tell that it's struct person at this address

987
01:11:25,910 --> 01:11:28,850
and we can if we dereference it,

988
01:11:30,210 --> 01:11:36,290
gdb will tell us exactly what p looks like it has id 1215 age 22.

989
01:11:37,660 --> 01:11:41,590
And just to show kind of how things are laid out.

990
01:11:42,060 --> 01:11:47,520
You can take this address and we see at this address,

991
01:11:48,060 --> 01:11:55,110
if we look. I remember exactly.

992
01:11:57,380 --> 01:11:57,920
Should be.

993
01:12:02,180 --> 01:12:06,860
So if we again so we can use this to debug our structures.

994
01:12:07,900 --> 01:12:15,310
In in the code, we can take a look at what's going on with structures this way,

995
01:12:15,340 --> 01:12:18,100
so gdb is a super powerful tool

996
01:12:18,100 --> 01:12:20,590
not just for stepping through code,

997
01:12:20,590 --> 01:12:27,430
but also for examining all kinds of potentially problematic pieces in your code

998
01:12:27,430 --> 01:12:30,520
and looking at arguments and stack frames and things like that,

999
01:12:30,850 --> 01:12:34,510
and this will be hopefully will be useful in the next lab,

1000
01:12:35,270 --> 01:12:39,680
when you have to work with, with stack frames and with assembly code.

1001
01:12:40,080 --> 01:12:43,470
So that's that's mostly what I wanted to talk about today.

1002
01:12:43,470 --> 01:12:47,910
So, with the last kind of seven minutes of lecture,

1003
01:12:47,910 --> 01:12:51,870
I'll open it up to any any other questions you guys have.

1004
01:12:59,510 --> 01:13:01,250
I had a bit of a tangential question,

1005
01:13:01,880 --> 01:13:05,870
who is who manages the creation of compilers

1006
01:13:05,870 --> 01:13:10,100
from to get from C to various instruction set architectures,

1007
01:13:10,100 --> 01:13:14,000
is that the creator of the instruction set architecture, is the third parties like that.

1008
01:13:14,500 --> 01:13:19,960
Um, I believe that it is not the creative the instruction set,

1009
01:13:19,960 --> 01:13:21,700
so it's often a third party,

1010
01:13:22,060 --> 01:13:24,430
so the two big C compilers that you'll see

1011
01:13:24,430 --> 01:13:29,530
refer to GCC which is maintained by I think the GNU foundation

1012
01:13:29,950 --> 01:13:34,990
and Clang llvm, which is its own thing,

1013
01:13:34,990 --> 01:13:39,520
so I think you know you can find I believe llvm is even open source,

1014
01:13:39,520 --> 01:13:44,430
so you can find. you can, you can find the code specifically that does this,

1015
01:13:44,550 --> 01:13:48,630
when a new instruction set is released such as RISC-V,

1016
01:13:48,720 --> 01:13:53,040
that calling convention document as well as all of those instruction documents,

1017
01:13:53,280 --> 01:13:55,050
I think carefully I assume

1018
01:13:55,050 --> 01:14:00,840
there's a high level of cooperation between the compiler designer and the instruction set designer.

1019
01:14:01,550 --> 01:14:05,720
But yeah a short answer is I believe it's a third party who does it,

1020
01:14:05,720 --> 01:14:09,710
likely with a lot of cooperation from the people who make the instruction set.

1021
01:14:09,770 --> 01:14:16,320
RISC-V is probably, RISC-V might be an exception where because it came out of a research project,

1022
01:14:16,440 --> 01:14:20,770
they may have written the compiler for it themselves, as well.

1023
01:14:21,410 --> 01:14:27,590
I I don't think Intel has for example has input in in GCC or llvm.

1024
01:14:45,530 --> 01:14:46,490
Other questions?

1025
01:14:54,650 --> 01:14:58,790
Okay, well, thanks for listening,

1026
01:14:58,790 --> 01:15:00,890
in that case I guess we can.

1027
01:15:01,790 --> 01:15:03,740
You can end the lecture here,

1028
01:15:03,800 --> 01:15:07,520
a five minutes to spare, so have a nice rest.

