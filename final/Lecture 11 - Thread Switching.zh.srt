1
00:00:00,030 --> 00:00:00,930
有人听到我说话吗？

2
00:00:02,860 --> 00:00:03,430
我能听见你说话。

3
00:00:03,850 --> 00:00:05,170
谢谢，好的。

4
00:00:06,500 --> 00:00:10,520
我想用今天的讲座来讨论一下线程，

5
00:00:10,520 --> 00:00:12,680
以及 xv6 如何进行线程切换，

6
00:00:12,980 --> 00:00:17,870
这是关于[xv6]的底层的讲座，

7
00:00:17,870 --> 00:00:21,560
我们之前讲过关于系统调用中断，

8
00:00:21,560 --> 00:00:23,120
页表和锁是如何工作的，

9
00:00:23,510 --> 00:00:25,880
今天我们将讨论

10
00:00:26,660 --> 00:00:29,480
xv6 是如何在不同进程之间切换的。

11
00:00:32,040 --> 00:00:34,230
最高层次的原因是，

12
00:00:34,230 --> 00:00:36,180
因为人们喜欢他们的电脑能够

13
00:00:36,180 --> 00:00:39,090
同时完成多项任务，

14
00:00:39,540 --> 00:00:42,330
所以原因可能是支持分时，

15
00:00:42,330 --> 00:00:45,540
像 Athena 一样，允许多个用户同时登录，

16
00:00:45,540 --> 00:00:47,310
它们都可以运行进程，

17
00:00:47,610 --> 00:00:49,530
甚至是一台单用户机器，

18
00:00:49,560 --> 00:00:50,670
甚至是你的 iPhone ，

19
00:00:51,040 --> 00:00:53,440
你可以运行许多不同的进程，

20
00:00:53,440 --> 00:00:56,680
并期望计算机能做你要求它做的所有事情，

21
00:00:56,680 --> 00:00:57,490
而不只是一件事。

22
00:01:00,260 --> 00:01:03,860
人们喜欢支持多任务的另一个原因是，

23
00:01:03,860 --> 00:01:06,350
因为它可以简化程序结构，

24
00:01:06,470 --> 00:01:08,690
特别是今天的话题线程，

25
00:01:08,810 --> 00:01:11,930
有时作为一种方式来帮助人们，

26
00:01:11,930 --> 00:01:16,970
帮助程序员以一种简单优雅的方式把程序组合在一起，

27
00:01:17,000 --> 00:01:18,140
以降低复杂性，

28
00:01:18,290 --> 00:01:19,910
实际上你已经看到了这样的例子，

29
00:01:19,910 --> 00:01:22,010
在第一个实验中的素数筛子，

30
00:01:22,010 --> 00:01:26,060
它不使用线程，但使用多个进程，

31
00:01:26,060 --> 00:01:30,590
为了帮助构建素数筛选软件，

32
00:01:30,590 --> 00:01:34,850
这是一种更方便、更优雅或更简单的方式，

33
00:01:34,850 --> 00:01:36,850
去写那个软件。

34
00:01:37,620 --> 00:01:40,920
人们使用线程的最后一个原因是，

35
00:01:40,920 --> 00:01:44,460
为了从多核机器获得并行加速，

36
00:01:44,700 --> 00:01:48,120
所以分解你的程序是很常见的，

37
00:01:48,120 --> 00:01:51,030
使用线程的方式，

38
00:01:51,030 --> 00:01:55,110
允许同一程序的不同部分在不同的内核上运行，

39
00:01:55,110 --> 00:01:57,600
也许如果你幸运的话，

40
00:01:57,600 --> 00:02:01,710
你可以把程序拆分为四个线程运行在四个核心上，

41
00:02:01,740 --> 00:02:05,370
你也许可以把它的速度提高到原来的四倍。

42
00:02:06,780 --> 00:02:11,850
实际上，你可以将 xv6 内核视为一个多核并行程序。

43
00:02:12,700 --> 00:02:15,070
那么线程是什么，

44
00:02:15,070 --> 00:02:18,760
是一种简化编程的抽象，

45
00:02:18,940 --> 00:02:20,650
当你有很多任务时，

46
00:02:20,650 --> 00:02:22,600
当你想要同时处理多项任务时，

47
00:02:22,630 --> 00:02:24,430
所以线程是什么，

48
00:02:24,670 --> 00:02:28,960
你可以把线程想成一个单一的串行执行，

49
00:02:28,960 --> 00:02:31,390
如果你写一个程序做一件又一件事情，

50
00:02:31,390 --> 00:02:32,560
你运行这个程序，

51
00:02:32,830 --> 00:02:37,570
你可以把这个程序看作是一种单一的控制线程。

52
00:02:38,290 --> 00:02:41,830
所以，这是一个宽泛的定义。

53
00:02:44,160 --> 00:02:47,790
因为，人们所说的线程有多种不同的定义，

54
00:02:47,790 --> 00:02:52,920
但我们说这是一个串行执行，

55
00:02:53,250 --> 00:02:58,990
因此，如果你启动一个 CPU ，

56
00:02:58,990 --> 00:03:02,560
让它用普通的方式一条接一条地执行指令。

57
00:03:05,580 --> 00:03:07,770
我们经常谈到线程有状态，

58
00:03:07,800 --> 00:03:08,820
因为结果是，

59
00:03:08,820 --> 00:03:10,830
我们想要保存线程状态，

60
00:03:10,830 --> 00:03:11,760
之后再恢复它，

61
00:03:12,780 --> 00:03:15,630
所以思考线程状态的正确方式是，

62
00:03:15,630 --> 00:03:16,620
最重要的部分，

63
00:03:16,740 --> 00:03:21,120
最重要的线程状态的可能是程序计数器，

64
00:03:21,420 --> 00:03:22,830
因为它是执行，

65
00:03:22,830 --> 00:03:25,530
我们很关心它在执行中的什么位置，

66
00:03:25,710 --> 00:03:27,960
它执行指令的地址是什么，

67
00:03:29,010 --> 00:03:32,910
但我们也关心微处理器的其它状态，

68
00:03:32,910 --> 00:03:34,860
这是支持执行所必需的，

69
00:03:35,100 --> 00:03:36,300
所以这意味着它是。

70
00:03:38,520 --> 00:03:42,960
线程状态包括编译器用来保存变量的寄存器，

71
00:03:43,200 --> 00:03:47,070
还因为编译器生成代码的方式，

72
00:03:47,130 --> 00:03:49,200
线程状态包括堆栈，

73
00:03:49,970 --> 00:03:53,150
所以，一般每个线程都有自己的堆栈，

74
00:03:53,150 --> 00:03:54,770
专用于执行该线程，

75
00:03:54,770 --> 00:03:58,130
堆栈记录函数调用的记录，

76
00:03:59,960 --> 00:04:04,490
反映该线程执行中的当前点。

77
00:04:05,630 --> 00:04:10,130
所以， xv6 在其内部包括线程系统，

78
00:04:10,160 --> 00:04:11,720
线程系统的所做的是，

79
00:04:11,780 --> 00:04:18,200
自动执行多个交织的线程，

80
00:04:18,410 --> 00:04:22,820
你可能希望启动 200 或 400 或 1000 个线程，

81
00:04:22,820 --> 00:04:28,380
线程系统会处理所有这些线程，

82
00:04:28,380 --> 00:04:30,780
使它们全部发展，全部执行。

83
00:04:32,030 --> 00:04:36,920
有两个主要的策略，

84
00:04:36,920 --> 00:04:38,390
我们想要交错，

85
00:04:39,210 --> 00:04:43,430
这是一个很大的话题，

86
00:04:43,430 --> 00:04:46,790
如何交错多个线程，

87
00:04:47,240 --> 00:04:50,090
交错执行多个线程的一种方法是

88
00:04:50,090 --> 00:04:51,920
拥有多个 CPU ，

89
00:04:55,070 --> 00:04:57,890
像是在多核处理器上，

90
00:04:58,490 --> 00:05:00,770
然后每个 CPU 可以运行自己的线程，

91
00:05:00,770 --> 00:05:01,970
所以如果你有 4 个 CPU ，

92
00:05:01,970 --> 00:05:05,540
很明显可以运行 4 个线程，

93
00:05:05,540 --> 00:05:07,070
每个 CPU 上运行一个线程，

94
00:05:07,070 --> 00:05:11,030
然后每个线程自动获得自己的程序计数器寄存器，

95
00:05:11,030 --> 00:05:15,320
程序计数器寄存器是与正在运行的 CPU 关联的，

96
00:05:15,680 --> 00:05:18,440
但是如果你有 4 个 CPU 和上千个线程，

97
00:05:18,590 --> 00:05:23,830
那么如何在核心上使用线程，

98
00:05:23,830 --> 00:05:26,320
不是一个好回答的问题。

99
00:05:26,530 --> 00:05:29,740
所以，我们看到的另一个主要策略是，

100
00:05:30,620 --> 00:05:34,280
实际上，这节课的大部分内容都是，

101
00:05:34,310 --> 00:05:41,360
每个 CPU 如何在不同线程之间切换，

102
00:05:41,390 --> 00:05:43,580
所以，如果我有一个 CPU 和上千个线程，

103
00:05:43,670 --> 00:05:47,810
我们看看 xv6 是如何构建切换系统的，

104
00:05:48,050 --> 00:05:50,300
这允许 xv6 在一段时间内运行一个线程，

105
00:05:50,300 --> 00:05:52,340
然后切换并放在一边，

106
00:05:52,340 --> 00:05:53,900
保存该线程的状态，

107
00:05:53,900 --> 00:05:56,540
并切换到第二个线程，执行一段时间，

108
00:05:56,540 --> 00:05:57,950
然后是第三个线程，等等，

109
00:05:57,950 --> 00:06:00,080
直到它执行了每个线程的一部分，

110
00:06:00,080 --> 00:06:04,340
然后，返回到第一个线程并继续执行，等等。

111
00:06:06,170 --> 00:06:08,690
实际上， xv6 和大多数操作系统，

112
00:06:08,690 --> 00:06:13,640
xv6 在所有可用核心上运行线程，

113
00:06:13,640 --> 00:06:16,820
并且每个核心在线程之间切换，

114
00:06:17,030 --> 00:06:19,760
因为通常是，尽管并非总是如此，

115
00:06:19,760 --> 00:06:23,030
线程数通常比 CPU 数多得多。

116
00:06:24,780 --> 00:06:31,290
一个线程系统的不同之处，

117
00:06:31,320 --> 00:06:33,930
或者线程系统实例的不同之处是，

118
00:06:33,930 --> 00:06:35,580
是它们否共享内存。

119
00:06:36,960 --> 00:06:44,380
所以这是很重要一点。

120
00:06:45,040 --> 00:06:48,640
一种可能是，你可以有一个单独的地址空间，

121
00:06:48,670 --> 00:06:50,920
许多线程在该地址空间中执行，

122
00:06:50,920 --> 00:06:52,810
它们可以看到彼此的变动，

123
00:06:52,990 --> 00:06:56,950
如果共享内存的一个线程修改了变量，

124
00:06:56,950 --> 00:06:59,770
那么其它共享该内存的线程会看到修改。

125
00:07:01,430 --> 00:07:04,520
所以，在线程共享内存的情况下，

126
00:07:04,520 --> 00:07:06,080
我们需要锁，

127
00:07:06,080 --> 00:07:08,390
你在上一节课上看到的。

128
00:07:10,330 --> 00:07:13,510
xv6 内核是共享内存的，

129
00:07:13,750 --> 00:07:16,840
所以 xv6 有，

130
00:07:17,170 --> 00:07:19,810
xv6 支持内核线程的概念，

131
00:07:19,810 --> 00:07:22,630
每个进程有一个内核线程，

132
00:07:22,630 --> 00:07:24,670
来执行该进程的系统调用，

133
00:07:24,820 --> 00:07:27,520
所有这些内核线程共享内核内存，

134
00:07:28,240 --> 00:07:30,730
所以 xv6 内核线程共享内存。

135
00:07:34,400 --> 00:07:37,500
另一方面，

136
00:07:37,650 --> 00:07:39,420
xv6 还有另一种线程，

137
00:07:39,420 --> 00:07:43,020
每个用户进程都有一个控制线程，

138
00:07:43,020 --> 00:07:45,870
执行该进程的用户指令，

139
00:07:46,080 --> 00:07:51,270
实际上， xv6 内核线程机制的一大部分是

140
00:07:51,270 --> 00:07:56,940
支持自动地在多个用户进程之间切换，

141
00:07:56,970 --> 00:07:59,010
每个用户进程具有内存，

142
00:07:59,010 --> 00:08:01,080
单个线程在其中运行，

143
00:08:01,290 --> 00:08:05,750
所以 xv6 用户进程，

144
00:08:11,160 --> 00:08:13,110
每个进程有一个线程，

145
00:08:13,110 --> 00:08:20,520
所以在单个 xv6 用户进程内的线程之间不会共享内存，

146
00:08:20,520 --> 00:08:21,840
因为你有多个进程，

147
00:08:21,840 --> 00:08:25,770
但是每个进程都是一个地址空间和单个线程，

148
00:08:27,000 --> 00:08:29,310
在 xv6 中的进程步共享内存。

149
00:08:29,790 --> 00:08:32,400
在其它更复杂的操作系统中，

150
00:08:32,400 --> 00:08:33,510
比如，在 Linux 中，

151
00:08:35,110 --> 00:08:42,310
Linux 用户级允许在一个进程中有多个线程，

152
00:08:42,310 --> 00:08:46,750
并且这些线程共享那个单个进程的内存，

153
00:08:47,380 --> 00:08:49,780
这非常酷，如果你想编写用户级的程序，

154
00:08:49,780 --> 00:08:54,940
用户级并行程序可以使用多核提速，

155
00:08:55,060 --> 00:08:56,650
需要另一种，

156
00:08:56,770 --> 00:08:59,290
它使用了很多相同的基础技术，

157
00:08:59,290 --> 00:09:00,580
我们今天要讨论的，

158
00:09:00,580 --> 00:09:04,390
但是，在 Linux 实现它有一定的复杂度，

159
00:09:05,000 --> 00:09:08,600
跟踪每个进程的多个线程，而不只是一个。

160
00:09:12,250 --> 00:09:15,970
好的，从高层次上，我想提一下，

161
00:09:15,970 --> 00:09:17,890
还有其他方法，

162
00:09:17,890 --> 00:09:22,150
可以支持在一台计算机上交错执行多个任务，

163
00:09:22,510 --> 00:09:24,940
我们不会讨论它们，

164
00:09:25,030 --> 00:09:29,020
如果你好奇，可以看看事件驱动编程的东西，

165
00:09:29,020 --> 00:09:30,910
或者状态机，

166
00:09:31,060 --> 00:09:34,030
它们是非线程技术，

167
00:09:34,060 --> 00:09:37,360
在许多不同任务之间共享一台计算机，

168
00:09:37,480 --> 00:09:42,730
这些是不同层次的不同方案，

169
00:09:42,730 --> 00:09:44,770
为了支持计算机上的多任务，

170
00:09:44,860 --> 00:09:46,570
线程效率不是很高，

171
00:09:46,600 --> 00:09:48,130
有更有效的方案，

172
00:09:48,700 --> 00:09:51,670
但是线程通常是最方便的方式，

173
00:09:51,700 --> 00:09:53,500
最适合程序员的方式，

174
00:09:53,680 --> 00:09:57,220
来支持许多不同的任务。

175
00:09:59,770 --> 00:10:04,610
好的，这里有几个挑战，

176
00:10:04,610 --> 00:10:05,840
我们必须解决，

177
00:10:05,870 --> 00:10:08,420
如果我们要实现线程系统。

178
00:10:12,590 --> 00:10:15,800
所以这是高级别的挑战。

179
00:10:22,880 --> 00:10:24,350
一个是我之前提到的，

180
00:10:24,350 --> 00:10:28,710
如何实现交错（线程）的切换，

181
00:10:28,800 --> 00:10:37,030
这个切换允许我们交错执行多个线程，

182
00:10:37,570 --> 00:10:43,680
这个进程的切换决定有一个广义名称，

183
00:10:43,680 --> 00:10:47,190
离开一个线程，并执行另一个线程，

184
00:10:47,340 --> 00:10:48,600
这通常称为调度。

185
00:10:51,520 --> 00:10:55,810
我们将看到 xv6 []的一段代码，

186
00:10:55,810 --> 00:10:56,650
就是调度器，

187
00:10:56,650 --> 00:10:58,750
实际上，有多个调度器，每个核心一个，

188
00:10:59,530 --> 00:11:02,830
但是关于如何驱动，

189
00:11:02,830 --> 00:11:04,660
如何决定从一个切换到另一个，

190
00:11:04,660 --> 00:11:06,310
如何选择要运行的下一个线程，

191
00:11:07,000 --> 00:11:07,780
这就是调度。

192
00:11:10,120 --> 00:11:12,100
另一个问题是，

193
00:11:12,100 --> 00:11:14,800
如果你想实现从一个线程到另一个线程的切换，

194
00:11:14,800 --> 00:11:16,750
你需要保存和恢复，

195
00:11:16,930 --> 00:11:19,840
所以我们需要决定，需要保存什么，

196
00:11:20,170 --> 00:11:21,970
保存到哪，

197
00:11:22,900 --> 00:11:26,260
当我们离开一个线程时，需要保存它，

198
00:11:26,260 --> 00:11:30,820
并在稍后想要重新执行该线程时，恢复它，

199
00:11:31,180 --> 00:11:34,870
最后一个问题是，如何处理计算密集型线程。

200
00:11:37,960 --> 00:11:41,560
很多选择，

201
00:11:41,740 --> 00:11:44,500
很多切换线程的直接的选择，

202
00:11:44,770 --> 00:11:46,930
引入线程自愿表示，

203
00:11:46,930 --> 00:11:48,370
我要保存自己的状态，

204
00:11:48,370 --> 00:11:51,400
让另一个线程运行，

205
00:11:51,460 --> 00:11:56,050
但是，如果我们有一个用户程序做长时间的计算，

206
00:11:56,050 --> 00:11:57,280
可能需要几个小时，

207
00:11:57,430 --> 00:12:00,190
它不会特别考虑，

208
00:12:00,190 --> 00:12:02,560
现在是时候让别的线程运行了，

209
00:12:02,770 --> 00:12:06,340
所以最方便是，通过某种方式

210
00:12:06,340 --> 00:12:11,260
自动从长时间运行的计算密集型进程收回控制权，

211
00:12:11,440 --> 00:12:14,260
把它放在一边，之后再运行。

212
00:12:16,780 --> 00:12:18,850
好的，我要谈谈这些，

213
00:12:18,850 --> 00:12:21,070
实际上，首先我要谈谈，

214
00:12:21,070 --> 00:12:24,850
处理计算密集型线程的机制。

215
00:12:27,220 --> 00:12:31,860
而且，方案就是你以前知道的，

216
00:12:32,520 --> 00:12:34,110
那就是定时器中断。

217
00:12:38,340 --> 00:12:41,150
这里的想法是，

218
00:12:41,180 --> 00:12:46,040
每个核心，每个 CPU 上都有一个硬件，

219
00:12:46,280 --> 00:12:49,640
它会产生周期性的中断，

220
00:12:49,850 --> 00:12:52,160
而 xv6 或任何操作系统

221
00:12:52,160 --> 00:12:54,920
将这些中断传送给内核，

222
00:12:54,920 --> 00:12:58,250
所以，即使我们在用户级运行一些循环，

223
00:12:58,250 --> 00:13:01,640
比如计算 pi 的前 10 亿位，

224
00:13:01,730 --> 00:13:05,960
尽管如此，定时器中断还是会在某个时间点发生，

225
00:13:05,960 --> 00:13:07,430
可能是每 10 毫秒一次，

226
00:13:07,640 --> 00:13:10,820
将控制从该用户级代码转移到

227
00:13:10,910 --> 00:13:12,770
内核中的中断处理程序，

228
00:13:12,860 --> 00:13:18,320
这是内核获得控制权的第一步，

229
00:13:18,320 --> 00:13:22,370
用来在不同的用户级线程之间切换，

230
00:13:22,580 --> 00:13:25,820
即使那些用户级线程不是协作的。

231
00:13:26,900 --> 00:13:32,720
基本方案是，在中断处理器中，

232
00:13:32,720 --> 00:13:36,920
所以我们有处理这些程序的内核中断。

233
00:13:38,170 --> 00:13:39,640
我们会看到，

234
00:13:40,500 --> 00:13:44,370
内核处理程序让出，

235
00:13:44,430 --> 00:13:47,010
这个名称是 yields ，

236
00:13:49,290 --> 00:13:53,730
内核处理程序自愿让出 CPU 给调度器，

237
00:13:53,730 --> 00:13:56,400
告诉调度器，你现在可以运行其他线程。

238
00:13:58,240 --> 00:14:03,060
而这个让出是一种线程切换的形式，

239
00:14:03,060 --> 00:14:06,330
它保存了当前线程的状态，

240
00:14:06,480 --> 00:14:07,920
这样以后就可以恢复。

241
00:14:10,320 --> 00:14:12,390
我们会在这里看到整个流程，

242
00:14:12,390 --> 00:14:13,920
实际上，你已经在这里看到了整个流程，

243
00:14:13,920 --> 00:14:15,360
因为它涉及到中断，

244
00:14:16,050 --> 00:14:18,330
你已经知道整个流程有些复杂，

245
00:14:18,330 --> 00:14:20,640
但是基本的想法是定时器中断

246
00:14:21,000 --> 00:14:22,500
将控制权交给内核，

247
00:14:22,500 --> 00:14:25,560
而内核自愿让出 CPU ，

248
00:14:26,820 --> 00:14:30,900
这个术语称为抢占调度。

249
00:14:38,980 --> 00:14:40,990
它的意思是，

250
00:14:41,140 --> 00:14:42,880
抢占的意思是，

251
00:14:43,780 --> 00:14:47,740
即使正在运行的代码不愿意，

252
00:14:48,070 --> 00:14:51,010
没有明确地让出 CPU ，

253
00:14:51,160 --> 00:14:53,500
定时器中断会夺走控制权，

254
00:14:53,710 --> 00:14:55,570
我们会让出给它，

255
00:14:55,570 --> 00:15:02,150
抢占式调度的反义词称为自愿式调度。

256
00:15:05,040 --> 00:15:06,330
有趣的事情是，

257
00:15:06,330 --> 00:15:11,370
抢占式调度在 xv6 等操作系统中的实现是

258
00:15:11,370 --> 00:15:14,100
定时器中断强制夺取 CPU ，

259
00:15:14,400 --> 00:15:18,840
然后内核自愿让出，

260
00:15:18,840 --> 00:15:21,300
切换到那个进程的线程。

261
00:15:24,100 --> 00:15:30,850
这里出现的另一个术语是，

262
00:15:30,850 --> 00:15:33,610
当线程运行时，

263
00:15:33,640 --> 00:15:36,630
有必要区分，

264
00:15:36,990 --> 00:15:42,510
系统区分当前在某些 CPU 上运行的线程，

265
00:15:42,630 --> 00:15:48,330
与想要运行，但当前没有在任何 CPU 上运行的线程，

266
00:15:48,330 --> 00:15:51,150
但是如果 CPU 空闲就可以运行，

267
00:15:51,390 --> 00:15:54,060
与那些实际上不想运行的线程，

268
00:15:54,060 --> 00:15:55,590
因为它们在等待 IO ，

269
00:15:55,590 --> 00:15:58,020
或者在等待什么事件。

270
00:15:58,600 --> 00:16:01,780
这种区别通常称为状态，

271
00:16:02,980 --> 00:16:05,110
即使线程的完整状态

272
00:16:05,110 --> 00:16:07,540
要比这复杂得多。

273
00:16:09,830 --> 00:16:11,390
既然说到这件事，

274
00:16:12,420 --> 00:16:15,300
我想列出几个我们会看到的状态，

275
00:16:16,370 --> 00:16:19,310
这些是 xv6 管理的状态，

276
00:16:19,310 --> 00:16:20,930
有一种状态是 RUNNING ，

277
00:16:20,930 --> 00:16:25,160
意味着它正在某个 CPU 上运行，

278
00:16:25,370 --> 00:16:31,650
有 RUNNABLE ，意味着目前没有在任何地方运行，

279
00:16:31,650 --> 00:16:36,030
但是有保存的状态，想要尽快运行，

280
00:16:36,360 --> 00:16:38,490
然后还有一个状态，

281
00:16:38,490 --> 00:16:41,580
今天不会讲太多，但是下周会讲到，

282
00:16:41,580 --> 00:16:45,270
叫做 SLEEPING ，表示线程等待某个 IO 事件，

283
00:16:45,480 --> 00:16:48,120
只有在 IO 事件发生之后运行，

284
00:16:48,300 --> 00:16:51,420
所以今天我们关注的运行时和可运行线程，

285
00:16:51,420 --> 00:16:53,610
这个抢先切换所做的，

286
00:16:53,610 --> 00:16:55,650
这个定时器中断和 yield 所做的是，

287
00:16:55,650 --> 00:16:57,660
将一个运行时线程，

288
00:16:57,690 --> 00:16:59,640
即被定时器中断的线程，

289
00:16:59,760 --> 00:17:01,800
转换为一个可运行线程。

290
00:17:02,160 --> 00:17:02,760
这是一个线程，

291
00:17:02,760 --> 00:17:06,180
通过让出或转换为另一个线程，

292
00:17:06,180 --> 00:17:07,140
它现在没有运行，

293
00:17:07,140 --> 00:17:08,910
但很明显它将会运行，

294
00:17:08,910 --> 00:17:12,060
因为它在计时器中断时运行。

295
00:17:14,220 --> 00:17:14,940
好的，那么，

296
00:17:14,970 --> 00:17:21,180
运行的线程的程序计数器寄存器在 CPU 中，

297
00:17:21,360 --> 00:17:24,420
在执行它的 CPU 的硬件寄存器中，

298
00:17:24,690 --> 00:17:27,870
可运行线程没有，

299
00:17:28,470 --> 00:17:30,840
它现在没有关联的 CPU ，

300
00:17:31,620 --> 00:17:33,270
所以，我们需要保存，

301
00:17:33,270 --> 00:17:39,510
对于可运行状态，我们需要保存所有 CPU 状态，

302
00:17:39,510 --> 00:17:45,540
任何线程运行时的 CPU 使用的状态，

303
00:17:45,720 --> 00:17:47,730
所以我们需要复制 CPU 的内容，

304
00:17:47,730 --> 00:17:49,890
不是 RAM ，只是寄存器，

305
00:17:50,040 --> 00:17:54,180
从 CPU 到内存中的某个地方以保存它们，

306
00:17:54,240 --> 00:17:56,550
当我们将线程从运行时转为可运行的时候。

307
00:17:56,640 --> 00:18:01,380
再说一次，我们必须明确保存的状态，

308
00:18:01,410 --> 00:18:04,650
只有 CPU 的运行状态，

309
00:18:04,650 --> 00:18:10,910
也就是程序计数器和 CPU 寄存器，

310
00:18:10,910 --> 00:18:12,170
所以这些需要保存，

311
00:18:13,000 --> 00:18:14,980
当将线程转换为可运行的。

312
00:18:15,520 --> 00:18:19,480
当某个调度器决定运行可运行线程时，

313
00:18:19,690 --> 00:18:23,890
那么，作为再次运行该线程的步骤一部分，

314
00:18:24,100 --> 00:18:27,010
我们会看到程序计数器，

315
00:18:27,010 --> 00:18:32,650
保存的程序计数器寄存器被复制回 CPU ，

316
00:18:32,980 --> 00:18:35,830
到调度器决定运行线程的 CPU 的寄存器上。

317
00:18:38,910 --> 00:18:42,960
好的，关于这些术语有什么问题吗？

318
00:18:49,880 --> 00:18:50,720
好的，我要，

319
00:18:50,750 --> 00:18:56,210
现在讨论一下 xv6 的东西。

320
00:18:57,760 --> 00:19:00,010
我要画两张图，

321
00:19:00,010 --> 00:19:02,500
关于线程和 xv6 ，

322
00:19:02,500 --> 00:19:05,320
一张是简单图，一张是更详细的图。

323
00:19:05,470 --> 00:19:09,870
像往常一样，用户的东西在上面，

324
00:19:09,870 --> 00:19:11,460
内核在下面。

325
00:19:14,040 --> 00:19:17,940
我们可能在用户级别运行多个进程，

326
00:19:17,940 --> 00:19:23,160
也许是 C 编译器、 ls 和 shell ，

327
00:19:23,520 --> 00:19:27,420
它们可能同时或不同时运行，

328
00:19:28,260 --> 00:19:37,180
在用户级别，每个进程都有，

329
00:19:38,400 --> 00:19:39,570
它有内存，

330
00:19:39,690 --> 00:19:42,840
我们特别感兴趣的是，

331
00:19:42,870 --> 00:19:45,510
每个进程都有用户堆栈，

332
00:19:46,840 --> 00:19:52,660
当它运行时，它在 RISC-V 硬件中有寄存器，

333
00:19:52,660 --> 00:19:54,610
PC 和寄存器。

334
00:19:55,590 --> 00:19:57,900
好的，当程序运行时，

335
00:19:57,900 --> 00:20:01,920
有一个在用户级别运行的控制线程，

336
00:20:02,760 --> 00:20:04,710
我要说的是，

337
00:20:04,710 --> 00:20:07,830
就像有一个用户线程，

338
00:20:07,860 --> 00:20:13,290
包含用户堆栈，用户内存，用户程序计数器，用户寄存器，

339
00:20:13,530 --> 00:20:15,360
如果程序访问系统调用，

340
00:20:15,360 --> 00:20:18,240
中断并进入内核，

341
00:20:19,020 --> 00:20:23,010
然后这些东西保存在这个程序的 trapframe 中，

342
00:20:23,640 --> 00:20:30,570
并且这个程序的内核线程被激活，

343
00:20:30,660 --> 00:20:35,760
现在， trapframe 保存着用户的东西，

344
00:20:35,760 --> 00:20:38,700
在我们保存了用户程序计数器寄存器之后，

345
00:20:38,850 --> 00:20:42,510
然后，我们将 CPU 切换到使用内核堆栈。

346
00:20:45,520 --> 00:20:47,590
我们不需要恢复寄存器，

347
00:20:47,590 --> 00:20:53,900
因为，进程的内核线程并没有真正运行，

348
00:20:53,900 --> 00:20:58,960
当用户线程运行时，它没有实际的保存状态，

349
00:20:58,990 --> 00:21:02,950
相反的，内核线程在其堆栈上激活。

350
00:21:02,980 --> 00:21:08,800
所以，第一次在 trampoline 和用户 trap 代码。

351
00:21:11,940 --> 00:21:13,710
然后内核运行一段时间，

352
00:21:13,710 --> 00:21:16,320
也许是系统调用或中断处理程序，

353
00:21:16,320 --> 00:21:17,250
不管是什么，

354
00:21:18,150 --> 00:21:22,740
有时，系统调用只是简单地返回，

355
00:21:22,740 --> 00:21:25,140
从这里到同一个进程，

356
00:21:25,140 --> 00:21:30,690
返回到用户空间，或者恢复该程序的程序计数器寄存器，

357
00:21:30,720 --> 00:21:34,320
但也可能不是简单地返回，

358
00:21:34,890 --> 00:21:36,180
而是因为这样或那样的原因，

359
00:21:36,180 --> 00:21:37,590
可能是因为定时器中断，

360
00:21:37,710 --> 00:21:39,900
我们要切换到另一个进程，

361
00:21:39,900 --> 00:21:42,270
高层次的观点是，

362
00:21:43,110 --> 00:21:48,930
如果 xv6 调度器决定从这个进程切换到不同进程，

363
00:21:49,590 --> 00:21:51,480
发生的第一件事是，

364
00:21:51,480 --> 00:21:54,540
我们要切换内核线程，

365
00:21:54,570 --> 00:21:58,260
从这个进程的内核线程到另一个进程的内核线程，

366
00:21:58,350 --> 00:22:01,530
然后其他进程的内核线程返回到用户空间。

367
00:22:01,530 --> 00:22:04,950
所以，假设 C 编译器需要读取磁盘，

368
00:22:05,070 --> 00:22:07,380
所以它会让出 CPU ，

369
00:22:07,860 --> 00:22:10,230
休眠并等待磁盘完成，

370
00:22:10,410 --> 00:22:13,710
也许 ls 想要执行，并处于可运行状态，

371
00:22:14,610 --> 00:22:17,250
xv6 调度器可能做的是，

372
00:22:17,400 --> 00:22:20,280
如果 ls 处于可运行状态，

373
00:22:20,280 --> 00:22:22,080
意味着它在某个地方停了下来，

374
00:22:22,080 --> 00:22:25,740
它的状态保存在一边，可能是因为定时器中断，

375
00:22:25,920 --> 00:22:28,890
所以 ls 有一个保存的 traframe ，

376
00:22:28,890 --> 00:22:32,880
包含用户寄存器和它自己的内核堆栈，

377
00:22:33,150 --> 00:22:40,910
它保存了一些与内核线程有关的寄存器，

378
00:22:40,940 --> 00:22:43,280
这被称为上下文。

379
00:22:43,520 --> 00:22:48,980
所以，如果 xv6 从编译器内核线程切换到 ls 内核线程，

380
00:22:49,500 --> 00:22:53,700
xv6 将保存内核寄存器，

381
00:22:53,790 --> 00:23:01,500
在 C 编译器内核线程切换到 ls 线程的上下文中，

382
00:23:02,730 --> 00:23:06,450
这个复杂的方案，我稍后会描述，

383
00:23:06,750 --> 00:23:11,560
我们恢复 ls 的内核线程寄存器，

384
00:23:11,560 --> 00:23:15,670
从上一次停止的 ls 上下文中，

385
00:23:16,000 --> 00:23:19,510
也许 ls 完成正在执行的系统调用，

386
00:23:19,510 --> 00:23:23,800
在 ls 的内核线程堆栈上，

387
00:23:24,160 --> 00:23:26,620
然后返回到 ls 系统调用，

388
00:23:26,620 --> 00:23:28,480
在返回用户空间的路上，

389
00:23:28,480 --> 00:23:32,810
它将为 ls 恢复以前保存的用户寄存器，

390
00:23:33,440 --> 00:23:35,660
然后继续执行 ls 。

391
00:23:35,690 --> 00:23:39,980
所以，这里有一堆我们将要讨论的细节，

392
00:23:39,980 --> 00:23:42,800
但也许这里的重点是，

393
00:23:42,830 --> 00:23:47,930
在 xv6 中，我们不会看到用户到用户的上下文切换，

394
00:23:47,930 --> 00:23:50,330
当我们从一个进程切换到另一个进程，

395
00:23:50,330 --> 00:23:54,760
总是一种策略，

396
00:23:54,760 --> 00:23:59,110
xv6 从一个进程切换到另一个进程是，

397
00:23:59,170 --> 00:24:01,570
跳入内核，保存进程状态，

398
00:24:01,570 --> 00:24:06,550
从这个进程的内核线程切换到另一个进程的内核线程，

399
00:24:06,550 --> 00:24:07,720
那个进程暂停了自己，

400
00:24:07,720 --> 00:24:10,000
然后返回并恢复用户寄存器，

401
00:24:10,000 --> 00:24:12,100
所以一直是这种间接的策略，

402
00:24:12,430 --> 00:24:13,990
实际上比这更间接的，

403
00:24:14,260 --> 00:24:15,790
对于线程切换，

404
00:24:15,910 --> 00:24:20,380
实际结果是从一个用户进程切换到另一个用户进程。

405
00:24:23,310 --> 00:24:26,400
关于这张图，有什么问题吗？

406
00:24:29,260 --> 00:24:32,890
切换，调度器，发生在这两个之间，对吗。

407
00:24:33,220 --> 00:24:36,700
是的，好的，让我来谈谈调度器，

408
00:24:36,700 --> 00:24:42,400
实际图片要比这复杂得多。

409
00:24:43,070 --> 00:24:47,890
这是更完整的图，

410
00:24:47,890 --> 00:24:52,170
假设我们有进程一 P1 正在运行，

411
00:24:52,170 --> 00:24:57,150
而进程二 P2 是可运行的，但是现在没有运行，

412
00:24:58,020 --> 00:24:59,550
还有一些额外的细节，

413
00:24:59,550 --> 00:25:02,730
我们在 xv6 中有多个核心，

414
00:25:02,730 --> 00:25:04,050
假设我们有两个核心，

415
00:25:04,050 --> 00:25:06,960
这意味着在硬件层面上，

416
00:25:07,680 --> 00:25:12,360
我们有 CPU0 ，它是其中一个核心，

417
00:25:12,660 --> 00:25:14,850
还有 CPU1 。

418
00:25:20,030 --> 00:25:21,710
更完整的故事是

419
00:25:21,710 --> 00:25:27,340
我们如何从执行用户空间到，

420
00:25:27,370 --> 00:25:29,920
在用户空间中执行的一个进程，

421
00:25:29,920 --> 00:25:33,460
到另一个可运行但没有运行的进程，

422
00:25:33,880 --> 00:25:36,910
第一部分与我所说的相同，

423
00:25:37,060 --> 00:25:39,790
定时器中断强制

424
00:25:40,390 --> 00:25:43,540
将控制从用户进程转移到内核，

425
00:25:43,600 --> 00:25:49,480
trampoline 代码保存进程一的用户寄存器和 trapframe ，

426
00:25:51,530 --> 00:25:54,900
然后执行 usertrap ，

427
00:25:54,900 --> 00:25:57,630
它知道该怎么处理这个 trap 或中断，

428
00:25:57,630 --> 00:25:59,940
系统调用，比如，

429
00:26:00,090 --> 00:26:04,440
所以有段时间，我们执行普通的内核 C 代码，

430
00:26:04,560 --> 00:26:07,830
在进程一的内核堆栈上。

431
00:26:10,240 --> 00:26:15,250
假设，进程一的内核代码决定让出 CPU ，

432
00:26:16,120 --> 00:26:18,580
它有一堆东西，我们可以看到细节，

433
00:26:18,610 --> 00:26:22,270
最终调用这个例程切换，

434
00:26:22,730 --> 00:26:26,060
是这个故事中的一个中心例程，

435
00:26:26,150 --> 00:26:29,900
switch 保存上下文，

436
00:26:29,900 --> 00:26:33,740
在上下文一中运行的内核线程的寄存器，

437
00:26:33,740 --> 00:26:35,450
所以有两组用户寄存器，

438
00:26:35,450 --> 00:26:40,450
用户寄存器， trapframe ，内核线程寄存器在上下文中。

439
00:26:41,510 --> 00:26:43,580
switch 不会，

440
00:26:43,580 --> 00:26:47,240
switch 从一个线程切换到另一个，

441
00:26:47,240 --> 00:26:50,600
但是实际上 xv6 的设计方式，

442
00:26:50,750 --> 00:26:54,890
用户线程，

443
00:26:54,920 --> 00:26:57,920
抱歉，在 CPU 上运行的内核线程可以切换的唯一位置是，

444
00:26:57,920 --> 00:27:00,710
那个 CPU 的调度器线程。

445
00:27:02,910 --> 00:27:05,550
所以我们甚至不能直接切换到另一个进程，

446
00:27:05,790 --> 00:27:07,680
只能切换到调度器线程，

447
00:27:07,680 --> 00:27:09,150
所以这里有一个，

448
00:27:10,360 --> 00:27:16,510
完整的线程装置专用于 CPU0 的调度器，

449
00:27:16,540 --> 00:27:17,830
因为我们使用的是 CPU ，

450
00:27:17,830 --> 00:27:25,390
这个 switch 会切换到调度器线程的之前保存的寄存器，

451
00:27:25,420 --> 00:27:27,340
假设是调度器 0 。

452
00:27:29,650 --> 00:27:33,070
在 CPU0 的调度器中，

453
00:27:33,100 --> 00:27:36,100
switch 会，通过恢复这些寄存器，

454
00:27:36,100 --> 00:27:38,440
由于寄存器包括堆栈指针，

455
00:27:38,440 --> 00:27:40,450
正如我们看到的， switch 的返回，

456
00:27:40,630 --> 00:27:53,650
将会返回到 CPU0 上的调度器函数，

457
00:27:53,650 --> 00:27:56,410
调度器函数会进行一些清理，

458
00:27:56,410 --> 00:27:58,630
使进程一进入休眠状态，

459
00:27:58,720 --> 00:28:02,020
然后它在进程表中查找另一个进程，

460
00:28:02,020 --> 00:28:03,400
一个可运行进程，

461
00:28:03,640 --> 00:28:06,130
如果它找到了一个，

462
00:28:07,160 --> 00:28:10,550
所以我们从这里下来，然后到调度器，

463
00:28:10,670 --> 00:28:12,620
如果调度器找到另一个要运行的进程，

464
00:28:12,620 --> 00:28:16,430
或者发现进程一是可运行的，并且仍然想要运行，

465
00:28:16,430 --> 00:28:19,010
找到进程一，没有别的进程想要运行，

466
00:28:19,850 --> 00:28:22,940
但不管怎样，调度器会再次调用 switch ，

467
00:28:22,940 --> 00:28:27,020
将上下文切换到进程二，

468
00:28:27,960 --> 00:28:32,490
在线程中， switch 再次保存自己的寄存器到自己的上下文中，

469
00:28:33,020 --> 00:28:36,680
它们也会是前序保存的上下文，

470
00:28:36,680 --> 00:28:38,720
当进程而停止时，

471
00:28:38,900 --> 00:28:41,870
这组寄存器将被恢复，

472
00:28:42,440 --> 00:28:44,870
进程二将使用前序调用，

473
00:28:44,870 --> 00:28:50,560
像进程一样，切换到调度器线程，

474
00:28:50,560 --> 00:28:51,550
当它停下来的时候，

475
00:28:51,730 --> 00:28:53,200
它调用 switch 返回

476
00:28:53,200 --> 00:28:56,150
无论系统调用还是中断，

477
00:28:56,150 --> 00:28:58,910
进程二结束，

478
00:28:59,030 --> 00:29:02,510
会有一个先前保存的进程二的 trapframe ，

479
00:29:02,720 --> 00:29:04,220
它将包含用户寄存器，

480
00:29:04,220 --> 00:29:08,360
也可以恢复或返回到用户空间。

481
00:29:09,050 --> 00:29:15,920
每个 CPU 都有一个完整的、单独的调度器线程，

482
00:29:15,920 --> 00:29:18,950
所以，它们也将被保存，

483
00:29:19,700 --> 00:29:22,940
CPU1 的调度器线程的上下文，

484
00:29:23,210 --> 00:29:28,960
以及在调度器一上运行的调度器循环，

485
00:29:28,960 --> 00:29:32,950
以及任何运行在 CPU1 上的进程，比如进程三或其他，

486
00:29:32,950 --> 00:29:34,750
当它决定让出 CPU 时，

487
00:29:34,750 --> 00:29:41,410
它将切换到 CPU 为它的调度器线程。

488
00:29:43,800 --> 00:29:44,850
好的，这里有一个问题，

489
00:29:44,850 --> 00:29:46,980
上下文存储在哪里，

490
00:29:47,310 --> 00:29:52,370
对于这些我刚才说的操作，

491
00:29:52,550 --> 00:29:54,140
保存的，

492
00:29:54,200 --> 00:30:00,190
事实上，对于线程切换，

493
00:30:01,030 --> 00:30:04,450
这些上下文，这些内核线程保存的寄存器

494
00:30:04,450 --> 00:30:05,860
都在进程结构体中，

495
00:30:06,190 --> 00:30:11,890
所以，任何内核线程只能有一组保存的内核寄存器。

496
00:30:12,380 --> 00:30:15,680
因为每个线程只在一个位置执行，

497
00:30:15,680 --> 00:30:20,690
它的上下文在某种程度上反映了它执行的位置，

498
00:30:20,690 --> 00:30:23,420
线程是单个控制线程，

499
00:30:23,420 --> 00:30:27,350
所以一个线程只需要一个寄存器的上下文，

500
00:30:27,380 --> 00:30:33,190
所以，它在进程结构体的 p->context 。

501
00:30:35,310 --> 00:30:38,670
而且每个调度器线程都有自己的上下文，

502
00:30:38,670 --> 00:30:39,900
不是在，

503
00:30:40,230 --> 00:30:43,380
没有与调度器线程关联的进程，

504
00:30:43,620 --> 00:30:50,710
调度器的上下文存储在核心的 CPU 结构体中。

505
00:30:51,480 --> 00:30:54,120
有一组 CPU 结构体，每个核心一个，

506
00:30:54,120 --> 00:30:55,860
每一个有一个上下文。

507
00:30:58,210 --> 00:31:02,200
为什么我们不能将寄存器包括在进程的 trapframe 中，

508
00:31:02,230 --> 00:31:08,890
实际上，这些寄存器可以存储在 trapframe 中，

509
00:31:08,890 --> 00:31:14,050
因为只有一个内核线程寄存器的存储集，

510
00:31:14,260 --> 00:31:17,050
对于进程，我们可以将它们保存在任何数据结构中，

511
00:31:17,230 --> 00:31:22,030
比如存在进程数据结构实例的一个元素，

512
00:31:22,270 --> 00:31:24,400
只有一个进程结构，

513
00:31:24,400 --> 00:31:26,380
有一个用于进程的 trapframe 结构，

514
00:31:26,500 --> 00:31:28,450
我们可以把寄存器保存在 trapframe 中。

515
00:31:31,730 --> 00:31:33,140
我是说，只是，

516
00:31:33,720 --> 00:31:35,730
可能是为了代码的简单性或清晰性，

517
00:31:35,730 --> 00:31:40,040
trapframe 只包含数据，

518
00:31:40,040 --> 00:31:42,500
进入和离开内核时需要的（数据）。

519
00:31:43,060 --> 00:31:47,920
content 结构由需要保存和恢复的内容组成，

520
00:31:47,920 --> 00:31:52,540
当内核线程和调度器线程之间切换时。

521
00:31:54,640 --> 00:31:55,360
好的，问题是，

522
00:31:55,360 --> 00:31:58,210
yield 是有内核调用的，

523
00:31:59,060 --> 00:32:02,630
所以在 xv6 中，用户线程没有真正直接的方式，

524
00:32:02,630 --> 00:32:08,240
用户线程让出 CPU 或切换，

525
00:32:08,480 --> 00:32:12,320
它是通过内核这种透明的完成，

526
00:32:13,210 --> 00:32:16,510
它会在内核觉得有必要发生的时候出现，

527
00:32:16,810 --> 00:32:17,920
如果有线程，

528
00:32:18,460 --> 00:32:22,960
有时候，你能猜到，

529
00:32:22,960 --> 00:32:26,500
一个系统调用可能让出，

530
00:32:26,500 --> 00:32:30,130
比如，如果进程在管道上进行读取，

531
00:32:30,130 --> 00:32:33,190
它知道在管道中没有需要等待读取的东西，

532
00:32:33,400 --> 00:32:35,290
那么读取就会阻塞，

533
00:32:35,870 --> 00:32:37,370
你可以预测读取阻塞，

534
00:32:37,370 --> 00:32:40,620
内核将运行其他进程，

535
00:32:40,620 --> 00:32:42,930
当我们等待数据出现在管道中时。

536
00:32:44,800 --> 00:32:47,800
所以，内核调用 yield 的时机，

537
00:32:47,800 --> 00:32:48,940
有两个主要的时机，

538
00:32:48,940 --> 00:32:53,650
一种是如果计时器中断，内核总会让出，

539
00:32:53,860 --> 00:32:56,760
基于这样的理论，

540
00:32:57,640 --> 00:33:02,500
我们应该交错执行所有这些进程，

541
00:33:02,500 --> 00:33:06,500
想要定期在定时器中断时运行，

542
00:33:06,770 --> 00:33:09,020
所处，定时器中断总是调用 yield ，

543
00:33:09,410 --> 00:33:13,280
当进程系统调用等待 IO 时，

544
00:33:13,370 --> 00:33:15,200
等待你输入下一次按键，

545
00:33:15,200 --> 00:33:16,910
读取控制台，

546
00:33:16,910 --> 00:33:18,110
但是你没有按键，

547
00:33:18,410 --> 00:33:24,070
然后等待 IO 调用的机器调用 yield ，

548
00:33:24,070 --> 00:33:26,650
调用 sleep ，我们下周会谈到。

549
00:33:29,200 --> 00:33:29,800
好的。

550
00:33:31,540 --> 00:33:32,950
好的，那么。

551
00:33:32,950 --> 00:33:34,390
我有一个问题。

552
00:33:34,420 --> 00:33:35,020
好的。

553
00:33:35,700 --> 00:33:37,530
如果是 sleep ，

554
00:33:37,560 --> 00:33:40,020
它是否会做大致相同的事，

555
00:33:40,080 --> 00:33:42,660
比如会是系统调用，

556
00:33:42,690 --> 00:33:44,520
保存 trapframe ，

557
00:33:44,790 --> 00:33:47,850
然后是一样的[图片]，

558
00:33:47,850 --> 00:33:51,570
但它只是，

559
00:33:51,570 --> 00:33:55,800
使进程在没有定时器中断的情况下进入内核，

560
00:33:55,800 --> 00:33:57,350
但是，是进程自己决定的吗？

561
00:33:57,900 --> 00:34:03,510
是的，所以这个进程有一个读取系统调用，

562
00:34:03,510 --> 00:34:04,710
这就是为什么它在内核中，

563
00:34:05,330 --> 00:34:11,210
而读取需要这个进程等待磁盘完成读取，

564
00:34:11,210 --> 00:34:13,220
或者等待数据出现在管道上，

565
00:34:13,310 --> 00:34:16,310
那么图跟这个是一样的，

566
00:34:18,510 --> 00:34:20,100
内核中调用系统调用，

567
00:34:20,100 --> 00:34:22,200
trapframe ，所有保存的用户寄存器，

568
00:34:22,200 --> 00:34:23,970
执行系统调用，系统会[]，

569
00:34:24,000 --> 00:34:26,550
需要等待磁盘完成读取某些内容，

570
00:34:27,480 --> 00:34:31,770
系统调用调用 sleep ，包含 switch ，

571
00:34:32,180 --> 00:34:38,150
保存进程上下文中的内核线程寄存器，

572
00:34:38,450 --> 00:34:41,090
切换到该当前 CPU 调度器，

573
00:34:41,090 --> 00:34:42,680
让其他线程运行，

574
00:34:42,710 --> 00:34:45,980
而这个线程等待磁盘读取完成。

575
00:34:46,590 --> 00:34:48,690
所以，我们现在谈论的一切，

576
00:34:48,720 --> 00:34:50,520
除了定时器中断，

577
00:34:50,970 --> 00:34:53,100
几乎都是一样的，

578
00:34:53,100 --> 00:34:55,680
如果发生的情况是我们使用系统调用，

579
00:34:55,680 --> 00:34:58,470
系统调用需要等待一些 IO ，

580
00:34:58,680 --> 00:34:59,700
并放弃 CPU 。

581
00:35:02,250 --> 00:35:04,230
对于今天的讨论，

582
00:35:04,230 --> 00:35:06,090
这两种情况几乎是一样的。

583
00:35:08,970 --> 00:35:12,090
好的，问题是每个 CPU 调度器都有自己的堆栈吗。

584
00:35:12,090 --> 00:35:13,020
是的，

585
00:35:13,290 --> 00:35:15,030
这里有一个堆栈，

586
00:35:18,600 --> 00:35:22,350
而这个调度器有单独的堆栈，

587
00:35:23,730 --> 00:35:26,520
对于 CPU1 的调度器。

588
00:35:31,920 --> 00:35:35,010
是的，这个调度器的堆栈也设置好了，

589
00:35:36,300 --> 00:35:38,040
实际上，所有这些东西，

590
00:35:38,070 --> 00:35:41,910
上下文，堆栈，调度器线程，

591
00:35:41,910 --> 00:35:45,060
设置与用户进程的设置方式不同。

592
00:35:46,450 --> 00:35:48,130
它们是在引导时设置的，

593
00:35:48,280 --> 00:35:54,220
如果查看 start.S 或 start.c ，

594
00:35:54,220 --> 00:35:59,020
你会看到每个核心的调度器线程的设置，

595
00:35:59,020 --> 00:36:03,070
堆栈在引导的汇编代码中非常早的位置，

596
00:36:03,100 --> 00:36:06,220
其中为每个 CPU 设置堆栈，

597
00:36:06,220 --> 00:36:07,300
在那个堆栈上，

598
00:36:07,300 --> 00:36:09,460
CPU 引导，

599
00:36:09,640 --> 00:36:11,320
然后运行它的调度器线程。

600
00:36:15,590 --> 00:36:16,880
好的，嗯。

601
00:36:18,930 --> 00:36:20,430
一条行话，

602
00:36:20,430 --> 00:36:23,700
当人们谈论上下文切换时，

603
00:36:24,840 --> 00:36:32,240
他们谈论的通常是这种行为，

604
00:36:32,240 --> 00:36:34,070
从一个线程切换到另一个，

605
00:36:34,070 --> 00:36:37,040
保存旧线程的一组寄存器，

606
00:36:37,220 --> 00:36:40,730
并且恢复要切换到的线程先前保存的寄存器，

607
00:36:41,600 --> 00:36:43,070
这就是上下文的意思，

608
00:36:43,070 --> 00:36:47,700
有时它也适用于完整的，

609
00:36:47,700 --> 00:36:50,280
一个用户进程切换到另一个，

610
00:36:50,280 --> 00:36:54,810
偶尔会看到在用户和内核之间切换的上下文，

611
00:36:54,930 --> 00:36:57,060
但对我们来说，我们大多数的意思是，

612
00:36:58,260 --> 00:37:03,670
从一个内核线程切换到调度器线程。

613
00:37:04,980 --> 00:37:08,130
只是一些片段信息，

614
00:37:10,100 --> 00:37:13,430
要记住的[][]，

615
00:37:13,610 --> 00:37:16,580
每个核心一次只做一件事，

616
00:37:16,610 --> 00:37:21,320
每个核心在任何时间只运行一个线程，

617
00:37:21,320 --> 00:37:25,700
它要么运行一些用户线程或一些内核线程，

618
00:37:25,730 --> 00:37:27,890
或核心的调度器线程，

619
00:37:28,190 --> 00:37:30,830
所以在任何时间，核心都不会做多件事，

620
00:37:30,830 --> 00:37:31,850
它只是在做一件事，

621
00:37:31,850 --> 00:37:34,700
正是这种切换在创造了一个假象，

622
00:37:34,700 --> 00:37:39,200
多个线程在核心上不同时间运行，

623
00:37:39,620 --> 00:37:46,360
类似地，每个线程运行在，

624
00:37:46,870 --> 00:37:50,320
要么在一个核心上运行，

625
00:37:50,740 --> 00:37:54,130
或它的状态已保存，

626
00:37:54,130 --> 00:37:55,570
然后我们从它切换走。

627
00:37:56,280 --> 00:37:57,840
所以，一个线程，

628
00:37:57,840 --> 00:38:00,270
线程不会在多个核心上运行，

629
00:38:00,270 --> 00:38:02,160
线程要么在一个核心上运行，

630
00:38:02,190 --> 00:38:05,310
要么根本没有运行，作为保存状态。

631
00:38:06,610 --> 00:38:10,690
另一个关于 xv6 设置的有趣的事情是，

632
00:38:10,780 --> 00:38:17,190
这些上下文保存内核线程寄存器，

633
00:38:17,430 --> 00:38:20,280
它们总是由调用 swtch 产生，

634
00:38:20,670 --> 00:38:27,210
所以，这些上下文总是关联指线程的状态，

635
00:38:27,240 --> 00:38:30,420
它在对 swtch 的调用中执行的。

636
00:38:33,240 --> 00:38:35,820
我们会看到的方式是，

637
00:38:35,910 --> 00:38:38,610
当我们从一个切换到另一个，

638
00:38:38,610 --> 00:38:40,950
并恢复目标线程的上下文，

639
00:38:41,100 --> 00:38:45,240
它要做的第一件事是从上一个调用返回到 swtch ，

640
00:38:45,390 --> 00:38:47,700
这些上下文总是保存状态，

641
00:38:48,270 --> 00:38:50,160
就像它在 swtch 里一样。

642
00:38:52,490 --> 00:38:53,180
好的。

643
00:38:56,060 --> 00:39:00,320
关于图表级别的情况，还有什么问题吗？

644
00:39:05,240 --> 00:39:06,470
我有一个问题，

645
00:39:06,740 --> 00:39:08,900
你一直使用线程这个术语，

646
00:39:08,900 --> 00:39:12,500
但在我看来，我们对 xv6 的实现，

647
00:39:12,860 --> 00:39:15,710
一个进程只有一个线程，

648
00:39:15,860 --> 00:39:19,460
所以，有没有可能一个进程可以有多个线程，

649
00:39:19,460 --> 00:39:21,050
还是我说错了。

650
00:39:21,740 --> 00:39:24,630
在 xv6 中，好的。

651
00:39:26,030 --> 00:39:29,870
我们在这里的说法是有一些让人困惑的地方，

652
00:39:29,900 --> 00:39:31,460
在 xv6 中，

653
00:39:32,260 --> 00:39:34,150
一个进程，

654
00:39:38,470 --> 00:39:43,930
一个进程执行用户级别的指令，

655
00:39:44,080 --> 00:39:49,000
或者执行内核中的指令，

656
00:39:49,780 --> 00:39:52,900
或者根本不执行，

657
00:39:52,900 --> 00:39:59,440
它的状态被保存到上下文和 trapframe 中。

658
00:40:02,300 --> 00:40:03,920
所以这就是实际情况，

659
00:40:03,980 --> 00:40:05,570
你怎么叫它，

660
00:40:09,060 --> 00:40:10,740
你想怎么叫都行，

661
00:40:10,800 --> 00:40:13,950
我不知道对这个结构有什么简单的解释，

662
00:40:14,160 --> 00:40:16,320
我们一直这样叫它，

663
00:40:16,590 --> 00:40:20,640
我一直说每个进程有两个线程，

664
00:40:21,100 --> 00:40:24,930
一个用户级线程和一个内核级线程，

665
00:40:25,080 --> 00:40:26,190
这是一个进程，

666
00:40:26,190 --> 00:40:27,090
有这样的限制，

667
00:40:27,090 --> 00:40:28,860
进程只会执行，

668
00:40:28,860 --> 00:40:31,770
或者在用户空间的内核中执行，

669
00:40:31,860 --> 00:40:35,070
或者在内核中中断系统调用中，

670
00:40:35,430 --> 00:40:36,240
但不能两个同时。

671
00:40:38,680 --> 00:40:39,820
理解了。

672
00:40:39,850 --> 00:40:43,780
是的，我为这件事的复杂性道歉。

673
00:40:47,540 --> 00:40:48,110
好的。

674
00:40:48,710 --> 00:40:50,690
好的，让我切换到代码，

675
00:40:50,690 --> 00:40:52,220
看看 xv6 代码。

676
00:41:01,130 --> 00:41:04,250
好的，首先，

677
00:41:10,090 --> 00:41:15,520
我展示一些我们一直在谈论的东西，

678
00:41:15,520 --> 00:41:20,300
我来看一下进程的结构。

679
00:41:20,970 --> 00:41:22,440
我们可以在进程结构中看到，

680
00:41:22,440 --> 00:41:23,880
很多东西我们已经讨论过，

681
00:41:24,390 --> 00:41:26,250
复习一下，

682
00:41:26,250 --> 00:41:34,980
这是 trapframe ，保存了用户级别寄存器。保存用户级寄存器的陷阱帧。

683
00:41:36,440 --> 00:41:43,810
这里有一个上下文，它保存内核线程寄存器，

684
00:41:43,810 --> 00:41:46,000
当切换到调度器线程。

685
00:41:46,580 --> 00:41:51,320
有一个指向这个进程的指针是内核堆栈，

686
00:41:51,320 --> 00:41:53,810
保存函数调用的位置，

687
00:41:53,960 --> 00:41:55,490
当我门在内核中执行时。

688
00:41:56,560 --> 00:41:58,780
这是状态变量，

689
00:41:58,780 --> 00:42:03,490
它记录该进程是否正在运行或是否可运行，

690
00:42:03,490 --> 00:42:05,800
或者处于休眠状态或根本没有分配。

691
00:42:06,550 --> 00:42:13,500
最后，这里有一个锁，保护我们看到的各种东西，

692
00:42:15,710 --> 00:42:22,670
目前，我们可以看到，至少保护了对状态变量的更改。

693
00:42:23,480 --> 00:42:26,360
比如，两个调度器线程，

694
00:42:26,360 --> 00:42:29,720
不会试图获取一个可运行的进程并同时运行它。

695
00:42:30,300 --> 00:42:32,970
这个锁做的事情之一就是防止这种情况发生。

696
00:42:35,280 --> 00:42:40,680
我要为你们运行一个简单的演示程序 spin 程序。

697
00:42:41,460 --> 00:42:44,760
我要用它来推动，

698
00:42:44,970 --> 00:42:47,220
创造一种可预测的情况，

699
00:42:47,220 --> 00:42:49,710
我们从一个线程切换到另一个线程，

700
00:42:49,890 --> 00:42:52,290
但这就是这个程序，

701
00:42:52,290 --> 00:42:54,840
spin 程序创建了两个进程，

702
00:42:54,840 --> 00:42:56,850
而且这两个过程都是永远计算的，

703
00:42:57,320 --> 00:42:59,570
在这里调用 fork，

704
00:43:00,320 --> 00:43:02,330
我创造了一个子程序，

705
00:43:02,420 --> 00:43:07,310
然后两个子程序永远在这个循环里，

706
00:43:07,310 --> 00:43:08,990
而每个进程打印一个字符，

707
00:43:08,990 --> 00:43:10,760
所以，我们可以看到它们的进展，

708
00:43:11,000 --> 00:43:13,340
但是它们不经常打印字符，

709
00:43:13,340 --> 00:43:17,570
而且它们从来不会故意放弃 CPU 。

710
00:43:17,600 --> 00:43:21,620
所以我们这里有两个计算密集型进程，

711
00:43:21,740 --> 00:43:23,390
为了让它们两个都跑起来，

712
00:43:23,390 --> 00:43:25,940
我将在单个 CPU 上运行它们，

713
00:43:26,780 --> 00:43:29,660
只有一个核心的 xv6 ，

714
00:43:29,720 --> 00:43:31,490
所以，为了让它们两个都能执行，

715
00:43:31,610 --> 00:43:38,800
有必要在这两个进程之间切换。

716
00:43:40,440 --> 00:43:45,600
让我使用 gdb 把 spin 程序启动起来，

717
00:43:51,020 --> 00:43:53,180
运行 spin 程序，你可以看到它在打印，

718
00:43:53,210 --> 00:43:56,720
其中一个进程打印正斜杠，

719
00:43:56,720 --> 00:43:58,400
另一个打印反斜杠，

720
00:43:58,400 --> 00:44:00,500
你可以看到，每隔一段时间，

721
00:44:00,740 --> 00:44:03,170
xv6 在它们之间切换，

722
00:44:03,170 --> 00:44:05,270
而且只有一个核心，就像我配置的那样，

723
00:44:05,480 --> 00:44:08,960
所以我们看到打印一堆正斜杠，

724
00:44:08,960 --> 00:44:11,000
然后很明显是计时器中断，

725
00:44:11,000 --> 00:44:15,410
将一个 CPU 切换到另一个进程，

726
00:44:15,410 --> 00:44:17,930
然后打印一会另一种斜杠。

727
00:44:17,990 --> 00:44:20,660
所以，我想要观察的是计时器中断的运行，

728
00:44:20,810 --> 00:44:24,630
所以我要在 trap 里放一个断点，

729
00:44:26,940 --> 00:44:30,360
尤其是在 trap 中的第 207 行，

730
00:44:35,060 --> 00:44:45,240
trap 中的 devintr 代码，

731
00:44:45,240 --> 00:44:49,320
表示我们在中断中，

732
00:44:49,320 --> 00:44:52,050
并且这是中断是由定时器中断引起的。

733
00:44:53,430 --> 00:44:56,040
所以我在这里设置一个断点，

734
00:44:56,040 --> 00:44:59,880
在 trap.c 第 207 行，

735
00:44:59,880 --> 00:45:04,080
继续[]我刚才触发的 trap ，

736
00:45:04,080 --> 00:45:05,850
因为定时器中断相当频繁，

737
00:45:06,150 --> 00:45:06,900
我们可以从得到，

738
00:45:06,900 --> 00:45:10,860
用户 trap 调用 devintr 的地方，

739
00:45:11,400 --> 00:45:12,930
来处理这个中断。

740
00:45:13,480 --> 00:45:18,400
我想离开 devintr ，回到用户 trap 中。

741
00:45:20,420 --> 00:45:21,230
因为，事实上我们没有，

742
00:45:22,640 --> 00:45:25,250
devintr 到定时器中断的代码没有什么东西。

743
00:45:27,340 --> 00:45:34,810
然而，一旦我们回到 usertrap ，

744
00:45:36,200 --> 00:45:39,440
我们可以从这一行看到，

745
00:45:39,440 --> 00:45:41,630
我们刚从 devintr 返回。

746
00:45:47,860 --> 00:45:52,930
有趣的是，

747
00:45:54,340 --> 00:45:56,020
我们接下来要做的，

748
00:45:56,530 --> 00:45:59,020
期待我们在这一行，

749
00:45:59,140 --> 00:46:03,010
我们期待这里调用 yield ，

750
00:46:03,730 --> 00:46:07,300
在这里你可以看到， devintr 返回了 2 ，

751
00:46:07,450 --> 00:46:08,980
返回的是 2 ，

752
00:46:08,980 --> 00:46:11,140
2 是设备号，

753
00:46:11,320 --> 00:46:13,450
我们很快就会看到这一点，

754
00:46:13,480 --> 00:46:15,880
因为哪个设备是 2 ，

755
00:46:16,480 --> 00:46:18,820
usertrap 要 yield 的，

756
00:46:18,820 --> 00:46:22,320
它获得 CPU 并允许运行进程，

757
00:46:22,770 --> 00:46:23,700
你很快就会看到这一点，

758
00:46:23,910 --> 00:46:27,960
同时，让我们看看中断发生时正在执行的是什么。

759
00:46:28,140 --> 00:46:29,820
我要打印 p ，

760
00:46:31,010 --> 00:46:35,960
变量 p 保存着指向当前进程结构 proc 的指针。

761
00:46:38,890 --> 00:46:42,790
好的，问题是什么让每个进程的内核线程不同。

762
00:46:43,260 --> 00:46:47,310
每个进程都有单独的内核线程，

763
00:46:47,930 --> 00:46:52,490
确实有两个不同的进程内核线程，

764
00:46:52,490 --> 00:46:55,670
因为多个可以在不同的核心上执行。

765
00:46:57,650 --> 00:47:01,940
一个是每个进程都有单独的内核堆栈，

766
00:47:01,940 --> 00:47:05,990
就是结构体 proc 的 kstack 所指向的，

767
00:47:06,470 --> 00:47:08,150
另一个是，

768
00:47:13,490 --> 00:47:15,680
早些时候，

769
00:47:16,600 --> 00:47:19,600
当 usertrap C 代码调用时，

770
00:47:20,380 --> 00:47:22,720
通过 trampoline ，当中断发生时。

771
00:47:25,640 --> 00:47:29,630
我们可以通过任何内核代码区分它们，

772
00:47:29,630 --> 00:47:36,050
可以通过调用 myproc 来判断当前 CPU 上正在运行哪些进程。

773
00:47:36,620 --> 00:47:39,290
这是另一个不同的地方，

774
00:47:40,500 --> 00:47:43,500
这允许内核代码区分，

775
00:47:43,500 --> 00:47:47,850
哪个进程内核线程正在执行，

776
00:47:47,850 --> 00:47:50,640
而 myproc 使用的是 tp 寄存器，

777
00:47:50,640 --> 00:47:51,630
你可能还记得，

778
00:47:52,080 --> 00:47:58,300
设置为包含当前核心 hartid 或核心编号，

779
00:47:58,360 --> 00:48:01,000
使用它来索引到一个结构数组，

780
00:48:01,000 --> 00:48:04,270
也就是说，对于调度器设置的每个核心，

781
00:48:04,300 --> 00:48:07,420
每当它切换进程以指示每个核心，

782
00:48:07,420 --> 00:48:09,490
哪个进程在那个核心上运行。

783
00:48:10,660 --> 00:48:13,720
这就是不同内核如何区分。

784
00:48:15,730 --> 00:48:17,650
好的，我要使用这个 p 的值，

785
00:48:17,710 --> 00:48:21,910
名称和 p 值以确定哪个进程正在运行，

786
00:48:21,910 --> 00:48:26,680
xv6 记得名字就是 spin 进程，像预期的一样，

787
00:48:26,920 --> 00:48:31,570
有两个进程，我想进程 id 分别是 3 和 4 。

788
00:48:32,150 --> 00:48:32,780
糟糕。

789
00:48:34,680 --> 00:48:37,260
我们现在再次执行进程 3 ，

790
00:48:37,440 --> 00:48:41,400
所以在切换之后，我们应该在进程 4 中，

791
00:48:41,430 --> 00:48:42,900
另一个 spin 进程，

792
00:48:43,170 --> 00:48:48,390
我们可以查看 trapframe 中保存的用户寄存器。

793
00:48:54,600 --> 00:48:56,910
这是 32 个寄存器，

794
00:48:56,940 --> 00:49:01,890
trampoline 代码保存用户状态，

795
00:49:02,130 --> 00:49:08,130
用户 ra 返回用户堆栈指针的地址，

796
00:49:08,520 --> 00:49:11,070
用户寄存器是十六进制 62 。

797
00:49:12,050 --> 00:49:16,580
这些都是我们在观察 trap 时熟悉的东西。

798
00:49:17,290 --> 00:49:20,170
你可能最感兴趣的是，

799
00:49:23,290 --> 00:49:27,040
trapframe 保存着用户程序计数器和值 62 ，

800
00:49:28,090 --> 00:49:35,620
如果我们关心，可以查看 spin.c 的汇编代码。

801
00:49:36,540 --> 00:49:40,160
糟糕，在 spin.asm 查找 62 ，

802
00:49:41,100 --> 00:49:44,190
我们可以看到有一个中断定时器，

803
00:49:44,190 --> 00:49:50,490
中断发生在 spin 无限循环中的加法指令期间，

804
00:49:50,700 --> 00:49:51,900
这并不令人惊讶。

805
00:49:55,390 --> 00:50:01,630
好的，回到刚才返回的 trap 代码，

806
00:50:01,780 --> 00:50:06,700
我要单步几次把我们带到，

807
00:50:09,130 --> 00:50:11,590
到达执行 yield 。

808
00:50:12,260 --> 00:50:16,040
而 yield 是进程中让出 CPU 的第一步，

809
00:50:16,040 --> 00:50:17,090
切换到调度器，

810
00:50:17,090 --> 00:50:20,840
让调度器选择进程中的另一个内核线程来运行。

811
00:50:24,240 --> 00:50:27,000
好的，让我们单步进入 yield ，

812
00:50:27,480 --> 00:50:28,710
现在我们在 yield ， yield 是。

813
00:50:30,110 --> 00:50:30,980
你有什么问题吗。

814
00:50:31,580 --> 00:50:31,910
不是。

815
00:50:43,450 --> 00:50:46,840
好的，我们在 yield 中，

816
00:50:47,500 --> 00:50:49,180
yield 做了几件事，

817
00:50:49,180 --> 00:50:54,370
它获取这个进程的锁，

818
00:50:54,400 --> 00:50:57,070
因为它要对这个进程进行一系列的修改，

819
00:50:57,070 --> 00:50:58,960
而且它不希望有任何其他的，

820
00:50:59,140 --> 00:51:01,540
实际上，在它放弃锁之前，

821
00:51:01,540 --> 00:51:04,450
这个进程的状态会是一致的，

822
00:51:04,540 --> 00:51:09,460
比如， yield 将进程的状态更改为可运行，

823
00:51:09,460 --> 00:51:12,010
这表明，

824
00:51:12,420 --> 00:51:14,640
这个进程没有在运行，但希望运行，

825
00:51:14,940 --> 00:51:17,550
但是这个进程是在运行的，

826
00:51:17,640 --> 00:51:19,290
我是说，我们正在运行这个进程，

827
00:51:19,290 --> 00:51:21,870
就是正在执行的这个进程的内核线程，

828
00:51:22,020 --> 00:51:25,530
所以，获取这个锁所做的事情之一是，

829
00:51:25,890 --> 00:51:29,070
让它，尽管我们修改状态为可运行，

830
00:51:29,100 --> 00:51:33,430
没有其他核心的调度线程会看到这个进程，

831
00:51:33,580 --> 00:51:35,350
因为使用了锁，

832
00:51:35,560 --> 00:51:38,020
（其他核心）看到它是可运行的，并试着运行它，

833
00:51:38,290 --> 00:51:40,000
当我们还在这个核心上运行它时，

834
00:51:40,030 --> 00:51:41,200
将会是一场灾难，

835
00:51:41,200 --> 00:51:44,770
在两个不同的核心上运行相同的进程，

836
00:51:44,800 --> 00:51:46,780
你知道进程只有一个堆栈，

837
00:51:47,050 --> 00:51:51,070
这意味着两个不同的核心在同一个堆栈上调用[子例程]，

838
00:51:51,070 --> 00:51:53,920
这是一个灾难。

839
00:51:54,680 --> 00:51:56,750
所以，我们使用了锁，

840
00:51:59,380 --> 00:52:03,430
yield 把状态改为可运行。

841
00:52:04,130 --> 00:52:05,300
这意味着，

842
00:52:05,420 --> 00:52:08,290
我们最终放弃了，

843
00:52:11,960 --> 00:52:14,060
当我们最终放弃 CPU ，

844
00:52:14,060 --> 00:52:15,470
切换到调度器进程，

845
00:52:15,470 --> 00:52:17,450
这个状态会保持在可运行状态，

846
00:52:17,450 --> 00:52:18,710
这样它就可以再次运行，

847
00:52:18,980 --> 00:52:20,750
毕竟这是一个计时器中断，

848
00:52:20,750 --> 00:52:22,970
中断了正在运行的用户级进程，

849
00:52:22,970 --> 00:52:24,590
它希望继续运行。

850
00:52:25,790 --> 00:52:27,140
我们把状态设置为可运行，

851
00:52:27,140 --> 00:52:28,100
让它可以再次运行，

852
00:52:28,100 --> 00:52:30,440
一旦调度器做了决定。

853
00:52:33,290 --> 00:52:37,670
然后，另一件事情是，

854
00:52:44,090 --> 00:52:46,610
yield 调用了这个调度器函数。

855
00:52:48,580 --> 00:52:50,380
所以，我要单步执行调度器函数。

856
00:52:51,210 --> 00:52:53,190
我会在这里展示整个过程。

857
00:53:01,470 --> 00:53:04,590
这个调度器几乎什么都不做，

858
00:53:04,590 --> 00:53:05,790
它做了一些检查，

859
00:53:05,880 --> 00:53:09,360
它做了一些可用性检查和 panic ，

860
00:53:09,360 --> 00:53:11,220
这个原因是，

861
00:53:13,550 --> 00:53:15,710
xv6 中的这段代码，

862
00:53:15,710 --> 00:53:20,840
在多年的时间中，一直是最容易出错的，

863
00:53:20,960 --> 00:53:24,830
有最多的意外，不愉快的意外，

864
00:53:24,830 --> 00:53:28,650
所以这里有很多可用性检查和 panic ，

865
00:53:28,650 --> 00:53:33,250
因为经常会有与这些代码相关的 bug 。

866
00:53:35,650 --> 00:53:40,540
好的，我会跳过这些可用性检查，

867
00:53:40,540 --> 00:53:47,720
然后继续到调用 swtch ，

868
00:53:47,720 --> 00:53:49,670
这个调用 swtch 是真正的操作发生的地方，

869
00:53:49,670 --> 00:53:50,420
这个调用 swtch ，

870
00:53:50,420 --> 00:53:57,330
将保存目前的内核线程寄存器到 p-> context 中，

871
00:53:57,330 --> 00:54:01,950
是当前进程保存内核线程上下文，保存寄存器，

872
00:54:02,640 --> 00:54:08,760
c->context ， c 是指向核心 CPU 结构的指针，

873
00:54:09,090 --> 00:54:16,490
CPU 结构体具有保存这个核心调度器线程的寄存器的上下文，

874
00:54:16,490 --> 00:54:18,140
我们将从这个线程切换，

875
00:54:18,140 --> 00:54:19,550
保存这个线程的状态，

876
00:54:19,640 --> 00:54:24,140
恢复核心调度器的线程状态，

877
00:54:24,140 --> 00:54:29,990
并继续运行这个核心的调度器线程。

878
00:54:32,760 --> 00:54:34,200
好的，让我们看看是，

879
00:54:36,250 --> 00:54:40,990
让我们快速看一下上下文，

880
00:54:40,990 --> 00:54:42,550
我们将切换到的，

881
00:54:43,030 --> 00:54:44,680
我可以得出，

882
00:54:45,860 --> 00:54:47,810
我不能直接打印 c->context ，

883
00:54:47,810 --> 00:54:52,340
但我知道 c 打印 cpus[0] ，

884
00:54:52,430 --> 00:54:54,560
因为我们在核心 0 上，

885
00:54:54,560 --> 00:54:55,550
只有一个核心，

886
00:54:55,820 --> 00:54:57,950
我可以打印它的上下文。

887
00:55:00,960 --> 00:55:08,610
这就是这个核心的调度器线程中保存的寄存器。

888
00:55:10,560 --> 00:55:12,510
特别感兴趣的是 ra ，

889
00:55:12,510 --> 00:55:19,150
因为 ra 寄存器是当前函数调用要返回的地方，当前函数调用将返回到，

890
00:55:19,150 --> 00:55:20,770
所以我们要切换调度器线程，

891
00:55:20,770 --> 00:55:24,070
它会返回，并返回到 ra 。

892
00:55:24,930 --> 00:55:28,330
我们可以找到，

893
00:55:28,330 --> 00:55:32,500
通过查看 kernel.asm ，找到那个返回地址。

894
00:55:35,000 --> 00:55:36,050
实际上，那是。

895
00:55:43,800 --> 00:55:45,930
你可以看到的，这个 x/i ，

896
00:55:45,930 --> 00:55:48,750
打印某个地址的指令，

897
00:55:48,750 --> 00:55:53,460
但它也会打印函数的名称标签，

898
00:55:53,460 --> 00:55:54,600
那些指令在这个函数里面，

899
00:55:54,600 --> 00:55:58,140
所以我们很快会回到调度器上，

900
00:55:58,620 --> 00:56:01,350
这正是你希望的。

901
00:56:05,040 --> 00:56:05,460
好的。

902
00:56:11,120 --> 00:56:13,550
我想看看 swtch 做了什么，

903
00:56:13,550 --> 00:56:14,720
关于调用 swtch 。

904
00:56:18,910 --> 00:56:20,140
所以我在 swtch 上设置一个断点，

905
00:56:20,140 --> 00:56:20,830
设置断点，

906
00:56:20,830 --> 00:56:22,330
因为这里有一堆设置代码，

907
00:56:22,540 --> 00:56:26,710
将上下文的值从这些结构中提取出来，

908
00:56:26,710 --> 00:56:27,580
我会跳过它。

909
00:56:28,820 --> 00:56:30,920
好的，现在，

910
00:56:31,520 --> 00:56:32,870
当到达 swtch 断点时，

911
00:56:33,230 --> 00:56:36,250
GDB 不会给我们看指令，

912
00:56:36,250 --> 00:56:38,140
但是我们可以查看 switch.S ，

913
00:56:38,620 --> 00:56:40,690
来查看即将执行的指令。

914
00:56:41,350 --> 00:56:43,210
正如你看到的，我们在第一条指令，

915
00:56:43,210 --> 00:56:48,340
将 ra 保存到 a0 指向的地址，

916
00:56:48,640 --> 00:56:50,890
你可能还记得在调用 swtch 中，

917
00:56:50,890 --> 00:56:54,430
第一个参数是当前线程的上下文，

918
00:56:54,430 --> 00:56:58,390
第二个参数是我们要切换到的线程的上下文，

919
00:56:58,420 --> 00:57:00,610
两个参数分别到 a0 和 a1 。

920
00:57:01,000 --> 00:57:05,350
所有保存都要通过寄存器 a0 的原因是，

921
00:57:05,350 --> 00:57:09,670
是因为我们在 a0 指向的内存中保存了一堆寄存器，

922
00:57:09,670 --> 00:57:13,000
是我们切换的线程的上下文，

923
00:57:13,300 --> 00:57:15,850
而加载从地址 a1 中加载，

924
00:57:15,850 --> 00:57:19,720
因为这是指向我们要切换到的线程的上下文的指针。

925
00:57:26,740 --> 00:57:34,870
好的，线程， swtch 保存寄存器，加载寄存器，

926
00:57:34,870 --> 00:57:37,000
从目标线程的上下文中，然后返回，

927
00:57:37,510 --> 00:57:39,550
这就是为什么 ra 很有趣，

928
00:57:39,550 --> 00:57:43,180
因为它返回 ra 指向的位置，即进入调度器。

929
00:57:44,290 --> 00:57:47,260
好的，这里有一个问题，你可能会注意到，

930
00:57:47,260 --> 00:57:51,040
虽然 swtch 保存了 ra sp 和很多 s 寄存器，

931
00:57:51,070 --> 00:57:53,860
却没有保存程序计数器，

932
00:57:54,360 --> 00:57:57,150
这里没有提到程序计数器，

933
00:57:57,660 --> 00:57:58,710
那是为什么。

934
00:58:04,650 --> 00:58:10,380
是不是因为程序计数器在函数任何时候调用时都是更新的。

935
00:58:10,980 --> 00:58:15,840
是的，程序计数器里没有实际的信息值，

936
00:58:15,840 --> 00:58:20,320
我们知道正在执行的是 swtch 。

937
00:58:20,350 --> 00:58:22,780
因此没有保存程序计数器，

938
00:58:22,780 --> 00:58:27,040
因为它有一个可预测的值，也就是这条指令，

939
00:58:27,040 --> 00:58:28,900
swtch 指令的地址，

940
00:58:29,890 --> 00:58:33,070
我们真正关心的是我们从哪里被调用，

941
00:58:33,370 --> 00:58:35,410
因为当我们切换回这个线程时，

942
00:58:35,980 --> 00:58:39,580
我们希望继续从调用点执行，

943
00:58:39,730 --> 00:58:40,660
它就是 ra ，

944
00:58:40,660 --> 00:58:44,740
保存着调用 swtch 指令的地址。

945
00:58:45,320 --> 00:58:48,590
所以是 ra 被保存在这里，

946
00:58:48,980 --> 00:58:55,140
而 ra 是再次执行的点。

947
00:58:55,790 --> 00:58:56,480
让 swtch 返回，

948
00:58:56,480 --> 00:58:58,040
我们甚至可以打印，

949
00:58:58,930 --> 00:59:01,120
ra ，糟糕。

950
00:59:03,740 --> 00:59:04,550
我们可以打印 ra ，

951
00:59:04,550 --> 00:59:06,680
我们还没有切换线程，

952
00:59:06,770 --> 00:59:09,260
还记得我们是从这个 sched 函数过来的，

953
00:59:09,710 --> 00:59:13,640
所以，如你所想的， ra 指向 sched 函数。

954
00:59:14,960 --> 00:59:15,620
另一个问题是，

955
00:59:15,620 --> 00:59:18,800
为什么 swtch 只保存了 14 个寄存器，

956
00:59:18,800 --> 00:59:19,520
我数了一下，

957
00:59:19,550 --> 00:59:22,040
它只保存和恢复 14 个寄存器，

958
00:59:22,730 --> 00:59:25,520
尽管 RISC-V 有 32 个寄存器，

959
00:59:25,520 --> 00:59:29,300
可用于，代码可以使用。

960
00:59:29,820 --> 00:59:33,390
为什么只保存了一半的寄存器？

961
00:59:33,780 --> 00:59:36,960
当调用 swtch 时，它是作为正常函数调用的，

962
00:59:36,960 --> 00:59:40,560
所以，任何调用 swtch 都会假设 swtch 可能会修改这些，

963
00:59:40,560 --> 00:59:44,490
以便那个函数将其保存在它的堆栈中，

964
00:59:44,520 --> 00:59:49,020
这意味着当我们从一个跳到另一个的时候，

965
00:59:49,020 --> 00:59:54,030
它会自动恢复调用者保存寄存器。

966
00:59:54,090 --> 00:59:55,350
完全正确，

967
00:59:55,350 --> 00:59:58,110
这个 swtch 是由 C 代码调用的，

968
00:59:58,170 --> 01:00:04,050
我们知道 C 编译器保存在当前堆栈上，

969
01:00:04,140 --> 01:00:06,960
任何调用者保存寄存器，

970
01:00:06,960 --> 01:00:10,020
包含编译器之后需要的值。

971
01:00:10,590 --> 01:00:14,730
而那些调用者保存寄存器包括，

972
01:00:15,030 --> 01:00:18,680
我想有 18 个，

973
01:00:19,010 --> 01:00:20,240
取决于你如何计算它们，

974
01:00:20,240 --> 01:00:24,020
有 15 到 18 个调用者保存寄存器，

975
01:00:24,980 --> 01:00:29,750
所以，我们在这里看到的寄存器是所有不是调用者保存的寄存器，

976
01:00:29,750 --> 01:00:32,150
编译器没有保证保存，

977
01:00:32,180 --> 01:00:37,640
但是仍然可以保存调用函数所需的值，

978
01:00:37,670 --> 01:00:42,530
所以当我们切换线程时，只需要保存被调用者保存的寄存器。

979
01:00:45,830 --> 01:00:47,150
好的。

980
01:00:48,340 --> 01:00:50,830
我想打印的最后一个东西是，

981
01:00:50,890 --> 01:00:52,960
我们保存和恢复了堆栈指针，

982
01:00:53,080 --> 01:00:55,690
当前堆栈指针，很难从这个值判断，

983
01:00:55,690 --> 01:00:59,350
这意味着，它是当前进程的内核堆栈，

984
01:00:59,350 --> 01:01:01,660
我不知道你是否记得，

985
01:01:01,660 --> 01:01:05,380
但是是由虚拟内存系统在高内存映射的。

986
01:01:07,340 --> 01:01:15,200
好的，我们要保存当前的寄存器，

987
01:01:15,200 --> 01:01:20,240
从调度器线程的上下文中恢复寄存器，

988
01:01:20,240 --> 01:01:23,660
我不想执行每一个加载或保存，

989
01:01:23,660 --> 01:01:25,190
所以我要跳过，

990
01:01:25,580 --> 01:01:29,360
所有这 14 个保存和 14 个加载，

991
01:01:29,360 --> 01:01:32,900
直接到返回指令。

992
01:01:32,900 --> 01:01:35,900
好的，所以我们执行了 swtch 中的所有代码，除了返回，

993
01:01:36,170 --> 01:01:38,690
在我们返回之前，

994
01:01:38,690 --> 01:01:41,000
我们再次打印感兴趣的寄存器，

995
01:01:41,000 --> 01:01:41,750
看看我们在哪里。

996
01:01:41,780 --> 01:01:46,610
所以堆栈指针，现在它有一个不同的值，

997
01:01:46,820 --> 01:01:51,170
堆栈指针现在指向内存中的堆栈零区域，

998
01:01:51,170 --> 01:01:55,580
这是在引导序列中非常早的位置，

999
01:01:55,640 --> 01:01:58,610
在 start.S 中放置堆栈，

1000
01:01:58,610 --> 01:02:01,310
以便它可以调用第一个 C 函数，

1001
01:02:01,610 --> 01:02:04,520
所以回到这个 CPU 的初始引导堆栈，

1002
01:02:04,520 --> 01:02:07,820
它恰好就是调度器运行的地方。

1003
01:02:10,500 --> 01:02:14,460
好的，我们对程序计数器也很感兴趣，

1004
01:02:14,460 --> 01:02:16,260
我们在 swtch 中，因为我们还没有返回，

1005
01:02:16,350 --> 01:02:21,240
并且现在 ra 寄存器指向调度器，

1006
01:02:21,240 --> 01:02:22,290
因为我们已经加载，

1007
01:02:22,620 --> 01:02:27,450
我们已经恢复了之前由调度器线程保存的寄存器集。

1008
01:02:28,990 --> 01:02:31,540
实际上，我们现在在调度器线程中，

1009
01:02:31,540 --> 01:02:32,530
如果我执行 where ，

1010
01:02:32,890 --> 01:02:35,680
返回结果跟上次执行完全不一样了，

1011
01:02:35,680 --> 01:02:38,260
它现在是调用 swtch ，

1012
01:02:38,260 --> 01:02:40,420
但是现在我们调用 swtch ，

1013
01:02:40,420 --> 01:02:43,990
要切换到过去某个时间调度器，

1014
01:02:44,290 --> 01:02:46,750
调度器很久以前就在引导期间运行了，

1015
01:02:46,990 --> 01:02:50,860
是在引导过程中所调用的最后一件事。

1016
01:02:53,310 --> 01:02:58,500
所以，我要执行一条指令，从 swtch 返回到调度器。

1017
01:02:59,890 --> 01:03:01,570
现在我们在这个内核的调度器中，

1018
01:03:02,110 --> 01:03:03,250
看看完整的代码，

1019
01:03:08,320 --> 01:03:10,810
这是调度器代码，

1020
01:03:11,480 --> 01:03:12,710
这个函数叫做 scheduler ，

1021
01:03:12,710 --> 01:03:15,950
现在我们在 CPU 调度器线程中执行，

1022
01:03:16,280 --> 01:03:18,050
我们在，

1023
01:03:18,170 --> 01:03:23,060
我们从之前的调用返回到 swtch ，

1024
01:03:23,060 --> 01:03:24,920
它是调度器在之前创建的，

1025
01:03:25,250 --> 01:03:28,370
当它决定开始运行这一进程时，

1026
01:03:28,370 --> 01:03:32,180
pid 3 ，它是被中断的 spin 进程，

1027
01:03:32,750 --> 01:03:37,070
所以现在这个 swtch 进程 id 是 3 ，

1028
01:03:37,070 --> 01:03:38,510
是 spin 调用的 swtch ，

1029
01:03:38,510 --> 01:03:40,550
但这次返回的不是之前的 swtch ，

1030
01:03:40,550 --> 01:03:41,810
之前的 swtch 还没有返回，

1031
01:03:42,080 --> 01:03:48,310
仍保存在进程 id 3 堆栈和上下文中，

1032
01:03:48,340 --> 01:03:50,770
只是从先前的 swtch 返回。

1033
01:03:53,160 --> 01:03:55,530
好的，在调度器中发生的事情，

1034
01:03:55,740 --> 01:03:59,820
已停止运行这个进程，

1035
01:03:59,820 --> 01:04:04,170
所以你可以忘掉我们所做的各种事情，

1036
01:04:04,950 --> 01:04:06,630
在运行这个进程的过程中，

1037
01:04:06,630 --> 01:04:09,600
我们希望[忽略] c->proc 等于零，

1038
01:04:09,660 --> 01:04:11,310
意味着我们忘了这个。

1039
01:04:11,970 --> 01:04:14,310
我们不再在这个核心中运行这个进程，

1040
01:04:14,310 --> 01:04:17,670
所以我们不想让任何人对此感到困惑，

1041
01:04:17,700 --> 01:04:23,480
让我把每个核心进程指针设置为零，

1042
01:04:23,900 --> 01:04:25,220
接下来发生的事情是，

1043
01:04:25,340 --> 01:04:30,260
你记得 yield ，获取这个进程的锁，

1044
01:04:30,320 --> 01:04:32,420
因为它不想任何其他核心调度器

1045
01:04:32,420 --> 01:04:34,220
看到这个进程并可能运行它，

1046
01:04:34,760 --> 01:04:37,970
直到这个进程完全进入休眠状态。

1047
01:04:39,290 --> 01:04:41,930
我们现在已经完成了从这个进程的切换，

1048
01:04:42,140 --> 01:04:45,710
这样我们可以释放对刚刚让出的进程的锁，

1049
01:04:46,880 --> 01:04:47,930
这就是 release ，

1050
01:04:48,740 --> 01:04:52,910
在这一点上，我们还在调度器中，

1051
01:04:52,910 --> 01:04:54,170
如果还有另一个核心，

1052
01:04:54,230 --> 01:04:58,730
在这时，其他核心调度器可以找到这个进程，

1053
01:04:58,730 --> 01:05:00,170
因为它是可运行的，并运行它。

1054
01:05:00,700 --> 01:05:01,360
不过，没关系，

1055
01:05:01,360 --> 01:05:04,210
因为我们已经完全保存了它的寄存器，

1056
01:05:04,240 --> 01:05:07,540
不再在那个进程堆栈上执行，

1057
01:05:07,540 --> 01:05:12,050
因为现在在这个核心的调度器堆栈上执行，

1058
01:05:12,290 --> 01:05:15,830
所以，如果其他核心决定运行这个进程，也没什么问题。

1059
01:05:16,840 --> 01:05:18,430
好的，但是这里没有其他核心，

1060
01:05:18,430 --> 01:05:21,040
所以在这个演示中并没有发生。

1061
01:05:26,440 --> 01:05:31,240
实际上，我想花点时间再谈一下 p->lock ，

1062
01:05:31,510 --> 01:05:36,190
p->lock 做了几件事，

1063
01:05:39,120 --> 01:05:42,470
从调度器的角度来看，它做了两件事，

1064
01:05:42,500 --> 01:05:45,290
一个是让出 CPU ，

1065
01:05:45,650 --> 01:05:47,420
涉及多个步骤，

1066
01:05:47,420 --> 01:05:49,370
我们必须设置状态为可运行的，

1067
01:05:49,370 --> 01:05:50,930
将状态从运行中改为可运行，

1068
01:05:51,080 --> 01:05:55,460
我们将寄存器保存在让出进程的上下文中，

1069
01:05:55,550 --> 01:05:58,730
现在我们必须停止使用让出进程的堆栈，

1070
01:05:58,760 --> 01:06:00,620
至少有三个步骤，

1071
01:06:00,620 --> 01:06:07,640
需要时间来做这些步骤让出 CPU ，

1072
01:06:07,910 --> 01:06:10,100
所以锁做的一件事是，

1073
01:06:10,130 --> 01:06:10,910
正如我提到的，

1074
01:06:10,910 --> 01:06:13,940
阻止任何其他核心调度器看到我们的进程，

1075
01:06:13,940 --> 01:06:16,070
直到所有三个步骤完成之前，

1076
01:06:16,070 --> 01:06:19,580
所以锁是把这些步骤变成原子性的，

1077
01:06:19,860 --> 01:06:22,680
从其他核心的角度来看，它们都发生，

1078
01:06:22,800 --> 01:06:24,900
或者它们都不发生。

1079
01:06:26,160 --> 01:06:30,030
当我们开始运行一个进程时，

1080
01:06:30,270 --> 01:06:35,490
p->lock 也具有类似的保护功能，

1081
01:06:36,750 --> 01:06:39,210
我们将进程的状态设置为运行中，

1082
01:06:39,210 --> 01:06:40,800
当我们开始执行进程时，

1083
01:06:40,800 --> 01:06:46,260
我们把它的寄存器从它的进程上下文转移到 RISC-V 寄存器中，

1084
01:06:46,320 --> 01:06:51,910
但是，如果在进程中间发生中断，

1085
01:06:51,910 --> 01:06:54,220
中断会看到进程处于一种奇怪的状态，

1086
01:06:54,220 --> 01:06:56,560
比如状态标记为运行中，

1087
01:06:56,560 --> 01:07:01,960
但是没有完成将寄存器从上下文移动到 RISC-V 寄存器，

1088
01:07:02,170 --> 01:07:03,250
那将是一场灾难，

1089
01:07:03,250 --> 01:07:04,990
如果发生定时器中断，

1090
01:07:04,990 --> 01:07:07,000
因为我们可能会离开这个过程，

1091
01:07:07,210 --> 01:07:09,880
在它恢复寄存器之前。

1092
01:07:11,220 --> 01:07:12,690
从这个进程中离开，

1093
01:07:12,690 --> 01:07:18,690
会保存未初始化的 RISC-V 寄存器到进程的上下文，

1094
01:07:18,780 --> 01:07:20,520
覆盖它的真正的寄存器。

1095
01:07:20,940 --> 01:07:25,620
所以，实际上，我们也希望启动一个进程具有原子性，

1096
01:07:26,430 --> 01:07:28,530
在这种情况下，持有一个锁，

1097
01:07:28,530 --> 01:07:32,070
在切换到进程的过程中持有 p->lock ，

1098
01:07:32,790 --> 01:07:35,220
为了防止其他核心看到这个进程，

1099
01:07:35,220 --> 01:07:41,100
还会在切换到那个线程的[]持续时间内关闭中断，

1100
01:07:41,190 --> 01:07:43,920
防止定时器中断看到，

1101
01:07:43,920 --> 01:07:48,030
只切换到一半的进程。

1102
01:07:51,320 --> 01:07:51,800
好的。

1103
01:07:53,670 --> 01:07:55,470
所以我们在调度器中，

1104
01:07:55,770 --> 01:07:57,870
我们在调度器的循环中执行，

1105
01:07:57,870 --> 01:07:59,850
调度器中的循环，依次查看所有进程，

1106
01:07:59,850 --> 01:08:01,500
以找到一个要运行的进程，

1107
01:08:01,860 --> 01:08:04,590
在这种情况下，我们知道还有另一个进程，

1108
01:08:04,590 --> 01:08:08,870
因为，还有另一个我们 fork 的 spin 进程，

1109
01:08:09,170 --> 01:08:13,070
但是有很多东西要检查，

1110
01:08:13,460 --> 01:08:18,230
我将跳过扫描进程表，

1111
01:08:18,320 --> 01:08:22,390
直接调到到调度器找到下一个进程的点，

1112
01:08:22,390 --> 01:08:28,270
所以我要把断点放在第 474 行，

1113
01:08:28,270 --> 01:08:29,950
在那里它找到了一个要运行的新进程。

1114
01:08:31,920 --> 01:08:36,180
[]在这里，调度器扫描进程表，

1115
01:08:36,180 --> 01:08:37,740
并找到另一个要运行的进程。

1116
01:08:38,840 --> 01:08:41,990
它会调用那个进程运行，

1117
01:08:41,990 --> 01:08:43,670
你可以看第 468 行，

1118
01:08:43,670 --> 01:08:45,800
它获取了那个进程锁，

1119
01:08:45,830 --> 01:08:48,530
所以现在它有权做不同的步骤，

1120
01:08:48,530 --> 01:08:50,510
切换到那个进程，

1121
01:08:50,930 --> 01:08:54,860
在第 473 行，它将进程状态设置为运行中，

1122
01:08:55,440 --> 01:08:56,550
现在是第 474 行，

1123
01:08:56,550 --> 01:09:01,680
我们在 CPU 结构中记录 CPU 正在执行的进程，

1124
01:09:02,730 --> 01:09:06,990
然后调用 swtch 来保存调度器的寄存器，

1125
01:09:06,990 --> 01:09:10,440
并恢复目标处理器的寄存器，

1126
01:09:10,500 --> 01:09:12,030
你可以看到找到了什么进程，

1127
01:09:12,030 --> 01:09:15,060
通过查看新的进程名称，

1128
01:09:15,150 --> 01:09:16,590
当然它是 spin ，

1129
01:09:17,590 --> 01:09:19,330
它的进程 id 现在是 4 ，

1130
01:09:19,540 --> 01:09:21,670
以前是 3 ，现在是 4 。

1131
01:09:23,960 --> 01:09:25,580
我们已经将状态设置为运行中，

1132
01:09:25,580 --> 01:09:31,790
所以状态是运行中。

1133
01:09:32,550 --> 01:09:35,400
我们可以看到这个线程将切换到哪里，

1134
01:09:35,430 --> 01:09:37,770
在调用 swtch 的第 475 行，

1135
01:09:39,020 --> 01:09:42,050
打印上下文保存的寄存器，

1136
01:09:42,470 --> 01:09:44,600
那么 ra 在哪里，

1137
01:09:45,140 --> 01:09:46,280
我们要调用 swtch ，

1138
01:09:46,280 --> 01:09:49,340
但是正如我们知道的， swtch 返回，

1139
01:09:49,520 --> 01:09:52,430
当它返回时，返回到恢复的 ra ，

1140
01:09:52,550 --> 01:09:57,080
所以我们关心的是 ra 指向哪里，

1141
01:09:57,080 --> 01:09:58,820
我们可以通过以下方式找出。

1142
01:10:00,740 --> 01:10:01,310
糟糕。

1143
01:10:02,100 --> 01:10:04,290
使用 x/i ，

1144
01:10:07,440 --> 01:10:10,500
它返回 ra 指向某个点，

1145
01:10:10,530 --> 01:10:11,640
这并不令人惊讶，

1146
01:10:11,640 --> 01:10:18,210
假设另一个 spin 进程由于定时器中断而挂起，

1147
01:10:18,210 --> 01:10:21,930
我们知道调用 sched ，调用 swtch 。

1148
01:10:26,450 --> 01:10:29,750
好了，现在要调用 swtch 了，

1149
01:10:29,750 --> 01:10:31,730
让我再次打开 swtch 代码。

1150
01:10:38,660 --> 01:10:40,790
实际上在 swtch 中仍然，

1151
01:10:41,390 --> 01:10:44,450
仍然在调度器上下文中。

1152
01:10:46,940 --> 01:10:50,240
我要再次执行所有 swtch 的指令，

1153
01:10:50,240 --> 01:10:53,660
这次，从调度器切换到新进程。

1154
01:10:54,400 --> 01:10:57,250
我们跳过 28 个加载和保存。

1155
01:11:00,460 --> 01:11:04,300
说服我们，要回到 sched 了，

1156
01:11:04,300 --> 01:11:07,270
既然我们要返回 sched 而不是 scheduler ，

1157
01:11:07,390 --> 01:11:10,180
我们现在必须在进程的内核线程中，

1158
01:11:10,180 --> 01:11:13,940
而不再是调度器线程，

1159
01:11:13,940 --> 01:11:16,070
事实上，如果我们查看 backtrace ，

1160
01:11:16,190 --> 01:11:18,110
我们有一个 usertrap 调用，

1161
01:11:18,140 --> 01:11:19,790
这一定是定时器中断，

1162
01:11:19,880 --> 01:11:21,860
在过去的某个时候，

1163
01:11:22,310 --> 01:11:24,860
正如我们所看到的，调用 yield 和 sched ，

1164
01:11:24,860 --> 01:11:27,470
但它是定时器中断另一个进程，

1165
01:11:27,860 --> 01:11:30,260
不是在我们最初观察的进程中。

1166
01:11:35,600 --> 01:11:39,320
好的，有什么问题吗，

1167
01:11:39,380 --> 01:11:43,010
我要停止一步步介绍代码了，

1168
01:11:43,580 --> 01:11:47,330
关于我们看过的任何材料，有什么问题吗。

1169
01:11:49,790 --> 01:11:53,540
不好意思，如果它是这样，比如这个[]，

1170
01:11:53,810 --> 01:11:59,300
然后我们会看到 ra 会指向某个地方

1171
01:11:59,720 --> 01:12:02,780
比如睡眠之类的，是吗？

1172
01:12:03,360 --> 01:12:06,240
嗯，是的。

1173
01:12:07,040 --> 01:12:10,470
好的，我们在这里看到的 where ，

1174
01:12:10,470 --> 01:12:13,950
会包含一些系统调用实现函数，

1175
01:12:13,950 --> 01:12:14,880
并且调用 sleep ，

1176
01:12:14,910 --> 01:12:17,890
我想这是，

1177
01:12:18,280 --> 01:12:20,230
简单回答你的问题，是的，

1178
01:12:20,410 --> 01:12:24,850
如果我们停止执行这个进程，

1179
01:12:24,850 --> 01:12:26,650
因为不是定时器中断的原因，

1180
01:12:26,920 --> 01:12:32,680
swtch 将返回到某些系统调用代码，而不是 sched ，

1181
01:12:32,680 --> 01:12:35,320
我认为 sleep 可能调用 sched ，所以。

1182
01:12:37,750 --> 01:12:38,950
backtrace 看起来会不一样，

1183
01:12:38,950 --> 01:12:40,840
我想会包含 sched ，

1184
01:12:41,230 --> 01:12:42,940
我只选择了一种方式，

1185
01:12:43,650 --> 01:12:47,980
因为定时器中断而产生的进程切换。

1186
01:12:49,700 --> 01:12:52,340
但是你也可以切换等待用户 IO ，

1187
01:12:52,370 --> 01:12:55,100
等待其他进程执行比如写入管道的操作。

1188
01:12:58,380 --> 01:13:01,980
好的，有一件事你可能会注意到，

1189
01:13:02,190 --> 01:13:04,410
调度器调用 swtch ，

1190
01:13:04,940 --> 01:13:07,460
这里 swtch 返回的是什么，

1191
01:13:07,730 --> 01:13:11,360
但是我们是从一个不同的调用 swtch 返回，

1192
01:13:11,360 --> 01:13:12,830
而不是调度器创建的，

1193
01:13:12,950 --> 01:13:16,160
我们是从这个进程很久以前调用 swtch 返回的。

1194
01:13:18,110 --> 01:13:21,290
所以，这可能有点令人困惑，

1195
01:13:21,290 --> 01:13:24,660
但是，这就是线程切换[]的工作原理。

1196
01:13:25,730 --> 01:13:27,320
另一个需要注意的事情是，

1197
01:13:27,860 --> 01:13:29,000
我们正在查看的代码，

1198
01:13:29,000 --> 01:13:32,990
这个 swtch 代码，是线程切换的核心。

1199
01:13:33,600 --> 01:13:37,320
你要切换线程所做的就是，

1200
01:13:37,830 --> 01:13:40,470
保存寄存器和恢复寄存器，

1201
01:13:40,560 --> 01:13:42,900
线程有比寄存器多的状态，

1202
01:13:42,900 --> 01:13:45,540
它们在堆里有变量和东西，

1203
01:13:45,540 --> 01:13:47,490
无论什么，

1204
01:13:47,580 --> 01:13:50,580
所有其他状态都在内存中，

1205
01:13:50,760 --> 01:13:52,380
不会受到干扰，

1206
01:13:52,380 --> 01:13:56,750
我们没有做任何事情来干扰这些线程堆栈，

1207
01:13:56,750 --> 01:13:59,240
比如堆里的值，

1208
01:14:00,320 --> 01:14:04,700
所以微处理器的寄存器实际上是唯一一种易失性状态，

1209
01:14:04,730 --> 01:14:07,730
需要保存和恢复才能进行线程切换，

1210
01:14:07,760 --> 01:14:10,280
内存堆栈中的所有内容，

1211
01:14:10,280 --> 01:14:12,800
仍会在内存中原封不动，

1212
01:14:12,890 --> 01:14:15,620
所以，它不需要显式地保存和恢复。

1213
01:14:16,380 --> 01:14:19,830
我们只保存和恢复微处理器 CPU 寄存器，

1214
01:14:19,980 --> 01:14:24,330
因为我们想为新线程重新使用这些寄存器，

1215
01:14:24,330 --> 01:14:26,490
覆盖它们包含的任何值。

1216
01:14:26,850 --> 01:14:31,800
所以，这就是为什么我们必须保存旧线程的寄存器。

1217
01:14:32,970 --> 01:14:35,820
那么，其他处理器的状态呢，

1218
01:14:35,850 --> 01:14:39,870
我不知道我们使用的 RISC-V 处理器有没有其他标志，

1219
01:14:39,870 --> 01:14:44,970
但我知道有些 x86 英特尔芯片有浮点单元状态

1220
01:14:44,970 --> 01:14:46,620
或类似的东西，

1221
01:14:46,620 --> 01:14:48,990
在 RISC-V 中有没有这个？

1222
01:14:50,620 --> 01:14:54,550
你的观点在其他微处理器如 x86 上得到了很好的[理解]，

1223
01:14:54,550 --> 01:14:58,960
切换的细节略有不同，

1224
01:14:58,960 --> 01:15:01,690
因为它们在不同的状态有不同的寄存器，

1225
01:15:02,830 --> 01:15:06,370
所以这是非常依赖于 RISC-V 的代码，

1226
01:15:06,370 --> 01:15:12,050
对于其他处理器，切换程序可能看起来不同，

1227
01:15:12,050 --> 01:15:15,050
比如可能必须保存浮点寄存器，

1228
01:15:15,260 --> 01:15:19,090
RISC-V 使用的是通用寄存器。

1229
01:15:20,220 --> 01:15:22,860
实际上，我不确定它对浮点数有什么作用，

1230
01:15:22,950 --> 01:15:25,020
但是内核不使用浮点，

1231
01:15:25,020 --> 01:15:26,100
所以不用担心它，

1232
01:15:27,300 --> 01:15:29,550
但是，是的，这完全依赖于微处理器。

1233
01:15:31,710 --> 01:15:33,870
一个关于定时器中断的问题。

1234
01:15:34,680 --> 01:15:40,010
所以听起来像是所有调度工作的核心是，

1235
01:15:40,010 --> 01:15:41,390
有一个定时器中断，

1236
01:15:41,750 --> 01:15:45,020
如果它出现故障会发生什么？

1237
01:15:45,260 --> 01:15:47,300
这里会有一个定时器中断。

1238
01:15:49,070 --> 01:15:55,150
所以，我知道，

1239
01:15:55,180 --> 01:16:02,010
好的，用户进程的抢占式调度能起作用的原因是，

1240
01:16:02,010 --> 01:16:07,510
用户进程总是在打开中断的情况下执行，

1241
01:16:07,570 --> 01:16:13,000
xv6 确保在返回用户空间之前启用中断，

1242
01:16:13,000 --> 01:16:16,810
这意味着如果在用户空间中执行，可以发生定时器中断，

1243
01:16:17,200 --> 01:16:19,840
所以用户进程不可能，

1244
01:16:20,170 --> 01:16:22,240
如果在用户空间，定时器中断就会发生，

1245
01:16:22,820 --> 01:16:24,020
当时间到来的时候。

1246
01:16:24,200 --> 01:16:25,520
所以，在内核中有一点微妙之处，

1247
01:16:25,610 --> 01:16:27,320
内核有时会关闭中断，

1248
01:16:27,320 --> 01:16:28,850
比如，当你获取锁的时候，

1249
01:16:28,970 --> 01:16:30,170
中断将被关闭，

1250
01:16:30,170 --> 01:16:31,010
直到你释放它。

1251
01:16:31,370 --> 01:16:31,910
所以。

1252
01:16:34,600 --> 01:16:38,110
所以，如果内核中有一些 bug ，

1253
01:16:39,040 --> 01:16:40,570
如果内核关闭中断，

1254
01:16:40,570 --> 01:16:42,340
没有再打开它们，

1255
01:16:42,760 --> 01:16:45,910
内核中的代码不会放弃 CPU ，

1256
01:16:45,970 --> 01:16:47,290
从来没有调用 sleep ，

1257
01:16:47,290 --> 01:16:49,030
或者因为任何其他原因放弃 CPU ，

1258
01:16:49,510 --> 01:16:53,050
那么会发生计时器中断，

1259
01:16:53,050 --> 01:16:54,310
这意味着，

1260
01:16:55,470 --> 01:17:00,300
这个内核代码，可能永远不会放弃 CPU ，

1261
01:17:00,300 --> 01:17:05,330
但是，据我们所知， xv6 []，

1262
01:17:05,330 --> 01:17:08,150
所以它总是重新打开中断，

1263
01:17:08,150 --> 01:17:12,510
或者，如果在 xv6 中有关闭中断的代码，

1264
01:17:12,600 --> 01:17:14,250
它必须重新打开中断，

1265
01:17:14,280 --> 01:17:18,070
所以定时器中断可以在内核中发生，

1266
01:17:18,070 --> 01:17:20,020
我们可以从这个内核线程切换，

1267
01:17:20,170 --> 01:17:23,350
或者代码返回到用户空间，

1268
01:17:23,380 --> 01:17:25,150
内核代码返回到用户空间，

1269
01:17:25,180 --> 01:17:27,250
我们相信不会出现这种情况，

1270
01:17:27,250 --> 01:17:31,900
内核代码在中断关闭的情况下永远循环。

1271
01:17:33,990 --> 01:17:36,090
我知道了，我的问题更多的是关于，

1272
01:17:36,120 --> 01:17:39,090
所以我假设中断来自某个硬件，

1273
01:17:39,330 --> 01:17:41,490
如果那个硬件出现故障。

1274
01:17:41,520 --> 01:17:41,970
不。

1275
01:17:45,330 --> 01:17:47,790
没关系，那是你的电脑坏了，你应该买一台新的。

1276
01:17:50,560 --> 01:17:50,920
好的。

1277
01:17:51,010 --> 01:17:53,380
我是说，这是一个合理的问题，

1278
01:17:53,410 --> 01:17:56,740
你的计算机里有 100 亿个晶体管，

1279
01:17:56,740 --> 01:18:01,050
的确，有时硬件会有 bug ，

1280
01:18:01,050 --> 01:18:04,290
但这超出了我们的范围。

1281
01:18:05,220 --> 01:18:08,340
我是说，如果你计算 1+1 ，而电脑给出 3，

1282
01:18:08,340 --> 01:18:12,160
那么你遇到深层次的问题，

1283
01:18:12,160 --> 01:18:14,110
xv6 不能帮你解决。

1284
01:18:16,710 --> 01:18:18,900
所以，我们假设计算机是可以工作的。

1285
01:18:20,370 --> 01:18:24,350
唯一一次，软件可以，

1286
01:18:24,470 --> 01:18:28,100
我是说，有时软件会试图弥补硬件错误，

1287
01:18:28,100 --> 01:18:30,740
比如，如果你通过网络发送数据包，

1288
01:18:31,100 --> 01:18:32,720
总是发送校验和，

1289
01:18:33,240 --> 01:18:36,420
如果网络硬件翻转了一个位，

1290
01:18:36,720 --> 01:18:38,220
出现故障翻转了一个位，

1291
01:18:38,220 --> 01:18:39,720
那么你可以纠正这个，

1292
01:18:39,720 --> 01:18:41,340
但是对于计算机里的东西，

1293
01:18:42,100 --> 01:18:43,180
人们往往不会，

1294
01:18:43,360 --> 01:18:43,840
它只是，

1295
01:18:45,740 --> 01:18:50,290
人们不会试图让软件来弥补硬件错误。

1296
01:18:54,170 --> 01:18:55,340
我有个问题，

1297
01:18:55,340 --> 01:18:59,720
为什么在 trampoline. ，在 swtch 中，

1298
01:18:59,780 --> 01:19:02,570
我们用汇编语言编写代码，

1299
01:19:02,570 --> 01:19:03,350
这是因为，

1300
01:19:03,380 --> 01:19:08,450
是不是因为我们要确保这件事的发生，

1301
01:19:08,630 --> 01:19:11,140
所以我们不能用 C 写，

1302
01:19:11,140 --> 01:19:12,880
因为我们需要，

1303
01:19:13,440 --> 01:19:16,500
[感觉]这些事情发生。

1304
01:19:19,530 --> 01:19:21,540
是的，是的。

1305
01:19:22,800 --> 01:19:26,460
是的，我们当然希望这个确切的顺序发生，

1306
01:19:26,460 --> 01:19:33,430
C 很难访问像 ra 或 sp 这样的东西，

1307
01:19:34,120 --> 01:19:36,700
当然，在 C 语言中，也没有办法

1308
01:19:36,700 --> 01:19:42,130
使用 ra 寄存器访问修改堆栈指针，

1309
01:19:42,660 --> 01:19:48,760
这些东西不能在普通的 C 中看到，

1310
01:19:49,270 --> 01:19:51,430
你能在 C 中看到它的唯一方式是，

1311
01:19:51,460 --> 01:19:56,920
在 C 代码中嵌入汇编语言指令，

1312
01:19:57,340 --> 01:20:00,760
所以我们可以把这些汇编指令嵌入到 C 函数中，

1313
01:20:00,760 --> 01:20:02,750
但是，这就等同于一件事了。

1314
01:20:03,510 --> 01:20:07,920
我们是在低于 C 的级别下操作的，

1315
01:20:07,920 --> 01:20:11,080
所以我们不能在这里使用 C 。

1316
01:20:13,950 --> 01:20:14,700
我有个问题，

1317
01:20:14,700 --> 01:20:17,280
关于当线程完成执行，

1318
01:20:17,280 --> 01:20:19,290
假设发生在用户空间，

1319
01:20:19,290 --> 01:20:23,600
当我们调用 exec 系统调用，

1320
01:20:24,230 --> 01:20:27,620
它也结束了进程，

1321
01:20:27,980 --> 01:20:30,110
在内核空间的线程，

1322
01:20:30,200 --> 01:20:36,110
但是如果线程在新的定时器中断发生之前结束，

1323
01:20:36,170 --> 01:20:38,540
它是否还是，

1324
01:20:39,570 --> 01:20:42,720
比如 CPU 还在被那个线程获取，

1325
01:20:42,720 --> 01:20:45,060
或者结束那个线程并开始一个新的，

1326
01:20:45,060 --> 01:20:46,380
在新的定时器中断之前。

1327
01:20:46,560 --> 01:20:47,460
是的,

1328
01:20:49,460 --> 01:20:53,930
线程让出 CPU ，

1329
01:20:54,820 --> 01:20:57,160
exec 让出 CPU ，

1330
01:20:57,190 --> 01:20:58,690
所以实际上有很多点，

1331
01:20:58,690 --> 01:21:01,960
尽管我一直在用定时器中断来讨论，

1332
01:21:01,960 --> 01:21:06,070
事实上，在几乎所有的情况下，

1333
01:21:06,070 --> 01:21:08,200
xv6 在线程之间切换，

1334
01:21:08,200 --> 01:21:09,670
不是由于定时器中断，

1335
01:21:09,760 --> 01:21:13,960
因为有些系统调用在等待某些东西，

1336
01:21:13,960 --> 01:21:17,740
决定需要放弃 CPU ，

1337
01:21:17,770 --> 01:21:20,950
比如， exec 执行各种操作，

1338
01:21:20,950 --> 01:21:23,590
然后调用 yield 并放弃 CPU ，

1339
01:21:23,590 --> 01:21:26,240
它就是这么做的，

1340
01:21:26,240 --> 01:21:28,940
独立去做，与定时器中断无关。

1341
01:21:31,730 --> 01:21:32,300
是的。

1342
01:21:37,740 --> 01:21:40,890
好了，这节课的时间到了，

1343
01:21:40,890 --> 01:21:44,190
我想下周我会继续讨论这个问题，

1344
01:21:44,190 --> 01:21:47,370
但是我现在很乐意回答更多的问题，

1345
01:21:47,550 --> 01:21:48,210
如果人们有问题的话。

1346
01:21:52,150 --> 01:21:54,160
那么，让我们说操作系统，

1347
01:21:54,160 --> 01:21:58,870
实际上，我采用了线程实现，

1348
01:21:58,900 --> 01:22:05,560
比如，你希望在多个 CPU 上运行一个进程的多个线程，

1349
01:22:05,560 --> 01:22:07,480
这必须由操作系统来处理，

1350
01:22:07,480 --> 01:22:09,940
不能在用户空间中处理，是吗？

1351
01:22:10,360 --> 01:22:11,950
这种切换是怎么工作的，

1352
01:22:11,950 --> 01:22:15,130
是每个线程都变成了一个进程，

1353
01:22:15,130 --> 01:22:18,280
比如，在所有现有线程中循环，

1354
01:22:18,400 --> 01:22:22,630
或者，因为每个 CPU 仍然会切换，

1355
01:22:22,630 --> 01:22:24,610
即使一个进程提供八个核心，

1356
01:22:24,610 --> 01:22:28,330
它还会在这些 CPU 之间切换，

1357
01:22:28,330 --> 01:22:30,070
以及其他一些进程，

1358
01:22:30,550 --> 01:22:32,020
而且我们也不想，在同一个 CPU 上的切换一个线程和另一个线程，

1359
01:22:36,130 --> 01:22:37,540
或者我们希望，我不知道。

1360
01:22:38,640 --> 01:22:39,660
等等，我能不能。

1361
01:22:41,300 --> 01:22:43,280
我不确定问题是什么。

1362
01:22:43,880 --> 01:22:44,930
是的，我想，

1363
01:22:44,930 --> 01:22:47,780
你能解释一下这是怎么发生的吗？

1364
01:22:48,380 --> 01:22:49,610
抱歉，什么是怎么发生的。

1365
01:22:50,270 --> 01:22:53,750
假设每个进程有多个线程，

1366
01:22:53,750 --> 01:22:56,540
它们可以在不同的 CPU 上运行，

1367
01:22:56,660 --> 01:22:58,880
我们如何处理这些。

1368
01:22:59,480 --> 01:23:03,650
比如， Linux 支持每个进程多个线程，

1369
01:23:03,650 --> 01:23:09,000
在 Linux 中，是一个很复杂的实现，

1370
01:23:09,000 --> 01:23:11,430
也许最简单的解释是，

1371
01:23:11,910 --> 01:23:18,230
几乎 Linux 中的每个线程都是一个完整的进程，

1372
01:23:19,200 --> 01:23:22,170
给定进程的线程，

1373
01:23:22,380 --> 01:23:25,050
我们称之为特定进程的线程，

1374
01:23:25,080 --> 01:23:29,310
本质上是共享内存的独立进程，

1375
01:23:30,040 --> 01:23:35,530
所以 Linux 在某种程度上将执行线程的概念从地址空间中分离出来，

1376
01:23:35,530 --> 01:23:39,140
你可以把它们独立起来，

1377
01:23:39,140 --> 01:23:41,150
如果在一个进程中有两个线程，

1378
01:23:41,150 --> 01:23:44,360
它基本上是两个进程共享一个地址空间，

1379
01:23:44,690 --> 01:23:45,710
从那时起，

1380
01:23:45,710 --> 01:23:51,320
调度与 xv6 对各个进程所做的没有什么不同。

1381
01:23:51,740 --> 01:23:54,530
我明白了，然后，有没有什么东西，

1382
01:23:54,530 --> 01:23:56,570
比如用户必须指定，

1383
01:23:56,570 --> 01:23:59,510
每个线程要固定到一个 CPU 上，

1384
01:23:59,810 --> 01:24:02,990
或者操作系统如何确保

1385
01:24:02,990 --> 01:24:05,570
同一进程的不同线程不会在同一核心上运行，

1386
01:24:05,570 --> 01:24:07,400
因为这是不是违反了目的，

1387
01:24:07,430 --> 01:24:08,690
或者不是，我猜的，我不知道。

1388
01:24:09,160 --> 01:24:14,050
这个其实跟 xv6 很像，就是，

1389
01:24:15,820 --> 01:24:17,200
这里有四个核心，

1390
01:24:17,200 --> 01:24:21,610
Linux 只会为这四个核心中找到四个东西，

1391
01:24:22,000 --> 01:24:25,810
如果没有太多的事情发生，

1392
01:24:25,810 --> 01:24:28,780
那么可能会是同一进程的四个线程，

1393
01:24:29,370 --> 01:24:32,430
或者如果有一百个用户登录到 Athena 机器，

1394
01:24:32,430 --> 01:24:36,930
也许是每个线程来自多个不同的进程，

1395
01:24:36,930 --> 01:24:40,650
没有一个固定答案，

1396
01:24:40,710 --> 01:24:43,890
或者内核为每个核心找到要做的事情，

1397
01:24:43,890 --> 01:24:45,330
然后那个核心做那件事。

1398
01:24:46,500 --> 01:24:47,580
好的，理解了。

1399
01:24:48,520 --> 01:24:52,120
如果你想仔细测量，

1400
01:24:52,120 --> 01:24:53,980
有一种方法可以将线程固定在核心上，

1401
01:24:53,980 --> 01:24:57,490
但是人们只有在做一些奇怪的事情时才会这么做。

1402
01:25:00,540 --> 01:25:02,910
所以是共享虚拟表。

1403
01:25:03,930 --> 01:25:04,380
你能再说一遍吗？

1404
01:25:04,380 --> 01:25:05,280
虚拟内存。

1405
01:25:05,490 --> 01:25:10,020
所以说哪些线程有相同的页表。

1406
01:25:10,140 --> 01:25:15,510
是的，如果你在 Linux 上，在一个进程中创建两个线程，

1407
01:25:15,510 --> 01:25:16,680
然后你就有了两个线程。

1408
01:25:19,080 --> 01:25:23,760
我不知道它们是否共享完全相同的页表，

1409
01:25:23,760 --> 01:25:26,100
或者它们的页表是相同的，

1410
01:25:26,520 --> 01:25:27,330
两个中的一个。

1411
01:25:28,620 --> 01:25:31,860
有没有原因让它们分开，

1412
01:25:32,220 --> 01:25:34,740
如果你手动映射内存，或者。

1413
01:25:36,540 --> 01:25:41,640
我不知道 Linux 是哪种。

1414
01:25:44,320 --> 01:25:47,860
好的，我还有一个关于一个小细节的问题，

1415
01:25:48,130 --> 01:25:52,030
根据我的理解，当你调用 swtch 时，

1416
01:25:52,450 --> 01:25:56,050
从一个调用切换到另一个，

1417
01:25:56,080 --> 01:25:57,640
所以当你第一次调用 swtch 时，

1418
01:25:57,670 --> 01:26:03,310
必须人为地创建返回的端点，是吧。

1419
01:26:03,430 --> 01:26:04,060
是的。

1420
01:26:04,510 --> 01:26:07,030
因为你不能随便跳到任何代码。

1421
01:26:07,300 --> 01:26:13,360
是的，你想知道那个伪造在哪里，

1422
01:26:14,930 --> 01:26:16,790
那个上下文是在哪里创造的。

1423
01:26:17,750 --> 01:26:21,290
我猜可能是在进程创建的地方，

1424
01:26:21,290 --> 01:26:21,560
我不知道。

1425
01:26:21,560 --> 01:26:24,170
是的，可能是 userinit ，

1426
01:26:24,820 --> 01:26:27,760
没有使用 allocproc 。

1427
01:26:31,030 --> 01:26:32,560
我也不知道。

1428
01:26:32,920 --> 01:26:35,680
有一个叫做 fork trap 的东西。

1429
01:26:35,680 --> 01:26:39,250
是的，看这个，有 forkret ，

1430
01:26:39,250 --> 01:26:40,630
好的，所以 allocproc ，

1431
01:26:40,630 --> 01:26:45,790
在引导时的第一个进程或 fork 时调用，

1432
01:26:46,000 --> 01:26:52,720
allocproc 为新进程设置上下文的关键元素，

1433
01:26:53,770 --> 01:26:56,320
它设置了新进程的上下文，

1434
01:26:56,380 --> 01:26:59,230
大多数寄存器是什么并不重要，

1435
01:26:59,260 --> 01:27:00,820
但重要的是 ra 是什么，

1436
01:27:00,820 --> 01:27:03,550
因为第一个 swtch ，

1437
01:27:03,550 --> 01:27:05,710
那个进程会返回到 ra ，

1438
01:27:07,450 --> 01:27:10,120
那个进程需要使用自己的堆栈，

1439
01:27:10,150 --> 01:27:14,100
所以 ra 和 sp 设置，是伪造的，

1440
01:27:14,370 --> 01:27:17,430
所以，第一个 swtch 或进程可以正常工作。

1441
01:27:18,130 --> 01:27:20,410
所以，如果我理解正确的话，

1442
01:27:20,410 --> 01:27:21,670
当这个 swtch 发生时，

1443
01:27:21,670 --> 01:27:27,490
它会开始执行 forkret 内部的第一条指令，

1444
01:27:27,550 --> 01:27:30,460
forkret 调用 swtch ，再返回。

1445
01:27:30,910 --> 01:27:36,370
是的，从 swtch 返回跳到 forkret 的开头。

1446
01:27:37,330 --> 01:27:39,800
好的，有意思，

1447
01:27:40,370 --> 01:27:43,880
我们有没有调用 forkret ，还是总是这样，

1448
01:27:44,060 --> 01:27:45,650
我想总是这样发生的。

1449
01:27:45,860 --> 01:27:48,710
我不认为有什么东西调用了 forkret ，

1450
01:27:48,860 --> 01:27:51,600
因为，

1451
01:27:51,660 --> 01:27:57,300
是的，它只在第一个进程运行时以这种奇怪的方式执行。

1452
01:27:58,510 --> 01:28:04,180
它的工作实际上是释放调度器占用的锁，

1453
01:28:04,330 --> 01:28:05,500
然后返回，

1454
01:28:05,530 --> 01:28:08,890
然后这个 usertrapret ，当然，也是伪造的。

1455
01:28:09,500 --> 01:28:11,610
它是，

1456
01:28:11,610 --> 01:28:14,610
就像是从 trap 返回，

1457
01:28:14,610 --> 01:28:17,340
trapframe 也是伪造的，

1458
01:28:17,760 --> 01:28:23,490
调到用户代码的第一个指令。

1459
01:28:24,760 --> 01:28:26,080
但是 trapframe ，

1460
01:28:26,110 --> 01:28:29,110
它又是一样，不需要初始化任何寄存器，

1461
01:28:29,110 --> 01:28:31,930
因为就像我们要从头开始，

1462
01:28:31,930 --> 01:28:33,970
所以你不需要假设任何事。

1463
01:28:34,330 --> 01:28:36,220
是的，程序计数器我认为是。

1464
01:28:37,400 --> 01:28:37,670
是的。

1465
01:28:37,670 --> 01:28:39,920
它需要初始化为零，

1466
01:28:40,340 --> 01:28:41,510
我不知道还有什么，

1467
01:28:42,320 --> 01:28:43,700
也许就是它。

1468
01:28:46,440 --> 01:28:48,870
它们可能，如果我们调用它们不正确，

1469
01:28:48,990 --> 01:28:50,730
因为如果我们已经进行了调用，

1470
01:28:50,730 --> 01:28:52,590
那么就会设置程序计数器。

1471
01:28:52,770 --> 01:28:54,840
是的，只会在这里发生，

1472
01:28:54,840 --> 01:28:58,290
是因为 fork 复制了程序计数器，

1473
01:28:58,840 --> 01:29:00,160
用户程序计数器，

1474
01:29:00,580 --> 01:29:02,590
所以我们唯一不做 fork 的是，

1475
01:29:02,590 --> 01:29:03,670
对于第一个进程，

1476
01:29:03,670 --> 01:29:05,830
在那里它明显的欺骗性的。

1477
01:29:05,830 --> 01:29:06,490
噢。

1478
01:29:07,310 --> 01:29:08,030
而且堆栈指针。

1479
01:29:08,030 --> 01:29:08,480
哦，是的。

1480
01:29:08,510 --> 01:29:09,560
也需要设置。

1481
01:29:11,130 --> 01:29:14,100
是的，因为它是 EPC 不是 PC ，

1482
01:29:14,100 --> 01:29:17,370
就是那个要被 trampoline 换掉的。

1483
01:29:17,610 --> 01:29:18,330
是的。

1484
01:29:19,660 --> 01:29:20,620
哦，我明白了。

1485
01:29:21,820 --> 01:29:25,540
因为真正的程序计数器会在 trampoline 中，

1486
01:29:26,020 --> 01:29:28,180
但是我们要把它切换，跳到那里。

1487
01:29:29,220 --> 01:29:30,480
是的。

1488
01:29:32,870 --> 01:29:33,950
我能不能问一下，

1489
01:29:33,950 --> 01:29:36,590
你能不能回到 allocproc 。

1490
01:29:42,940 --> 01:29:45,370
我觉得这里，

1491
01:29:45,960 --> 01:29:47,730
哦，不是，抱歉，是 forkret ，

1492
01:29:48,000 --> 01:29:52,920
那里有一些东西我想只发生在第一个进程。

1493
01:29:53,960 --> 01:29:58,970
对于第一个调用，我不太确定发生了什么事。

1494
01:29:59,090 --> 01:29:59,390
我们看看，

1495
01:29:59,390 --> 01:30:03,620
文件系统需要初始化，

1496
01:30:03,620 --> 01:30:07,070
特别是一些内容需要从磁盘上读取，

1497
01:30:07,190 --> 01:30:08,960
为了使文件系统运行，

1498
01:30:09,520 --> 01:30:12,940
比如有一种叫做超级块，

1499
01:30:12,940 --> 01:30:15,280
用来描述文件系统有多大，

1500
01:30:15,280 --> 01:30:17,560
以及文件系统中各种内容的位置，

1501
01:30:17,620 --> 01:30:19,900
还有一个崩溃恢复日志，

1502
01:30:19,900 --> 01:30:22,130
需要重播，

1503
01:30:22,250 --> 01:30:26,000
以便从之前的崩溃中恢复过来，

1504
01:30:26,000 --> 01:30:26,600
如果有的话。

1505
01:30:27,770 --> 01:30:31,040
但是为了在文件系统中执行任何操作，

1506
01:30:31,040 --> 01:30:35,060
你需要等待磁盘操作完成，

1507
01:30:35,060 --> 01:30:36,770
但是 xv6 的工作方式，

1508
01:30:37,010 --> 01:30:41,420
你只能在进程的上下文中执行文件系统代码，

1509
01:30:42,110 --> 01:30:44,930
为了比如等待 IO ，

1510
01:30:45,320 --> 01:30:49,340
所以文件系统的初始化必须推迟，

1511
01:30:49,340 --> 01:30:51,650
直到我们有一个进程在运行。

1512
01:30:53,140 --> 01:30:56,800
这发生在 forkret 的第一个进程中。

1513
01:31:00,350 --> 01:31:01,070
我明白了。

1514
01:31:01,640 --> 01:31:04,550
我猜我们稍后会对此有更多了解。

1515
01:31:05,320 --> 01:31:07,450
是的，不是关于这个烂摊子，

1516
01:31:07,450 --> 01:31:10,390
而是关于文件系统是如何工作的。

1517
01:31:11,050 --> 01:31:13,030
好的，谢谢，

1518
01:31:13,030 --> 01:31:15,100
抱歉占用您时间了。

1519
01:31:16,920 --> 01:31:18,900
谢谢你的回答。

1520
01:31:21,840 --> 01:31:23,910
抱歉，是不是在初始化个进程，

1521
01:31:23,910 --> 01:31:26,400
当这个东西被执行的时候……

