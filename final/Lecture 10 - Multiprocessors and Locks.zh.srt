1
00:00:00,330 --> 00:00:03,360
是的，我们不是很好。

2
00:00:06,650 --> 00:00:08,090
好的，那 Erica 呢，

3
00:00:08,800 --> 00:00:11,590
lazy 实验对你来说怎么样。

4
00:00:12,040 --> 00:00:13,630
我也觉得还可以，

5
00:00:13,630 --> 00:00:16,810
我也是在 copyin 和 copyout 有 bug ，

6
00:00:16,810 --> 00:00:20,110
但我得到了结果，所以，还可以。

7
00:00:20,700 --> 00:00:22,290
我想这是一种棘手的情况，

8
00:00:22,290 --> 00:00:24,420
当你开始编程的时候，可能没有想到。

9
00:00:26,390 --> 00:00:28,490
但是，幸运的是， usertests 会为你找到它。

10
00:00:33,180 --> 00:00:34,950
Caroline 。

11
00:00:37,580 --> 00:00:39,050
实验进行得很顺利，

12
00:00:39,080 --> 00:00:41,060
实际上我还没有做完。

13
00:00:41,960 --> 00:00:44,990
好的，我想要注意 copyin 。

14
00:00:45,110 --> 00:00:46,070
是的。

15
00:00:52,560 --> 00:00:54,090
Kendall Garner 怎么样？

16
00:00:55,920 --> 00:00:58,680
我想在很大程度上，

17
00:00:58,770 --> 00:01:01,440
对我来说不算太糟，

18
00:01:01,440 --> 00:01:04,080
可能试着解决的最奇怪的[]是，

19
00:01:04,080 --> 00:01:07,020
当它低于堆栈的界限。

20
00:01:08,760 --> 00:01:12,080
是的，应该是它到达了守护页。

21
00:01:16,760 --> 00:01:17,360
好的。

22
00:01:18,810 --> 00:01:22,020
好的，差不多该开始了。

23
00:01:22,820 --> 00:01:27,620
欢迎来到 6.S081 的下一节课，

24
00:01:27,740 --> 00:01:29,660
无论你在哪里，不管是什么时区。

25
00:01:31,540 --> 00:01:33,400
所以，今天的课程是关于锁。

26
00:01:33,940 --> 00:01:37,870
你们可能在之前的课上见过锁，

27
00:01:38,050 --> 00:01:42,130
或者至少以这样或那样的方式与它们接触，

28
00:01:42,130 --> 00:01:44,890
这节课是有点概念性的课程，

29
00:01:44,890 --> 00:01:48,310
可能与你之前见过的一些东西有些重叠，

30
00:01:48,310 --> 00:01:52,150
锁将更关注内核和操作系统方面。

31
00:01:52,560 --> 00:01:54,120
这改变了几件事情。

32
00:01:54,750 --> 00:01:56,970
作为开始，

33
00:01:57,000 --> 00:01:59,970
让我们提醒自己，为什么需要锁，

34
00:02:00,060 --> 00:02:03,060
我想我们的出发点是，

35
00:02:03,060 --> 00:02:07,170
应用程序想要使用多个核心。

36
00:02:12,190 --> 00:02:14,230
它们希望使用多核来获得性能。

37
00:02:17,040 --> 00:02:21,990
所以，如果一个应用程序希望在多个核心上运行，

38
00:02:21,990 --> 00:02:26,370
可能核心是应用程序调用系统调用的一部分，

39
00:02:26,580 --> 00:02:28,710
所以内核必须能够处理，

40
00:02:31,320 --> 00:02:32,880
必须处理并发系统调用。

41
00:02:45,440 --> 00:02:50,630
这意味着系统调用在不同的核心上并行运行，

42
00:02:50,900 --> 00:02:59,650
它们可能并行访问共享数据结构。

43
00:03:04,390 --> 00:03:05,830
就像你们已经在 alloc 看到过的，

44
00:03:05,830 --> 00:03:09,490
实际上 xv6 有相当多的共享数据结构，

45
00:03:09,580 --> 00:03:13,780
比如 proc 数据结构或 ticks ，

46
00:03:13,780 --> 00:03:17,860
或者稍后我们会看到缓冲区，

47
00:03:17,860 --> 00:03:20,170
实际上有大量的共享数据结构。

48
00:03:20,960 --> 00:03:26,150
所以，如果你并行访问一个数据结构，

49
00:03:26,150 --> 00:03:28,880
其中一个核心是写入者，

50
00:03:28,880 --> 00:03:30,920
其他是读取者，

51
00:03:30,920 --> 00:03:35,090
我们阻塞来协调更新这些共享数据结构，

52
00:03:35,090 --> 00:03:37,430
这样读取者看到一致的。

53
00:03:38,310 --> 00:03:46,840
所以我们需要锁，来控制共享，保证正确共享。

54
00:03:52,010 --> 00:03:55,310
现在，这有点令人沮丧。

55
00:03:55,860 --> 00:03:59,070
因为我们想要并行访问，

56
00:03:59,460 --> 00:04:05,340
我们想在不同的核心上并行运行多个一致的调用，

57
00:04:05,700 --> 00:04:09,450
但不幸的是，如果它们共享数据结构，

58
00:04:09,450 --> 00:04:10,500
它们需要锁，

59
00:04:10,500 --> 00:04:13,620
而锁序列化操作，

60
00:04:13,920 --> 00:04:17,160
所以，实际上，锁最终会限制性能。

61
00:04:27,320 --> 00:04:28,910
所以我们现在的情况有些微妙，

62
00:04:28,910 --> 00:04:31,070
为了正确，我们需要锁，

63
00:04:31,070 --> 00:04:33,590
但对于性能来说，它们不是很好。

64
00:04:34,600 --> 00:04:37,420
但是，这就是实际情况，

65
00:04:37,420 --> 00:04:40,750
我们看看能做些什么。

66
00:04:41,300 --> 00:04:44,480
但这是最高级别的场景，

67
00:04:44,750 --> 00:04:48,620
也许带来了这一点，

68
00:04:48,620 --> 00:04:51,710
为什么应用程序需要多个核心，

69
00:04:51,920 --> 00:04:54,650
这与技术趋势有关，

70
00:04:54,650 --> 00:04:56,480
在过去的几十年里，

71
00:04:56,900 --> 00:04:59,330
有一些经典的图表，

72
00:04:59,330 --> 00:05:00,620
在某种程度上说明了这些观点，

73
00:05:00,830 --> 00:05:02,990
所以，让我调出其中一个，

74
00:05:02,990 --> 00:05:04,730
这是一个有点复杂的图表，

75
00:05:04,730 --> 00:05:09,470
x 轴上是年份，

76
00:05:09,470 --> 00:05:12,170
而 y 轴上是单位，

77
00:05:12,290 --> 00:05:15,500
或者根据我们看哪条线是不同的单位。

78
00:05:16,140 --> 00:05:18,150
但是真正的东西是，

79
00:05:18,630 --> 00:05:22,440
过去几年发生的事情。

80
00:05:22,440 --> 00:05:24,690
过去几十年是，

81
00:05:25,260 --> 00:05:26,940
从 2000 年开始，

82
00:05:26,940 --> 00:05:30,690
时钟频率并没有继续增加。

83
00:05:31,320 --> 00:05:35,920
基本上是停滞不前，持续不变的。

84
00:05:37,000 --> 00:05:42,700
所以，核心的单线程性能，

85
00:05:42,700 --> 00:05:47,980
也基本达到了极限，停滞不前。

86
00:05:52,060 --> 00:05:53,980
然而，另一方面，

87
00:05:53,980 --> 00:05:58,630
核心的最小晶体管数量还在随时间增长，

88
00:05:58,990 --> 00:06:02,980
所以，如果你不能使用晶体管使单个核心运行得更快，

89
00:06:03,250 --> 00:06:06,400
唯一的选择是使用多个内核，

90
00:06:06,400 --> 00:06:10,570
你可以看到从 2001 年或 2000 年开始，

91
00:06:10,570 --> 00:06:11,860
内核的数量越来越多。

92
00:06:13,500 --> 00:06:15,570
所以，应用程序需要更高的性能，

93
00:06:15,900 --> 00:06:18,630
你不能依赖一个核心，

94
00:06:18,630 --> 00:06:20,640
而是要使用多个核心。

95
00:06:21,170 --> 00:06:25,460
而且，这意味着如果应用程序是内核密集型或非内核密集型，

96
00:06:25,460 --> 00:06:28,430
比如一台服务器，

97
00:06:28,490 --> 00:06:33,950
那就意味着操作系统必须在多核上高效运行。

98
00:06:34,740 --> 00:06:35,970
所以这是主要原因，

99
00:06:36,330 --> 00:06:42,600
我们对内核中的并行性非常感兴趣。

100
00:06:45,120 --> 00:06:46,320
对这个有什么问题吗？

101
00:06:52,020 --> 00:06:55,050
好的，我猜你们以前看过其中的一些图表，

102
00:06:55,050 --> 00:06:56,580
但这很好地提醒我们，

103
00:06:56,580 --> 00:06:58,560
所有讨论的出发点是什么。

104
00:07:00,660 --> 00:07:01,500
那么为什么要使用锁，

105
00:07:02,960 --> 00:07:07,400
我们已经提到了，是为了正确性，

106
00:07:07,400 --> 00:07:12,080
如果我们有读取者和写入者访问共享数据结构，

107
00:07:12,440 --> 00:07:14,750
会出现的问题是，

108
00:07:14,750 --> 00:07:16,880
我们想要避免竞态条件。

109
00:07:23,830 --> 00:07:25,000
如果没有锁，

110
00:07:25,150 --> 00:07:26,230
会出现一种风险，

111
00:07:26,260 --> 00:07:27,670
我们有共享的数据结构，

112
00:07:27,670 --> 00:07:33,250
我们会有竞态条件，

113
00:07:33,250 --> 00:07:37,330
竞态条件是相当烦人的，

114
00:07:37,420 --> 00:07:41,620
所以，首先对它的情况有了一点了解，

115
00:07:41,770 --> 00:07:43,180
让我们看一下，

116
00:07:43,210 --> 00:07:46,120
让我们在 xv6 中创造一个竞态条件，

117
00:07:46,120 --> 00:07:47,980
然后看看它是怎么表现出来的，

118
00:07:47,980 --> 00:07:50,020
然后理解实际发生了什么。

119
00:07:51,100 --> 00:07:58,370
好的，这是 kalloc.c 中的函数 kfree 。

120
00:07:58,370 --> 00:08:00,140
这是一个函数，释放，

121
00:08:00,500 --> 00:08:02,750
在你释放页面之后，它会推入到 free 列表，

122
00:08:02,810 --> 00:08:05,420
内核有一个非常简单的数据结构，

123
00:08:05,420 --> 00:08:07,190
使用 freelist 保存所有空闲页表。

124
00:08:07,700 --> 00:08:11,120
所以，当 kalloc 需要页面时，它从 freelist 中获取。

125
00:08:11,620 --> 00:08:17,230
这里你可以看到， allocation 有一个，

126
00:08:19,500 --> 00:08:21,660
内存分配器有一个锁 kmem.lock ，

127
00:08:22,020 --> 00:08:24,780
在这里，它更新了 freelist ，

128
00:08:25,080 --> 00:08:29,310
使用刚刚释放的页面或者需要释放的参数。

129
00:08:29,880 --> 00:08:30,630
所以我们要做的是，

130
00:08:30,630 --> 00:08:33,990
注释掉这两个 acquire 和 release ，

131
00:08:33,990 --> 00:08:38,790
这标志着获得锁，然后释放锁，

132
00:08:38,790 --> 00:08:41,760
所以这段代码，

133
00:08:41,760 --> 00:08:44,010
之前在中间的这段（代码），

134
00:08:44,400 --> 00:08:48,150
不再是原子地执行了。

135
00:08:54,100 --> 00:08:55,840
所以我们就这么做，

136
00:08:56,910 --> 00:09:03,330
然后运行 QEMU ，编译它。

137
00:09:05,300 --> 00:09:07,130
在我运行它之前，

138
00:09:07,160 --> 00:09:09,290
注意到我们已经启动了，

139
00:09:09,380 --> 00:09:14,150
实际上，我们已经有几个 kfree 的调用，

140
00:09:14,450 --> 00:09:15,680
像你知道的，

141
00:09:15,680 --> 00:09:17,510
实际上事情看起来运行得很好。

142
00:09:18,070 --> 00:09:19,630
让我们运行 usertests 。

143
00:09:20,260 --> 00:09:22,870
也许要想想这件事，

144
00:09:22,870 --> 00:09:23,740
你期望的是什么，

145
00:09:23,740 --> 00:09:25,870
这能正常工作，或者不能正常工作。

146
00:09:28,920 --> 00:09:30,120
有人试过吗。

147
00:09:33,070 --> 00:09:36,640
我想它可能会丢失一些页面，

148
00:09:36,640 --> 00:09:38,500
但也可能不会，

149
00:09:38,590 --> 00:09:41,970
因为可能竞态条件不会出现。

150
00:09:42,120 --> 00:09:43,920
是的，其中一件事是，

151
00:09:43,920 --> 00:09:46,170
我们面临的是这些情况可能不会发生，

152
00:09:46,170 --> 00:09:48,330
所以，让我们运行 usertests ，看看实际会发生什么。

153
00:09:51,820 --> 00:09:53,320
我们从这里开始。

154
00:09:54,360 --> 00:09:55,560
这需要一小段时间，

155
00:09:55,560 --> 00:09:56,790
你可能会抱怨，

156
00:09:56,790 --> 00:09:59,310
因为要跑很多，

157
00:10:00,940 --> 00:10:02,590
在我的机器上要加载很多，

158
00:10:02,590 --> 00:10:07,060
这里 QEMU 模拟了三个核心，

159
00:10:07,060 --> 00:10:09,100
并且不同的核心可以并行运行。

160
00:10:11,830 --> 00:10:13,840
到目前为止一切顺利，

161
00:10:14,020 --> 00:10:15,580
我们开始通过测试。

162
00:10:21,470 --> 00:10:22,430
这有点慢，

163
00:10:22,430 --> 00:10:24,200
因为我同时运行了 Zoom 。

164
00:10:26,920 --> 00:10:30,280
让我们稍等一下，看看会发生什么。

165
00:10:43,070 --> 00:10:45,320
好的，好吧。

166
00:10:46,290 --> 00:10:48,420
我们还是回去看幻灯片，

167
00:10:48,420 --> 00:10:50,580
然后我们过一会再回来看看，

168
00:10:50,580 --> 00:10:52,020
看看会发生什么。

169
00:10:52,860 --> 00:10:54,900
但是需要指出，

170
00:10:54,960 --> 00:10:57,330
这些竞态条件可能会出现，也可能不会出现，

171
00:10:57,330 --> 00:10:58,770
因为情况可能总是这样，

172
00:10:58,770 --> 00:11:01,590
每个核心或每次我们调用 kfree ，

173
00:11:02,040 --> 00:11:05,340
这两行（代码）原子地执行，

174
00:11:06,240 --> 00:11:08,820
就像它们使用了锁那样，

175
00:11:08,970 --> 00:11:10,530
那就不会出现问题，

176
00:11:10,530 --> 00:11:11,490
唯一的问题是，

177
00:11:11,490 --> 00:11:14,940
如果两个线程或两个进程同时执行，

178
00:11:15,000 --> 00:11:16,110
然后有（代码）在中间执行。

179
00:11:17,140 --> 00:11:19,420
看看这个，在我说话的时候，

180
00:11:19,420 --> 00:11:21,010
我们看到这里有一个 panic ，

181
00:11:21,040 --> 00:11:23,920
所以，有一些竞态条件引起了 panic 。

182
00:11:24,940 --> 00:11:27,970
更确切地说，竞态条件会出现，

183
00:11:27,970 --> 00:11:31,480
正如所提到的那样，

184
00:11:31,480 --> 00:11:33,910
这是不够的，

185
00:11:34,030 --> 00:11:36,070
一些空闲页面丢失了，

186
00:11:36,100 --> 00:11:38,650
基本上 usertest 运行得很好直到最后，

187
00:11:38,770 --> 00:11:42,100
抱怨丢失了一些页面，

188
00:11:42,100 --> 00:11:44,890
在整个 usertests 中。

189
00:11:45,600 --> 00:11:46,140
好的。

190
00:11:46,440 --> 00:11:48,870
所以，这些竞态条件可以以不同的方式表现出来，

191
00:11:48,930 --> 00:11:50,460
它们可能会发生，也可能不会发生。

192
00:11:51,120 --> 00:11:53,520
很明显这里发生了，

193
00:11:53,760 --> 00:11:57,750
让我们试着了解到底哪里出了问题。

194
00:12:00,420 --> 00:12:02,370
回到幻灯片上。

195
00:12:06,400 --> 00:12:09,040
所以，你知道这个应该在脑海中的图片，

196
00:12:09,040 --> 00:12:12,250
比如有多个核心在运行。

197
00:12:13,070 --> 00:12:16,880
所以， CPU0 正在执行指令，

198
00:12:17,470 --> 00:12:19,600
并且 CPU1 也在执行指令。

199
00:12:21,210 --> 00:12:24,750
它们都连接到一块内存上，

200
00:12:24,960 --> 00:12:27,720
如果你回想一下方案示意图，

201
00:12:27,720 --> 00:12:29,250
我们之前展示过几次，

202
00:12:29,550 --> 00:12:31,770
实际上这里有一个 DRAM 控制器，

203
00:12:31,770 --> 00:12:36,150
它连接到 DRAM 芯片，

204
00:12:36,450 --> 00:12:38,100
所有的阶段都在这里，

205
00:12:38,800 --> 00:12:40,420
或者所有的内存都在这里。

206
00:12:41,370 --> 00:12:43,050
我把内存画得大一点，

207
00:12:43,050 --> 00:12:47,230
好让我有地方可以画，

208
00:12:47,260 --> 00:12:53,820
所以我们的 freelist 在内存中，

209
00:12:54,180 --> 00:12:56,670
我们假设 freelist 上面有两页。

210
00:12:59,060 --> 00:13:07,670
并且两个 CPU 会几乎同时调用 kfree 。

211
00:13:13,460 --> 00:13:15,440
好的，再看一下代码，

212
00:13:15,440 --> 00:13:18,110
确保运行的跟我们想的一样，

213
00:13:18,110 --> 00:13:19,400
所以我们看看 kfree ，

214
00:13:19,790 --> 00:13:24,080
它传递了 pa ，物理地址，

215
00:13:24,350 --> 00:13:28,130
我们要把它放到 freelist 上。

216
00:13:29,000 --> 00:13:35,750
CPU0 有一个 R ，

217
00:13:36,770 --> 00:13:41,000
它指向了一些空闲页面，

218
00:13:41,540 --> 00:13:46,490
可能 CPU1 也有一个，

219
00:13:47,080 --> 00:13:49,090
对 CPU1 ，我们使用另一种颜色。

220
00:13:49,660 --> 00:13:53,590
所以 CPU 另一个 R 总是指向一些页面，

221
00:13:53,590 --> 00:13:55,540
我们想放入 freelist 。

222
00:13:56,450 --> 00:13:57,050
能理解吗?

223
00:13:59,050 --> 00:14:01,210
所以，我们回顾代码，

224
00:14:01,240 --> 00:14:04,180
所做的第一件事就是，

225
00:14:04,180 --> 00:14:08,500
更新 r->next 指针指向 freelist 。

226
00:14:09,210 --> 00:14:13,830
我们假设 CPU1 首先运行，

227
00:14:14,250 --> 00:14:16,500
它所做的是，

228
00:14:16,500 --> 00:14:20,890
将指针指向开始，

229
00:14:22,000 --> 00:14:24,400
指向 freelist 指向的地方。

230
00:14:25,090 --> 00:14:28,660
CPU1 也在同时运行，

231
00:14:28,990 --> 00:14:37,270
然后，它可以在 CPU0 执行第二条指令之前运行，

232
00:14:37,570 --> 00:14:39,040
所以它可能做同样的事情，

233
00:14:39,040 --> 00:14:41,260
它可能也运行第一条指令，

234
00:14:41,560 --> 00:14:54,420
并且将指针更新为二。

235
00:14:54,420 --> 00:14:58,980
所以，两个 R ，一个来自 CPU1 ，一个来自 CPU0 ，

236
00:14:58,980 --> 00:15:00,390
都指向 freelist 的开头，

237
00:15:00,390 --> 00:15:03,330
而 freelist 也指向 freelist 的开头。

238
00:15:03,930 --> 00:15:07,020
所以，现在有两条指令在并行执行。

239
00:15:07,730 --> 00:15:09,890
所以，我们再回到代码，

240
00:15:10,280 --> 00:15:12,500
剩下的指令正在执行，

241
00:15:12,500 --> 00:15:14,630
更新 freelist 指向 r 。

242
00:15:17,040 --> 00:15:21,450
所以， CPU 0 1 要执行这些指令

243
00:15:21,450 --> 00:15:24,780
可能是完全一样的时间，

244
00:15:24,810 --> 00:15:26,070
但是有一个会先执行，

245
00:15:26,070 --> 00:15:27,870
这里只有一个共享内存，

246
00:15:28,260 --> 00:15:30,210
所以一个更新先执行，

247
00:15:30,270 --> 00:15:31,710
另一个更新第二。

248
00:15:32,290 --> 00:15:34,630
我们假设 CPU1 先运行。

249
00:15:35,240 --> 00:15:36,620
现在接下来会发生什么，

250
00:15:36,620 --> 00:15:38,090
好的，首先执行的 CPU ，

251
00:15:38,090 --> 00:15:40,750
freelist 会指向它的 R 。

252
00:15:42,200 --> 00:15:44,210
然后 CPU2 运行，

253
00:15:44,240 --> 00:15:46,910
所以现在 CPU2 运行指令，

254
00:15:47,210 --> 00:15:48,740
那么接下来要做是什么，

255
00:15:48,770 --> 00:15:52,610
它会更新 freelist 指向。

256
00:15:55,340 --> 00:15:56,750
这是 freelist ，

257
00:15:58,000 --> 00:16:02,580
它会指向传入的 R 。

258
00:16:03,230 --> 00:16:05,300
所以我们现在是一种情况，

259
00:16:05,300 --> 00:16:08,480
我们丢失了一页，

260
00:16:10,880 --> 00:16:13,970
实际上 CPU0 释放的的 R，

261
00:16:14,150 --> 00:16:16,580
最终不在 freelist 上，

262
00:16:16,970 --> 00:16:18,320
所以我们丢了那一页。

263
00:16:22,680 --> 00:16:25,800
一个坏结果出现，

264
00:16:25,800 --> 00:16:27,600
当然，可能会有更多的坏结果，

265
00:16:27,600 --> 00:16:30,690
因为可能有更多的 CPU 尝试执行这个 freelist ，

266
00:16:31,020 --> 00:16:32,370
它们可能会观察到，

267
00:16:32,370 --> 00:16:33,720
其中之一可能会观察到，

268
00:16:33,720 --> 00:16:37,800
freelist 临时指向 CPU0 的 R ，

269
00:16:38,040 --> 00:16:39,840
所以我们开始使用它，

270
00:16:40,110 --> 00:16:44,670
然后由第二个 CPU 更新 freelist ，

271
00:16:44,700 --> 00:16:46,530
所以如果引入更多 CPU ，

272
00:16:46,530 --> 00:16:48,780
我们可能会得到更离奇的结果，

273
00:16:48,780 --> 00:16:50,340
而不仅是丢失页面。

274
00:16:52,310 --> 00:16:53,120
这能理解吗？

275
00:16:55,750 --> 00:16:56,800
有什么问题吗？

276
00:17:04,820 --> 00:17:06,170
好的。

277
00:17:07,220 --> 00:17:10,100
所以，代码使用的方法，

278
00:17:10,100 --> 00:17:11,540
用来解决这个问题的方法，

279
00:17:11,540 --> 00:17:15,140
是一种很常用的方法，

280
00:17:15,440 --> 00:17:19,190
解决这个问题就是使用锁。

281
00:17:19,970 --> 00:17:23,210
所以，让我详细讨论一下锁的问题。

282
00:17:26,860 --> 00:17:30,130
那么什么是锁抽象。

283
00:17:32,480 --> 00:17:34,640
现在它只是一个对象，

284
00:17:34,640 --> 00:17:37,520
与内核中的任何其他类型的对象一样，

285
00:17:37,730 --> 00:17:39,050
任何包含。

286
00:17:39,740 --> 00:17:41,450
实际上，有一个称为锁结构体的东西，

287
00:17:41,960 --> 00:17:45,680
它包含一些字段，维护锁的状态，

288
00:17:46,010 --> 00:17:49,460
它有一个相当简单的 API ，

289
00:17:49,460 --> 00:17:51,760
有一个 acquire ，

290
00:17:51,760 --> 00:17:55,030
实际上，只有两个对此抽象的调用，

291
00:17:55,450 --> 00:18:03,490
acquire 使用一个锁结构体的指针，

292
00:18:03,790 --> 00:18:11,450
release 也使用一个锁结构体的指针，

293
00:18:11,810 --> 00:18:14,000
来更新锁对象。

294
00:18:14,900 --> 00:18:18,890
这里的规则是，

295
00:18:20,020 --> 00:18:25,420
acquire 遵守以下规则，

296
00:18:25,420 --> 00:18:33,160
只有一个进程可以进入或者获得锁。

297
00:18:37,950 --> 00:18:39,570
所以，在任何特定时间点，

298
00:18:40,140 --> 00:18:41,730
只有一个进程

299
00:18:41,730 --> 00:18:44,400
可以成功获取到锁，

300
00:18:44,730 --> 00:18:48,150
任何在同一时间获取锁的进程，

301
00:18:48,180 --> 00:18:51,000
必须等到第一个进程调用 release 。

302
00:18:52,560 --> 00:18:54,360
所以，这个序列，

303
00:18:54,480 --> 00:18:58,920
这些在 acquire release 之间的指令，

304
00:18:59,160 --> 00:19:01,020
经常称为临界区间。

305
00:19:07,720 --> 00:19:09,550
被称为临界区间的一个原因是

306
00:19:09,550 --> 00:19:13,570
因为这些指令一起执行，

307
00:19:13,600 --> 00:19:16,450
需要对 r 进行更新，

308
00:19:16,450 --> 00:19:18,850
由锁保护的任何共享数据结构，

309
00:19:19,090 --> 00:19:20,170
使用原子地方式。

310
00:19:21,090 --> 00:19:22,920
并且确保，

311
00:19:23,460 --> 00:19:27,870
如果你在 acquire release 之间有多条指令，

312
00:19:27,870 --> 00:19:32,550
但它们要么一起执行，要么一个都不执行。

313
00:19:33,800 --> 00:19:35,030
所以，不会出现这种情况，

314
00:19:35,030 --> 00:19:38,270
临界区的这些指令交错执行，

315
00:19:38,480 --> 00:19:40,430
像我们在竞态条件下看到的那样，

316
00:19:40,910 --> 00:19:43,850
实际上，这用来避免竞态条件。

317
00:19:48,190 --> 00:19:50,020
关于锁抽象，有什么问题吗？

318
00:19:55,220 --> 00:20:01,170
程序通常有很多锁，

319
00:20:01,260 --> 00:20:03,750
实际上 xv6 就有很多锁。

320
00:20:08,140 --> 00:20:09,940
有很多锁的原因是，

321
00:20:09,940 --> 00:20:11,020
因为即使，

322
00:20:11,020 --> 00:20:14,860
锁可以序列化进程的执行，

323
00:20:15,040 --> 00:20:18,460
两个进入临界区间的进程，

324
00:20:18,460 --> 00:20:19,330
只有一个可以成功，

325
00:20:19,330 --> 00:20:25,360
另一个在第一个完成后运行临界区间，

326
00:20:25,540 --> 00:20:27,640
所以这里没有并行。

327
00:20:28,500 --> 00:20:31,080
如果内核只有一个锁，

328
00:20:31,110 --> 00:20:33,390
通常称为大内核锁，

329
00:20:33,540 --> 00:20:38,430
那么内核中每个系统调用都会被串行化，

330
00:20:39,240 --> 00:20:43,020
系统调用 1 获取大内核锁，

331
00:20:43,020 --> 00:20:44,310
做它想做的事情，

332
00:20:44,310 --> 00:20:45,870
然后释放大内核锁，

333
00:20:45,870 --> 00:20:47,490
然后返回用户空间。

334
00:20:48,220 --> 00:20:49,990
然后第二个系统调用运行，

335
00:20:50,380 --> 00:20:51,970
所以我们有并行运行的程序，

336
00:20:51,970 --> 00:20:54,280
并行运行大量的系统调用，

337
00:20:54,310 --> 00:20:57,730
突然所有的系统调用都是串行运行的，

338
00:20:57,730 --> 00:20:58,960
如果我们只有一把锁的话。

339
00:20:59,880 --> 00:21:04,170
所以通常程序，比如 xv6 有很多锁，

340
00:21:04,170 --> 00:21:06,360
因为这样，我们可以得到一些并行性。

341
00:21:09,670 --> 00:21:17,940
因为，如果两个系统调用使用两个不同的锁，

342
00:21:17,970 --> 00:21:21,060
那么它们实际上可以完全并行运行，

343
00:21:21,270 --> 00:21:24,300
没有任何串行化，

344
00:21:24,690 --> 00:21:27,990
因为使用不同的锁进行串行化。

345
00:21:31,070 --> 00:21:32,570
现在。

346
00:21:34,040 --> 00:21:36,050
有几点很重要，

347
00:21:36,380 --> 00:21:41,270
在这个接口中没有什么是强制的，

348
00:21:41,270 --> 00:21:43,790
你使用 acquire release ，

349
00:21:43,790 --> 00:21:45,410
这是由程序决定的。

350
00:21:46,010 --> 00:21:50,180
所以，如果你希望代码段是原子的，

351
00:21:50,540 --> 00:21:54,560
由开发人员将 acquire release 那里。

352
00:21:55,230 --> 00:21:57,480
从这里可以清楚地看到，

353
00:21:57,480 --> 00:22:02,220
你可以想象，这需要一些技巧性，

354
00:22:02,430 --> 00:22:03,630
所以需要认识到，

355
00:22:03,630 --> 00:22:06,630
锁并不是自动完成的，

356
00:22:06,870 --> 00:22:09,900
一切都由开发者决定的，

357
00:22:09,900 --> 00:22:13,800
将锁与数据结构关联，

358
00:22:14,100 --> 00:22:19,020
并确保适当的 acquire release 在那里。

359
00:22:23,050 --> 00:22:29,920
所以，很明显地情况，锁限制了并行性，

360
00:22:29,920 --> 00:22:31,510
并且因此限制了性能，

361
00:22:31,810 --> 00:22:35,080
所以，这就提出了何时使用锁的问题。

362
00:22:42,710 --> 00:22:46,430
我要给你们一种保守的规则，

363
00:22:46,640 --> 00:22:50,150
但这是考虑这件事的一个很好的起点。

364
00:22:50,680 --> 00:22:58,910
所以这个保守的规则，或者叫做指导原则更好，

365
00:23:00,090 --> 00:23:03,030
[]是你有两个进程，

366
00:23:05,740 --> 00:23:10,510
两个进程访问一个共享数据结构。

367
00:23:17,130 --> 00:23:22,100
其中一个是写入者或更新者，

368
00:23:22,100 --> 00:23:25,880
这意味着它对共享数据结构做修改。

369
00:23:27,050 --> 00:23:29,750
那么你需要对这个数据结构使用锁。

370
00:23:40,620 --> 00:23:41,820
所以这是一条保守的规则，

371
00:23:41,970 --> 00:23:43,410
像是告警的红旗，

372
00:23:43,470 --> 00:23:49,350
当你编程时，并且有一个由多个进程访问的数据结构，

373
00:23:49,350 --> 00:23:50,460
那么什么是写入者，

374
00:23:50,520 --> 00:23:51,960
在这时候，你应该想，

375
00:23:51,960 --> 00:23:53,910
好的，这里可能有竞态条件，

376
00:23:54,090 --> 00:23:56,040
你希望避免这种竞态条件，

377
00:23:56,280 --> 00:23:57,600
你使用锁，

378
00:23:57,630 --> 00:24:01,650
使用锁来保证这个竞态条件不会发生。

379
00:24:02,450 --> 00:24:06,470
但是，这些规则在某些方面太严格了。

380
00:24:10,890 --> 00:24:15,600
在某些情况下，可以处理共享数据结构的这些操作，

381
00:24:15,600 --> 00:24:16,470
其中一个是写入者，

382
00:24:16,530 --> 00:24:21,630
特别地是，有一种编程风格称为无锁编程。

383
00:24:22,610 --> 00:24:27,230
这是各种会发生的情况。

384
00:24:32,310 --> 00:24:33,810
无论如何，你想使用无锁编程，

385
00:24:33,810 --> 00:24:36,420
是为了获得更好的性能或更多的并行性。

386
00:24:38,730 --> 00:24:40,260
无锁编程是很难的，

387
00:24:40,350 --> 00:24:42,930
甚至比使用锁编程更难，

388
00:24:43,290 --> 00:24:45,840
我们会在本学期末讨论这个问题，

389
00:24:45,840 --> 00:24:49,890
我们会研究一些无锁编程风格，

390
00:24:49,890 --> 00:24:53,970
特别是在操作系统内核中常见的。

391
00:24:54,440 --> 00:24:58,220
基本上，对于这节课以及本学期的剩下的大部分课，

392
00:24:58,310 --> 00:25:00,110
我们会考虑这种情况，

393
00:25:00,110 --> 00:25:05,480
我们使用锁来控制共享。

394
00:25:06,280 --> 00:25:07,900
这已经很难了，

395
00:25:07,930 --> 00:25:10,810
只用锁，也不是那么简单的。

396
00:25:12,520 --> 00:25:15,490
所以一方面，有点太严格了，

397
00:25:15,760 --> 00:25:18,280
因为并不总是所有情况都需要，

398
00:25:18,280 --> 00:25:19,900
也有一些情况太宽松了。

399
00:25:21,340 --> 00:25:22,210
如果你可能只是。

400
00:25:26,200 --> 00:25:27,460
你可能[]宽松，

401
00:25:27,460 --> 00:25:29,110
你想使用锁，

402
00:25:29,110 --> 00:25:31,630
来保证一些其他属性，

403
00:25:31,630 --> 00:25:32,740
比如你看一下 printf ，

404
00:25:35,750 --> 00:25:37,670
如果我们将一个字符串传递给 printf ，

405
00:25:38,280 --> 00:25:40,440
xv6 内核试图，

406
00:25:40,440 --> 00:25:44,220
至少让整个字符串原子地打印出来。

407
00:25:44,760 --> 00:25:47,640
而且你知道这里不涉及共享数据结构，

408
00:25:47,850 --> 00:25:51,510
但在这种情况下使用锁仍然很有用，

409
00:25:51,510 --> 00:25:53,430
因为我们希望输出是串行化的。

410
00:25:54,220 --> 00:25:56,320
所以这个规则并不完美，

411
00:25:56,320 --> 00:25:57,880
但它是一个不错的指导原则。

412
00:26:00,020 --> 00:26:01,910
关于这条规则，有什么问题吗？

413
00:26:04,810 --> 00:26:06,850
我有一个问题不是关于这个规则的，

414
00:26:06,850 --> 00:26:11,950
但是有没有可能两个进程同时获取锁，

415
00:26:11,950 --> 00:26:15,690
因此可以修改数据结构。

416
00:26:16,460 --> 00:26:20,420
是的，不是，锁的一部分规定是

417
00:26:20,420 --> 00:26:24,410
两个进程不能同时获得锁。

418
00:26:25,290 --> 00:26:31,140
这条规则，永远不会有这种情况，

419
00:26:31,140 --> 00:26:35,640
两个进程可以同时获得锁，

420
00:26:35,940 --> 00:26:37,590
我们过一会会看到如何实现它，

421
00:26:37,590 --> 00:26:40,410
但是 API 或规范要求是，

422
00:26:40,800 --> 00:26:44,580
在任何给定的时间点，只有一个进程或没有持有锁。

423
00:26:45,090 --> 00:26:45,540
好的。

424
00:26:49,300 --> 00:26:53,980
好的，如果我们看一些锁编程，

425
00:26:54,310 --> 00:26:58,090
可能产生一些问题，因为这些竞态条件。

426
00:26:59,950 --> 00:27:05,440
当然，那个在 kfree 中的竞态条件，

427
00:27:05,620 --> 00:27:07,180
或者是我们在 kfree 中创造的，

428
00:27:07,360 --> 00:27:09,280
使用一些方法很容易发现，

429
00:27:09,280 --> 00:27:11,830
实际上，如果使用一个竞态检查工具，

430
00:27:11,890 --> 00:27:13,420
它会立即找到它。

431
00:27:13,820 --> 00:27:16,550
但还有更复杂的情况，

432
00:27:16,850 --> 00:27:20,630
你可能会想，为什么可以这样，

433
00:27:20,660 --> 00:27:24,350
可以使加锁是自动的？

434
00:27:31,120 --> 00:27:34,090
所以，你遵循我刚在说的简单规则，

435
00:27:34,090 --> 00:27:36,490
你知道，如果我们每次共享数据结构，

436
00:27:36,700 --> 00:27:40,510
那么共享数据结构中的操作就需要锁，

437
00:27:40,540 --> 00:27:44,230
我们应该在每个操作中把锁和数据结构关联起来，

438
00:27:44,230 --> 00:27:53,340
实际上，它在数据结构上执行，

439
00:27:53,340 --> 00:27:54,840
来获取或释放锁。

440
00:27:55,320 --> 00:27:57,270
所以考虑它的一种方式是，

441
00:27:57,390 --> 00:28:02,350
在 xv6 术语中，每一种数据结构都有一个锁，

442
00:28:04,440 --> 00:28:07,800
这种情况下，锁是自动获取的，

443
00:28:07,800 --> 00:28:09,660
当我们做任何与该结构相关的事情时，

444
00:28:09,750 --> 00:28:12,410
结果发现它太死板了，

445
00:28:12,500 --> 00:28:16,250
这就是为什么锁不是自动的。

446
00:28:16,800 --> 00:28:19,260
所以在运行操作系统中，

447
00:28:19,260 --> 00:28:21,330
比如操作系统如下所示，

448
00:28:21,630 --> 00:28:24,120
假设我们有一个叫 rename 的调用。

449
00:28:25,530 --> 00:28:29,370
它将文件名从一个目录移动到另一个目录，

450
00:28:29,490 --> 00:28:31,620
假设我们有 d1/x ，

451
00:28:32,160 --> 00:28:36,720
我们把它重命名为 d2/y 。

452
00:28:37,840 --> 00:28:41,260
所以，我们在目录中有文件名 d1/x ，

453
00:28:41,260 --> 00:28:44,890
我们把它重命名为 d2/y 。

454
00:28:45,460 --> 00:28:50,140
所以，如果我们遵循严格的规则，

455
00:28:50,140 --> 00:28:53,260
比如这个原子锁定规则，会发生什么。

456
00:28:53,740 --> 00:28:56,560
这条规则，当我们有两个对象，

457
00:28:56,560 --> 00:28:57,940
d1 和 d2 。

458
00:28:58,820 --> 00:29:01,760
所以我们遵循规则，原子规则，

459
00:29:01,760 --> 00:29:15,070
我们对 d1 加锁，删除 x ，然后释放 d1 的锁。

460
00:29:17,740 --> 00:29:20,470
然后，我们做数据的第二部分，

461
00:29:20,470 --> 00:29:30,640
对 d2 加锁，添加 y ，然后释放 d2 。

462
00:29:33,460 --> 00:29:33,970
然后我们就完成了。

463
00:29:34,000 --> 00:29:37,780
这是一种假设的方案，

464
00:29:37,780 --> 00:29:42,850
你可以想象如果我们进行原子锁会发生什么，

465
00:29:43,360 --> 00:29:47,920
这个例子的重点是会产生错误的结果，

466
00:29:48,280 --> 00:29:51,820
为什么这是一个有问题的方案，

467
00:29:52,090 --> 00:29:53,350
为什么这行不通。

468
00:30:03,170 --> 00:30:06,620
所以，要考虑的是这个时间。

469
00:30:08,000 --> 00:30:11,360
所以我们已经完成了第一步，

470
00:30:12,050 --> 00:30:13,880
还没有完成第二步。

471
00:30:14,630 --> 00:30:16,640
另一个进程会观察到什么。

472
00:30:24,160 --> 00:30:24,820
有人知道吗？

473
00:30:28,950 --> 00:30:30,480
文件丢失了。

474
00:30:30,870 --> 00:30:33,810
是的，在第一步和第二步之间，

475
00:30:33,810 --> 00:30:34,950
这个文件不存在。

476
00:30:41,520 --> 00:30:43,050
我的意思是这显然是错误的，

477
00:30:43,080 --> 00:30:46,470
因为该文件确实存在，它只是被重命名，

478
00:30:46,710 --> 00:30:49,410
应该没有什么时候它不存在，

479
00:30:50,430 --> 00:30:52,890
但是通过以这种方式实现它，

480
00:30:53,040 --> 00:30:56,160
看起来该文件可能并不存在，

481
00:30:56,160 --> 00:30:57,000
尽管它确实存在。

482
00:30:57,800 --> 00:31:00,230
所以正确的解决方案是，

483
00:31:00,230 --> 00:31:03,790
我们需要的是，

484
00:31:03,790 --> 00:31:10,250
在重命名开始前，先锁定 d1 和 d2 ，

485
00:31:10,760 --> 00:31:13,120
然后擦除并添加，

486
00:31:15,780 --> 00:31:21,580
然后释放 d1 和 d2 的锁。

487
00:31:24,500 --> 00:31:25,250
所以，这能理解吗？

488
00:31:26,870 --> 00:31:27,950
所以，这是一个例子，

489
00:31:27,950 --> 00:31:32,810
我们有一个需要多个锁的操作，

490
00:31:32,960 --> 00:31:37,550
并且锁不能真正地与这两个对象相关联，

491
00:31:37,550 --> 00:31:39,170
它们是这个操作的参数，

492
00:31:39,590 --> 00:31:44,840
实际上操作本身必须首先获取两个锁，

493
00:31:44,840 --> 00:31:46,580
然后执行操作。

494
00:31:47,400 --> 00:31:50,490
所以原子锁不是直接可能的。

495
00:31:51,250 --> 00:31:52,120
会有这种情况，

496
00:31:52,120 --> 00:31:55,990
不是运行简单的方案，

497
00:31:55,990 --> 00:31:58,360
它们会遇到问题。

498
00:32:00,400 --> 00:32:01,300
对这个有什么问题吗？

499
00:32:07,010 --> 00:32:08,900
所以我们能不能这么说，

500
00:32:08,930 --> 00:32:11,120
当我们访问数据结构时，

501
00:32:11,120 --> 00:32:13,490
我们需要访问或者我们必须获取

502
00:32:13,490 --> 00:32:17,240
所有我们需要的数据结构相关联的锁，

503
00:32:17,570 --> 00:32:18,350
在开始的时候。

504
00:32:19,120 --> 00:32:19,840
这是其中之一，

505
00:32:19,870 --> 00:32:21,520
是的，这是一种方法，

506
00:32:21,520 --> 00:32:26,530
我想很快会归结到拥有一个大内核锁。

507
00:32:27,380 --> 00:32:28,790
好的。

508
00:32:28,790 --> 00:32:31,190
你在不会有并发的风险上，

509
00:32:31,850 --> 00:32:33,560
所以你想做得更好，

510
00:32:34,190 --> 00:32:35,690
我认为这一直是矛盾，

511
00:32:35,750 --> 00:32:37,100
你可以使事情变得简单，

512
00:32:37,130 --> 00:32:40,670
通过使用粗粒度锁，

513
00:32:41,060 --> 00:32:44,630
但是你会丢失性能，

514
00:32:44,990 --> 00:32:46,190
或者可能丢失性能，

515
00:32:46,740 --> 00:32:48,270
取决于锁是不是有意的。

516
00:32:49,730 --> 00:32:50,750
好的，谢谢。

517
00:32:52,700 --> 00:32:58,430
从锁的角度来看，这是考虑锁的不同方法。

518
00:33:00,910 --> 00:33:02,590
这有三个常见的问题，

519
00:33:02,650 --> 00:33:05,620
而且，它们三个都要，

520
00:33:05,620 --> 00:33:08,290
也许这会帮助你思考锁的问题，

521
00:33:08,290 --> 00:33:09,940
也许其中一个是你的最爱，

522
00:33:09,940 --> 00:33:13,300
你可以使用它作为你思考问题的方式，

523
00:33:13,300 --> 00:33:14,680
但是，这些可能是有用的，

524
00:33:14,680 --> 00:33:16,660
它们以不同的方式来思考锁。

525
00:33:17,530 --> 00:33:19,990
首先，

526
00:33:20,080 --> 00:33:28,350
可以考虑的一种方式是锁避免丢失更新，

527
00:33:28,470 --> 00:33:29,160
或者帮助（避免丢失）。

528
00:33:29,840 --> 00:33:31,370
如果你正确使用锁，

529
00:33:31,370 --> 00:33:34,430
锁可以帮助避免丢失更新。

530
00:33:38,680 --> 00:33:43,060
如果你考虑一下之前的 kalloc.c 中的示例，

531
00:33:43,060 --> 00:33:48,460
丢失的更新就是丢失了 kfree 的一个更新。

532
00:33:49,150 --> 00:33:53,530
通过使用锁，它没有丢失更新，

533
00:33:53,590 --> 00:33:55,210
所以这是思考这个问题的一种方式，

534
00:33:56,070 --> 00:33:58,260
一种非常低级的方式。

535
00:33:58,260 --> 00:34:00,930
另一种思考方式是，你可以使用锁，

536
00:34:00,930 --> 00:34:11,200
锁使多步操作成为原子操作。

537
00:34:13,700 --> 00:34:15,680
所以，有一种临界区间的观点，

538
00:34:15,680 --> 00:34:21,050
我们使用锁在一系列步骤或指令上，

539
00:34:21,050 --> 00:34:23,210
执行所有指令，然后释放，

540
00:34:23,450 --> 00:34:27,320
整个临界区间作为原子操作执行。

541
00:34:27,870 --> 00:34:32,460
这也是思考锁的一个很好的方式。

542
00:34:33,090 --> 00:34:33,990
然后是第三个，

543
00:34:34,410 --> 00:34:35,940
这可能会有帮助，

544
00:34:35,940 --> 00:34:43,410
锁真正的作用是锁帮助维护一个不变量，

545
00:34:47,140 --> 00:34:50,200
不变量共享它在保护的数据结构。

546
00:34:51,260 --> 00:34:54,200
这里发生的是，

547
00:34:54,500 --> 00:34:56,900
在 acquire 之前，

548
00:34:56,930 --> 00:34:59,780
如果没有锁持有者，持有不变量，

549
00:35:00,140 --> 00:35:02,990
当我们获得锁，并进行一些操作时，

550
00:35:02,990 --> 00:35:07,310
那么可能暂时违反不变量，

551
00:35:07,670 --> 00:35:09,380
但是在我们使用 release 的时候，

552
00:35:13,180 --> 00:35:17,080
如果你考虑一下 r freelist 的例子，

553
00:35:17,320 --> 00:35:23,290
不变量是空闲指针指向下一个指针，

554
00:35:23,350 --> 00:35:26,500
并且所有的空闲页面都在一个列表上。

555
00:35:27,390 --> 00:35:32,160
在这一点上，这是暂时违反的，

556
00:35:33,950 --> 00:35:36,200
在 kfree 中间，

557
00:35:36,200 --> 00:35:39,380
因为多个指针指向 freelist 的开头。

558
00:35:40,760 --> 00:35:42,860
然后我们在末尾建立。

559
00:35:43,750 --> 00:35:47,860
所以如果 freelist 不是那么复杂的变量，

560
00:35:47,860 --> 00:35:50,080
比如更复杂的共享数据结构，

561
00:35:50,590 --> 00:35:54,040
可以是一种很有帮助的方式，来思考锁到底做了什么。

562
00:35:55,330 --> 00:35:58,390
所以，即使在这三个示例中，

563
00:35:58,390 --> 00:36:01,210
所有三种锁视角都是合理的，

564
00:36:01,450 --> 00:36:07,330
它们中的一个，带来了更多思考，

565
00:36:07,330 --> 00:36:12,040
然后，另一个用来考虑锁。

566
00:36:14,510 --> 00:36:17,060
对于这一点，有什么问题吗？

567
00:36:23,560 --> 00:36:25,060
好的。

568
00:36:25,620 --> 00:36:30,420
所以，在我们自己的几件事上，

569
00:36:31,460 --> 00:36:34,760
在[所需]属性中，或者使用锁可能发生的事，

570
00:36:34,850 --> 00:36:41,210
你知道，锁用来修复正确性问题，避免竞态条件，

571
00:36:41,450 --> 00:36:45,230
但是当不适当的使用锁，

572
00:36:45,320 --> 00:36:47,630
也会引入它们自己的一套问题。

573
00:36:48,280 --> 00:36:49,960
所以我想谈一谈这一点，

574
00:36:50,380 --> 00:36:52,570
最明显的一个当然是死锁。

575
00:36:57,240 --> 00:36:59,790
比如，这个简单的例子，

576
00:36:59,790 --> 00:37:02,790
虽然有点无聊，但值得一想，

577
00:37:03,000 --> 00:37:07,040
你获取锁，

578
00:37:07,680 --> 00:37:09,660
你开始了临界区间，

579
00:37:09,660 --> 00:37:14,650
在临界区间内，你又一次获取了同一把锁，

580
00:37:16,930 --> 00:37:17,830
接下来会发生什么，

581
00:37:20,300 --> 00:37:22,010
第二次获取能成功吗？

582
00:37:29,640 --> 00:37:32,850
好吧，我们早些时候已经说过了，

583
00:37:32,850 --> 00:37:34,590
你知道这是不允许的，

584
00:37:34,710 --> 00:37:37,110
所以第二次获取会被阻塞，

585
00:37:37,140 --> 00:37:39,570
直到第一次获取被释放锁，

586
00:37:39,570 --> 00:37:41,670
但那是这个进程本身，

587
00:37:41,670 --> 00:37:43,590
所以这会导致死锁。

588
00:37:46,970 --> 00:37:49,070
这是一个微不足道的死锁的例子，

589
00:37:49,160 --> 00:37:50,480
或许不是很有趣，

590
00:37:50,480 --> 00:37:52,580
如果 xv6 [文本]中有一个死锁，

591
00:37:52,580 --> 00:37:56,660
因为当它发现相同的进程再次获取相同的锁时，

592
00:37:56,840 --> 00:37:58,700
就会引起 panic 。

593
00:37:59,330 --> 00:38:03,200
一个更有趣的情况是，当涉及多个锁时，

594
00:38:03,380 --> 00:38:06,960
让我们回到前面的例子，

595
00:38:07,020 --> 00:38:09,330
假设我们有以下内容，

596
00:38:09,930 --> 00:38:13,010
我们有核心一号 CPU1 ，

597
00:38:16,620 --> 00:38:17,670
我们有 CPU2 。

598
00:38:19,970 --> 00:38:30,150
CPU1 执行重命名 d1/x 到 d2/y 。

599
00:38:33,310 --> 00:38:36,370
并且 CPU2 同时执行，

600
00:38:37,100 --> 00:38:43,430
以另一种方式重命名，

601
00:38:43,430 --> 00:38:51,240
从另一个方向， d2/a 到 d1/b ，

602
00:38:51,540 --> 00:38:53,130
只是为了让名字有所不同。

603
00:38:53,520 --> 00:38:57,600
所以这里要注意的关键是，

604
00:38:57,960 --> 00:39:01,680
CPU1 运行重命名从 d1 到 d2 ，

605
00:39:02,160 --> 00:39:05,400
而 CPU2 正好相反，

606
00:39:05,400 --> 00:39:07,290
执行重命名从 d2 到 d1 。

607
00:39:09,040 --> 00:39:10,300
所以让我们假设，

608
00:39:10,300 --> 00:39:13,090
我们是按照它们的参数顺序获取锁的，

609
00:39:13,480 --> 00:39:15,190
那么会发生什么，

610
00:39:15,670 --> 00:39:18,670
在这种情况下，你获得两个锁，

611
00:39:18,670 --> 00:39:21,610
我们从前面的一个例子中知道，这上是很重要的。

612
00:39:22,080 --> 00:39:26,380
所以获取 d1 锁。

613
00:39:28,570 --> 00:39:31,690
假设是真正的同时运行，

614
00:39:32,200 --> 00:39:34,840
所以在这一点上，另一个可能，

615
00:39:34,840 --> 00:39:39,090
另一个 CPU 可能会先获取 d2 ，

616
00:39:39,180 --> 00:39:41,190
因为这是它的第一个参数。

617
00:39:43,180 --> 00:39:46,570
而现在 d1 想要获得 d2 ，

618
00:39:48,470 --> 00:39:50,720
所以会尝试获取 d2 。

619
00:39:51,260 --> 00:39:52,220
它会成功吗，

620
00:39:53,540 --> 00:39:54,410
它不会成功，

621
00:39:54,410 --> 00:39:57,500
因为另一个持有这个锁，

622
00:39:57,530 --> 00:40:00,890
所以这个会到此为止，不再继续。

623
00:40:01,560 --> 00:40:03,480
现在让我们看看另一个 CPU ，

624
00:40:03,480 --> 00:40:05,280
CPU2 获取了 d2 ，

625
00:40:05,280 --> 00:40:07,800
它现在要获取第二个参数 d1 。

626
00:40:08,630 --> 00:40:12,440
它会试着调用 acquire d1 ，

627
00:40:12,800 --> 00:40:14,390
它是否能够继续执行。

628
00:40:14,570 --> 00:40:16,220
不，无法继续，

629
00:40:16,370 --> 00:40:20,420
因为 CPU1 持有锁 d1 。

630
00:40:21,040 --> 00:40:24,130
所以有时这被称为死锁，

631
00:40:24,130 --> 00:40:27,100
因为，

632
00:40:27,430 --> 00:40:30,280
因为我们获取锁的方式，获取的顺序，

633
00:40:30,310 --> 00:40:33,280
获取锁的顺序会导致死锁。

634
00:40:41,050 --> 00:40:42,010
这能理解吗？

635
00:40:42,580 --> 00:40:43,330
这个例子。

636
00:40:45,580 --> 00:40:48,550
这是一个更危险的死锁的例子，

637
00:40:48,580 --> 00:40:50,710
这不是一个明显的问题，

638
00:40:51,010 --> 00:40:54,580
这个情况的解决方案是简单的。

639
00:40:56,370 --> 00:40:58,860
解决方案是，如果你有多把锁，

640
00:40:59,040 --> 00:41:01,500
那你就得对锁排序，

641
00:41:03,930 --> 00:41:08,220
所有操作都必须按照这个顺序来获取锁。

642
00:41:17,410 --> 00:41:18,880
所以如果你是一名系统设计师，

643
00:41:18,880 --> 00:41:24,040
你必须决定所有锁对象的全局顺序，

644
00:41:24,280 --> 00:41:26,320
比如，在这种情况下，

645
00:41:26,320 --> 00:41:30,670
你可能会说 d1 应该总是在 d2 之前，

646
00:41:30,880 --> 00:41:31,930
这就意味着，

647
00:41:32,230 --> 00:41:34,090
当我们执行重命名时，

648
00:41:34,240 --> 00:41:41,230
规则是我们总是先获取更小数字的目录，

649
00:41:41,230 --> 00:41:43,930
在获取更高数字的目录之前。

650
00:41:44,900 --> 00:41:49,220
这将确保全局顺序，

651
00:41:49,220 --> 00:41:52,160
这种情况就不会发生。

652
00:41:53,960 --> 00:41:56,210
因为，锁的顺序会是，

653
00:41:56,210 --> 00:41:59,450
对于这个是 d1 d2 ，

654
00:41:59,690 --> 00:42:04,400
这个也使用相同的顺序获取锁， d1 d2 ，

655
00:42:04,580 --> 00:42:06,980
这样我们就没有死锁了。

656
00:42:09,700 --> 00:42:10,450
这能理解吗？

657
00:42:14,630 --> 00:42:15,830
对于这个，有什么问题吗？

658
00:42:22,180 --> 00:42:25,870
所以这表明了一些问题，

659
00:42:25,870 --> 00:42:26,530
即使这样，

660
00:42:26,530 --> 00:42:28,930
好的，让我们来解决这个死锁问题，

661
00:42:28,930 --> 00:42:32,200
我有全局顺序，请注意这个顺序是全局的，

662
00:42:32,560 --> 00:42:38,370
这有一个小问题，

663
00:42:38,490 --> 00:42:40,440
在设计系统时，因为。

664
00:42:40,860 --> 00:42:42,120
等一下。

665
00:43:07,510 --> 00:43:10,480
所以考虑一下锁的顺序，

666
00:43:15,050 --> 00:43:16,610
一定是全局的。

667
00:43:18,030 --> 00:43:26,400
所以，如果我们有一个模块 m1 调用方法模块 m2 的方法。

668
00:43:29,440 --> 00:43:33,970
那么调用者 m1g ，可能需要注意，

669
00:43:33,970 --> 00:43:35,440
或者你需要注意，

670
00:43:35,440 --> 00:43:40,660
在 m2 中 f 获取了哪些锁。

671
00:43:42,630 --> 00:43:48,510
因为，如果 m2 使用了一些锁，

672
00:43:48,750 --> 00:43:51,960
然后遵守我们的锁规则，

673
00:43:52,110 --> 00:43:55,080
只需要确保如果它有锁，

674
00:43:55,170 --> 00:43:57,720
从 f 和 g 获取的所有锁，

675
00:43:57,720 --> 00:44:00,480
是在某种全局顺序中。

676
00:44:01,270 --> 00:44:03,880
所以这意味着这些内部结构，

677
00:44:06,600 --> 00:44:17,570
就锁而言， m2 的内部部件必须对 m1 可见。

678
00:44:21,400 --> 00:44:23,110
所以 m1 可以确保，

679
00:44:23,110 --> 00:44:28,360
以适当的方式调用 m2 。

680
00:44:29,120 --> 00:44:32,420
在某些方面，这是一种对抽象的违反，

681
00:44:34,700 --> 00:44:36,050
实际上做得很好，

682
00:44:36,050 --> 00:44:39,350
m1 不需要知道关于 m2 实现的任何信息，

683
00:44:39,830 --> 00:44:42,980
不幸的是，锁是一种常见的例子，

684
00:44:42,980 --> 00:44:47,030
m2 要讲内部信息泄露给 m1 ，

685
00:44:47,240 --> 00:44:48,740
因为 m1 确实需要知道。

686
00:44:49,740 --> 00:44:53,400
所以，当你设计一个更大的系统时，

687
00:44:53,400 --> 00:44:56,130
这使得模块化变得更加复杂。

688
00:45:01,730 --> 00:45:07,160
抱歉，我想知道，是否需要完整的锁的顺序，

689
00:45:07,160 --> 00:45:10,010
或者有没有一些锁，

690
00:45:10,400 --> 00:45:14,750
可以用任何方式排序。

691
00:45:14,900 --> 00:45:16,640
是的，这要看情况，

692
00:45:16,640 --> 00:45:19,370
如果 f 和 g 共享任何锁，

693
00:45:19,970 --> 00:45:22,460
比如，如果查看 xv6 ，

694
00:45:22,730 --> 00:45:27,560
它有多个锁顺序链，

695
00:45:27,560 --> 00:45:29,570
因为有些函数与其他锁无关，

696
00:45:29,570 --> 00:45:32,270
它们永远不会一起获得。

697
00:45:33,000 --> 00:45:34,890
所以如果它们从来没有一起获取，

698
00:45:34,890 --> 00:45:36,600
如果您愿意，只需连接锁集，

699
00:45:36,930 --> 00:45:41,340
然后，只需要确保特定锁集合中的顺序是全局的，

700
00:45:41,610 --> 00:45:45,630
并且其它锁集合的顺序序完全独立于其它顺序。

701
00:45:47,730 --> 00:45:50,940
所以这是正确的，不一定是全局顺序，

702
00:45:50,940 --> 00:45:55,560
但就像所有操作相同共享类型的锁集的函数，

703
00:45:55,650 --> 00:45:57,480
它们需要一致的全局顺序。

704
00:45:59,130 --> 00:45:59,910
谢谢。

705
00:46:04,430 --> 00:46:05,300
好的，那么。

706
00:46:05,880 --> 00:46:11,010
另一种挑战使用锁的挑战，

707
00:46:11,070 --> 00:46:12,420
我们已经看到了两个挑战，

708
00:46:12,420 --> 00:46:14,130
一个是死锁，一个是模块化，

709
00:46:14,520 --> 00:46:19,640
第三个挑战是锁与性能。

710
00:46:24,100 --> 00:46:26,800
我之前暗示了几次，

711
00:46:26,800 --> 00:46:28,600
但它需要，

712
00:46:28,630 --> 00:46:32,770
强调一下是非常重要的。

713
00:46:33,400 --> 00:46:37,720
所以我们想要性能，

714
00:46:37,720 --> 00:46:40,180
你需要拆分数据结构，

715
00:46:40,660 --> 00:46:42,880
所以如果你有一个大内核锁，

716
00:46:43,150 --> 00:46:46,660
这将使你的性能限于在单个 CPU 上，

717
00:46:46,810 --> 00:46:51,850
如果你想要具有多个 CPU 扩展的性能，

718
00:46:52,060 --> 00:46:53,140
你就得拆分。

719
00:46:54,190 --> 00:46:55,690
你需要拆分数据结构。

720
00:47:04,910 --> 00:47:10,130
最好的拆分，它并不明显，

721
00:47:10,280 --> 00:47:11,420
或者是一个挑战，

722
00:47:17,780 --> 00:47:21,380
比如，如果你将锁与每个目录相关联，

723
00:47:21,380 --> 00:47:23,510
如果你将锁与每个 inode 相关联，

724
00:47:23,870 --> 00:47:25,940
是否将锁与每个进程相关联。

725
00:47:26,480 --> 00:47:30,920
哪里是，更适合的以不同的方式拆分数据结构。

726
00:47:31,930 --> 00:47:35,290
如果你需要修改，

727
00:47:35,290 --> 00:47:39,700
重新设计锁规则，

728
00:47:39,700 --> 00:47:41,530
你必须确保，

729
00:47:41,530 --> 00:47:43,540
你仍然保持着不变量，

730
00:47:43,540 --> 00:47:46,210
是内核想要保持的。

731
00:47:46,870 --> 00:47:48,790
如果你拆分锁，

732
00:47:48,790 --> 00:47:50,590
你还必须重写代码。

733
00:47:51,540 --> 00:47:57,500
你也可能需要重写代码。

734
00:48:02,540 --> 00:48:03,830
所以事实证明，

735
00:48:03,830 --> 00:48:11,360
你应该重构内核的一部分，或者你的程序的一部分，

736
00:48:11,660 --> 00:48:12,920
为了获得更好的性能，

737
00:48:12,920 --> 00:48:16,340
通过拆分数据结构或引入更多的锁，

738
00:48:16,610 --> 00:48:18,470
有很多工作要做，

739
00:48:18,470 --> 00:48:22,040
你要仔细考虑，想要维持持的范围，

740
00:48:22,310 --> 00:48:24,110
你必须要写代码，

741
00:48:24,350 --> 00:48:27,050
一般说来，这是一项繁重的工作，

742
00:48:28,020 --> 00:48:28,800
它们并不容易。

743
00:48:32,500 --> 00:48:35,680
所以这是比较负面的观点，

744
00:48:35,680 --> 00:48:38,530
因为我们想要更好的性能，

745
00:48:38,560 --> 00:48:40,360
这需要更多的锁。

746
00:48:40,690 --> 00:48:46,280
但这是一项繁重的工作。

747
00:48:46,940 --> 00:48:51,840
对于这个问题，有一种普遍的做法是，

748
00:48:51,840 --> 00:48:54,980
从粗粒度的锁开始，

749
00:49:05,160 --> 00:49:06,000
然后测量。

750
00:49:11,600 --> 00:49:14,450
不管是什么应用程序运行在内核上，

751
00:49:14,690 --> 00:49:18,020
观察是否得到了加速，

752
00:49:18,020 --> 00:49:19,880
如果它们利用了多个核心。

753
00:49:20,560 --> 00:49:23,290
如果它们这样做了，你就完成了，

754
00:49:23,290 --> 00:49:25,240
你的锁设计已经够好了，

755
00:49:25,990 --> 00:49:27,460
如果没有加快速度，

756
00:49:27,460 --> 00:49:29,620
这意味着某些锁被争用，

757
00:49:33,030 --> 00:49:35,820
多个进程尝试获取相同的锁，

758
00:49:35,850 --> 00:49:37,500
因此它们被串行化了，

759
00:49:37,710 --> 00:49:39,630
所以，得不到加速。

760
00:49:40,160 --> 00:49:44,390
然后你需要重新考虑，需要重新设计。

761
00:49:48,020 --> 00:49:49,400
但这里的重点是，

762
00:49:49,400 --> 00:49:52,640
你要以这些测量来指导，

763
00:49:53,030 --> 00:49:54,380
因为可能是这种情况，

764
00:49:54,380 --> 00:49:59,840
一些使用粗粒度锁的模块不是经常并行调用，

765
00:49:59,930 --> 00:50:02,780
所以，没有必要对它重新设计，

766
00:50:03,140 --> 00:50:04,670
因为重新设计有很多工作要做，

767
00:50:04,700 --> 00:50:08,510
这也会使代码的条理变得复杂，

768
00:50:08,600 --> 00:50:12,200
不重新设计这些是一个更好的选择，

769
00:50:12,200 --> 00:50:13,190
这不是必须的。

770
00:50:15,430 --> 00:50:19,690
所以，一般说来，一条好的规则是，

771
00:50:19,690 --> 00:50:21,250
从粗粒度的锁开始，

772
00:50:21,340 --> 00:50:24,310
测量这些锁中的一个是否出现争用，

773
00:50:24,310 --> 00:50:26,230
然后重新设计系统的这一部分，

774
00:50:26,230 --> 00:50:28,480
你就会得到更好的并行性。

775
00:50:30,740 --> 00:50:33,170
这能理解吗，目前为止有什么问题吗？

776
00:50:39,030 --> 00:50:41,490
好的，我们来看一下。

777
00:50:42,140 --> 00:50:46,070
好的，让我们看看 xv6 中的一些代码，

778
00:50:46,190 --> 00:50:51,650
了解一下，锁在 xv6 中实际是如何工作的。

779
00:50:53,650 --> 00:50:57,190
所以，我要回到，

780
00:50:58,480 --> 00:51:01,470
回到这一屏，

781
00:51:01,680 --> 00:51:03,180
我需要这个。

782
00:51:03,680 --> 00:51:05,690
我想看看 uart ，

783
00:51:05,690 --> 00:51:08,270
因为我们从那里开始讨论锁。

784
00:51:10,240 --> 00:51:13,820
在周一的时候。

785
00:51:13,820 --> 00:51:15,350
我想更详细的看看它。

786
00:51:16,390 --> 00:51:18,580
现在我们对锁有了更多的了解，

787
00:51:18,580 --> 00:51:21,250
也说明了几个有趣的观点。

788
00:51:28,110 --> 00:51:32,490
首先，你想知道，

789
00:51:32,520 --> 00:51:35,470
查看锁，

790
00:51:35,500 --> 00:51:38,860
UART 只有一个锁，

791
00:51:39,070 --> 00:51:41,890
你可以认为这是一个可用的粗粒度（锁），

792
00:51:41,950 --> 00:51:45,040
在一点上对于 UART 来说。

793
00:51:45,540 --> 00:51:49,830
这个锁保护 UART 传输缓冲区，

794
00:51:50,190 --> 00:51:53,550
以及写指针和读指针。

795
00:51:55,150 --> 00:51:56,230
当我们传输的时候，

796
00:51:56,230 --> 00:52:01,120
写指针指向传输缓冲区中的下一个空闲插槽，

797
00:52:01,330 --> 00:52:04,570
而读指针是需要传输的下一个插槽。

798
00:52:05,200 --> 00:52:10,510
这就是我们并行的标准设计，

799
00:52:11,060 --> 00:52:14,090
或者是生产者消费者并行性。

800
00:52:15,210 --> 00:52:19,230
让我回去，把它拿出来。

801
00:52:19,470 --> 00:52:25,820
案例研究 UART ，

802
00:52:27,340 --> 00:52:28,870
这是缓冲区，

803
00:52:29,870 --> 00:52:32,150
有一个读指针，一个写指针，

804
00:52:32,480 --> 00:52:35,750
或者写索引和读索引。

805
00:52:37,110 --> 00:52:40,620
这是连接到用来显示的 UART ，

806
00:52:42,820 --> 00:52:44,320
这是写入端，

807
00:52:46,740 --> 00:52:50,730
可能是 printf ，将字符插入到缓冲区中。

808
00:52:52,490 --> 00:52:53,090
好的?

809
00:52:53,840 --> 00:52:58,760
所以，我们可以看到这个锁有多个作用。

810
00:53:03,200 --> 00:53:06,200
一个是保护这个数据结构，

811
00:53:11,640 --> 00:53:13,500
这个数据结构具有某种不变性，

812
00:53:14,200 --> 00:53:17,890
也就是，从读到写，

813
00:53:18,250 --> 00:53:23,080
任何在 R 和 W 之间的字符都是要发送的，

814
00:53:23,440 --> 00:53:27,100
任何在 W 和 R 之间的东西都是空插槽。

815
00:53:27,780 --> 00:53:32,370
这个锁帮助我们维持这个不变量。

816
00:53:34,080 --> 00:53:37,980
所以，我们回到代码。

817
00:53:38,480 --> 00:53:41,210
让我们看一下 acquire 。

818
00:53:41,900 --> 00:53:43,280
这里是 uartputc ，

819
00:53:44,480 --> 00:53:47,600
uartputc 做的第一件事是，

820
00:53:47,600 --> 00:53:49,190
获取锁，

821
00:53:49,900 --> 00:53:53,440
然后插入一个字符，

822
00:53:53,500 --> 00:53:55,120
如果缓冲区中有位置，

823
00:53:55,150 --> 00:53:56,830
将字符插入缓冲区，

824
00:53:57,190 --> 00:53:59,110
开始打印，

825
00:53:59,110 --> 00:54:02,460
然后释放锁，

826
00:54:02,670 --> 00:54:07,620
所以，如果两个进程同时调用 uartputc ，

827
00:54:07,740 --> 00:54:10,380
那么锁将会确保，

828
00:54:10,410 --> 00:54:13,140
第一个进程中的一个字符出现在第一个插槽中，

829
00:54:13,170 --> 00:54:18,720
然后第二个进程的字符进入下一个插槽，

830
00:54:18,780 --> 00:54:22,920
它们不会最终进入同一个插槽。

831
00:54:22,920 --> 00:54:24,270
所以这是一个明显的例子，

832
00:54:24,270 --> 00:54:30,690
锁可以帮助我们避免竞态条件，

833
00:54:30,750 --> 00:54:34,360
否则，第二个进程可能会

834
00:54:34,360 --> 00:54:37,390
覆盖第一个进程的字符，

835
00:54:38,740 --> 00:54:39,700
这是一部分。

836
00:54:40,150 --> 00:54:42,190
然后，我们看看。

837
00:54:42,960 --> 00:54:44,130
我们之前看过一点，

838
00:54:44,130 --> 00:54:44,970
我们查看 start ，

839
00:54:45,000 --> 00:54:46,740
我们看到有更多的事情。

840
00:54:48,640 --> 00:54:52,000
这个，我们看到，

841
00:54:53,220 --> 00:54:56,850
如果缓冲区不是，

842
00:54:57,460 --> 00:54:58,750
如果缓冲器不为空，

843
00:54:59,080 --> 00:55:03,070
那么我们知道有一些字符，

844
00:55:03,070 --> 00:55:05,800
正在进行或正在发送。

845
00:55:06,450 --> 00:55:08,580
你知道锁可以确保，

846
00:55:08,580 --> 00:55:11,160
我们不会覆盖其中的任何一个，

847
00:55:11,370 --> 00:55:15,390
所以任何队列尾端的东西，

848
00:55:15,390 --> 00:55:22,590
是由 UART 本身处理的。

849
00:55:22,620 --> 00:55:27,460
所以，尾端正在处理。

850
00:55:30,370 --> 00:55:31,510
我们确保，

851
00:55:31,510 --> 00:55:37,090
通过获取锁，我们不会在这个方面修改或干扰。

852
00:55:38,060 --> 00:55:41,930
最后，更多的事情是，

853
00:55:42,140 --> 00:55:46,520
对 UART 寄存器的写入，

854
00:55:46,520 --> 00:55:47,720
比如 THR 寄存器，

855
00:55:47,720 --> 00:55:51,230
这里只有一个锁确保，

856
00:55:51,350 --> 00:55:54,770
记得 uartstart 在持有锁的情况下调用，

857
00:55:55,100 --> 00:55:58,880
确保只有一个写入者到 THR 寄存器。

858
00:55:59,870 --> 00:56:05,390
所以，另一方面锁确保的是，

859
00:56:05,390 --> 00:56:11,500
硬件寄存器有一个写入者。

860
00:56:16,460 --> 00:56:17,090
好的?

861
00:56:18,530 --> 00:56:20,150
还有一件有趣的事，

862
00:56:20,150 --> 00:56:22,730
我想稍微谈一下，

863
00:56:23,120 --> 00:56:27,770
那就是 UART 硬件完成后，

864
00:56:27,770 --> 00:56:29,570
会有一个中断。

865
00:56:30,170 --> 00:56:32,600
如你所知，

866
00:56:32,600 --> 00:56:34,370
我们注意到在 uartstart 之前，

867
00:56:34,370 --> 00:56:37,250
我们有调用者，

868
00:56:37,250 --> 00:56:39,080
它是获取锁的调用者，

869
00:56:39,140 --> 00:56:41,690
来确保，

870
00:56:41,900 --> 00:56:45,830
我们不会有多个[]写入写寄存器。

871
00:56:46,620 --> 00:56:50,820
UART 中断本身可以

872
00:56:50,820 --> 00:56:54,780
与调用 printf 的其他进程并行运行，

873
00:56:54,780 --> 00:56:58,500
所以，有一些实际的 printf 运行在 CPU0 上，

874
00:56:58,560 --> 00:57:01,500
而在 CPU1 上接受 UART 中断，

875
00:57:01,530 --> 00:57:02,910
因为它什么都没做，

876
00:57:02,910 --> 00:57:05,250
所以，它可以在任何时间点中断。

877
00:57:05,720 --> 00:57:08,360
它将会调用 uartstart 。

878
00:57:09,080 --> 00:57:10,610
它必须是这种情况，

879
00:57:10,610 --> 00:57:14,030
我们希望确保硬件寄存器中只有一个写入者，

880
00:57:14,270 --> 00:57:19,100
或者保护传输缓冲区的不变性，

881
00:57:19,460 --> 00:57:21,380
我们必须获取锁。

882
00:57:21,810 --> 00:57:24,480
所以，在 xv6 中，

883
00:57:24,480 --> 00:57:29,130
中断可以运行驱动的下半部，

884
00:57:29,130 --> 00:57:33,600
可以在不同的处理器上真正的同时运行，

885
00:57:33,630 --> 00:57:35,790
和驱动的上半部一起，

886
00:57:36,000 --> 00:57:40,140
所以，中断函数也需要锁。

887
00:57:40,930 --> 00:57:42,430
实际上，在这种情况下，

888
00:57:42,580 --> 00:57:45,820
需要在 UART 中的锁，

889
00:57:45,850 --> 00:57:47,770
然后调用 uartstart ，

890
00:57:47,770 --> 00:57:48,940
然后释放锁。

891
00:57:50,720 --> 00:57:52,640
稍后，我会回到这里，

892
00:57:52,670 --> 00:57:57,110
因为实现锁比较困难，

893
00:57:57,350 --> 00:57:59,690
在这种方式下，这是正确的。

894
00:58:00,490 --> 00:58:05,280
你应该担心的事情是，

895
00:58:05,580 --> 00:58:07,980
稍后我会讲一下，

896
00:58:08,010 --> 00:58:09,510
等到了那里我再讲。

897
00:58:13,040 --> 00:58:15,440
好的，关于这个，有什么问题，

898
00:58:15,440 --> 00:58:20,990
一个简单的使用锁和 UART 的例子。

899
00:58:29,640 --> 00:58:32,220
好的，让我来讲一下，

900
00:58:32,220 --> 00:58:34,140
让我来讲一下实现锁。

901
00:58:34,940 --> 00:58:41,120
所以，规范是只有一个进程可以获取锁，

902
00:58:41,240 --> 00:58:45,110
在任何时间点锁持有者都不会超过一个。

903
00:58:45,640 --> 00:58:48,340
我们想要了解，

904
00:58:48,340 --> 00:58:49,570
如何实现锁，

905
00:58:49,570 --> 00:58:51,400
以保证规范的方式。

906
00:58:51,930 --> 00:58:53,610
我会先写一个错误的锁，

907
00:58:54,440 --> 00:58:58,160
让我们理解这里的挑战是什么，

908
00:58:59,020 --> 00:59:00,280
或者错误的 acquire 。

909
00:59:05,310 --> 00:59:08,160
这样，我们知道挑战是如何实现 acquire 。

910
00:59:09,610 --> 00:59:11,890
这是我的错误的那个，

911
00:59:11,980 --> 00:59:19,480
acquire struct lock *l ，

912
00:59:21,970 --> 00:59:23,020
它所做是，

913
00:59:23,020 --> 00:59:27,400
在它后面，有一个无限循环 while(1) ，

914
00:59:28,980 --> 00:59:37,190
如果 l->locked 是零，表示没有人持有它。

915
00:59:37,900 --> 00:59:40,510
然后，调用者应该获取锁，

916
00:59:40,690 --> 00:59:45,040
那么，我们把 l->locked 设为 1 ，

917
00:59:48,320 --> 00:59:50,360
在这个时刻我们拿到了锁，

918
00:59:50,360 --> 00:59:51,380
我们可以返回，

919
00:59:51,770 --> 00:59:52,880
什么事情都不用做，

920
00:59:53,590 --> 00:59:55,090
并结束循环。

921
00:59:55,090 --> 00:59:56,080
如果我们没拿到锁，

922
00:59:56,080 --> 00:59:57,130
因为 locked 是 1 ，

923
00:59:57,130 --> 00:59:58,480
这意味着有其他人持有锁，

924
00:59:58,480 --> 00:59:59,410
我们只需要继续旋转，

925
01:00:01,080 --> 01:00:03,720
等待一遍又一遍地循环，

926
01:00:03,990 --> 01:00:08,310
直到在某一时刻，锁持有者调用 release ，

927
01:00:08,310 --> 01:00:11,790
它会将 locked 设置为零。

928
01:00:14,740 --> 01:00:18,520
那么这个实现的问题是什么？

929
01:00:20,870 --> 01:00:26,690
我想两个进程可能同时读到它没有被锁。

930
01:00:27,260 --> 01:00:28,520
是的，没错。

931
01:00:30,040 --> 01:00:31,720
所以，这里有一个竞态条件，

932
01:00:31,750 --> 01:00:36,160
竞态条件在这里。

933
01:00:39,020 --> 01:00:42,170
我们可以有两个 CPU 进来。

934
01:00:42,230 --> 01:00:44,060
我们看这个时序图，

935
01:00:44,700 --> 01:00:49,080
你知道 CPU1 ， CPU0 ， CPU1 ，

936
01:00:50,600 --> 01:00:52,220
这是语句 A，

937
01:00:52,550 --> 01:00:53,900
这是语句 B ，

938
01:00:54,500 --> 01:00:58,640
CPU1 到达语句 A ，

939
01:00:58,700 --> 01:01:05,530
CPU0 和 CPU1 都到达语句 A ，

940
01:01:05,530 --> 01:01:09,130
所以，它们都看到 locked 是零，

941
01:01:09,370 --> 01:01:10,930
然后，它们都执行了 B 。

942
01:01:13,470 --> 01:01:15,720
好的，这里它们看到 locked 是 0 ，

943
01:01:17,020 --> 01:01:18,910
这个也看到的是 locked 是 0 。

944
01:01:20,760 --> 01:01:22,920
所以，它们都执行语句 B ，

945
01:01:22,920 --> 01:01:25,800
它们都获得了锁，

946
01:01:26,070 --> 01:01:30,150
那么这个函数违反了规范。

947
01:01:31,670 --> 01:01:32,270
这能理解吗？

948
01:01:35,740 --> 01:01:38,740
所以，要解决这个问题，

949
01:01:38,800 --> 01:01:40,300
并得到一个正确的实现，

950
01:01:40,300 --> 01:01:41,680
有多种方式可以做到，

951
01:01:41,980 --> 01:01:46,720
但最常见的方式是依靠特殊的硬件指令。

952
01:01:47,620 --> 01:01:50,590
这条硬件指令所做的就是，

953
01:01:50,860 --> 01:01:53,830
它做这个测试，并原子的设置。

954
01:01:56,050 --> 01:02:01,470
所以，解决这个问题的方法是

955
01:02:03,140 --> 01:02:09,140
硬件的 testandset 支持。

956
01:02:16,680 --> 01:02:18,690
你可以这样想，

957
01:02:18,690 --> 01:02:20,760
在 RISC-V 上，

958
01:02:20,790 --> 01:02:24,960
这条指令是 amoswap ，

959
01:02:26,680 --> 01:02:27,970
是我们会用到的。

960
01:02:28,740 --> 01:02:32,100
基本上可以归结为测试和设置，

961
01:02:32,130 --> 01:02:34,170
硬件保证，

962
01:02:34,410 --> 01:02:38,580
你使用这三个参数，

963
01:02:38,580 --> 01:02:44,600
地址，寄存器一 r1 和寄存器二，寄存器1 R1和寄存器2

964
01:02:45,020 --> 01:02:50,930
本质上硬件所做的是，

965
01:02:50,930 --> 01:02:52,700
它锁定这个地址，

966
01:02:53,500 --> 01:02:57,650
如果你愿意，我们稍后会更多的讨论锁定地址。

967
01:02:58,200 --> 01:03:03,120
它（把值）放入一个临时变量，

968
01:03:03,910 --> 01:03:07,240
那个地址中的值。

969
01:03:09,570 --> 01:03:16,710
然后，将 r1 的值放到地址中。

970
01:03:17,560 --> 01:03:23,260
然后把原始地址的值放入，

971
01:03:24,380 --> 01:03:30,200
tmp 中的原始值放入 r2 ，

972
01:03:30,470 --> 01:03:32,900
然后释放锁，并返回。

973
01:03:37,220 --> 01:03:39,890
在这个锁里，

974
01:03:39,890 --> 01:03:42,620
你能保证这个测试，

975
01:03:42,740 --> 01:03:45,350
测试结果会返回到 r2 ，

976
01:03:45,620 --> 01:03:48,530
而设置是原子发生的。

977
01:03:49,070 --> 01:03:50,570
所以这是一条硬件指令，

978
01:03:50,600 --> 01:03:53,960
大多数处理器都有这样的硬件指令。

979
01:03:54,440 --> 01:03:58,340
因为这是一种方便的实现锁的方法。

980
01:04:00,560 --> 01:04:03,170
所以我们要做的是，

981
01:04:03,170 --> 01:04:09,770
我们减少软件锁实现原子性，

982
01:04:09,770 --> 01:04:12,320
而是硬件锁实现。

983
01:04:13,190 --> 01:04:19,760
处理器可能会使用不同的方式实现这个，

984
01:04:19,790 --> 01:04:23,900
所以，指令集本身有一份说明书，

985
01:04:23,900 --> 01:04:25,460
它并没有说明它是如何实现的，

986
01:04:25,850 --> 01:04:28,400
它非常依赖于实际的实现。

987
01:04:30,320 --> 01:04:36,770
显然取决于内存系统的工作方式。

988
01:04:44,320 --> 01:04:50,620
比如，如果多个处理器共享单个内存控制器，

989
01:04:50,680 --> 01:04:52,120
对内存进行读写，

990
01:04:52,210 --> 01:04:54,760
那么内存控制器可以支持该操作，

991
01:04:55,060 --> 01:04:59,440
允许在一个特定的地址设置锁，

992
01:04:59,440 --> 01:05:04,000
然后让一个处理器做两个操作或三条指令，

993
01:05:04,240 --> 01:05:05,380
然后解锁，

994
01:05:05,410 --> 01:05:09,310
因为所有处理器的读写都通过这个内存控制器，

995
01:05:09,310 --> 01:05:11,470
内存控制器可以对锁进行排序。

996
01:05:12,290 --> 01:05:17,840
如果处理器中的内存位于共享总线上，

997
01:05:18,110 --> 01:05:21,260
通常是总线仲裁器可以做这个，

998
01:05:21,260 --> 01:05:27,500
总线仲裁器支持以原子方式执行两条内存操作。

999
01:05:28,340 --> 01:05:32,990
如果处理器有缓存，

1000
01:05:32,990 --> 01:05:36,230
那么它通常是高速缓存一致性协议的一部分，

1001
01:05:36,230 --> 01:05:40,460
高速缓存一致性协议将确保，

1002
01:05:40,460 --> 01:05:41,360
如果有写入者，

1003
01:05:41,360 --> 01:05:48,350
缓存行会持有我们要更新的值，

1004
01:05:48,350 --> 01:05:50,150
最终在一个单独的高速缓存中，

1005
01:05:50,580 --> 01:05:56,850
然后，处理器控制有两个操作的单个缓存行的锁。

1006
01:05:57,330 --> 01:05:59,070
所以，这个的实现，

1007
01:05:59,070 --> 01:06:01,500
可以用多种不同的方式来完成，

1008
01:06:01,500 --> 01:06:02,970
但理论上来说，

1009
01:06:02,970 --> 01:06:05,220
所做的是，你锁定地址，

1010
01:06:05,520 --> 01:06:07,440
读取原始值，

1011
01:06:07,770 --> 01:06:09,660
保存新值，

1012
01:06:09,660 --> 01:06:10,770
然后返回值。

1013
01:06:12,360 --> 01:06:13,050
这能理解吗？

1014
01:06:15,820 --> 01:06:18,580
看看我们如何使用这条指令，

1015
01:06:19,240 --> 01:06:25,060
让我们看看 xv6 中 acquire 和 release 的实现，

1016
01:06:25,300 --> 01:06:27,460
它还会揭露一些其他有趣的细节。

1017
01:06:31,800 --> 01:06:34,950
让我先来介绍一下 spinlock.h ，

1018
01:06:34,980 --> 01:06:40,570
spinlock.h ，如你所见，它非常简单，

1019
01:06:40,600 --> 01:06:45,160
它有这个 locked 标记，和我们的伪代码一样，

1020
01:06:45,460 --> 01:06:47,320
还有其他两个东西用来调试，

1021
01:06:47,320 --> 01:06:48,700
即锁的名称，

1022
01:06:48,790 --> 01:06:53,490
和当前持有锁的 CPU 。

1023
01:06:54,170 --> 01:06:56,630
这主要是打印出调试消息，

1024
01:06:56,630 --> 01:06:59,690
比如，获取相同的 CPU 。

1025
01:07:01,450 --> 01:07:07,230
好的，让我们来看看它的实现。

1026
01:07:12,020 --> 01:07:14,630
我们从 acquire 开始。

1027
01:07:15,140 --> 01:07:18,620
我们先看看这个循环，

1028
01:07:19,540 --> 01:07:23,530
这实际上是一种测试和设置循环，

1029
01:07:23,530 --> 01:07:24,880
就是我刚才谈到的，

1030
01:07:25,150 --> 01:07:30,640
实际上，在 C 标准中，

1031
01:07:30,670 --> 01:07:34,390
定义了这些原子操作之一，

1032
01:07:34,420 --> 01:07:38,350
C 标准种有一个函数，

1033
01:07:38,350 --> 01:07:42,070
也就是 __sync_lock_test_and_set ，

1034
01:07:42,070 --> 01:07:45,130
指定了我刚才描述的行为。

1035
01:07:45,700 --> 01:07:50,740
然后，每个处理器都需要实现该行为，

1036
01:07:50,860 --> 01:07:55,180
由于大多数处理器具有测试和设置硬件指令，

1037
01:07:55,420 --> 01:07:58,570
这是实现[]的一个合理而直接的方案，

1038
01:07:58,600 --> 01:08:01,420
实际上，如果我们看看 kernel.asm ，

1039
01:08:01,420 --> 01:08:03,280
我们可以查看汇编指令，

1040
01:08:03,280 --> 01:08:05,980
了解 RISC-V 处理器的确切功能。

1041
01:08:08,000 --> 01:08:09,320
所以。

1042
01:08:11,200 --> 01:08:14,230
这是我们的汇编结构 acquire ，

1043
01:08:14,560 --> 01:08:19,390
这是 amoswap 指令。

1044
01:08:27,830 --> 01:08:29,240
所以你可以看到，

1045
01:08:30,800 --> 01:08:35,240
amoswap 调用寄存器 a5 ，

1046
01:08:35,240 --> 01:08:39,770
并且输入和输出也是 a5 ，

1047
01:08:40,160 --> 01:08:41,930
与整个地址一样长，

1048
01:08:42,200 --> 01:08:48,880
如果不相等，我们就返回，

1049
01:08:48,910 --> 01:08:54,640
否则我们会回到，

1050
01:08:57,170 --> 01:08:58,820
再检查一遍我说的是对的，

1051
01:08:59,180 --> 01:09:02,360
将 a4 移动到[]，

1052
01:09:02,360 --> 01:09:06,620
如果不等于，则到 +0x22 。

1053
01:09:07,260 --> 01:09:09,030
好吧，这有点难计算，

1054
01:09:09,030 --> 01:09:11,400
但基本上在一种情况下，我们[扩展]，

1055
01:09:11,490 --> 01:09:13,080
在另一种情况下，我们向后分支。

1056
01:09:14,270 --> 01:09:16,730
所以，可能看 C 代码更容易。

1057
01:09:19,580 --> 01:09:20,840
所以让我们到这里，

1058
01:09:20,840 --> 01:09:21,800
那么会发生什么呢，

1059
01:09:21,980 --> 01:09:24,590
如果锁没有被持有，

1060
01:09:25,140 --> 01:09:27,090
lk->locked 的值是多少，

1061
01:09:27,090 --> 01:09:29,340
lk->locked 会是零，

1062
01:09:30,180 --> 01:09:31,920
所以我们称之为测试和设置，

1063
01:09:32,100 --> 01:09:35,460
将会发生的是，我们在 locked 中写入 1 ，

1064
01:09:36,330 --> 01:09:37,830
但是返回之前的值。

1065
01:09:38,620 --> 01:09:40,690
所以如果之前的值是零，

1066
01:09:41,140 --> 01:09:43,390
那我们就好了，

1067
01:09:43,390 --> 01:09:45,400
因为这意味着没有人拿着锁，

1068
01:09:45,400 --> 01:09:47,680
我们就结束了这个 while 循环。

1069
01:09:49,740 --> 01:09:51,660
现在，我们假设锁的值是 1 ，

1070
01:09:51,840 --> 01:09:54,990
所以可能锁已经上锁，

1071
01:09:55,350 --> 01:09:56,940
这条指令会做什么，

1072
01:09:57,030 --> 01:10:02,130
它会读取旧值，把它放在一边，

1073
01:10:02,130 --> 01:10:04,020
在这种情况下，是 1 ，

1074
01:10:04,110 --> 01:10:07,110
然后在那个位置写入一个新的 1 。

1075
01:10:07,790 --> 01:10:10,490
这不会改变任何事情，

1076
01:10:10,490 --> 01:10:12,260
因为它已经被锁上了。

1077
01:10:12,810 --> 01:10:14,880
函数将会返回 1 ，

1078
01:10:15,210 --> 01:10:17,370
表明之前的持有，

1079
01:10:17,370 --> 01:10:18,810
它已经被锁上了，

1080
01:10:18,840 --> 01:10:21,360
所以在这种情况下，它不等于零，

1081
01:10:21,480 --> 01:10:23,490
它会旋转，一直旋转，

1082
01:10:23,580 --> 01:10:28,140
直到 locked 重新设置为 0 ，

1083
01:10:28,590 --> 01:10:30,270
而这发生在 release 中。

1084
01:10:32,500 --> 01:10:33,430
对于这个，有什么问题吗？

1085
01:10:51,200 --> 01:10:51,980
没有问题？

1086
01:10:52,810 --> 01:10:54,190
好的。

1087
01:10:56,070 --> 01:11:01,430
所以现在，让我们看看对应的 release 操作，

1088
01:11:01,990 --> 01:11:10,390
这里是 release 操作，

1089
01:11:10,690 --> 01:11:13,570
如果你再看一下 kernel.asm 。

1090
01:11:15,960 --> 01:11:17,160
那个指令，

1091
01:11:17,250 --> 01:11:19,020
所以让我们看看 release ，

1092
01:11:19,020 --> 01:11:20,940
可能在这里后面，这是 release 。

1093
01:11:22,220 --> 01:11:25,700
所以， release 也使用了这个 amoswap 指令，

1094
01:11:27,960 --> 01:11:30,510
把 0 放入 s1 。

1095
01:11:33,520 --> 01:11:35,290
所以这保证的是，

1096
01:11:35,290 --> 01:11:40,090
这个原子更新 lk->locked ，

1097
01:11:40,360 --> 01:11:44,530
使用原子操作将 0 写入 lk->locked 。

1098
01:11:46,080 --> 01:11:49,230
你们中的许多人问到，为什么不直接使用 store ，

1099
01:11:49,800 --> 01:11:51,600
store 指令来写入 0 。

1100
01:11:53,990 --> 01:11:56,910
有没有人，能猜猜为什么，

1101
01:11:58,310 --> 01:11:59,390
为什么那可能行不通，

1102
01:11:59,390 --> 01:12:00,950
或者问题可能是什么。

1103
01:12:02,380 --> 01:12:06,340
因为某个其他进程可能正在将 1 写入锁，或者，

1104
01:12:06,820 --> 01:12:09,200
不，或者再写一个 0 ，

1105
01:12:09,230 --> 01:12:10,610
但不是这样的，对吧。

1106
01:12:11,320 --> 01:12:12,490
是啊，可能是对的，

1107
01:12:12,490 --> 01:12:16,690
可能有两个进程或两个 CPU 同时写入 l->locked ，

1108
01:12:17,170 --> 01:12:20,380
但我认为真正的问题是，

1109
01:12:20,380 --> 01:12:23,230
对很多人来说，我也经常这么想，

1110
01:12:23,350 --> 01:12:25,450
就是你要做一条 store 指令，

1111
01:12:25,450 --> 01:12:27,070
这是一个原子操作。

1112
01:12:28,250 --> 01:12:30,800
并不总是这样的，

1113
01:12:30,830 --> 01:12:33,110
比如，如果你，

1114
01:12:33,110 --> 01:12:35,510
这取决于架构的实现，

1115
01:12:35,540 --> 01:12:38,240
比如，如果缓存[]协议工作，

1116
01:12:38,240 --> 01:12:40,160
或者缓存系统使用缓存行工作，

1117
01:12:40,160 --> 01:12:43,290
其中缓存行可能大于整数，

1118
01:12:43,290 --> 01:12:45,750
通常大于整数，

1119
01:12:45,750 --> 01:12:46,860
那么真正发生的是，

1120
01:12:46,860 --> 01:12:49,110
第一个操作是加载缓存行，

1121
01:12:49,110 --> 01:12:50,460
然后是更新缓存行，

1122
01:12:50,790 --> 01:12:54,510
所以， store 指令里面有两个微操作，

1123
01:12:54,690 --> 01:12:57,540
你可能会得到错误的结果。

1124
01:12:58,990 --> 01:13:05,890
所以，为了避免必须了解任何硬件实现，

1125
01:13:05,890 --> 01:13:08,860
以及整数运算是否是原子的，

1126
01:13:08,890 --> 01:13:14,720
或者写入 64 位内存值是原子操作，

1127
01:13:14,870 --> 01:13:19,550
我们使用 RISC-V 操作，

1128
01:13:19,550 --> 01:13:21,560
它可以保证原子执行。

1129
01:13:25,020 --> 01:13:25,770
这能理解吗？

1130
01:13:28,100 --> 01:13:28,640
是的。

1131
01:13:30,290 --> 01:13:35,610
好的，为了[扩展]一下，

1132
01:13:36,180 --> 01:13:39,450
amoswap 不是唯一存在的指令，

1133
01:13:39,450 --> 01:13:41,160
这是 RISC-V 手册，

1134
01:13:41,490 --> 01:13:44,700
在列表中，是所有的原子操作，

1135
01:13:44,700 --> 01:13:46,800
所以有 AMOAND, AMOOR ，

1136
01:13:46,800 --> 01:13:48,390
还有 AMOMAX, AMOMIN ，

1137
01:13:48,690 --> 01:13:53,820
它们都可以在原子操作中读写一个值。

1138
01:13:58,480 --> 01:13:59,050
好的?

1139
01:13:59,890 --> 01:14:02,350
好的，还有其他几件事我想指出，

1140
01:14:02,380 --> 01:14:04,150
在这个实现中。

1141
01:14:06,420 --> 01:14:10,710
让我重新回到 acquire 。

1142
01:14:12,850 --> 01:14:19,030
所以， acquire 函数首先做的是，

1143
01:14:19,030 --> 01:14:21,460
它关闭了中断。

1144
01:14:22,900 --> 01:14:26,290
最好能理解为什么是这样，

1145
01:14:26,290 --> 01:14:29,140
现在，我回到 UART 示例代码。

1146
01:14:29,680 --> 01:14:31,300
你可以稍微想一想这个。

1147
01:14:31,800 --> 01:14:34,200
所以我们要考虑一下这个情况，

1148
01:14:34,380 --> 01:14:39,430
是 acquire 可能没有正确实现，

1149
01:14:39,430 --> 01:14:41,200
没有关闭中断，

1150
01:14:41,320 --> 01:14:43,960
所以思考这个问题的方法是，

1151
01:14:43,960 --> 01:14:45,700
如果我们到 uartputc ，

1152
01:14:46,090 --> 01:14:48,670
我们假设 uartputc 运行，

1153
01:14:49,170 --> 01:14:52,470
并且获得了锁，

1154
01:14:53,520 --> 01:14:55,470
但是不关闭中断，

1155
01:14:55,530 --> 01:14:56,340
会发生什么。

1156
01:15:03,050 --> 01:15:05,540
给大家几秒钟考虑一下，

1157
01:15:05,930 --> 01:15:07,040
如果你有想法

1158
01:15:07,040 --> 01:15:08,300
或者为什么它可能是错误的，

1159
01:15:08,300 --> 01:15:09,950
可以直接说。

1160
01:15:18,340 --> 01:15:21,520
或许，它可以被中断，

1161
01:15:21,520 --> 01:15:28,240
因为时钟，然后其他事情发生了，

1162
01:15:28,480 --> 01:15:31,090
它也需要打印一些其他的东西，

1163
01:15:31,090 --> 01:15:33,400
它试图再做一次 uartputc ，

1164
01:15:33,970 --> 01:15:35,530
但是锁已经被拿走了。

1165
01:15:35,740 --> 01:15:37,180
这是一种可能的情况，

1166
01:15:37,180 --> 01:15:40,300
有一个更直接的例子。

1167
01:15:40,840 --> 01:15:43,360
我们假设 uartputc 得到了锁，

1168
01:15:43,810 --> 01:15:46,690
而 UART 正忙于传输一些字符。

1169
01:15:47,590 --> 01:15:50,230
那么当 UART 完成了传输字符，

1170
01:15:50,230 --> 01:15:50,890
它要做什么。

1171
01:15:53,160 --> 01:15:54,750
它会导致中断，

1172
01:15:55,230 --> 01:15:57,090
并且 uartintr 运行，

1173
01:15:57,940 --> 01:15:59,560
uartintr 会做什么，

1174
01:16:00,740 --> 01:16:02,300
它获取同一把锁，

1175
01:16:02,450 --> 01:16:04,520
uartputc 已经持有了，

1176
01:16:04,520 --> 01:16:05,600
那么，这里会发生什么，

1177
01:16:06,080 --> 01:16:07,310
如果只有一个 CPU ，

1178
01:16:07,580 --> 01:16:10,580
没有其他 CPU 可以运行这个中断。

1179
01:16:12,460 --> 01:16:13,660
我们现在死锁了，

1180
01:16:13,660 --> 01:16:19,500
因为当前 CPU 持有 uartputc 的锁，

1181
01:16:19,560 --> 01:16:22,110
然后，后面传入的中断，

1182
01:16:22,260 --> 01:16:23,490
它做的第一件事就是，

1183
01:16:23,490 --> 01:16:25,140
获取已经持有的锁。

1184
01:16:25,640 --> 01:16:28,550
实际上，在 xv6 的情况下，你会得到一个 panic ，

1185
01:16:28,640 --> 01:16:30,290
因为相同的 CPU ，

1186
01:16:30,560 --> 01:16:32,780
正在再次尝试获取相同的锁。

1187
01:16:37,460 --> 01:16:40,400
所以，获得自旋锁，

1188
01:16:40,400 --> 01:16:42,920
处理了两种不同类型的并发，

1189
01:16:43,040 --> 01:16:45,710
其一，它们是两个不同 CPU 之间的并发，

1190
01:16:45,980 --> 01:16:47,450
而且我们必须保证，

1191
01:16:47,450 --> 01:16:50,240
中断函数运行在不同的 CPU 上，

1192
01:16:50,420 --> 01:16:52,940
一般我们不会重新安排传输缓冲区，

1193
01:16:53,440 --> 01:16:55,150
但是如果它们在同一个 CPU 上运行，

1194
01:16:55,150 --> 01:16:57,550
我们要确保它仍然是原子的，

1195
01:16:57,550 --> 01:16:58,840
它不会被中断，

1196
01:16:58,840 --> 01:17:01,780
所以，我们在 acquire 中关闭了中断。

1197
01:17:03,360 --> 01:17:06,450
它们只有在 release 结束时才会再次打开，

1198
01:17:06,780 --> 01:17:09,570
当锁被释放的时候，

1199
01:17:09,570 --> 01:17:10,890
在这一点上，再次看到，

1200
01:17:10,920 --> 01:17:12,090
接收中断，

1201
01:17:12,270 --> 01:17:15,090
因为锁不会再被释放，

1202
01:17:16,190 --> 01:17:17,990
不是 acquire 持有它，不再持有。

1203
01:17:18,940 --> 01:17:19,810
这能理解吗？

1204
01:17:28,560 --> 01:17:32,730
好的，在这个实现中还有一件更微妙的事情，

1205
01:17:32,730 --> 01:17:33,900
我想说一下，

1206
01:17:34,260 --> 01:17:39,110
而且我们需要处理。

1207
01:17:43,200 --> 01:17:46,110
那就是内存排序。

1208
01:17:53,810 --> 01:17:57,860
比如，你认为锁是，

1209
01:17:57,860 --> 01:18:01,900
比如， acquire locked 是 1 ，

1210
01:18:02,290 --> 01:18:04,270
也许我们有一个临界区，

1211
01:18:04,270 --> 01:18:06,550
x<-x+1 ，

1212
01:18:06,940 --> 01:18:12,580
然后， release 将 locked 设置为 0 。

1213
01:18:13,260 --> 01:18:15,270
所以，考虑一下指令方案，

1214
01:18:15,270 --> 01:18:17,400
它是在特定的 CPU 上执行的，

1215
01:18:17,550 --> 01:18:20,280
这些是正在执行的指令。

1216
01:18:22,110 --> 01:18:25,620
现在，如果代码仅仅是顺序的。

1217
01:18:30,490 --> 01:18:36,670
编译器或处理器可能会重新排序指令，

1218
01:18:36,670 --> 01:18:38,350
为了获得更好的性能，

1219
01:18:38,680 --> 01:18:43,120
比如，如果它是顺序流，

1220
01:18:43,120 --> 01:18:46,180
可以把这个指令移到后面去吗？

1221
01:18:49,170 --> 01:18:53,010
我们不会改变单一执行流程的正确性。

1222
01:18:58,180 --> 01:18:58,900
你知道，不是很清楚，

1223
01:18:58,930 --> 01:19:01,180
因为锁是完全独立的，

1224
01:19:01,180 --> 01:19:02,950
与它无关，

1225
01:19:02,950 --> 01:19:05,710
如果是顺序执行就完全没问题，

1226
01:19:06,010 --> 01:19:10,030
将 x 移动到 locked 0 之后。

1227
01:19:10,620 --> 01:19:16,020
所以，在单一的串行执行中，

1228
01:19:18,140 --> 01:19:18,830
这是对的。

1229
01:19:23,500 --> 01:19:26,770
实际上，处理器都是这样做的，

1230
01:19:26,770 --> 01:19:28,750
它们[]地执行任务，

1231
01:19:29,170 --> 01:19:31,120
我们期望执行指令，

1232
01:19:31,120 --> 01:19:34,300
这会导致这些指令重新排序。

1233
01:19:34,760 --> 01:19:37,430
编译器也会这样做，

1234
01:19:37,520 --> 01:19:39,290
可能优化一些代码路径，

1235
01:19:39,290 --> 01:19:40,700
并且重新排序指令，

1236
01:19:40,700 --> 01:19:43,730
结果是相同的串行执行。

1237
01:19:44,710 --> 01:19:47,680
但是，很明显在并行执行的过程中这是一场灾难，

1238
01:19:47,680 --> 01:19:49,840
因为如果获取了锁，

1239
01:19:51,320 --> 01:19:52,940
这是我们的 release ，

1240
01:19:54,180 --> 01:19:55,290
我们所做的，

1241
01:19:55,290 --> 01:19:59,670
我们将临界区间移出了 acquire 区间，

1242
01:19:59,670 --> 01:20:00,930
这完全是错误的。

1243
01:20:01,580 --> 01:20:05,940
所以，这在并发执行中是错误的。

1244
01:20:12,780 --> 01:20:17,580
所以，为了禁止或告诉编译器和硬件不要这么做，

1245
01:20:17,910 --> 01:20:21,750
有一个叫做内存屏障的东西，

1246
01:20:21,750 --> 01:20:23,070
或者某个 synchronize ，

1247
01:20:23,370 --> 01:20:24,870
这个指令表示，

1248
01:20:24,870 --> 01:20:27,660
在这个点之前的加载或保存，

1249
01:20:27,900 --> 01:20:30,540
不允许移动到这一点之后。

1250
01:20:31,320 --> 01:20:34,860
所以 release 有这个， acquire 也有这个，

1251
01:20:35,190 --> 01:20:37,350
比如，这个 x<-x+1 ，

1252
01:20:37,380 --> 01:20:41,880
如果这个更新是在 acquire 之后和 release 之前，

1253
01:20:41,910 --> 01:20:43,980
x<-x+1 必须留在，

1254
01:20:43,980 --> 01:20:46,890
这个内存同步点之前。

1255
01:20:47,410 --> 01:20:48,970
所以不会，

1256
01:20:48,970 --> 01:20:52,630
不会有内存重排的问题，

1257
01:20:52,930 --> 01:20:55,750
这就是 __sync_synchronize 在这的原因，

1258
01:20:55,900 --> 01:20:59,530
无论是在 release 还是在 acquire 。

1259
01:21:03,560 --> 01:21:04,250
这能理解吗？

1260
01:21:06,230 --> 01:21:07,670
我有一个问题。

1261
01:21:08,880 --> 01:21:12,450
是不是按照惯例，

1262
01:21:12,450 --> 01:21:18,290
这个[]的开始，

1263
01:21:18,320 --> 01:21:22,670
所以，我想编译器可以搞清楚，

1264
01:21:22,670 --> 01:21:26,810
在获取锁之前，有一条指令，

1265
01:21:26,810 --> 01:21:30,860
它可以被移动到锁释放之后。

1266
01:21:32,830 --> 01:21:34,150
这会发生吗，

1267
01:21:34,150 --> 01:21:37,210
或者它会遇到屏障。

1268
01:21:37,300 --> 01:21:39,280
在这种情况下，

1269
01:21:39,280 --> 01:21:40,420
acquire 是一个屏障，

1270
01:21:40,420 --> 01:21:41,440
release 也是一个屏障，

1271
01:21:41,440 --> 01:21:44,350
所以，任何在 locked 设置为 1 之前发生的事情，

1272
01:21:44,440 --> 01:21:45,640
会在它之前发生，

1273
01:21:45,880 --> 01:21:47,650
永远不会超过那个指令，

1274
01:21:47,680 --> 01:21:48,790
这就是屏障，

1275
01:21:48,910 --> 01:21:49,480
如果你愿意的话，

1276
01:21:50,390 --> 01:21:53,330
这个是屏障一，这是屏障二。

1277
01:21:55,520 --> 01:21:58,820
所以，这意味着在这之前的任何指令，留在这里，

1278
01:21:59,150 --> 01:22:03,440
在之间的指令，会发生在 acquire 和 release 之间，

1279
01:22:03,440 --> 01:22:06,530
之后的指令，将留在 release 之后。

1280
01:22:07,950 --> 01:22:08,550
好的。

1281
01:22:11,110 --> 01:22:11,710
好的?

1282
01:22:12,550 --> 01:22:15,130
好的，我的时间快到了，

1283
01:22:15,160 --> 01:22:19,390
所以让我来总结一下。

1284
01:22:27,710 --> 01:22:32,210
所以，对于锁，锁对正确性有好处，

1285
01:22:40,370 --> 01:22:42,050
但可能会对性能造成不良影响。

1286
01:22:47,480 --> 01:22:49,160
这是一种失望的局面，

1287
01:22:49,160 --> 01:22:51,830
因为我们使用锁的一个原因是，

1288
01:22:51,830 --> 01:22:54,620
为了在并行执行过程中保持正确，

1289
01:22:54,620 --> 01:22:58,130
但是锁实际上限制了并行执行。

1290
01:22:58,850 --> 01:23:06,360
这是一个或两个锁使编程复杂化。

1291
01:23:07,290 --> 01:23:09,420
你会在一些实验里体验到，

1292
01:23:09,420 --> 01:23:11,430
从现在开始，我们将要做的事情，

1293
01:23:11,430 --> 01:23:13,470
我们会看到锁一直会出现，

1294
01:23:13,890 --> 01:23:18,300
这至少会给我们一些思考，

1295
01:23:18,300 --> 01:23:21,060
有必要理解为什么锁在那里，

1296
01:23:21,060 --> 01:23:22,230
以及它们保护的是什么。

1297
01:23:22,700 --> 01:23:26,420
如果你做并行编程，这是一种内在的，

1298
01:23:26,780 --> 01:23:29,210
你需要使用锁。

1299
01:23:29,880 --> 01:23:33,840
所以，如果你想避免锁带来的复杂性，

1300
01:23:33,840 --> 01:23:35,520
你可以做几件事，

1301
01:23:35,550 --> 01:23:37,530
不要分享它，除非必须这么做。

1302
01:23:42,860 --> 01:23:44,480
如果你没有共享数据结构，

1303
01:23:46,340 --> 01:23:48,110
这些竞态条件就不会发生，

1304
01:23:48,350 --> 01:23:51,500
所以这里你不需要锁，

1305
01:23:51,500 --> 01:23:53,390
你不需要这种复杂的编程。

1306
01:23:54,000 --> 01:23:56,760
但是，通常你会有一些共享的数据结构，

1307
01:23:56,760 --> 01:23:58,920
你会需要锁，

1308
01:23:59,100 --> 01:24:01,830
我认为要做的事情是从粗粒度开始，

1309
01:24:04,130 --> 01:24:08,500
然后在需要的时候转向细粒度，

1310
01:24:08,500 --> 01:24:10,060
基于你的测量，

1311
01:24:10,060 --> 01:24:13,150
你要确保锁真的争用，

1312
01:24:13,150 --> 01:24:14,620
在你开始重新设计之前。

1313
01:24:15,480 --> 01:24:18,060
最后，也可以使用竞争检测器。

1314
01:24:20,460 --> 01:24:25,950
这些竞争检测器工具会发现问题或竞态条件，

1315
01:24:25,950 --> 01:24:27,390
因为你把锁放错了，

1316
01:24:27,390 --> 01:24:29,370
或者你将 acquire 和 release 放错了，

1317
01:24:29,370 --> 01:24:32,070
而实际上，你还有竞争。

1318
01:24:32,770 --> 01:24:34,900
好的，这是一个关于锁的快速介绍，

1319
01:24:34,960 --> 01:24:36,670
我们将会谈论更多关于锁的话题，

1320
01:24:36,670 --> 01:24:38,650
在本学期的剩余课程中，

1321
01:24:38,650 --> 01:24:39,340
它会出现，

1322
01:24:39,340 --> 01:24:42,160
最后，我们将讨论有关无锁编程的问题，

1323
01:24:42,460 --> 01:24:44,950
看看在内核中是如何做到这一点的。

1324
01:24:45,580 --> 01:24:47,380
好的，我在这里停止，

1325
01:24:47,740 --> 01:24:50,380
所以，任何必须去别的地方的人可以去，

1326
01:24:50,380 --> 01:24:51,730
但是，如果你还有什么问题，

1327
01:24:51,730 --> 01:24:53,650
请随时提出来。

1328
01:24:54,820 --> 01:24:55,990
我们在聊天中有个问题，

1329
01:24:56,260 --> 01:24:58,930
fence 指令是不是没有必要，

1330
01:24:58,930 --> 01:25:02,740
因为 amoswap 指令可以具有获取释放顺序。

1331
01:25:04,060 --> 01:25:08,080
是的，好的，所以有两件事，

1332
01:25:08,170 --> 01:25:12,430
sync 指令同时为编译器和硬件。

1333
01:25:25,000 --> 01:25:27,010
是的，我马上要超过工作时间了，

1334
01:25:27,010 --> 01:25:28,450
但我认为还有更多的问题。

1335
01:25:28,450 --> 01:25:30,880
如何只为编译器做这件事呢？

1336
01:25:31,480 --> 01:25:35,350
编译器知道正在编译的是哪个体系结构，

1337
01:25:35,860 --> 01:25:39,490
所以我们知道它什么时候必须确保合适的栅栏，

1338
01:25:39,760 --> 01:25:41,800
无论运行在哪种体系结构上，

1339
01:25:41,800 --> 01:25:43,990
不管是哪种内存一致性模型。

1340
01:25:44,740 --> 01:25:46,840
所以这会引起更复杂的讨论，

1341
01:25:46,840 --> 01:25:49,810
就是每个硬件都有一个内存模型，

1342
01:25:50,140 --> 01:25:53,230
编译器决定，

1343
01:25:53,230 --> 01:25:56,080
给特定架构的内存模型，

1344
01:25:56,080 --> 01:25:57,790
它可以做什么，不能做什么。

1345
01:25:59,440 --> 01:26:01,150
我想我的问题是，

1346
01:26:01,210 --> 01:26:04,360
fence 指令只有在这种情况是没有必要的，

1347
01:26:04,360 --> 01:26:09,310
如果你调用 amoswap.w.rl ，

1348
01:26:09,400 --> 01:26:19,290
放在 sync 中，这有一个 sync ，

1349
01:26:19,290 --> 01:26:23,910
但是编译器排序，然后。

1350
01:26:24,460 --> 01:26:25,120
是的。

1351
01:26:25,330 --> 01:26:28,240
内存排序和无序。

1352
01:26:28,690 --> 01:26:29,200
是的。

1353
01:26:29,230 --> 01:26:31,300
机器也使用 fence 指令，

1354
01:26:31,300 --> 01:26:35,230
fence 指令只在执行 .rl 的情况下是没有必要的，

1355
01:26:35,230 --> 01:26:37,180
看起来它不会检测到这一点，

1356
01:26:37,180 --> 01:26:38,230
那么你怎么做的，

1357
01:26:38,530 --> 01:26:42,340
所以编译器最终强制排序，

1358
01:26:42,670 --> 01:26:46,840
但你已经使用[]指令覆盖了它。

1359
01:26:46,870 --> 01:26:49,660
是的，好问题，

1360
01:26:49,690 --> 01:26:53,470
更复杂的需求实现会是，

1361
01:26:53,470 --> 01:26:59,900
比如 RISC-V 专门的 acquire 和 release 实现，

1362
01:26:59,900 --> 01:27:02,390
可能比我们做的事情更复杂，

1363
01:27:02,390 --> 01:27:05,150
使用 fence 指令是一个粗粒度的实现。

1364
01:27:05,800 --> 01:27:10,570
但是这有点复杂，

1365
01:27:10,600 --> 01:27:14,620
是的，如果你对这个感兴趣，

1366
01:27:14,650 --> 01:27:20,110
RISC-V 的内存模型非常复杂，

1367
01:27:20,110 --> 01:27:25,120
如果你看一下操作手册中的非特权指令，

1368
01:27:25,120 --> 01:27:28,810
有一整章来专门介绍内存排序，

1369
01:27:28,810 --> 01:27:30,370
告诉你应该做什么。

1370
01:27:30,370 --> 01:27:34,410
在特定情况下，编译器应该怎么做。

1371
01:27:37,760 --> 01:27:40,640
所以，你的意思是编译器会注意到这一事实，

1372
01:27:40,640 --> 01:27:43,730
我们只是把汇编指令放在这里，

1373
01:27:43,760 --> 01:27:47,030
而且它本身不会对任何内存访问进行重新排序。

1374
01:27:47,120 --> 01:27:52,910
抱歉， synchronize ，这个同步库函数是库函数，

1375
01:27:52,910 --> 01:27:54,530
它可以通过不同的方式实现。

1376
01:27:55,030 --> 01:27:57,460
这是一种实现。

1377
01:27:58,440 --> 01:28:00,810
并且库函数由编译器提供。

1378
01:28:02,610 --> 01:28:06,300
但是编译器有没有进行优化的选项，

1379
01:28:06,300 --> 01:28:09,450
它可以移动加载和存储指令。

1380
01:28:10,560 --> 01:28:12,120
是的，编译器有。

1381
01:28:12,480 --> 01:28:16,080
那么如何在不使用 fence 指令时防止这种情况发生，

1382
01:28:16,110 --> 01:28:17,040
我想知道这个。

1383
01:28:17,040 --> 01:28:20,520
我想我说的是，

1384
01:28:20,800 --> 01:28:23,680
也许我想说的是，

1385
01:28:24,470 --> 01:28:28,070
synchronized 告诉编译器和硬件，

1386
01:28:28,070 --> 01:28:30,860
但是编译器可以实现不同的 __sync_synchronize ，

1387
01:28:30,860 --> 01:28:32,660
它知道它不能移动东西，

1388
01:28:32,900 --> 01:28:35,390
但它没有 RISC-V 上的发布和 fence 指令，

1389
01:28:35,390 --> 01:28:38,450
它知道它以一种特殊的方式在 RISC-V 上运行。

1390
01:28:42,060 --> 01:28:46,530
但是 RISC-V 内存模型还不够吗，

1391
01:28:46,530 --> 01:28:50,160
机器可以重组东西，

1392
01:28:50,160 --> 01:28:52,800
所以你是否需要 acquire ，

1393
01:28:53,410 --> 01:28:55,150
整个[点]都有。

1394
01:28:55,210 --> 01:29:02,130
好的，还有比 __sync_synchronize 更复杂的接口，

1395
01:29:03,120 --> 01:29:07,650
这给了编译器编写者更多的自由，

1396
01:29:07,650 --> 01:29:08,730
我们可以得到编译器，

1397
01:29:08,730 --> 01:29:11,700
并将编译器和处理器解耦。

1398
01:29:13,000 --> 01:29:15,340
比如，我想这里有一个标记可以传入，

1399
01:29:15,340 --> 01:29:19,240
有一个 release 一致性同步。

1400
01:29:19,970 --> 01:29:22,550
我不知道细节，

1401
01:29:22,550 --> 01:29:23,990
我不知道，

1402
01:29:23,990 --> 01:29:25,100
但你可以查一下这个，

1403
01:29:25,400 --> 01:29:27,680
这是粗粒度接口，

1404
01:29:27,680 --> 01:29:30,500
更细粒度的接口，让程序员有更多的控制权。

1405
01:29:31,300 --> 01:29:33,250
好的，谢谢。

1406
01:29:35,660 --> 01:29:38,240
我有一个问题，

1407
01:29:38,270 --> 01:29:44,180
如果有多个线程和一个处理器，

1408
01:29:44,210 --> 01:29:50,060
[争论]的方式与我们对多处理器的争论是否相同。

1409
01:29:50,920 --> 01:29:55,210
你能重复一下问题吗，只是确认一下。

1410
01:29:56,700 --> 01:29:57,870
所以我们没有，

1411
01:29:58,140 --> 01:30:01,200
我想我们并没有谈到多线程，

1412
01:30:01,200 --> 01:30:03,870
我们主要讨论的是多 CPU ，

1413
01:30:04,140 --> 01:30:07,650
所以对于多线程来说，

1414
01:30:07,740 --> 01:30:13,720
我想解决方案与拥有多个 CPU 时的解决方案相同，

1415
01:30:13,720 --> 01:30:16,090
比如，那里有没有同样的参数。

1416
01:30:16,480 --> 01:30:17,860
或多或少，

1417
01:30:17,890 --> 01:30:20,650
至少在理论上是正确的思考方式，

1418
01:30:20,710 --> 01:30:22,930
所以你有多个线程，

1419
01:30:22,960 --> 01:30:24,490
但是只有一个 CPU ，

1420
01:30:24,880 --> 01:30:27,280
还是这样情况，你希望确保，

1421
01:30:27,280 --> 01:30:30,910
以原子方式执行某些内核代码序列。

1422
01:30:31,550 --> 01:30:35,600
所以，你仍然需要有一个临界区间的概念。

1423
01:30:36,100 --> 01:30:39,760
你可能不需要显式的锁或释放，

1424
01:30:39,760 --> 01:30:42,640
但是你确实需要一种打开和关闭中断的方法，

1425
01:30:42,640 --> 01:30:43,810
在一段代码中。

1426
01:30:44,670 --> 01:30:48,360
所以，如果你查看较旧的操作系统内核，

1427
01:30:48,360 --> 01:30:52,350
它们通常在内核中没有真正的锁获取，

1428
01:30:52,350 --> 01:30:54,660
因为它们假设在一个处理器上运行，

1429
01:30:54,810 --> 01:30:56,610
但是它们确实有像锁这样的东西，

1430
01:30:56,610 --> 01:31:01,120
要打开和关闭中断。

1431
01:31:03,460 --> 01:31:04,660
好的，我明白了，

1432
01:31:04,960 --> 01:31:07,330
我的另一个问题是，

1433
01:31:07,420 --> 01:31:14,860
在带有 UART 图片和缓冲区的的幻灯片上。

1434
01:31:17,570 --> 01:31:18,800
是的，是不是，

1435
01:31:18,800 --> 01:31:19,790
是的，就是那个，

1436
01:31:19,820 --> 01:31:25,790
是不是一直都是这样的，读在后面，

1437
01:31:25,820 --> 01:31:26,930
我不明白这个。

1438
01:31:27,170 --> 01:31:28,730
是的，好的。

1439
01:31:29,400 --> 01:31:30,690
所以这个到显示器，

1440
01:31:30,690 --> 01:31:33,480
这是字符序列，

1441
01:31:33,480 --> 01:31:34,800
要到显示器。

1442
01:31:36,730 --> 01:31:42,190
写入者增加更多字符，

1443
01:31:42,190 --> 01:31:45,220
所以，写入者走这条路，

1444
01:31:45,220 --> 01:31:47,980
读取者跟随写入者，

1445
01:31:48,340 --> 01:31:51,610
因为你不能打印尚未放入缓冲区的字符。

1446
01:31:52,260 --> 01:31:58,620
UART 把东西给显示器，

1447
01:32:02,340 --> 01:32:07,710
开始将这个插槽中的第一个字符放到显示器上，

1448
01:32:08,100 --> 01:32:11,040
同时， printf 进入，

1449
01:32:11,070 --> 01:32:12,990
它们在这里放更多的字符，

1450
01:32:13,020 --> 01:32:15,030
所以写指针在这里，

1451
01:32:15,300 --> 01:32:17,310
然后当显示了一个字符，

1452
01:32:17,490 --> 01:32:19,860
然后 UART 将这个指针向上移动，

1453
01:32:20,340 --> 01:32:21,540
以显示下一个字符。

1454
01:32:22,430 --> 01:32:26,900
UART 总是有点落后于写入者，

1455
01:32:26,930 --> 01:32:28,820
直到它赶上，

1456
01:32:28,820 --> 01:32:31,070
然后 r 和 w 相同，

1457
01:32:31,070 --> 01:32:34,220
在这一点上，意味着缓冲区中不再有字符。

1458
01:32:35,920 --> 01:32:38,800
哦，好的，我明白了。

1459
01:32:38,800 --> 01:32:40,060
好的，非常感谢。

1460
01:32:40,420 --> 01:32:40,900
不用谢。

1461
01:32:42,850 --> 01:32:43,780
还有什么问题吗？

1462
01:32:48,990 --> 01:32:49,980
只有我们在这里。

1463
01:32:50,580 --> 01:32:51,060
好的。

1464
01:32:53,680 --> 01:32:55,510
所有人，再见。

