1
00:00:00,000 --> 00:00:02,430
对于已经登录的用户，

2
00:00:03,100 --> 00:00:07,180
好奇你在 traps 实验的经历。

3
00:00:08,200 --> 00:00:12,490
如果你已经开始了懒分配实验，进展如何。

4
00:00:13,810 --> 00:00:18,670
[]是不是比页表实验轻松。

5
00:00:20,580 --> 00:00:23,400
Andrew You ，你有什么想说的吗？

6
00:00:32,000 --> 00:00:34,040
我认为 traps 实验没问题，

7
00:00:35,030 --> 00:00:38,620
我只是想确认一下，

8
00:00:38,980 --> 00:00:43,270
我使用 trampoline 页面有点烦人。

9
00:00:43,720 --> 00:00:44,170
是的。

10
00:00:44,410 --> 00:00:47,560
但是一旦我弄清楚了，然后它就可以工作了。

11
00:00:47,770 --> 00:00:50,140
好的，是的，实验的整个目标是，

12
00:00:50,140 --> 00:00:57,140
把 trap 处理入口和出口完全暴露给你。

13
00:01:01,990 --> 00:01:05,440
Amir 呢，你在 traps 实验的经历如何。

14
00:01:08,180 --> 00:01:17,150
我觉得 traps 实验很好，比页表实验易于管理。

15
00:01:17,620 --> 00:01:23,410
我注意到有机会更精巧地实现的某些方面，这很好，这真是太好了

16
00:01:23,890 --> 00:01:28,750
到目前为止，懒分配实验的调试情况还不错。

17
00:01:29,560 --> 00:01:32,170
但在我看来，两者都比页表要好。

18
00:01:32,410 --> 00:01:34,210
很高兴听到你这么说，

19
00:01:34,240 --> 00:01:35,470
我相信你也很高兴听到这个，

20
00:01:35,470 --> 00:01:37,060
但我也很高兴听到你这么说。

21
00:01:40,480 --> 00:01:42,220
Timmy 怎么样？

22
00:01:44,180 --> 00:01:50,330
是的，前两个实验比页表要好得多。

23
00:01:51,950 --> 00:01:57,480
我想，对于懒分配实验来说最难的是，

24
00:01:57,480 --> 00:02:01,810
读写和所有的东西，

25
00:02:01,900 --> 00:02:04,870
但在我看来并不是那么糟糕。

26
00:02:05,800 --> 00:02:06,280
好的。

27
00:02:11,480 --> 00:02:12,380
Catherine 怎么样，

28
00:02:13,010 --> 00:02:19,180
对你来说， traps 实验或懒分配实验与页表实验相比较。

29
00:02:33,340 --> 00:02:35,380
你在吗，Katherine ， Katherine Weeks 。

30
00:02:36,600 --> 00:02:37,890
你好，我做得很好，

31
00:02:37,920 --> 00:02:40,320
抱歉，我不知道你在跟哪个 Catherine 说话，

32
00:02:40,320 --> 00:02:41,370
我想大概只有 20 个人，

33
00:02:41,370 --> 00:02:44,160
所以你可能不太可能还有另一个。

34
00:02:45,420 --> 00:02:46,350
我做得很好。

35
00:02:46,950 --> 00:02:51,030
很好，所以这个实验比页表实验少了很多痛苦.

36
00:02:51,030 --> 00:02:52,950
是的，绝对不会那么痛苦。

37
00:02:55,420 --> 00:02:55,960
太棒了。

38
00:02:56,260 --> 00:02:56,740
嗯。

39
00:02:57,470 --> 00:02:58,310
嗯。

40
00:02:59,420 --> 00:03:06,620
页表后面的那个 traps （实验），绝对简单的多。

41
00:03:09,300 --> 00:03:11,400
好的，很高兴听到你们这么说，

42
00:03:11,400 --> 00:03:13,680
我只想做个非正式的民意测验，

43
00:03:14,480 --> 00:03:17,030
页表实验比我们预想的要难，

44
00:03:17,090 --> 00:03:20,180
所以，这些更好。

45
00:03:20,810 --> 00:03:24,440
好的，那么我们要做什么呢。

46
00:03:24,800 --> 00:03:29,480
不管你在哪里，欢迎收看 6.S081 的下一节课，

47
00:03:29,690 --> 00:03:32,630
今天的主题是关于中断，

48
00:03:32,690 --> 00:03:35,780
在开始讨论中断之前，

49
00:03:35,960 --> 00:03:38,420
我想分享一点东西，

50
00:03:38,420 --> 00:03:39,740
我想说的是，

51
00:03:39,740 --> 00:03:42,350
上个星期，我没能抽出时间来做这件事。

52
00:03:42,780 --> 00:03:44,730
你可能会感兴趣的。

53
00:03:47,840 --> 00:03:50,600
让我看下，在这里找到我正确的屏幕，

54
00:03:50,870 --> 00:03:55,100
所以在这里，看我屏幕的左下角，

55
00:03:55,370 --> 00:04:00,650
我通过对话机登录到 Athena 。

56
00:04:01,180 --> 00:04:04,300
我有几件事想谈谈，

57
00:04:04,390 --> 00:04:08,830
在真正的操作系统中，内存是如何使用的。

58
00:04:09,540 --> 00:04:12,120
因为我们上周谈了很多，特别是在课程的最后，

59
00:04:12,120 --> 00:04:17,250
很多问题关于逐出页面，寻找空闲内存之类的东西。

60
00:04:17,990 --> 00:04:20,750
这是一台 Athena 机器，

61
00:04:20,810 --> 00:04:22,640
你要注意的是，

62
00:04:22,640 --> 00:04:27,410
如果你看一下内存这一行，它告诉你有多少，

63
00:04:27,590 --> 00:04:31,190
运行的程序是 top ，可能你们很多人都用过它，

64
00:04:31,550 --> 00:04:34,460
你可以看到一台机器里有多少内存，

65
00:04:34,460 --> 00:04:38,120
如你所见，这台机器里有很多内存。

66
00:04:38,520 --> 00:04:45,800
如果你仔细看一下，实际上大部分都是在使用的。

67
00:04:45,830 --> 00:04:50,180
很大一部分内存实际上并没有被应用程序使用，

68
00:04:50,180 --> 00:04:51,830
而是由缓冲器高速缓存使用。

69
00:04:52,410 --> 00:04:54,900
这在操作系统中很常见，

70
00:04:54,900 --> 00:04:58,980
你不想让你的内存无所事事，

71
00:04:59,190 --> 00:05:00,840
你可能把它用在有用的东西上，

72
00:05:01,020 --> 00:05:06,060
在这种情况下，它的很大一部分用于缓冲区缓存。

73
00:05:06,790 --> 00:05:10,390
一些内存是空闲的，不是很多，

74
00:05:10,780 --> 00:05:14,980
在一台机器中总内存的一小部分，

75
00:05:14,980 --> 00:05:18,580
这是一个非常常见的情况，像大多数操作系统一样。

76
00:05:19,080 --> 00:05:22,590
我们在任何时刻都几乎没有可用的内存。

77
00:05:23,620 --> 00:05:28,480
这意味着，如果应用程序或内核需要一些内存，

78
00:05:28,600 --> 00:05:30,250
我们得扔掉一些东西，

79
00:05:30,370 --> 00:05:34,660
也许这几页就足够了，

80
00:05:34,660 --> 00:05:36,460
但在某种情况下，它需要大量的空闲内存，

81
00:05:36,520 --> 00:05:40,360
它会要求从应用程序或缓冲器告诉缓存中中逐出某些内容。

82
00:05:41,380 --> 00:05:44,710
所以这里的主要观点是，

83
00:05:44,710 --> 00:05:46,210
当内核分配内存时，

84
00:05:46,210 --> 00:05:48,370
通常不是一个便宜的操作，

85
00:05:48,370 --> 00:05:52,170
因为没有太多空闲内存可用。

86
00:05:53,270 --> 00:05:55,010
另一件有趣的事情是，

87
00:05:55,010 --> 00:06:01,160
我根据驻留内存量对 top 的输出进行排序。

88
00:06:01,660 --> 00:06:03,760
所以你看的每一行，

89
00:06:03,760 --> 00:06:08,020
对于每个进程，这是地址空间的大小，

90
00:06:08,290 --> 00:06:11,470
然后，下一行告诉你实际使用了多少内存，

91
00:06:11,470 --> 00:06:12,760
比如物理内存量，

92
00:06:12,760 --> 00:06:16,850
地址空间的一小部分在物理内存中，

93
00:06:17,240 --> 00:06:21,410
正如你看到的，它通常比地址空间小得多，

94
00:06:21,440 --> 00:06:27,260
所以我们最后谈到的虚拟内存提供的技巧，很酷的想法，

95
00:06:27,410 --> 00:06:30,140
在这里使用，比如按需调页，

96
00:06:30,380 --> 00:06:35,330
共享列是共享页面，来自共享库中，

97
00:06:35,600 --> 00:06:42,580
你大体上可以看到，常驻内存比虚拟地址空间小得多。

98
00:06:43,740 --> 00:06:46,170
也许还有几件有趣的事需要注意，

99
00:06:46,200 --> 00:06:49,410
看着这台机器，负载很低，

100
00:06:49,440 --> 00:06:53,100
即使有 102 个用户登录。

101
00:06:53,620 --> 00:07:00,310
你会看到有很多进程， 950 左右，

102
00:07:00,550 --> 00:07:04,690
注意机器已开机多长时间， 249 天，

103
00:07:05,080 --> 00:07:09,340
你的 xv6 内核可能根本不会运行那么长时间。

104
00:07:12,780 --> 00:07:15,000
好的，这就是，关于这个有什么问题吗，

105
00:07:15,000 --> 00:07:19,100
主要的一点是，大多数内存正在使用，

106
00:07:19,100 --> 00:07:23,030
并且常驻内存通常比虚拟地址空间小得多。

107
00:07:27,420 --> 00:07:31,020
你可以自己运行这个，如果你想看看是怎么发生的。

108
00:07:33,360 --> 00:07:34,080
有什么问题吗？

109
00:07:35,750 --> 00:07:39,230
您可以看到 6.S081 学生中的一些人登录，

110
00:07:39,230 --> 00:07:41,630
如果你看一下，会看到很多 QEMU 在运行。

111
00:07:43,410 --> 00:07:46,250
好的，没有问题。

112
00:07:46,280 --> 00:07:49,970
让我回到今天的话题，中断。

113
00:07:52,270 --> 00:07:56,800
基本的想法是很直接的，

114
00:07:56,830 --> 00:07:59,350
我们想要实现的是，

115
00:07:59,970 --> 00:08:07,950
某种情况下，硬件需要关注。

116
00:08:10,800 --> 00:08:12,690
从网络传入数据包，

117
00:08:12,720 --> 00:08:17,760
互联网网卡产生中断，

118
00:08:17,760 --> 00:08:22,920
用户在键盘上键入一个键，键盘会产生中断。

119
00:08:23,490 --> 00:08:26,190
软件要做什么，

120
00:08:26,520 --> 00:08:29,550
如果软件必须保存它的工作，

121
00:08:29,580 --> 00:08:31,410
不管它现在在做什么，

122
00:08:32,990 --> 00:08:36,570
把它放在一边，进程中断，

123
00:08:41,660 --> 00:08:45,430
然后恢复到正在进行的工作中。

124
00:08:51,020 --> 00:08:59,990
保存和恢复与我们之前看到的机制非常相似，

125
00:08:59,990 --> 00:09:08,950
即用于系统调用，还有 traps ，比如页面错误，

126
00:09:09,040 --> 00:09:11,050
它们都使用相同的机制。

127
00:09:18,920 --> 00:09:24,710
所以在这个意义上，中断与 traps 或系统调用没有什么不同，

128
00:09:24,710 --> 00:09:27,620
但有几件事让它们有点不同，

129
00:09:27,620 --> 00:09:29,780
以及为什么我们要花一节课来讲解它们。

130
00:09:30,360 --> 00:09:33,450
所以有三个东西组成中断，

131
00:09:34,740 --> 00:09:38,850
与系统调用和异常略有不同。

132
00:09:38,850 --> 00:09:42,480
第一，用一个更好的词来说，它们是异步的，

133
00:09:46,310 --> 00:09:50,030
我的意思是，系统调用，

134
00:09:50,030 --> 00:09:54,740
当硬件生成中断时，中断处理程序运行，

135
00:09:54,980 --> 00:09:59,900
中断处理程序可能与 CPU 上当前运行的进程无关。

136
00:10:00,420 --> 00:10:02,790
所以，与进行系统调用的情况不同，

137
00:10:02,790 --> 00:10:05,610
当系统调用发生时，你跳入内核，

138
00:10:05,760 --> 00:10:08,700
然后我们在调用进程的上下文中运行。

139
00:10:09,220 --> 00:10:11,080
而对于中断则不是这样，

140
00:10:11,170 --> 00:10:16,960
它们可能与你正在 CPU 中运行的进程完全无关，

141
00:10:16,960 --> 00:10:19,990
可能与中断处理程序无关，甚至不是它调用的。

142
00:10:21,000 --> 00:10:22,260
所以那是不同的。

143
00:10:22,380 --> 00:10:28,840
第二，到目前为止，我们看到的并发性比以往任何时候都要多。

144
00:10:28,840 --> 00:10:35,640
实际上，这是讨论并发性的开始，

145
00:10:35,790 --> 00:10:38,730
我们将在周三的课程中详细讨论这个问题，

146
00:10:38,730 --> 00:10:45,030
基本的观点是，CPU 和生成的设备是并行运行的，

147
00:10:45,060 --> 00:10:47,220
你知道有网卡的 UART ，

148
00:10:47,220 --> 00:10:50,850
只是做它的事情，从网络中挑选数据包，

149
00:10:51,060 --> 00:10:52,860
然后在某一时刻产生中断。

150
00:10:53,240 --> 00:10:56,330
同时，CPU 也在运行，也在做自己的事情，

151
00:10:56,360 --> 00:11:00,650
所以，在设备和 CPU 之间，我们有真正的并行性，

152
00:11:00,650 --> 00:11:04,190
我们必须管理这种并行性，我们稍后会看到。

153
00:11:05,450 --> 00:11:10,280
最后，我将主要关注外部设备，

154
00:11:10,280 --> 00:11:13,400
比如网卡和 UART ，这些必须被编程。

155
00:11:21,310 --> 00:11:24,850
每个设备都有自己的编程手册，

156
00:11:24,850 --> 00:11:30,400
以 RISC-V 同样的方式，包含指令和寄存器作用，RISC-V有说明书和哪些寄存器做什么的手册，

157
00:11:30,760 --> 00:11:34,030
每个设备都有类似的手册，

158
00:11:34,270 --> 00:11:39,940
描述它有什么寄存器，你可以遵循哪些操作，

159
00:11:39,970 --> 00:11:43,600
设备对于读取和写入控制寄存器的回应。

160
00:11:44,380 --> 00:11:51,850
不幸的是，设备手册通常不如 RISC-V 手册清楚，

161
00:11:52,030 --> 00:11:55,780
这使得复杂的编程变得更加复杂。

162
00:11:56,820 --> 00:12:00,300
我在这节课上要做的其实很简单，

163
00:12:00,510 --> 00:12:09,990
讨论 shell 提示符（$）是如何出现的，

164
00:12:09,990 --> 00:12:11,940
然后如果你键入 ls ，

165
00:12:12,240 --> 00:12:15,810
这些字符是怎么读入的，

166
00:12:15,810 --> 00:12:17,760
然后显示在控制台中，

167
00:12:17,790 --> 00:12:21,000
实际上，基本上剩下的课程都是关于这三个字符的，

168
00:12:21,880 --> 00:12:27,130
以及实现这一目标所必需的的所有机制。

169
00:12:28,550 --> 00:12:32,630
到目前为止，在我继续深入讨论之前，有什么问题吗？

170
00:12:38,470 --> 00:12:40,210
好的。

171
00:12:41,850 --> 00:12:45,930
所以可能要问的第一个问题是，中断是从哪里来的。

172
00:13:00,330 --> 00:13:05,090
我们这节课将主要关注外部中断，

173
00:13:05,090 --> 00:13:07,490
不是计时器中断或软件中断，

174
00:13:07,760 --> 00:13:11,720
外部中断来自电路板上的设备，

175
00:13:11,810 --> 00:13:18,170
这是一块 SiFive 电路板，就是 QEMU 模拟的那个，

176
00:13:18,170 --> 00:13:20,900
这里有一些小的改动，

177
00:13:21,140 --> 00:13:24,380
我们看到，你在这块板上看到，

178
00:13:24,440 --> 00:13:27,080
那里有很多不同的设备，

179
00:13:27,350 --> 00:13:28,850
可以连接到这块板上，

180
00:13:29,030 --> 00:13:31,360
这里是以太网连接器，

181
00:13:31,540 --> 00:13:35,860
这是 MicroUSB，在那里，

182
00:13:36,100 --> 00:13:38,320
这是 MicroSD 卡，

183
00:13:38,620 --> 00:13:41,290
这是重置按钮，

184
00:13:41,290 --> 00:13:46,810
这是从这些设备到 CPU 的各种线路。

185
00:13:47,500 --> 00:13:49,150
这节课的大部分内容是，

186
00:13:49,150 --> 00:13:56,440
理解当设备发生中断时， CPU 上会发生什么，

187
00:13:56,440 --> 00:13:59,080
以及如何从设备读取和写入信息。

188
00:13:59,760 --> 00:14:06,050
我相信下面的两个针脚，在这个扩展接头上，

189
00:14:06,050 --> 00:14:12,690
我想其中一个是用来传输的 UART Tx ，

190
00:14:12,720 --> 00:14:20,180
另一个是用来接收的 UART0 Re 。

191
00:14:21,690 --> 00:14:23,820
<---我认为它实际上与两边都有联系，

192
00:14:23,820 --> 00:14:26,040
微型USB以及通过该延长线，--->

193
00:14:26,040 --> 00:14:31,870
我认为 UART 芯片本身，你可能在那边的芯片里。

194
00:14:37,720 --> 00:14:44,320
好的，所以电路板上有很多线到 CPU ，

195
00:14:44,620 --> 00:14:48,070
我们放大一点，详细看看 CPU ，

196
00:14:48,620 --> 00:14:56,640
电路板使用 SiFive 文档中的方案，

197
00:14:56,640 --> 00:15:00,540
或者电路板的处理器使用 RISC-V 处理器，

198
00:15:00,930 --> 00:15:02,940
我们之前看过这个，

199
00:15:03,210 --> 00:15:08,220
看这里，右边是设备，

200
00:15:08,220 --> 00:15:09,540
这里是 UART0 ，

201
00:15:09,870 --> 00:15:15,690
我们知道 UART0 内存映射到物理地址空间中的某个位置。

202
00:15:16,140 --> 00:15:18,720
这边的所有 DRAM ，

203
00:15:18,720 --> 00:15:22,410
我们知道 DRAM 位于 0x8000 之上，

204
00:15:22,410 --> 00:15:25,980
而在 0x8000 之下，是不同的设备。

205
00:15:26,610 --> 00:15:33,060
基本上对那些物理地址使用 load 和 store 指令，

206
00:15:33,060 --> 00:15:34,500
我们实际上可以对 UART 进行编程，

207
00:15:34,560 --> 00:15:36,690
稍后会更详细地了解这一点。

208
00:15:37,800 --> 00:15:40,710
所有设备都可以到达处理器，

209
00:15:40,830 --> 00:15:46,070
真正发生的是这个平台级别的中断间控制器，

210
00:15:46,070 --> 00:15:47,810
简称为 PLIC ，

211
00:15:48,430 --> 00:15:54,970
是对外部设备中断的管理者。

212
00:15:55,670 --> 00:15:57,590
所以如果我们再放大一点，

213
00:15:57,980 --> 00:16:04,760
这是片上设备 PLIC 的示意图，

214
00:16:04,760 --> 00:16:10,460
这里看到，有 53 条中断线路来自不同的设备。

215
00:16:10,980 --> 00:16:14,250
可能，中断线路上的设备，进入 PLIC ，

216
00:16:14,580 --> 00:16:16,890
然后 PLIC 路由这些中断。

217
00:16:24,410 --> 00:16:27,050
举个例子，这取决于，

218
00:16:27,050 --> 00:16:29,030
所以这是我们的核心，

219
00:16:29,970 --> 00:16:34,380
在这里，我们运行的是三个内核，

220
00:16:34,380 --> 00:16:37,980
PLIC 是可以编程的，

221
00:16:38,130 --> 00:16:43,080
所以 PLIC 将中断交给这些核心中的一个或者第一个，

222
00:16:43,080 --> 00:16:45,330
它可以获得中断，

223
00:16:45,330 --> 00:16:47,040
而且有一些灵活性。

224
00:16:47,760 --> 00:16:50,550
如果此时没有一个核心可以接受中断，

225
00:16:50,550 --> 00:16:52,020
比如它们禁用了中断，

226
00:16:52,020 --> 00:16:54,300
因为他们在处理另一个中断，

227
00:16:54,390 --> 00:16:57,390
PLIC 将持有这个中断，

228
00:16:57,390 --> 00:17:00,930
直到有处理器可以处理中断。

229
00:17:02,130 --> 00:17:06,330
所以 PLIC 有一些内部状态来记录这些。

230
00:17:06,930 --> 00:17:09,000
如果你看一下文档，

231
00:17:09,000 --> 00:17:11,460
PLIC 中真正发生的是，

232
00:17:11,460 --> 00:17:13,620
表示有一个中断，等待其中一个核心，声称拥有它，

233
00:17:17,850 --> 00:17:21,720
所以这告诉 PLIC 不要给任何其他核心，

234
00:17:21,870 --> 00:17:24,060
一旦核心完全完成，

235
00:17:24,060 --> 00:17:26,370
它会说好的，我完成了这个中断，

236
00:17:26,370 --> 00:17:28,620
然后 PLIC 会，

237
00:17:28,920 --> 00:17:33,000
通知 PLIC 可以忘记这个中断。

238
00:17:35,770 --> 00:17:37,000
有任何关于这个的问题吗？

239
00:17:37,730 --> 00:17:42,220
这是 RISC-V 的内部中断结构。

240
00:17:44,140 --> 00:17:47,620
是的，所以当每个核心持有 PLIC 时，

241
00:17:47,650 --> 00:17:51,670
PLIC 是否有某种执行机制来确保公平。

242
00:17:52,520 --> 00:17:54,980
这一切都取决于内核，

243
00:17:55,040 --> 00:17:58,640
以任何它想要的方式对 PLIC 进行编程。

244
00:17:59,330 --> 00:18:05,120
PLIC 不是真的选择传送中断服务，[写入它们]，

245
00:18:05,120 --> 00:18:09,980
但是从内核程序获取[]，将中断传递到哪里，等等。

246
00:18:10,460 --> 00:18:12,680
实际上，有优先级的中断，

247
00:18:12,740 --> 00:18:16,700
内核可以决定哪个中断比另一个中断更重要，

248
00:18:16,700 --> 00:18:18,320
这里有很大的灵活性。

249
00:18:26,370 --> 00:18:28,230
关于硬件的任何其他问题？

250
00:18:33,930 --> 00:18:34,560
好的。

251
00:18:37,640 --> 00:18:39,380
好的，这就是它的硬件方面，

252
00:18:39,470 --> 00:18:43,370
让我们从高层次上谈一下软件方面的问题。

253
00:18:44,360 --> 00:18:50,150
通常情况下，管理设备的代码称为驱动程序。

254
00:19:00,230 --> 00:19:04,730
你知道，基本上就是代码，

255
00:19:04,760 --> 00:19:09,140
通常内核查看 C 代码，

256
00:19:09,260 --> 00:19:13,580
在 xv6 中，所有的驱动程序都在内核内部，

257
00:19:13,820 --> 00:19:19,800
这些用于管理的代码就是驱动程序，

258
00:19:20,070 --> 00:19:21,810
都在内核内部。

259
00:19:22,580 --> 00:19:25,880
所以我们今天来看一下，

260
00:19:25,880 --> 00:19:29,870
你知道 uart.c 是 UART 芯片的驱动程序。

261
00:19:30,860 --> 00:19:37,100
如果你看一下代码的内部结构，

262
00:19:37,100 --> 00:19:40,670
大多数驱动都有一种结构。

263
00:19:41,350 --> 00:19:42,640
我来画一下，

264
00:19:42,940 --> 00:19:45,670
不是作为地址空间，不是使用地址空间，

265
00:19:45,670 --> 00:19:47,530
但通常情况下，当人们谈论驱动时，

266
00:19:47,620 --> 00:19:51,030
会有底部和顶部。

267
00:19:54,500 --> 00:19:57,590
一般底部是中断处理程序。

268
00:20:03,080 --> 00:20:05,510
所以中断处理程序，当中断进入时，

269
00:20:05,540 --> 00:20:11,000
如果处理器， CPU 启用了中断，中断将会触发，

270
00:20:11,000 --> 00:20:13,610
处理器随后会看到，

271
00:20:13,610 --> 00:20:17,240
调用该设备的中断处理程序，

272
00:20:17,330 --> 00:20:19,070
就是调用这里的代码。

273
00:20:19,910 --> 00:20:27,080
并且中断处理程序运行在，任何特定进程的任意上下文中，

274
00:20:27,080 --> 00:20:31,040
就是引发中断的进程。

275
00:20:32,240 --> 00:20:35,690
驱动程序的顶部是，

276
00:20:35,690 --> 00:20:39,500
是用户进程或者其他内核要调用的，

277
00:20:39,500 --> 00:20:41,570
比如 console 的例子，

278
00:20:41,570 --> 00:20:44,460
UART 有读写接口，

279
00:20:46,320 --> 00:20:53,260
是更高级别的代码调用的，

280
00:20:53,680 --> 00:20:57,400
通常情况下，在驱动程序中经常会有一些队列，

281
00:20:57,610 --> 00:21:05,890
顶部代码调用，将字符放入队列中，

282
00:21:05,890 --> 00:21:08,500
而中断处理程序放入或，

283
00:21:08,890 --> 00:21:10,360
根据发送或接收，

284
00:21:10,360 --> 00:21:11,980
如果是接受，

285
00:21:11,980 --> 00:21:17,100
也许中断处理程序也会将字符放入队列中。

286
00:21:17,850 --> 00:21:22,410
我们会看到，使用这些队列可以使顶部和底部解耦，

287
00:21:22,770 --> 00:21:27,750
并且允许设备与 CPU 上的其他代码并行运行。

288
00:21:30,150 --> 00:21:33,990
中断处理程序，通常对中断处理程序有一些限制，

289
00:21:33,990 --> 00:21:35,760
因为它们运行在任何上下文中，

290
00:21:35,760 --> 00:21:40,380
在你可以调用 copyin 或 copyout 的进程上下文中，

291
00:21:40,590 --> 00:21:43,860
因为当前页表，

292
00:21:43,860 --> 00:21:47,370
可能不是对应页表，

293
00:21:47,370 --> 00:21:50,130
进程的字符应该[复制]。

294
00:21:50,960 --> 00:21:56,090
所以驱动程序的上部，通常与用户进程进行交互，

295
00:21:56,090 --> 00:21:58,220
可能调用 copyin 或 copyout 。

296
00:22:01,280 --> 00:22:04,880
对这张高级别（示例）图片有什么问题吗？

297
00:22:07,630 --> 00:22:09,880
我们会更详细地研究它，

298
00:22:09,910 --> 00:22:15,200
但这是典型驱动程序的主要组织方式，

299
00:22:15,470 --> 00:22:18,860
如果你注意到，操作系统中有很多驱动程序，

300
00:22:18,860 --> 00:22:28,220
实际上，有些驱动程序代码比内核本身要大是很常见的。

301
00:22:29,060 --> 00:22:32,900
最主要的原因是，对于每个设备，你需要一个驱动程序。

302
00:22:33,720 --> 00:22:35,850
而且大多数计算机都有很多设备。

303
00:22:42,520 --> 00:22:45,670
好的，让我们来谈谈对设备编程。

304
00:22:55,280 --> 00:22:59,270
通常，设备编程使用内存映射 IO 。

305
00:23:06,450 --> 00:23:11,190
正如我们在 RISC-V 或 SiFive 电路板上看到的，

306
00:23:11,190 --> 00:23:18,570
设备出现在物理地址空间的特定地址，

307
00:23:18,570 --> 00:23:22,170
这是由设备电路板制造商决定。

308
00:23:22,770 --> 00:23:24,630
操作系统需要知道，

309
00:23:24,630 --> 00:23:29,700
这些设备位于物理内存空间中的哪个位置，

310
00:23:29,910 --> 00:23:31,740
然后对它们进行编程，

311
00:23:31,740 --> 00:23:38,250
对这些地址使用普通的加载存储指令。

312
00:23:39,000 --> 00:23:42,960
这些加载存储指令所做的是，

313
00:23:43,020 --> 00:23:54,530
它们读或写设备的控制寄存器。

314
00:24:00,200 --> 00:24:04,550
所以，当你在其中一个控制寄存器中存储某些内容时，

315
00:24:04,670 --> 00:24:06,290
发送你的数据包，

316
00:24:06,290 --> 00:24:08,060
所以不是读或写内存，

317
00:24:08,120 --> 00:24:10,850
这些加载存储指令通常具有副作用，

318
00:24:10,880 --> 00:24:13,280
引起设备做某些事。

319
00:24:15,080 --> 00:24:18,710
你必须查看设备文档，

320
00:24:18,710 --> 00:24:20,840
才能弄清楚这个设备是做什么的。

321
00:24:21,360 --> 00:24:24,930
有时候文档非常清楚，

322
00:24:24,990 --> 00:24:26,880
有时候文档不太清楚。

323
00:24:27,430 --> 00:24:30,850
这里给你一个小的示例。

324
00:24:32,630 --> 00:24:34,460
在这里我想给你们看两样东西，

325
00:24:34,550 --> 00:24:37,940
在屏幕的右侧，

326
00:24:38,180 --> 00:24:45,470
你可以看到 SiFive 电路板的物理内存映射空间，

327
00:24:45,830 --> 00:24:49,370
你可以看到特定事物映射的地址是什么，

328
00:24:49,490 --> 00:24:53,330
它们出现在物理地址空间中的位置，

329
00:24:53,330 --> 00:24:55,460
它们实际出现在物理地址空间的位置。

330
00:24:56,050 --> 00:25:01,180
比如， CLINT 在 0x0200 。

331
00:25:01,540 --> 00:25:06,430
我们再挑一个。

332
00:25:07,400 --> 00:25:08,900
PLIC 也在那里的某个地方，

333
00:25:08,900 --> 00:25:12,200
好的，这里是 PLIC ，在 0x0C00 ，

334
00:25:12,200 --> 00:25:17,510
这是平台中断控制器，

335
00:25:17,510 --> 00:25:21,970
我们看到 UART0 在这个特定地址，

336
00:25:22,060 --> 00:25:26,590
实际上，在我们使用的 QEMU 上，

337
00:25:26,590 --> 00:25:31,270
UART 实际上在另一个位置。

338
00:25:31,960 --> 00:25:35,200
那是因为我们使用 QEMU ，

339
00:25:35,200 --> 00:25:38,080
并不是完全模仿 SiFive 电路板，

340
00:25:38,080 --> 00:25:40,120
而是跟 SiFive 电路板很相似。

341
00:25:41,610 --> 00:25:42,960
好的，这就是内存映射，

342
00:25:43,110 --> 00:25:50,100
从物理地址到设备的内存映射。

343
00:25:51,550 --> 00:25:54,790
然后，在左边，

344
00:25:54,820 --> 00:26:00,790
是 UART 文档的一部分。

345
00:26:01,950 --> 00:26:08,170
这是 16550 ，

346
00:26:08,170 --> 00:26:12,640
这是位于 QEMU 上模拟的 UART 芯片，

347
00:26:12,640 --> 00:26:20,560
我们用来与键盘和控制台交互，

348
00:26:20,620 --> 00:26:23,080
这是一个很简单的芯片，

349
00:26:23,080 --> 00:26:26,260
这个设备并没有太多的功能，

350
00:26:26,290 --> 00:26:29,080
即便如此，它们还是有点复杂。

351
00:26:29,260 --> 00:26:32,330
在这张表中，

352
00:26:33,160 --> 00:26:38,440
显示了芯片拥有的寄存器，控制器寄存器，

353
00:26:38,440 --> 00:26:41,440
比如，控制寄存器 0 0 0 ，

354
00:26:41,740 --> 00:26:44,260
当你执行加载指令时，

355
00:26:44,350 --> 00:26:47,290
它将持有数据，

356
00:26:47,650 --> 00:26:49,420
如果执行存储指令，

357
00:26:49,630 --> 00:26:52,690
寄存器会，数据会复制进来，

358
00:26:52,690 --> 00:26:55,090
传输到线路之外，

359
00:26:55,210 --> 00:27:04,880
UART 是一种允许你通过串行线发送比特的设备，

360
00:27:04,880 --> 00:27:08,330
发送是一条线路，接收是另一条线路，

361
00:27:09,590 --> 00:27:11,810
基本上，你取一个字节

362
00:27:11,810 --> 00:27:17,480
它们在这一条线上是多路复用或串行化的，

363
00:27:17,780 --> 00:27:19,130
送到另一边，

364
00:27:19,130 --> 00:27:21,050
有一个 UART 芯片在另一边，

365
00:27:21,050 --> 00:27:24,670
将比特组装回单个字节。

366
00:27:25,780 --> 00:27:29,410
你还可以在这个设备上，控制其他几件事情，

367
00:27:29,590 --> 00:27:36,970
你可以一定程度上控制设备的波特率，

368
00:27:37,180 --> 00:27:46,530
对我们来说最重要的可能是寄存器 1 ，

369
00:27:46,590 --> 00:27:49,530
在这里，是中断启用寄存器，

370
00:27:49,620 --> 00:27:51,630
我们可以对它编程，

371
00:27:51,630 --> 00:27:55,110
使 UART 生成中断。

372
00:27:57,640 --> 00:27:59,500
向下滚动，

373
00:27:59,500 --> 00:28:02,710
在这份文档中，你会看到。

374
00:28:03,900 --> 00:28:04,860
向下滚动一点，

375
00:28:04,860 --> 00:28:10,980
文档更详细地描述了每个寄存器中的每一位的含义，

376
00:28:10,980 --> 00:28:18,060
比如，在中断启用寄存器 IER 中，

377
00:28:18,360 --> 00:28:21,510
有接收行状态中断，

378
00:28:21,570 --> 00:28:24,690
和传输保持状态中断。

379
00:28:25,030 --> 00:28:26,890
这是这些位的含义。

380
00:28:27,500 --> 00:28:31,010
它还有很多，有更多的文档，

381
00:28:31,010 --> 00:28:35,000
告诉你寄存器的更多细节，

382
00:28:35,000 --> 00:28:37,700
如何在轮询模式或中断模式下使用它，

383
00:28:37,700 --> 00:28:39,200
我们会多谈一点，

384
00:28:39,230 --> 00:28:43,700
如何对启用寄存器等进行编程，等等。

385
00:28:43,730 --> 00:28:47,750
这是真实文档的一个简短版本，

386
00:28:47,750 --> 00:28:50,900
真正芯片制造商的文档要多得多，

387
00:28:51,240 --> 00:28:54,090
有更多的内容和更多的细节，

388
00:28:54,330 --> 00:28:58,290
这个对我们谈论 UART 编程足够了。

389
00:28:59,100 --> 00:29:01,440
你可以看到，这是最简单的设备之一，

390
00:29:01,440 --> 00:29:04,380
即使那份文档，它也相当复杂。

391
00:29:10,050 --> 00:29:13,620
抱歉，我想知道，如果你写入，

392
00:29:13,650 --> 00:29:19,000
如果你将某些内容写入传输保持寄存器，

393
00:29:19,300 --> 00:29:22,930
然后你再写一遍，在那之后，

394
00:29:23,400 --> 00:29:31,940
它是不是确保了之前的数字不会被覆盖。

395
00:29:32,120 --> 00:29:36,170
是或不是，这是你来决定的，

396
00:29:36,170 --> 00:29:39,380
实际上这是我们要关注的一件事，

397
00:29:39,740 --> 00:29:43,910
你告诉，加载指令加载一些值，

398
00:29:43,910 --> 00:29:45,860
或存储指令将一些值加载到寄存器中，

399
00:29:46,100 --> 00:29:51,330
然后， UART 芯片继续，

400
00:29:51,330 --> 00:29:55,620
它会把那个字节发送到串行线路上，

401
00:29:56,040 --> 00:29:57,960
当它完成时，

402
00:29:58,140 --> 00:30:00,750
它将生成一个中断，告诉内核，

403
00:30:00,750 --> 00:30:01,890
好了，完成了那个字节，

404
00:30:01,920 --> 00:30:03,330
现在你可以给我下一个字节了。

405
00:30:04,300 --> 00:30:07,270
因此内核和设备必须遵循一个协议，

406
00:30:07,270 --> 00:30:09,190
以确保一切都能顺利解决。

407
00:30:10,340 --> 00:30:13,130
这个我们使用的 UART ，

408
00:30:13,130 --> 00:30:20,330
16550A 实际上内部有一个 FIFO ，

409
00:30:20,360 --> 00:30:23,060
我想它可以缓冲一些字符，

410
00:30:23,060 --> 00:30:24,410
我想最多是 16 个字符。

411
00:30:25,560 --> 00:30:27,720
但是你仍然要玩这个游戏，

412
00:30:27,720 --> 00:30:30,720
你不能放入超过 16 个字符，

413
00:30:30,720 --> 00:30:34,890
在设备告诉你已经发送了一个字符之前。

414
00:30:37,270 --> 00:30:38,110
这能理解吗？

415
00:30:39,130 --> 00:30:40,600
是的，谢谢。

416
00:30:41,780 --> 00:30:43,610
我们会再多说一点，

417
00:30:43,640 --> 00:30:48,020
在看更多细节之前，

418
00:30:48,170 --> 00:30:54,380
我们要看的个例研究，

419
00:30:54,650 --> 00:30:58,610
为了解释设备和中断是如何工作的，

420
00:30:58,610 --> 00:30:59,840
是 $ ls，

421
00:30:59,840 --> 00:31:03,750
你知道这里发生了什么。

422
00:31:04,660 --> 00:31:06,850
实际上是如何打印的，

423
00:31:06,910 --> 00:31:08,710
发生的事情是，

424
00:31:08,710 --> 00:31:12,550
就像我们刚才讨论的那样，

425
00:31:12,670 --> 00:31:18,180
在本例中，基本上就是把 $ 符放入 UART ，

426
00:31:18,390 --> 00:31:20,910
实际上，是我们刚看过的寄存器中。

427
00:31:21,560 --> 00:31:26,210
然后 UART 产生中断，

428
00:31:26,540 --> 00:31:28,610
我们可以设置，

429
00:31:28,670 --> 00:31:33,700
当发送字符时产生一个中断。

430
00:31:42,140 --> 00:31:43,910
然后在另一边，

431
00:31:43,910 --> 00:31:46,940
所以 QEMU 中的事情是这样设置的，

432
00:31:46,940 --> 00:31:49,010
QEMU 在一个在发送线上，

433
00:31:49,040 --> 00:31:51,470
在发送线路的另一边，

434
00:31:51,470 --> 00:31:53,630
通常是另一个 UART 芯片，

435
00:31:53,630 --> 00:31:56,750
它连接到控制台，

436
00:31:56,750 --> 00:31:59,570
连接到一个虚拟控制台。

437
00:32:00,370 --> 00:32:03,280
另一方面，你知道 ls 会发生什么，

438
00:32:03,960 --> 00:32:06,210
我们需要使用输入，

439
00:32:06,240 --> 00:32:10,080
所以，键盘实际上连接到接收的线路，

440
00:32:15,880 --> 00:32:17,320
接收线。

441
00:32:18,490 --> 00:32:21,700
基本上就是键盘，

442
00:32:21,700 --> 00:32:23,560
你按了键盘上的一个键，

443
00:32:23,560 --> 00:32:26,440
在本例中的虚拟键盘，

444
00:32:26,680 --> 00:32:29,020
另一边的 UART 芯片，

445
00:32:29,020 --> 00:32:33,340
会序列化字符 l ，

446
00:32:33,340 --> 00:32:34,780
把它发送给另一边的 UART ，

447
00:32:34,780 --> 00:32:40,180
另一边把位放在一起变成一个字节，

448
00:32:40,450 --> 00:32:42,910
然后产生中断，

449
00:32:45,080 --> 00:32:47,960
生成中断告知处理器，

450
00:32:47,960 --> 00:32:51,510
嘿，键盘上有一个字符可用。

451
00:32:53,320 --> 00:32:57,160
在中断处理程序中，收到 UART 的字节，

452
00:32:57,190 --> 00:32:58,120
正如我们稍后看到的，

453
00:32:58,480 --> 00:33:00,970
所以，这里有两个事情需要理解，

454
00:33:00,970 --> 00:33:03,520
更详细地了解它们是如何工作的。

455
00:33:05,910 --> 00:33:06,690
好的?

456
00:33:07,110 --> 00:33:08,250
这个有什么问题吗？

457
00:33:13,720 --> 00:33:19,530
好的， RISC-V 有一系列的支持，

458
00:33:23,600 --> 00:33:25,130
对中断的支持。

459
00:33:34,380 --> 00:33:40,050
我们会更详细地了解一些会使用的寄存器的细节，

460
00:33:40,050 --> 00:33:42,030
但是知道有哪些是有用的，

461
00:33:42,150 --> 00:33:48,630
这是 SIE ，管理程序中断启用寄存器，

462
00:33:48,810 --> 00:33:56,220
它有一位，用于外部中断，

463
00:33:56,400 --> 00:33:58,020
来自设备，比如 UART ，

464
00:33:58,320 --> 00:34:02,790
来自软件中断，这一点我会讨论一下，

465
00:34:02,790 --> 00:34:06,870
但这是可能的，从一个 RISC-V 核心

466
00:34:06,870 --> 00:34:09,480
向另一个 RISC-V 核心发送中断，

467
00:34:10,070 --> 00:34:12,560
还有定时器中断。

468
00:34:14,740 --> 00:34:20,950
我不准备谈论管理者模式的软件中断或计时器中断，

469
00:34:20,950 --> 00:34:22,420
而是重点放在外部中断。

470
00:34:23,340 --> 00:34:26,220
还有另一个我们见过的寄存器，

471
00:34:26,220 --> 00:34:29,610
管理者状态寄存器，

472
00:34:30,480 --> 00:34:39,740
它有一个位用来禁用和启用特定内核上的中断。

473
00:34:41,720 --> 00:34:45,290
所以，每个核心都有这些寄存器，

474
00:34:45,320 --> 00:34:48,830
除了这三个位之外，

475
00:34:48,830 --> 00:34:54,020
对于每个控制，你有外部中断、软件中断、计时器中断，

476
00:34:54,230 --> 00:34:57,650
有一个位可以控制收到的中断，

477
00:34:57,800 --> 00:35:02,450
所以，你可以原子地从没有中断切换到可以中断，

478
00:35:02,450 --> 00:35:03,320
反之亦然，

479
00:35:03,380 --> 00:35:07,140
只需要修改 SSTATUS 寄存器中的这一位。

480
00:35:08,660 --> 00:35:11,130
然后是 SIP 寄存器，

481
00:35:11,130 --> 00:35:15,330
称为管理程序中断挂起寄存器，

482
00:35:21,020 --> 00:35:22,970
基本上进程可以使用它，

483
00:35:23,030 --> 00:35:25,220
当中断发生，

484
00:35:25,220 --> 00:35:30,650
查看 SIP ，看是什么中断。

485
00:35:31,220 --> 00:35:35,150
另外，当中断发生时，

486
00:35:35,450 --> 00:35:39,020
在 SCAUSE 寄存器，我们之前已经看过几次，

487
00:35:40,160 --> 00:35:45,530
将会出现一个进入的中断的指示，我们随后会看到，

488
00:35:46,040 --> 00:35:48,350
当然还有 STVEC 寄存器，

489
00:35:48,650 --> 00:35:54,020
保存程序，或处理器切换的地址，

490
00:35:54,230 --> 00:35:59,630
当 trap 系统调用，

491
00:35:59,630 --> 00:36:02,660
或发生页面错误，产生中断，

492
00:36:02,690 --> 00:36:05,720
因为这三种情况都使用相同的机制。

493
00:36:06,160 --> 00:36:09,310
我不会说太多关于 SCAUSE 和 STVEC ，

494
00:36:09,310 --> 00:36:12,970
因为我们之前已经详细看过了，

495
00:36:13,390 --> 00:36:18,370
基本上以相同的方式运行，

496
00:36:18,370 --> 00:36:26,770
与页面错误或其他异常的系统调用一样。

497
00:36:30,080 --> 00:36:34,280
好的，让我们来看看，

498
00:36:34,460 --> 00:36:36,890
这些东西是如何初始化的，

499
00:36:37,070 --> 00:36:40,820
我们不会谈论驱动的实际工作方式，

500
00:36:40,820 --> 00:36:43,220
而是看看 xv6 程序是如何对它编程，

501
00:36:43,670 --> 00:36:48,710
设置这些寄存器，让我们处于中断的位置。

502
00:36:50,030 --> 00:36:53,300
聊天中有一个问题，确认一下。

503
00:37:03,140 --> 00:37:04,160
好的，

504
00:37:04,970 --> 00:37:06,170
聊天有点落后，

505
00:37:06,290 --> 00:37:13,490
那么让我们来看一下， xv6 如何对寄存器编程，

506
00:37:13,790 --> 00:37:16,130
所以找出一些代码。

507
00:37:16,920 --> 00:37:24,930
让我跳出这个这个窗口，

508
00:37:24,930 --> 00:37:26,610
其实我也不需要这个。

509
00:37:26,940 --> 00:37:30,420
我不打算使用 gdb 来遍历代码，

510
00:37:30,420 --> 00:37:34,560
我只想看看相关的特定函数。

511
00:37:35,140 --> 00:37:38,350
所以，第一件事可能是在 start.c 中，

512
00:37:38,380 --> 00:37:41,290
当机器启动时，处理器启动时，

513
00:37:41,780 --> 00:37:46,810
start 函数被调用，

514
00:37:46,810 --> 00:37:48,430
它以 M 模式运行，

515
00:37:48,460 --> 00:37:52,750
它禁用了页表，

516
00:37:53,350 --> 00:37:57,190
因为很快，稍后，

517
00:37:57,190 --> 00:37:58,750
内核可以设置页表，

518
00:37:58,960 --> 00:38:00,130
我们在这里看到，

519
00:38:00,130 --> 00:38:04,450
将所有中断和异常交给管理者模式，

520
00:38:04,780 --> 00:38:11,200
然后，对管理者中断启用寄存器编程，

521
00:38:11,200 --> 00:38:17,390
用来接受软件中断，定时器中断，以及外部中断。

522
00:38:18,500 --> 00:38:21,080
然后为了更好的[衡量]，

523
00:38:21,080 --> 00:38:26,810
定时器中断发生在 M 模式，

524
00:38:27,110 --> 00:38:35,000
M 模式代码对定时器寄存器编程，

525
00:38:35,120 --> 00:38:39,230
然后产生计时器中断。

526
00:38:40,080 --> 00:38:41,700
我不想讨论这个，

527
00:38:41,730 --> 00:38:43,440
所以，我要去看 main.c 。

528
00:38:46,980 --> 00:38:50,580
看看外部设备是如何处理的，

529
00:38:50,610 --> 00:38:54,870
我们的第一个外部设备是可以打印的 console 。

530
00:38:55,440 --> 00:38:57,930
我们可以看看 consoleinit 做了什么。

531
00:38:59,520 --> 00:39:01,440
这是 consoleinit ，

532
00:39:01,560 --> 00:39:07,200
初始化锁，实际上我们不关心这个，

533
00:39:07,200 --> 00:39:08,820
它不是这节课（的内容），

534
00:39:08,880 --> 00:39:12,090
它调用了 uartinit 。

535
00:39:12,840 --> 00:39:16,890
uartinit 在这里。

536
00:39:18,380 --> 00:39:23,030
它设置了 UART 芯片，

537
00:39:23,030 --> 00:39:25,310
配置要使用的 UART 芯片。

538
00:39:25,740 --> 00:39:28,500
首先是禁用中断，

539
00:39:28,500 --> 00:39:29,670
你知道有一个顺序，

540
00:39:29,670 --> 00:39:31,500
当你对它编程时，必须遵守，

541
00:39:31,890 --> 00:39:35,280
然后，你可以设置波特率，

542
00:39:35,310 --> 00:39:38,460
然后设置 6 7 位，

543
00:39:38,460 --> 00:39:41,190
7 位或 8 位[修复] UART 。

544
00:39:43,080 --> 00:39:51,090
然后，重新设置 UART 的内部 FIFO ，

545
00:39:51,090 --> 00:39:53,850
清除那里可能存在的任何东西，

546
00:39:54,000 --> 00:39:56,910
然后，接收到，

547
00:39:56,910 --> 00:40:00,780
它将启用传输中断和接收中断。

548
00:40:02,890 --> 00:40:04,930
Amir ，我想你举手了。

549
00:40:07,140 --> 00:40:09,690
是的，我想知道波特率是什么。

550
00:40:09,990 --> 00:40:12,540
哦，是线路运行的速度。

551
00:40:14,740 --> 00:40:16,360
我知道了，谢谢。

552
00:40:20,510 --> 00:40:21,890
好的，那就是 uartinit 。

553
00:40:21,950 --> 00:40:27,410
现在，原则上 UART 可以生成中断，

554
00:40:27,530 --> 00:40:31,340
但是当然我们还没有对中断启用寄存器编程，

555
00:40:31,340 --> 00:40:34,370
在 RISC-V 处理器上，

556
00:40:34,370 --> 00:40:35,870
我们还没有对 PLIC 编程，

557
00:40:36,020 --> 00:40:39,340
这个时候，什么都不会发生。

558
00:40:39,340 --> 00:40:42,400
所以下一件事，我们将回到 main.c ，

559
00:40:42,820 --> 00:40:46,690
我们会看到，向下滚动一点，

560
00:40:46,690 --> 00:40:49,090
我们会看到 PLIC 初始化，

561
00:40:49,330 --> 00:40:50,590
让我们来看看这个。

562
00:40:52,540 --> 00:40:56,480
基本上， plicinit 代码，

563
00:40:56,660 --> 00:41:00,590
如果看一下我刚才给你的这张表格，

564
00:41:00,590 --> 00:41:03,740
物理内存或内存布局，

565
00:41:03,740 --> 00:41:07,730
你知道， PLIC 在某个特定的位置，

566
00:41:07,730 --> 00:41:09,770
位置在 kernel/memlayout.h 。

567
00:41:10,340 --> 00:41:13,550
我们看到 PLIC 是 0C000000 ，

568
00:41:13,550 --> 00:41:15,200
字面上是从那份文档复制过来的。

569
00:41:15,890 --> 00:41:18,620
我们向 PLIC 写东西，

570
00:41:18,620 --> 00:41:23,300
使用 PLIC 的地址编号，

571
00:41:23,600 --> 00:41:28,460
强制转换为 32 整数指针，

572
00:41:28,460 --> 00:41:30,590
因为 PLIC 寄存器是 32 位的。

573
00:41:31,160 --> 00:41:33,140
然后写入，

574
00:41:33,170 --> 00:41:40,190
这个强制转换是将 1 写入寄存器 UART0_IRQ 。

575
00:41:41,060 --> 00:41:42,800
这个说做的就是，

576
00:41:42,800 --> 00:41:45,920
它启用来自 UART 的中断请求，

577
00:41:46,370 --> 00:41:50,720
记得 PLIC 路由中断，

578
00:41:50,720 --> 00:41:54,770
所以中断可能从图片左侧进入 PLIC ，

579
00:41:54,770 --> 00:41:58,820
这个程序中， PLIC 可以接受这些中断。

580
00:42:00,270 --> 00:42:04,740
类似地，对 PLIC 编程，从 IO 磁盘接收中断，

581
00:42:04,770 --> 00:42:06,270
我不会讨论论这个。

582
00:42:08,510 --> 00:42:12,530
好的，然后，我们回到 main.c 。

583
00:42:12,590 --> 00:42:18,580
在 plicinit 之后，是 plicinithart ，

584
00:42:18,610 --> 00:42:25,370
针对每个核心，每个独立核心，

585
00:42:25,370 --> 00:42:29,930
只有一个核心，第一个核心初始化该方面，

586
00:42:30,170 --> 00:42:32,330
我们接收这些设备的中断，

587
00:42:32,720 --> 00:42:37,280
然后，每个核心都必须单独地说我也对这些设备感兴趣。

588
00:42:37,980 --> 00:42:39,960
比如，在这里，

589
00:42:40,110 --> 00:42:43,110
每个核心都调用这些函数，

590
00:42:43,110 --> 00:42:46,950
每个核心，都对来自 UART 的中断感兴趣，

591
00:42:46,950 --> 00:42:49,800
也对 VIRTIO 的中断感兴趣。

592
00:42:50,730 --> 00:42:53,070
你在这里可以看到 UART0_IRQ ，

593
00:42:53,070 --> 00:42:55,920
是一个唯一的数字，

594
00:42:55,920 --> 00:43:00,840
UART_IRQ 在 UART 中，

595
00:43:00,840 --> 00:43:04,630
我想在 QEMU 上是编号 10 。

596
00:43:06,540 --> 00:43:09,180
我们忽略 priority ，

597
00:43:09,180 --> 00:43:10,530
所以我们把它设为零。

598
00:43:11,880 --> 00:43:15,180
好的，每个 CPU 单独调用，

599
00:43:15,180 --> 00:43:16,290
必须向 PLIC 表明，

600
00:43:16,290 --> 00:43:20,220
它对接收中断感兴趣。

601
00:43:22,290 --> 00:43:25,260
在这一点，你知道 PLIC ，

602
00:43:25,380 --> 00:43:28,230
所以我们必须对设备进行编程以产生中断，

603
00:43:28,230 --> 00:43:33,300
我们对 PLIC 编程在各个 CPU 上传递中断，

604
00:43:33,480 --> 00:43:36,900
但是 CPU 本身还没有接受中断，

605
00:43:36,930 --> 00:43:40,650
因为我们还没有设置 SSTATUS 寄存器中的位，

606
00:43:40,650 --> 00:43:44,640
所以，让我们回到 main.c 。

607
00:43:47,440 --> 00:43:51,160
main.c 做了更多初始化，

608
00:43:51,160 --> 00:43:52,960
但是，最后它调用了 scheduler 。

609
00:43:53,940 --> 00:43:55,920
所以，我们来看一下 proc.c ，

610
00:43:56,960 --> 00:43:59,330
搜索 scheduler 。

611
00:44:04,940 --> 00:44:06,020
我们在这里看到的是，

612
00:44:06,020 --> 00:44:08,900
整个机器的，

613
00:44:08,900 --> 00:44:10,730
处理器已经设置，

614
00:44:10,910 --> 00:44:14,690
调度器调度虚拟进程运行，

615
00:44:14,690 --> 00:44:19,370
在任何一个启用中断之前。

616
00:44:20,180 --> 00:44:21,950
所以，我们来看看 riscv.h 。

617
00:44:22,530 --> 00:44:27,110
你们会看到，这是一个 C 函数。

618
00:44:28,240 --> 00:44:29,830
它启用中断

619
00:44:29,830 --> 00:44:31,570
你不会感到惊讶，

620
00:44:31,570 --> 00:44:33,070
它唯一能做的就是，

621
00:44:33,190 --> 00:44:36,520
设置 SSTATUS 寄存器中的中断启用位。

622
00:44:37,330 --> 00:44:39,070
在这个特殊的时刻，

623
00:44:39,430 --> 00:44:44,050
如果在 PLIC 处存在挂起的中断，

624
00:44:44,260 --> 00:44:47,590
那么这个特殊的核心会被中断。

625
00:44:48,770 --> 00:44:50,150
我们随后会看到，

626
00:44:50,150 --> 00:44:52,370
但是，此时启用了中断。

627
00:44:53,840 --> 00:44:55,400
这就是基本设置。

628
00:44:56,050 --> 00:44:57,160
对于这个，有什么问题吗？

629
00:45:02,020 --> 00:45:02,800
不好意思，

630
00:45:02,830 --> 00:45:07,810
在那个时刻，哪个核心会被打断呢？

631
00:45:08,420 --> 00:45:11,090
所以，每个核心都运行调度器循环。

632
00:45:11,680 --> 00:45:14,680
无论什么核心启用中断，

633
00:45:15,250 --> 00:45:16,630
所有内核都会启用中断，

634
00:45:16,630 --> 00:45:21,390
但是我们假设只有一个核心最先到达那里，比如核心 1 ，

635
00:45:21,660 --> 00:45:25,950
如果核心 1 在这个时刻设置中断启用位，

636
00:45:25,950 --> 00:45:27,360
它可能会收到中断。

637
00:45:29,480 --> 00:45:31,820
我们随后会看到，一次中断到底发生了什么。

638
00:45:33,230 --> 00:45:34,430
理解了，谢谢。

639
00:45:36,520 --> 00:45:39,790
好的，那么我想做的是，

640
00:45:39,820 --> 00:45:42,160
就是看看这个，

641
00:45:42,280 --> 00:45:44,650
如何打印 $ ，

642
00:45:44,710 --> 00:45:46,870
也就是 shell 提示符。

643
00:45:47,550 --> 00:45:51,660
所以，我们往回一点。

644
00:45:52,460 --> 00:45:54,470
我们首先再次查看 init 。

645
00:45:55,040 --> 00:45:57,230
所以，这是第一个出现的进程，

646
00:45:57,320 --> 00:45:59,540
在 execinit 代码中，

647
00:45:59,540 --> 00:46:01,970
这是第一个运行的进程。

648
00:46:02,520 --> 00:46:04,740
它所做的一件事是，

649
00:46:05,040 --> 00:46:09,510
它建立了一个代表控制台的设备。

650
00:46:10,100 --> 00:46:12,740
这是创建的设备，

651
00:46:12,860 --> 00:46:14,990
使用 mknod 操作，

652
00:46:15,350 --> 00:46:18,680
并且返回文件描述符，文件描述符零，

653
00:46:18,680 --> 00:46:20,300
因为它是第一个打开的文件描述符，

654
00:46:20,300 --> 00:46:22,280
然后分配给标准输出，

655
00:46:22,310 --> 00:46:24,380
然后再分配给标准错误，

656
00:46:24,680 --> 00:46:28,730
所以，这设置了文件描述符 0 、 1 和 2 ，

657
00:46:29,030 --> 00:46:31,880
对应于 console 。

658
00:46:33,280 --> 00:46:38,710
现在，对于 shell 。

659
00:46:40,030 --> 00:46:42,100
让我们来看一下 shell 。

660
00:46:42,960 --> 00:46:50,050
shell 打开使用文件描述符 1 2 3 ，

661
00:46:50,530 --> 00:46:53,350
不好意思， 0 1 2 open 只想 console ，

662
00:46:53,620 --> 00:47:03,490
然后 shell 将打印 $ 和空格到文件描述符 2 。

663
00:47:04,200 --> 00:47:07,740
因此，尽管 console 和 UART ，

664
00:47:07,800 --> 00:47:11,550
这些都属于应用程序员，

665
00:47:11,550 --> 00:47:13,770
比如 shell ，当然，我们需要 shell ，

666
00:47:13,860 --> 00:47:15,450
它看起来就像一个普通文件，

667
00:47:15,750 --> 00:47:17,940
所以实际上， shell 本身，

668
00:47:18,120 --> 00:47:19,710
它写入文件描述符 2 ，

669
00:47:19,740 --> 00:47:21,870
实际上并不知道另一边是什么，

670
00:47:21,900 --> 00:47:23,430
我们已经在 util 实验中看到，

671
00:47:23,430 --> 00:47:24,990
你可以用它做各种很酷的事情。

672
00:47:25,460 --> 00:47:26,600
这里有一个例子，

673
00:47:26,600 --> 00:47:30,350
Unix 中的设备表示为一个文件，

674
00:47:30,380 --> 00:47:32,180
这和其他东西没什么不同。

675
00:47:33,650 --> 00:47:36,800
好的，让我们看看这个 printf 是如何工作的。

676
00:47:37,340 --> 00:47:42,770
所以， xv6 用户应用程序中有一个 printf ，

677
00:47:42,770 --> 00:47:45,710
一个很小的 C 库，包括 printf 代码。

678
00:47:46,340 --> 00:47:50,690
printf ，像你在 traps 实验中看到的，

679
00:47:50,690 --> 00:47:54,510
是某种[本能]函数，

680
00:47:54,510 --> 00:47:58,170
但是，最终它调用了 write 系统调用，

681
00:47:58,440 --> 00:48:02,370
在我们的示例中， write 系统调用是文件描述符 2 ，

682
00:48:02,370 --> 00:48:06,690
而 c 包含 $ 符号，

683
00:48:06,690 --> 00:48:11,370
因此我们传递包含 $ 的内存地址

684
00:48:11,370 --> 00:48:14,370
给文件描述符用来写入，

685
00:48:14,640 --> 00:48:17,160
我们要求写入一个字符。

686
00:48:19,290 --> 00:48:21,270
所以 shell 写入的每个字符，

687
00:48:21,270 --> 00:48:22,740
它会引起系统调用。

688
00:48:23,340 --> 00:48:24,840
现在我们可以去。

689
00:48:25,870 --> 00:48:27,430
让我们看看实际会发生什么。

690
00:48:28,040 --> 00:48:31,610
你之前看见过系统调用，

691
00:48:31,640 --> 00:48:34,250
但是， sysfile.h 。

692
00:48:36,960 --> 00:48:38,940
sys_write 。

693
00:48:40,190 --> 00:48:44,090
这是 write 系统调用和它的参数，

694
00:48:44,150 --> 00:48:46,910
文件描述符，要写入的字节数，

695
00:48:46,910 --> 00:48:47,990
还有地址，

696
00:48:49,100 --> 00:48:51,890
包含 $ 的地址，

697
00:48:51,920 --> 00:48:53,090
调用 filewrite 。

698
00:48:58,080 --> 00:49:00,750
让我们快速看一下 filewrite 。

699
00:49:01,860 --> 00:49:05,490
好的，我们离我们想要讨论的东西越来越近了。

700
00:49:06,140 --> 00:49:10,790
在这里， filewrite 查看文件描述符类型，

701
00:49:10,790 --> 00:49:12,890
如果是管道，调用管道的函数，

702
00:49:13,070 --> 00:49:16,700
如果是设备，不起作用，

703
00:49:17,000 --> 00:49:21,020
然后，它对那个设备调用 write 函数。

704
00:49:21,910 --> 00:49:29,020
所以，这实际上会调用 console 中的 write 函数。

705
00:49:30,330 --> 00:49:31,800
让我们看看那里会发生什么。

706
00:49:31,830 --> 00:49:33,030
这里是 consolewrite ，

707
00:49:33,840 --> 00:49:36,930
获取锁，我们现在不关心这个，

708
00:49:37,080 --> 00:49:41,340
它使用 either_copyin 复制进一个字符，

709
00:49:41,890 --> 00:49:44,080
然后，调用 uartputc 。

710
00:49:45,530 --> 00:49:48,650
它调用进入 UART ，

711
00:49:48,680 --> 00:49:49,940
你可以这样考虑，

712
00:49:49,940 --> 00:49:51,530
console 是驱动程序，

713
00:49:51,620 --> 00:49:54,380
我们现在看的是驱动程序的顶端，

714
00:49:54,650 --> 00:49:58,280
现在调用 uart.c 中的东西，

715
00:49:58,550 --> 00:50:00,740
来打印一个字符。

716
00:50:02,060 --> 00:50:05,960
这是 uart.c ，这会有点有趣，

717
00:50:07,780 --> 00:50:11,680
基本上，UART 内部保持一个缓冲区，

718
00:50:12,040 --> 00:50:14,500
让我们回退一点。

719
00:50:15,080 --> 00:50:18,290
在顶部，有一个用于传输的缓冲区，

720
00:50:18,620 --> 00:50:21,200
缓冲区大小是 32 个字符。

721
00:50:21,770 --> 00:50:24,350
这里有一个指针，写指针和读指针，

722
00:50:24,350 --> 00:50:30,620
用来将该字符放入循环缓冲区中，

723
00:50:30,950 --> 00:50:32,600
更详细地讨论一下这个，

724
00:50:32,600 --> 00:50:37,970
但是，有一个指向生产者的指针和一个指向消费者的指针。

725
00:50:38,620 --> 00:50:43,150
在这种情况下， shell 是生产者，

726
00:50:43,210 --> 00:50:45,760
它检查，

727
00:50:45,760 --> 00:50:46,690
它做的第一件事是

728
00:50:46,690 --> 00:50:48,730
检查这个循环缓冲区是否已满。

729
00:50:49,370 --> 00:50:52,010
检查循环缓冲区是否已满的方法，

730
00:50:52,010 --> 00:50:57,350
它的初始状态是写指针和读指针都是零，

731
00:50:57,350 --> 00:50:58,910
缓冲区的零索引，

732
00:50:59,240 --> 00:51:04,250
如果它们相等，则缓冲器是空的，

733
00:51:04,430 --> 00:51:06,410
但是如果在写指针上加一，

734
00:51:06,410 --> 00:51:08,000
与接收指针相同，

735
00:51:08,030 --> 00:51:13,160
比如，如果你填入 0 1 2 3 4 5 6 7 8 9 到 31 ，

736
00:51:13,400 --> 00:51:15,770
然后你要绕回来，

737
00:51:16,040 --> 00:51:22,680
加上一，它仍然等于接收索引或读索引，

738
00:51:22,680 --> 00:51:23,970
你知道缓冲区已满。

739
00:51:24,820 --> 00:51:28,600
所以，这一点上你不能写任何东西，

740
00:51:28,600 --> 00:51:30,640
因为很明显 UART 正忙，

741
00:51:30,640 --> 00:51:31,870
以它的方式工作，

742
00:51:31,870 --> 00:51:37,870
试着发送之前的 31 个或 30 个字符。

743
00:51:38,390 --> 00:51:40,430
在这种缓冲已满的情况下，

744
00:51:40,550 --> 00:51:46,280
shell 会休眠，在旁边等待，

745
00:51:46,280 --> 00:51:48,590
内核将运行其他程序，

746
00:51:48,890 --> 00:51:53,720
直到 shell 唤醒，已经准备好发送，

747
00:51:55,180 --> 00:51:57,430
或者 UART 准备好发送更多数据。

748
00:51:58,090 --> 00:52:00,340
当然这种情况下不是这样的，

749
00:52:00,340 --> 00:52:02,800
因为有几个字符正在打印，

750
00:52:03,220 --> 00:52:04,660
所以缓冲里有空间，

751
00:52:04,900 --> 00:52:09,220
所以驱动程序将一个字符放入缓冲区，

752
00:52:09,610 --> 00:52:12,640
更新写指针到下一个插槽，

753
00:52:12,790 --> 00:52:14,230
然后调用 uartstart 。

754
00:52:15,960 --> 00:52:17,910
基本上 uartstart 不做别的事，

755
00:52:17,910 --> 00:52:21,780
通知设备，去帮我做点事吧。

756
00:52:23,620 --> 00:52:25,180
还有，嗯。

757
00:52:25,800 --> 00:52:32,880
基本上，首先检查设备是否正忙，

758
00:52:32,880 --> 00:52:36,000
发送当前字符，

759
00:52:36,300 --> 00:52:39,390
如果设备正忙，

760
00:52:39,390 --> 00:52:41,850
我们只要回去，可能会睡眠，

761
00:52:42,320 --> 00:52:43,820
我们会睡眠，

762
00:52:44,060 --> 00:52:46,580
否则我们从缓冲区读取字符，

763
00:52:46,820 --> 00:52:51,490
并将其放入传输寄存器中，

764
00:52:51,640 --> 00:52:52,870
就像我们之前看到的。

765
00:52:54,480 --> 00:52:58,710
所以传输寄存器就像之前这样，

766
00:52:58,710 --> 00:53:01,170
稍后我们看一下。

767
00:53:02,410 --> 00:53:09,440
WriteReg 把指定的寄存器转换成 Reg 类型，

768
00:53:09,440 --> 00:53:11,300
然后，将值写入其中。

769
00:53:12,360 --> 00:53:15,510
传输保持寄存器 THR 是

770
00:53:15,570 --> 00:53:18,240
我们之前在文档中看到的寄存器 0 。

771
00:53:20,390 --> 00:53:25,250
好的，所以，你知道，

772
00:53:26,570 --> 00:53:28,370
我从哪里开始。

773
00:53:28,920 --> 00:53:31,380
你应该首先从通知设备，

774
00:53:31,380 --> 00:53:33,420
然后说，我有一个寄存器，

775
00:53:33,420 --> 00:53:36,180
我有一个字节可以发送。

776
00:53:36,790 --> 00:53:40,570
这就是所有的。

777
00:53:42,430 --> 00:53:45,220
这就是， shell ，

778
00:53:45,250 --> 00:53:48,520
系统调用 shell 所做的，

779
00:53:48,790 --> 00:53:52,960
如果通知设备，会回到用户空间，

780
00:53:52,960 --> 00:53:55,480
shell 可以继续运行，做它想做的任何事情，

781
00:53:55,840 --> 00:53:58,600
shell 要做的下一件事就是调用 read 系统调用，

782
00:53:58,600 --> 00:54:00,340
真正读取来自键盘的输入。

783
00:54:00,740 --> 00:54:02,750
所以 shell 将返回用户空间，

784
00:54:02,750 --> 00:54:06,620
使用我们看过的机制，比如 userret ，

785
00:54:06,950 --> 00:54:08,450
它继续，并做着自己的事，

786
00:54:08,630 --> 00:54:11,450
同时，那个设备没有被通知，

787
00:54:11,660 --> 00:54:13,700
来真正发送一些字节。

788
00:54:16,240 --> 00:54:17,950
所以。

789
00:54:19,400 --> 00:54:21,680
所以，在某个时候我们会被中断，

790
00:54:22,720 --> 00:54:27,130
希望，因为我们进入产生中断的硬件，

791
00:54:27,370 --> 00:54:28,720
我们往回一点，

792
00:54:28,720 --> 00:54:32,200
讨论一下，当中断发生时发生了什么。

793
00:54:37,130 --> 00:54:42,270
好的，那么硬件做了什么。

794
00:54:44,320 --> 00:54:49,140
在这种情况下， RISC-V 实际发生中断，

795
00:54:49,140 --> 00:54:53,160
所以，我们设置 SSTATUS 寄存器中的中断启用位，

796
00:54:53,280 --> 00:54:55,200
所以，这个进程可以被中断，

797
00:54:55,440 --> 00:55:00,060
比如，键盘发起中断到 PLIC ，

798
00:55:00,240 --> 00:55:03,660
PLIC 将中断路由到特定的内核，

799
00:55:03,900 --> 00:55:08,910
那个核心设置了 SIE 位，

800
00:55:09,810 --> 00:55:11,520
所以，设置中断启用位，

801
00:55:13,260 --> 00:55:15,660
设置管理者中断启用位，

802
00:55:15,780 --> 00:55:17,160
所以，如果设置了该位，

803
00:55:17,750 --> 00:55:18,770
会发生以下情况。

804
00:55:19,370 --> 00:55:22,400
这个跟我们之前看到的很像，

805
00:55:22,430 --> 00:55:27,630
硬件要做的第一件事就是清除 SIE 位。

806
00:55:29,330 --> 00:55:32,450
这会阻止任何进来的中断，

807
00:55:32,450 --> 00:55:34,340
这样我们就可以先处理这些中断，

808
00:55:34,340 --> 00:55:35,690
如果我们想要更多的中断，

809
00:55:35,690 --> 00:55:37,730
我们必须重新启用那个位，

810
00:55:37,730 --> 00:55:40,480
你知道这些阻止更多的中断，

811
00:55:40,480 --> 00:55:42,340
中断，中断，中断，

812
00:55:43,440 --> 00:55:51,800
然后，设置异常程序计数器 SEPC 为当前 PC 。

813
00:55:52,840 --> 00:55:54,730
比如，如果中断，

814
00:55:54,730 --> 00:55:56,710
比如 shell 返回用户空间，

815
00:55:56,710 --> 00:55:59,290
在用户空间运行时发生中断，

816
00:55:59,290 --> 00:56:00,850
因为发送了一个字符，

817
00:56:01,150 --> 00:56:04,960
然后，程序计数器收到，在用户空间中的程序计数器，

818
00:56:05,410 --> 00:56:10,860
它保存当前模式。

819
00:56:12,880 --> 00:56:15,520
比如，在这种情况下，

820
00:56:15,520 --> 00:56:19,270
我们将保存 xv6 的用户模式，

821
00:56:19,420 --> 00:56:21,910
然后，它设置为管理者模式。

822
00:56:26,360 --> 00:56:30,710
将程序计数器设置为 stvec 的值，

823
00:56:31,300 --> 00:56:33,340
不管 stvec 的值是什么，

824
00:56:33,340 --> 00:56:38,890
然后，继续 usertrap ，或 uservec ，或 kernelvec ，

825
00:56:39,670 --> 00:56:41,530
取决于中断发生在什么地方，

826
00:56:41,530 --> 00:56:44,230
我们是在内核空间还是在用户模式，

827
00:56:44,230 --> 00:56:47,440
在我们的例子中，shell 可能会返回用户空间。

828
00:56:47,980 --> 00:56:53,260
stvec 会包含用户[]地址，

829
00:56:53,290 --> 00:56:57,070
核心将恢复内核，

830
00:56:57,340 --> 00:57:01,630
到位于 stvec 中的指令，

831
00:57:01,660 --> 00:57:04,100
我们还记得上一节课，

832
00:57:04,100 --> 00:57:08,900
stvec 继续并调用 usertrap 。

833
00:57:09,900 --> 00:57:12,630
好的，最后我们会在 usertrap 中。

834
00:57:15,320 --> 00:57:16,970
这就是我们讲的故事，

835
00:57:16,970 --> 00:57:21,110
我不想谈论太多关于保存和恢复的事情，

836
00:57:21,110 --> 00:57:24,440
因为，第一我们在之前的课中详细解释过，

837
00:57:24,440 --> 00:57:29,720
第二，你已经看见过，在之前的的 traps 实验中，

838
00:57:29,750 --> 00:57:31,910
所以，你很清楚发生了什么。

839
00:57:36,860 --> 00:57:37,550
有什么问题呢？

840
00:57:43,150 --> 00:57:44,950
好的，那么。

841
00:57:46,410 --> 00:57:47,970
所以，这里我们回到 usertrap ，

842
00:57:48,120 --> 00:57:51,540
它是你在 traps 实验里详细研究过的函数。

843
00:57:51,720 --> 00:57:56,130
我们处理了一个系统调用的案例。

844
00:57:56,520 --> 00:58:00,810
我们要做的，我们要做的一件事是，

845
00:58:00,810 --> 00:58:04,690
看看这个例子，设备中断。

846
00:58:05,260 --> 00:58:08,200
好的，所以我们要。

847
00:58:09,150 --> 00:58:12,120
这在文件的稍低一点的地方。

848
00:58:16,140 --> 00:58:17,790
这是设备的中断，

849
00:58:17,820 --> 00:58:23,280
它查看 scause 寄存器，

850
00:58:23,280 --> 00:58:25,890
查看这是否是外部中断，

851
00:58:26,220 --> 00:58:28,080
如果是外部中断，

852
00:58:28,350 --> 00:58:30,330
它调用函数 plic_claim ，

853
00:58:30,960 --> 00:58:34,590
声称那个特定的中断。

854
00:58:34,800 --> 00:58:36,180
让我们回到 plic ，

855
00:58:39,080 --> 00:58:40,520
查看 plic_claim ，

856
00:58:41,000 --> 00:58:45,380
归结起来就是，这个，

857
00:58:45,530 --> 00:58:48,200
特定的 CPU 会告诉 PLIC ，

858
00:58:48,260 --> 00:58:52,250
嘿，我在请求说 CPU 0 或 CPU 1 ，

859
00:58:52,310 --> 00:58:58,160
它会告诉 PLIC CPU 1 正在请求这个特定的中断，

860
00:58:58,160 --> 00:59:02,120
一旦收到中断请求， PLIC 返回它得到的中断，

861
00:59:02,640 --> 00:59:05,340
实际传入的中断的 irq ，

862
00:59:05,340 --> 00:59:09,750
在这种情况下，这是一个中断 UART0_IRQ 10 。

863
00:59:10,280 --> 00:59:12,830
所以 plic_claim 会返回 10 。

864
00:59:13,660 --> 00:59:15,820
然后在这段代码中，

865
00:59:16,060 --> 00:59:19,180
嘿，这是中断 10 ，

866
00:59:19,180 --> 00:59:21,850
如果是中断 10 一定是 UART 中断，

867
00:59:22,150 --> 00:59:25,630
然后我们调用 uartintr 函数。

868
00:59:26,370 --> 00:59:28,950
而 uartintr 函数，

869
00:59:31,690 --> 00:59:36,010
从 UART 把字符拿出来，

870
00:59:36,250 --> 00:59:38,350
它从 uart 获取字符的方式是，

871
00:59:38,350 --> 00:59:43,360
在第一个寄存器中查找，接收寄存器，

872
00:59:43,660 --> 00:59:45,850
从那里拿出字符。

873
00:59:47,240 --> 00:59:52,610
这是一个整数，然后它调用 consoleintr ，

874
00:59:53,120 --> 00:59:55,340
来做剩下的工作。

875
00:59:58,510 --> 00:59:59,200
好的?

876
01:00:01,570 --> 01:00:04,000
不好意思，我说错了，

877
01:00:04,000 --> 01:00:07,060
我们在谈论传输。

878
01:00:10,940 --> 01:00:14,960
所以，如果在读取端有一个字符，

879
01:00:14,990 --> 01:00:18,170
然后我们会调用 consoleintr ，

880
01:00:18,170 --> 01:00:20,180
但是在读取端没有字符，

881
01:00:20,180 --> 01:00:23,270
因为我们没有读取，键盘还没有做任何事情，

882
01:00:23,480 --> 01:00:25,370
我们只是在传输一个字符，

883
01:00:25,640 --> 01:00:29,000
那么这个会返回 -1 ，

884
01:00:29,150 --> 01:00:31,160
然后唯一能做的就是，

885
01:00:31,190 --> 01:00:35,960
将调用 uartstart ，

886
01:00:36,020 --> 01:00:39,800
发送在缓冲器中的任何其他字符，

887
01:00:39,830 --> 01:00:42,410
可能是 shell 放在这里的，

888
01:00:42,710 --> 01:00:44,600
有另一个字符的时候恢复，

889
01:00:44,600 --> 01:00:46,460
因为 $ 之后是空格，

890
01:00:46,760 --> 01:00:49,340
并且 write 系统调用可能，

891
01:00:49,640 --> 01:00:53,630
写空格可能跟设备发送同时发生，

892
01:00:53,960 --> 01:00:56,780
所以，当传输中断完成时，

893
01:00:57,190 --> 01:01:01,330
它继续在缓冲器中找另一个字符，

894
01:01:01,330 --> 01:01:03,970
空格字符，然后把空格字符送出。

895
01:01:06,980 --> 01:01:08,150
好的，这能理解吗？

896
01:01:10,320 --> 01:01:12,900
我有一个高层次的问题。

897
01:01:13,510 --> 01:01:18,070
我知道 UART 很有用，

898
01:01:18,070 --> 01:01:20,050
比如使用键盘，

899
01:01:20,410 --> 01:01:24,730
键盘上的字符通过 UART ，

900
01:01:24,880 --> 01:01:26,080
然后通过 CPU ，

901
01:01:26,080 --> 01:01:27,820
然后是我们编写的内核代码，

902
01:01:28,120 --> 01:01:29,950
但是我不理解的是，

903
01:01:29,950 --> 01:01:33,730
当 UART 打印字符时，

904
01:01:33,910 --> 01:01:36,130
比如没有键盘交互。

905
01:01:36,520 --> 01:01:37,210
这是正确的，

906
01:01:37,210 --> 01:01:38,560
但是显示器是，

907
01:01:38,800 --> 01:01:40,720
实际上有两个设备，

908
01:01:40,720 --> 01:01:43,390
一个是键盘，一个是 console 上的显示器。

909
01:01:43,940 --> 01:01:49,760
QEMU 与 console 交互是通过 UART ，

910
01:01:49,790 --> 01:01:53,030
通过发送字符到控制台，

911
01:01:53,510 --> 01:01:54,770
然后 console 的工作是

912
01:01:54,770 --> 01:01:57,860
在显示器上绘制该字符。

913
01:01:59,030 --> 01:02:00,710
哦，我明白了，好的，谢谢。

914
01:02:02,920 --> 01:02:03,820
这可能需要时间，

915
01:02:03,850 --> 01:02:06,460
它需要画出这些东西。

916
01:02:08,040 --> 01:02:09,360
好的。

917
01:02:10,100 --> 01:02:11,540
所以现在有几件事，

918
01:02:11,540 --> 01:02:13,100
我想退回去一点，

919
01:02:13,100 --> 01:02:17,270
从更高层次上考虑这件事，

920
01:02:17,270 --> 01:02:18,590
所以我们应该遍历代码，

921
01:02:18,590 --> 01:02:20,480
我们对这里的情况有一些理解，

922
01:02:20,960 --> 01:02:26,510
比如细节怎样，

923
01:02:26,630 --> 01:02:28,910
它值得退回一点，

924
01:02:28,910 --> 01:02:31,430
想一想这一切意味着什么。

925
01:02:32,470 --> 01:02:36,370
特别是，有趣的是并发中断，

926
01:02:36,370 --> 01:02:38,920
从并发的角度考虑中断。

927
01:02:42,440 --> 01:02:48,110
这是使中断变得棘手或难以编程的一件事，

928
01:02:48,380 --> 01:02:51,560
首先是我们之前提到过，

929
01:02:51,620 --> 01:02:54,080
在我们的例子中的 UART 设备，

930
01:02:54,320 --> 01:02:57,620
设备和 CPU 并行运行。

931
01:03:03,140 --> 01:03:06,230
所以，比如，在我们讨论的场景中，

932
01:03:06,380 --> 01:03:12,290
UART 发送一个字符给 console ，

933
01:03:12,380 --> 01:03:16,880
在这个发生的同时， CPU 仍在继续它的工作，

934
01:03:16,880 --> 01:03:19,250
在这种情况下，返回到 shell ，

935
01:03:19,370 --> 01:03:24,800
shell 可以调用其他的系统调用写入空格字符，

936
01:03:25,070 --> 01:03:26,330
所有这些都是并行进行的，

937
01:03:26,510 --> 01:03:29,270
所以我们需要管理这种并行性，

938
01:03:29,270 --> 01:03:30,710
我们已经看过一点，

939
01:03:30,710 --> 01:03:32,330
但我会更详细地讨论一下。

940
01:03:32,620 --> 01:03:35,080
这里显示的并行性，

941
01:03:35,110 --> 01:03:37,570
通常称为生产者-消费者并行性。

942
01:03:49,040 --> 01:03:50,330
我稍后讲一下，

943
01:03:50,330 --> 01:03:52,670
所以现在我们更详细地讨论一下。

944
01:03:52,850 --> 01:03:53,840
第二个是，

945
01:03:54,680 --> 01:04:03,790
中断停止了当前正在运行的程序，

946
01:04:08,450 --> 01:04:09,860
或者正在运行的当前程序。

947
01:04:12,740 --> 01:04:14,150
所以在 shell 的情况下，

948
01:04:14,360 --> 01:04:18,950
shell 程序可能正在执行类似 212 的指令，

949
01:04:19,250 --> 01:04:20,630
然后突然出现了中断，

950
01:04:20,630 --> 01:04:22,580
直接在这一点停下来。

951
01:04:23,340 --> 01:04:27,540
对用户空间的代码来说，这没什么大不了的，

952
01:04:27,720 --> 01:04:30,180
因为当我们从中断返回，

953
01:04:30,180 --> 01:04:33,690
我们会恢复用户级别程序的所有状态，

954
01:04:33,870 --> 01:04:38,040
它会恢复出现中断的地址，

955
01:04:38,100 --> 01:04:41,230
我们已经在 traps 和页面错误中看到了，

956
01:04:41,230 --> 01:04:44,590
实际上是相当不错的，

957
01:04:44,620 --> 01:04:46,450
不过，这里有个棘手的情况，

958
01:04:46,450 --> 01:04:48,700
当内核本身中断时，

959
01:04:48,730 --> 01:04:50,110
所以如果是在内核模式下运行，

960
01:04:50,260 --> 01:04:51,550
而且内核被中断，

961
01:04:52,020 --> 01:04:55,650
这意味着，再说得更详细一点，

962
01:04:55,680 --> 01:04:59,400
即使是内核也不是直接按顺序执行的，

963
01:04:59,580 --> 01:05:02,640
如果你看到一条内核指令后跟另一条内核指令，

964
01:05:03,030 --> 01:05:06,810
在这些指令之间，中断可能发生，

965
01:05:07,590 --> 01:05:11,070
取决于是否启用中断。

966
01:05:11,820 --> 01:05:14,340
在一些代码中，

967
01:05:14,340 --> 01:05:16,710
在中间可以中断是不好的，

968
01:05:16,800 --> 01:05:17,910
在下一个示例中，

969
01:05:17,910 --> 01:05:20,880
内核可能必须禁用或启用中断，

970
01:05:20,880 --> 01:05:23,700
使代码序列是原子的。

971
01:05:24,930 --> 01:05:30,880
中断启用和禁用。

972
01:05:35,230 --> 01:05:37,180
稍后我会更详细地谈到，

973
01:05:37,270 --> 01:05:41,290
第三关于并发的问题，

974
01:05:41,290 --> 01:05:45,770
出现在中断处理程序中。

975
01:05:47,490 --> 01:05:49,320
让我换个说法，

976
01:05:49,530 --> 01:05:59,180
驱动的顶部和底部可以并行运行。

977
01:06:08,660 --> 01:06:11,180
比如，在我们的例子中，

978
01:06:12,370 --> 01:06:16,870
shell 会再次调用 write 系统调用，

979
01:06:16,870 --> 01:06:19,840
在打印 $ 之后打印空格，

980
01:06:20,050 --> 01:06:23,920
如果你回到驱动的顶部，

981
01:06:24,010 --> 01:06:26,080
它可能想，

982
01:06:26,080 --> 01:06:30,670
添加这个空格到 UART 的队列中，

983
01:06:30,820 --> 01:06:33,280
但同时在另一个 CPU 上，

984
01:06:33,370 --> 01:06:38,050
它可能在处理来自 UART 的中断，

985
01:06:38,200 --> 01:06:41,740
这也是并行运行的，

986
01:06:41,740 --> 01:06:44,680
这是相同的代码，查看相同的队列。

987
01:06:45,300 --> 01:06:46,380
所以这是真的，

988
01:06:46,380 --> 01:06:48,870
中断处理程序可以并行运行，

989
01:06:48,870 --> 01:06:50,400
设备驱动的底部，

990
01:06:50,400 --> 01:06:52,530
可能并行运行在不同的 CPU 上，

991
01:06:53,000 --> 01:06:56,660
与驱动程序的顶部位于不同的 CPU 上。

992
01:06:57,270 --> 01:06:58,650
所以我们必须处理好这个，

993
01:06:58,950 --> 01:07:02,460
而我们管理的方式就是使用锁。

994
01:07:06,060 --> 01:07:07,740
因为这里有一个共享的数据结构，

995
01:07:07,740 --> 01:07:09,360
我们需要一个缓冲区，

996
01:07:09,480 --> 01:07:13,800
我们要确保缓冲区正确更新，

997
01:07:14,040 --> 01:07:19,860
需要确保一次只有一个 CPU

998
01:07:19,860 --> 01:07:21,750
操纵这个特定的缓冲区，

999
01:07:21,750 --> 01:07:22,620
我们需要使用锁。

1000
01:07:23,100 --> 01:07:25,500
锁将是周三课程的主题，

1001
01:07:25,560 --> 01:07:27,180
我不会讨论太多，

1002
01:07:27,210 --> 01:07:29,190
但是在周三会有很多讨论。

1003
01:07:30,810 --> 01:07:38,090
我想关注的是生产者-消费者平行性，

1004
01:07:38,240 --> 01:07:41,300
这是一种在驱动程序出现的典型模式，

1005
01:07:41,300 --> 01:07:44,990
这是非常常见的。

1006
01:07:44,990 --> 01:07:48,260
生产者和消费者。

1007
01:07:53,150 --> 01:07:55,520
这也很简单，

1008
01:07:55,550 --> 01:08:00,020
当你看到，驱动程序中有一个缓冲区，

1009
01:08:01,750 --> 01:08:04,240
在我们的示例中，我想有 32 个条目，

1010
01:08:04,630 --> 01:08:07,210
从 0 到 31 ，

1011
01:08:07,420 --> 01:08:10,240
并且有两个指针，

1012
01:08:10,700 --> 01:08:12,890
有一个读指针和一个写指针。

1013
01:08:13,870 --> 01:08:17,290
写指针，读指针，

1014
01:08:17,320 --> 01:08:20,380
如果它们相等，缓冲区就是空的，

1015
01:08:20,560 --> 01:08:24,760
当 shell 写入时，比如使用 putc ，

1016
01:08:26,800 --> 01:08:29,710
就是把像 $ 这样的字符放到这里，

1017
01:08:29,860 --> 01:08:32,740
并将写指针指向下一条目。

1018
01:08:34,440 --> 01:08:36,030
这就是生产者的部分，

1019
01:08:36,240 --> 01:08:37,740
生产者可以继续，

1020
01:08:37,740 --> 01:08:40,560
填满所有这些字符，

1021
01:08:40,560 --> 01:08:45,610
直到到达，

1022
01:08:45,610 --> 01:08:48,190
直到如果下一个将达到读指针，

1023
01:08:48,190 --> 01:08:50,980
我们知道这个循环缓冲区已满，

1024
01:08:51,100 --> 01:08:53,170
在这时，生产者必须停止，

1025
01:08:53,200 --> 01:08:56,650
我们之前在代码中看到了，

1026
01:08:56,650 --> 01:08:59,440
UART 调用 sleep ，

1027
01:08:59,470 --> 01:09:04,760
把 shell 放在边上，

1028
01:09:04,760 --> 01:09:06,410
并运行另一个进程。

1029
01:09:07,940 --> 01:09:10,940
所以中断处理程序 uartinit 或 intr ，

1030
01:09:12,870 --> 01:09:14,640
这种情况下，在消费者这边，

1031
01:09:14,730 --> 01:09:20,580
每次都是 uartstart ，

1032
01:09:20,820 --> 01:09:25,320
当你在中断中，它查看读指针，

1033
01:09:25,470 --> 01:09:28,320
如果读指针在写指针之后，

1034
01:09:28,320 --> 01:09:29,730
写指针已经走远，

1035
01:09:29,730 --> 01:09:31,410
假设这里是空格，

1036
01:09:31,410 --> 01:09:33,900
我不知道怎么画空格，但这有一个空格。

1037
01:09:34,500 --> 01:09:37,110
所以写指针现在可能在这里。

1038
01:09:37,680 --> 01:09:39,570
所以在[]发出之后，

1039
01:09:39,570 --> 01:09:43,020
UART 看到，在写指针后面，

1040
01:09:43,020 --> 01:09:45,000
这意味着得发送下一个。

1041
01:09:46,280 --> 01:09:48,290
所以你可以把它看作是，

1042
01:09:48,290 --> 01:09:52,430
写指针，读指针在改变写指针，

1043
01:09:52,640 --> 01:09:56,390
这就是正在发生的事情，

1044
01:09:56,390 --> 01:09:57,290
现在可能出现，

1045
01:09:57,290 --> 01:10:02,330
在某个时候， UART 与写指针保持同步，

1046
01:10:02,330 --> 01:10:05,150
当它们相等时，它知道缓冲区是空的，

1047
01:10:05,150 --> 01:10:05,900
没什么事情可做。

1048
01:10:09,220 --> 01:10:09,910
这能理解吗？

1049
01:10:12,190 --> 01:10:16,900
不好意思，这个数据结构对所有核心都是相同的吗？

1050
01:10:17,400 --> 01:10:20,520
好的，让我回到代码上来，

1051
01:10:20,550 --> 01:10:23,010
然后是高层级的图片。

1052
01:10:23,560 --> 01:10:25,090
让我们回到 UART ，

1053
01:10:25,090 --> 01:10:26,260
所以这个数据结构，

1054
01:10:26,820 --> 01:10:28,920
刚才谈到的就是这个缓冲区。

1055
01:10:32,600 --> 01:10:35,240
这两个指针，写指针和读指针，

1056
01:10:35,240 --> 01:10:38,430
是两个索引用来[]。

1057
01:10:39,330 --> 01:10:39,990
好的?

1058
01:10:41,080 --> 01:10:44,110
并且这个数据结构在内存中，

1059
01:10:45,010 --> 01:10:47,200
这里只有一个 RAM ，

1060
01:10:47,200 --> 01:10:51,790
所以，所有核心都可能与这个数据结构并行交互。

1061
01:10:53,220 --> 01:10:54,510
这就是为什么我们需要锁。

1062
01:10:57,350 --> 01:10:58,340
好的，我知道了。

1063
01:10:58,370 --> 01:11:01,160
还有一个关于 sleep 的问题，

1064
01:11:02,180 --> 01:11:07,630
它怎么知道让 shell 睡觉，

1065
01:11:07,690 --> 01:11:11,770
比如，那里写入的只有地址。

1066
01:11:11,770 --> 01:11:22,640
基本上， sleep 让当前运行的进程进入睡眠状态，

1067
01:11:23,030 --> 01:11:26,960
我们下周会讨论它的很多细节。

1068
01:11:27,520 --> 01:11:31,120
它传入的是，正在等待的东西。

1069
01:11:31,690 --> 01:11:33,040
在这种情况下，

1070
01:11:33,040 --> 01:11:36,580
这个地址有一个 channel id ，

1071
01:11:36,580 --> 01:11:39,520
或者一种与睡眠程序交互的方式。

1072
01:11:40,260 --> 01:11:45,120
在本例中，[] 是 uart_tx_r 的地址。

1073
01:11:45,750 --> 01:11:51,390
并且 start 函数，

1074
01:11:51,600 --> 01:11:54,480
它需要缓冲区中的空间，

1075
01:11:54,630 --> 01:11:56,520
它会唤醒，

1076
01:11:57,380 --> 01:12:00,500
使用对应的 wakeup 以及 urat_tx_r ，

1077
01:12:00,500 --> 01:12:04,640
表示睡眠在这个地址的任何进程都应该唤醒。

1078
01:12:07,190 --> 01:12:10,640
具体是如何实现的，我们稍后会看到。

1079
01:12:13,680 --> 01:12:14,310
这能理解吗。

1080
01:12:14,790 --> 01:12:17,280
所以，这两个调用是相互的， sleep 和 wakeup ，

1081
01:12:21,470 --> 01:12:23,510
有时称为条件同步。

1082
01:12:27,440 --> 01:12:28,370
还有其他问题吗？

1083
01:12:35,990 --> 01:12:36,560
好的。

1084
01:12:37,590 --> 01:12:38,580
很好。

1085
01:12:39,530 --> 01:12:42,140
让我们看看。

1086
01:12:43,100 --> 01:12:48,470
所以，这就是打印 $ 的全部故事，

1087
01:12:48,470 --> 01:12:53,030
正如你所看到的，它涉及到很多部分，

1088
01:12:53,030 --> 01:12:56,870
（这些部分）一起将 $ 发送到 console 。

1089
01:12:57,710 --> 01:13:02,450
类似的事情也发生在读取端，

1090
01:13:02,450 --> 01:13:08,690
在某个时候， shell 打印 $ 和空格，

1091
01:13:08,690 --> 01:13:13,280
然后调用 read 读取来自键盘的输入，

1092
01:13:13,580 --> 01:13:16,010
所以现在我们看看发生了什么，

1093
01:13:16,070 --> 01:13:18,890
当它发生时，

1094
01:13:18,890 --> 01:13:21,920
这也是从 file 开始的。

1095
01:13:22,470 --> 01:13:24,630
所以现在有一个读系统调用，

1096
01:13:24,960 --> 01:13:27,630
如果从 console 上读，

1097
01:13:27,630 --> 01:13:31,280
它会调用 fileread ，

1098
01:13:31,310 --> 01:13:32,840
抱歉，不是 write 。

1099
01:13:34,500 --> 01:13:38,610
如果它是设备，在本例中是 console ，

1100
01:13:38,610 --> 01:13:41,910
然后，我们调用该设备的读方法，

1101
01:13:42,320 --> 01:13:44,510
这在 console.c 中，

1102
01:13:44,510 --> 01:13:47,480
所以，我们调用 consoleread 。

1103
01:13:49,330 --> 01:13:52,150
基本上它与 UART 有相同的结构，

1104
01:13:52,150 --> 01:13:55,470
在顶部有一个环形缓冲区。

1105
01:13:56,700 --> 01:14:01,260
这就是它， INPUT_BUF ，有 128 个字符，

1106
01:14:01,500 --> 01:14:02,910
基本上是相同的游戏，

1107
01:14:02,940 --> 01:14:04,770
是生产者-消费者并行性，

1108
01:14:04,950 --> 01:14:07,560
但是，在这种情况下， shell 是消费者，

1109
01:14:07,560 --> 01:14:11,550
它从缓冲区中读取字符。

1110
01:14:12,040 --> 01:14:13,930
键盘是生产者，

1111
01:14:13,930 --> 01:14:16,540
它将字符放入缓冲区。

1112
01:14:17,250 --> 01:14:20,280
所以，让我们回到 consoleread ，

1113
01:14:20,310 --> 01:14:22,500
如果什么都没有，

1114
01:14:22,500 --> 01:14:26,850
如果读指针，读索引和写索引相同，

1115
01:14:26,850 --> 01:14:28,440
缓冲区是空的，

1116
01:14:28,650 --> 01:14:30,420
它又回到睡眠状态。

1117
01:14:31,320 --> 01:14:35,340
所以，在打印 $ 之后，

1118
01:14:35,520 --> 01:14:38,190
shell 会去睡眠，

1119
01:14:38,520 --> 01:14:44,340
内核将 shell 置于睡眠状态，直到字符进入。

1120
01:14:45,440 --> 01:14:49,280
在某一时刻，用户输入 l ，

1121
01:14:49,670 --> 01:14:52,370
ls 的第一个字符，

1122
01:14:52,700 --> 01:15:00,110
这将导致 l 发送到电路板上的 UART 芯片，

1123
01:15:00,530 --> 01:15:04,100
它将通过 PLIC 到某个核心，

1124
01:15:04,100 --> 01:15:07,220
核心将接受中断，到 devintr ，

1125
01:15:07,220 --> 01:15:09,650
devintr ，我们会看到 UART 中断是如何进行的，

1126
01:15:09,950 --> 01:15:14,630
它将调用我们刚才看到的函数。

1127
01:15:15,020 --> 01:15:16,820
它会回到底部，

1128
01:15:16,850 --> 01:15:19,190
我自己迷惑了一下的地方，

1129
01:15:19,700 --> 01:15:22,550
所以在这种情况下，它会写，

1130
01:15:22,610 --> 01:15:25,250
它会从 UART 设备获取字符，

1131
01:15:25,250 --> 01:15:26,630
获得字符 l ，

1132
01:15:26,870 --> 01:15:31,250
使用字符 l 调用 consoleintr 函数，

1133
01:15:31,370 --> 01:15:33,230
这样我们就可以回到 console 。

1134
01:15:36,100 --> 01:15:39,490
consoleintr 得到那个字符，

1135
01:15:39,490 --> 01:15:42,070
所以现在我们有一个 l ，

1136
01:15:42,070 --> 01:15:46,330
它是控制 P ，打印进程列表，

1137
01:15:46,780 --> 01:15:49,240
实现控制 H 和 控制 U ，

1138
01:15:49,300 --> 01:15:51,880
用来回退和控制别的东西。

1139
01:15:52,320 --> 01:15:53,850
但是，在所有其他情况下，

1140
01:15:53,880 --> 01:15:55,170
基本上所做的是，

1141
01:15:55,440 --> 01:15:59,670
通过将字符打印到 console 将其回显给用户。

1142
01:16:00,300 --> 01:16:03,990
然后它将字符放入缓冲区，

1143
01:16:04,260 --> 01:16:09,330
并唤醒等待缓冲区的进程，

1144
01:16:09,390 --> 01:16:10,590
如果有进程在等待。

1145
01:16:11,190 --> 01:16:14,760
如果它达到换行，并且有进程等待，

1146
01:16:14,760 --> 01:16:17,010
它会唤醒等待进程，

1147
01:16:17,280 --> 01:16:20,370
然后等待进程将从缓冲区中读取字符。

1148
01:16:22,520 --> 01:16:25,100
这里我们又看到了这种解耦，

1149
01:16:25,100 --> 01:16:28,310
在生产者和消费者之间使用缓冲区，

1150
01:16:28,310 --> 01:16:30,620
以便生产者消费者可以并行运行，

1151
01:16:31,140 --> 01:16:33,210
以各自的速度独立运行，

1152
01:16:33,540 --> 01:16:34,950
如果一个跑得很快，

1153
01:16:35,010 --> 01:16:37,170
无论缓冲区是空，还是满，

1154
01:16:37,170 --> 01:16:39,990
就阻塞并等待对方追赶上来。

1155
01:16:43,380 --> 01:16:44,430
这个，有什么问题吗？

1156
01:16:55,150 --> 01:16:55,810
好的。

1157
01:16:58,750 --> 01:17:01,570
好的，我想再谈一件事。

1158
01:17:04,760 --> 01:17:05,810
那就是。

1159
01:17:09,440 --> 01:17:13,610
我主要谈论中断的发展，

1160
01:17:13,640 --> 01:17:15,860
比如，过去几十年发生的事情。

1161
01:17:25,230 --> 01:17:30,090
所以，对于处理器来说，中断曾经是相当快的，

1162
01:17:31,420 --> 01:17:32,320
特别是在，

1163
01:17:32,320 --> 01:17:37,350
曾经很快。

1164
01:17:38,120 --> 01:17:40,580
所以，在最初的 Unix 被开发的时候，

1165
01:17:41,030 --> 01:17:42,710
就是这种情况，

1166
01:17:42,980 --> 01:17:45,380
意味着硬件非常简单。

1167
01:17:46,310 --> 01:17:50,360
因为，如果有什么重要的工作要做，

1168
01:17:50,480 --> 01:17:52,160
我们可以直接中断处理器，

1169
01:17:52,430 --> 01:17:54,500
处理器会做这些工作，

1170
01:17:54,500 --> 01:17:58,760
所以硬件本身是非常直接的。

1171
01:17:59,850 --> 01:18:04,600
现在，与处理器相比，中断比较慢，

1172
01:18:04,960 --> 01:18:06,370
你可以看到，

1173
01:18:06,370 --> 01:18:10,060
因为中断处理程序需要保存寄存器，

1174
01:18:10,090 --> 01:18:11,590
它需要接受中断，

1175
01:18:11,590 --> 01:18:16,420
有几个预算指令，

1176
01:18:16,420 --> 01:18:18,880
它们只用来服务于中断。

1177
01:18:19,460 --> 01:18:23,780
因此如果设备产生高速中断，

1178
01:18:23,780 --> 01:18:26,630
处理器很难跟上。

1179
01:18:27,500 --> 01:18:30,530
所以，你看今天的设备，

1180
01:18:30,560 --> 01:18:33,620
硬件或设备有更多的工作要做，

1181
01:18:39,400 --> 01:18:43,300
设备本身有很多工作要做，

1182
01:18:43,300 --> 01:18:45,130
在实际生成中断之前。

1183
01:18:45,940 --> 01:18:50,590
所以，为了避免过多地中断处理器，

1184
01:18:51,350 --> 01:18:54,920
现在，如果你有一个高性能设备，

1185
01:18:54,920 --> 01:18:59,130
比如，你有千兆以太网，

1186
01:19:01,000 --> 01:19:05,560
这块网卡使用很多小包，

1187
01:19:05,830 --> 01:19:10,480
那么网卡可以产生，

1188
01:19:10,480 --> 01:19:13,600
大约每秒 150 万个包，

1189
01:19:16,290 --> 01:19:19,110
对于最小的 64 字节以太网包，

1190
01:19:19,110 --> 01:19:21,330
你粗略计算一下，

1191
01:19:21,330 --> 01:19:24,810
每秒生成 150 万个包，你可以接收。

1192
01:19:25,440 --> 01:19:31,570
所以，这意味着如果你对每个包中断，

1193
01:19:32,280 --> 01:19:33,480
那就是一微秒一个中断

1194
01:19:37,330 --> 01:19:40,390
事实上，略高于，

1195
01:19:40,960 --> 01:19:42,970
略低于，

1196
01:19:42,970 --> 01:19:44,290
略高于，

1197
01:19:44,320 --> 01:19:48,400
所以，考虑如果一微秒一个中断，

1198
01:19:48,400 --> 01:19:50,500
内核中的操作，

1199
01:19:50,560 --> 01:19:55,000
有一微秒的预算指令来处理这个包，

1200
01:19:55,000 --> 01:19:56,380
实际上是 150 万，

1201
01:19:56,380 --> 01:20:01,690
这比一微秒的预算要少一点。

1202
01:20:02,540 --> 01:20:04,760
你可以计算出有多少条指令，

1203
01:20:04,940 --> 01:20:06,290
不会有那么多，

1204
01:20:06,650 --> 01:20:08,810
所以在这种情况下，

1205
01:20:08,810 --> 01:20:11,000
我们需要有一个不同的计划，

1206
01:20:11,000 --> 01:20:14,210
那么你怎么处理这些中断包，

1207
01:20:14,210 --> 01:20:18,800
以超过处理器速度进来的包。

1208
01:20:19,550 --> 01:20:25,310
对于快速设备的解决方案是，

1209
01:20:25,400 --> 01:20:27,620
有时称为轮询。

1210
01:20:32,960 --> 01:20:36,560
不是写入中断，

1211
01:20:36,560 --> 01:20:39,140
CPU 也可以，

1212
01:20:39,140 --> 01:20:41,750
只是读取控制寄存器，

1213
01:20:41,780 --> 01:20:43,160
查看那里是否有一个字节，

1214
01:20:43,160 --> 01:20:44,480
比如在 UART 寄存器中，

1215
01:20:44,480 --> 01:20:47,660
我们只是不停读取 LHR 寄存器，

1216
01:20:47,750 --> 01:20:49,580
只是检查那里是否有一个字节。

1217
01:20:50,150 --> 01:20:56,330
说到底，这是 CPU 旋转，

1218
01:20:58,640 --> 01:21:00,950
它在设备上旋转，

1219
01:21:01,490 --> 01:21:07,030
直到设备有输入，有数据。

1220
01:21:10,590 --> 01:21:13,230
这会浪费 CPU 周期，

1221
01:21:13,230 --> 01:21:20,760
因为我们一遍又一遍地检查那个寄存器，

1222
01:21:20,880 --> 01:21:22,920
看它是否是数据，

1223
01:21:23,070 --> 01:21:27,030
我们没有使用这些周期来运行另一个应用程序，

1224
01:21:27,030 --> 01:21:29,580
我们之前看到的，

1225
01:21:29,580 --> 01:21:33,120
如果没有任何东西，内核会让 shell 睡眠，

1226
01:21:33,150 --> 01:21:34,680
以便另一个应用程序可以运行。

1227
01:21:35,080 --> 01:21:39,250
但是如果我们做轮询，那就不会发生了，

1228
01:21:39,430 --> 01:21:41,080
现在，对于速度慢的设备，

1229
01:21:41,170 --> 01:21:43,750
你当然希望不是永远旋转，

1230
01:21:43,750 --> 01:21:46,810
直到设备来做它的工作，

1231
01:21:47,170 --> 01:21:51,910
我们想从 shell 切换出去，

1232
01:21:51,910 --> 01:21:53,200
并运行其他东西。

1233
01:21:53,260 --> 01:21:55,420
但如果设备速度非常快，

1234
01:21:55,800 --> 01:21:58,770
则中断的开销很高，

1235
01:21:58,770 --> 01:22:02,310
我们最好还是轮询设备，

1236
01:22:02,310 --> 01:22:04,560
因为我们很快就会成功。

1237
01:22:06,840 --> 01:22:10,590
但是，如果设备比较慢，又浪费 CPU 。

1238
01:22:16,410 --> 01:22:24,880
但是如果设备速度很快，

1239
01:22:29,990 --> 01:22:33,440
它节省了保存时间，

1240
01:22:36,740 --> 01:22:39,950
节省了 entry 和 exit 成本。

1241
01:22:45,610 --> 01:22:48,550
所以，比如高性能网卡，

1242
01:22:48,550 --> 01:22:52,150
如果有一连串包进来，

1243
01:22:52,150 --> 01:22:53,650
将使用轮询。

1244
01:22:54,180 --> 01:22:57,030
更多的复杂驱动，

1245
01:22:57,210 --> 01:23:04,470
它们会动态切换地在轮询和中断之间切换。

1246
01:23:18,170 --> 01:23:19,670
好的。

1247
01:23:20,930 --> 01:23:21,830
有什么问题吗？

1248
01:23:24,300 --> 01:23:27,030
我的安排时间快到了。

1249
01:23:29,180 --> 01:23:30,440
有什么剩下的问题吗？

1250
01:23:35,170 --> 01:23:37,600
好的，那我们周三见，

1251
01:23:37,600 --> 01:23:42,250
在周三，我们将继续并发并行的故事，

1252
01:23:42,250 --> 01:23:45,370
我们将看到一些机制管理并行，

1253
01:23:45,490 --> 01:23:48,640
确保共享数据结构正确获取它们的数据。

1254
01:23:49,380 --> 01:23:51,000
那么，周三见。

1255
01:23:54,660 --> 01:23:59,010
抱歉，我想找出我的问题在哪里，

1256
01:23:59,010 --> 01:24:00,120
因为我把它弄丢了，

1257
01:24:00,210 --> 01:24:03,690
我的问题是，

1258
01:24:03,720 --> 01:24:08,100
所以我看到 uartinit 只被调用了一次，

1259
01:24:08,100 --> 01:24:16,580
这是为什么只有一个缓冲区供所有核心共享的原因吗？

1260
01:24:18,970 --> 01:24:21,160
好的，这里只有一个 UART 设备。

1261
01:24:24,460 --> 01:24:28,690
缓冲区对应于 UART 设备，

1262
01:24:28,690 --> 01:24:30,760
实际上是由多个核心共享的。

1263
01:24:31,300 --> 01:24:35,560
它可能是在不同核心上运行的多个进程，

1264
01:24:35,560 --> 01:24:37,060
都在试图打印到控制台。

1265
01:24:38,460 --> 01:24:39,930
好的，我明白了，

1266
01:24:39,960 --> 01:24:42,120
是的，有道理。

1267
01:24:42,820 --> 01:24:49,090
所以，只有一个队列会使用 UART 执行任务。

1268
01:24:49,620 --> 01:24:52,200
是的，这有点复杂，

1269
01:24:52,200 --> 01:24:55,680
但是假设有多个人在写，

1270
01:24:56,240 --> 01:25:00,080
只需做一次实验就行了。

1271
01:25:01,460 --> 01:25:06,570
我们看到有多个，

1272
01:25:06,660 --> 01:25:07,650
让我。

1273
01:25:11,630 --> 01:25:13,160
这里是 uartputc ，

1274
01:25:13,160 --> 01:25:15,860
你看到的第一件事是它需要一个锁。

1275
01:25:16,790 --> 01:25:21,380
多个核心正在将一个字符放入缓冲区，

1276
01:25:21,650 --> 01:25:23,240
它们中的一个获得锁，

1277
01:25:23,270 --> 01:25:24,830
其他都不会获得锁，

1278
01:25:25,190 --> 01:25:29,420
所以那个获得锁的 CPU ，

1279
01:25:29,660 --> 01:25:33,380
可以查看写指针，

1280
01:25:33,380 --> 01:25:36,800
把字符放入其中，

1281
01:25:36,800 --> 01:25:38,180
否则去睡眠。

1282
01:25:38,850 --> 01:25:43,230
如果它完成了，就可以解锁，

1283
01:25:43,650 --> 01:25:46,440
然后下一个核心可以进入，

1284
01:25:46,440 --> 01:25:48,450
获取锁并做它的工作。

1285
01:25:48,910 --> 01:25:54,820
所以，这个锁会序列化对 UART 的并发访问。

1286
01:25:58,400 --> 01:26:00,560
理解了，是的，谢谢。

1287
01:26:02,000 --> 01:26:04,700
好的，星期三我们将详细讨论锁的问题。

1288
01:26:07,210 --> 01:26:08,110
谢谢。

1289
01:26:10,160 --> 01:26:11,420
还有什么问题吗？

1290
01:26:12,750 --> 01:26:13,860
我有个问题。

1291
01:26:14,730 --> 01:26:20,690
我知道我们要在中断使用锁，

1292
01:26:20,690 --> 01:26:22,910
因为只有一个控制台，

1293
01:26:22,910 --> 01:26:24,920
而有多个核心。

1294
01:26:27,000 --> 01:26:29,190
你是说哪里的锁。

1295
01:26:29,550 --> 01:26:31,380
我想是这样的，

1296
01:26:31,410 --> 01:26:34,770
因为通常我们不想在中断内部使用锁。

1297
01:26:34,800 --> 01:26:37,800
是的，你通过电子邮件问了这个问题。

1298
01:26:37,830 --> 01:26:38,880
是的。

1299
01:26:39,180 --> 01:26:41,010
是的，问题是，

1300
01:26:41,010 --> 01:26:42,750
正如前面提到的，

1301
01:26:42,780 --> 01:26:48,930
底部的中断处理可以和顶部的并行运行。

1302
01:26:49,480 --> 01:26:53,500
所以，一个核心可能正在执行 uartputc ，

1303
01:26:53,710 --> 01:26:56,140
而另一个核心可能正在运行 uartintr ，

1304
01:26:56,530 --> 01:26:59,440
我们要确保它们在某种程度上，

1305
01:26:59,440 --> 01:27:01,390
不会纠缠在一起，

1306
01:27:01,420 --> 01:27:02,590
让它们串行，

1307
01:27:02,590 --> 01:27:04,870
锁确保了它们被序列化。

1308
01:27:05,480 --> 01:27:06,950
好的，有道理，

1309
01:27:06,950 --> 01:27:10,430
但是否意味着有时候

1310
01:27:10,430 --> 01:27:13,160
所有的核心都可能在等待

1311
01:27:13,160 --> 01:27:15,410
其中的一个处理这件事。

1312
01:27:15,590 --> 01:27:15,980
是的。

1313
01:27:17,150 --> 01:27:19,640
是，因为中断必须等待，

1314
01:27:19,640 --> 01:27:22,880
没有什么事情可以调度了。

1315
01:27:22,880 --> 01:27:25,160
一些其他进程可能在运行，

1316
01:27:25,160 --> 01:27:28,070
它不是，这不是死锁，

1317
01:27:28,100 --> 01:27:31,550
好的，有死锁的风险，但不是这个，

1318
01:27:31,760 --> 01:27:33,530
那个我们将在周三谈论。

1319
01:27:34,670 --> 01:27:39,760
但是，它的大概意思是，

1320
01:27:39,760 --> 01:27:43,150
如果有多个调用 uartputc ，

1321
01:27:43,770 --> 01:27:44,820
缓冲区已满，

1322
01:27:45,180 --> 01:27:49,290
然后在某个时刻，这个中断会释放锁。

1323
01:27:50,060 --> 01:27:53,330
让我们回到 uartputc ，

1324
01:27:53,330 --> 01:27:55,280
实际上发生的事情是，

1325
01:27:55,670 --> 01:27:58,070
它们会调用 sleep ，

1326
01:27:58,760 --> 01:28:00,980
而 sleep 使用那个锁作为参数，

1327
01:28:01,010 --> 01:28:02,330
我们后面会知道为什么，

1328
01:28:02,540 --> 01:28:06,710
但是在内部，在 sleep 将进程睡眠之前，

1329
01:28:06,710 --> 01:28:07,910
它会释放锁。

1330
01:28:08,920 --> 01:28:09,670
哦，我明白了，

1331
01:28:09,670 --> 01:28:11,830
所以是调用 sleep 带上锁参数，

1332
01:28:11,830 --> 01:28:14,500
然后意味着可以在睡眠的时候释放锁，

1333
01:28:14,500 --> 01:28:15,820
让其他进程去做。

1334
01:28:16,570 --> 01:28:18,010
好的，有意思。

1335
01:28:18,810 --> 01:28:19,080
是的。

1336
01:28:19,080 --> 01:28:20,820
然后，当从 sleep 返回，

1337
01:28:20,820 --> 01:28:22,920
再次获取，好的。

1338
01:28:23,160 --> 01:28:24,150
重新获得锁。

1339
01:28:24,510 --> 01:28:27,630
对，是的，有道理。

1340
01:28:28,200 --> 01:28:29,640
sleep 也有单独的故事，

1341
01:28:29,640 --> 01:28:31,170
我们将在一周或两周后讨论这个。

1342
01:28:32,100 --> 01:28:33,240
有道理，是的，是的，

1343
01:28:33,270 --> 01:28:36,390
所以我想，

1344
01:28:37,540 --> 01:28:40,240
所以我想这对我来说不是很清楚，

1345
01:28:40,240 --> 01:28:42,790
是不是所有的 CPU 都会被中断，

1346
01:28:42,790 --> 01:28:45,220
当有人通过 UART 发送东西的时候。

1347
01:28:45,870 --> 01:28:47,910
不，要看情况，

1348
01:28:47,970 --> 01:28:50,070
这取决于你怎么对 PLIC 编程，

1349
01:28:50,460 --> 01:28:55,020
xv6 对 PLIC 的编程方式是只有一个 CPU ，

1350
01:28:55,230 --> 01:28:58,630
所有的 CPU 都可能被中断，但是。

1351
01:28:58,630 --> 01:28:59,020
好的。

1352
01:28:59,050 --> 01:29:01,090
只有一个去处理中断。

1353
01:29:03,230 --> 01:29:03,860
好的。

1354
01:29:04,540 --> 01:29:05,770
如果你回到 PLIC ，

1355
01:29:05,770 --> 01:29:08,620
当你获得中断，会调用 plic_claim ，

1356
01:29:08,650 --> 01:29:13,300
那个 CPU 会得到，

1357
01:29:13,820 --> 01:29:16,700
它会得到 IRQ ，

1358
01:29:17,030 --> 01:29:19,820
然后 PLIC 会记住，

1359
01:29:19,820 --> 01:29:21,260
那个 IRQ 正在处理，

1360
01:29:21,260 --> 01:29:22,670
不会把它给其他任何人。

1361
01:29:24,720 --> 01:29:25,560
我明白了，好的，

1362
01:29:25,560 --> 01:29:29,400
所以，它们中的一个会获得它，随机的还是别的。

1363
01:29:31,260 --> 01:29:32,790
你可以编程 PLIC ，

1364
01:29:32,790 --> 01:29:35,790
比如编程到一个 CPU 。

1365
01:29:35,790 --> 01:29:36,420
我明白了。

1366
01:29:37,050 --> 01:29:37,290
PLIC。

1367
01:29:37,290 --> 01:29:37,980
我明白了，

1368
01:29:37,980 --> 01:29:40,950
所以在 PLIC 里面是相关的代码，

1369
01:29:40,950 --> 01:29:43,410
来决定打扰谁。

1370
01:29:44,630 --> 01:29:45,620
是的， PLIC 是一个[]，

1371
01:29:45,800 --> 01:29:47,330
我想 PLIC 里面没有代码。

1372
01:29:47,330 --> 01:29:50,210
是啊，好的。

1373
01:29:50,660 --> 01:29:51,620
CPU 编程。

1374
01:29:51,890 --> 01:29:55,890
我是，是的，好的。

1375
01:29:57,360 --> 01:29:59,850
是的，我想说 PLIC 代码在哪里运行，

1376
01:29:59,850 --> 01:30:01,440
但是，是的，它不是代码，而是硬件，

1377
01:30:01,440 --> 01:30:02,460
好的，理解了。

1378
01:30:02,940 --> 01:30:05,130
谢谢，星期三见。

1379
01:30:06,290 --> 01:30:06,740
好的。

1380
01:30:07,440 --> 01:30:08,880
我有个问题，

1381
01:30:08,910 --> 01:30:14,430
与同时运行多个核心的想法有关。

1382
01:30:15,050 --> 01:30:17,690
我想起其中一个实验，

1383
01:30:17,690 --> 01:30:19,100
在 prime 问题中，

1384
01:30:19,100 --> 01:30:22,970
我们看到实际上是交错输出，

1385
01:30:23,060 --> 01:30:27,800
是不是因为锁只是在 putc ，

1386
01:30:28,850 --> 01:30:32,510
但是来自多个核心的 putc 调用可以交错，

1387
01:30:32,510 --> 01:30:36,200
意味着单个 print[] 不能保证是原子的。

1388
01:30:36,200 --> 01:30:36,740
你是对的。

1389
01:30:37,160 --> 01:30:38,510
好的，理解了。

1390
01:30:39,480 --> 01:30:40,320
好的，谢谢。

1391
01:30:40,560 --> 01:30:41,070
不用谢。

1392
01:30:42,200 --> 01:30:43,160
我有一个简短的问题，

1393
01:30:43,820 --> 01:30:47,210
我记得阅读材料里有，

1394
01:30:47,210 --> 01:30:51,050
阅读材料表示计时器中断是在机器模式下处理的，

1395
01:30:51,680 --> 01:30:55,400
我想知道是在哪里处理的，

1396
01:30:55,400 --> 01:30:56,990
当我们做 traps 实验时，

1397
01:30:57,880 --> 01:31:02,260
比如，在 traps 实验中，在哪里切换到机器模式，

1398
01:31:02,260 --> 01:31:04,330
然后我们在做什么。

1399
01:31:04,880 --> 01:31:06,650
好的，好问题，

1400
01:31:06,650 --> 01:31:09,020
你知道。

1401
01:31:09,870 --> 01:31:12,000
所以我调出代码，

1402
01:31:12,270 --> 01:31:14,400
所以如果你查看 start ，

1403
01:31:14,400 --> 01:31:15,690
有一个 start 运行在 M 模式，

1404
01:31:15,690 --> 01:31:17,790
当机器启动时的开始时间，

1405
01:31:18,320 --> 01:31:21,350
并且它对计时器检查进行编程，

1406
01:31:22,140 --> 01:31:24,180
这是 timerinit

1407
01:31:24,660 --> 01:31:29,460
而 timerinit 对 CLINT 进行编程，

1408
01:31:29,490 --> 01:31:31,080
这是本地中断，

1409
01:31:31,080 --> 01:31:37,600
在时钟中断发生时生成中断，

1410
01:31:37,930 --> 01:31:45,310
这可能是这里最重要的函数，

1411
01:31:45,490 --> 01:31:50,320
它将机器模式的 trap 处理函数设置为这个 timervec 函数，这个名为timervec的函数，

1412
01:31:50,440 --> 01:31:51,850
那是由汇编编写的。

1413
01:31:52,450 --> 01:31:55,120
当计时器中断发生时，

1414
01:31:55,120 --> 01:31:56,470
这个函数会被调用。

1415
01:31:57,210 --> 01:32:01,620
所以，当内核在用户模式或管理模式下运行时，

1416
01:32:01,950 --> 01:32:06,400
CLINT 生成一个中断到达这一行，

1417
01:32:06,790 --> 01:32:10,480
它将切换到机器模式，

1418
01:32:10,480 --> 01:32:11,920
并且调用这个函数 timervec ，

1419
01:32:12,250 --> 01:32:18,160
基本上与管理模式和用户模式中看到的相同。

1420
01:32:18,560 --> 01:32:19,010
好的？

1421
01:32:19,160 --> 01:32:19,820
是的。

1422
01:32:20,120 --> 01:32:24,710
然后，如果你看一下 kernelvec.S 。

1423
01:32:25,360 --> 01:32:27,550
我们看了很多次 kernelvec ，

1424
01:32:27,550 --> 01:32:28,300
我的意思是那个函数，

1425
01:32:28,300 --> 01:32:29,530
看看它是否保存了很多东西。

1426
01:32:29,800 --> 01:32:31,180
这是 timervec ，

1427
01:32:31,870 --> 01:32:34,270
它基本上是类似的想法，

1428
01:32:34,390 --> 01:32:35,740
我们看看它是一些寄存器，

1429
01:32:35,740 --> 01:32:37,000
让它可以完成工作，

1430
01:32:37,390 --> 01:32:40,810
它做的就是在这里编写六行代码，

1431
01:32:41,360 --> 01:32:44,690
或者五行，七行代码，

1432
01:32:44,960 --> 01:32:48,140
它所做的就是对 CLINT 重新编程，

1433
01:32:48,140 --> 01:32:49,670
以生成未来的中断，

1434
01:32:49,820 --> 01:32:54,140
然后向管理程序发出软件中断，

1435
01:32:54,540 --> 01:32:56,670
所以，它将进入管理者模式。

1436
01:32:57,410 --> 01:32:57,860
好吧。

1437
01:32:57,860 --> 01:33:01,250
然后，在 mret 的时候，

1438
01:33:01,790 --> 01:33:06,260
mret ，比如内核使用计时器中断，

1439
01:33:06,260 --> 01:33:07,430
它进入机器模式，

1440
01:33:07,760 --> 01:33:11,210
然后 mret 从机器模式返回到管理者模式，

1441
01:33:11,960 --> 01:33:15,320
如果中断启用了管理者模式，

1442
01:33:15,350 --> 01:33:20,240
这个时刻，可能产生管理者软件中断。

1443
01:33:20,990 --> 01:33:22,070
哦，好的。

1444
01:33:22,160 --> 01:33:24,710
现在，内核也会做同样的事情，

1445
01:33:24,710 --> 01:33:26,540
转到 kernelvec ，

1446
01:33:26,780 --> 01:33:28,730
保存恢复所有寄存器，

1447
01:33:28,970 --> 01:33:33,440
然后转到内核 trap ，

1448
01:33:33,740 --> 01:33:36,560
内核 trap 会看到那是计时器中断。

1449
01:33:37,360 --> 01:33:37,840
我明白了，

1450
01:33:38,020 --> 01:33:41,500
那么切换到机器模式是在哪一点，

1451
01:33:41,530 --> 01:33:43,510
它到底做了什么。

1452
01:33:44,440 --> 01:33:46,360
我不知道在哪一点，

1453
01:33:46,360 --> 01:33:48,280
这是硬件工作。

1454
01:33:48,670 --> 01:33:50,530
好的，知道了。

1455
01:33:50,980 --> 01:33:53,830
实际上做得更多一点，

1456
01:33:53,830 --> 01:33:57,040
是的，这里有一些原因，

1457
01:33:57,040 --> 01:34:01,000
我想为什么在机器模式使用计时器，

1458
01:34:01,000 --> 01:34:03,040
但从我们的角度来看，

1459
01:34:03,480 --> 01:34:04,440
这很好，

1460
01:34:04,440 --> 01:34:08,100
如果我们能把定时器中断交给管理者模式，

1461
01:34:08,100 --> 01:34:10,350
而不用处理定时器模式，

1462
01:34:10,380 --> 01:34:14,310
但是，对这个特殊的芯片是不起作用的。

1463
01:34:14,930 --> 01:34:17,000
好的，有道理，非常感谢。

1464
01:34:17,300 --> 01:34:17,930
不用谢。

1465
01:34:19,300 --> 01:34:23,140
哦，我有一个关于这部分的跟进问题。

1466
01:34:23,710 --> 01:34:26,140
请继续你的问题。

1467
01:34:26,140 --> 01:34:28,330
好的。

1468
01:34:28,760 --> 01:34:35,180
我看到它分配了 32 个 uint64 ，

1469
01:34:35,180 --> 01:34:40,970
但是它似乎只用了四个或三个，

1470
01:34:41,000 --> 01:34:41,150
嗯。

1471
01:34:41,150 --> 01:34:44,330
在 start.c 中。

1472
01:34:44,940 --> 01:34:45,900
在 scratch ，

1473
01:34:45,900 --> 01:34:48,960
是的，我想它分配的比需要的多，

1474
01:34:48,960 --> 01:34:53,670
32 个暂存区域，

1475
01:34:53,700 --> 01:34:55,200
原因是，

1476
01:34:55,200 --> 01:35:01,800
对于每一个 CPU ，

1477
01:35:01,920 --> 01:35:04,350
必须有一些暂存空间，

1478
01:35:04,380 --> 01:35:08,610
我想那里有三个或类似的 CPU ，

1479
01:35:08,610 --> 01:35:10,650
所以多分配一点，

1480
01:35:17,970 --> 01:35:21,120
但不会[]分配太多。

1481
01:35:22,260 --> 01:35:27,300
好的，比如，它只用 scratch[0] scratch[1] scratch[1] ，

1482
01:35:27,300 --> 01:35:30,300
不，我想是使用 3 ，

1483
01:35:30,300 --> 01:35:32,760
从 0 到 3 ，是四个，

1484
01:35:32,970 --> 01:35:34,980
4 和 5 是六个，

1485
01:35:35,360 --> 01:35:37,670
所以是六个整数，

1486
01:35:38,030 --> 01:35:43,670
我想，我们可以运行四个 CPU ，

1487
01:35:43,670 --> 01:35:44,690
但我们运行了三个，

1488
01:35:44,690 --> 01:35:45,920
但我们可以运行四个。

1489
01:35:47,840 --> 01:35:49,340
所以 6 乘以 24 ，

1490
01:35:49,340 --> 01:35:52,730
我想肯定分配了太多内存。

1491
01:35:54,090 --> 01:35:56,160
我不记得，不久前我想过这件事，

1492
01:35:56,160 --> 01:36:04,220
我也记不清 32 是从哪里来的了。

1493
01:36:05,290 --> 01:36:07,540
所以，我们需要再检查一遍。

1494
01:36:08,660 --> 01:36:09,980
你可以重建它。

1495
01:36:41,430 --> 01:36:48,360
哦，是的，保存恢复，都是 8 字节的。

1496
01:36:49,520 --> 01:36:50,270
是的。

1497
01:36:53,190 --> 01:36:55,140
还有，它。

1498
01:37:03,830 --> 01:37:05,750
好的，我晚点给你说，

1499
01:37:05,750 --> 01:37:08,000
我现在想不起来了，

1500
01:37:08,000 --> 01:37:09,380
为什么是这样的。

1501
01:37:10,450 --> 01:37:13,900
好的，有道理，非常感谢。

1502
01:37:14,050 --> 01:37:15,220
不客气，问得好。

1503
01:37:15,580 --> 01:37:16,750
谢谢。

