1
00:00:05,470 --> 00:00:08,080
Alright, I'd like to get started,

2
00:00:08,140 --> 00:00:09,640
can anyone hear me?

3
00:00:10,750 --> 00:00:11,290
Yep loud and clear.

4
00:00:12,270 --> 00:00:14,550
Alright, so today my plan is

5
00:00:14,550 --> 00:00:16,320
for first I want to spend a few minutes

6
00:00:16,320 --> 00:00:21,600
re-emphasizing some points from the lecture last week on thread switching,

7
00:00:21,600 --> 00:00:23,760
because they turned out to be important points,

8
00:00:23,760 --> 00:00:28,500
and I would spend most of the lecture talking about something called coordination

9
00:00:29,130 --> 00:00:32,850
which is the larger term for xv6 sleeping wakeup mechanism

10
00:00:33,000 --> 00:00:36,030
and particularly I'm going to talk about the lost wakeup problem.

11
00:00:36,900 --> 00:00:42,810
Alright, so, one, one point I want to just mention again is that,

12
00:00:46,620 --> 00:00:51,570
is the fact that xv6 whenever anything calls switch

13
00:00:51,570 --> 00:00:54,570
to switch from one thread to another,

14
00:00:54,720 --> 00:00:57,420
usually from a kernel thread to the scheduler thread,

15
00:00:57,630 --> 00:01:05,070
it's always preceded by an acquire of this process's lock.

16
00:01:06,050 --> 00:01:09,410
So process requires this lock call swtch,

17
00:01:09,710 --> 00:01:11,780
which always switches into the scheduler

18
00:01:11,780 --> 00:01:13,700
and it's the scheduler that releases the lock.

19
00:01:14,730 --> 00:01:19,620
In fact almost always the sequence looks more like this

20
00:01:19,680 --> 00:01:22,680
or a process who wants to go to sleep for some reason,

21
00:01:22,680 --> 00:01:24,660
it's yielding the CPU for waiting for something

22
00:01:24,840 --> 00:01:26,670
and it acquires a lock on itself,

23
00:01:26,700 --> 00:01:28,530
it sets its state,

24
00:01:30,660 --> 00:01:32,250
and there's a number of different states,

25
00:01:32,250 --> 00:01:34,230
what we see we saw last week was,

26
00:01:34,260 --> 00:01:39,360
set state to runnable instead of running,

27
00:01:39,660 --> 00:01:41,490
and then call swtch

28
00:01:41,850 --> 00:01:44,820
or sched which itself calls swtch.

29
00:01:45,910 --> 00:01:53,320
And that you know this switch basically switches threads over into the scheduler thread,

30
00:01:53,900 --> 00:01:56,750
which so as previous call to swtch,

31
00:01:56,750 --> 00:01:59,390
this scheduler thread returns.

32
00:02:00,390 --> 00:02:10,960
And then this was scheduler thread calls release on the lock of the process,

33
00:02:10,960 --> 00:02:12,910
that's just yielded the CPU.

34
00:02:16,370 --> 00:02:20,510
The reason for this, just to repeat, is that,

35
00:02:22,130 --> 00:02:25,010
the acquisition of this lock on the process

36
00:02:25,010 --> 00:02:27,890
prevents the scheduler on a different core

37
00:02:27,980 --> 00:02:33,080
from from looking right at this point in time,

38
00:02:33,080 --> 00:02:37,880
and saying that, oh this thread is runnable and trying to run it,

39
00:02:38,120 --> 00:02:40,880
because every other core maybe running a scheduler loop,

40
00:02:41,330 --> 00:02:45,150
which is continually looping over the process table,

41
00:02:45,180 --> 00:02:46,650
looking for runnable threads,

42
00:02:46,740 --> 00:02:49,740
so any one of them may see that this thread is runnable,

43
00:02:50,010 --> 00:02:52,260
if we hadn't acquired the process lock,

44
00:02:52,530 --> 00:02:54,450
so the fact that we acquired the process lock means

45
00:02:54,450 --> 00:02:57,930
that the other schedulers, before they even look at a process of state,

46
00:02:58,080 --> 00:02:59,520
must acquire its lock.

47
00:02:59,520 --> 00:03:01,290
So we know after this acquisition,

48
00:03:01,350 --> 00:03:03,120
no other threads going to look at the lock.

49
00:03:03,240 --> 00:03:05,460
We can't give up the lock here though,

50
00:03:05,460 --> 00:03:08,010
we can't give up the lock before calling swtch,

51
00:03:08,010 --> 00:03:09,870
that is this thread acquires the lock,

52
00:03:09,870 --> 00:03:10,920
but it can't give it up,

53
00:03:11,130 --> 00:03:12,300
because if we did,

54
00:03:12,300 --> 00:03:14,250
then right after we gave it up,

55
00:03:14,340 --> 00:03:18,750
some other core scheduler would probably start running this process,

56
00:03:18,780 --> 00:03:22,530
even though the thread is currently running on this core.

57
00:03:22,960 --> 00:03:26,860
And having two cores run the same thread, using the same stack,

58
00:03:26,860 --> 00:03:30,680
is would cause a pretty instant crash.

59
00:03:31,980 --> 00:03:34,860
And therefore the process acquires lock

60
00:03:34,890 --> 00:03:36,450
and does release it at called swtch

61
00:03:36,450 --> 00:03:40,890
and different thread, namely the scheduler thread actually releases the lock,

62
00:03:40,920 --> 00:03:45,030
at a point after this thread has completely stopped using its own stack,

63
00:03:45,060 --> 00:03:51,310
so at this point, it's okay for another core scheduler running this thread,

64
00:03:51,310 --> 00:03:53,770
because the thread is now no longer running

65
00:03:54,070 --> 00:03:56,950
and has given up given up the processor.

66
00:03:58,920 --> 00:04:00,720
Okay, so that's an important point

67
00:04:01,050 --> 00:04:02,820
and it'll come up in a few minutes,

68
00:04:02,820 --> 00:04:04,200
it's one of the many constraints

69
00:04:04,200 --> 00:04:07,650
on the design of the sleep wakeup coordination scheme.

70
00:04:09,040 --> 00:04:14,720
Any questions about this holding of the p->lock across switch?

71
00:04:19,200 --> 00:04:20,310
Yeah, if.

72
00:04:20,920 --> 00:04:21,490
Yes.

73
00:04:21,580 --> 00:04:23,710
When we have multiple cores,

74
00:04:23,770 --> 00:04:27,820
the only reason they're able to have the same view of the lock is,

75
00:04:27,820 --> 00:04:31,600
because there's a single shared physical memory system right?

76
00:04:31,840 --> 00:04:32,800
That is correct.

77
00:04:33,610 --> 00:04:36,250
So, is there like implementations

78
00:04:36,250 --> 00:04:38,380
where there's weird file systems,

79
00:04:38,380 --> 00:04:40,510
that can guarantee this [adversity]

80
00:04:40,510 --> 00:04:41,320
so we can [lock].

81
00:04:43,510 --> 00:04:49,130
If you buy two computers, then they don't share memory, right,

82
00:04:49,190 --> 00:04:51,980
so that's one way to do if you buy two separate computers,

83
00:04:51,980 --> 00:04:53,390
then they won't share memory

84
00:04:53,390 --> 00:04:55,580
and we won't have any of these problems.

85
00:04:57,020 --> 00:05:00,610
It's just that the way processor chips look,

86
00:05:00,610 --> 00:05:04,780
these days, there's always multiple cores on a single processor chip

87
00:05:04,780 --> 00:05:10,720
and so the hardware just is built to have multiple cores sharing the same memory system.

88
00:05:12,340 --> 00:05:13,960
Oh I see, thanks.

89
00:05:17,750 --> 00:05:20,940
Okay, so that's one point.

90
00:05:22,540 --> 00:05:23,440
Another point,

91
00:05:23,470 --> 00:05:25,480
I don't think I've mentioned yet,

92
00:05:25,480 --> 00:05:28,780
has to do with the fact that

93
00:05:29,080 --> 00:05:36,490
in xv6, a process is not allowed to hold any other lock when it calls swtch.

94
00:05:36,950 --> 00:05:41,180
A process is required to hold p->lock when it called swtch,

95
00:05:41,720 --> 00:05:45,320
but it is forbidden to hold any other lock when it calls swtch,

96
00:05:45,350 --> 00:05:47,090
so this is another important constraint

97
00:05:47,090 --> 00:05:49,100
on the design of many things,

98
00:05:49,100 --> 00:05:51,700
including how sleep is going to work.

99
00:05:51,730 --> 00:05:54,280
So now let me lay out the reasoning for this,

100
00:05:54,280 --> 00:06:04,220
so it's no other locks, when you call swtch.

101
00:06:07,980 --> 00:06:12,120
A scenario, sort of illustrating why this is this rule has to be enforced,

102
00:06:12,120 --> 00:06:13,440
and this is a rule that,

103
00:06:14,020 --> 00:06:17,340
you know, if you're, extending,

104
00:06:17,340 --> 00:06:19,800
you know you're a programmer developing the xv6 kernel

105
00:06:19,800 --> 00:06:22,950
have to follow this rule along with many other rules.

106
00:06:24,340 --> 00:06:26,050
So the justification for this rule

107
00:06:26,080 --> 00:06:30,460
supposing we have process one or the kernel thread for process one

108
00:06:30,610 --> 00:06:32,830
and it acquires some lock,

109
00:06:33,560 --> 00:06:35,750
you know not impressive, but just some lock,

110
00:06:35,750 --> 00:06:39,320
maybe it's using the disk or using the uart to console

111
00:06:39,320 --> 00:06:41,090
and acquire some lock.

112
00:06:41,680 --> 00:06:43,960
And supposing it did then,

113
00:06:44,470 --> 00:06:48,190
give up the CPU by calling swtch or yield or sched or something,

114
00:06:48,190 --> 00:06:49,840
while still holding this lock.

115
00:06:50,570 --> 00:06:53,270
So now p1 holds lock,

116
00:06:53,270 --> 00:06:55,010
this lock held, but it's not running.

117
00:06:56,310 --> 00:06:58,050
And imagine also for a moment

118
00:06:58,050 --> 00:07:00,450
that we're on a machine with just a single core.

119
00:07:01,600 --> 00:07:02,950
So there's only one core,

120
00:07:03,130 --> 00:07:06,220
the process one called swtch which transfers the scheduler,

121
00:07:06,220 --> 00:07:09,850
the scheduler sees aha process two's kernel thread is waiting to run

122
00:07:10,090 --> 00:07:11,980
and so the scheduler switches the process,

123
00:07:12,010 --> 00:07:14,800
starts running process to two, switches to process two

124
00:07:15,100 --> 00:07:16,870
and supposing process two for whatever reason,

125
00:07:16,870 --> 00:07:20,770
maybe it also wants to use the disk or use that uart or something

126
00:07:20,890 --> 00:07:23,980
and it calls acquire on the same lock,

127
00:07:27,700 --> 00:07:30,490
so we have a second acquire of this lock,

128
00:07:30,640 --> 00:07:32,830
it's the same the same lock.

129
00:07:33,360 --> 00:07:34,980
Of course, the lock already held,

130
00:07:34,980 --> 00:07:36,240
so this acquire can't get it,

131
00:07:36,360 --> 00:07:37,860
these are spin locks,

132
00:07:37,890 --> 00:07:40,320
so what this actually causes to happen is that

133
00:07:40,350 --> 00:07:44,400
process two inside acquire will just sit in a loop

134
00:07:44,400 --> 00:07:46,740
spinning waiting for the lock to be released.

135
00:07:47,280 --> 00:07:48,720
And acquire won't return

136
00:07:48,750 --> 00:07:50,370
and since acquire doesn't return,

137
00:07:50,430 --> 00:07:52,530
process two can't, doesn't have a chance,

138
00:07:52,530 --> 00:07:56,130
even though it may be willing to yield the CPU when it's done later on,

139
00:07:56,250 --> 00:07:57,420
it doesn't get a chance to,

140
00:07:57,420 --> 00:08:00,600
because the acquire doesn't return until the lock is released.

141
00:08:00,810 --> 00:08:03,270
You know, but the only way the lock could be released is

142
00:08:03,270 --> 00:08:06,870
if process one resumes execution,

143
00:08:06,870 --> 00:08:12,670
and presumably later, it's correctly, it doesn't have terrible bugs in it,

144
00:08:12,820 --> 00:08:17,170
it was going to call it was intending to release this lock right,

145
00:08:17,170 --> 00:08:18,370
but it hasn't happened yet,

146
00:08:18,910 --> 00:08:20,200
because it's called swtch

147
00:08:20,230 --> 00:08:22,630
and process two is spinning waiting for the lock,

148
00:08:22,630 --> 00:08:24,820
so this is a deadlock, right,

149
00:08:25,700 --> 00:08:30,980
and it will just cause the system to freeze.

150
00:08:34,570 --> 00:08:36,580
And while I described this in the context

151
00:08:36,580 --> 00:08:39,280
of a machine with a single CPU, a single core,

152
00:08:39,880 --> 00:08:41,620
you can construct scenarios

153
00:08:41,620 --> 00:08:46,980
that using multiple locks would cause this same kind of deadlock

154
00:08:47,010 --> 00:08:48,750
on a machine with multiple cores.

155
00:08:49,980 --> 00:08:54,180
And so as a result, we have a general prohibition in xv6,

156
00:08:54,180 --> 00:08:59,120
that you're not allowed to hold spin locks across the swtch.

157
00:09:01,060 --> 00:09:02,320
Any questions about this rule?

158
00:09:06,720 --> 00:09:07,230
There's a question in the chat Robert.

159
00:09:07,950 --> 00:09:12,540
Oh, would you have a timer interrupt, switch to p1 which resolves the deadlock.

160
00:09:12,840 --> 00:09:15,360
Okay so, yet, it does turn out,

161
00:09:15,360 --> 00:09:18,810
so we're running, both all the stuffs running in the kernel right,

162
00:09:18,810 --> 00:09:22,650
you know acquire release which you know only so kernel code,

163
00:09:22,650 --> 00:09:23,820
so not running in user space,

164
00:09:23,820 --> 00:09:27,060
but indeed a timer interrupt could occur

165
00:09:27,090 --> 00:09:33,690
and xv6 is actually allows timer interrupts to happen

166
00:09:33,690 --> 00:09:37,440
in while running kernel code, system call code

167
00:09:37,500 --> 00:09:41,160
and in fact if you look at the kernel trap code

168
00:09:41,160 --> 00:09:42,780
or whatever it is in trap.c,

169
00:09:42,870 --> 00:09:45,450
you'll see that if a timer interrupt happens,

170
00:09:45,450 --> 00:09:47,970
while xv6 is executing the kernel,

171
00:09:47,970 --> 00:09:49,200
it will call yield.

172
00:09:49,480 --> 00:09:52,120
So if a timer interrupt could happen,

173
00:09:52,240 --> 00:09:54,070
while we're running acquire here,

174
00:09:54,490 --> 00:09:58,280
then actually we would be saved,

175
00:09:58,280 --> 00:10:00,650
because we call yield switch back here

176
00:10:00,650 --> 00:10:03,470
and hopefully p1 would then resume and eventually release the lock,

177
00:10:03,500 --> 00:10:08,630
however, for reasons that were explained in a previous lecture,

178
00:10:08,690 --> 00:10:13,820
acquire turns off interrupts before it starts to wait for the lock,

179
00:10:13,820 --> 00:10:16,070
because we absolutely for other reasons,

180
00:10:16,070 --> 00:10:20,600
cannot afford to have an interrupt happen while we're holding a lock,

181
00:10:20,630 --> 00:10:22,940
because that would cause a different kind of deadlock.

182
00:10:23,340 --> 00:10:29,150
It's the interrupt handler, needed to use, needed to acquire the lock,

183
00:10:29,510 --> 00:10:34,270
that this acquire had possibly just acquired,

184
00:10:34,450 --> 00:10:36,640
so if you look at the code for acquire xv6,

185
00:10:36,790 --> 00:10:40,240
you'll see the first thing it does is turn off interrupts and then spins

186
00:10:40,390 --> 00:10:44,140
and you may wonder those, why doesn't it spin and then turn off interrupts

187
00:10:44,140 --> 00:10:47,380
and the reason is that would allow a short period of time to occur

188
00:10:47,380 --> 00:10:50,710
in which the lock is held, but interrupts weren't disabled

189
00:10:50,950 --> 00:10:54,730
and again device interrupted that time might cause a deadlock.

190
00:10:55,260 --> 00:10:56,130
So, unfortunately,

191
00:10:56,130 --> 00:10:59,220
this other requirement that we leave interrupts off

192
00:10:59,220 --> 00:11:00,750
while we're spinning waiting for lock

193
00:11:00,810 --> 00:11:03,420
prevents the timer interrupt from going off

194
00:11:03,420 --> 00:11:06,870
and therefore prevents process two from yielding back to process one.

195
00:11:07,970 --> 00:11:08,720
That's a good question.

196
00:11:11,060 --> 00:11:11,870
Okay so another question,

197
00:11:11,870 --> 00:11:14,780
can I repeat how deadlocks are avoided?

198
00:11:19,440 --> 00:11:22,800
Oh, deadlocks are avoided in xv6 by prohibiting this,

199
00:11:24,150 --> 00:11:29,720
xv6 code is not allowed to acquire any lock other than p->lock,

200
00:11:29,750 --> 00:11:31,040
and then call swtch

201
00:11:31,250 --> 00:11:32,570
and if you look at the code for swtch,

202
00:11:32,570 --> 00:11:35,010
there's actually some checks in swtch,

203
00:11:35,010 --> 00:11:39,240
that are equivalent to checking that no locks are held other than p->lock.

204
00:11:40,020 --> 00:11:42,150
So the problem with this is this code,

205
00:11:43,000 --> 00:11:45,370
if it occurred in the xv6 kernel would be illegal

206
00:11:45,370 --> 00:11:47,470
and would could easily cause a deadlock,

207
00:11:47,710 --> 00:11:48,520
so it's forbidden.

208
00:11:50,190 --> 00:11:51,240
As that answered the question?ï¼ŒOkay.

209
00:11:54,920 --> 00:11:55,850
Other questions?

210
00:12:01,580 --> 00:12:03,740
Okay, okay, so keep this rule

211
00:12:03,740 --> 00:12:07,970
and previous need to hold p->lock across switch in mind,

212
00:12:08,000 --> 00:12:09,500
because they'll come up again

213
00:12:09,590 --> 00:12:12,410
in our discussion of how sleep and wakeup work.

214
00:12:15,160 --> 00:12:23,650
Alright new topic, coordination,

215
00:12:29,370 --> 00:12:36,220
which really means sleep/-, the.

216
00:12:40,450 --> 00:12:41,830
We've heard a lot about locks

217
00:12:41,830 --> 00:12:44,020
and locks are fantastic for situations

218
00:12:44,020 --> 00:12:47,290
where different threads really want to not be aware

219
00:12:47,290 --> 00:12:49,960
and not have to worry about or think about what other threads are up to,

220
00:12:50,260 --> 00:12:51,550
we hold locks and share data,

221
00:12:51,640 --> 00:12:54,220
that means we just never have to worry about the possibility

222
00:12:54,220 --> 00:12:58,060
that some other lock is is or maybe not, who knows, using that data,

223
00:12:58,060 --> 00:13:01,240
because the lock, so it causes things to happen one at a time,

224
00:13:01,630 --> 00:13:04,270
but when you're writing threaded code,

225
00:13:04,300 --> 00:13:09,940
there are also situations where you explicitly want to wait for some specific event

226
00:13:09,940 --> 00:13:12,430
where you want different threads to interact.

227
00:13:14,530 --> 00:13:18,180
So, for example, supposing, we have pipes

228
00:13:18,180 --> 00:13:20,040
and we got a reader and a writer right,

229
00:13:20,040 --> 00:13:21,840
if I'm reading a pipe,

230
00:13:22,360 --> 00:13:24,370
and there's nothing currently to read in the pipe,

231
00:13:24,550 --> 00:13:28,780
I want to be able to wait for any other process to write data to the pipe,

232
00:13:28,780 --> 00:13:32,200
I want to wait for this sort of pipe is not empty event.

233
00:13:32,620 --> 00:13:37,560
Similarly if I'm reading the disk, or writing the disk.

234
00:13:41,650 --> 00:13:42,640
If I'm reading the disk,

235
00:13:42,640 --> 00:13:45,190
then I want to be able to tell the disk controller,

236
00:13:45,190 --> 00:13:47,620
look, please read a particular block on the disk,

237
00:13:47,740 --> 00:13:49,720
it may take a long time milliseconds,

238
00:13:49,840 --> 00:13:53,290
long long time before the disk finally finishes the read,

239
00:13:53,290 --> 00:13:55,120
especially if it has to seek and rotate

240
00:13:56,200 --> 00:14:00,280
and the process is doing the read needs to be able to wait for that specific event,

241
00:14:00,430 --> 00:14:02,590
we want to wait for the disk read to complete.

242
00:14:05,330 --> 00:14:07,610
Similarly you may have noticed,

243
00:14:07,610 --> 00:14:12,410
when you're programming, that a unix program can make the wait system call.

244
00:14:12,950 --> 00:14:14,570
And what wait does is

245
00:14:14,570 --> 00:14:18,500
it causes the calling process to wait, until any of its children exit,

246
00:14:18,530 --> 00:14:22,070
so here we have the parent process intentionally waiting

247
00:14:22,100 --> 00:14:24,830
for some event sort of caused by another process.

248
00:14:25,490 --> 00:14:30,020
So these are all situations where a process needs to wait for a specific event

249
00:14:30,020 --> 00:14:33,260
either typically IO or another process,

250
00:14:33,290 --> 00:14:37,610
sort of declaring that something specific has happened.

251
00:14:39,190 --> 00:14:41,950
And coordination is the sort of tool

252
00:14:41,950 --> 00:14:44,830
that helps us solve these kind of problems

253
00:14:44,980 --> 00:14:47,440
or implement these kind of requirements

254
00:14:47,830 --> 00:14:50,200
and coordination is totally fundamental,

255
00:14:50,200 --> 00:14:54,520
just just like with locks, coordination is another fundamental tool

256
00:14:54,520 --> 00:14:56,470
for writing threaded programs

257
00:14:56,470 --> 00:14:58,190
and it comes up all the time.

258
00:14:59,520 --> 00:15:06,930
Alright, so, how could we have a process or a thread wait for this kind of event,

259
00:15:07,140 --> 00:15:12,210
so one possibility is extremely straightforward one is

260
00:15:12,210 --> 00:15:14,800
just a busy wait to loop,

261
00:15:15,770 --> 00:15:17,030
so you could imagine.

262
00:15:18,570 --> 00:15:20,430
And we'll discard this as a bad idea in a moment,

263
00:15:20,430 --> 00:15:23,520
but let's say we want to read from a pipe,

264
00:15:23,580 --> 00:15:26,130
we just write a loop in the pipe read function

265
00:15:26,130 --> 00:15:31,510
that says you know while you know the pipe buffer is empty,

266
00:15:33,050 --> 00:15:39,070
we're gonna do absolutely nothing, right,

267
00:15:39,130 --> 00:15:42,220
now we're gonna let sit in this loop going around around in this loop,

268
00:15:42,340 --> 00:15:45,070
until maybe some other thread on another core

269
00:15:45,130 --> 00:15:47,320
writes into the buffer and makes it not empty

270
00:15:47,320 --> 00:15:48,340
and then this loop will finish

271
00:15:48,340 --> 00:15:49,990
and then we'll return the data

272
00:15:50,020 --> 00:15:52,120
or whatever it is we're supposed to do with the data.

273
00:15:56,700 --> 00:15:57,990
So you imagine writing code like this

274
00:15:57,990 --> 00:15:59,670
and actually there is a little bit of,

275
00:15:59,790 --> 00:16:02,460
there may be you know small amount of code like this,

276
00:16:02,460 --> 00:16:07,920
like if you know that the thing you're waiting for is extremely likely to happen

277
00:16:07,920 --> 00:16:09,750
and a tenth of a microsecond,

278
00:16:09,750 --> 00:16:12,810
let's say this may be the best way to wait for it,

279
00:16:13,110 --> 00:16:17,610
so typically this is done with some kind of device hardware.

280
00:16:18,520 --> 00:16:20,530
When you ask the device hardware to do something,

281
00:16:20,530 --> 00:16:24,490
you know it will always complete that task in a tiny amount of time,

282
00:16:25,870 --> 00:16:29,170
just sitting in a short loop can be the right answer.

283
00:16:29,200 --> 00:16:32,200
But if this might take a long time milliseconds,

284
00:16:32,200 --> 00:16:33,730
or you just don't know how long right,

285
00:16:33,940 --> 00:16:35,920
maybe it's going to be ten minutes

286
00:16:35,920 --> 00:16:40,270
before whatever process is writing the pipe actually writes anything,

287
00:16:40,330 --> 00:16:43,030
then we don't want to spin there and waste CPU time,

288
00:16:43,060 --> 00:16:47,890
which could be used to find more digits of pi or something else useful,

289
00:16:48,190 --> 00:16:51,010
we want to give up the CPU instead.

290
00:16:52,060 --> 00:16:56,320
And only we want some way to give up the CPU like swtch,

291
00:16:56,350 --> 00:17:00,730
but actually regain the CPU when the event we care about has actually occurred

292
00:17:00,790 --> 00:17:04,060
and it's that that coordination is all about techniques

293
00:17:04,060 --> 00:17:10,030
to give up the CPU until the condition, the event that we're waiting for has actually occurred.

294
00:17:10,620 --> 00:17:14,280
And again sleep and wakeup,

295
00:17:14,280 --> 00:17:16,800
there's a number of different coordination primitives

296
00:17:16,800 --> 00:17:18,630
that people have invented over the years.

297
00:17:20,200 --> 00:17:24,070
And xv6 in common with many flavors of Unix,

298
00:17:24,640 --> 00:17:26,260
uses something called sleep and wakeup.

299
00:17:27,290 --> 00:17:30,580
Okay, alright, with this background,

300
00:17:30,580 --> 00:17:36,940
I'd like to switch to a looking at code in xv6.

301
00:17:41,940 --> 00:17:45,810
Alright, so I just shared my screen,

302
00:17:45,930 --> 00:17:49,800
let me know if the screen share did on work.

303
00:17:50,460 --> 00:17:53,250
Okay, I have in preparation for this lecture,

304
00:17:53,580 --> 00:17:58,620
rewritten some of the code in the uart driver,

305
00:17:58,650 --> 00:18:04,770
that's the serial driver that xv6 uses to read and write characters from the console,

306
00:18:05,580 --> 00:18:07,290
so I have this function uartwrite,

307
00:18:07,290 --> 00:18:12,210
which when a program like the shell prints its prompt or produces any other output,

308
00:18:12,990 --> 00:18:14,790
that makes a write system call

309
00:18:14,790 --> 00:18:17,580
and in my slightly modified version of xv6

310
00:18:17,610 --> 00:18:21,270
that write system call ends up with a call to uartwrite,

311
00:18:21,360 --> 00:18:22,560
in the uart driver

312
00:18:22,560 --> 00:18:29,040
which actually writes the characters in this loop one by one to the uart hardware.

313
00:18:31,740 --> 00:18:35,970
And this is written in a sort of classic device driver style.

314
00:18:37,480 --> 00:18:40,570
You'll see code like this in many device drivers.

315
00:18:41,920 --> 00:18:44,620
Okay, so one of the things that's going on here is

316
00:18:44,620 --> 00:18:50,260
that the uart hardware can only accept one character for transmission at a time,

317
00:18:50,530 --> 00:18:52,210
and so the way this code has to look,

318
00:18:52,330 --> 00:18:54,700
typically have lots of characters you want to write,

319
00:18:55,420 --> 00:18:57,400
it can write a character to the uart hardware,

320
00:18:57,790 --> 00:18:59,530
and it needs to wait for the uart hardware

321
00:18:59,530 --> 00:19:01,780
to say yes I finished sending that character,

322
00:19:01,780 --> 00:19:02,740
I'm ready for a new one

323
00:19:02,740 --> 00:19:04,990
and then the driver can write a new one,

324
00:19:05,640 --> 00:19:07,830
a new character the next character to output,

325
00:19:08,160 --> 00:19:11,970
because this hardware can operate very slowly,

326
00:19:12,000 --> 00:19:14,670
like maybe only a thousand characters per second,

327
00:19:14,850 --> 00:19:18,720
the amount of time we have to wait between characters can be very long,

328
00:19:18,780 --> 00:19:21,750
in milliseconds in a long, long time, on modern computer,

329
00:19:21,750 --> 00:19:25,650
it's you know a billion cycles a million cycles maybe,

330
00:19:26,250 --> 00:19:27,870
which a huge amount of work could be done,

331
00:19:27,870 --> 00:19:30,690
so we'd really prefer not to just spin

332
00:19:30,720 --> 00:19:33,330
waiting for the uart to finish sending each character.

333
00:19:33,710 --> 00:19:35,480
We like to have a better way,

334
00:19:35,630 --> 00:19:41,400
and so in fact, xv6 has a better way like most operating systems,

335
00:19:41,460 --> 00:19:47,910
the uart hardware will raise an interrupt after it's finished sending each character,

336
00:19:48,120 --> 00:19:50,910
and so we have not just this write routine,

337
00:19:51,510 --> 00:19:53,730
we'll see uart driver has an interrupt routine

338
00:19:53,880 --> 00:19:56,040
which I think trap.c calls

339
00:19:56,040 --> 00:20:00,420
when the uart hardware raises an interrupt to say that it's finished

340
00:20:00,420 --> 00:20:03,520
and the interrupt routine checks that uart

341
00:20:03,520 --> 00:20:07,090
to read one of the memory mapped registers in the uart hardware

342
00:20:07,480 --> 00:20:10,450
to look for the flag that says I'm done transmitting,

343
00:20:10,510 --> 00:20:13,030
which is this LSR_TX_IDLE flag,

344
00:20:13,180 --> 00:20:14,740
and if that flag set,

345
00:20:14,800 --> 00:20:20,230
then the interrupt routine actually sets this flag in memory,

346
00:20:21,020 --> 00:20:22,850
and makes this wakeup call

347
00:20:23,000 --> 00:20:26,210
which will calls the uartwrite,

348
00:20:26,270 --> 00:20:27,830
whatever thread is in uartwrtie,

349
00:20:27,830 --> 00:20:30,830
to return from its sleep here

350
00:20:30,980 --> 00:20:34,040
and attempt to send a new character.

351
00:20:34,930 --> 00:20:36,070
So the game is that,

352
00:20:37,020 --> 00:20:39,030
if a thread needs to wait for something

353
00:20:39,030 --> 00:20:42,300
and here we are, we need to wait for the uart hardware

354
00:20:42,300 --> 00:20:43,980
to be willing to accept a new character

355
00:20:44,010 --> 00:20:48,120
to call sleep waiting for a specific condition, usually,

356
00:20:48,270 --> 00:20:51,690
and when the condition is fulfilled,

357
00:20:51,960 --> 00:20:55,620
code that realizes the condition is fulfilled what called wakeup.

358
00:20:56,210 --> 00:20:57,980
So these sleeps and wakeups are paired.

359
00:20:58,890 --> 00:21:01,620
And sleep will look at the implementation by and by,

360
00:21:01,620 --> 00:21:03,240
but sleep does a number of things

361
00:21:03,240 --> 00:21:06,840
and then calls swtch in order to give up the CPU.

362
00:21:08,800 --> 00:21:10,690
One thing to notice is

363
00:21:10,690 --> 00:21:14,170
that the wakeup and sleep have to be linked together somehow,

364
00:21:14,200 --> 00:21:16,180
that is we call wakeup,

365
00:21:16,210 --> 00:21:20,380
we really only want to wakeup threads that are waiting for the specific event,

366
00:21:20,380 --> 00:21:21,760
that we realize has happened

367
00:21:21,940 --> 00:21:24,490
and so sleep and wakeup take this argument

368
00:21:25,010 --> 00:21:27,590
which is called the sleep channel,

369
00:21:27,830 --> 00:21:34,250
it's wakeup supplies the very same value here, that we're passing to sleep,

370
00:21:34,280 --> 00:21:36,920
sleep and wakeup actually don't really look,

371
00:21:37,010 --> 00:21:38,660
don't care what these these,

372
00:21:38,660 --> 00:21:41,030
they just take 64 bit values here,

373
00:21:41,030 --> 00:21:42,200
they don't care what they are really,

374
00:21:43,010 --> 00:21:44,870
the only thing that's going on is that,

375
00:21:46,170 --> 00:21:54,600
when if we sleep on that particular sleep channels, particular wait channel,

376
00:21:55,500 --> 00:21:59,010
we want to wakeup to pass the very same value here,

377
00:21:59,010 --> 00:22:02,940
in order to show that indicate which sleepers it wants to wakeup.

378
00:22:06,020 --> 00:22:07,760
Any questions about this interface?

379
00:22:08,000 --> 00:22:09,050
Okay.

380
00:22:10,570 --> 00:22:12,490
So there's a question just to clarify

381
00:22:12,490 --> 00:22:16,530
the process is not woken up every for every character that's written.

382
00:22:20,550 --> 00:22:21,810
Okay, let's see,

383
00:22:21,870 --> 00:22:26,430
in this driver that I've specially hacked for demonstration purposes,

384
00:22:27,570 --> 00:22:29,760
there's an interrupt per character,

385
00:22:29,910 --> 00:22:33,660
so the the the way uartwrite works is that

386
00:22:33,690 --> 00:22:34,890
for each character

387
00:22:34,890 --> 00:22:38,310
that is in this while for each character in the buffer character supposed to write,

388
00:22:38,520 --> 00:22:41,910
we wait here in this loop,

389
00:22:42,090 --> 00:22:44,850
until the uart is ready to accept one more character,

390
00:22:45,060 --> 00:22:46,680
we write one more character,

391
00:22:47,340 --> 00:22:49,500
we set this done flag to zero,

392
00:22:50,250 --> 00:22:55,260
and go back and wait typically in sleep until the done flag is one.

393
00:22:55,970 --> 00:23:00,080
And then after the uart finished sending this character,

394
00:23:00,140 --> 00:23:03,800
it'll interrupt and the interrupt routine will set done to one and do the wakeup,

395
00:23:03,800 --> 00:23:07,210
so in fact there is a wake- sleep and wakeup

396
00:23:07,210 --> 00:23:09,580
in an iteration of the loop for every single character

397
00:23:10,900 --> 00:23:16,930
and more the uart is actually capable of sending some number,

398
00:23:16,930 --> 00:23:20,280
like 4 16 or something characters at a time,

399
00:23:20,280 --> 00:23:21,450
so a more efficient driver

400
00:23:21,450 --> 00:23:28,230
would would hand 16 characters to the uart per iteration of this loop

401
00:23:28,410 --> 00:23:30,540
and there'd be an interrupt every 16 characters

402
00:23:30,690 --> 00:23:34,560
and higher speed devices are typically like ethernet drivers,

403
00:23:35,050 --> 00:23:38,110
typically accept many more bytes than that per interrupt.

404
00:23:39,890 --> 00:23:41,780
Alright.

405
00:23:42,320 --> 00:23:47,450
Okay, so this is just an illustration of what the interface looks like.

406
00:23:48,140 --> 00:23:51,200
Sleep and wakeup are nice,

407
00:23:51,200 --> 00:23:54,530
because for one reason they're nice, they're relatively flexible,

408
00:23:54,920 --> 00:23:57,350
sleep wakeup don't really care what it is uart to.

409
00:23:58,880 --> 00:23:59,540
Yeah, you can.

410
00:24:00,730 --> 00:24:02,950
You don't have to tell sleep what you're waiting for,

411
00:24:02,950 --> 00:24:04,840
you don't have to tell wakeup what event happened,

412
00:24:04,930 --> 00:24:09,280
you just need to have these matching sleep channel 64 bit values.

413
00:24:10,790 --> 00:24:16,520
However, there's one interesting property of the sleep interface,

414
00:24:16,670 --> 00:24:18,770
we have to pass it a lock here,

415
00:24:18,830 --> 00:24:22,160
there's a second argument, this lock argument

416
00:24:22,460 --> 00:24:29,090
and there's a big story behind why sleep takes this second argument.

417
00:24:30,480 --> 00:24:33,480
And I'm gonna explain what's going on,

418
00:24:33,510 --> 00:24:36,600
but the high level picture is,

419
00:24:36,600 --> 00:24:40,920
that it's not doesn't seem to be possible

420
00:24:41,310 --> 00:24:47,940
to design a sleep that is completely ignorant of what it is you're trying to wait for.

421
00:24:50,420 --> 00:24:52,850
It's hard to write a sort of general purpose sleep,

422
00:24:52,850 --> 00:24:56,090
that simply sleeps waiting for some specific event

423
00:24:56,390 --> 00:24:57,920
and this is danger,

424
00:24:57,920 --> 00:25:00,110
which we'll see in a moment called lost wakeups

425
00:25:00,140 --> 00:25:02,480
that just about every coordination mechanism

426
00:25:02,480 --> 00:25:04,880
has to grapple with somehow and deal with somehow.

427
00:25:06,360 --> 00:25:10,500
And then the sleep interface, this fact, we have to pass a lock

428
00:25:10,500 --> 00:25:14,160
is sort of a little bit of ugly implementation,

429
00:25:14,190 --> 00:25:16,800
leaking through into the interface in a way,

430
00:25:16,800 --> 00:25:18,000
I'll explain in just a moment.

431
00:25:22,080 --> 00:25:22,920
Yeah, I'll explain,

432
00:25:22,920 --> 00:25:23,460
this is a question,

433
00:25:23,460 --> 00:25:26,220
why do we need the done flag and the sleep channel?

434
00:25:26,250 --> 00:25:28,140
I will hold on to that question,

435
00:25:28,230 --> 00:25:30,870
I'll explain that in five or ten minutes.

436
00:25:32,000 --> 00:25:38,150
Okay, so before explaining why it is that sleep is doing with this lock,

437
00:25:38,360 --> 00:25:41,560
I actually want to talk a bit

438
00:25:41,560 --> 00:25:45,850
about what the implications would be if we had a simpler sleep,

439
00:25:46,210 --> 00:25:49,960
that didn't have didn't take that extra lock argument.

440
00:25:51,130 --> 00:25:52,180
So.

441
00:25:59,180 --> 00:26:00,080
Alright so.

442
00:26:05,390 --> 00:26:08,360
And the topic here is lost wakeups,

443
00:26:12,040 --> 00:26:16,930
that's the problem gonna describe now.

444
00:26:17,320 --> 00:26:21,020
so, suppose that the interface was

445
00:26:21,020 --> 00:26:30,250
just sleep on this arbitrary channel value with no second argument,

446
00:26:31,570 --> 00:26:33,250
you can't make this work,

447
00:26:33,250 --> 00:26:35,380
so I'm actually gonna call this broken_sleep.

448
00:26:37,560 --> 00:26:39,930
And you could imagine,

449
00:26:39,960 --> 00:26:41,580
if we didn't know better that,

450
00:26:41,670 --> 00:26:51,790
sleep like this could simply set the state of the process to this special sleeping value

451
00:26:51,790 --> 00:26:55,210
which says I don't want to run anymore, I'm waiting for a specific event

452
00:26:55,660 --> 00:26:58,540
and then if you look at the xv6 implementation of sleep,

453
00:26:58,540 --> 00:27:00,610
you'll see it does this among other things,

454
00:27:01,480 --> 00:27:05,050
we need to record this special sleep channel value,

455
00:27:05,540 --> 00:27:10,640
so that a future call to wakeup can realize that we're actually waiting for the thing,

456
00:27:10,640 --> 00:27:14,290
that the wakeup is waking us up for,

457
00:27:14,290 --> 00:27:17,320
so you could imagine a sleep and would be broken,

458
00:27:17,350 --> 00:27:19,150
that really just did this,

459
00:27:19,180 --> 00:27:24,300
I guess you'd have to take acquire this process is locked also.

460
00:27:25,890 --> 00:27:27,630
And then of course, [] wakeup.

461
00:27:34,280 --> 00:27:36,740
And this really is pretty much how wakeup works,

462
00:27:36,740 --> 00:27:38,240
we want to wakeup all the threads

463
00:27:38,240 --> 00:27:41,960
that are waiting on that are called sleep with this particular channel value,

464
00:27:42,140 --> 00:27:43,520
so we're just going to say,

465
00:27:43,520 --> 00:27:48,240
you know for each p and the process table,

466
00:27:51,530 --> 00:27:57,630
if the state if it's sleeping,

467
00:28:00,790 --> 00:28:05,920
and it's sleeping on the channel that we're waking up,

468
00:28:13,990 --> 00:28:17,880
then set the state to runnable,

469
00:28:22,230 --> 00:28:25,860
actually modular [], this is pretty much what a wakeup does.

470
00:28:29,410 --> 00:28:33,340
Okay, so, some alternate [] [] would be nice,

471
00:28:33,340 --> 00:28:35,200
if sleep and wakeup with this simple.

472
00:28:37,060 --> 00:28:39,490
Let me demonstrate though,

473
00:28:45,500 --> 00:28:46,550
let me demonstrate.

474
00:28:55,060 --> 00:28:58,030
Well, before I go back to the xv6 code,

475
00:28:58,390 --> 00:28:59,740
let me just outline

476
00:28:59,740 --> 00:29:03,280
how you would use this sleep and wakeup in the uart driver

477
00:29:03,280 --> 00:29:05,350
and this is sort of a repeat of what we've already seen,

478
00:29:05,350 --> 00:29:08,200
but using this slightly simpler interface.

479
00:29:08,700 --> 00:29:10,620
You would have.

480
00:29:11,140 --> 00:29:14,170
And indeed the driver does this you have this done flag,

481
00:29:15,570 --> 00:29:17,970
then uartwrite,

482
00:29:22,740 --> 00:29:29,160
you know would say for each character in the buffer,

483
00:29:32,060 --> 00:29:35,450
and then which check this done flag

484
00:29:35,480 --> 00:29:42,510
just say while not done, go to sleep,

485
00:29:44,880 --> 00:29:50,460
and then pass that channel whatever was tx_chan or something,

486
00:29:51,410 --> 00:29:52,430
doesn't really matter.

487
00:29:52,520 --> 00:29:56,780
Okay and then we're gonna send c to the uart,

488
00:29:57,430 --> 00:30:01,510
and set done equals zero right.

489
00:30:03,030 --> 00:30:10,240
And then the interrupt routine just sets it done flag is equal to true,

490
00:30:10,830 --> 00:30:11,490
and of course wakeup.

491
00:30:13,660 --> 00:30:19,470
So this is how we could use this simplified broken_sleep.

492
00:30:19,680 --> 00:30:21,390
Alright, so this is really broken_sleep.

493
00:30:22,400 --> 00:30:26,090
With this is missing though is locking,

494
00:30:27,280 --> 00:30:33,020
so actually, both both of these routines

495
00:30:33,020 --> 00:30:36,890
for both the write routine and the interrupt routine absolutely have to lock.

496
00:30:37,920 --> 00:30:40,140
And one reason is that,

497
00:30:40,320 --> 00:30:42,600
this done flag, anytime we have shared data,

498
00:30:42,630 --> 00:30:44,730
we really need to put a lock around the shared data,

499
00:30:45,510 --> 00:30:46,830
and the other reason is that,

500
00:30:47,010 --> 00:30:48,690
actually I didn't put it in here,

501
00:30:48,690 --> 00:30:51,960
but both the interrupt routine and the write routine

502
00:30:51,990 --> 00:30:55,200
need to access the hardware that uart hardware itself

503
00:30:55,260 --> 00:30:56,880
and typically it's an error,

504
00:30:56,910 --> 00:30:58,590
unless you're very very clever,

505
00:30:59,370 --> 00:31:01,470
it's an error to have two threads

506
00:31:01,680 --> 00:31:06,090
concurrently try to read and write the memory mapped hardware registers,

507
00:31:06,690 --> 00:31:10,080
so we need a lock around in both of these subroutines

508
00:31:10,080 --> 00:31:20,690
in order to avoid both racing access on done and racing accesses to the hardware.

509
00:31:21,140 --> 00:31:23,720
So the question is where should we put the locks in.

510
00:31:25,050 --> 00:31:28,260
It's it's easy in the interrupt routine,

511
00:31:28,260 --> 00:31:30,510
we're gonna lock our lock at the beginning,

512
00:31:31,290 --> 00:31:34,320
whatever the lock I think its called uart_tx_lock or something

513
00:31:34,320 --> 00:31:35,730
and we're gonna unlock at the end.

514
00:31:36,880 --> 00:31:39,850
So the interrupt routine just takes a lock and releases it,

515
00:31:40,090 --> 00:31:43,780
the puzzle is where to put the locks in the uart routine.

516
00:31:45,330 --> 00:31:47,860
One possibility is

517
00:31:47,860 --> 00:31:49,810
that uartwrite could hold the lock

518
00:31:49,810 --> 00:31:53,920
for the entire sequence of trying to send a character each character.

519
00:31:54,450 --> 00:32:03,350
So we could acquire the lock here, and unlock here.

520
00:32:06,200 --> 00:32:10,370
So lock and unlock it at the beginning and very end processing each character,

521
00:32:11,150 --> 00:32:13,580
so why, why does this definitely not work.

522
00:32:22,680 --> 00:32:24,180
One reason is that

523
00:32:24,180 --> 00:32:27,220
the only way we can get out of this loop is that

524
00:32:27,220 --> 00:32:29,890
the interrupt routine sets done to one,

525
00:32:30,100 --> 00:32:34,600
but if we hold this lock for this entire sequence in it,

526
00:32:34,750 --> 00:32:36,580
the interrupt routine also needs to lock

527
00:32:36,670 --> 00:32:39,400
and so it will sit here spinning waiting for the lock,

528
00:32:39,490 --> 00:32:42,130
because we hold the lock

529
00:32:42,250 --> 00:32:44,800
and aren't going to release it until done is set,

530
00:32:44,830 --> 00:32:48,820
but done can only be set when the interrupt routine is actually able to get the lock,

531
00:32:49,000 --> 00:32:52,300
so we cannot just simply hold the lock

532
00:32:53,590 --> 00:32:57,010
across the entire sequence of sending each character.

533
00:33:00,070 --> 00:33:02,230
Alright, so another possibility,

534
00:33:02,230 --> 00:33:04,450
the sort of nasty problem here is

535
00:33:04,450 --> 00:33:07,180
that uartwrite was holding a lock

536
00:33:07,180 --> 00:33:10,840
at the time when it expected the interrupt routine to execute

537
00:33:10,870 --> 00:33:12,100
which is right here,

538
00:33:12,100 --> 00:33:15,370
the only time when we really need the interrupt routine to execute is,

539
00:33:15,800 --> 00:33:16,880
is at this point here

540
00:33:17,060 --> 00:33:18,560
otherwise it's okay to hold the lock,

541
00:33:18,800 --> 00:33:22,220
so another possibility would be to acquire the lock at the beginning,

542
00:33:22,220 --> 00:33:26,840
because we need to protect our access to this shared variable done,

543
00:33:26,960 --> 00:33:33,900
but release it before the call to sleep,

544
00:33:34,140 --> 00:33:38,130
that gives the interrupt routine a chance to execute and set done to one

545
00:33:38,130 --> 00:33:42,180
and then we'll just re-acquire it after sleep returns.

546
00:33:43,470 --> 00:33:45,720
So then we go back up to the top and check done again,

547
00:33:45,720 --> 00:33:46,560
we have the lock again.

548
00:33:50,100 --> 00:33:53,490
Alright, so let me actually modify my driver to do this.

549
00:33:58,940 --> 00:34:00,350
We'll see, yeah.

550
00:34:01,740 --> 00:34:03,570
See what the consequences are.

551
00:34:06,050 --> 00:34:07,340
Alright.

552
00:34:08,020 --> 00:34:10,600
So the sleep we're talking about where we want to,

553
00:34:10,900 --> 00:34:12,490
you can see this code actually does,

554
00:34:13,210 --> 00:34:16,120
acquire the lock at the very beginning and release it at the end

555
00:34:16,300 --> 00:34:19,210
and the interrupt routine also acquires and releases.

556
00:34:19,330 --> 00:34:22,540
And the proposal is that we do two things,

557
00:34:22,540 --> 00:34:29,170
one is, we're gonna, we're exploring is why my broken_sleep idea,

558
00:34:29,290 --> 00:34:33,100
that only takes a single argument,

559
00:34:33,130 --> 00:34:34,180
why that doesn't work.

560
00:34:34,180 --> 00:34:37,420
So the idea is that in order to make the locking workout right,

561
00:34:37,420 --> 00:34:38,770
we're gonna call broken_sleep alright,

562
00:34:38,770 --> 00:34:43,600
but we're gonna release the lock here,

563
00:34:44,570 --> 00:34:48,120
and re-acquire it after sleep returns.

564
00:34:53,730 --> 00:34:56,790
And literally all this broken_sleep does is

565
00:34:56,790 --> 00:34:58,710
exactly what I wrote on my little whiteboard,

566
00:34:58,710 --> 00:35:01,950
namely, it sets the state to sleeping

567
00:35:01,950 --> 00:35:06,210
and sets the channel to this tx_chan argument,

568
00:35:06,330 --> 00:35:07,740
then call swtch.

569
00:35:09,810 --> 00:35:12,340
Alright, let's see what happens.

570
00:35:21,020 --> 00:35:24,170
Oh, wow look at that, actually managed,

571
00:35:24,170 --> 00:35:27,530
so init is printing out, it's init starting message,

572
00:35:27,530 --> 00:35:29,990
and it actually managed to write a few characters

573
00:35:29,990 --> 00:35:31,400
and that seems to have hung.

574
00:35:33,160 --> 00:35:35,140
And it turns out that if I type a character,

575
00:35:35,140 --> 00:35:36,850
I'm going to type a period,

576
00:35:38,110 --> 00:35:44,080
by typing peri- period, output restarts,

577
00:35:44,680 --> 00:35:47,410
maybe make more output I run ls,

578
00:35:47,410 --> 00:35:53,280
oops, ls also emitted a few characters and then stopped,

579
00:35:53,280 --> 00:35:56,250
but if I type something, I type type x,

580
00:35:57,120 --> 00:36:00,670
will do restart ls, it'll keep going.

581
00:36:02,060 --> 00:36:02,630
So.

582
00:36:05,170 --> 00:36:06,460
What do you think is going on here?

583
00:36:08,170 --> 00:36:09,790
So you want to propose a theory.

584
00:36:20,960 --> 00:36:23,960
The problem definitely has to do with the code that I just changed,

585
00:36:24,170 --> 00:36:25,250
so what's happening.

586
00:36:33,790 --> 00:36:36,340
Alright, so what's going on here is

587
00:36:36,340 --> 00:36:41,350
that my new code releases the lock,

588
00:36:41,940 --> 00:36:43,530
releases this lock at this point,

589
00:36:43,590 --> 00:36:49,010
and then right here, the interrupt happens,

590
00:36:49,010 --> 00:36:50,690
because as soon as you release the lock,

591
00:36:50,960 --> 00:36:53,030
first of all, the interrupts are re-enabled,

592
00:36:53,030 --> 00:36:54,740
so in this CPU interrupts could happen,

593
00:36:54,740 --> 00:36:55,790
this is a multi-core machine,

594
00:36:55,790 --> 00:36:59,860
so actually interrupts can be taken on any core,

595
00:37:00,160 --> 00:37:05,740
so almost certainly what's going on at this point that I've marked in the code is

596
00:37:05,740 --> 00:37:11,200
that on some other core, the uart interrupt is executing

597
00:37:11,590 --> 00:37:13,480
and it's sitting in acquire,

598
00:37:14,090 --> 00:37:17,030
waiting for this lock on some other core.

599
00:37:19,350 --> 00:37:20,580
And so as soon as I release it,

600
00:37:20,580 --> 00:37:23,580
that other core is going to acquire the lock,

601
00:37:23,970 --> 00:37:28,650
is going to see that the uart has completed sending the character,

602
00:37:29,340 --> 00:37:33,120
it's going to set this transmit done flag to one,

603
00:37:33,900 --> 00:37:34,650
just great,

604
00:37:34,860 --> 00:37:38,100
and then it's gonna call wakeup on tx_chan.

605
00:37:39,130 --> 00:37:41,110
Which is also fine, except,

606
00:37:42,090 --> 00:37:46,770
because the writing thread is still executing between the release and the broken_sleep,

607
00:37:47,130 --> 00:37:49,440
the writing thread hasn't gone to sleep yet,

608
00:37:49,770 --> 00:37:53,340
so the wakeup that the interrupt routine calls

609
00:37:53,370 --> 00:37:55,500
doesn't actually wakeup anything up,

610
00:37:55,530 --> 00:37:57,540
because nothing's yet gone to sleep on that channel.

611
00:37:58,680 --> 00:38:05,040
And then, the writing thread will proceed to call this broken_sleep

612
00:38:05,040 --> 00:38:09,960
which will, you know, set the state to sleeping and set the sleep channel,

613
00:38:10,020 --> 00:38:13,050
but the interrupt has already happened and the wakeup has already been called,

614
00:38:13,080 --> 00:38:17,070
so this sleep, nothing will ever wakeup,

615
00:38:17,430 --> 00:38:18,540
because the wakeup already happened.

616
00:38:20,270 --> 00:38:22,520
This is called the lost wakeup problem.

617
00:38:24,860 --> 00:38:29,120
Any questions about why or how this arises?

618
00:38:39,330 --> 00:38:42,660
Yeah, is it always going to be the case,

619
00:38:42,690 --> 00:38:45,630
that once something gets lost,

620
00:38:45,630 --> 00:38:48,300
once a wakeup gets lost,

621
00:38:48,300 --> 00:38:52,230
that on the next time, everything that's been buffered is just going to get dumped.

622
00:38:52,830 --> 00:38:57,360
Well, it completely depends on the details of what's going on.

623
00:38:57,420 --> 00:38:59,850
In this case it's actually just us,

624
00:39:00,620 --> 00:39:03,020
it's sort of accidental that,

625
00:39:03,680 --> 00:39:08,150
me typing something caused the output to resume,

626
00:39:08,270 --> 00:39:12,980
me typing input caused the output get fixed

627
00:39:13,040 --> 00:39:16,640
and the reason for that is that the uart has only one kind of interrupt,

628
00:39:16,640 --> 00:39:19,570
it makes it, it calls the same interrupt routine

629
00:39:19,600 --> 00:39:24,100
whether for input to signal input and the signal completed output,

630
00:39:24,580 --> 00:39:26,740
so when I type something which is input,

631
00:39:26,950 --> 00:39:29,980
the this uart interrupt routine gets called

632
00:39:30,190 --> 00:39:34,180
and the uart is thinking of is calling it just a signal that input has arrived,

633
00:39:34,180 --> 00:39:36,880
but in fact the interrupt routine in xv6,

634
00:39:37,090 --> 00:39:43,870
you know looks for, you know notices that the you know the way this code happens to be written

635
00:39:44,140 --> 00:39:48,010
is that if the uart is ready to transmit another character,

636
00:39:48,010 --> 00:39:50,350
it always calls wakeup,

637
00:39:50,900 --> 00:39:54,470
even though it's a while ago maybe I had already called wakeup,

638
00:39:54,740 --> 00:39:55,760
so it's sort of accidental

639
00:39:55,760 --> 00:39:58,910
that me typing characters caused us to get restarted

640
00:39:59,090 --> 00:40:02,780
and so sometimes if there are lost wakeups,

641
00:40:02,810 --> 00:40:06,620
sometimes they sort of fix themselves in this way, if you're lucky

642
00:40:06,620 --> 00:40:08,030
and sometimes they don't,

643
00:40:08,120 --> 00:40:11,930
like if the uart had separate receive and transmit interrupt routines,

644
00:40:11,930 --> 00:40:14,550
then there have been no getting out of this.

645
00:40:16,040 --> 00:40:17,030
Does that answer your question?

646
00:40:17,360 --> 00:40:18,410
Yes, thank you.

647
00:40:22,940 --> 00:40:23,510
Okay.

648
00:40:24,170 --> 00:40:24,980
So.

649
00:40:25,160 --> 00:40:26,030
Yes, please go ahead.

650
00:40:26,210 --> 00:40:30,320
What purpose does the tx_done bit serve?

651
00:40:31,820 --> 00:40:32,960
Oh, the tx_done bit,

652
00:40:33,110 --> 00:40:36,140
or you mean this flag tx_done,

653
00:40:36,590 --> 00:40:43,430
it is simply a way for the interrupt routine to communicate to uartwrite.

654
00:40:44,000 --> 00:40:48,050
That a previously transmitted character is finished

655
00:40:48,260 --> 00:40:51,710
and it's OK for uartwrite to proceed to transmitting the next character,

656
00:40:52,010 --> 00:40:53,420
so it's a little piece of,

657
00:40:54,320 --> 00:40:59,090
just like a little communication flag from the interrupt routine to uartwrite.

658
00:41:03,430 --> 00:41:07,090
Because if it it could like it would sleep

659
00:41:07,120 --> 00:41:09,520
and then it would know that when it wakes up,

660
00:41:10,100 --> 00:41:13,220
it's probably uart interrupted woke it up,

661
00:41:13,400 --> 00:41:19,270
so probably the tx_done bit like would have been set,

662
00:41:19,300 --> 00:41:20,500
but if we didn't have it,

663
00:41:20,920 --> 00:41:22,720
so I guess I'm saying that

664
00:41:23,050 --> 00:41:27,790
actually wakeup it should know that it's from uart interrupt.

665
00:41:28,000 --> 00:41:29,800
Okay, so is another way of phrasing your question,

666
00:41:29,800 --> 00:41:31,930
how come there's this while loop here,

667
00:41:33,540 --> 00:41:34,140
instead of just.

668
00:41:34,140 --> 00:41:35,940
Okay, okay I think answer my question,

669
00:41:36,060 --> 00:41:37,830
I think the answer to my question is,

670
00:41:37,830 --> 00:41:40,440
because uart interrupt serve two purposes.

671
00:41:40,440 --> 00:41:41,220
Okay, yeah.

672
00:41:42,040 --> 00:41:43,330
Yeah yeah yeah,

673
00:41:43,330 --> 00:41:45,760
in general, did your answer your question is

674
00:41:45,760 --> 00:41:49,570
sort of a specific instance of the more general answer that,

675
00:41:51,520 --> 00:41:56,830
it's it just turns out to be not practical

676
00:41:56,860 --> 00:42:01,300
to make sleeps and wakeups speed precise guaranteed precise,

677
00:42:01,300 --> 00:42:02,890
that is that if sleep returns,

678
00:42:02,890 --> 00:42:06,250
then for sure, whatever you're waiting for has happened.

679
00:42:06,340 --> 00:42:11,170
So, one example of this is that suppose we have two processes,

680
00:42:11,170 --> 00:42:14,560
that are both trying to write that uart at the same time,

681
00:42:14,590 --> 00:42:16,210
they're both in uartwrite and they can,

682
00:42:16,210 --> 00:42:19,390
because after one writes a character, it'll sleep,

683
00:42:19,660 --> 00:42:22,810
releasing that turns out releasing the lock

684
00:42:22,900 --> 00:42:25,330
and then the other one can enter that loop

685
00:42:25,330 --> 00:42:28,510
and try to wait until uart not busy.

686
00:42:29,120 --> 00:42:31,190
And they both may both end up sleeping

687
00:42:31,430 --> 00:42:33,470
and when an interrupt happens in the uart,

688
00:42:33,470 --> 00:42:34,730
can accept one more character,

689
00:42:34,730 --> 00:42:36,590
they'll both be woken up up,

690
00:42:36,590 --> 00:42:39,620
but only one should actually write the character.

691
00:42:40,270 --> 00:42:41,740
And that this while loop.

692
00:42:42,180 --> 00:42:46,800
And in fact you'll see a while loop every sleep, in xv6 I believe,

693
00:42:46,800 --> 00:42:48,420
it's because this problem of,

694
00:42:48,690 --> 00:42:49,800
you maybe woken up,

695
00:42:49,800 --> 00:42:52,950
but really somebody else sort of took the thing you were waiting for,

696
00:42:52,950 --> 00:42:54,180
so you have to sleep again,

697
00:42:54,360 --> 00:42:56,830
this happens pervasively.

698
00:42:59,600 --> 00:42:59,990
Okay.

699
00:42:59,990 --> 00:43:00,620
Thank you.

700
00:43:00,830 --> 00:43:01,310
Yes.

701
00:43:03,000 --> 00:43:04,230
I've got a question.

702
00:43:04,900 --> 00:43:05,200
Yes.

703
00:43:05,230 --> 00:43:09,700
So it looks like we only saw one lost wakeup,

704
00:43:10,000 --> 00:43:13,060
because as soon as we pressed like a character,

705
00:43:13,060 --> 00:43:16,330
the rest of the output of the entire rest output came out,

706
00:43:16,510 --> 00:43:19,270
shouldn't we have seen multiple lost wakeups where,

707
00:43:19,480 --> 00:43:20,740
why didn't happen again.

708
00:43:21,220 --> 00:43:22,390
Oh, it did it did here,

709
00:43:22,390 --> 00:43:23,530
let me let me run this,

710
00:43:23,530 --> 00:43:24,430
I'm going to run readme,

711
00:43:24,460 --> 00:43:25,630
I'm going to cat README right,

712
00:43:25,630 --> 00:43:27,130
which is a couple thousand bytes,

713
00:43:27,310 --> 00:43:30,850
so, oops, I had already typed something.

714
00:43:31,570 --> 00:43:32,950
I guess we've got one character,

715
00:43:33,040 --> 00:43:34,660
I'm going to type a period,

716
00:43:35,370 --> 00:43:38,040
we got a few more characters and then it hung up again.

717
00:43:38,680 --> 00:43:41,320
I'm gonna take another period, another couple characters.

718
00:43:41,890 --> 00:43:45,820
Each time I type a period that causes an interrupt for the input,

719
00:43:46,470 --> 00:43:47,880
which then wakes up the process

720
00:43:47,880 --> 00:43:50,520
and it could do a few more characters of wirtes then hangs again.

721
00:43:51,060 --> 00:43:52,590
You know another lost wakeup.

722
00:43:53,930 --> 00:43:57,080
Yeah, just miss that, makes sense.

723
00:43:57,410 --> 00:43:58,430
Yeah, so I'm typing period,

724
00:43:58,430 --> 00:44:01,310
here I get a couple characters per lost wakeup,

725
00:44:01,310 --> 00:44:04,130
because of the lost wakeup requires this coincidence,

726
00:44:04,130 --> 00:44:08,090
that the interrupt has already happened and was waiting to acquire the lock,

727
00:44:08,690 --> 00:44:09,440
just that,

728
00:44:10,200 --> 00:44:12,660
we get that coincidence a lot of the time, but not all the time.

729
00:44:15,650 --> 00:44:16,220
Alright.

730
00:44:17,260 --> 00:44:21,970
Okay so our goal then is to get rid of this lost wakeup problem,

731
00:44:21,970 --> 00:44:24,910
by somehow eliminating this window here,

732
00:44:25,540 --> 00:44:28,330
between the release of the uart_tx_lock,

733
00:44:28,330 --> 00:44:29,740
which we have to release,

734
00:44:29,740 --> 00:44:32,620
because the interrupt needs that lock,

735
00:44:32,620 --> 00:44:34,090
so we know we have to release the lock.

736
00:44:34,840 --> 00:44:36,610
But somehow we want to eliminate this window

737
00:44:36,610 --> 00:44:41,830
between when we release the lock and when the process actually marks itself as sleeping,

738
00:44:42,250 --> 00:44:45,430
so that the interrupts wakeup will see that the process is sleeping

739
00:44:45,430 --> 00:44:48,160
and actually wake it up and therefore not lose the wakeup.

740
00:44:48,970 --> 00:44:51,460
So we've got to somehow close that window.

741
00:44:53,570 --> 00:44:57,860
And to do that, we gotta make sleep's interface a little bit more complicated,

742
00:44:58,160 --> 00:45:05,500
so, go back to the original working sleep

743
00:45:05,500 --> 00:45:07,000
and I called a working sleep

744
00:45:07,120 --> 00:45:12,000
and the way that people solve this problem is

745
00:45:12,000 --> 00:45:13,710
that sleep requires,

746
00:45:13,710 --> 00:45:16,200
even though sleep doesn't really know what you're waiting for,

747
00:45:16,500 --> 00:45:19,260
it requires that you be waiting for something

748
00:45:19,410 --> 00:45:21,870
and furthermore that there be a lock

749
00:45:21,930 --> 00:45:24,570
that protects whatever it is you're waiting for.

750
00:45:25,710 --> 00:45:27,990
So it requires that there be a sleep condition,

751
00:45:28,910 --> 00:45:30,170
which it doesn't really know about

752
00:45:30,590 --> 00:45:34,790
the sleep condition is that tx_done is equal to one,

753
00:45:35,450 --> 00:45:36,920
sleep doesn't know what the sleep condition is,

754
00:45:36,920 --> 00:45:39,860
but it does it is requires, that there be a lock,

755
00:45:39,860 --> 00:45:43,550
that protects the sleep condition, namely this uart_tx_lock

756
00:45:43,820 --> 00:45:47,630
and the lock be locked when you check the condition,

757
00:45:47,630 --> 00:45:49,700
that you hold the lock until you call sleep,

758
00:45:50,030 --> 00:45:52,070
and that you pass the lock to sleep.

759
00:45:52,430 --> 00:45:55,490
And what sleep promises essentially at the interface level is

760
00:45:55,490 --> 00:46:00,350
that it's gonna atomically put the process to sleep and release the lock

761
00:46:00,650 --> 00:46:05,120
as a sort of, at least it is an indivisible pair of actions,

762
00:46:05,120 --> 00:46:07,700
at least with respect to wakeup.

763
00:46:09,000 --> 00:46:12,200
So, wakeup will never see this situation,

764
00:46:12,200 --> 00:46:15,710
which yeah you release the lock, but you know the process is not sleep,

765
00:46:16,160 --> 00:46:20,210
sleep makes the release of the lock and putting the process to sleep the atomic.

766
00:46:23,110 --> 00:46:26,710
And the rules for this is that there has to be, this has to be a condition,

767
00:46:27,220 --> 00:46:29,620
which has to be a lock protecting the condition,

768
00:46:29,860 --> 00:46:31,720
the lock has to be held when you call sleep,

769
00:46:31,720 --> 00:46:32,890
you have to pass the lock to sleep,

770
00:46:32,890 --> 00:46:39,070
and furthermore the lock has to be held, when you call wakeup.

771
00:46:39,640 --> 00:46:42,790
This condition lock needs to be held when you call wakeup wakeup,

772
00:46:42,790 --> 00:46:47,080
so these are rules, that the programmer had better follow,

773
00:46:47,110 --> 00:46:49,660
if they want to write correct code using sleep and wakeup.

774
00:46:52,790 --> 00:46:53,330
Alright.

775
00:46:55,790 --> 00:46:59,090
So let's look at the sleep and wakeup,

776
00:46:59,150 --> 00:47:00,890
trying to spot how they actually

777
00:47:01,070 --> 00:47:04,130
use this extra little piece of information and these rules

778
00:47:04,550 --> 00:47:06,230
to avoid lost wakeups.

779
00:47:06,380 --> 00:47:07,670
So first I want to look at wakeup,

780
00:47:10,130 --> 00:47:12,050
wakeup not very surprising,

781
00:47:12,530 --> 00:47:14,690
it just runs through the entire process table,

782
00:47:15,050 --> 00:47:17,720
it locks every process,

783
00:47:17,930 --> 00:47:20,600
remember that, after it's locked process,

784
00:47:20,600 --> 00:47:23,090
you can't really look at a process at state with locking it,

785
00:47:23,390 --> 00:47:24,710
it locks each process,

786
00:47:25,010 --> 00:47:26,810
if the process is sleeping,

787
00:47:27,320 --> 00:47:32,360
and the channel that's sleeping for is the same channel that was passed to wakeup,

788
00:47:32,880 --> 00:47:36,420
then wakeup marks the changes the process of state to runnable

789
00:47:36,660 --> 00:47:38,520
and then releases the process's lock.

790
00:47:40,400 --> 00:47:41,780
So no surprises here.

791
00:47:42,960 --> 00:47:46,110
We'll ignore my broken_sleep

792
00:47:46,110 --> 00:47:47,760
and instead look at sleep itself,

793
00:47:47,970 --> 00:47:49,800
so here's the implementation of sleep,

794
00:47:52,820 --> 00:47:54,890
with now, this new lock argument.

795
00:47:56,690 --> 00:48:01,910
So we know sleep has to reduce has to release that condition lock

796
00:48:01,940 --> 00:48:03,260
that its second argument,

797
00:48:03,260 --> 00:48:04,190
we know it has to release it,

798
00:48:04,190 --> 00:48:07,390
because the you know the interrupt routine has to be able to acquire,

799
00:48:07,420 --> 00:48:10,540
so we know there's going to be release of that lock somewhere inside sleep,

800
00:48:10,540 --> 00:48:12,850
and indeed here's the release of that lock,

801
00:48:13,090 --> 00:48:14,380
of course we're worried,

802
00:48:14,620 --> 00:48:18,040
after we release the lock that at this very point,

803
00:48:18,310 --> 00:48:23,320
wakeup might be called and might wake up this process,

804
00:48:23,350 --> 00:48:25,810
so in order to might try to wake up this process,

805
00:48:25,810 --> 00:48:27,760
but of course we haven't marked sleeping yet, right,

806
00:48:27,760 --> 00:48:31,600
so we cannot afford to have wakeup execute.

807
00:48:33,550 --> 00:48:34,210
Oops.

808
00:48:34,270 --> 00:48:38,260
Have wakeup execute, right, after this release, even though we're releasing.

809
00:48:38,260 --> 00:48:40,330
So in order to cause that not to happen,

810
00:48:40,330 --> 00:48:42,280
before releasing the condition lock,

811
00:48:42,310 --> 00:48:47,020
sleep acquires the lock of the process that's going to sleep.

812
00:48:47,470 --> 00:48:55,360
If you recall, wakeup must be called with the condition lock held

813
00:48:55,360 --> 00:48:57,160
and it acquires the,

814
00:48:57,490 --> 00:48:59,200
if it's about to wakeup process,

815
00:48:59,200 --> 00:49:02,050
it first must wait to acquire that process's lock.

816
00:49:04,400 --> 00:49:07,310
So for the entire amount of time,

817
00:49:07,310 --> 00:49:12,890
between when uartwrite between, before uartwrite checked the condition,

818
00:49:13,160 --> 00:49:16,250
when we when we call sched here,

819
00:49:16,580 --> 00:49:22,730
this thread holds one or another of the condition lock and p->lock at all times.

820
00:49:23,910 --> 00:49:27,390
I just go back to uart, want to emphasize this,

821
00:49:27,420 --> 00:49:32,210
uartwrite acquires the condition lock here

822
00:49:32,510 --> 00:49:36,140
and holds the condition lock all the way through to where it calls sleep,

823
00:49:36,530 --> 00:49:38,180
so it requires the condition lock,

824
00:49:38,570 --> 00:49:40,190
checks the condition with lock held,

825
00:49:40,340 --> 00:49:42,680
call sleep with the condition lock held,

826
00:49:42,920 --> 00:49:45,590
so wakeup can't do anything now,

827
00:49:45,590 --> 00:49:47,960
because it can not even allowed to call wakeup,

828
00:49:48,080 --> 00:49:50,690
until until the caller owns the condition locks,

829
00:49:50,690 --> 00:49:52,520
so wakeup definitely not executing now,

830
00:49:53,540 --> 00:49:55,580
we still hold the lock, we call sleep,

831
00:49:57,110 --> 00:50:00,160
sleep releases the condition lock,

832
00:50:00,160 --> 00:50:03,820
but first acquires the process's lock.

833
00:50:06,030 --> 00:50:07,380
And if you remember,

834
00:50:07,530 --> 00:50:08,160
oops,

835
00:50:10,050 --> 00:50:13,260
wakeup, wakeup is called with the condition lock,

836
00:50:13,530 --> 00:50:15,720
after we release it.

837
00:50:16,530 --> 00:50:18,840
Sorry, after we release the condition lock,

838
00:50:18,840 --> 00:50:19,890
wakeup can be called,

839
00:50:19,920 --> 00:50:22,500
but wakeup won't look at the process

840
00:50:22,500 --> 00:50:24,600
until it has the process lock which we hold.

841
00:50:24,600 --> 00:50:26,580
So okay, so wakeup is still not executing.

842
00:50:30,900 --> 00:50:34,140
Acquire the process lock, release the condition lock,

843
00:50:34,170 --> 00:50:35,820
while holding the process lock,

844
00:50:35,820 --> 00:50:40,230
mark the process as sleeping on this particular channel

845
00:50:40,590 --> 00:50:43,470
and then calls sched, which calls swtch right,

846
00:50:43,500 --> 00:50:46,350
we still have the process lock, so wakeup still isn't doing anything,

847
00:50:46,560 --> 00:50:47,700
and if you remember,

848
00:50:47,700 --> 00:50:52,260
the you know switching away from this thread to the scheduler thread

849
00:50:52,500 --> 00:50:55,320
and the scheduler routine after it's called the swtch returns,

850
00:50:55,380 --> 00:50:59,580
releases recently running process's lock.

851
00:50:59,920 --> 00:51:03,250
So at this point, after we're in the scheduler,

852
00:51:03,280 --> 00:51:07,360
wakeup can finally acquire p->lock for this process,

853
00:51:07,600 --> 00:51:12,170
notice that it's sleeping and on this channel

854
00:51:12,170 --> 00:51:13,670
and set its state to wakeup.

855
00:51:14,110 --> 00:51:17,710
So we guaranteed the effect of the rule

856
00:51:17,710 --> 00:51:20,560
that you have to hold the condition lock when calling sleep,

857
00:51:20,560 --> 00:51:22,090
the fact that sleep knows about that lock

858
00:51:22,090 --> 00:51:25,540
and release it only after requiring process p->lock

859
00:51:25,720 --> 00:51:28,680
and wakeup needing to hold both locks

860
00:51:29,010 --> 00:51:30,480
in order to [think about] this process

861
00:51:30,690 --> 00:51:33,900
means that we can no longer lose a wakeup,

862
00:51:34,140 --> 00:51:36,720
so we fix this lost wakeup problem.

863
00:51:39,050 --> 00:51:40,700
I realized a little bit involved,

864
00:51:41,330 --> 00:51:43,100
any questions about what's going on here?

865
00:52:02,910 --> 00:52:07,890
Alright, well, feel free to ask questions at any time.

866
00:52:09,480 --> 00:52:14,100
Alright, so we saw one, we saw this one, look at this one case,

867
00:52:14,100 --> 00:52:19,810
in which were using sleep and wakeup in a way that avoids lost wakeups,

868
00:52:20,140 --> 00:52:23,140
there's a bunch of others in xv6,

869
00:52:23,200 --> 00:52:27,580
this particular one, the thing that we're waiting for the condition that we're waiting for,

870
00:52:28,030 --> 00:52:30,220
you know is that interrupt has occurred,

871
00:52:30,220 --> 00:52:34,360
that has signalled that hardware is ready to do the next thing,

872
00:52:35,680 --> 00:52:40,260
there's also times when kernel code calls sleep

873
00:52:40,290 --> 00:52:42,930
in order to wait for a diff some other thread to do something,

874
00:52:43,110 --> 00:52:45,330
which is not actually in the end conceptually different,

875
00:52:45,330 --> 00:52:47,190
but may feel a little bit different,

876
00:52:47,190 --> 00:52:49,800
so in the pipe code, for example,

877
00:52:50,680 --> 00:52:52,030
if you look at piperead,

878
00:52:56,210 --> 00:53:00,500
there's a bunch of junk here which you have to ignore,

879
00:53:00,500 --> 00:53:05,460
but the read system call on the pipe, ends up calling piperead,

880
00:53:05,610 --> 00:53:08,520
there's a lock that protects the pipe

881
00:53:08,550 --> 00:53:13,490
and this is going to end up being the condition lock,

882
00:53:13,880 --> 00:53:18,380
pipereed needs to wait until there's actually data buffered in the pipe,

883
00:53:18,530 --> 00:53:22,940
and that condition is that there's data ready,

884
00:53:22,940 --> 00:53:26,390
is nread or nwrite is greater than nread

885
00:53:26,390 --> 00:53:28,340
that is more bytes have been written than read,

886
00:53:28,670 --> 00:53:36,010
while that's not true, piperead sits in sleep, waiting for that condition,

887
00:53:36,100 --> 00:53:39,910
and passes in this pipe lock,

888
00:53:39,970 --> 00:53:42,790
the condition lock that protects the condition into sleep,

889
00:53:44,150 --> 00:53:45,950
in order to protect against lost wakeup.

890
00:53:45,950 --> 00:53:47,750
So the reason why you might get lost wakeup is

891
00:53:47,750 --> 00:53:49,520
that on a different core,

892
00:53:50,580 --> 00:53:52,710
a little farther up in the file,

893
00:53:52,710 --> 00:53:53,640
on a different core,

894
00:53:53,730 --> 00:53:58,170
there's probably some other thread, just now calling pipewrite

895
00:53:58,530 --> 00:54:02,810
and it's gonna add byte to the pipe buffer,

896
00:54:02,810 --> 00:54:09,090
and finally call the wakeup on the channel, that piperead waiting for

897
00:54:09,330 --> 00:54:14,580
and you know we want to avoid the risk that between the reader checking,

898
00:54:15,180 --> 00:54:19,740
there's, noticing there's no bytes to read and calling sleep,

899
00:54:19,770 --> 00:54:23,700
we do not want to pipewrite on another core to sleep in there,

900
00:54:25,220 --> 00:54:29,300
and add bytes and wake us up, before we've even gone to sleep, right,

901
00:54:29,300 --> 00:54:30,350
would be a lost wakeup.

902
00:54:31,600 --> 00:54:34,060
And this lock basically this lock

903
00:54:34,060 --> 00:54:37,030
and the fact that sleep is careful about releasing it,

904
00:54:38,540 --> 00:54:41,360
prevent a writer from sleeping in,

905
00:54:41,420 --> 00:54:43,220
between the check of the condition and the sleep,

906
00:54:43,280 --> 00:54:44,990
because the writer has to acquire the lock too.

907
00:54:48,670 --> 00:54:51,700
And for those of you are,

908
00:54:53,610 --> 00:54:57,060
the people asked about wrapping sleep and while loops,

909
00:54:57,300 --> 00:55:02,670
both pipereed and pipewrite are examples of sleep wrapped in a while,

910
00:55:03,330 --> 00:55:09,220
so for example the, this is the loop that piperead waits for data to appear,

911
00:55:09,220 --> 00:55:11,320
waits for the buff pipe buffer to be non empty,

912
00:55:11,770 --> 00:55:13,630
and the sleep is wrapped in a loop

913
00:55:13,720 --> 00:55:16,020
and again the reason is that,

914
00:55:16,140 --> 00:55:20,790
there could be perfectly well be multiple processes reading the very same pipe

915
00:55:21,120 --> 00:55:23,970
and so if a writer writes one byte to the pipe,

916
00:55:24,420 --> 00:55:26,130
so there's only one byte there,

917
00:55:26,190 --> 00:55:27,660
the writer's going to call wakeup,

918
00:55:28,660 --> 00:55:33,310
that's gonna wakeup all the multiple processes that were reading that pipe,

919
00:55:33,340 --> 00:55:35,230
but there's only one byte in the pipe,

920
00:55:35,500 --> 00:55:40,420
and so one of those processes going to wakeup first, right,

921
00:55:40,480 --> 00:55:42,880
it's going to come out of its sleep first.

922
00:55:43,000 --> 00:55:44,290
Actually, this reminds me,

923
00:55:44,290 --> 00:55:47,170
there's another crucial thing I forgot to mention about sleep,

924
00:55:49,170 --> 00:55:51,840
and that's that the last thing sleep does,

925
00:55:51,840 --> 00:55:52,770
let's look at,

926
00:55:55,980 --> 00:55:57,330
here's, here's the,,

927
00:55:57,920 --> 00:55:58,400
sorry,

928
00:55:58,550 --> 00:55:59,780
here's the end of sleep,

929
00:55:59,900 --> 00:56:03,650
the last thing sleep does is acquires the condition lock,

930
00:56:03,890 --> 00:56:06,710
so you must call sleep with the condition lock held

931
00:56:06,920 --> 00:56:09,440
and sleep re-acquires it before it returns.

932
00:56:10,850 --> 00:56:14,510
Okay, so what that means is that,

933
00:56:14,510 --> 00:56:15,800
if there were a bunch of readers,

934
00:56:15,800 --> 00:56:17,750
there's one byte written to just return to a pipe

935
00:56:17,750 --> 00:56:19,550
and a bunch of readers that all woken up,

936
00:56:19,550 --> 00:56:22,100
one of them will succeed,

937
00:56:22,220 --> 00:56:26,510
one of the sleep, so one of the threads will succeed in acquiring this lock,

938
00:56:27,000 --> 00:56:30,000
the others will be waiting and sleep, spinning waiting for the lock,

939
00:56:30,270 --> 00:56:33,600
that one lucky process sleep will return,

940
00:56:33,600 --> 00:56:34,560
it will come back to this check

941
00:56:34,560 --> 00:56:38,040
and you know p->nwrite is one larger than nread,

942
00:56:38,160 --> 00:56:39,180
so its data to read,

943
00:56:39,180 --> 00:56:40,140
it will fall out of the loop,

944
00:56:40,140 --> 00:56:41,370
will read the one byte

945
00:56:41,520 --> 00:56:42,840
and now there's nothing in the buffer,

946
00:56:43,020 --> 00:56:45,540
release the lock, and return,

947
00:56:45,600 --> 00:56:48,180
and now the next thread that was woken up,

948
00:56:48,660 --> 00:56:52,410
it's sleep will be able to re-acquire the condition lock,

949
00:56:52,590 --> 00:56:57,350
it's sleep will return, it will return, recheck the loop condition,

950
00:56:57,350 --> 00:57:00,860
but now nread is equal to nwrite,

951
00:57:01,040 --> 00:57:04,700
and so that thread and any other thread waiting will go back to sleep.

952
00:57:04,880 --> 00:57:07,010
This is again just to reinforce,

953
00:57:07,010 --> 00:57:10,460
why almost every, maybe every call to sleep

954
00:57:10,490 --> 00:57:13,190
has to be wrapped in a loop that re-checks the condition.

955
00:57:18,360 --> 00:57:22,350
Questions about the way sleep, pipes use sleep?

956
00:57:33,670 --> 00:57:40,300
Alright, the sleep and wakeup interface rules are a little bit complex.

957
00:57:41,420 --> 00:57:44,870
Because you have to reveal a bit to sleep about what you're waiting for,

958
00:57:44,870 --> 00:57:47,000
you have to tell the lock and follow some rules,

959
00:57:48,500 --> 00:57:50,360
which is sometimes annoying.

960
00:57:50,630 --> 00:57:53,090
On the other hand, sleep and wakeup pretty flexible,

961
00:57:53,090 --> 00:57:56,450
partially, because they don't actually have to understand the condition itself,

962
00:57:56,630 --> 00:57:59,030
that just has to be a condition and be a lock,

963
00:57:59,270 --> 00:58:03,110
there are other schemes that are somewhat higher level,

964
00:58:03,290 --> 00:58:05,480
there's other coordination seems like the semaphore,

965
00:58:05,480 --> 00:58:07,760
you read about in the reading for today,

966
00:58:08,000 --> 00:58:11,030
in which the interface is slightly less complex,

967
00:58:11,030 --> 00:58:13,700
like the semaphores, you don't have to tell the semaphore about a lock,

968
00:58:15,100 --> 00:58:19,000
and the caller to semaphore doesn't have to worry about lost wakeups,

969
00:58:19,030 --> 00:58:21,010
internally the implementation of the semaphore,

970
00:58:21,160 --> 00:58:23,830
again as you saw in the reading for today,

971
00:58:23,830 --> 00:58:28,120
the internal implementation of semaphores worries about lost wakeup.

972
00:58:28,120 --> 00:58:33,070
So, because the interface is specialized to these up down counters,

973
00:58:34,560 --> 00:58:38,040
the need to deal with lost wakeup doesn't leak through into the interface.

974
00:58:38,640 --> 00:58:40,770
So that semaphores are somewhat simpler,

975
00:58:40,770 --> 00:58:41,910
although they're less general,

976
00:58:42,180 --> 00:58:45,420
if you don't, if you don't have a count,

977
00:58:45,420 --> 00:58:46,710
you're not waiting for count,

978
00:58:46,710 --> 00:58:51,730
then semaphores are not necessarily going to be super helpful for you.

979
00:58:52,240 --> 00:58:56,470
So that that causes me to claim that sleep and wakeup a little more general.

980
00:59:00,440 --> 00:59:01,970
Alright.

981
00:59:02,980 --> 00:59:05,230
So with sleep and wakeup under our belts,

982
00:59:05,290 --> 00:59:10,180
I want to talk about one more kind of challenge that xv6 faces,

983
00:59:10,180 --> 00:59:11,860
that's actually related to sleep and wakeup

984
00:59:12,880 --> 00:59:15,970
and that's how to shut down threads.

985
00:59:16,000 --> 00:59:18,910
Every threading system, the threads eventually need to exit

986
00:59:18,910 --> 00:59:22,090
and we need to clean up their state, free their stack,

987
00:59:22,300 --> 00:59:25,750
on xv6, when a process exits,

988
00:59:26,550 --> 00:59:28,320
we need to free its user memory

989
00:59:28,320 --> 00:59:31,200
and free its page table and free its trapframe,

990
00:59:31,410 --> 00:59:36,780
mark the process the slot in the process table as reusable.

991
00:59:37,140 --> 00:59:39,480
So, these are sort of typical cleanup requirements is

992
00:59:39,480 --> 00:59:40,980
a bunch of stuff that has to be freed

993
00:59:41,310 --> 00:59:48,010
when threads exit or or killed.

994
00:59:48,190 --> 00:59:51,040
So, but there's two big problems that arise here,

995
00:59:51,100 --> 00:59:53,830
with thread exit or killing threads,

996
00:59:53,830 --> 00:59:55,900
one is that we can't just reach out,

997
00:59:55,900 --> 01:00:01,360
we can't usually just reach out and unilaterally destroy another thread,

998
01:00:01,780 --> 01:00:02,920
the problem is that,

999
01:00:02,920 --> 01:00:06,070
other thread may actually be currently executing on another core

1000
01:00:06,070 --> 01:00:07,270
and using its stack

1001
01:00:07,270 --> 01:00:11,170
and maybe about to save its registers in its struct context or whatever,

1002
01:00:11,530 --> 01:00:15,100
the other thread if it's in the kernel, maybe holding locks,

1003
01:00:15,100 --> 01:00:19,450
it may be in the middle of some complicated update to a kernel data structure,

1004
01:00:19,780 --> 01:00:22,000
and if we simply somehow shoot down the thread

1005
01:00:22,000 --> 01:00:23,650
and stop it dead in its [tracks],

1006
01:00:23,770 --> 01:00:28,840
then it may have gotten halfway through a delicate update to some kernel data,

1007
01:00:29,050 --> 01:00:31,120
but we shot it down before it completed.

1008
01:00:31,920 --> 01:00:38,560
So, we can't afford any of those things to happen.

1009
01:00:39,820 --> 01:00:43,810
Another problem is that even if a thread calls exit

1010
01:00:43,810 --> 01:00:46,180
and sort of decided for its not killed,

1011
01:00:46,180 --> 01:00:48,280
but decided for itself that it wants to quit,

1012
01:00:49,180 --> 01:00:52,090
it has resources that it uses while executes

1013
01:00:52,090 --> 01:00:55,600
like its stack, for example and its slot in the process table,

1014
01:00:55,810 --> 01:00:58,150
and while it's still executing,

1015
01:00:58,650 --> 01:01:02,670
it, it may not be able to free up the resources that is still using.

1016
01:01:03,800 --> 01:01:07,100
So we need a way for threads to,

1017
01:01:07,190 --> 01:01:08,720
for those last few resources,

1018
01:01:08,720 --> 01:01:10,790
that are critical to execution to somehow be freed,

1019
01:01:10,790 --> 01:01:12,140
even though the thread needs them,

1020
01:01:12,530 --> 01:01:14,450
even just execute any code at all.

1021
01:01:16,560 --> 01:01:18,690
Okay, so keep these two problems in mind,

1022
01:01:18,780 --> 01:01:23,000
xv6 actually has two, two things,

1023
01:01:23,000 --> 01:01:26,840
that are related to shutting down threads or processes,

1024
01:01:26,930 --> 01:01:28,700
one is exit and the other is kill.

1025
01:01:28,730 --> 01:01:30,350
So let's look at exit first.

1026
01:01:31,160 --> 01:01:33,560
I'll look at the code for exit in proc.c,

1027
01:01:34,810 --> 01:01:38,780
this is what the exit system call calls.

1028
01:01:41,480 --> 01:01:44,150
And you know what exit has to do in the end,

1029
01:01:44,150 --> 01:01:46,490
we know sort of from the outside from the interface,

1030
01:01:46,490 --> 01:01:49,550
that it's gonna free up the process memory and page tables,

1031
01:01:49,550 --> 01:01:51,170
got to close its open files

1032
01:01:51,740 --> 01:01:54,050
and we also know that there's this wait call,

1033
01:01:54,050 --> 01:01:56,030
that the parent may be making, making

1034
01:01:56,030 --> 01:02:00,710
and exit has to eventually cause the parent to be woken up as well

1035
01:02:01,580 --> 01:02:06,260
and so we're going to look for all these things in the, in the exit code.

1036
01:02:06,710 --> 01:02:09,140
So you can see some of this stuff,

1037
01:02:09,140 --> 01:02:12,320
like exit specifically closes the open files,

1038
01:02:12,320 --> 01:02:13,820
and this might actually be quite complex,

1039
01:02:13,820 --> 01:02:17,150
because the files or file system files closing them,

1040
01:02:17,150 --> 01:02:19,250
actually involves things like reference counting.

1041
01:02:21,070 --> 01:02:22,120
And we haven't gotten there yet,

1042
01:02:22,120 --> 01:02:22,780
but we'll see that,

1043
01:02:22,930 --> 01:02:25,140
this takes a fair amount of work.

1044
01:02:25,140 --> 01:02:29,610
But a process goes ahead and closes when you call exit, closes its own files.

1045
01:02:30,950 --> 01:02:32,840
And it also does something similar,

1046
01:02:32,840 --> 01:02:36,710
it has a record of the current working directory,

1047
01:02:36,710 --> 01:02:38,540
which is what's changed when you call cd,

1048
01:02:38,540 --> 01:02:43,130
and it needs to to sort of release that reference into the file system.

1049
01:02:43,750 --> 01:02:46,930
Then there's some other horrible stuff that happens,

1050
01:02:46,960 --> 01:02:48,700
that's related to the fact,

1051
01:02:48,700 --> 01:02:51,370
that if a process exits,

1052
01:02:51,370 --> 01:02:53,650
but it has children of its own,

1053
01:02:54,200 --> 01:02:59,120
those children are inherited by the init process,

1054
01:02:59,150 --> 01:03:00,290
because as it turns out,

1055
01:03:00,290 --> 01:03:01,430
we'll see in a few minutes,

1056
01:03:01,430 --> 01:03:07,070
that every process that exits, there has to be a corresponding wait from a parent,

1057
01:03:07,070 --> 01:03:11,230
that actually finishes up some of the steps in exiting

1058
01:03:11,920 --> 01:03:15,610
and so if I exit, my children they need to be waited for,

1059
01:03:15,610 --> 01:03:17,080
I was their parent, I'm not going to wait for them,

1060
01:03:17,080 --> 01:03:17,950
because I've exited.

1061
01:03:18,130 --> 01:03:20,500
And so there's a stretch of code here

1062
01:03:20,500 --> 01:03:24,730
and exit that is re-parenting the exiting processes children,

1063
01:03:24,730 --> 01:03:26,200
so that their parents of init,

1064
01:03:26,200 --> 01:03:27,820
which is process id one.

1065
01:03:29,970 --> 01:03:33,780
And then finally, a process wakes up its own parent,

1066
01:03:34,170 --> 01:03:36,780
which might be waiting and sleeping and wait,

1067
01:03:39,500 --> 01:03:43,840
and sets its state to the zombie state,

1068
01:03:44,950 --> 01:03:46,000
it turns out we haven't,

1069
01:03:46,580 --> 01:03:47,480
but we'll see in a moment,

1070
01:03:47,480 --> 01:03:51,680
but the process hasn't completely finished releasing all of its resources,

1071
01:03:52,040 --> 01:03:54,830
so it's not quite ready to be reused,

1072
01:03:55,190 --> 01:03:57,080
we want to end up in a position,

1073
01:03:57,080 --> 01:04:01,730
where the process can be and all its state can be reused by a fork,

1074
01:04:02,000 --> 01:04:04,670
by some other fork that's unrelated right.

1075
01:04:05,100 --> 01:04:06,630
But we're not quite there yet,

1076
01:04:06,750 --> 01:04:08,820
and we'll see why in a moment,

1077
01:04:08,820 --> 01:04:10,680
we set the state to zombie,

1078
01:04:11,760 --> 01:04:14,940
and then we're not done yet,

1079
01:04:14,940 --> 01:04:16,470
we haven't freed the process,

1080
01:04:16,530 --> 01:04:19,410
we just jump into the scheduler,

1081
01:04:20,200 --> 01:04:25,880
without having completely finished freeing our resources.

1082
01:04:27,730 --> 01:04:28,630
Okay.

1083
01:04:29,440 --> 01:04:31,300
So the story here continues,

1084
01:04:31,330 --> 01:04:34,210
this point zombie process won't be run,

1085
01:04:34,210 --> 01:04:36,700
the scheduler only runs runnable processes,

1086
01:04:36,700 --> 01:04:38,890
so this process isn't quite free,

1087
01:04:38,920 --> 01:04:40,870
because that would be state equals unused,

1088
01:04:40,990 --> 01:04:42,730
but it's definitely not going to run again,

1089
01:04:42,760 --> 01:04:43,930
because in state zombie,

1090
01:04:43,930 --> 01:04:47,980
so [] to the scheduler, scheduler now runs something else.

1091
01:04:49,740 --> 01:04:53,460
We knew from the sort of description of exit and wait,

1092
01:04:53,520 --> 01:04:56,940
in Unix that, if a process exits,

1093
01:04:56,940 --> 01:05:00,330
then its parent calls wait,

1094
01:05:00,330 --> 01:05:03,480
the wait, that wait is going to return to signal to the parent,

1095
01:05:03,480 --> 01:05:05,790
that one of its children is exited,

1096
01:05:05,970 --> 01:05:08,010
so we can look for the implementation of wait.

1097
01:05:12,770 --> 01:05:16,940
Also, here is the big loop, this implementation of wait,

1098
01:05:16,940 --> 01:05:21,230
but really what's going on is that when a process calls wait,

1099
01:05:21,680 --> 01:05:23,990
it scans the process table,

1100
01:05:25,560 --> 01:05:31,380
looking for processes whose parent is the current process,

1101
01:05:34,400 --> 01:05:36,260
and in particular looking for processes,

1102
01:05:36,260 --> 01:05:39,350
whose parent is the current process and in state zombie,

1103
01:05:39,380 --> 01:05:42,110
that is they've gotten that far,

1104
01:05:42,110 --> 01:05:45,230
in in exit or almost finished exiting.

1105
01:05:47,280 --> 01:05:49,980
So now we found this called a wait to the wait system calls,

1106
01:05:49,980 --> 01:05:52,500
found a child process that has exited.

1107
01:05:54,930 --> 01:06:02,190
And, I don't know if you remember exit can return this 32 bit exit status,

1108
01:06:02,190 --> 01:06:04,710
so the parents of the next bunch of code collects that,

1109
01:06:05,040 --> 01:06:08,970
and then it's the parent that calls freeproc,

1110
01:06:09,300 --> 01:06:13,290
which does the final steps in freeing up process's resources.

1111
01:06:13,380 --> 01:06:14,730
So we'll look at freeproc,

1112
01:06:15,670 --> 01:06:19,030
and this is the final shutdown of stuff, that would be quite awkward,

1113
01:06:19,030 --> 01:06:23,500
if the if the exiting process itself freed, while it was executing,

1114
01:06:24,520 --> 01:06:28,720
it freezes trapframe, freeze the user page table,

1115
01:06:29,260 --> 01:06:32,770
and if we freed kernel stacks,

1116
01:06:32,800 --> 01:06:37,540
the process's, existing process's kernel stack would be freed here also,

1117
01:06:37,810 --> 01:06:44,340
but because of the stack guard, kernel stack stack guard page is,

1118
01:06:44,340 --> 01:06:49,680
we don't actually ever turns out, we don't free, whenever free the kernel stacks,

1119
01:06:50,280 --> 01:06:53,940
but all the stuff that would be a sort of potentially a pain to free in the exit,

1120
01:06:54,520 --> 01:06:57,970
while the exiting process is running is freed by the parent.

1121
01:07:00,610 --> 01:07:01,810
One thing to notice here is that,

1122
01:07:01,810 --> 01:07:06,750
wait, wait is not just for the convenience of parents,

1123
01:07:06,750 --> 01:07:09,150
that want to know when their when their children have exited,

1124
01:07:09,390 --> 01:07:12,780
wait is actually critical piece of the exit process

1125
01:07:12,780 --> 01:07:16,710
and you really in Unix, it's just a requirement,

1126
01:07:16,920 --> 01:07:21,240
that there be a wait that corresponds to every exiting process

1127
01:07:21,240 --> 01:07:25,800
and that's really the reason why when a process exits its children

1128
01:07:26,040 --> 01:07:28,050
are sort of given away to init,

1129
01:07:28,630 --> 01:07:31,120
they're turning to init children,

1130
01:07:31,240 --> 01:07:35,260
when init does just calls wait in a loop,

1131
01:07:35,500 --> 01:07:37,780
because every process has to be waited for,

1132
01:07:37,780 --> 01:07:42,880
so that the parent can call freeproc and finish freeing up resources

1133
01:07:42,880 --> 01:07:44,230
and then when it's completely done,

1134
01:07:44,860 --> 01:07:50,410
it sets if the parents done freeing all the exit processes resources,

1135
01:07:51,040 --> 01:07:53,470
sets that child state unused,

1136
01:07:53,470 --> 01:07:59,890
now fork and you know some future called a fork can reuse that process slot.

1137
01:08:03,760 --> 01:08:04,660
Any questions?

1138
01:08:07,890 --> 01:08:10,770
Oh, I have a question about sleep,

1139
01:08:10,920 --> 01:08:16,320
so in sleep where we are.

1140
01:08:17,500 --> 01:08:19,720
Yeah, so when we are,

1141
01:08:20,860 --> 01:08:23,390
oh, sorry, not sleep, exit.

1142
01:08:23,390 --> 01:08:24,500
I want say exit, yeah.

1143
01:08:28,340 --> 01:08:30,560
Yeah, so why are we,

1144
01:08:31,450 --> 01:08:37,450
why are we grabbing original parent before we reparent,

1145
01:08:37,480 --> 01:08:38,740
is that necessary.

1146
01:08:42,000 --> 01:08:47,900
This is [] code, that's wrestling with the possibility

1147
01:08:47,960 --> 01:08:54,530
that a process and its parent may exit at the same time.

1148
01:08:55,670 --> 01:08:57,680
And there's some,

1149
01:08:58,800 --> 01:09:03,510
even though ordinarily, just nothing interesting going on process exits,

1150
01:09:03,810 --> 01:09:05,970
its parent waits for it, everything's fine,

1151
01:09:06,780 --> 01:09:09,390
but it could be that parent, that a process exits

1152
01:09:09,480 --> 01:09:11,460
and its parent process exits at the same time

1153
01:09:11,460 --> 01:09:16,230
and so while we're trying to wake up our parent to tell we've exited,

1154
01:09:16,260 --> 01:09:17,940
that parent is itself exiting.

1155
01:09:18,460 --> 01:09:21,700
And a lot of this code here,

1156
01:09:22,420 --> 01:09:25,800
which I feel I kind of understood a year ago,

1157
01:09:25,800 --> 01:09:28,080
but don't any longer understand,

1158
01:09:28,110 --> 01:09:33,420
is about taking care of this rare case of concurrent exits of a parent and child.

1159
01:09:33,960 --> 01:09:36,240
And if it weren't for that,

1160
01:09:36,330 --> 01:09:37,980
it would all be extremely straightforward,

1161
01:09:37,980 --> 01:09:39,780
a parent, the process would have a parent

1162
01:09:39,930 --> 01:09:43,110
and it would just wake up its parent at this point.

1163
01:09:45,660 --> 01:09:48,380
And, we wouldn't,

1164
01:09:48,470 --> 01:09:51,170
it were for concurrent exits a parent and child.

1165
01:09:51,780 --> 01:09:54,420
The child could just wake up its parent period.

1166
01:09:54,450 --> 01:09:56,010
Okay, I see, thank you.

1167
01:09:56,040 --> 01:09:58,170
Sorry to not really be explaining here.

1168
01:09:59,510 --> 01:10:00,830
I have a quick question,

1169
01:10:01,370 --> 01:10:07,550
so why are we setting the process state to zombie after we wake up the parent,

1170
01:10:07,700 --> 01:10:09,620
we want to do that before.

1171
01:10:09,860 --> 01:10:15,450
Oh yeah, it turns out because we've acquired the,

1172
01:10:16,170 --> 01:10:19,710
the existing processes that required its own process lock,

1173
01:10:19,980 --> 01:10:22,230
the parent can't look at this process.

1174
01:10:22,760 --> 01:10:25,850
And we've acquired our own lock here

1175
01:10:25,850 --> 01:10:27,020
and then we're going to call sched,

1176
01:10:27,020 --> 01:10:34,160
the parent, is parents wait acquires p-> requires the child's lock, which is p->lock

1177
01:10:34,550 --> 01:10:37,070
and so that means that between this acquire

1178
01:10:37,130 --> 01:10:43,280
and when after we call sched and the scheduler thread releases this p->lock,

1179
01:10:43,340 --> 01:10:48,280
the parent can't look at this process in this block of code.

1180
01:10:48,310 --> 01:10:48,790
Okay.

1181
01:10:48,940 --> 01:10:51,490
So the order of this stuff doesn't matter,

1182
01:10:51,490 --> 01:10:54,710
indeed if we didn't have the lock up,

1183
01:10:55,350 --> 01:10:56,880
it's possible some other.

1184
01:10:57,240 --> 01:11:03,790
Well, in most situations, no order would work if we didn't hold the lock.

1185
01:11:06,530 --> 01:11:09,620
Anyway, yeah because we hold a lock, that the order doesn't matter,

1186
01:11:09,620 --> 01:11:10,760
because the parent can't look.

1187
01:11:11,120 --> 01:11:11,930
That makes sense.

1188
01:11:19,020 --> 01:11:20,190
Okay.

1189
01:11:21,980 --> 01:11:26,810
Okay, so the trick here is the trick I wanted to emphasize was that,

1190
01:11:29,150 --> 01:11:33,200
to a great extent, actually the child doesn't,

1191
01:11:33,620 --> 01:11:35,660
in the end, the child doesnt free all its resources,

1192
01:11:35,660 --> 01:11:37,790
because it can't, because it's still using the whole executes

1193
01:11:37,790 --> 01:11:41,480
and instead some other thread, namely the parent

1194
01:11:41,630 --> 01:11:47,270
does the freeing of the delicate resources that are required for execution,

1195
01:11:47,780 --> 01:11:49,370
so that's sort of a trick

1196
01:11:49,370 --> 01:11:53,810
to allow us to that greatly simplify exit.

1197
01:11:56,080 --> 01:12:00,270
Okay, the last thing I want to look at is kill,

1198
01:12:00,690 --> 01:12:04,290
so that you know the kill system call,

1199
01:12:04,290 --> 01:12:08,250
one process in Unix can call that make the kill system call,

1200
01:12:08,520 --> 01:12:11,040
passes the process id of a different process

1201
01:12:11,280 --> 01:12:12,570
and the goal is that

1202
01:12:12,660 --> 01:12:16,920
that should cause that other process, the target process to stop executing.

1203
01:12:17,510 --> 01:12:20,030
And if we're not careful,

1204
01:12:20,030 --> 01:12:23,750
you know this risks especially if other processes executing in the kernel,

1205
01:12:24,560 --> 01:12:28,370
this risk is probably mentioned a few minutes ago,

1206
01:12:28,370 --> 01:12:32,240
where gosh that you know the kernel thread of the process you're trying to kill

1207
01:12:32,240 --> 01:12:34,340
might might in the middle of updating something,

1208
01:12:34,340 --> 01:12:37,190
you know updating the file system, creating a file, for example

1209
01:12:37,250 --> 01:12:40,190
and we can't just kill it dead on the spot,

1210
01:12:40,190 --> 01:12:45,710
because that would leave some delicate multi step operation only halfway completed.

1211
01:12:46,200 --> 01:12:51,930
Now, so we know that kill can't really just stop the target process,

1212
01:12:52,350 --> 01:12:56,850
and indeed in xv6 and the Unix as well,

1213
01:12:56,970 --> 01:13:00,090
kill does almost absolutely nothing,

1214
01:13:01,050 --> 01:13:04,800
it scans the process table looking for the target process id

1215
01:13:04,860 --> 01:13:11,110
and just sets this flag in that process's process structure,

1216
01:13:12,000 --> 01:13:16,140
and also, if it was sleeping, calls to be runnable,

1217
01:13:16,140 --> 01:13:17,400
so to wake up from sleep,

1218
01:13:17,400 --> 01:13:19,080
but all it does is set this flag,

1219
01:13:19,110 --> 01:13:23,610
it doesn't stop the other process from executing or anything like it.

1220
01:13:26,490 --> 01:13:29,910
Kill itself very gentle,

1221
01:13:30,790 --> 01:13:33,730
the game is that,

1222
01:13:33,730 --> 01:13:37,690
the target process at points in the kernel code

1223
01:13:37,690 --> 01:13:40,420
where it would be safe to stop executing,

1224
01:13:41,170 --> 01:13:45,100
the other process checks its own killed flag,

1225
01:13:45,130 --> 01:13:46,090
and if it's set,

1226
01:13:46,180 --> 01:13:51,580
the other process sort of voluntarily exits, calls this exit function

1227
01:13:52,240 --> 01:13:56,300
and you can see some of those points at trap.c,

1228
01:13:56,690 --> 01:14:00,560
in fact you can see all the points trap.c,

1229
01:14:01,400 --> 01:14:02,870
so if we're in usertrap

1230
01:14:02,870 --> 01:14:06,590
in a system call, before actually executing the system call,

1231
01:14:06,620 --> 01:14:08,570
if the process has already been killed

1232
01:14:08,840 --> 01:14:11,810
or if kill has been called for this process,

1233
01:14:12,050 --> 01:14:14,510
then the process calls exit and goes away.

1234
01:14:15,180 --> 01:14:18,030
And this is a point in the kernel where it's not holding any locks,

1235
01:14:18,030 --> 01:14:19,740
it's not in the middle of doing anything,

1236
01:14:20,190 --> 01:14:25,050
and so it's completely safe for the process to just quit and call exit.

1237
01:14:26,230 --> 01:14:31,450
And there's a similar check, at the end of usertrap.

1238
01:14:33,920 --> 01:14:39,360
So after a system call, the process also checks if it's being killed

1239
01:14:39,420 --> 01:14:44,190
and indeed this code here executes,

1240
01:14:44,430 --> 01:14:47,610
even if the process is interrupted by an interrupt,

1241
01:14:47,610 --> 01:14:49,890
so for example the timer interrupt goes off,

1242
01:14:50,160 --> 01:14:52,830
then this code will execute

1243
01:14:52,830 --> 01:14:55,140
and we'll see that the process has been killed

1244
01:14:55,140 --> 01:14:56,430
and then the process will exit.

1245
01:14:59,350 --> 01:15:00,970
And so what that means is

1246
01:15:00,970 --> 01:15:05,320
that the what kill means, kill the meaning of kill,

1247
01:15:05,320 --> 01:15:09,100
the effective kill is not exactly stop the other process right now,

1248
01:15:09,650 --> 01:15:10,820
it's much more like,

1249
01:15:11,030 --> 01:15:14,900
well you know if the process other processes in user space,

1250
01:15:14,900 --> 01:15:17,420
then the next time it makes a system call,

1251
01:15:18,500 --> 01:15:19,610
it will exit

1252
01:15:20,300 --> 01:15:22,490
or the next time a timer interrupt goes off

1253
01:15:22,490 --> 01:15:26,240
while executing user code in the target process,

1254
01:15:26,360 --> 01:15:29,060
if it's interrupted by a timer interrupt or some other interrupt,

1255
01:15:29,210 --> 01:15:30,920
then it will also exit.

1256
01:15:30,920 --> 01:15:32,660
So there might be a significant delay,

1257
01:15:32,660 --> 01:15:38,480
between when one process calls kill and when the other process actually exits.

1258
01:15:39,440 --> 01:15:42,620
And that's just the way it is.

1259
01:15:44,420 --> 01:15:45,980
There's a sort of intermediate question

1260
01:15:45,980 --> 01:15:49,490
though if the process is not in use, it's own user space,

1261
01:15:49,490 --> 01:15:51,350
but is in the middle of a system call,

1262
01:15:53,180 --> 01:15:54,320
and it's killed,

1263
01:15:54,650 --> 01:15:56,240
do we need to do anything special?

1264
01:15:57,110 --> 01:15:59,840
The reason why this may come up is,

1265
01:15:59,840 --> 01:16:03,540
suppose the process is reading from the console, right,

1266
01:16:03,600 --> 01:16:05,550
you know reading for the next character you type,

1267
01:16:05,550 --> 01:16:07,830
you may not type another character until tomorrow.

1268
01:16:08,440 --> 01:16:11,380
And it would be nice if when you kill the process,

1269
01:16:11,380 --> 01:16:14,020
it actually went away before tomorrow.

1270
01:16:15,970 --> 01:16:20,290
And for that reason, in a number of points in xv6

1271
01:16:20,290 --> 01:16:23,710
in which a process is sleeping,

1272
01:16:24,320 --> 01:16:26,000
xv6 actually arranges that,

1273
01:16:26,000 --> 01:16:29,420
if it's killed while sleeping in the kernel,

1274
01:16:29,990 --> 01:16:31,580
it will actually exit.

1275
01:16:31,730 --> 01:16:33,920
So, let me show you the machinery for that,

1276
01:16:34,760 --> 01:16:37,340
the first thing to look at is in kill itself.

1277
01:16:39,020 --> 01:16:43,160
You can see that if the target process is sleeping,

1278
01:16:43,720 --> 01:16:45,640
then kill will set state to runnable

1279
01:16:45,940 --> 01:16:48,190
and that'll mean that even if it had called sleep,

1280
01:16:48,750 --> 01:16:50,070
the scheduler will now run it

1281
01:16:50,100 --> 01:16:52,320
and it will simply return from sleep.

1282
01:16:52,800 --> 01:16:56,850
And so let's look at a place where that actually matters,

1283
01:16:56,850 --> 01:17:02,010
in the pipe code, if a process is in sleep waiting to read a pipe,

1284
01:17:05,190 --> 01:17:08,970
and it's killed, kill set to runnable return from sleep,

1285
01:17:09,060 --> 01:17:10,770
go back to the top of this loop,

1286
01:17:11,310 --> 01:17:13,440
probably if there was no data in the pipe,

1287
01:17:13,440 --> 01:17:15,630
before the pi-, still be no data in the pipe,

1288
01:17:15,780 --> 01:17:21,720
and now piperead at least checks whether the process has been killed

1289
01:17:21,840 --> 01:17:22,890
and if it has been killed,

1290
01:17:22,890 --> 01:17:24,120
instead of sleeping again,

1291
01:17:24,300 --> 01:17:28,410
the piperead will return return an error, doesn't really matter,

1292
01:17:28,440 --> 01:17:33,540
but we're returning to is this syscall,

1293
01:17:33,540 --> 01:17:35,880
since we're in a system call,

1294
01:17:36,400 --> 01:17:41,230
where pipe really returns to in the end is returns from the system call,

1295
01:17:41,470 --> 01:17:45,310
and then usertrap checks p->killed again

1296
01:17:45,430 --> 01:17:46,300
and will now exit.

1297
01:17:46,810 --> 01:17:49,700
So for, sleeps,

1298
01:17:49,790 --> 01:17:55,280
that we know it's okay to just bail out of when a process is killed,

1299
01:17:55,640 --> 01:17:58,310
those loop's check the killed flag,

1300
01:17:58,340 --> 01:18:01,610
but there are also sleeps where it would not be okay,

1301
01:18:02,060 --> 01:18:03,680
for a process to quit,

1302
01:18:03,680 --> 01:18:05,120
if it's killed in that sleep.

1303
01:18:05,990 --> 01:18:10,580
So, for example if a process is in the middle of updating the file system on disk

1304
01:18:10,580 --> 01:18:11,750
to create a new file

1305
01:18:11,930 --> 01:18:14,450
that is it bad time,

1306
01:18:14,600 --> 01:18:16,520
even if it's sleeping waiting for the disk,

1307
01:18:16,520 --> 01:18:19,970
that's a bad time for a process to just decide to quit,

1308
01:18:19,970 --> 01:18:20,720
because it's been killed,

1309
01:18:20,720 --> 01:18:23,120
we want to finish the complete file system operation,

1310
01:18:23,240 --> 01:18:25,460
and only then have the process exit,

1311
01:18:25,790 --> 01:18:27,230
and so you can see this,

1312
01:18:27,350 --> 01:18:28,340
we've looked at this,

1313
01:18:28,340 --> 01:18:33,200
but I'll show you in the disk driver.

1314
01:18:33,960 --> 01:18:35,820
An example of a sleep loop,

1315
01:18:35,880 --> 01:18:37,380
that doesn't check killed,

1316
01:18:37,590 --> 01:18:38,520
look at that,

1317
01:18:40,720 --> 01:18:42,310
so here we are, this is the sleep

1318
01:18:42,730 --> 01:18:48,230
in which they process waits for the disk to finish reading a disk block,

1319
01:18:48,290 --> 01:18:50,060
and it absolutely doesn't check killed,

1320
01:18:50,750 --> 01:18:53,360
because it wants to finish it,

1321
01:18:53,360 --> 01:18:54,860
maybe in the middle of creating a file,

1322
01:18:54,860 --> 01:18:56,870
which involves multiple disk reads and writes,

1323
01:18:57,020 --> 01:18:59,420
want to finish the entire file system operation,

1324
01:18:59,600 --> 01:19:00,860
the entire system call

1325
01:19:01,250 --> 01:19:03,770
and only then check p->killed and exit.

1326
01:19:06,990 --> 01:19:08,280
Questions about anything?

1327
01:19:10,820 --> 01:19:11,870
I have a question,

1328
01:19:11,870 --> 01:19:15,290
about why kill allowed in the way it it,

1329
01:19:15,530 --> 01:19:18,320
why wouldn't the process kill all the other processes

1330
01:19:18,320 --> 01:19:21,790
if you can run, oh, by itself.

1331
01:19:25,140 --> 01:19:28,140
Well, you know you do that MIT on a Athena time sharing machine

1332
01:19:28,140 --> 01:19:29,460
will probably kick you out of school.

1333
01:19:31,490 --> 01:19:34,820
Right, but why is it allowed.

1334
01:19:34,940 --> 01:19:39,950
It's allowed in xv6, because xv6 is a toy operating system,

1335
01:19:39,950 --> 01:19:44,300
that it just the,

1336
01:19:44,960 --> 01:19:51,820
anything that has to do with like permissions just doesn't exist in xv6,

1337
01:19:52,360 --> 01:19:54,610
in Linux or a real operating system,

1338
01:19:55,150 --> 01:19:57,580
every process has a user id,

1339
01:19:57,910 --> 01:20:02,650
that corresponds to the more or less to the human user who's executing the process

1340
01:20:02,710 --> 01:20:07,330
and some system calls use the user id of the process

1341
01:20:07,330 --> 01:20:10,030
to kind of check what is the process allowed to do this,

1342
01:20:10,450 --> 01:20:15,760
and so in Linux, you would see a extra check here,

1343
01:20:15,790 --> 01:20:21,250
that said that the calling process has to have the same user id,

1344
01:20:21,340 --> 01:20:23,080
as the process is trying to kill,

1345
01:20:23,290 --> 01:20:24,700
otherwise it's not allowed.

1346
01:20:25,730 --> 01:20:28,490
And that, at least in a time sharing context,

1347
01:20:29,170 --> 01:20:30,460
we have multiple users

1348
01:20:30,460 --> 01:20:32,320
and we don't want them to kill each other's processes,

1349
01:20:32,410 --> 01:20:35,410
that's more or less sufficient to keep people from

1350
01:20:35,440 --> 01:20:39,040
make it hard for people to kill other people's processes.

1351
01:20:41,090 --> 01:20:42,320
Okay I see, thank you.

1352
01:20:45,400 --> 01:20:47,740
Does init process ever exit?

1353
01:20:48,770 --> 01:20:50,210
Let me check.

1354
01:20:54,430 --> 01:20:57,580
Yes, if fork fails, exit,

1355
01:20:57,640 --> 01:21:00,610
however the real answer to the question is no,

1356
01:21:00,610 --> 01:21:03,430
the intent is that init never exit,

1357
01:21:03,760 --> 01:21:05,110
they just sit in this loop

1358
01:21:05,500 --> 01:21:09,950
and what is doing is calling wait over and over again,

1359
01:21:10,340 --> 01:21:15,800
if init exits, I think that's a fatal error in the system will crash.

1360
01:21:16,360 --> 01:21:19,330
There's code somewhere in the kernel, it says, may be in exit.

1361
01:21:19,940 --> 01:21:20,870
Just check exit.

1362
01:21:30,240 --> 01:21:33,150
Yeah, here we are, exit, at the beginning of exit,

1363
01:21:33,330 --> 01:21:37,230
if it looks like the current process is the init process, it's a panic.

1364
01:21:37,860 --> 01:21:41,690
Because, this system would eventually [] to a halt,

1365
01:21:41,690 --> 01:21:42,710
if there were no init,

1366
01:21:42,740 --> 01:21:45,290
because then there would be nothing collect,

1367
01:21:45,320 --> 01:21:48,380
nothing to call wait on these exiting processes

1368
01:21:48,380 --> 01:21:50,690
and nothing to complete the freeing of the processes

1369
01:21:50,690 --> 01:21:52,400
and gradually we run out of processes,

1370
01:21:52,400 --> 01:21:55,810
and then that would be some other error.

1371
01:21:56,940 --> 01:21:58,230
We have to have init.

1372
01:21:58,700 --> 01:21:59,780
So the real answer is that no,

1373
01:21:59,780 --> 01:22:01,430
it really can't be allowed to exit,

1374
01:22:02,260 --> 01:22:02,980
better not exit.

1375
01:22:08,750 --> 01:22:09,290
Okay.

1376
01:22:12,580 --> 01:22:13,480
Any other questions?

1377
01:22:16,280 --> 01:22:18,500
Um, it's another question,

1378
01:22:18,770 --> 01:22:22,160
so, we haven't really talked about much in this class yet,

1379
01:22:22,160 --> 01:22:27,460
but look what happens or what needs to happen to shut down the OS.

1380
01:22:28,480 --> 01:22:29,380
Got unplugged.

1381
01:22:30,840 --> 01:22:31,320
Okay.

1382
01:22:31,350 --> 01:22:32,310
Okay.

1383
01:22:32,340 --> 01:22:33,360
Yeah.

1384
01:22:33,870 --> 01:22:36,270
Yeah, this is very complex,

1385
01:22:36,270 --> 01:22:37,740
and it depends on what you're running,

1386
01:22:37,740 --> 01:22:41,990
if you're, if the operating if the machine is currently doing nothing,

1387
01:22:42,650 --> 01:22:47,510
well, part of the answer the question is

1388
01:22:47,510 --> 01:22:49,640
that the file system ends up being,

1389
01:22:50,610 --> 01:22:53,130
because the file system is permanent,

1390
01:22:53,430 --> 01:22:56,970
you know the file system is carried over from reboot to reboot.

1391
01:22:57,790 --> 01:23:00,940
We need to leave the file system in good shape,

1392
01:23:01,060 --> 01:23:04,930
so if we were in the middle of some update to the file system,

1393
01:23:04,930 --> 01:23:06,130
like creating a file,

1394
01:23:06,160 --> 01:23:09,910
then we want to shut the system down or the power fails or something,

1395
01:23:09,910 --> 01:23:13,090
we absolutely need a strategy to make sure that,

1396
01:23:14,340 --> 01:23:17,010
even though we were in the middle of some complex update to the file system,

1397
01:23:17,010 --> 01:23:19,680
that we don't leave it in the file system in a state,

1398
01:23:20,010 --> 01:23:25,950
we don't expose any broken invariance in the on disk file system structures,

1399
01:23:26,100 --> 01:23:29,100
because the files is really just a data structure, that lives on disk.

1400
01:23:29,750 --> 01:23:32,720
So there's like a lot of,

1401
01:23:33,320 --> 01:23:35,990
that's sort of machinery involved in making sure that

1402
01:23:35,990 --> 01:23:38,900
if you shut down or the power fails or who knows what that,

1403
01:23:39,170 --> 01:23:43,670
the disk can, that we can recover the file system on disk.

1404
01:23:45,030 --> 01:23:46,620
For the rest of, it's not for that,

1405
01:23:49,100 --> 01:23:52,700
then, whether you have to do anything special to shutdown

1406
01:23:52,730 --> 01:23:55,100
depends on what processes you're running,

1407
01:23:55,190 --> 01:23:58,280
if you're running some important server, a database server,

1408
01:23:58,280 --> 01:24:01,730
that a lot of other computers depend on and use over the network,

1409
01:24:02,210 --> 01:24:06,530
who knows, the answer may be that you just cannot be allowed to shut down,

1410
01:24:06,530 --> 01:24:10,490
because you're providing a service that's critical to a bunch of other computers.

1411
01:24:11,080 --> 01:24:12,850
If your computer is not doing much of anything.

1412
01:24:15,200 --> 01:24:16,760
Then you can just turn it off

1413
01:24:16,940 --> 01:24:19,170
and it will stop executing

1414
01:24:20,040 --> 01:24:21,180
and there's not much to do,

1415
01:24:21,270 --> 01:24:23,280
really, may be the answer to your question is,

1416
01:24:24,360 --> 01:24:25,410
if you want to shut down the computer,

1417
01:24:25,410 --> 01:24:27,270
make sure the file system is in good shape

1418
01:24:27,300 --> 01:24:30,270
and then stop executing instructions and that's fine.

1419
01:24:31,730 --> 01:24:32,240
Good.

1420
01:24:32,240 --> 01:24:34,010
That makes sense, yeah, thank you.

1421
01:24:37,090 --> 01:24:37,930
Anything else?

1422
01:24:41,980 --> 01:24:44,020
Oh, sorry, I have another question,

1423
01:24:44,020 --> 01:24:46,960
so what is this semaphore interface.

1424
01:24:48,740 --> 01:24:50,000
About p and v.

1425
01:24:53,330 --> 01:24:57,080
So just two, just those two functions?

1426
01:24:57,650 --> 01:24:59,360
Um, yeah.

1427
01:25:00,100 --> 01:25:02,470
Yeah, xv6 doesn't have semaphores really,

1428
01:25:02,470 --> 01:25:05,110
but you know the books semaphores, I think it's just p and v,

1429
01:25:05,170 --> 01:25:09,310
there are two methods, you have a semaphore object has two methods p and v.

1430
01:25:11,010 --> 01:25:13,080
Okay, I see, thank you.

1431
01:25:13,110 --> 01:25:13,560
Sure.

1432
01:25:20,600 --> 01:25:21,410
Anything else?

1433
01:25:25,170 --> 01:25:25,830
Alright.

