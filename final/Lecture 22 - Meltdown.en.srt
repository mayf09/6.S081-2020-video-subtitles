1
00:00:00,950 --> 00:00:03,580
Alright, anyone hear me?

2
00:00:04,210 --> 00:00:05,980
Good.

3
00:00:07,480 --> 00:00:08,890
Alright today we got meltdown,

4
00:00:09,370 --> 00:00:13,210
the reason why I'm reading this paper is that,

5
00:00:13,690 --> 00:00:18,400
security has kind of been a topic all along

6
00:00:18,400 --> 00:00:21,880
and comes up a lot in the design of the kernels,

7
00:00:21,940 --> 00:00:23,530
that we talked about in the class

8
00:00:24,400 --> 00:00:27,820
and as we know the main strategy, we've talked about for,

9
00:00:28,330 --> 00:00:32,320
what it main for a kernel to provide security is isolation,

10
00:00:33,460 --> 00:00:36,280
in the sense that user programs can read data from the kernel

11
00:00:36,280 --> 00:00:40,780
and user programs can't read other user's data from other user programs,

12
00:00:41,500 --> 00:00:45,590
and the specific techniques that you know we've seen,

13
00:00:45,590 --> 00:00:48,740
operating systems used in order to get isolation

14
00:00:48,740 --> 00:00:51,620
or things like the user supervisor mode in the hardware

15
00:00:51,770 --> 00:00:53,870
and the page tables in the hardware

16
00:00:54,650 --> 00:00:59,090
as well as just sort of well designed kernel software,

17
00:00:59,090 --> 00:01:00,740
like the system calls are all defensive

18
00:01:00,740 --> 00:01:05,720
about how they use user supplied pointers.

19
00:01:07,460 --> 00:01:09,680
But it's worth thinking about,

20
00:01:09,770 --> 00:01:13,220
looking at examples of how this kind of stuff goes wrong,

21
00:01:13,250 --> 00:01:16,910
I mean in fact, you know kernels try hard to provide isolation and security,

22
00:01:16,910 --> 00:01:19,400
but there are problems that come up.

23
00:01:19,550 --> 00:01:24,980
And this paper is a one of the most interesting problems,

24
00:01:24,980 --> 00:01:28,160
that's come up with operating system security in recent times.

25
00:01:28,520 --> 00:01:30,740
Meltdown is came out,

26
00:01:30,740 --> 00:01:35,090
it was published at the beginning of 2018 so not too long ago,

27
00:01:35,810 --> 00:01:38,390
and a lot of people like me found it surprising

28
00:01:38,390 --> 00:01:40,070
and actually pretty disturbing,

29
00:01:40,600 --> 00:01:43,570
pretty disturbing attack on user kernel isolation.

30
00:01:46,020 --> 00:01:50,910
It really undermined faith or sort of this very basic assumption,

31
00:01:50,910 --> 00:01:55,710
that the page tables that the hardware supplies just get you isolation

32
00:01:55,710 --> 00:01:57,150
and that's the end of the story

33
00:01:57,390 --> 00:02:01,380
and this attack does not support that view at all,

34
00:02:01,830 --> 00:02:05,100
further it was an example of,

35
00:02:05,100 --> 00:02:08,730
one of a number of recent examples of what's called a microarchitectural attack,

36
00:02:08,760 --> 00:02:17,550
an attack that involves exploitation of hidden implementation details inside the CPU,

37
00:02:17,580 --> 00:02:22,770
that are often not even known how this how CPU's work,

38
00:02:22,860 --> 00:02:24,300
but people guess

39
00:02:24,360 --> 00:02:28,230
and they're able to make successful attacks based on correct guesses

40
00:02:28,650 --> 00:02:32,460
about hidden details of CPU implementation.

41
00:02:34,060 --> 00:02:35,530
Meltdown turns out to be fixable

42
00:02:35,620 --> 00:02:39,250
and seems to be pretty completely fixed,

43
00:02:39,640 --> 00:02:43,450
but nevertheless people it sort of set people up to fear,

44
00:02:43,630 --> 00:02:49,450
that there might be an open-ended supply of similar microarchitectural attacks.

45
00:02:49,920 --> 00:02:55,740
So it's a pretty important recent event worth understanding.

46
00:02:56,520 --> 00:03:06,320
Let me start by just laying out the basic core of the attack,

47
00:03:06,410 --> 00:03:08,450
and we'll talk about what's going on here,

48
00:03:08,450 --> 00:03:12,310
but this is somewhat simplified version of the code

49
00:03:12,310 --> 00:03:14,110
in the paper for how the attack works,

50
00:03:14,410 --> 00:03:16,840
the basic idea is that you're an attacker,

51
00:03:16,990 --> 00:03:22,690
and for one reason or another you're able to run software on some computer,

52
00:03:22,690 --> 00:03:24,910
that has some secrets that you'd like to steal,

53
00:03:24,940 --> 00:03:26,950
you're not allowed to directly get up the secrets,

54
00:03:26,950 --> 00:03:30,070
but they're in memory, maybe kernel memory or another processes memory,

55
00:03:30,130 --> 00:03:32,410
but you've been able to run a process,

56
00:03:32,410 --> 00:03:36,310
maybe because you logged into a time sharing machine like Athena machine,

57
00:03:36,310 --> 00:03:40,210
or maybe because you bought time on some hosting service.

58
00:03:40,900 --> 00:03:45,430
So what the attack allows you to do is run a program

59
00:03:45,430 --> 00:03:49,330
in which you declare a buffer in your own memory,

60
00:03:49,330 --> 00:03:53,920
so this buf is a just ordinary user memory that's accessible,

61
00:03:54,670 --> 00:03:59,740
you have the virtual address in the kernel of something that you're interested in stealing.

62
00:04:02,590 --> 00:04:04,210
And you issue,

63
00:04:04,240 --> 00:04:05,680
what I'm writing out here is sort of

64
00:04:05,680 --> 00:04:09,310
you know mix of C and assembler,

65
00:04:09,310 --> 00:04:11,170
but what I mean in line 3 is that,

66
00:04:11,290 --> 00:04:14,830
you have the address of the kernel virtual address of the data

67
00:04:14,830 --> 00:04:17,050
you want to steal at register one or r1

68
00:04:17,260 --> 00:04:25,180
and line 3 were, or just imagine that this is instructions to dereference register one

69
00:04:25,180 --> 00:04:27,310
and load its results into register two,

70
00:04:27,760 --> 00:04:29,680
that's the instruction that we're going to run,

71
00:04:30,100 --> 00:04:31,810
and then there's an instruction that,

72
00:04:32,590 --> 00:04:37,120
just gets the low bit of register two,

73
00:04:37,120 --> 00:04:42,340
so this attack, this particular version of this attack reads just a single bit,

74
00:04:42,340 --> 00:04:46,600
just one low bit of a one memory location from the kernel,

75
00:04:47,200 --> 00:04:49,720
multiply that four thousand 4096

76
00:04:49,720 --> 00:04:51,130
and since it's either zero or one,

77
00:04:51,130 --> 00:04:54,580
that means that r2 will end up being zero or 4096

78
00:04:54,580 --> 00:04:57,610
and then we simply read the contents of our buf,

79
00:04:57,790 --> 00:04:59,810
which is a buffer of user memory,

80
00:04:59,870 --> 00:05:04,490
we simply read either buffer 0 or buffer 4096,

81
00:05:06,200 --> 00:05:07,430
and that's the basic attack.

82
00:05:11,640 --> 00:05:12,930
So, one question is,

83
00:05:13,860 --> 00:05:15,510
why doesn't this just directly work,

84
00:05:15,600 --> 00:05:18,660
line 3 reading this kernel address,

85
00:05:19,540 --> 00:05:21,520
can we just read addresses from the kernel.

86
00:05:25,620 --> 00:05:29,220
No, no, we all have faith that the answer can't possibly be yes,

87
00:05:29,220 --> 00:05:32,970
we can't possibly be able to just directly read from the kernel for in user space,

88
00:05:33,150 --> 00:05:39,510
and the machinery that we know the CPU somehow is invoking to make this not work out,

89
00:05:39,630 --> 00:05:43,080
is that when we use kernel virtual address,

90
00:05:43,110 --> 00:05:46,830
that implies a lookup in the page table,

91
00:05:47,240 --> 00:05:49,010
and there's permission bits in the page table

92
00:05:49,100 --> 00:05:51,710
and we're just assuming that the operating system

93
00:05:52,130 --> 00:05:56,690
has not set the flag in the page table entries for kernel virtual addresses,

94
00:05:56,690 --> 00:06:01,750
has not set that flag that allows users to use those addresses,

95
00:06:01,750 --> 00:06:04,570
that's the PTE_U flag on the RISC-V

96
00:06:04,870 --> 00:06:08,590
and that therefore this instruction must fail, must cause a page fault.

97
00:06:09,220 --> 00:06:10,780
And indeed, if we ran this code,

98
00:06:10,780 --> 00:06:12,370
this instruction would cause a page fault,

99
00:06:12,550 --> 00:06:16,870
and if we tried to, if we added a code after this,

100
00:06:16,870 --> 00:06:19,460
to say print the value in register 3,

101
00:06:20,090 --> 00:06:21,950
we get a page fault on line three,

102
00:06:21,950 --> 00:06:23,480
and we never get to the print statement,

103
00:06:23,720 --> 00:06:26,870
and we find we couldn't directly steal data out of the kernel.

104
00:06:30,920 --> 00:06:34,820
Nevertheless, the sequence turned out to be useful as the paper shows.

105
00:06:36,380 --> 00:06:42,690
One thing that, one thing that the paper assumes

106
00:06:42,810 --> 00:06:45,660
which is no longer really true for the most part is that,

107
00:06:45,750 --> 00:06:51,840
the kernel is mapped into every user processes address space,

108
00:06:52,240 --> 00:07:00,250
that is user user codes running a full set of kernel PTE is present in the page table,

109
00:07:00,280 --> 00:07:02,890
but they have the PTE_U bit clear,

110
00:07:03,130 --> 00:07:06,370
so user code will get a fault,

111
00:07:06,370 --> 00:07:09,700
if it tries to use a kernel virtual address,

112
00:07:09,940 --> 00:07:11,320
so all those mappings in,

113
00:07:11,320 --> 00:07:12,820
at the time this paper was written,

114
00:07:13,120 --> 00:07:16,300
all those mappings were there, when executing in user space,

115
00:07:16,450 --> 00:07:20,070
they just couldn't be used by user code

116
00:07:20,100 --> 00:07:22,560
or they cause a fault, they were used by user code,

117
00:07:22,560 --> 00:07:25,590
and the reason why people by operating system designers

118
00:07:25,800 --> 00:07:31,200
mapped both kernel and user addresses when running user code is

119
00:07:31,200 --> 00:07:33,690
that made system calls quite a bit faster,

120
00:07:33,930 --> 00:07:36,150
because that meant that on a system call happened,

121
00:07:36,240 --> 00:07:38,040
you don't have to switch page tables,

122
00:07:38,040 --> 00:07:41,310
and switching page tables just usually takes time itself

123
00:07:41,490 --> 00:07:44,760
and also typically causes CPU caches to be flushed,

124
00:07:44,820 --> 00:07:46,650
which makes subsequent codes slower.

125
00:07:48,160 --> 00:07:49,420
So people got a boost,

126
00:07:49,420 --> 00:07:53,020
by mapping both user and kernel mappings always in user space.

127
00:07:55,370 --> 00:07:58,460
But this attack actually, and this attack relies on that habit.

128
00:08:00,040 --> 00:08:04,390
Okay, I'm going to explain what's going on here,

129
00:08:04,390 --> 00:08:05,440
that makes this code useful,

130
00:08:05,440 --> 00:08:06,910
but before I do that,

131
00:08:06,910 --> 00:08:12,600
any any questions about, any questions about this, this code fragment?

132
00:08:15,280 --> 00:08:17,200
I was actually wondering if you could repeat,

133
00:08:17,470 --> 00:08:20,440
what you just said about kernel to user mapping,

134
00:08:20,980 --> 00:08:22,330
and don't [really] register.

135
00:08:22,630 --> 00:08:24,370
Okay, let's see,

136
00:08:28,560 --> 00:08:30,150
you know how in xv6,

137
00:08:30,180 --> 00:08:33,480
when you're executing when the process is executing in user space,

138
00:08:33,540 --> 00:08:35,280
if you look at the page table,

139
00:08:35,760 --> 00:08:38,580
that page table has mapping for the user addresses,

140
00:08:38,970 --> 00:08:40,680
and for like the trampoline page

141
00:08:40,680 --> 00:08:43,480
and the trapframe page and nothing else,

142
00:08:44,160 --> 00:08:45,630
so that's how xv6 works.

143
00:08:46,110 --> 00:08:51,810
The page table that this paper assumes where different from that,

144
00:08:52,380 --> 00:08:55,020
this, in the time this paper was written,

145
00:08:55,200 --> 00:08:59,860
most operating systems would have

146
00:08:59,860 --> 00:09:05,200
a set complete set of kernel mappings in the page table,

147
00:09:06,100 --> 00:09:08,140
while user code was running,

148
00:09:09,930 --> 00:09:14,580
and so all those page table entries would be there,

149
00:09:14,580 --> 00:09:17,910
all the kernel page table entries would be there when user code is running,

150
00:09:17,910 --> 00:09:22,320
but since the PTE_U bit was clear on each of those page table entries,

151
00:09:22,320 --> 00:09:25,530
user code wouldn't actually be able to use a kernel virtual address,

152
00:09:25,710 --> 00:09:27,150
but the mappings were there,

153
00:09:27,300 --> 00:09:29,760
and the reason for that is that when you do a system call,

154
00:09:29,880 --> 00:09:32,760
you didn't have to switch page tables,

155
00:09:33,060 --> 00:09:35,850
because you do a system call into the kernel

156
00:09:35,850 --> 00:09:37,620
and boom you're using the same page table,

157
00:09:37,620 --> 00:09:41,040
but now you can use all those kernel PTEs,

158
00:09:41,040 --> 00:09:42,150
because you're in supervisor mode,

159
00:09:42,180 --> 00:09:43,860
and that saved a bunch of time

160
00:09:44,070 --> 00:09:46,440
getting into and out of the kernel during system calls.

161
00:09:47,230 --> 00:09:49,360
Everybody, everybody used that technique,

162
00:09:49,390 --> 00:09:52,630
and that was almost certainly what Intel had in mind,

163
00:09:52,630 --> 00:09:54,920
for how you should write an operating system.

164
00:09:55,840 --> 00:09:57,550
Okay, so that for the whole paper,

165
00:09:57,550 --> 00:10:01,300
that structure is assumed for the attack,

166
00:10:01,480 --> 00:10:02,530
of course getting rid of it

167
00:10:02,530 --> 00:10:06,130
is what's the most immediate solution to this problem,

168
00:10:07,150 --> 00:10:08,440
but the time, the paper was written

169
00:10:08,710 --> 00:10:11,620
all those kernel mappings were present in user space.

170
00:10:13,760 --> 00:10:14,630
Other questions?

171
00:10:16,860 --> 00:10:20,850
So you need to know the address and you want to get.

172
00:10:21,090 --> 00:10:25,980
Yeah, that's right, it is and.

173
00:10:28,790 --> 00:10:30,080
So you know that's a good point,

174
00:10:30,080 --> 00:10:32,030
you need to know the kernel virtual address

175
00:10:32,030 --> 00:10:34,820
and that's actually maybe no joke.

176
00:10:37,560 --> 00:10:41,370
Yeah, you might think that would make the attack harder.

177
00:10:44,600 --> 00:10:49,000
But first of all point of philosophy in security,

178
00:10:49,000 --> 00:10:53,020
you just have to assume that the attacker has infinite time and patience.

179
00:10:53,510 --> 00:10:55,220
And if there are some valuable secrets,

180
00:10:55,520 --> 00:10:59,990
they are probably willing to spend a couple of months trying to steal that secret,

181
00:11:00,590 --> 00:11:02,480
or longer, right,

182
00:11:02,870 --> 00:11:04,640
because you know it's gonna be somebody's password,

183
00:11:04,640 --> 00:11:06,320
that protects all kinds of valuable stuff,

184
00:11:06,320 --> 00:11:08,990
maybe money or secret email.

185
00:11:09,640 --> 00:11:12,970
So that means for example the attacker probably has time

186
00:11:12,970 --> 00:11:16,820
to try every single kernel address, right,

187
00:11:16,850 --> 00:11:19,550
looking for whatever precious data there after,

188
00:11:19,640 --> 00:11:20,660
maybe a password,

189
00:11:20,870 --> 00:11:24,950
or the attacker may have time to study to look through the kernel code

190
00:11:24,950 --> 00:11:28,640
and look through typical compiled kernels and find addresses

191
00:11:28,640 --> 00:11:30,920
and maybe put print statements in their kernel

192
00:11:30,920 --> 00:11:33,770
to examine the structure of data in kernel memory,

193
00:11:33,770 --> 00:11:35,870
until they understand how the kernel works,

194
00:11:36,530 --> 00:11:39,950
well enough to be able to get an address here.

195
00:11:40,100 --> 00:11:43,900
Now, actually, because this game has been going on,

196
00:11:43,930 --> 00:11:45,610
other versions of this game,

197
00:11:46,000 --> 00:11:48,070
the security game had been going out for a long time,

198
00:11:48,130 --> 00:11:53,010
kernels actually defend themselves against attacks

199
00:11:53,010 --> 00:11:55,800
that involve guessing kernel addresses,

200
00:11:55,920 --> 00:11:59,490
and one of the things that was actually mentioned this paper is

201
00:11:59,490 --> 00:12:06,360
this called thing called kernel address space layout randomization,

202
00:12:06,360 --> 00:12:09,720
so modern kernels actually load the kernel at a random address,

203
00:12:10,140 --> 00:12:15,970
in order to make it harder to guess kernel virtual addresses,

204
00:12:15,970 --> 00:12:19,150
and they did this before this, long before this paper came out,

205
00:12:19,420 --> 00:12:22,180
because it was helpful in defeating other attacks.

206
00:12:22,700 --> 00:12:24,890
So, so this is the game,

207
00:12:24,890 --> 00:12:29,810
but we have to assume that the attacker,

208
00:12:29,840 --> 00:12:33,260
in the end, the attacker will probably win this game.

209
00:12:34,640 --> 00:12:40,340
Okay, so let's just assume the attacker either knows a [] kernel virtual address to look at

210
00:12:40,340 --> 00:12:43,850
or can guess one or is willing to exhaustively try every address.

211
00:12:44,280 --> 00:12:47,970
And the paper suggests that that's a plausible strategy,

212
00:12:48,240 --> 00:12:49,290
once you have meltdown.

213
00:12:51,810 --> 00:12:52,470
Okay.

214
00:12:53,930 --> 00:12:55,340
Okay, so what's gonna happen,

215
00:12:55,460 --> 00:12:58,540
well, so we're wondering how can this code be,

216
00:12:58,720 --> 00:13:01,300
possibly be useful to an attacker,

217
00:13:01,360 --> 00:13:03,340
and the answer has to do,

218
00:13:03,430 --> 00:13:08,740
like if the way CPU's work was just what you read in the CPU manual,

219
00:13:08,830 --> 00:13:10,780
this attack clearly is nonsense,

220
00:13:10,810 --> 00:13:13,390
like it'll fault at instruction 3

221
00:13:13,420 --> 00:13:14,440
and that'll be the end of it,

222
00:13:14,590 --> 00:13:20,340
but it turns out CPU's work in far more complex ways than is in the manual,

223
00:13:20,490 --> 00:13:24,960
and the way the reason the attack works is

224
00:13:24,960 --> 00:13:28,800
because of some CPU implementation details.

225
00:13:30,350 --> 00:13:33,410
And there's actually two main things that the attack relies on,

226
00:13:33,410 --> 00:13:37,910
one is implementation trick of CPU's called speculative execution,

227
00:13:38,180 --> 00:13:39,440
which I'll talk about first,

228
00:13:39,620 --> 00:13:45,620
and the other implementation trick the attack relies on is the way CPU's do caching.

229
00:13:48,330 --> 00:13:49,050
Okay.

230
00:13:49,620 --> 00:13:51,300
So first speculative execution,

231
00:13:52,920 --> 00:13:56,700
let me, I have a code example for that also,

232
00:13:57,120 --> 00:14:00,390
and for the moment I'm not talking about security at all,

233
00:14:01,220 --> 00:14:07,520
the speculative execution this stuff is just a technique to improve the performance of CPUs,

234
00:14:08,300 --> 00:14:10,670
some optimization trick that CPUs use,

235
00:14:11,210 --> 00:14:17,050
so imagine that we're just, we have, which is running this code,

236
00:14:17,320 --> 00:14:19,360
this is somewhat contrived example,

237
00:14:19,360 --> 00:14:23,920
but it's sort of illustrates what speculative execution is all about,

238
00:14:25,120 --> 00:14:29,200
supposing I have address in some say register zero,

239
00:14:29,320 --> 00:14:31,510
and just because the logic my program,

240
00:14:31,510 --> 00:14:33,640
the address is either valid or not valid,

241
00:14:33,640 --> 00:14:36,430
maybe it contains zero if under some circumstances,

242
00:14:36,430 --> 00:14:39,920
like we haven't initialize my data yet.

243
00:14:39,950 --> 00:14:44,180
So this will assume there's a valid variable that's sitting in memory somewhere,

244
00:14:44,660 --> 00:14:47,630
so before using the address here,

245
00:14:48,230 --> 00:14:50,780
so this address in register zero here on line 4,

246
00:14:50,780 --> 00:14:51,590
we're going to test,

247
00:14:51,620 --> 00:14:53,090
we're gonna load valid from memory,

248
00:14:53,090 --> 00:14:57,080
and we're only going to use the address if valid is set to 1,

249
00:14:57,500 --> 00:15:00,410
then if valid is set to 0, we are not going to see address at all,

250
00:15:00,620 --> 00:15:03,830
and if valid is set to one, then we're going to dereference the address,

251
00:15:03,890 --> 00:15:06,380
you know load the data it points to at register 2,

252
00:15:06,530 --> 00:15:08,570
and add one to it and it doesn't really matter,

253
00:15:08,600 --> 00:15:10,460
we're going to do something with that data we loaded,

254
00:15:10,610 --> 00:15:12,020
in this case, add one to it

255
00:15:12,020 --> 00:15:16,800
and set register 3 equal to the data plus one.

256
00:15:17,800 --> 00:15:23,010
Alright, well, in a simple CPU implementation,

257
00:15:24,370 --> 00:15:27,780
at line 2 here, you can load,

258
00:15:28,380 --> 00:15:30,990
the valid is a variable sitting in memory in RAM,

259
00:15:32,070 --> 00:15:34,140
and you have to issue some kind of,

260
00:15:34,140 --> 00:15:34,740
this is going to be,

261
00:15:34,740 --> 00:15:38,550
line 2 is going to be some sort of load instruction that reads valid out of RAM,

262
00:15:39,330 --> 00:15:41,790
or else being equal if we actually have to load it from RAM,

263
00:15:42,500 --> 00:15:47,660
that'll take hundreds of cycles on our say two GHz machine,

264
00:15:48,370 --> 00:15:52,240
like any load that actually has to go to RAM will take hundreds of cycles,

265
00:15:52,300 --> 00:15:54,850
the machine can execute an instruction,

266
00:15:55,420 --> 00:15:57,250
up to an instruction every cycle,

267
00:15:57,250 --> 00:16:01,240
so if we actually had to wait a couple of hundred cycles here,

268
00:16:01,480 --> 00:16:05,800
we'd be the machine to be sitting there idling for hundreds hundreds of cycles,

269
00:16:05,800 --> 00:16:06,820
sort of wasting its time.

270
00:16:07,440 --> 00:16:11,880
And because that's a significant significant slowdown, right,

271
00:16:12,060 --> 00:16:13,080
if everything went well,

272
00:16:13,080 --> 00:16:15,750
we'd be able to execute an instruction every cycle,

273
00:16:15,750 --> 00:16:17,430
instead of every couple hundred cycles.

274
00:16:20,000 --> 00:16:24,530
All modern, all serious modern CPUs do use something called branch prediction,

275
00:16:24,620 --> 00:16:26,780
so this if statement is a branch,

276
00:16:27,530 --> 00:16:29,690
if we actually turned it into machine instructions,

277
00:16:29,690 --> 00:16:31,100
we see there was a branch here,

278
00:16:31,280 --> 00:16:32,690
and it's a conditional branch,

279
00:16:32,690 --> 00:16:36,920
branch based on this test whether register 1 is equal to 1,

280
00:16:37,220 --> 00:16:38,720
and what CPUs do is,

281
00:16:38,720 --> 00:16:41,240
they use what's called branch branch prediction,

282
00:16:41,660 --> 00:16:43,280
that is for every branch,

283
00:16:43,310 --> 00:16:48,500
more or less the CPU essentially remembers a cache of information

284
00:16:48,500 --> 00:16:51,290
about each of the branches in your program,

285
00:16:51,350 --> 00:16:53,600
or at least each recently executed branch,

286
00:16:53,810 --> 00:16:57,380
then remembers oh did that branch was the branch taken or not taken,

287
00:16:58,010 --> 00:17:03,660
and if the CPU doesn't have enough information to predict,

288
00:17:03,720 --> 00:17:06,390
so that's prediction based on the last time you executed the branch,

289
00:17:06,600 --> 00:17:09,270
even if the CPU doesn't have a prediction,

290
00:17:09,390 --> 00:17:13,640
it may still just go ahead and execute the instructions,

291
00:17:14,630 --> 00:17:16,280
either that the branch takes you to

292
00:17:16,280 --> 00:17:19,520
or the fail to instructions, assuming the branch wasn't taken,

293
00:17:19,580 --> 00:17:25,530
that is, even before the CPU knows whether this conditional is true,

294
00:17:25,890 --> 00:17:30,300
it'll choose one way or the other and start executing down that path,

295
00:17:30,480 --> 00:17:33,680
even though it might be the wrong path, doesn't know yet.

296
00:17:34,320 --> 00:17:35,400
And so in this case,

297
00:17:35,580 --> 00:17:37,380
maybe before this load completes,

298
00:17:37,380 --> 00:17:39,780
and before the value of valid is known,

299
00:17:40,020 --> 00:17:43,800
the CPU may start executing instruction 4

300
00:17:44,250 --> 00:17:47,790
and do the load with whatever value is sitting in r0,

301
00:17:47,880 --> 00:17:49,680
which may or may not be a valid pointer

302
00:17:50,100 --> 00:17:52,500
and once that load yields something,

303
00:17:52,650 --> 00:17:54,180
maybe even add one to it

304
00:17:54,180 --> 00:17:56,220
and set register 3 equal to that value.

305
00:17:56,840 --> 00:17:59,030
And then maybe a long time later,

306
00:17:59,030 --> 00:18:02,360
when this load at line 2 finally completes,

307
00:18:02,750 --> 00:18:06,320
now we know what the value of valid is,

308
00:18:06,590 --> 00:18:08,990
the CPU will then, this real,

309
00:18:09,020 --> 00:18:11,180
you know you know it kept track of the fact,

310
00:18:11,180 --> 00:18:13,940
that it executed lines 4 and 5

311
00:18:13,940 --> 00:18:16,310
without really knowing whether that was proper,

312
00:18:17,060 --> 00:18:20,270
if valid is 1, then that's fine, it just keeps going,

313
00:18:20,300 --> 00:18:23,810
if valid is 0, then the CPU has enough cleverness

314
00:18:23,810 --> 00:18:28,700
to cancel the effects of its execution of line 4 and 5,

315
00:18:28,760 --> 00:18:33,140
and restart execution in the proper place after the branch at line 7.

316
00:18:34,260 --> 00:18:36,690
And this execution of code before you know

317
00:18:36,690 --> 00:18:40,440
whether you really should be executing it is called speculation,

318
00:18:46,700 --> 00:18:48,920
and again, the point is performance,

319
00:18:48,920 --> 00:18:50,510
if the CPU guess is right,

320
00:18:51,180 --> 00:18:54,540
then it got a big head start executing these instructions,

321
00:18:54,540 --> 00:18:57,960
and didn't have to wait for the expensive memory load.

322
00:19:00,660 --> 00:19:02,220
Any questions about what this means?

323
00:19:08,940 --> 00:19:19,250
Okay, this machinery, the hardware, the transistors in the CPU for speculation are extremely complex,

324
00:19:19,610 --> 00:19:22,970
there's a huge amount going on in the CPU to make this work,

325
00:19:23,440 --> 00:19:25,900
none of which is published, right,

326
00:19:25,900 --> 00:19:29,510
it's a whole Intel internal stuff,

327
00:19:29,570 --> 00:19:31,970
not in, not in the machine manual.

328
00:19:32,550 --> 00:19:36,720
So surrounding meltdown and attacks

329
00:19:36,720 --> 00:19:38,520
like it is a huge amount of speculation

330
00:19:38,520 --> 00:19:41,400
about what's probably going on inside the CPU

331
00:19:41,400 --> 00:19:44,220
in order to make such attack work or not work.

332
00:19:45,090 --> 00:19:48,460
Okay, back to speculation though.

333
00:19:55,210 --> 00:19:57,160
One thing that's going on is that,

334
00:19:57,400 --> 00:20:05,460
in order to undo speculative failed speculative mispredicted speculative execution,

335
00:20:05,670 --> 00:20:09,900
the machine had keeps shadow versions of registers essentially,

336
00:20:10,200 --> 00:20:12,690
you know it assigned to registers 2, register 3,

337
00:20:12,690 --> 00:20:15,900
but it's assigning kind of a temporary registers,

338
00:20:16,560 --> 00:20:19,350
if speculation succeeds,

339
00:20:19,530 --> 00:20:23,010
then those registers those shadow registers become the real registers,

340
00:20:23,040 --> 00:20:24,060
if it fails,

341
00:20:24,120 --> 00:20:28,380
then those shadow registers discarded the CPU discards the shadow registers.

342
00:20:28,710 --> 00:20:32,660
So these two assignments r2 and r3 would just be as if they never happened.

343
00:20:37,310 --> 00:20:39,860
So in this code,

344
00:20:39,860 --> 00:20:45,920
we need to think about what happens if register 0 is a valid pointer

345
00:20:45,920 --> 00:20:49,270
and what happens if it's not a valid pointer, right.

346
00:20:49,300 --> 00:20:52,690
If we're speculatively executing line 4,

347
00:20:53,140 --> 00:20:56,560
and register 2 is a valid pointer,

348
00:20:56,560 --> 00:21:00,010
then it turns out the CPU will actually do the load,

349
00:21:00,700 --> 00:21:04,900
and loaded into at least the transient version of register 2,

350
00:21:04,900 --> 00:21:05,980
so we'll actually go out

351
00:21:05,980 --> 00:21:10,650
and and try to fetch what r0 points to

352
00:21:10,650 --> 00:21:12,660
and that will certainly work

353
00:21:12,660 --> 00:21:17,040
if the data r0 is pointed to is sitting in the cache,

354
00:21:17,130 --> 00:21:22,050
and I don't know if if the CPU will do the load,

355
00:21:22,080 --> 00:21:23,370
if it misses in the cache

356
00:21:23,370 --> 00:21:25,230
and has to load from RAM, it might.

357
00:21:27,880 --> 00:21:29,680
But, maybe the more interesting question for us,

358
00:21:29,680 --> 00:21:32,920
for this attack is what happens if register 0 is not a valid pointer,

359
00:21:36,140 --> 00:21:40,010
in that case, if we're speculatively executing here,

360
00:21:40,980 --> 00:21:45,210
the machine can't fault at this point,

361
00:21:45,210 --> 00:21:46,710
because we're speculatively executing,

362
00:21:46,710 --> 00:21:50,430
machine doesn't know, it may know that r0 was an invalid,

363
00:21:50,880 --> 00:21:56,490
that this speculatively executed instruction tried to use an invalid pointer, an invalid address,

364
00:21:56,490 --> 00:21:58,020
but it can't page fault,

365
00:21:58,110 --> 00:22:01,050
because it's not sure whether this execution

366
00:22:01,080 --> 00:22:07,230
is valid is correct speculative execution or misspeculation,

367
00:22:07,230 --> 00:22:08,820
and so it's only,

368
00:22:09,120 --> 00:22:13,720
so, so it can't actually raise a fault on line 4

369
00:22:13,720 --> 00:22:17,680
until after valid value of valid is known,

370
00:22:17,680 --> 00:22:23,770
and after this branch, this speculative predicted branch,

371
00:22:23,800 --> 00:22:28,120
after we know after the machine knows what the condition is,

372
00:22:28,510 --> 00:22:34,900
if the machine see if the machine's that line 4 sees oh register 0 is an valid address,

373
00:22:35,580 --> 00:22:38,100
and then valid turns out to be 1,

374
00:22:38,370 --> 00:22:42,300
then, and only then does the machine actually generate the page fault,

375
00:22:42,570 --> 00:22:46,740
if r0 is an invalid address, then valid turns out to be 0,

376
00:22:46,770 --> 00:22:50,030
the machine does not generate a page fault.

377
00:22:50,960 --> 00:22:53,480
So the, the decision about whether to fault

378
00:22:53,540 --> 00:22:57,020
is deferred possibly for hundreds of cycles

379
00:22:57,110 --> 00:22:59,150
until the value of valid is known,

380
00:22:59,420 --> 00:23:02,390
then the technical term for the point at which

381
00:23:02,390 --> 00:23:08,570
we know whether an instruction was correctly speculatively executed

382
00:23:08,870 --> 00:23:13,040
rather than being thrown away is called retirement.

383
00:23:15,600 --> 00:23:19,430
So we say an instruction is speculative

384
00:23:19,430 --> 00:23:21,020
and at some point it's retired,

385
00:23:21,020 --> 00:23:24,490
and that's when we know it's either going to be thrown away

386
00:23:24,490 --> 00:23:29,530
or what's real and should be its effect should be committed to the visible state of the machine

387
00:23:29,800 --> 00:23:31,090
and the rule is that,

388
00:23:33,220 --> 00:23:35,560
instruction can only be retired,

389
00:23:35,710 --> 00:23:40,990
if first of all is finished executing loading memory, you're adding one to something,

390
00:23:40,990 --> 00:23:43,570
and every instruction before it,

391
00:23:43,570 --> 00:23:45,670
was executed before it has also retired,

392
00:23:46,090 --> 00:23:48,730
so this line 4 can't be retired

393
00:23:48,730 --> 00:23:54,890
until the load of valid completes and the conditions is evaluated,

394
00:23:54,890 --> 00:23:56,000
only then can be retired,

395
00:23:56,270 --> 00:23:58,130
so it's going to fault, it may it's gonna fault,

396
00:23:58,280 --> 00:24:03,260
possibly hundreds of instructions after it is the memory load,

397
00:24:05,370 --> 00:24:06,990
or attempted to do the memory load.

398
00:24:11,630 --> 00:24:14,240
And as a critical detail for this attack,

399
00:24:16,690 --> 00:24:19,060
there's an even more.

400
00:24:19,870 --> 00:24:22,030
If lets its,

401
00:24:23,210 --> 00:24:25,220
if the address in r0 is invalid

402
00:24:25,220 --> 00:24:27,350
and has no mapping in the page table at all,

403
00:24:27,530 --> 00:24:30,230
then actually don't know what happens.

404
00:24:32,850 --> 00:24:37,380
If the address in r0 has a page table mapping,

405
00:24:37,410 --> 00:24:39,210
but there's no permission for it,

406
00:24:39,240 --> 00:24:41,940
that is the PTE_U flag is not set,

407
00:24:42,120 --> 00:24:45,360
then what Intel machines actually do is,

408
00:24:45,390 --> 00:24:50,640
load that data and assign it into the transient register 2,

409
00:24:51,840 --> 00:24:57,180
and where it can be used by the speculative execution of line 5,

410
00:24:57,330 --> 00:25:01,320
so even if r0 was was an address for which we don't have permission,

411
00:25:01,320 --> 00:25:02,610
because it's a kernel address,

412
00:25:02,820 --> 00:25:06,930
we'll still see it's value loaded into r3 and its value plus 1,

413
00:25:06,990 --> 00:25:10,320
sorry, we won't see it, but it will be loaded into r2

414
00:25:10,680 --> 00:25:12,630
and that plus one at r3

415
00:25:12,780 --> 00:25:16,050
and then when this load is retired,

416
00:25:16,290 --> 00:25:20,340
the machine will realize aha, that was an invalid load,

417
00:25:20,370 --> 00:25:22,620
because the page table entry didn't allow it,

418
00:25:23,040 --> 00:25:24,690
and so we're going to raise a fault,

419
00:25:24,690 --> 00:25:28,650
and cancel the execution of the subsequent instructions,

420
00:25:28,650 --> 00:25:31,830
and cancel the effects of this instruction,

421
00:25:31,890 --> 00:25:35,170
undo the modification to r2 and r3.

422
00:25:35,380 --> 00:25:41,460
So in this example, there's two speculations going on,

423
00:25:41,490 --> 00:25:44,640
one is we're speculating about where this branch,

424
00:25:44,640 --> 00:25:46,950
machines speculating about where this branch went

425
00:25:47,400 --> 00:25:49,560
and just saying oh it went one way or the other,

426
00:25:49,560 --> 00:25:51,390
just gonna give that a shot speculatively,

427
00:25:51,990 --> 00:25:55,380
in addition there's speculative execution after each load,

428
00:25:55,380 --> 00:25:57,000
we're essentially speculating about

429
00:25:57,000 --> 00:26:03,560
whether the machine is speculating about whether that load complete successfully.

430
00:26:03,920 --> 00:26:07,910
And in the case of a load, Intel machines always just go on,

431
00:26:08,150 --> 00:26:10,010
you know if data could be provided,

432
00:26:11,110 --> 00:26:12,130
because it's in the cache,

433
00:26:12,130 --> 00:26:14,920
and at least the page table entry exists, permissions are not,

434
00:26:15,220 --> 00:26:18,160
the machine will speculatively continue to execute

435
00:26:18,520 --> 00:26:20,650
and only on retirement,

436
00:26:20,650 --> 00:26:23,950
the load will actually generate the fault,

437
00:26:24,040 --> 00:26:26,140
and that will cause the speculation to be cancelled.

438
00:26:28,660 --> 00:26:32,290
Alright, any questions about this stuff?

439
00:26:39,870 --> 00:26:43,230
I'm a little confused about, the second speculation

440
00:26:43,230 --> 00:26:45,630
which is loading r0 into r2,

441
00:26:46,290 --> 00:26:52,140
so, does that mean that like the value of r0 is loaded into r2

442
00:26:52,140 --> 00:26:53,610
and the flags are checked later?

443
00:26:56,900 --> 00:27:01,180
Yes, yes, so what happens, yes, that's exactly, right,

444
00:27:01,270 --> 00:27:03,100
so what actually happens is that

445
00:27:03,100 --> 00:27:04,630
during the speculative phase,

446
00:27:07,190 --> 00:27:08,930
whatever it is that r0 points to,

447
00:27:09,080 --> 00:27:12,590
if there's sort of if it points to anything,

448
00:27:12,620 --> 00:27:14,060
if r0 points to anything,

449
00:27:14,120 --> 00:27:18,770
then the data that memory location will be loaded into r2,

450
00:27:19,740 --> 00:27:22,590
later, when this load is retired,

451
00:27:24,280 --> 00:27:27,280
and it turned, then the permissions will be checked,

452
00:27:28,560 --> 00:27:30,930
and if we didn't have permission to do that load,

453
00:27:31,610 --> 00:27:35,510
then all subsequent instructions effects will be cancelled,

454
00:27:35,510 --> 00:27:38,270
like all these modifications registere will be undone,

455
00:27:39,180 --> 00:27:41,880
and fault will be raised,

456
00:27:42,180 --> 00:27:47,130
with the state of the machines and registers as they were just before instruction 4.

457
00:27:47,250 --> 00:27:49,080
Okay, that's interesting.

458
00:27:49,780 --> 00:27:50,350
Yes.

459
00:27:52,700 --> 00:27:54,110
Yes, I also have a question,

460
00:27:54,350 --> 00:27:58,610
is there no possible way to restrict the CPU

461
00:27:58,640 --> 00:28:02,330
from checking permissions before doing a speculative load.

462
00:28:06,380 --> 00:28:12,140
You mean, is there a way to cause the machine to do the check before the load?

463
00:28:13,370 --> 00:28:14,900
Yes, I guess more concrete,

464
00:28:14,900 --> 00:28:17,360
like the only reason this is a problem or,

465
00:28:17,360 --> 00:28:22,340
but one of the ways is that we're just loading a page that,

466
00:28:23,170 --> 00:28:29,020
if we can be aware that it has permissions that are going to be bad somehow,

467
00:28:29,110 --> 00:28:32,980
we're accessing a page that we don't we shouldn't be able to access,

468
00:28:33,310 --> 00:28:36,820
the can the speculative execution be cancelled,

469
00:28:36,820 --> 00:28:38,710
given that we can read these permissions.

470
00:28:40,500 --> 00:28:42,810
Yes, in a, yes that's,

471
00:28:42,810 --> 00:28:46,110
yeah, well, there's two answers,

472
00:28:46,110 --> 00:28:49,680
one is that's not the way the Intel chips CPUs actually worked,

473
00:28:50,700 --> 00:28:53,400
and the other answer is yes, it would have been,

474
00:28:54,300 --> 00:28:56,610
I I believe it would have been easy for them

475
00:28:56,610 --> 00:29:00,690
to have done and enforce that check even for speculative loads,

476
00:29:00,690 --> 00:29:04,530
so that even in speculation register 2 would never have been written.

477
00:29:05,980 --> 00:29:07,540
So maybe.

478
00:29:08,920 --> 00:29:11,080
And indeed, it turns out that,

479
00:29:11,080 --> 00:29:12,940
you may know, I've noticed the paper mentioned that,

480
00:29:12,940 --> 00:29:17,290
the meltdown seems not to work on AMD CPUs,

481
00:29:17,440 --> 00:29:24,030
even though AMD CPUs, the instruction manual is the same as for Intel CPUs,

482
00:29:24,030 --> 00:29:27,780
essentially on the same instruction set and the instructions mean the same things,

483
00:29:27,840 --> 00:29:30,810
the attack doesn't work on AMD CPUs

484
00:29:31,140 --> 00:29:35,190
and it's widely believed that the reason is that AMD CPUs,

485
00:29:36,080 --> 00:29:38,240
even when speculatively executing,

486
00:29:39,520 --> 00:29:43,900
if you don't have permission to read this address,

487
00:29:43,930 --> 00:29:48,160
won't even speculatively loads the value to r2,

488
00:29:49,470 --> 00:29:52,200
and that's why the attack didn't work on AMD CPUs

489
00:29:52,410 --> 00:29:57,840
and recent Intel CPUs apparently have adopted that approach,

490
00:29:57,840 --> 00:30:05,330
and actually won't won't speculatively load, if they don't have permissions.

491
00:30:06,500 --> 00:30:07,220
And as far as I know,

492
00:30:07,220 --> 00:30:11,290
there's no particular sacrifice at performance,

493
00:30:11,320 --> 00:30:12,910
I think the information was all there,

494
00:30:13,540 --> 00:30:18,550
but for just I don't know, just say maybe a few [],

495
00:30:18,550 --> 00:30:21,040
they decided only to apply it on retirement.

496
00:30:23,620 --> 00:30:24,400
Because they seem to.

497
00:30:24,400 --> 00:30:25,510
That's very interesting.

498
00:30:28,400 --> 00:30:31,940
Yeah, I mean, let me just warn you this there's a lot of guesswork here,

499
00:30:33,050 --> 00:30:35,360
and I believe what I'm saying is true,

500
00:30:35,360 --> 00:30:40,940
but in Intel and AMD have not been very revealing about what's going on.

501
00:30:43,190 --> 00:30:49,130
Okay, thers's some terminology here that's important,

502
00:30:49,250 --> 00:30:53,090
the when you read in the manual for the CPU,

503
00:30:53,090 --> 00:30:55,430
that says oh you know an add instruction takes two registers

504
00:30:55,430 --> 00:30:56,900
and adds them and puts them in a third,

505
00:30:56,930 --> 00:31:01,680
that stuff, that aspect of the design is called architectural,

506
00:31:03,130 --> 00:31:08,830
sort of [] behavior,

507
00:31:10,350 --> 00:31:12,300
the [] behavior of the machine,

508
00:31:12,690 --> 00:31:14,940
and so the [] behavior of machine is that,

509
00:31:14,940 --> 00:31:17,670
if your load from an address you know permissions for you get a page fault [],

510
00:31:17,670 --> 00:31:18,750
you're not allowed to load,

511
00:31:19,710 --> 00:31:23,340
that's in distinction to what the machines actually doing,

512
00:31:23,340 --> 00:31:27,270
which is called Micro-Architectural.

513
00:31:29,540 --> 00:31:32,330
That is actually the machine has speculating executions

514
00:31:32,330 --> 00:31:34,670
doing all these crazy things without telling you,

515
00:31:34,820 --> 00:31:38,420
and the intent of the CPU designers,

516
00:31:38,420 --> 00:31:42,140
when they design all these complex micro-architectural optimizations

517
00:31:42,140 --> 00:31:43,490
is that they be transparent,

518
00:31:43,760 --> 00:31:45,710
that yeah, it's doing all this stuff internally,

519
00:31:45,710 --> 00:31:48,950
but it looks the results you get from programs

520
00:31:48,980 --> 00:31:51,710
are the same results you get from a simpler machine,

521
00:31:51,710 --> 00:31:54,710
that just did the straightforward thing that was in the manual.

522
00:31:55,500 --> 00:31:57,210
They are intended to be transparent

523
00:31:57,240 --> 00:32:00,730
and so you know, for example, at some level,

524
00:32:00,730 --> 00:32:03,370
what Intel is doing here is transparent,

525
00:32:03,370 --> 00:32:06,970
yeah, maybe they don't check for permissions when you when you do the memory load,

526
00:32:07,180 --> 00:32:09,940
but if there was a problem on retirement,

527
00:32:09,940 --> 00:32:11,560
it's gonna undo all these effects

528
00:32:11,560 --> 00:32:13,360
and so you'll never see that memory,

529
00:32:13,360 --> 00:32:14,410
you weren't supposed to see,

530
00:32:14,410 --> 00:32:17,890
so gosh that looks just like what the manual said,

531
00:32:17,980 --> 00:32:20,110
you're not allowed to load stuff you don't have permission for.

532
00:32:22,040 --> 00:32:23,690
So this distinction is,

533
00:32:26,050 --> 00:32:27,730
a lot of what this attack is playing,

534
00:32:27,730 --> 00:32:30,190
on that it knows all the attack,

535
00:32:30,190 --> 00:32:32,380
knows a lot about what's going on inside.

536
00:32:35,840 --> 00:32:40,240
Okay, other questions about speculative execution?

537
00:32:47,840 --> 00:32:50,590
Okay, I'm gonna put that aside for a moment

538
00:32:50,590 --> 00:32:53,440
and talk about another piece of micro-architecture,

539
00:32:59,240 --> 00:33:03,410
that's caches.

540
00:33:06,420 --> 00:33:08,730
And these again, everybody knows caches are there,

541
00:33:08,730 --> 00:33:12,090
but you know they're supposed to be more or less more or less transparent.

542
00:33:16,130 --> 00:33:17,720
And let me draw a picture of the caches,

543
00:33:17,720 --> 00:33:19,490
I think are relevant to the cache structure,

544
00:33:19,490 --> 00:33:21,590
I think is most relevant to meltdown.

545
00:33:21,650 --> 00:33:23,360
So first of all, you have the,

546
00:33:24,500 --> 00:33:28,800
we have the core which is the you know part of the machine,

547
00:33:28,800 --> 00:33:31,650
that parses instructions and has registers

548
00:33:31,650 --> 00:33:34,470
and has an addition unit and division unit,

549
00:33:34,470 --> 00:33:39,300
and you know whatever the execution part of the machine,

550
00:33:39,300 --> 00:33:44,130
and then, whenever it needs to do a load or store,

551
00:33:45,710 --> 00:33:50,270
it talks to the memory system,

552
00:33:51,380 --> 00:33:53,360
and the memory system has a bunch of caches,

553
00:33:53,360 --> 00:33:55,700
so in particular in the machines, we're talking about,

554
00:33:55,700 --> 00:34:03,140
there's a data cache called L1 data cache,

555
00:34:03,620 --> 00:34:10,590
that is maybe you know 64 kilobytes in size or something not very big,

556
00:34:10,590 --> 00:34:11,940
but it's extremely fast,

557
00:34:12,150 --> 00:34:15,630
if you, if the data you need is in the L1 cache,

558
00:34:15,630 --> 00:34:18,360
that you get back to you in a couple of cycles,

559
00:34:18,390 --> 00:34:19,890
and the structure of the L1 cache,

560
00:34:19,890 --> 00:34:22,200
it has a bunch of lines are called lines,

561
00:34:22,920 --> 00:34:25,770
each of which holds probably 64 bytes of data,

562
00:34:25,860 --> 00:34:29,520
the lines are indexed the table really the cache,

563
00:34:29,670 --> 00:34:32,910
the lines are indexed by virtual address,

564
00:34:33,600 --> 00:34:36,150
if the virtual addresses in the cache,

565
00:34:36,150 --> 00:34:41,220
then, the cache holds the data with that virtual address

566
00:34:41,370 --> 00:34:46,410
and in addition as it turns out, it's believed,

567
00:34:47,520 --> 00:34:50,910
the L1 cache entry contains a copy of the permissions

568
00:34:50,910 --> 00:34:54,870
taken from the page table entry that corresponds to this virtual address.

569
00:34:55,460 --> 00:35:00,210
So, there's a whole, this is it a table,

570
00:35:01,270 --> 00:35:03,100
when the core is used load instruction,

571
00:35:03,460 --> 00:35:05,290
the first thing that happens is that,

572
00:35:05,290 --> 00:35:07,330
the hardware looks in the L1 cache

573
00:35:07,330 --> 00:35:09,670
and see if there's a cache entry

574
00:35:09,670 --> 00:35:14,350
whose virtual address matches the requested,

575
00:35:15,610 --> 00:35:16,870
the address we're trying to load from it,

576
00:35:16,870 --> 00:35:20,680
and if so, that we can just the machine just returns this data from the cache,

577
00:35:20,980 --> 00:35:22,030
were done very quickly,

578
00:35:22,300 --> 00:35:24,190
if they did is not in L1 cache,

579
00:35:24,190 --> 00:35:27,140
then the next step is that we,

580
00:35:27,170 --> 00:35:31,910
the rest of the memory system is is in is addressed with physical addresses,

581
00:35:31,910 --> 00:35:33,980
so we at this point, we're going to need a physical address,

582
00:35:33,980 --> 00:35:36,020
if we missed the L1 cache,

583
00:35:36,350 --> 00:35:41,090
this translation look-aside buffer is a cache of page table entries,

584
00:35:41,240 --> 00:35:43,100
it's going to look up the virtual address,

585
00:35:43,100 --> 00:35:46,750
that the program issued in the translation look aside buffer,

586
00:35:47,470 --> 00:35:48,160
it may not be there,

587
00:35:48,160 --> 00:35:49,810
in which case, now we got a lot of work to do,

588
00:35:49,810 --> 00:35:53,740
because we've got to load the relevant page table entry for memory.

589
00:35:54,290 --> 00:35:56,780
But let's assume we hittin the translation look-aside buffer,

590
00:35:56,900 --> 00:36:00,710
we can now get the needed physical address,

591
00:36:00,890 --> 00:36:04,130
typically there's another cache, another much bigger cache,

592
00:36:04,830 --> 00:36:09,000
that's physically indexed index with the physical address.

593
00:36:10,880 --> 00:36:12,740
And so we might, now that we have a physical address,

594
00:36:12,740 --> 00:36:14,000
we can look at this cache,

595
00:36:14,690 --> 00:36:16,610
and if we miss there,

596
00:36:16,610 --> 00:36:19,910
then we have to send the physical address after the RAM system,

597
00:36:20,150 --> 00:36:20,900
takes a long time,

598
00:36:20,900 --> 00:36:22,100
but when we finally get data back,

599
00:36:22,100 --> 00:36:24,020
then we can populate the L2 cache,

600
00:36:24,650 --> 00:36:28,220
and populate the L1 cache with the stuff we got back from RAM

601
00:36:28,400 --> 00:36:31,870
and return the the data back to the core.

602
00:36:36,730 --> 00:36:37,690
So this is caching.

603
00:36:43,060 --> 00:36:49,140
Just, by the, by the hit L1 cache practice a few cycles,

604
00:36:49,140 --> 00:36:52,470
hit the L2 cache probably takes a dozen or two cycles,

605
00:36:52,620 --> 00:36:56,070
and miss that, requires you to go around probably takes you a couple hundred cycles,

606
00:36:56,800 --> 00:36:59,400
these cycles are, you know,

607
00:36:59,910 --> 00:37:03,540
let's say half a nanosecond on a 2 GHz machine.

608
00:37:05,130 --> 00:37:08,100
So it's extremely advantageous to have caching you would,

609
00:37:08,100 --> 00:37:09,000
if you didn't have cache

610
00:37:09,000 --> 00:37:12,630
and you would be sacrificing a factor of a couple of hundred in performance,

611
00:37:12,750 --> 00:37:16,950
these are just absolutely critical to decent performance, these caches.

612
00:37:20,000 --> 00:37:26,590
Now, this caches is the L1 cache,

613
00:37:27,140 --> 00:37:30,740
well, both turns out both both these caches can contain,

614
00:37:31,010 --> 00:37:32,360
if we're running in user space,

615
00:37:32,360 --> 00:37:36,110
both these caches in the operating system's meltdown was aimed at,

616
00:37:36,320 --> 00:37:39,920
both of these caches can contain both user data and kernel data,

617
00:37:40,700 --> 00:37:42,680
the L2 cache can contain kernel data,

618
00:37:42,680 --> 00:37:49,420
because it's physically addressed, there's no problem.

619
00:37:49,540 --> 00:37:52,360
The L1 cache is a little bit trickier,

620
00:37:52,360 --> 00:37:53,200
it's virtual addresses,

621
00:37:53,200 --> 00:37:55,180
when we change page tables,

622
00:37:55,390 --> 00:37:57,670
the contents of the L1 cache are no longer valid,

623
00:37:57,670 --> 00:37:59,350
because we change page tables,

624
00:37:59,350 --> 00:38:01,990
that means that the meaning of virtual addresses changed,

625
00:38:01,990 --> 00:38:04,750
so you'd have to flush the L1 cache, when change page tables,

626
00:38:04,960 --> 00:38:10,520
although there's more complex tricks that allow you to avoid that,

627
00:38:10,850 --> 00:38:15,140
and so but the fact that these operating systems in the days of this paper,

628
00:38:15,260 --> 00:38:19,070
didn't change page tables, when changing between user space and kernel space,

629
00:38:19,070 --> 00:38:20,000
because both were mapped,

630
00:38:20,150 --> 00:38:24,470
meant that, data we didn't have to flush the L1 cache,

631
00:38:24,710 --> 00:38:28,010
and that mean the L1 cache would have both user and kernel data in it,

632
00:38:28,010 --> 00:38:29,750
and that it made system calls even faster,

633
00:38:30,200 --> 00:38:31,670
if you call a system call,

634
00:38:31,670 --> 00:38:32,570
the system call returns,

635
00:38:32,570 --> 00:38:37,750
there's still gonna be likely still to be useful user data in the caches,

636
00:38:37,750 --> 00:38:40,040
because we never changed,

637
00:38:40,040 --> 00:38:42,980
we never changed page tables or changed the meanings of these addresses.

638
00:38:45,620 --> 00:38:47,750
Anyway, so there's likely to be kernel data,

639
00:38:48,110 --> 00:38:49,340
even if you're running a user space,

640
00:38:49,340 --> 00:38:52,710
is likely to be kernel data in the L1 cache,

641
00:38:53,070 --> 00:38:55,770
and it's these permissions which are copied out of the TLB,

642
00:38:55,770 --> 00:38:57,330
copied out of page table entries,

643
00:38:57,510 --> 00:39:01,290
that tells the machine that oh even though the data is in the cache,

644
00:39:01,320 --> 00:39:02,490
you're not allowed to see it,

645
00:39:03,130 --> 00:39:05,050
and raise raise a page fault.

646
00:39:11,870 --> 00:39:13,940
So this is a good time to mention that,

647
00:39:15,220 --> 00:39:22,390
even though the intent of micro-architectural optimizations is they be completely transparent,

648
00:39:24,910 --> 00:39:26,650
that can't possibly be true,

649
00:39:26,740 --> 00:39:30,730
because the whole point of these micro-architectural optimizations

650
00:39:30,730 --> 00:39:33,040
is almost always to improve performance,

651
00:39:33,160 --> 00:39:39,250
and so they will be guaranteed to be at least visible in terms of performance,

652
00:39:39,310 --> 00:39:41,680
as you could tell if your machine has a cache or not,

653
00:39:41,710 --> 00:39:43,360
because if it doesn't have a cache,

654
00:39:43,390 --> 00:39:46,600
it'll run a couple hundred times slower, right,

655
00:39:47,020 --> 00:39:50,980
in addition you can tell where the data you're trying to fetch,

656
00:39:51,010 --> 00:39:53,350
if you're capable of measuring time accurately enough,

657
00:39:53,590 --> 00:39:55,600
and you do a load, you can tell,

658
00:39:55,900 --> 00:39:59,440
if the load returned in a couple cycles, the data must have been cached,

659
00:39:59,440 --> 00:40:02,380
if the load returned after a hundred times that,

660
00:40:03,360 --> 00:40:05,820
they probably had to be loaded from RAM,

661
00:40:06,210 --> 00:40:07,650
and so the differences are profound,

662
00:40:07,650 --> 00:40:12,600
and if you can measure time to you know a few nanoseconds or even tens of nanoseconds,

663
00:40:12,780 --> 00:40:14,070
you can tell the difference,

664
00:40:14,220 --> 00:40:15,420
so in the performance level,

665
00:40:15,510 --> 00:40:18,390
is micro-architecture is absolutely not transparent.

666
00:40:19,120 --> 00:40:22,330
And all the things we talk about, branch prediction caches or whatever,

667
00:40:22,330 --> 00:40:28,300
all that stuff is at least indirectly visible to timing.

668
00:40:30,990 --> 00:40:32,190
And so, of course many people,

669
00:40:32,190 --> 00:40:40,020
even though the micro-architectural design is sort of in any detailed level secret,

670
00:40:40,440 --> 00:40:42,990
to Intel, it's their private business how they implement this,

671
00:40:43,020 --> 00:40:48,630
in fact it's all along been of extremely intense interest to a lot of people,

672
00:40:48,630 --> 00:40:50,310
because it affects performance a lot.

673
00:40:50,520 --> 00:40:55,230
So a compiler writers for example know a lot about micro-architecture,

674
00:40:55,230 --> 00:40:58,350
because, the most many many compiler optimizations

675
00:40:58,350 --> 00:41:04,890
are implicitly exploiting people's good guesses about what the machines actually doing inside.

676
00:41:05,500 --> 00:41:11,800
And indeed the CPU manufacturers publish optimization guides,

677
00:41:11,830 --> 00:41:15,010
that reveal some of the micro-architectural tricks,

678
00:41:15,100 --> 00:41:16,840
but they rarely go into much detail,

679
00:41:17,410 --> 00:41:23,560
certainly not enough detail to really understand exactly why meltdown works.

680
00:41:24,180 --> 00:41:27,240
So the micro-architecture stuff is sort of sits somewhere

681
00:41:27,240 --> 00:41:34,540
between supposed to be transparent and visible and hidden and sort of partially,

682
00:41:34,630 --> 00:41:39,460
you know certainly a lot of people are interested

683
00:41:39,460 --> 00:41:41,800
and a lot of people know all kinds of random things about it.

684
00:41:43,800 --> 00:41:50,420
Okay, so the reason why this cache stuff is interesting for meltdown,

685
00:41:50,540 --> 00:41:53,390
first of all, any questions about about caching?

686
00:41:58,660 --> 00:42:02,530
Okay, let me talk them,

687
00:42:03,720 --> 00:42:09,300
about sort of main way that the paper uses caching,

688
00:42:09,300 --> 00:42:13,800
the paper talks about this technique called flush, flush and reload.

689
00:42:18,740 --> 00:42:21,760
And, what flush and reload is up to,

690
00:42:21,760 --> 00:42:23,710
is that it's answering the question

691
00:42:24,850 --> 00:42:33,350
did a particular piece of code use the memory at a particular address.

692
00:42:33,840 --> 00:42:39,120
And it's not directly a security exploit,

693
00:42:39,120 --> 00:42:41,820
because it only works for memory that you can get at.

694
00:42:42,210 --> 00:42:43,380
So if your user code

695
00:42:43,380 --> 00:42:45,060
and you have some memory, that's your memory

696
00:42:45,060 --> 00:42:45,960
and you're allowed to use it,

697
00:42:46,140 --> 00:42:48,600
you can and you call one of your own functions

698
00:42:48,600 --> 00:42:52,110
or then you'll be able to tell,

699
00:42:52,110 --> 00:42:54,120
you can use flush and reload to tell,

700
00:42:54,120 --> 00:42:58,800
whether the function your function, you just executed used your memory,

701
00:42:59,320 --> 00:43:02,740
you can't directly use this attack or it's not an attack,

702
00:43:02,770 --> 00:43:04,990
you can use this technique to figure out,

703
00:43:04,990 --> 00:43:09,010
if some other process use that process is private memory,

704
00:43:11,110 --> 00:43:14,590
although, because processes sometimes share memory, yeah,

705
00:43:16,180 --> 00:43:18,220
you may still be able to do,

706
00:43:18,220 --> 00:43:20,210
well, the right way to put it is

707
00:43:20,210 --> 00:43:22,760
you can only find out about memory you're allowed to access.

708
00:43:23,540 --> 00:43:24,980
Okay, so answering the question,

709
00:43:25,780 --> 00:43:29,620
did did a particular function use this memory.

710
00:43:29,650 --> 00:43:35,960
So, step one, is we're gonna flush,

711
00:43:35,960 --> 00:43:39,050
supposing we were interested in address x,

712
00:43:41,240 --> 00:43:43,130
we want to flush the cache,

713
00:43:43,130 --> 00:43:47,600
we want to make sure the cache doesn't contain the memory location x,

714
00:43:47,600 --> 00:43:49,850
and it turns out that for our convenience,

715
00:43:50,270 --> 00:43:55,600
Intel supplies an instruction, called clFlash,

716
00:43:56,680 --> 00:43:58,210
and you give it an address

717
00:43:58,720 --> 00:44:01,660
and it will get rid of,

718
00:44:01,660 --> 00:44:06,730
it will ensure that that location is not cached any of the caches,

719
00:44:07,120 --> 00:44:08,440
and so that's super convenient.

720
00:44:10,360 --> 00:44:12,790
Even if the machine didn't provide this instruction,

721
00:44:12,790 --> 00:44:15,760
that it turns out, there's ways of getting rid of stuff from the cache,

722
00:44:15,760 --> 00:44:19,810
like for example if you know the cache holds 64 kilobytes,

723
00:44:19,840 --> 00:44:22,810
then it's likely to be the case,

724
00:44:22,810 --> 00:44:26,410
that if you load 64 kilobytes of random memory,

725
00:44:26,760 --> 00:44:28,710
you know just load instructions that,

726
00:44:29,010 --> 00:44:32,040
those will be loaded into the cache,

727
00:44:32,250 --> 00:44:35,760
and after you've loaded 64 kilobytes of new data into the cache,

728
00:44:36,360 --> 00:44:38,100
everything that used to be in it must be gone,

729
00:44:38,130 --> 00:44:41,130
because the cache can only hold 64 kilobytes or whatever it may be.

730
00:44:41,580 --> 00:44:44,540
So, even without this [] instruction,

731
00:44:44,600 --> 00:44:47,090
you can still flush everything in the cache.

732
00:44:47,660 --> 00:44:49,040
Then step two is,

733
00:44:49,250 --> 00:44:54,770
you're interested in whether some particular piece of code uses data x,

734
00:44:54,770 --> 00:44:57,140
you just call that code whatever it is,

735
00:44:57,920 --> 00:45:01,580
and it does what it does maybe uses x, maybe doesn't,

736
00:45:02,590 --> 00:45:06,670
now you wanna tell if x is actually in the cache,

737
00:45:06,670 --> 00:45:08,980
because if it is if you flushed from the cache,

738
00:45:09,010 --> 00:45:09,970
if it's in the cache now,

739
00:45:09,970 --> 00:45:12,130
it must be that f causes to be loaded,

740
00:45:12,670 --> 00:45:13,900
unless something else is going on.

741
00:45:14,140 --> 00:45:17,170
So you need to, you want to do a load,

742
00:45:17,170 --> 00:45:19,120
but you wanna know how long the load takes,

743
00:45:19,450 --> 00:45:21,700
so we're only talking about nanoseconds,

744
00:45:21,700 --> 00:45:24,310
like five nanoseconds versus hundred nanoseconds here,

745
00:45:24,310 --> 00:45:26,200
how can we measure time that accurately,

746
00:45:26,380 --> 00:45:29,170
that's a tough assignment,

747
00:45:29,170 --> 00:45:32,740
however again the CPUs come to [ra],

748
00:45:32,740 --> 00:45:37,360
in fact provide instruction which gives you cycle granularity time,

749
00:45:39,620 --> 00:45:41,360
and it's called rdtsc,

750
00:45:42,010 --> 00:45:47,140
so we're just gonna execute the rdtsc instruction,

751
00:45:47,170 --> 00:45:50,140
which tells us essentially the number of cycles that have elapsed,

752
00:45:50,140 --> 00:45:53,620
since the machine cycles have elapsed since the machine started.

753
00:45:54,330 --> 00:45:56,580
And since it's probably 2 GHz machine,

754
00:45:56,580 --> 00:46:00,120
that means that the precision we have here is half a nanosecond,

755
00:46:00,830 --> 00:46:01,820
its pretty small.

756
00:46:02,360 --> 00:46:04,850
Now we're gonna load,

757
00:46:06,500 --> 00:46:13,840
we're just gonna say junk equals star x,

758
00:46:13,870 --> 00:46:17,860
we're going to load the data of location x,

759
00:46:18,250 --> 00:46:19,690
I get the time again,

760
00:46:23,300 --> 00:46:26,750
and look at the difference right, b minus a,

761
00:46:29,450 --> 00:46:33,620
if b minus a is you know 5 or 6 or 7 or something,

762
00:46:33,620 --> 00:46:36,530
that means that this load hit in the cache,

763
00:46:36,530 --> 00:46:38,600
and that means that this function used the data,

764
00:46:38,870 --> 00:46:41,180
if b minus a is 150,

765
00:46:41,930 --> 00:46:45,530
then that means that x wasn't in the cache,

766
00:46:45,980 --> 00:46:50,410
and yeah you know that may probably means that f,

767
00:46:50,410 --> 00:46:52,660
that may mean that did never used x,

768
00:46:52,690 --> 00:46:54,520
that's not quite that cut and dry,

769
00:46:54,520 --> 00:46:57,970
because f might have used x and then use something else,

770
00:46:58,330 --> 00:47:00,940
that conflicted with x in the cache

771
00:47:00,940 --> 00:47:03,460
and caused x to be kicked out of the cache again.

772
00:47:03,580 --> 00:47:05,470
But, for simple situations,

773
00:47:06,910 --> 00:47:11,260
a very large value of b minus a, means f didn't use it,

774
00:47:11,260 --> 00:47:15,670
in a small value of b minus a, means that f did use that data.

775
00:47:18,070 --> 00:47:19,900
So this is not an attack yet,

776
00:47:19,900 --> 00:47:24,760
because again we have to be able to access this memory,

777
00:47:24,760 --> 00:47:26,230
so this is our memory.

778
00:47:28,290 --> 00:47:31,560
Any questions about flush plus reload?

779
00:47:40,340 --> 00:47:44,140
Alright, I think that's all the preliminaries,

780
00:47:44,470 --> 00:47:46,360
let's go back to meltdown.

781
00:47:48,910 --> 00:47:51,040
So this is a more full version,

782
00:47:51,040 --> 00:47:53,800
I showed you sort of core meltdown at the beginning,

783
00:47:53,920 --> 00:47:57,280
this is a more complete meltdown.

784
00:47:59,690 --> 00:48:02,960
And so we actually now have I added the flush and reload part.

785
00:48:04,380 --> 00:48:06,150
Again, we're going to declare this buffer,

786
00:48:06,210 --> 00:48:08,940
and the idea is that,

787
00:48:09,090 --> 00:48:13,050
depending on we're gonna be just fetching one bit from the kernel,

788
00:48:13,200 --> 00:48:17,370
we're going to multiply that one bit by 4096,

789
00:48:17,370 --> 00:48:19,440
so we're hoping to use flush plus reload

790
00:48:19,440 --> 00:48:22,110
to see that either buf of 0 is in the cache

791
00:48:22,110 --> 00:48:24,540
or buffer of 4096 is in the cache,

792
00:48:24,690 --> 00:48:29,130
and the reason for the large separation there

793
00:48:30,280 --> 00:48:33,700
is that apparently the pref-, this hardware has a prefetcher in it,

794
00:48:33,700 --> 00:48:35,560
so if you load one thing from memory,

795
00:48:35,770 --> 00:48:38,290
it will load the next couple things up from memory too,

796
00:48:38,320 --> 00:48:39,580
the next couple of cache lines,

797
00:48:39,760 --> 00:48:42,790
and so we can't have the two different cache lines,

798
00:48:42,820 --> 00:48:46,150
that we're going to apply flush and reload to be to be particularly close,

799
00:48:46,560 --> 00:48:47,730
need to be far enough apart,

800
00:48:47,730 --> 00:48:52,320
that even prefetch, hardware prefetching won't cause confusion.

801
00:48:53,030 --> 00:48:54,530
So we put the whole page apart,

802
00:48:55,760 --> 00:48:56,750
the flash part now,

803
00:48:56,780 --> 00:48:58,850
we just call this clflush instruction

804
00:48:59,060 --> 00:49:05,970
to make sure that the relevant parts of our buf are not catched.

805
00:49:06,700 --> 00:49:19,470
Now, we're exploiting,

806
00:49:19,500 --> 00:49:22,800
this line 7 is not maybe may or may not be necessary,

807
00:49:22,800 --> 00:49:26,850
but what what's going on here is we're exploiting this sort of,

808
00:49:27,360 --> 00:49:35,000
I'm going to be exploiting the gap in time between,

809
00:49:36,030 --> 00:49:41,780
you know, we we're doing this load line 10 to load a kernel address,

810
00:49:41,780 --> 00:49:42,860
so it's gonna fault,

811
00:49:43,700 --> 00:49:47,990
but we're hoping to be able to execute another couple of instructions speculatively,

812
00:49:48,080 --> 00:49:51,140
before this instruction is retired,

813
00:49:51,230 --> 00:49:55,520
and before it actually raises the fault and cancels these instructions, right,

814
00:49:55,610 --> 00:49:58,880
if the fault if this load would be retired,

815
00:49:58,880 --> 00:50:00,290
say at this point,

816
00:50:00,700 --> 00:50:02,440
that would be too early for us,

817
00:50:02,620 --> 00:50:07,240
because it's going to turn out we actually need line 13 to be speculatively executed

818
00:50:07,510 --> 00:50:08,980
in order to complete the attack,

819
00:50:09,160 --> 00:50:10,780
so we want to make sure that

820
00:50:10,780 --> 00:50:14,470
this load isn't retired for as long as possible,

821
00:50:15,150 --> 00:50:20,120
in order to delay the fault and delay the speculative cancellation.

822
00:50:20,480 --> 00:50:24,920
Now we know instructions aren't retired until all previous instructions have retired,

823
00:50:25,400 --> 00:50:26,480
it's one of the rules.

824
00:50:27,090 --> 00:50:28,560
So at line 7,

825
00:50:28,620 --> 00:50:32,010
I'm imagining that we're going to launch some expensive instruction,

826
00:50:32,010 --> 00:50:33,600
that doesn't complete for a long time,

827
00:50:33,840 --> 00:50:37,110
maybe it loads something else that's known to have to come from RAM,

828
00:50:37,110 --> 00:50:38,580
so it'll take a few hundred cycles,

829
00:50:38,580 --> 00:50:41,760
or maybe it does a divide or a square root or something,

830
00:50:41,760 --> 00:50:43,980
who knows what something that takes a long time,

831
00:50:44,070 --> 00:50:46,320
it won't be retired for a long time,

832
00:50:46,530 --> 00:50:50,340
and therefore will cause this load not to be retired for a long time,

833
00:50:50,550 --> 00:50:53,940
giving these instructions time to execute speculatively.

834
00:50:57,420 --> 00:50:59,010
Right, now we're assuming again,

835
00:50:59,010 --> 00:51:01,830
we have a virtual address in the kernel,

836
00:51:04,680 --> 00:51:06,960
gonna execute line 10,

837
00:51:07,140 --> 00:51:09,150
line ten won't raise a fault, until that,

838
00:51:09,150 --> 00:51:10,590
we know it's going to raise a fault,

839
00:51:10,590 --> 00:51:12,120
won't raise a fault until retires,

840
00:51:12,120 --> 00:51:15,300
but we're intending, we believe we've set things up,

841
00:51:15,300 --> 00:51:17,640
so won't retire for a while, since it hasn't retired,

842
00:51:18,390 --> 00:51:20,190
and because on Intel CPUs,

843
00:51:20,310 --> 00:51:23,790
the data is returned, even if you weren't allowed to see it,

844
00:51:23,940 --> 00:51:26,830
the data return for speculative execution,

845
00:51:26,830 --> 00:51:28,270
even if you did not permission,

846
00:51:28,840 --> 00:51:32,050
that means that we can speculatively execute,

847
00:51:32,320 --> 00:51:34,420
the machine will speculatively execute line 11

848
00:51:34,420 --> 00:51:37,560
and get the low bit of kernel data now,

849
00:51:38,040 --> 00:51:40,140
multiplied by 4096,

850
00:51:40,350 --> 00:51:43,770
line 13 is itself a load, it's another load,

851
00:51:44,570 --> 00:51:50,800
using an address basically the address of buf plus the contents of r2,

852
00:51:51,570 --> 00:51:54,510
we know it's going to get cancelled,

853
00:51:55,160 --> 00:51:57,620
because we know this will fault, right,

854
00:51:57,620 --> 00:52:00,440
we know the actual write to r3 will be cancelled,

855
00:52:00,470 --> 00:52:09,250
but line 13 will cause some data from buf to be loaded into the cache,

856
00:52:09,520 --> 00:52:12,400
even if it doesn't end up affecting register 3,

857
00:52:12,490 --> 00:52:17,860
so r3, line 13 is going to cause something to be loaded into the cache,

858
00:52:18,100 --> 00:52:21,250
and this case depending on whether the low bit is 0 or 1,

859
00:52:21,880 --> 00:52:28,660
line 13 will cause the actual cache to contain either buf 0 or buf 4096,

860
00:52:30,010 --> 00:52:33,250
then, right, then that,

861
00:52:33,460 --> 00:52:35,440
even though r2 and r3 are cancelled,

862
00:52:35,500 --> 00:52:38,200
the change in the cache,

863
00:52:38,230 --> 00:52:40,600
because it's supposed to be hidden micro-architectural state,

864
00:52:40,600 --> 00:52:43,420
that will actually be the cache will be changed.

865
00:52:44,680 --> 00:52:46,600
Finally, at some point, the fault will happen,

866
00:52:46,990 --> 00:52:50,740
and we need to sort of recover after the fault,

867
00:52:50,740 --> 00:52:52,510
but it's just a page fault,

868
00:52:52,510 --> 00:52:57,160
and it turns out you can or user process can register a page fault handler

869
00:52:57,340 --> 00:52:59,200
and get control back after a page fault,

870
00:52:59,200 --> 00:53:03,730
and the paper mentions a couple of other ways of being able to continue after the fault.

871
00:53:05,470 --> 00:53:06,940
And now all we have to do is figure out

872
00:53:06,940 --> 00:53:11,440
whether it was buf 0 or buf 4096, that was loaded into the cache,

873
00:53:11,620 --> 00:53:13,930
and now we can do the reload part of flush and reload,

874
00:53:14,050 --> 00:53:17,290
we read the accurate time,

875
00:53:18,120 --> 00:53:20,460
load buf 0, read the time again,

876
00:53:20,460 --> 00:53:22,800
load buf 1, read the time again,

877
00:53:22,800 --> 00:53:24,780
and compare the two differences in time,

878
00:53:24,930 --> 00:53:27,570
and whichever one of these took a shorter amount of time,

879
00:53:28,140 --> 00:53:34,520
is likely to indicate whether the low bit of the kernel data was 0 or 1.

880
00:53:39,350 --> 00:53:43,490
And then we report that repeat that a couple of billion times,

881
00:53:44,270 --> 00:53:45,770
we can scan all of kernel memory.

882
00:53:47,100 --> 00:53:49,080
But in this example,

883
00:53:49,230 --> 00:53:52,560
if b minus a smaller than c minus b,

884
00:53:52,560 --> 00:53:56,400
doesn't that mean that buf of 0 was cached.

885
00:53:57,060 --> 00:54:00,420
Let's see if I got this wrong,

886
00:54:00,450 --> 00:54:03,630
b minus a yeah means the buf 0 was cache,

887
00:54:03,630 --> 00:54:06,600
oh yeah yeah yeah you're right.

888
00:54:10,790 --> 00:54:15,180
Now we're [], good catch.

889
00:54:17,540 --> 00:54:19,670
Oh, sorry, do you need for,

890
00:54:19,820 --> 00:54:25,010
before we had an if before like 9,

891
00:54:25,700 --> 00:54:30,050
do we need if now or is it is still at all.

892
00:54:31,980 --> 00:54:38,280
The efforts to help me illustrate the legitimate reasons for speculative execution,

893
00:54:38,820 --> 00:54:43,410
keep computing even though we don't know whether the branch took or not,

894
00:54:43,410 --> 00:54:47,610
but here the real core of the speculation is that,

895
00:54:47,670 --> 00:54:51,740
we don't know if this load will fault, right,

896
00:54:51,740 --> 00:54:56,150
and so we're the machines speculatively executing past the load,

897
00:54:56,330 --> 00:55:00,830
on the theory that it's probably most don't fault, right,

898
00:55:00,830 --> 00:55:02,090
even though they may take a long time,

899
00:55:02,090 --> 00:55:04,340
like a load could take hundreds of cycles,

900
00:55:04,970 --> 00:55:06,440
and so we'd love to be able to,

901
00:55:06,470 --> 00:55:09,530
so the machine will speculatively execute pass the load,

902
00:55:10,040 --> 00:55:14,140
even though it doesn't, not knowing whether it's going to fault or not,

903
00:55:14,140 --> 00:55:16,300
and if the load did fault,

904
00:55:16,300 --> 00:55:18,460
it will then undo all this speculative execution,

905
00:55:18,730 --> 00:55:20,980
there's a speculative execution comes up,

906
00:55:21,670 --> 00:55:27,970
any time you have a long running instruction that may or may not succeed,

907
00:55:28,000 --> 00:55:29,080
so like divide,

908
00:55:29,110 --> 00:55:31,030
so we know whether it's going to be divided by zero or not,

909
00:55:31,030 --> 00:55:33,940
you know so instructions after divider also speculated.

910
00:55:35,980 --> 00:55:39,070
Anyway, the speculation, the real critical speculation starts here,

911
00:55:39,070 --> 00:55:40,120
now, in fact we tried,

912
00:55:41,260 --> 00:55:43,930
in order to make the attack likely more successful,

913
00:55:43,930 --> 00:55:46,570
we sort of ensure that speculation starts here,

914
00:55:46,570 --> 00:55:48,790
but this is the real speculation we care about.

915
00:56:01,640 --> 00:56:02,690
Other questions?

916
00:56:06,100 --> 00:56:10,730
For this example we've only read one bit,

917
00:56:13,050 --> 00:56:16,590
is is there some likes really small, simple modification,

918
00:56:16,590 --> 00:56:19,890
that we could make to read like a full register size of bits.

919
00:56:20,100 --> 00:56:22,590
Yeah, run this 64 times, one for each bit.

920
00:56:24,810 --> 00:56:29,760
Why is it not possible to just read 64 bits at a time?

921
00:56:30,790 --> 00:56:34,290
A sixty, sixty, well you need the buf,

922
00:56:34,320 --> 00:56:36,660
the size of this buffer has to be

923
00:56:36,660 --> 00:56:44,430
to the you know two to the number of bits, you're reading times 4096 or something,

924
00:56:44,670 --> 00:56:46,050
so 64 bits is too big,

925
00:56:46,050 --> 00:56:48,810
we don't have enough memory to a make a buffer that big,

926
00:56:50,810 --> 00:56:52,700
we need this, the way this is set up.

927
00:56:54,810 --> 00:57:00,310
But anyway, 64 bits too much,

928
00:57:00,310 --> 00:57:02,080
you could certainly 8 bit of time,

929
00:57:02,320 --> 00:57:09,350
and have this buf size be 256 times 4096.

930
00:57:11,620 --> 00:57:13,060
The paper actually argues the,

931
00:57:14,860 --> 00:57:16,540
the paper observes,

932
00:57:18,150 --> 00:57:23,500
that since the most of the time is here in the flush reload,

933
00:57:25,380 --> 00:57:27,720
if you read a byte at a time,

934
00:57:28,620 --> 00:57:36,750
then figuring out what the bits of that byte are takes 256 flush and reloads,

935
00:57:38,310 --> 00:57:40,140
one for each possible value.

936
00:57:40,800 --> 00:57:42,780
If you load a bit at a time,

937
00:57:43,140 --> 00:57:47,470
then each bit takes just one flush plus reload,

938
00:57:47,470 --> 00:57:51,460
are sort of two two are two flush plus reloads,

939
00:57:51,610 --> 00:57:52,930
so if you need a bit of time,

940
00:57:53,140 --> 00:57:56,170
then you end up only doing 16 flush plus reloads,

941
00:57:56,170 --> 00:57:57,160
if you read a byte at a time,

942
00:57:57,160 --> 00:57:59,800
you end up doing 256 flush plus reloads,

943
00:58:00,160 --> 00:58:00,910
the paper says that,

944
00:58:00,910 --> 00:58:04,000
it's faster to do it a bit at a time than a byte at a time.

945
00:58:05,890 --> 00:58:10,500
Which seems a little counterintuitive, seems to be true.

946
00:58:18,960 --> 00:58:20,010
Other questions?

947
00:58:28,760 --> 00:58:32,810
So where would this user program, will this program have to be run from,

948
00:58:33,890 --> 00:58:37,400
is there any particular location on the machine,

949
00:58:37,400 --> 00:58:38,690
that doesn't have to be,

950
00:58:39,480 --> 00:58:41,220
where would you write it I guess?

951
00:58:43,650 --> 00:58:47,340
Where would this program be run from, can be a user program?

952
00:58:47,880 --> 00:58:53,250
Well yeah, that depends on what kind of access, you have to the machine,

953
00:58:53,250 --> 00:58:55,740
and where the data is that you want to steal,

954
00:58:56,070 --> 00:58:59,360
and then you know who knows, right.

955
00:58:59,360 --> 00:59:02,150
But for example is supposing,

956
00:59:03,000 --> 00:59:05,610
you're logged into Athena [] machine,

957
00:59:06,030 --> 00:59:08,160
it was a couple hundred other users,

958
00:59:08,250 --> 00:59:10,170
and you want to steal somebody's password,

959
00:59:11,470 --> 00:59:12,340
and you're patient,

960
00:59:13,030 --> 00:59:15,160
you can use and let's assume,

961
00:59:15,160 --> 00:59:17,320
that Athena is you know a couple years ago

962
00:59:17,320 --> 00:59:19,000
and Athena was running a version of Linux

963
00:59:19,000 --> 00:59:22,840
that mapped the kernel into every user's every processes address space,

964
00:59:23,140 --> 00:59:26,080
then you can use meltdown to get out bit by bit,

965
00:59:26,560 --> 00:59:27,430
everything in the kernel,

966
00:59:27,430 --> 00:59:30,820
including [] IO buffers and the network buffers and stuff,

967
00:59:30,910 --> 00:59:32,590
and if somebody's typing their password,

968
00:59:32,620 --> 00:59:34,390
if you're lucky or patient,

969
00:59:35,340 --> 00:59:36,570
and somebody's typing you know password,

970
00:59:36,570 --> 00:59:37,830
and you load all of kernel memory,

971
00:59:37,860 --> 00:59:41,760
you're going to see that password in kernel memory, right.

972
00:59:42,580 --> 00:59:44,920
And because in fact the kernel probably maps

973
00:59:44,950 --> 00:59:47,590
like xv6 maps all of physical memory,

974
00:59:47,830 --> 00:59:49,690
that means you can probably read all physical memory,

975
00:59:49,690 --> 00:59:53,200
that is all of all other processes memory,

976
00:59:53,320 --> 00:59:55,690
using this technique on a time sharing machine.

977
00:59:56,640 --> 01:00:01,500
So I can see what's everybody's in text editor contents or whatever I like.

978
01:00:02,500 --> 01:00:04,330
Now you have to,

979
01:00:05,460 --> 01:00:06,630
that's a way you could use it,

980
01:00:06,630 --> 01:00:08,010
if you're using a time machine,

981
01:00:08,010 --> 01:00:11,600
for other situations, you know it would be different.

982
01:00:12,270 --> 01:00:13,170
Make sense.

983
01:00:13,920 --> 01:00:16,740
In time sharing is not that pervasive anymore,

984
01:00:16,980 --> 01:00:20,130
but the sort of killer scenario

985
01:00:20,130 --> 01:00:21,990
would be some kind of cloud computing thing,

986
01:00:21,990 --> 01:00:25,260
where you're using a cloud provider like Amazon,

987
01:00:25,650 --> 01:00:28,620
and you know which runs many customers on the same machine.

988
01:00:29,280 --> 01:00:33,480
And depending on the details of how they set up their virtual machine monitor

989
01:00:33,480 --> 01:00:36,090
or container system or whatever it may be.

990
01:00:36,450 --> 01:00:40,640
If you buy time from Amazon,

991
01:00:41,330 --> 01:00:46,720
then you may be able to peer into the memory of other customer's software

992
01:00:46,720 --> 01:00:48,580
running on the same Amazon machine maybe.

993
01:00:50,730 --> 01:00:51,900
So I think that's really,

994
01:00:53,230 --> 01:00:55,120
yeah, that's how people actually use this probably.

995
01:00:55,300 --> 01:00:59,170
Actually another time that might be useful is your browser,

996
01:00:59,170 --> 01:00:59,800
when you're browsing,

997
01:00:59,800 --> 01:01:03,070
the web browser actually runs a lot of code in it that is not trusted,

998
01:01:03,070 --> 01:01:05,350
that is supplied by the random websites you visit,

999
01:01:07,330 --> 01:01:08,860
maybe in the form of plugins,

1000
01:01:09,070 --> 01:01:12,370
may be in the form of Javascript, that's loaded in your browser,

1001
01:01:12,370 --> 01:01:15,840
and compiled by the browser and execute it,

1002
01:01:15,990 --> 01:01:19,500
and it is possible, that this attack could be carried out

1003
01:01:19,770 --> 01:01:25,340
by code that you run in your browser when you browse the web.

1004
01:01:26,190 --> 01:01:26,970
That you may not,

1005
01:01:28,060 --> 01:01:30,220
even though it's running their load from websites

1006
01:01:30,220 --> 01:01:32,620
and they would steal whatever stuff is sitting in your laptop.

1007
01:01:33,790 --> 01:01:36,040
I don't know if the details of that quite work out.

1008
01:01:37,180 --> 01:01:42,190
Has anyone demonstrated an attack through either Javascript or like WebAssembly?

1009
01:01:42,250 --> 01:01:43,150
I don't know, I don't,

1010
01:01:43,150 --> 01:01:46,300
I I feel certainly people worried about WebAssembly.

1011
01:01:46,920 --> 01:01:49,230
I don't know whether the attack was literally possible,

1012
01:01:50,010 --> 01:01:53,280
for Javascript I know that,

1013
01:01:53,900 --> 01:01:57,760
maybe the sticking point was the accurate time, I mean.

1014
01:01:59,370 --> 01:02:01,620
You couldn't quite get this nanosecond timing,

1015
01:02:01,680 --> 01:02:04,770
so you couldn't quite execute flush and reload now,

1016
01:02:04,770 --> 01:02:07,200
whether somebody with a bit more cleverness

1017
01:02:07,200 --> 01:02:08,430
could figure out a way to do it,

1018
01:02:08,430 --> 01:02:13,250
I don't know WebAssembly is much closer to running machine code,

1019
01:02:13,250 --> 01:02:16,610
and you know I I don't know exactly how the details worked out,

1020
01:02:16,610 --> 01:02:21,160
but, oh boy was, so many people rapidly thought about.

1021
01:02:25,250 --> 01:02:29,180
Okay, it turns out the attack doesn't always work,

1022
01:02:29,420 --> 01:02:30,740
like and for reasons that,

1023
01:02:30,830 --> 01:02:31,520
I don't think,

1024
01:02:31,550 --> 01:02:35,120
the author never explained or only speculated about,

1025
01:02:35,120 --> 01:02:38,000
and you can see, I don't know if you can see this,

1026
01:02:38,000 --> 01:02:39,140
well, maybe you can't see this,

1027
01:02:39,170 --> 01:02:41,990
but if you turn the last page of their paper,

1028
01:02:42,260 --> 01:02:44,060
you'll see the output it's actually,

1029
01:02:44,150 --> 01:02:47,150
you know, they mounted the attack on their own machines

1030
01:02:47,150 --> 01:02:51,080
and extracted a bunch of data from their own, the kernel on their own machine.

1031
01:02:51,530 --> 01:02:53,670
And, if you look closer,

1032
01:02:53,670 --> 01:02:56,040
you'll see there's a huge all these lines

1033
01:02:56,370 --> 01:03:01,410
are just xx xxx xxx, all these lines x x with dots,

1034
01:03:01,560 --> 01:03:04,620
these are places where they didn't manage to extract anything,

1035
01:03:04,650 --> 01:03:06,120
where meltdown failed,

1036
01:03:06,540 --> 01:03:08,880
even though they repeated it many times.

1037
01:03:09,340 --> 01:03:11,530
And you can tell they must have been,

1038
01:03:11,650 --> 01:03:16,480
you know they were the papers version of this attack was re-trying many many times,

1039
01:03:16,480 --> 01:03:19,570
because for example section 6.2 talks about performance,

1040
01:03:19,870 --> 01:03:21,340
says that in some cases,

1041
01:03:21,490 --> 01:03:24,910
the rate at which they could extract data was only ten bytes per second,

1042
01:03:25,450 --> 01:03:27,640
which means they were sitting there trying again and again and again,

1043
01:03:27,640 --> 01:03:31,660
and after thousands of times they finally managed to get some data,

1044
01:03:31,660 --> 01:03:32,230
that is that,

1045
01:03:32,730 --> 01:03:37,860
flush plus reload indicated that the two cache lines at different load times.

1046
01:03:39,270 --> 01:03:40,710
So there's something unexplained going on

1047
01:03:40,710 --> 01:03:45,180
about why it's quite frequent for meltdown actually fail,

1048
01:03:45,210 --> 01:03:47,580
get some data actually got real data here,

1049
01:03:48,140 --> 01:03:49,970
there's also a bunch of data that they didn't get,

1050
01:03:50,420 --> 01:03:54,370
and I don't know if people,

1051
01:03:54,370 --> 01:03:56,410
as far as I know, people are not really sure,

1052
01:03:56,410 --> 01:04:00,340
what all the conditions are about when it succeeds when it doesn't,

1053
01:04:00,490 --> 01:04:03,130
you know the most straightforward possibility is that,

1054
01:04:03,130 --> 01:04:07,420
if the kernel data is in the L1 cache, the meltdown succeeds,

1055
01:04:07,420 --> 01:04:10,540
and the kernel data is not in the L1 cache, doesn't succeed.

1056
01:04:10,600 --> 01:04:15,010
That's very easy to believe that that could be what's going on,

1057
01:04:15,760 --> 01:04:17,500
because if it's not in the L1 cache,

1058
01:04:17,620 --> 01:04:21,490
then there's a whole bunch more machinery involved in speculative load

1059
01:04:21,730 --> 01:04:26,740
and it's easy to imagine that the CPU for speculative load,

1060
01:04:26,770 --> 01:04:28,990
that's maybe not known if it's even needed,

1061
01:04:29,590 --> 01:04:34,840
would not bother doing all the work required to load stuff from RAM.

1062
01:04:36,440 --> 01:04:39,280
But, it's not quite that simple,

1063
01:04:40,150 --> 01:04:41,500
you can tell it's not quite that simple,

1064
01:04:41,500 --> 01:04:44,290
because the paper says that sometimes when they tried,

1065
01:04:44,380 --> 01:04:47,650
retried many times and it finally worked,

1066
01:04:47,710 --> 01:04:50,970
so there's some more complex condition,

1067
01:04:51,000 --> 01:04:54,360
maybe a race effectively race inside the CPU

1068
01:04:54,750 --> 01:04:57,030
under which it occasionally works,

1069
01:04:57,800 --> 01:04:59,990
even for data that's not not in the cache.

1070
01:05:06,670 --> 01:05:08,650
The end of the paper is actually also,

1071
01:05:08,650 --> 01:05:10,420
if you didn't get that for worth reading,

1072
01:05:10,420 --> 01:05:13,570
because it does explain a sort of more real world,

1073
01:05:13,570 --> 01:05:15,700
like we wanted to find out this particular thing,

1074
01:05:15,700 --> 01:05:20,410
you know this, we know there's passwords stored in our Firefox's password manager,

1075
01:05:20,440 --> 01:05:21,430
we wanted to get them out

1076
01:05:21,820 --> 01:05:23,680
and steal them using meltdown,

1077
01:05:23,860 --> 01:05:26,680
you know what are all the, how do you find out what the addresses,

1078
01:05:26,680 --> 01:05:30,100
for example, they sort of lay out a complete attack,

1079
01:05:30,340 --> 01:05:34,290
I mean, a complete attack done by academics not real attackers,

1080
01:05:34,290 --> 01:05:37,290
but nevertheless and filling many of the [pragmatic] details.

1081
01:05:40,630 --> 01:05:44,290
The only thing I want to talk about is his fixes,

1082
01:05:45,090 --> 01:05:46,380
you've already touched on a little bit.

1083
01:05:47,230 --> 01:05:52,560
When this paper came out, it got a lot of attention,

1084
01:05:52,560 --> 01:05:54,180
and there was actually another second paper

1085
01:05:54,180 --> 01:05:57,960
by overlapping set of people about a different attack,

1086
01:05:57,960 --> 01:06:03,320
that also used different, different kind of speculation inside CPUs, called spectre.

1087
01:06:03,350 --> 01:06:06,650
So the pair of papers came out at the same time

1088
01:06:06,680 --> 01:06:09,920
and was very exciting.

1089
01:06:10,160 --> 01:06:11,150
And so people hustled,

1090
01:06:11,150 --> 01:06:13,700
people realize that boy, this is extremely damaging,

1091
01:06:13,700 --> 01:06:14,990
because now we're talking about is that

1092
01:06:15,110 --> 01:06:17,510
you know isolation has been broken, right.

1093
01:06:17,940 --> 01:06:21,060
You're gonna hardly, so basically hardly even think about it anymore,

1094
01:06:21,060 --> 01:06:26,430
but you know this thing, this is a technique for breaking page table protections,

1095
01:06:26,460 --> 01:06:30,390
which is you know how we enforce isolation between user and kernel,

1096
01:06:30,390 --> 01:06:33,840
it's like deeply fundamental attack,

1097
01:06:34,350 --> 01:06:39,060
or anyway undermines an extremely important piece of security,

1098
01:06:40,160 --> 01:06:41,330
in a very general way right,

1099
01:06:41,330 --> 01:06:42,410
seems like you could read anything.

1100
01:06:43,790 --> 01:06:47,600
And so people really really hustled, to a deploy fixes for this,

1101
01:06:47,600 --> 01:06:52,490
in the immediate fix that a lot of operating systems installed

1102
01:06:52,490 --> 01:06:56,730
within weeks of this paper coming out

1103
01:06:56,730 --> 01:06:59,400
and sometimes had already installed this thing called KASLR,

1104
01:07:00,180 --> 01:07:03,510
which is now called kpti in Linux,

1105
01:07:03,540 --> 01:07:06,060
and it's a pretty straightforward idea,

1106
01:07:06,330 --> 01:07:10,470
the idea is just like not to put the kernel mappings in the user page table,

1107
01:07:11,010 --> 01:07:15,030
and instead as in xv6,

1108
01:07:15,900 --> 01:07:18,540
switch page tables during system calls,

1109
01:07:18,540 --> 01:07:21,990
so user space just user mappings make a system call,

1110
01:07:22,020 --> 01:07:24,870
there's some kind of trampoline arrangement like in xv6,

1111
01:07:24,870 --> 01:07:29,190
and you switch page tables to a page table that has the kernel mappings

1112
01:07:29,190 --> 01:07:30,240
in order to execute the kernel.

1113
01:07:32,080 --> 01:07:34,780
And that causes attack cannot work,

1114
01:07:34,990 --> 01:07:41,210
because the, in that because you switch page tables,

1115
01:07:41,840 --> 01:07:45,470
this virtual address in r1,

1116
01:07:47,400 --> 01:07:51,780
it's not only no longer valid, it's no longer meaningful,

1117
01:07:51,990 --> 01:07:54,300
because there's no translation for it,

1118
01:07:55,080 --> 01:07:58,140
so the CPU doesn't know what to do with it,

1119
01:07:58,790 --> 01:08:00,950
like this virtual address won't be cached,

1120
01:08:01,250 --> 01:08:03,470
it's not even in the TLB,

1121
01:08:03,830 --> 01:08:05,600
so there's just no way for the kernel

1122
01:08:05,600 --> 01:08:08,930
to decide what memory corresponds to this virtual address.

1123
01:08:10,600 --> 01:08:12,670
You know when this attack is executed in user space,

1124
01:08:12,880 --> 01:08:15,670
because this virtual, this kernel virtual address no longer means anything,

1125
01:08:16,520 --> 01:08:19,520
it's not, it's not illegal, it's just meaningless,

1126
01:08:20,300 --> 01:08:22,550
and so that would cause the attack not to work.

1127
01:08:23,420 --> 01:08:26,870
The downside of this KASLR fixes,

1128
01:08:26,870 --> 01:08:30,110
that now system calls are more expensive, because switching page tables.

1129
01:08:32,610 --> 01:08:34,080
If you don't do anything,

1130
01:08:34,110 --> 01:08:37,680
switching page tables causes the TLB flushed,

1131
01:08:37,680 --> 01:08:41,430
because now all those virtual addresses and TLB are the wrong virtual addresses,

1132
01:08:41,430 --> 01:08:43,200
that don't correspond to this page table anymore,

1133
01:08:43,350 --> 01:08:45,510
and it causes the L1 cache to be flushed,

1134
01:08:45,510 --> 01:08:46,830
because it's virtually address

1135
01:08:47,340 --> 01:08:50,310
and so on on some machines,

1136
01:08:50,310 --> 01:08:54,160
the switching page tables made system calls considerably slower.

1137
01:08:56,820 --> 01:08:59,820
In an recent machines actually have this trick called PCID,

1138
01:08:59,820 --> 01:09:01,380
which you can look up,

1139
01:09:01,380 --> 01:09:02,160
but basically makes it,

1140
01:09:02,160 --> 01:09:05,610
so you can avoid flushing these caches on a page table switch,

1141
01:09:05,640 --> 01:09:06,930
although it still takes some time.

1142
01:09:07,920 --> 01:09:10,260
And if you poke around the web looking for people,

1143
01:09:10,260 --> 01:09:12,060
there was a lot of worry at the time,

1144
01:09:12,060 --> 01:09:17,310
that this split, that this two page table idea would be unacceptably slow,

1145
01:09:17,640 --> 01:09:21,390
now in fact, that didn't really turn out to be a serious problem,

1146
01:09:21,420 --> 01:09:22,320
and if you poke around,

1147
01:09:22,320 --> 01:09:26,130
you'll see that people's guesses about typical workloads,

1148
01:09:26,460 --> 01:09:29,880
you know how much it impacts overall performance of typical workloads,

1149
01:09:29,880 --> 01:09:34,950
which after all, don't spend all their time entering and exiting kernel, is like 5%,

1150
01:09:35,970 --> 01:09:37,770
so it wasn't such a bad deal.

1151
01:09:41,690 --> 01:09:45,940
Any questions about this KASLR fix?

1152
01:09:52,620 --> 01:09:54,930
So people adopted this pretty rapidly,

1153
01:09:55,260 --> 01:09:57,750
in fact there had been kernels that had already adopted it,

1154
01:09:57,750 --> 01:09:59,610
because it defended against some other attacks.

1155
01:10:02,200 --> 01:10:04,450
There's also a reasonable hardware fix,

1156
01:10:04,450 --> 01:10:08,230
that I believe Intel it's actually made in recent processors

1157
01:10:08,230 --> 01:10:09,730
and that AMD had already made,

1158
01:10:09,730 --> 01:10:17,540
and that's basically to because the, in fact, the permission,

1159
01:10:17,900 --> 01:10:20,480
you know this is the structure of the cache,

1160
01:10:20,480 --> 01:10:24,110
when an instruction loads something from the L1 cache,

1161
01:10:24,110 --> 01:10:26,300
like this kernel data, we're trying to attack,

1162
01:10:27,050 --> 01:10:32,810
the permissions or people believe that the permissions are sitting right there in the cache entry,

1163
01:10:33,050 --> 01:10:36,200
and so there's no trouble with the CPU checking the permissions at that point,

1164
01:10:36,290 --> 01:10:41,860
and indeed, AMD CPUs and perhaps modern Intel CPUs

1165
01:10:42,070 --> 01:10:43,930
will actually do the permission check very early

1166
01:10:43,930 --> 01:10:45,880
and won't return this data,

1167
01:10:46,120 --> 01:10:47,920
they won't even return it to the core,

1168
01:10:48,040 --> 01:10:49,780
if the permission checks don't workout.

1169
01:10:49,930 --> 01:10:55,810
So there's none of this speculative instructions are able to see forbidden data.

1170
01:10:57,120 --> 01:11:00,000
So I I don't know if you know the answer to this question

1171
01:11:00,000 --> 01:11:04,800
is probably just speculative, but no [] intended,

1172
01:11:04,830 --> 01:11:07,710
but why, why do you think Intel would do this,

1173
01:11:07,740 --> 01:11:08,820
like this seems like.

1174
01:11:09,120 --> 01:11:09,720
Okay.

1175
01:11:09,930 --> 01:11:12,210
Because to me, it seems like it was a discussion,

1176
01:11:12,210 --> 01:11:15,030
shall we check permissions on transient instructions

1177
01:11:15,030 --> 01:11:18,990
and they were just like know why, why bother will need just a simple check.

1178
01:11:19,740 --> 01:11:20,610
Why bother,

1179
01:11:20,790 --> 01:11:24,420
indeed stuff transparent and the users not be able to see the data either way,

1180
01:11:24,660 --> 01:11:26,220
during the check early.

1181
01:11:26,540 --> 01:11:30,290
You know that's like some gates on a pretty critical path, right,

1182
01:11:30,290 --> 01:11:34,830
the the you know the core of L1 data cache,

1183
01:11:35,340 --> 01:11:37,770
path is extremely performance critical,

1184
01:11:38,010 --> 01:11:40,890
you know if you can shave a few transistors off the,

1185
01:11:42,200 --> 01:11:43,910
you know off the critical path here,

1186
01:11:43,910 --> 01:11:46,640
between issuing instruction and getting the data back,

1187
01:11:46,880 --> 01:11:50,270
you know that may may allow you to have a slightly faster cycle time

1188
01:11:50,270 --> 01:11:51,770
and run programs faster.

1189
01:11:53,820 --> 01:11:55,080
And so it's got to be the case,

1190
01:11:55,080 --> 01:11:56,640
that I don't know got to be the case,

1191
01:11:56,640 --> 01:11:58,920
but it's easy to imagine that,

1192
01:11:58,920 --> 01:12:01,110
it would have cost them a few transistors

1193
01:12:01,380 --> 01:12:04,320
to actually enforce the permissions early,

1194
01:12:04,650 --> 01:12:08,310
because after all they still need all of the stuff at retirement,

1195
01:12:08,490 --> 01:12:11,880
it's not like doing it early would save them some work later on,

1196
01:12:12,030 --> 01:12:15,210
they still have to defer the fault until retirement.

1197
01:12:17,400 --> 01:12:18,750
So all that stuff, still there,

1198
01:12:19,750 --> 01:12:23,860
I'm just guessing that it didn't seem like it would have any advantages

1199
01:12:23,860 --> 01:12:26,620
and would have been a little bit of extra work.

1200
01:12:30,000 --> 01:12:32,460
And into either way completely invisible,

1201
01:12:33,030 --> 01:12:35,790
theoretically invisible too, at the architectural level.

1202
01:12:36,390 --> 01:12:41,700
Did any kernel decide to like revert this KASLR fix,

1203
01:12:41,700 --> 01:12:44,820
now that be like Intel has fixed the CPU,

1204
01:12:44,910 --> 01:12:47,250
do improve performance again.

1205
01:12:47,430 --> 01:12:49,200
I know it's optional on a lot of kernels,

1206
01:12:49,290 --> 01:12:55,750
I'm not totally sure what's going on with the Intel fix,

1207
01:12:55,870 --> 01:12:57,970
I'm fairly sure that they have this fix out there,

1208
01:12:57,970 --> 01:13:02,750
but exactly you know I I I don't really know what's going on.

1209
01:13:03,140 --> 01:13:04,220
I think in the Linux kernel,

1210
01:13:04,220 --> 01:13:07,370
you can just ask which hardware fixes have been implemented,

1211
01:13:07,370 --> 01:13:11,360
and Linux you know changes the [mitigation] that enables

1212
01:13:11,360 --> 01:13:13,280
depending on what actually the hardware tells it.

1213
01:13:14,840 --> 01:13:15,410
So might.

1214
01:13:15,410 --> 01:13:18,140
Oh so, so you can, you can actually do that,

1215
01:13:18,140 --> 01:13:21,170
like you can read enough info about the processor

1216
01:13:21,260 --> 01:13:23,750
as the kernel to know whether what to do.

1217
01:13:23,990 --> 01:13:25,940
You can run your run your laptop,

1218
01:13:25,940 --> 01:13:26,750
there's a Linux command,

1219
01:13:26,750 --> 01:13:31,420
that is actually yeah on like which is why it tells you,

1220
01:13:31,420 --> 01:13:34,990
exactly what fixes have been implemented where things are mitigated in hardware,

1221
01:13:36,040 --> 01:13:39,550
this is a wide range of these respective applications attacks.

1222
01:13:40,380 --> 01:13:43,170
Are you saying that Linux will actually use the combined page table,

1223
01:13:43,170 --> 01:13:44,220
if the CPU.

1224
01:13:45,360 --> 01:13:45,900
Cool.

1225
01:13:51,020 --> 01:13:52,940
I think it was, for 99%,

1226
01:13:52,940 --> 01:13:54,200
I haven't checked it recently,

1227
01:13:54,230 --> 01:13:56,450
I believe that's still the case.

1228
01:14:04,040 --> 01:14:06,080
Sorry, so what were people doing,

1229
01:14:06,110 --> 01:14:08,840
like like how did they find find this,

1230
01:14:08,990 --> 01:14:10,820
what are they trying to do.

1231
01:14:11,180 --> 01:14:12,560
What are they trying to do,

1232
01:14:12,860 --> 01:14:14,480
trying to break into computers.

1233
01:14:14,900 --> 01:14:20,980
Well, the, who knows what they're really trying to do,

1234
01:14:21,040 --> 01:14:25,570
I mean the papers are written by various academics,

1235
01:14:25,570 --> 01:14:32,300
maybe you know their research is finding security problems.

1236
01:14:32,390 --> 01:14:33,740
I think more that guys find,

1237
01:14:33,740 --> 01:14:36,020
that one thing the motive for a long time is,

1238
01:14:36,020 --> 01:14:38,990
they wanted to break address space randomization.

1239
01:14:40,020 --> 01:14:41,670
And they had earlier papers,

1240
01:14:41,670 --> 01:14:45,000
you know the different schemes trying to break address randomization,

1241
01:14:45,000 --> 01:14:47,700
so only one group of one stream of researchers

1242
01:14:47,700 --> 01:14:50,280
that were in this area had that as a background.

1243
01:14:50,860 --> 01:14:54,400
I think project zero people came from a completely different angle.

1244
01:15:00,170 --> 01:15:02,840
This is people have seen Robert said before,

1245
01:15:02,840 --> 01:15:04,850
people have been working in this area for decades,

1246
01:15:04,850 --> 01:15:11,610
you know trying find bugs they can exploit and understand.

1247
01:15:17,160 --> 01:15:20,730
So, I guess this, how this is a hard question to answer,

1248
01:15:20,730 --> 01:15:27,100
but like how likely is it that there's another like meltdown out there,

1249
01:15:27,100 --> 01:15:27,790
because it seems.

1250
01:15:27,790 --> 01:15:29,380
Extremely likely.

1251
01:15:29,560 --> 01:15:30,160
Okay,

1252
01:15:30,790 --> 01:15:35,530
like micro, the fundamentally like thing with micro-architecture like exposing changes.

1253
01:15:37,040 --> 01:15:39,920
That's right, I I think what's going on is that,

1254
01:15:39,920 --> 01:15:44,840
the CPU manufacturers have for decades and decades have been,

1255
01:15:45,490 --> 01:15:49,600
you know often adding more and more and more [optimistic],

1256
01:15:49,600 --> 01:15:52,750
there's many many many sort of cool little tricks

1257
01:15:52,750 --> 01:15:56,050
inside the micro-architecture for making things go faster,

1258
01:15:56,290 --> 01:16:02,050
and you know now and end people didn't worry that much

1259
01:16:02,050 --> 01:16:03,580
or it just wasn't on the radar,

1260
01:16:03,580 --> 01:16:06,880
that this could be a serious security problem,

1261
01:16:07,330 --> 01:16:09,820
and so now people now very aware that,

1262
01:16:09,820 --> 01:16:11,710
this stuff could be a serious security problem,

1263
01:16:11,740 --> 01:16:13,840
but we're now in a position where we're living

1264
01:16:13,840 --> 01:16:18,280
with you know thirty years of clever ideas inside the CPUs.

1265
01:16:18,640 --> 01:16:20,770
And so, indeed a bunch of,

1266
01:16:21,040 --> 01:16:22,450
since this paper came out,

1267
01:16:22,450 --> 01:16:23,950
and indeed before this paper came out,

1268
01:16:24,100 --> 01:16:25,300
a bunch of kind of,

1269
01:16:25,510 --> 01:16:30,310
a bunch of this style of attacks have come to light exploiting

1270
01:16:30,490 --> 01:16:38,110
various different micro-architectural these and CPUs,

1271
01:16:38,230 --> 01:16:40,330
so I think this is gonna be a while,

1272
01:16:40,330 --> 01:16:42,490
before this all laid to rest.

1273
01:16:42,760 --> 01:16:45,580
We've looked at security conferences in the last you know two years,

1274
01:16:45,580 --> 01:16:48,730
basically every year every conference basically session

1275
01:16:48,730 --> 01:16:53,370
on like exploiting speculative execution properties,

1276
01:16:53,460 --> 01:16:56,220
and see if they can make attacks work.

1277
01:16:57,210 --> 01:16:59,460
And maybe a larger question is whether,

1278
01:17:00,240 --> 01:17:01,800
you know whether the situation is,

1279
01:17:01,830 --> 01:17:06,390
well, you know there's you know 15 or 20 or 30 things,

1280
01:17:06,390 --> 01:17:08,700
that sort of have to be worked out,

1281
01:17:08,700 --> 01:17:10,380
and then we'll be done,

1282
01:17:11,470 --> 01:17:20,330
or whether there's some much higher levels approach gone wrong,

1283
01:17:20,360 --> 01:17:21,590
you know that we all,

1284
01:17:22,260 --> 01:17:23,970
this is probably way too pessimistic,

1285
01:17:23,970 --> 01:17:27,510
but people have a lot of faith in isolation as an idea,

1286
01:17:27,510 --> 01:17:29,460
that there's a totally reasonable thing to do,

1287
01:17:30,900 --> 01:17:33,450
assume that isolation works and will design stuff,

1288
01:17:33,450 --> 01:17:37,530
like cloud computing and running Javascript in the browser

1289
01:17:37,530 --> 01:17:38,970
and all this stuff under the assumption,

1290
01:17:39,000 --> 01:17:40,440
which is not actually true,

1291
01:17:40,440 --> 01:17:43,020
but it was close enough believed to be close enough to true,

1292
01:17:43,260 --> 01:17:47,520
that isolation will just you know cause they're not to be serious security problems,

1293
01:17:47,850 --> 01:17:50,690
and that's actually probably still doable,

1294
01:17:50,900 --> 01:17:55,540
but this whole [] of micro-architectural attacks

1295
01:17:56,390 --> 01:17:59,750
not made that story seem more convincing, that's for sure.

1296
01:18:02,400 --> 01:18:04,020
Just to add on to that,

1297
01:18:04,410 --> 01:18:09,630
I'm not sure a [] levels expertise would like CPU design,

1298
01:18:09,630 --> 01:18:18,210
but to what extent can CPU design be made straightforwardly without a micro-architecture,

1299
01:18:18,390 --> 01:18:21,810
while still preserving its high performance.

1300
01:18:21,990 --> 01:18:25,240
Performance, I mean, people believe this stuff.

1301
01:18:25,480 --> 01:18:27,970
Nicely security too, but yeah.

1302
01:18:28,060 --> 01:18:29,620
Well, some of this clearly can be fixed,

1303
01:18:29,620 --> 01:18:30,670
like this meltdown thing,

1304
01:18:30,670 --> 01:18:34,780
I mean there is a fix this you actually check the permissions,

1305
01:18:35,230 --> 01:18:39,010
that probably doesn't sacrifice any performance,

1306
01:18:39,220 --> 01:18:40,870
for some of the other attacks that have come up,

1307
01:18:43,590 --> 01:18:46,710
it's not clear that you could fix them without sacrificing performance,

1308
01:18:46,770 --> 01:18:48,090
I mean some of this very very deep,

1309
01:18:48,090 --> 01:18:49,860
like the fact that we're sharing

1310
01:18:50,130 --> 01:18:53,870
you know, this there's a lot of sharing,

1311
01:18:53,870 --> 01:18:55,850
like a time sharing a cloud environment,

1312
01:18:55,850 --> 01:18:57,050
there's just a lot of sharing,

1313
01:18:57,290 --> 01:19:06,890
and so, for example suppose there's a disk drive or a network on your cloud server, right,

1314
01:19:07,400 --> 01:19:11,240
gosh, you might be able to get information about the other people on that cloud server,

1315
01:19:11,450 --> 01:19:13,880
simply by watching how their traffic

1316
01:19:13,880 --> 01:19:18,140
interferes with your traffic disk traffic or network traffic or memory traffic or something.

1317
01:19:18,290 --> 01:19:19,460
So there's some sort of,

1318
01:19:20,240 --> 01:19:20,990
I, you know I don't know,

1319
01:19:20,990 --> 01:19:21,770
but that's practical,

1320
01:19:21,770 --> 01:19:24,890
maybe it's not although you know for many many things

1321
01:19:24,890 --> 01:19:25,940
in which people said point that

1322
01:19:25,940 --> 01:19:27,590
attack just doesn't seem to be practical,

1323
01:19:27,920 --> 01:19:30,540
you know it turned out to be practical enough.

1324
01:19:32,170 --> 01:19:33,460
And I think.

1325
01:19:34,690 --> 01:19:36,790
And so a lot of this micro-architectural stuff,

1326
01:19:36,790 --> 01:19:38,860
maybe could be cleaned up without performance loss,

1327
01:19:38,860 --> 01:19:41,050
or maybe can't be cleaned up without performance loss,

1328
01:19:41,350 --> 01:19:42,730
but I think it's,

1329
01:19:43,750 --> 01:19:48,450
I think it's a much more serious problem than just we're gonna applies fixes,

1330
01:19:50,260 --> 01:19:51,130
they'll go away.

1331
01:19:52,650 --> 01:19:55,710
And the place is the most acute is cryptography,

1332
01:19:55,950 --> 01:19:58,350
there's been many many years of

1333
01:19:58,880 --> 01:20:01,220
people looking into these kind of clever,

1334
01:20:02,210 --> 01:20:10,440
often cache timing based ways of sensing bit set of keys

1335
01:20:10,440 --> 01:20:12,510
and other people's cryptographic,

1336
01:20:12,930 --> 01:20:17,100
people running running at cryptographic encryption on the same machine as you,

1337
01:20:17,580 --> 01:20:20,250
can you guess anything about my key

1338
01:20:20,250 --> 01:20:24,130
by watching, by doing cache timing,

1339
01:20:24,490 --> 01:20:25,810
answer is absolutely.

1340
01:20:26,530 --> 01:20:29,140
And it's not a micro-architectural bugs,

1341
01:20:32,010 --> 01:20:34,950
it's just a consequence of sharing often.

1342
01:20:35,620 --> 01:20:37,210
Anyway I don't know how this is gonna play out,

1343
01:20:37,210 --> 01:20:38,800
but it's not it's not straightforward.

1344
01:20:40,610 --> 01:20:42,230
I mean this curious part is,

1345
01:20:42,230 --> 01:20:44,480
when people made progress on,

1346
01:20:44,810 --> 01:20:49,880
just measuring the like EM radiation from a CPU

1347
01:20:49,880 --> 01:20:53,000
and figuring out what instructions are run and what data is in it,

1348
01:20:53,270 --> 01:20:55,910
with machine learning with like some accuracy,

1349
01:20:55,910 --> 01:20:58,100
you know not a hundred percent, not nearly,

1350
01:20:58,100 --> 01:21:01,100
but like a scary amount of accuracy,

1351
01:21:01,100 --> 01:21:02,870
because anything over zero is scary.

1352
01:21:07,840 --> 01:21:09,940
Yeah, we all live in you know that's all,

1353
01:21:12,180 --> 01:21:14,970
well, there's a boundary between attacks that are,

1354
01:21:17,430 --> 01:21:20,520
there's some threshold between the attacks that are possible,

1355
01:21:20,520 --> 01:21:23,760
but you know gosh just seems like that would be too expensive

1356
01:21:23,760 --> 01:21:27,150
or awkward painful whatever complex to carry out.

1357
01:21:28,270 --> 01:21:31,220
And, attacks really could be carried out,

1358
01:21:31,220 --> 01:21:33,260
of course we only should defend against the second class,

1359
01:21:33,260 --> 01:21:36,230
because the first class is often too expensive to defend against,

1360
01:21:36,620 --> 01:21:40,430
but as the value of stuff containing computers gets larger,

1361
01:21:40,430 --> 01:21:46,220
and attackers get more clever get more closer access to shared environments,

1362
01:21:47,000 --> 01:21:53,590
kind of threshold by which attacks are feasible enough to defend against changes.

1363
01:21:58,610 --> 01:22:03,080
Alright, I'm done with the lecture,

1364
01:22:03,080 --> 01:22:06,110
I'm happy to take more questions, if people have.

1365
01:22:09,210 --> 01:22:09,930
Thank you.

1366
01:22:11,280 --> 01:22:11,880
Thank you.

1367
01:22:12,750 --> 01:22:15,360
Thanks, I actually had a question about the cache,

1368
01:22:15,600 --> 01:22:21,090
so the L1 cache is its per CPU, right.

1369
01:22:21,930 --> 01:22:22,530
Yes.

1370
01:22:23,430 --> 01:22:25,080
And L2 isn't shared.

1371
01:22:25,260 --> 01:22:28,980
Well, so this picture is different for each CPU,

1372
01:22:28,980 --> 01:22:31,680
for different models of CPU, etc,

1373
01:22:31,740 --> 01:22:35,870
the the habit today is

1374
01:22:35,900 --> 01:22:40,040
looks it's a little bit more complex than this,

1375
01:22:40,160 --> 01:22:42,080
typically a multiple cores,

1376
01:22:43,170 --> 01:22:46,230
2 4 8 or 64 something,

1377
01:22:46,980 --> 01:22:48,990
each one has a L1 cache,

1378
01:22:48,990 --> 01:22:50,700
that's quite close to the CPU,

1379
01:22:50,700 --> 01:22:52,830
but it's small fast and small,

1380
01:22:53,130 --> 01:22:55,620
each core typically also has a bigger L2 cache,

1381
01:22:55,620 --> 01:23:01,310
this you know it's sort of dedicated to that CPU.

1382
01:23:04,150 --> 01:23:12,930
And then, and then there's often a shared L3 cache,

1383
01:23:13,170 --> 01:23:14,580
often but not always,

1384
01:23:14,760 --> 01:23:18,710
and another approach is to make the summation of the L2 cache

1385
01:23:18,710 --> 01:23:22,430
is sort of convenient for all the CPUs to use,

1386
01:23:22,430 --> 01:23:25,280
so that I have super high speed access to my L2 cache,

1387
01:23:25,280 --> 01:23:28,850
but I can get at other people said a slightly bigger [penalties],

1388
01:23:28,850 --> 01:23:30,650
the effective cache size larger,

1389
01:23:30,740 --> 01:23:33,440
so often three see either three level caches

1390
01:23:33,440 --> 01:23:37,850
or or a sort of joint to second level caches.

1391
01:23:41,000 --> 01:23:45,160
And typically the L2 and L3 are physically addressed, L1 is virtual.

1392
01:23:47,980 --> 01:23:54,830
Sorry, so what's the point of having physically address, yeah, yeah it's.

1393
01:23:54,830 --> 01:23:59,810
Yeah, it's easy, the stuff in L1 cache, a virtual address cache.

1394
01:24:02,220 --> 01:24:05,850
If the same data is used with different virtual addresses,

1395
01:24:05,850 --> 01:24:09,510
you can't you know the virtual address cache doesn't help you find it,

1396
01:24:10,060 --> 01:24:13,660
if it was cache under a different address where these L2 caches,

1397
01:24:13,660 --> 01:24:14,920
the data is independent,

1398
01:24:15,130 --> 01:24:18,880
is usable no matter what virtual address you address it and.

1399
01:24:22,380 --> 01:24:24,330
Where does the MMU use,

1400
01:24:24,330 --> 01:24:27,180
it relative to all these caches in the TLB.

1401
01:24:27,210 --> 01:24:30,180
Oh, it's not it's distributed really,

1402
01:24:30,180 --> 01:24:33,570
because the I mean the most obvious,

1403
01:24:34,530 --> 01:24:37,500
I mean I think in real life,

1404
01:24:38,930 --> 01:24:42,050
the TLB the most critical thing is that TLB,

1405
01:24:42,050 --> 01:24:45,200
and I believe it's indexed in parallel with the L1 cache typically.

1406
01:24:46,300 --> 01:24:47,710
So if you hit in the cache,

1407
01:24:47,920 --> 01:24:50,350
the L1 cache great, although there may be a.

1408
01:24:52,740 --> 01:24:54,300
Anyway, and if you miss the L1 cache,

1409
01:24:54,300 --> 01:24:56,220
then now you have the physical,

1410
01:24:56,220 --> 01:24:57,990
you were looking up in that TLB at the same time,

1411
01:24:57,990 --> 01:25:00,000
now your physical can addressed,

1412
01:25:01,550 --> 01:25:05,690
the MMU that was not just a single box that sits somewhere,

1413
01:25:05,690 --> 01:25:08,350
it's actually kind of involved.

1414
01:25:09,890 --> 01:25:12,080
Okay, but isn't it hardware, so.

1415
01:25:12,230 --> 01:25:13,730
Oh, everything is yours hardware, yeah.

1416
01:25:15,530 --> 01:25:20,480
But remember these you know these chips have billions of transistors on them,

1417
01:25:20,630 --> 01:25:22,610
so yeah, maybe it's hardware,

1418
01:25:22,610 --> 01:25:26,900
but we're talking about massively complex hardware,

1419
01:25:27,140 --> 01:25:31,700
that's designed using very sophisticated software like design techniques,

1420
01:25:31,730 --> 01:25:36,150
so that it can do very very complex and sophisticated things,

1421
01:25:36,510 --> 01:25:37,410
so yeah, it's hardware,

1422
01:25:37,410 --> 01:25:41,660
but, yeah, it's not at all at all straightforward.

1423
01:25:43,320 --> 01:25:49,800
So do table mapping like page table mappings ever end up in the caches at all,

1424
01:25:49,800 --> 01:25:52,260
or are they always just routed through that TLB,

1425
01:25:52,290 --> 01:25:53,400
because if you miss it,

1426
01:25:53,400 --> 01:25:55,890
that TLB you have to go to memory retrieve.

1427
01:25:55,890 --> 01:25:59,640
That right, so they're certainly the L2 cache will hold,

1428
01:26:00,790 --> 01:26:02,770
from the point of view the L2 cache,

1429
01:26:03,190 --> 01:26:07,070
TLB misses, TLB reloads are just memory accesses,

1430
01:26:07,070 --> 01:26:09,560
so that TLB needs to load a bunch of page table junk,

1431
01:26:09,860 --> 01:26:11,240
it's just a memory load,

1432
01:26:11,240 --> 01:26:13,970
and it could use, stuff could easily be cached in the L2.

1433
01:26:13,970 --> 01:26:15,140
But it has to skip to L1,

1434
01:26:15,140 --> 01:26:17,180
because L1 has virtual addresses, but.

1435
01:26:17,180 --> 01:26:21,200
I don't think that TLB would consult the L1 for its.

1436
01:26:21,200 --> 01:26:21,560
Okay.

1437
01:26:22,510 --> 01:26:24,700
Because it's virtual addresses.

1438
01:26:25,980 --> 01:26:29,070
And then one thing about the spectre attack.

1439
01:26:30,110 --> 01:26:32,510
How would you, I,

1440
01:26:32,540 --> 01:26:37,190
so so the thing is like I've heard about meltdown inspector like at least a dozen times,

1441
01:26:37,190 --> 01:26:39,710
and every time I looked it up I would not understand it,

1442
01:26:39,710 --> 01:26:42,230
so this is the first time I actually understand what's going on,

1443
01:26:42,410 --> 01:26:44,030
but for spectre,

1444
01:26:44,150 --> 01:26:47,970
is there, like how similar is it to meltdown?

1445
01:26:47,970 --> 01:26:48,600
It's not.

1446
01:26:48,840 --> 01:26:50,430
It's not, okay.

1447
01:26:52,230 --> 01:26:53,970
Or, that they will,

1448
01:26:55,560 --> 01:26:59,700
my understanding the spectre attack is by training the branch predictor,

1449
01:26:59,730 --> 01:27:05,880
that you know the other code that you're trying to get attack stuff from.

1450
01:27:05,910 --> 01:27:11,060
Let's suppose it's another process you share some memory with it, right.

1451
01:27:11,060 --> 01:27:14,180
Yeah, because you're it's really the same program as you,

1452
01:27:14,180 --> 01:27:17,090
but it's some other user running the program, right.

1453
01:27:18,040 --> 01:27:29,920
You can, the branch, the branch, the tables the branch predictor uses are shared between different,

1454
01:27:29,920 --> 01:27:31,420
if I run a CPU [],

1455
01:27:31,420 --> 01:27:34,390
that you run or maybe run on different hyper threads of the same CPU,

1456
01:27:34,390 --> 01:27:37,990
everybody sees the same branch sees the same branch predictor,

1457
01:27:38,020 --> 01:27:41,350
so I can train the branch predictor to predict branches in a certain way,

1458
01:27:41,590 --> 01:27:42,970
and then I'll let you run,

1459
01:27:44,230 --> 01:27:47,890
you're running with my branch predictor training, right,

1460
01:27:47,890 --> 01:27:50,470
and so that means I can essentially trick your program

1461
01:27:50,470 --> 01:27:53,980
into speculatively executing instructions of my choice.

1462
01:27:54,790 --> 01:27:55,840
Right, now it's only speculative,

1463
01:27:55,840 --> 01:27:56,830
so of course they'll be undone,

1464
01:27:56,830 --> 01:28:00,370
but they they will cause cache loads,

1465
01:28:00,880 --> 01:28:03,580
that to some extent I can control.

1466
01:28:04,180 --> 01:28:05,920
Because I control how you speculatively execute,

1467
01:28:05,920 --> 01:28:07,000
and then if we share memory,

1468
01:28:07,000 --> 01:28:09,340
I can use flush and reload to sense

1469
01:28:09,930 --> 01:28:13,890
what cache lines your program loaded this speculative execution.

1470
01:28:15,390 --> 01:28:16,890
Oh, so in that case,

1471
01:28:16,890 --> 01:28:20,130
you don't need to, you don't need to,

1472
01:28:20,130 --> 01:28:24,750
like know like directly address address a piece of memory,

1473
01:28:24,750 --> 01:28:28,590
you just need to make sure that program will specularly executed,

1474
01:28:28,740 --> 01:28:31,020
like in meltdown, we did it ourselves,

1475
01:28:31,020 --> 01:28:34,200
but in spectre just directed there,

1476
01:28:34,590 --> 01:28:35,340
that's kind of cool,

1477
01:28:35,370 --> 01:28:36,090
because you can just say,

1478
01:28:36,090 --> 01:28:40,080
oh you know just go and load that secret by training the branch predictor,

1479
01:28:40,080 --> 01:28:41,610
without knowing where the secret is,

1480
01:28:42,300 --> 01:28:43,650
like you gotta know someone,

1481
01:28:43,740 --> 01:28:45,510
yeah you kind of have to know.

1482
01:28:45,510 --> 01:28:47,160
You need to know great [] and great detail.

1483
01:28:47,160 --> 01:28:49,170
Yeah sorry, you have to know.

1484
01:28:49,350 --> 01:28:51,030
But you have to yourself.

1485
01:28:51,060 --> 01:28:51,390
Yes.

1486
01:28:51,390 --> 01:28:52,200
That's not secret,

1487
01:28:52,200 --> 01:28:53,580
you're probably running a program that,

1488
01:28:54,000 --> 01:28:55,140
I know what program you're running.

1489
01:28:55,140 --> 01:28:59,380
Yeah, okay, that makes sense, thank you.

1490
01:29:01,700 --> 01:29:02,990
Yeah, I was just wondering,

1491
01:29:02,990 --> 01:29:06,830
it seems like when you when a research paper, like this gets released,

1492
01:29:06,830 --> 01:29:09,200
it's out there for like people,

1493
01:29:09,200 --> 01:29:12,200
Linux and Windows and like Intel for them

1494
01:29:12,200 --> 01:29:14,750
to try to go and scramble to patch the bug,

1495
01:29:14,750 --> 01:29:17,900
but it's also out there for hackers can start to learn from the paper,

1496
01:29:17,900 --> 01:29:19,640
like oh this is a method we could use,

1497
01:29:20,190 --> 01:29:22,740
and I'm I'm wondering,

1498
01:29:22,740 --> 01:29:25,470
like it as a researcher is there a general practice

1499
01:29:25,470 --> 01:29:27,510
of like as we're working on the paper

1500
01:29:27,510 --> 01:29:31,170
will sort of tipoff the quote unquote good guys first,

1501
01:29:31,170 --> 01:29:32,040
so that they can have.

1502
01:29:32,040 --> 01:29:37,380
Yeah, authors informed every you know the CPU manufacturers and OS manufacturers

1503
01:29:37,380 --> 01:29:38,550
before they publish the paper.

1504
01:29:39,030 --> 01:29:40,830
There's a whole, there's a whole protocol,

1505
01:29:41,460 --> 01:29:44,520
you know these kind of things would even be accepted anymore,

1506
01:29:44,520 --> 01:29:46,020
unless you follow the protocol.

1507
01:29:46,650 --> 01:29:48,660
That doesn't mean the attackers weren't already using it, right,

1508
01:29:48,660 --> 01:29:52,650
because you probably know the attackers discovered this twenty years ago, but.

1509
01:29:53,070 --> 01:29:56,430
Great, thank you.

1510
01:29:57,480 --> 01:29:59,280
It's not straightforward,

1511
01:29:59,370 --> 01:30:00,810
I think in this particular case,

1512
01:30:00,810 --> 01:30:04,290
I think you know what some Intel was not too excited about,

1513
01:30:05,020 --> 01:30:08,530
the collaboration between the Linux community and Intel was not completely smooth, I think.

1514
01:30:10,940 --> 01:30:11,870
When this happened,

1515
01:30:12,530 --> 01:30:14,690
I think they worked at some of the case, but.

1516
01:30:18,670 --> 01:30:19,990
I think it was kind of scary,

1517
01:30:19,990 --> 01:30:22,600
because I I read on Wikipedia,

1518
01:30:22,600 --> 01:30:28,570
that the Ubuntu fix was published after the paper was published,

1519
01:30:28,600 --> 01:30:31,030
which I found scary, but.

1520
01:30:38,120 --> 01:30:40,490
Thank you so much.

1521
01:30:42,240 --> 01:30:42,960
Thank you.

1522
01:30:43,170 --> 01:30:45,660
Thank you, well see you next week.

