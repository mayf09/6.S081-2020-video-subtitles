1
00:00:00,000 --> 00:00:02,430
声音检查，大家能听到我说话吗？

2
00:00:04,690 --> 00:00:07,330
是的。是的。好的。

3
00:00:07,780 --> 00:00:11,830
好的，欢迎收听 6.S081 的下一节课，

4
00:00:11,860 --> 00:00:18,850
无论你在哪里，特别是，我希望西海岸，佛罗里达和阿拉巴马的人们都还好，

5
00:00:18,910 --> 00:00:21,790
你知道那边的情况很糟糕。

6
00:00:24,140 --> 00:00:28,280
所以今天的主题是虚拟内存，

7
00:00:28,310 --> 00:00:30,530
特别地，我们会讨论页表，

8
00:00:30,560 --> 00:00:33,350
我们会多次回到这个主题，

9
00:00:33,350 --> 00:00:35,150
会有多次关于这个的讲座。

10
00:00:36,030 --> 00:00:41,310
或许我们可以再次从回答问题开始，

11
00:00:42,130 --> 00:00:51,280
我的问题是，通过 6.004 或 6.033 课程，你对虚拟内存有什么印象。

12
00:00:51,880 --> 00:00:55,330
我会先说一下自己对虚拟内存的看法，

13
00:00:55,330 --> 00:00:59,020
当我第一次学习它，还是一个学生的时候，

14
00:00:59,230 --> 00:01:01,990
我想它是很直接的，能有多难，

15
00:01:01,990 --> 00:01:05,470
就是一个表将虚拟地址映射到物理地址。

16
00:01:05,880 --> 00:01:10,320
或许有点复杂，但不是那么复杂，

17
00:01:10,530 --> 00:01:20,690
只有当用它编程时，我才知道虚拟内存是巧妙的，迷人的，非常强大。

18
00:01:21,430 --> 00:01:30,610
所以我希望在后面的课程和实验中，你们能从这个角度理解虚拟内存。

19
00:01:30,760 --> 00:01:33,790
我们会对在线的一些人进行提问，

20
00:01:33,790 --> 00:01:39,820
通过 6.004 或 6.033 课程，你对虚拟内存有什么印象。

21
00:01:40,340 --> 00:01:47,070
同样，我会点名，然后你分享自己的印象。

22
00:01:47,100 --> 00:01:48,240
Adela Yang.

23
00:01:53,360 --> 00:01:54,500
不好意思，问题是什么？

24
00:01:54,950 --> 00:02:01,220
通过 6.004 或 6.033 课程，你对虚拟内存有什么印象。

25
00:02:02,020 --> 00:02:10,150
它使用偏移来保存虚拟地址到物理地址的映射。

26
00:02:11,650 --> 00:02:15,190
好的， Abraham Caldera 。

27
00:02:20,040 --> 00:02:21,600
Abraham ，你在线吗？

28
00:02:23,230 --> 00:02:33,790
是的，我的印象是，它使用了一种[间接]表示的方法来保护物理硬件，

29
00:02:34,480 --> 00:02:47,030
还有，使用 44 位的虚拟地址映射到 64 位的物理地址。

30
00:02:48,100 --> 00:02:53,300
好的， Bibic Pendant 。

31
00:02:56,750 --> 00:03:04,160
我的印象是每个进程可以有独立的地址空间，

32
00:03:04,620 --> 00:03:10,120
还有，内存管理单元或者其他技术

33
00:03:10,120 --> 00:03:19,210
可以用来映射每个进程虚拟空间的虚拟地址到物理地址。

34
00:03:20,040 --> 00:03:25,920
而且虚拟地址的低位是相同的，

35
00:03:25,920 --> 00:03:31,950
所以，映射是以块位单位的，这能够提高性能。

36
00:03:33,880 --> 00:03:35,470
Wiseley Wu.

37
00:03:39,580 --> 00:03:43,390
是的，我印象最深的是

38
00:03:43,390 --> 00:03:51,150
虚拟地址允许我们保护每个进程的物理地址，

39
00:03:51,630 --> 00:03:54,870
而且我们可以使用一些巧妙的操作，

40
00:03:54,870 --> 00:04:00,780
让物理地址上对应的位也可以在虚拟地址上使用。

41
00:04:02,600 --> 00:04:05,150
Wilson Spearmen, Spearmen.

42
00:04:09,040 --> 00:04:11,950
是的，我的印象是它是隔离的基础，

43
00:04:11,950 --> 00:04:18,520
因为每个进程可以假装有自己的内存可以使用。

44
00:04:20,470 --> 00:04:27,220
好的，显然这是很好的，这里有两个主题，

45
00:04:27,220 --> 00:04:32,950
一个是这里有某种形式的映射，这种映射可以帮助实现隔离，

46
00:04:33,670 --> 00:04:38,320
这就是我们讨论虚拟内存的原因，因为隔离。

47
00:04:38,850 --> 00:04:43,560
所以我们在接下来的课程中会看到，

48
00:04:43,560 --> 00:04:45,690
特别是当你使用虚拟内存编程时，

49
00:04:45,930 --> 00:04:50,250
会真正深刻理解它的能力。

50
00:04:50,780 --> 00:04:52,790
所以，为了让理解它，

51
00:04:52,790 --> 00:04:59,330
这是第一节课，主要讨论虚拟内存的机制，

52
00:04:59,390 --> 00:05:03,680
然后，我们可以看到，使用这些机制来获得很酷的技巧。

53
00:05:04,670 --> 00:05:10,160
所以今天的主题是，计划分为三部分。

54
00:05:10,810 --> 00:05:13,150
首先，我要讲的是地址空间，

55
00:05:13,180 --> 00:05:22,090
就是你们中一些人刚才在回答问题中提到的。

56
00:05:22,420 --> 00:05:25,900
我还要讲的是页式硬件，

57
00:05:27,020 --> 00:05:30,470
当然，主要是 RISC-V 的页式硬件，

58
00:05:31,390 --> 00:05:38,740
但是基本上所有现代处理器都有某种形式的页式硬件，

59
00:05:38,770 --> 00:05:45,550
它是支持虚拟内存的默认机制。

60
00:05:46,270 --> 00:05:53,950
然后，本节课的最后一个部分，是查看一些 xv6 虚拟内存代码，

61
00:05:54,280 --> 00:06:01,850
以及内核地址空间和用户地址空间的布局。

62
00:06:02,700 --> 00:06:04,350
所以这是主要计划。

63
00:06:08,260 --> 00:06:14,230
好的，我们回答了，记得你们回答这个问题提到的，

64
00:06:14,380 --> 00:06:21,820
使用虚拟内存的一个原因是可以获得隔离，

65
00:06:22,000 --> 00:06:25,420
如果你正确设置页表，正确使用它们编程，

66
00:06:25,570 --> 00:06:28,270
理论上你就可以获得强隔离。

67
00:06:29,020 --> 00:06:33,100
这再次提醒我们，我们想从隔离获得什么，

68
00:06:33,100 --> 00:06:35,380
我们来看我们的标准图片，

69
00:06:35,380 --> 00:06:42,640
我们有一些用户程序，比如 shell cat 和所有你在实验一中构建的实用程序，

70
00:06:42,940 --> 00:06:50,700
在下面，我们有内核，操作系统在内核空间中。

71
00:06:51,300 --> 00:07:00,010
我们要做的是把这些应用程序圈起来，

72
00:07:00,010 --> 00:07:02,170
让它们不会互相影响，

73
00:07:02,260 --> 00:07:08,680
同样的，我们希望内核或操作系统完全独立，

74
00:07:08,680 --> 00:07:13,330
如果一个应用程序因为意外或故意做了一些坏事情，

75
00:07:13,600 --> 00:07:15,670
它不会影响到操作系统，

76
00:07:16,580 --> 00:07:17,570
这是我们的目标。

77
00:07:17,900 --> 00:07:25,130
我们今天关注的这个问题的[特定方面]，是内存相关的东西，

78
00:07:25,190 --> 00:07:27,890
我们关注的是内存隔离。

79
00:07:29,930 --> 00:07:35,690
默认情况下，如果我们不做任何事情，我们不会有内存隔离，

80
00:07:35,690 --> 00:07:41,120
因为你想一下，只有一个 RISC-V 电路板，上周我展示的那个，

81
00:07:41,120 --> 00:07:44,060
它包含内存，很多 DRAM 芯片，

82
00:07:44,650 --> 00:07:50,980
在 DRAM 芯片中，保存着应用程序的代码，

83
00:07:51,610 --> 00:07:56,230
比如内存中某处是内核，文本，数据，栈，任何东西，

84
00:07:56,560 --> 00:07:59,500
如果 shell 在运行，内存中某处是 shell ，

85
00:07:59,970 --> 00:08:02,490
还有，内存中某处是 cat 程序。

86
00:08:04,640 --> 00:08:11,000
这里有一个物理内存，从 0 到一个很大的地址，

87
00:08:11,240 --> 00:08:14,030
取决于我们的机器上有多少内存，

88
00:08:14,090 --> 00:08:17,000
在物理内存中，所有程序都必须存在，

89
00:08:17,420 --> 00:08:21,230
否则处理器甚至不能执行它们的指令。

90
00:08:22,360 --> 00:08:24,670
这里很明显有个风险是，

91
00:08:24,820 --> 00:08:28,270
比如说，让我们简化一下，

92
00:08:28,270 --> 00:08:36,710
比如 shell 位于地址 0 到 200 （不是）， 2000 ， 1000 到 2000 ，

93
00:08:37,720 --> 00:08:42,550
比如 cat 有一个程序错误，

94
00:08:42,550 --> 00:08:53,120
它加载 1000 到寄存器 a0 ，而 1000 是 shell 开始的地址，

95
00:08:53,420 --> 00:09:01,460
然后，意外的，它执行了 sd 指令 $7 a0 ，

96
00:09:02,980 --> 00:09:08,110
这条指令的效果是把 7 写到地址 1000 ，

97
00:09:08,110 --> 00:09:14,050
它会修改属于 shell 的内存镜像，

98
00:09:14,830 --> 00:09:21,550
所以，现在我们打破了隔离，这是我们不想要的。

99
00:09:22,360 --> 00:09:27,880
所以我们希望在不同程序之间真正隔离这些内存，

100
00:09:27,880 --> 00:09:29,770
让这种事情不会发生。

101
00:09:31,590 --> 00:09:37,950
解决这个问题的一种方法是，地址空间。

102
00:09:44,500 --> 00:09:53,890
它的基本思想很简单，我们给每个程序包括内核分配自己的地址空间。

103
00:09:55,090 --> 00:09:57,040
我们可以考虑这个例子，

104
00:09:57,040 --> 00:10:03,690
我们运行 cat ，它有地址空间从 0 到某个最大值，

105
00:10:04,350 --> 00:10:11,370
shell 有自己的地址空间，也是从 0 到某个值，

106
00:10:11,520 --> 00:10:16,520
内核有自己的地址空间，操作系统有自己的地址空间。

107
00:10:17,640 --> 00:10:25,980
所以，当 cat ，我们回到上一张讲稿中的例子，

108
00:10:25,980 --> 00:10:30,360
保存 7 到 a0 。

109
00:10:30,950 --> 00:10:34,970
比如 a0 的值是 1000 ，

110
00:10:34,970 --> 00:10:40,700
如果 cat 执行这条指令，会写入地址 1000 ，

111
00:10:40,700 --> 00:10:46,100
但是这是它自己的地址 1000 ，而不是 shell 的地址 1000 。

112
00:10:46,400 --> 00:10:49,880
所以，每个程序在自己的地址空间运行，

113
00:10:50,060 --> 00:10:53,960
有它自己的值，并且这些地址都是完全独立的。

114
00:10:54,360 --> 00:10:57,540
在这种不同地址空间的概念下，

115
00:10:57,570 --> 00:11:03,480
cat 甚至不能访问属于 shell 的地址。

116
00:11:04,900 --> 00:11:10,270
所以这是我们要达成的目标，

117
00:11:10,300 --> 00:11:12,370
因为它会给我们提供强隔离，

118
00:11:12,370 --> 00:11:17,860
因为 cat 想访问其他不是它的内存是不能的。

119
00:11:19,080 --> 00:11:29,190
所以，我们现在的目标是复用所有不同的地址空间在一个物理内存上，

120
00:11:29,190 --> 00:11:31,920
因为根本上，我们只有一些 DRAM 芯片，

121
00:11:32,220 --> 00:11:35,430
你知道，内存位于 RAM 芯片上。

122
00:11:36,930 --> 00:11:41,830
所以，我的计划是。

123
00:11:41,830 --> 00:11:43,990
好的， Amiar ，你有一个问题，请继续。

124
00:11:46,260 --> 00:11:53,760
是的，我想知道，在物理硬件配置中，只有这么多空间，

125
00:11:54,180 --> 00:11:58,800
而在虚拟内存布局中，也有一个最大虚拟地址，

126
00:11:59,250 --> 00:12:03,990
从设计上来说，虚拟地址是否要足够小。

127
00:12:04,510 --> 00:12:06,910
不，不需要，

128
00:12:06,910 --> 00:12:10,000
虚拟地址空间可以比物理内存大，

129
00:12:10,000 --> 00:12:13,180
物理内存也可以比虚拟地址空间大，

130
00:12:13,180 --> 00:12:14,980
我们等一下会看到这是如何发生的，

131
00:12:15,130 --> 00:12:21,100
我们会看到，这是页表很酷的部分之一，它非常灵活。

132
00:12:22,110 --> 00:12:27,630
那么，物理内存可能耗尽吗，

133
00:12:28,280 --> 00:12:31,910
因为很多进程使用它们的虚拟（地址）空间。

134
00:12:31,940 --> 00:12:35,750
是的，完全可能，我们等一会会看到，

135
00:12:35,750 --> 00:12:38,570
比如你有许多大的应用程序，

136
00:12:38,570 --> 00:12:41,570
每个程序都有一个大页表，它们分配了很多内存，

137
00:12:41,570 --> 00:12:42,890
在某个时刻，内存就会用完。

138
00:12:43,920 --> 00:12:44,760
我明白了，谢谢。

139
00:12:44,760 --> 00:12:48,840
那么，这个在 xv6 中哪里出现了，有人知道吗？

140
00:12:52,530 --> 00:12:58,370
你肯定在现在做的 syscall 实验中碰到了。

141
00:13:01,310 --> 00:13:02,630
分配页面在哪里。

142
00:13:08,660 --> 00:13:13,010
或者，如果你完成了 syscall 实验的第一部分，

143
00:13:13,010 --> 00:13:15,230
打印空闲内存地址数量。

144
00:13:17,720 --> 00:13:18,140
kalloc?

145
00:13:18,140 --> 00:13:22,130
是的， kalloc ， kalloc 有一个空闲页面列表，

146
00:13:22,400 --> 00:13:25,910
如果空闲页面列表在某个时刻是空的，

147
00:13:26,120 --> 00:13:28,940
那么 kalloc 会返回一个空指针，

148
00:13:29,240 --> 00:13:31,880
希望操作系统做一些明智的事情，

149
00:13:31,880 --> 00:13:34,250
把消息传回给用户应用程序，

150
00:13:34,250 --> 00:13:38,690
表示没有更多内存给你或者完全没有内存给任何程序。

151
00:13:40,970 --> 00:13:41,600
好的？

152
00:13:43,110 --> 00:13:45,900
操作系统需要优雅地处理这种情况，

153
00:13:46,410 --> 00:13:50,040
一般是把错误信息传回给用户程序。

154
00:13:57,280 --> 00:13:58,720
好的。

155
00:13:59,400 --> 00:14:06,060
那么如何实现这些地址空间，如何复用所有的地址空间在单个物理内存上。

156
00:14:06,580 --> 00:14:12,760
最常见的，也是非常灵活的方法是使用页表。

157
00:14:17,330 --> 00:14:20,960
想法是，这是硬件支持的，

158
00:14:21,080 --> 00:14:27,710
所以这是由处理器或叫做内存管理单元的硬件实现的，

159
00:14:28,040 --> 00:14:30,440
所以，你脑海中要有的画面是，

160
00:14:30,650 --> 00:14:35,370
CPU 执行任何指令，

161
00:14:35,980 --> 00:14:46,990
比如存储指令，把 $7 放入 a0 间接引用，

162
00:14:47,580 --> 00:14:49,620
执行这些指令，

163
00:14:49,980 --> 00:14:55,560
当它执行存储指令，加载指令，任何含有地址的指令，

164
00:14:55,800 --> 00:14:59,190
那个地址我们都应该认为是虚拟地址，

165
00:14:59,220 --> 00:15:01,410
它不是物理地址，而是虚拟地址。

166
00:15:02,100 --> 00:15:05,190
比如，我们在这使用的 a0 中的值，

167
00:15:05,250 --> 00:15:12,120
比如说是 1000 ， 0x1000 就是一个虚拟地址，

168
00:15:12,120 --> 00:15:17,580
虚拟地址通过内存管理单元路由，

169
00:15:21,160 --> 00:15:26,230
内存管理单元把它转换成物理地址。

170
00:15:27,690 --> 00:15:32,670
然后那个物理地址在内存中进行索引，

171
00:15:33,120 --> 00:15:37,740
加载值或保存需要写入的值。

172
00:15:38,700 --> 00:15:41,610
所以从 CPU 的角度来看，

173
00:15:41,640 --> 00:15:48,150
它总是，一旦 MMU 启动，每条指令[发出的]都是虚拟地址。

174
00:15:49,100 --> 00:15:53,990
为了把虚拟地址转换成物理地址，一般 MMU 有一张表。

175
00:15:55,060 --> 00:15:59,080
虚拟地址在一边，物理地址在一边，

176
00:15:59,350 --> 00:16:04,480
另一边的这里可能是我们的条目 1000 ，

177
00:16:04,480 --> 00:16:14,190
可能映射到无论什么， 0x （开头的）某个值，在内存中的某个地方，

178
00:16:14,490 --> 00:16:19,050
所以这个在虚拟地址和物理地址之间的映射是很灵活的。

179
00:16:19,890 --> 00:16:23,430
所以，一边是虚拟地址，另一边是物理地址。

180
00:16:26,030 --> 00:16:29,690
通常，这个映射也保存在内存中。

181
00:16:30,220 --> 00:16:40,300
所以 CPU 有一些寄存器用来指出，包含物理地址的页表保存在哪里。

182
00:16:40,720 --> 00:16:46,060
所以某个地方存放物理地址的页表或映射，

183
00:16:46,060 --> 00:16:49,410
比如，地址 10 ，

184
00:16:49,860 --> 00:16:57,690
在 RISC-V 中的这个寄存器叫做 satp ，保存着地址 10 ，

185
00:16:57,780 --> 00:17:08,550
CPU 告诉内存管理单元，到哪里寻找把虚拟地址转换为物理地址的映射。

186
00:17:10,020 --> 00:17:13,710
然后，基本想法是给每个应用程序自己的映射。

187
00:17:14,310 --> 00:17:17,610
所以 cat 有自己的映射。糟糕。

188
00:17:19,120 --> 00:17:24,850
每个应用程序，它自己的。糟糕。

189
00:17:25,180 --> 00:17:27,160
是的， Bibic 继续。

190
00:17:29,410 --> 00:17:40,210
所以， MMU 你说它不用保存映射，那么它是只做转换吗，

191
00:17:40,240 --> 00:17:46,870
就像，它读取内存并转换，但是不用保存映射。

192
00:17:46,870 --> 00:17:49,600
这就是你脑海中应该有的画面。

193
00:17:52,780 --> 00:17:57,040
每个映射，好的，所以映射保存在内存中，

194
00:17:57,040 --> 00:18:00,130
MMU 只是访问查看映射，

195
00:18:00,130 --> 00:18:03,910
我们过一会会看到，这个映射比我画在这里的要更复杂。

196
00:18:05,300 --> 00:18:10,540
所以，每个应用程序有它自己的映射，

197
00:18:12,340 --> 00:18:15,520
那个映射定义了它的地址空间。

198
00:18:16,380 --> 00:18:23,430
所以当 CPU ，当操作系统从一个应用程序切换到另一个应用程序，

199
00:18:23,610 --> 00:18:27,360
它也会切换 satp 寄存器的内容，

200
00:18:27,360 --> 00:18:32,580
用来保存对应进程映射的根地址。

201
00:18:33,410 --> 00:18:37,910
所以在这种方式下，多个应用程序运行在 CPU 上，

202
00:18:37,910 --> 00:18:41,000
每次从一个应用程序切换到另一个应用程序，

203
00:18:41,060 --> 00:18:46,910
也会切换 satp 寄存器，指向那个应用程序对应的映射。

204
00:18:47,430 --> 00:18:57,330
在这种方式下， cat 的虚拟地址与 shell 的虚拟地址转换不同，

205
00:18:57,330 --> 00:18:59,640
因为它们都有自己的映射。

206
00:19:02,380 --> 00:19:03,010
能理解吗？

207
00:19:06,470 --> 00:19:11,110
好的，所以，这是基本计划，

208
00:19:11,140 --> 00:19:17,740
目前为止我画的或者解释的方法是很初级的，也是不合理的。

209
00:19:18,240 --> 00:19:19,650
是的， Bibic ，继续。

210
00:19:20,830 --> 00:19:28,910
抱歉，你说 satp 寄存器为进程做修改，

211
00:19:28,940 --> 00:19:36,250
我想每个进程的 satp 寄存器的值是由内核保存的。

212
00:19:36,490 --> 00:19:39,250
是的，内核写入 satp 寄存器，

213
00:19:39,250 --> 00:19:45,040
事实上，写入或读取，特别是写入 satp 寄存器是一个特权指令。

214
00:19:45,830 --> 00:19:49,880
所以用户程序不能更新页面映射寄存器，

215
00:19:49,880 --> 00:19:52,070
说现在自己希望运行在这个页面映射，

216
00:19:52,460 --> 00:19:56,130
因为这会违反隔离性，

217
00:19:56,130 --> 00:19:59,460
所以只有内核，内核模式的代码可以更新它。

218
00:20:03,730 --> 00:20:06,130
好的，像我说的，这张图片是很初级的，

219
00:20:06,190 --> 00:20:10,300
我还没有说过这个映射是如何工作的。

220
00:20:10,760 --> 00:20:18,560
我画的这种方式，看起来表示每个虚拟地址都在映射中有一个条目。

221
00:20:19,370 --> 00:20:26,360
如果你这么做了，在 RISC-V 中它（映射）会有多大。

222
00:20:32,380 --> 00:20:33,100
有人知道吗？

223
00:20:36,150 --> 00:20:38,700
理论上， RISC-V 上有多少地址，

224
00:20:38,700 --> 00:20:41,610
或者寄存器能存储多少地址，

225
00:20:46,090 --> 00:20:49,640
寄存器是 64 位的，那么是多少地址。

226
00:20:52,490 --> 00:20:53,180
有人知道吗？

227
00:20:53,850 --> 00:20:57,060
我知道问这些问题是对你们智力的侮辱，但是（这很重要）。

228
00:21:00,110 --> 00:21:02,600
我们在聊天窗口中有一些答案，比如 2 的 64 次方。

229
00:21:02,600 --> 00:21:05,660
我没有看聊天窗口，抱歉，是的， 2 的 64 次方。

230
00:21:05,690 --> 00:21:08,720
让我看下能不能把聊天窗口显示出来，让我看到它。

231
00:21:13,460 --> 00:21:14,930
是的， 2 的 64 次方，谢谢。

232
00:21:17,000 --> 00:21:20,030
好的，这张表是巨大的，

233
00:21:20,420 --> 00:21:24,590
实际上，我们知道仅包含这张表就会使用所有内存，

234
00:21:24,590 --> 00:21:25,670
所以这是不合理的。

235
00:21:26,350 --> 00:21:28,930
事实上，事情不是这样工作的。

236
00:21:29,520 --> 00:21:33,600
我会分两步来解释它在 RISC-V 中是如何工作的。

237
00:21:33,930 --> 00:21:41,490
第一步是，不要对每个地址[]，而是对每个页面。

238
00:21:44,580 --> 00:21:46,560
每次转换一个页面，

239
00:21:46,650 --> 00:21:54,590
在 RISC-V 中，一个页是 4 KB ，也就是 4096 字节。

240
00:21:55,140 --> 00:22:02,580
这很常见，几乎所有处理器页面大小使用 4 KB ，或者支持 4 KB 。

241
00:22:03,420 --> 00:22:05,970
所以现在转换工作有些不同，

242
00:22:06,000 --> 00:22:14,280
这里，我们有虚拟地址，分为两部分，一个是索引，一个是偏移量，

243
00:22:15,300 --> 00:22:18,120
偏移量就是页面内部的字节。

244
00:22:18,880 --> 00:22:26,530
所以当 MMU 做转换的时候，它使用索引在映射中，

245
00:22:26,980 --> 00:22:31,030
给你一些内存中的物理页面编号，

246
00:22:31,480 --> 00:22:37,330
那个物理页面编号指向 4096 字节中的一些物理页。

247
00:22:38,040 --> 00:22:42,750
然后偏移量部分，索引那个物理页，

248
00:22:42,810 --> 00:22:53,520
比如，偏移量是 12 那么你知道那个页中的第 12 个条目被使用。

249
00:22:54,110 --> 00:22:57,920
很多人问到了这个，

250
00:22:59,100 --> 00:23:03,120
回答这个问题，有一种方法获得偏移量，

251
00:23:03,120 --> 00:23:11,190
把偏移量加到基础页面上，得到真正的物理地址位置，

252
00:23:11,190 --> 00:23:15,150
保存，加载值的那个位置。

253
00:23:16,410 --> 00:23:18,630
关于 RISC-V 的一个有趣的事情是，

254
00:23:18,630 --> 00:23:26,570
这也是对一些问题的回答，有人问物理地址或虚拟地址都是 64 位的，

255
00:23:28,250 --> 00:23:32,330
这完全正确，因为 RISC-V 是 64 位寄存器。

256
00:23:33,220 --> 00:23:40,660
但是实际上我们在 RISC-V 处理器上，并没有使用所有 64 位，

257
00:23:41,190 --> 00:23:45,030
也就是，最高的 25 位没有使用。

258
00:23:45,800 --> 00:23:49,160
所以，这限制了虚拟地址，

259
00:23:49,370 --> 00:23:59,950
限制了虚拟地址空间在 2 的 39 次方，大概是 512 GB 。

260
00:24:04,220 --> 00:24:13,250
当然未来版本的处理器可能需要支持更大的地址空间，[也可以完成]，

261
00:24:13,280 --> 00:24:21,500
比如使用这 25 位中的一些，来构建更大的虚拟地址空间。

262
00:24:22,310 --> 00:24:26,420
所以，索引中还剩下 39 位，

263
00:24:26,450 --> 00:24:34,820
虚拟地址中的 27 位是索引，我们等一会会看到为什么是 27 ，

264
00:24:34,820 --> 00:24:43,800
然后 12 位是偏移量，必须是 12 ，因为 2 的 12 次方是 4096 。

265
00:24:45,420 --> 00:24:45,960
好的？

266
00:24:46,590 --> 00:24:53,010
而在 RISC-V 物理地址，实际上是 56 位。

267
00:24:57,940 --> 00:25:03,070
所以物理内存可以比单个虚拟地址空间大。

268
00:25:03,900 --> 00:25:05,880
但是它限制在 2 的 56 次方，

269
00:25:05,970 --> 00:25:13,770
大多数板可能不支持 2 的 56 次方物理内存，因为这是一个很大的物理内存，

270
00:25:14,010 --> 00:25:20,970
但是理论上，如果你能制造出，一块板也能支持 2 的 56 次方物理内存。

271
00:25:22,020 --> 00:25:26,430
所以在这种方案中，物理地址是 56 位，

272
00:25:26,460 --> 00:25:29,580
44 位是物理地址编号， PPN ，

273
00:25:29,850 --> 00:25:34,530
12 位是偏移量，从虚拟地址继承而来。

274
00:25:36,810 --> 00:25:37,710
能理解吗？

275
00:25:40,560 --> 00:25:44,250
所以，在这里停顿一下，你可以整理自己的想法，

276
00:25:44,310 --> 00:25:49,410
我想指出的是，这个材料很重要，

277
00:25:49,410 --> 00:25:55,410
所以可以问问题，细节很重要，这会是很大一部分，

278
00:25:55,410 --> 00:26:01,560
你需要完全理解这个东西，来做后面的实验，页表实验。

279
00:26:02,580 --> 00:26:04,230
是的， Amiar ，请继续。

280
00:26:05,210 --> 00:26:08,690
你能退一张幻灯片吗，我希望屏幕显示，让我更清楚。

281
00:26:10,770 --> 00:26:14,720
哪一张，页表幻灯片？是的。

282
00:26:20,250 --> 00:26:21,990
这张吗？不是。

283
00:26:22,670 --> 00:26:25,250
最近的那一张，但也不是很重要，

284
00:26:25,310 --> 00:26:27,170
是的，就是这张，谢谢。

285
00:26:27,620 --> 00:26:37,790
所以，我想知道 4096 字节的页面，它在内存中分配是不是连续的。

286
00:26:37,940 --> 00:26:45,080
是的，有连续的 4096 字节在物理内存中。

287
00:26:46,520 --> 00:26:49,520
我明白了，然后。

288
00:26:49,520 --> 00:26:52,550
映射是以 4096 字节为粒度的。

289
00:26:53,490 --> 00:27:01,560
然后偏移量 12 ，因为 2 的 12 次方是 4096 ，所以可以包含每个块。

290
00:27:02,460 --> 00:27:03,600
是的，页面中的每个字节。

291
00:27:04,760 --> 00:27:13,220
还有图片中的 56 是怎么来的，之前的我都能跟上，但是我不知道它是怎么来的。

292
00:27:13,220 --> 00:27:18,470
这是设计师们决定的，硬件设计师决定物理内存是多大，

293
00:27:18,590 --> 00:27:28,520
取决于他们设计哪块板， RISC-V 设计师决定 56 位物理地址是个好主意。

294
00:27:30,540 --> 00:27:35,040
通常他们得出这个数字的方法是根据技术趋势。

295
00:27:35,500 --> 00:27:38,980
比如我们想在后面的 5 年内可用，

296
00:27:38,980 --> 00:27:43,690
我们预测物理内存不会大于 2 的 56 次方。

297
00:27:44,740 --> 00:27:50,350
可能他们想的是不会大于某个更小的值，留出一些余量，

298
00:27:50,350 --> 00:27:55,000
防止他们的预测出错，他们选择一个更大的数。

299
00:27:56,700 --> 00:27:57,330
理解了吗？

300
00:27:57,330 --> 00:27:59,540
理解了，是的，谢谢。

301
00:27:59,810 --> 00:28:01,190
是的，很多人问到这个。

302
00:28:03,880 --> 00:28:07,360
还有人举手吗，我想有很多人要提问，

303
00:28:07,360 --> 00:28:13,030
但是我的 zomm 不能显示超过两个人举手，只是显示很多人举手。

304
00:28:13,710 --> 00:28:15,780
所以如果有问题，可以直接提问。

305
00:28:20,160 --> 00:28:20,820
好的。

306
00:28:21,570 --> 00:28:24,450
我有一个问题。是的，请继续。

307
00:28:24,660 --> 00:28:34,440
所以，虚拟内存可以达到 2 的 27 次方，物理内存可以达到 2 的 56 次方，

308
00:28:34,710 --> 00:28:46,130
所以我们有多个进程，会耗尽虚拟内存，而没有用完物理内存。

309
00:28:48,320 --> 00:28:53,040
是的，完全正确。

310
00:28:53,980 --> 00:28:54,610
好的。

311
00:28:54,730 --> 00:28:57,280
我也有个问题，

312
00:28:57,280 --> 00:29:06,120
这个物理地址的 56 ，它是不是可能内存位置的数目，

313
00:29:06,510 --> 00:29:10,890
我不认为它是位的数目，因为这是 64 位机器，

314
00:29:11,160 --> 00:29:17,820
56 可能扩展到 64 ，但是他们选择了只使用 56 。

315
00:29:17,850 --> 00:29:24,300
正确，你可以这样想，只需要使用 56 位而不是 64 位。

316
00:29:25,530 --> 00:29:26,760
我明白了，谢谢。

317
00:29:30,240 --> 00:29:30,780
好的？

318
00:29:30,960 --> 00:29:32,490
我也有个问题，

319
00:29:32,520 --> 00:29:37,140
你能回退一张幻灯片吗。

320
00:29:38,800 --> 00:29:45,790
从 CPU ，我们通过 MMU 到内存，

321
00:29:46,210 --> 00:29:52,450
但是对于不同进程有什么不同，

322
00:29:52,570 --> 00:29:54,130
因为每个进程，

323
00:29:54,160 --> 00:30:01,060
比如 shell 进程有地址 0x1000 ，

324
00:30:01,120 --> 00:30:05,740
ls 进程也有地址 0x1000 ，

325
00:30:05,860 --> 00:30:11,260
所以我们需要转换它们到不同的物理地址，所以。

326
00:30:11,260 --> 00:30:17,410
satp 寄存器包含使用哪个映射的地址，

327
00:30:18,460 --> 00:30:22,690
所以 ls 使用自己的映射运行， cat 也使用自己的映射运行。

328
00:30:22,720 --> 00:30:26,800
好的，所以每个进程有完全是它自己的的映射。

329
00:30:28,140 --> 00:30:29,220
理解了，谢谢。

330
00:30:29,740 --> 00:30:33,880
实际上，这是引出下一个知识点的[方法]，

331
00:30:34,180 --> 00:30:36,130
所以每个进程有自己的映射，

332
00:30:36,870 --> 00:30:40,170
这个映射有多大，比如我画的这个。

333
00:30:40,870 --> 00:30:47,960
这个映射有 2 的 27 次方个条目，这是很大的。

334
00:30:49,030 --> 00:30:56,140
所以如果每个进程有完整的页表，那会很快填满物理内存，

335
00:30:56,620 --> 00:30:59,770
这是巨大的，意味着每个进程都很大，

336
00:31:00,160 --> 00:31:04,900
所以，实际上，这不是硬件存储页表的方式，

337
00:31:04,900 --> 00:31:09,940
你可以把它想成一个数组，从 0 到 2 的 27 次方，

338
00:31:09,940 --> 00:31:11,770
但是实际上不是这样的。

339
00:31:12,160 --> 00:31:15,520
实际上，它是一个多级结构，

340
00:31:15,580 --> 00:31:25,600
这是由硬件实现的真正的 RISC-V 页表结构。

341
00:31:26,820 --> 00:31:31,650
所以我们之前看到的 27 位索引发生了什么，

342
00:31:32,260 --> 00:31:37,660
它分位三个 9 位数字。

343
00:31:38,220 --> 00:31:46,500
最开始的顶部 9 位作为顶层页表目录的索引，

344
00:31:47,130 --> 00:31:55,600
所以在一个目录中，是 4096 字节，跟页面大小一样。

345
00:31:56,160 --> 00:32:08,500
一个 PTE 条目是 64 字节，抱歉，我的意思是 64 位，跟寄存器一样， 8 字节。

346
00:32:09,000 --> 00:32:18,150
所以是 4096 除以 8 ，有 512 个条目在每个目录页面中。

347
00:32:19,370 --> 00:32:24,620
所以，发生的是 satp 指向顶层目录，

348
00:32:24,650 --> 00:32:31,130
我们使用顶层 9 位索引页面目录，得到一个新的物理页面编号。

349
00:32:32,040 --> 00:32:35,820
这个物理页面编号是下一级页面目录，

350
00:32:36,030 --> 00:32:41,910
完后我们使用下一级索引索引页面目录，

351
00:32:42,060 --> 00:32:47,340
同样的，我们会找到一个底层页面目录。

352
00:32:47,800 --> 00:32:52,570
这就是虚拟内存映射到物理内存的条目。

353
00:32:55,680 --> 00:32:59,160
所以某种意义上，它和上一张幻灯片展示的很像，

354
00:32:59,160 --> 00:33:02,520
除了索引发生三步而不是一步，

355
00:33:02,850 --> 00:33:06,120
这种方案的优点是，

356
00:33:06,360 --> 00:33:11,610
如果地址空间的大部分空间没有使用，你不需要为它们分配页表条目。

357
00:33:12,930 --> 00:33:15,510
比如，有一个地址空间，

358
00:33:16,120 --> 00:33:25,260
它只有一个页面，最底部的页面 4096 ，在地址空间中没有其他页面，

359
00:33:25,560 --> 00:33:29,130
只有地址 0 到 4095 ， 4096 真正映射，

360
00:33:29,490 --> 00:33:34,920
那么需要多少页表条目或页表目录来映射这个页面。

361
00:33:39,280 --> 00:33:45,240
好的，你需要一个顶级条目，你需要这个条目里的值是 0 ，

362
00:33:46,500 --> 00:33:51,300
最顶级的 9 位， 0 0 ，你需要一个条目是 0 。

363
00:33:51,880 --> 00:33:58,870
你还需要一个中间条目，它对应接下来的九个 [0 位]，

364
00:33:58,900 --> 00:34:01,360
然后还需要一个条目对应接下来的九个 0 位。

365
00:34:02,140 --> 00:34:07,000
所以，我们需要三个页面目录。

366
00:34:11,420 --> 00:34:16,370
在之前幻灯片的前一个方案中，我们需要 2 的 27 次方个条目，

367
00:34:16,400 --> 00:34:20,360
现在我们只需要 3 乘以 512 个条目就可以了。

368
00:34:21,920 --> 00:34:30,830
这就是硬件使用这种多级树方案的原因。

369
00:34:32,570 --> 00:34:34,670
关于这个有什么问题吗，因为这很重要。

370
00:34:36,270 --> 00:34:37,290
Samir ，继续。

371
00:34:39,000 --> 00:34:47,920
我的问题是，每个页表的 PPN 数字是 44 位，

372
00:34:48,440 --> 00:34:56,210
虚拟内存边上的表，我们从哪里得到其他 12 位。

373
00:34:57,300 --> 00:35:02,310
好的，最后的 12 位，好的，你说这个 44 ，是吧。

374
00:35:02,980 --> 00:35:03,430
是的。

375
00:35:03,430 --> 00:35:04,390
这里是如何发生的，

376
00:35:04,390 --> 00:35:15,680
好的，所有页面目录或页面[行]，它们的物理页面编号是 44 加上 12 个零位。

377
00:35:18,940 --> 00:35:23,860
所以，如果我们看这些 PTE 条目，它们都有相同的形式，

378
00:35:23,860 --> 00:35:29,320
看其中一个，有 44 位，还有 12 个零位，

379
00:35:29,320 --> 00:35:35,200
所以 44 加上 12 是 56 ，给我们一个物理地址，

380
00:35:36,610 --> 00:35:42,370
所以，这里有 64 位，有一些位是保留的，没有使用，

381
00:35:42,400 --> 00:35:48,190
实际上，末尾的 10 位完全没有使用，

382
00:35:48,190 --> 00:35:55,600
实际上，页表硬件保存了很多标志来控制转换，

383
00:35:55,600 --> 00:35:57,070
我们过一会会讨论这些标志。

384
00:35:57,740 --> 00:36:04,250
但是它们控制转换，它们保存在末尾 10 位。

385
00:36:05,100 --> 00:36:11,250
这也意味着，如果你把它们加起来，是 54 位，还有 10 位保留。

386
00:36:11,920 --> 00:36:16,420
它们没有被使用，这些 10 位也是为未来的增长（保留的），

387
00:36:16,810 --> 00:36:19,720
某个时刻，我们可能有一种新的 RISC-V 处理器，

388
00:36:19,960 --> 00:36:22,720
它有稍微不同的页表结构，

389
00:36:22,840 --> 00:36:26,740
它就可能物理页面编号多于 44 位。

390
00:36:29,440 --> 00:36:30,040
好的？谢谢。

391
00:36:31,380 --> 00:36:36,540
你可以看这里，如果你看画在这里的一个条目，

392
00:36:36,540 --> 00:36:40,990
这里有 10 个位保留，没有被使用。

393
00:36:42,000 --> 00:36:46,350
好的，我们来看标志位，因为它很重要。

394
00:36:47,610 --> 00:36:51,690
每个转换的最后 10 位，保存着许多标志位，

395
00:36:51,990 --> 00:36:54,780
第一个标志是 valid ，

396
00:36:55,510 --> 00:37:01,990
如果设置了 valid 位，意味着这是一个可用的 PTE ，可以使用它来转换。

397
00:37:03,150 --> 00:37:07,620
所以，我们来看看这个例子，

398
00:37:07,620 --> 00:37:13,350
三个页面目录只使用了条目 0 ，只有条目 0 设置了 valid 位，

399
00:37:13,440 --> 00:37:17,070
其他 511 个条目都没有设置 valid 位。

400
00:37:18,610 --> 00:37:26,440
告诉 MMU ，不需要继续查询这个 PTE ，这个 PTE 不包含有效信息。

401
00:37:27,820 --> 00:37:32,170
然后 R 表示允许从页面读，

402
00:37:32,230 --> 00:37:34,990
write 表示允许向页面写，

403
00:37:35,230 --> 00:37:38,800
execute 表示可以执行它的指令，

404
00:37:39,330 --> 00:37:46,320
user 表示运行在用户空间的程序也可以访问这个页面，

405
00:37:47,340 --> 00:37:50,310
其他位不是那么重要，会在（用到的）某个时刻展示，

406
00:37:50,670 --> 00:37:52,770
这些就是五个比较重要的位。

407
00:37:55,970 --> 00:37:56,840
能理解吗？

408
00:37:59,300 --> 00:38:05,820
是的， Nithya ，我可能读错你的名字，我向你道歉。

409
00:38:06,860 --> 00:38:08,900
就是那么读的，谢谢，

410
00:38:09,350 --> 00:38:13,220
我有一个关于三个页表的问题，

411
00:38:13,820 --> 00:38:21,800
这些地址或 PPN 值是如何组成最后的物理地址的，我可能错过了。

412
00:38:22,370 --> 00:38:25,310
是的，可能说的不是非常明确，

413
00:38:25,400 --> 00:38:28,790
第一个 PPN 在顶级页表，

414
00:38:29,330 --> 00:38:37,040
在顶级页面目录的第一个 PPN 包含了下一级的物理地址。

415
00:38:37,780 --> 00:38:40,480
这个又包含下一级，

416
00:38:40,480 --> 00:38:44,290
然后在最后一个，我们有 44 位，

417
00:38:44,380 --> 00:38:49,270
包含我们想要转换的真正的页面物理地址。

418
00:38:50,150 --> 00:38:51,770
好的，理解了。

419
00:38:51,860 --> 00:38:54,830
好的，有一个有趣的问题，

420
00:38:54,860 --> 00:38:59,540
让我在回答其他两个举手的问题之前，先回答自己的问题，

421
00:38:59,690 --> 00:39:09,780
再看这张图片，为什么页面目录保存的是物理页面编号，而不是虚拟地址。

422
00:39:11,520 --> 00:39:15,960
因为我们要查找内存，比如在内存中查找下一个目录。

423
00:39:16,110 --> 00:39:20,940
是的，正确，我们不能使用一种转换方案依赖另一种转换方案，

424
00:39:20,940 --> 00:39:24,240
我们可能会递归查找，所以那是没意义的。

425
00:39:24,680 --> 00:39:27,570
这就是正确答案，它必须是物理编号，

426
00:39:27,600 --> 00:39:32,700
那么 satp 呢，它保存的是物理地址还是虚拟地址。

427
00:39:39,190 --> 00:39:43,510
也是物理地址，因为第一个页面目录也在内存中。

428
00:39:44,710 --> 00:39:49,060
是的，没错，它必须是一个物理编号，因为我们使用它来转换。

429
00:39:50,120 --> 00:39:57,140
所以， satp 需要知道页面目录[路由]的物理页面编号。

430
00:39:59,180 --> 00:40:01,940
好的，这里有两个问题，两个人举手了，

431
00:40:02,240 --> 00:40:10,040
你可以重复你的问题，如果还没有解决。

432
00:40:10,760 --> 00:40:14,030
所以有一个三个表组成的层次结构，

433
00:40:14,360 --> 00:40:19,760
每个表由虚拟地址的一部分 9 个位索引，

434
00:40:22,740 --> 00:40:28,200
我不太明白它们之间的连接是如何发生的，

435
00:40:28,200 --> 00:40:35,220
只使用三个 9 位来索引每个表不是已经足够了吗？

436
00:40:36,780 --> 00:40:42,330
正确，第一个顶级 9 位用来索引第一个顶级页表目录，

437
00:40:42,330 --> 00:40:44,880
第二个索引第二个，但三个索引第三个。

438
00:40:48,240 --> 00:40:57,090
所以，可能我没有明白，当一个进程访问一个虚拟地址，

439
00:40:57,330 --> 00:41:06,360
虚拟地址加载到 satp 寄存器，得到对应的顶级页表，

440
00:41:07,640 --> 00:41:11,550
然后那个页表会。

441
00:41:12,130 --> 00:41:16,990
我们使用 27 位中的顶级 9 位来索引页面目录。

442
00:41:18,660 --> 00:41:20,850
那么它的结果是什么，

443
00:41:20,850 --> 00:41:26,580
比如结果是 MMU 创建一个新页表吗。

444
00:41:26,610 --> 00:41:32,400
不，不是， MMU 告诉操作系统或处理器，抱歉，我不能转换这个地址，

445
00:41:32,580 --> 00:41:36,990
然后生成一个页面错误，这个我们后面会讨论。

446
00:41:38,970 --> 00:41:42,120
但是不能转换地址，它不转换地址，

447
00:41:42,120 --> 00:41:47,130
就像你不能除零，如果你这样做，处理器会拒绝。

448
00:41:50,110 --> 00:41:51,250
我明白了，好的。

449
00:41:54,030 --> 00:41:55,650
Brandon ，你有什么问题？

450
00:41:56,320 --> 00:42:01,300
是的，我想确认我理解了，可能已经说过了

451
00:42:01,660 --> 00:42:09,160
但是我想知道中间页表，我们如何计算它们的物理地址，

452
00:42:09,540 --> 00:42:15,420
所以，这是否正确，如果我们想找到第二级页表物理地址，

453
00:42:15,420 --> 00:42:20,040
我们就使用第一级页表的 PPN ，它的 44 位，

454
00:42:20,070 --> 00:42:25,710
然后加上最初的虚拟地址的 12 位，得到完整的 56 位，就是这个问题。

455
00:42:26,010 --> 00:42:29,970
我们不用加上偏移量，我们只是使用十二个 0 位，

456
00:42:30,980 --> 00:42:32,960
我们使用 PPN ，它是 44 位。

457
00:42:33,110 --> 00:42:33,980
好的。

458
00:42:34,010 --> 00:42:40,280
后面跟上 12 个 0 位，就得到了 56 位物理地址，就是下一个页面目录，

459
00:42:40,280 --> 00:42:43,100
这需要每个页面目录是对齐的。

460
00:42:45,500 --> 00:42:47,300
我明白了，好的，有道理。

461
00:42:49,880 --> 00:42:53,300
这些都是好问题，这些东西是你们在页表实验中会遇到的，

462
00:42:53,300 --> 00:42:55,790
所以，现在问出来很好。

463
00:43:00,000 --> 00:43:01,950
好的，让我看一下。

464
00:43:04,410 --> 00:43:14,020
好的，让我稍等一下，[整理]一下思绪，看看我在哪里。

465
00:43:16,300 --> 00:43:25,150
好的，还有一件事情我想讲一下，因为你们会看到，

466
00:43:25,300 --> 00:43:29,470
就是，我们考虑刚才我展示的这种方案，

467
00:43:29,470 --> 00:43:36,760
看上去是我们或者处理器从内存加载值，保存值到内存，

468
00:43:36,790 --> 00:43:39,280
我们必须三次访问内存，

469
00:43:39,310 --> 00:43:45,040
一次是顶级页面目录，一次是中级页面目录，还有一次是底部页面目录。

470
00:43:45,500 --> 00:43:53,780
看起来对虚拟地址的内存引用都需要三次内存访问，这是很昂贵的。

471
00:43:54,540 --> 00:43:59,640
所以，实际中做的，几乎所有处理器所做的，

472
00:43:59,700 --> 00:44:04,290
它在旁边有一个缓存，包含着最近使用的转换，

473
00:44:05,300 --> 00:44:11,040
这称为转换后备缓冲器，

474
00:44:11,790 --> 00:44:17,330
你会经常看到这个术语 TLB 。

475
00:44:18,370 --> 00:44:25,050
它只是保存了页表条目或 PTE 条目的缓存。

476
00:44:28,180 --> 00:44:32,110
所以当处理器第一次访问查找虚拟地址，

477
00:44:32,110 --> 00:44:38,230
硬件遍历这个页面，这三级页表，

478
00:44:38,410 --> 00:44:44,320
最后找到那个虚拟地址的最终物理地址，

479
00:44:44,500 --> 00:44:53,610
然后， TLB 保存 [VA, PA] 映射，

480
00:44:53,940 --> 00:45:00,090
让你下次访问这个虚拟地址，可以直接查询 TLB ,

481
00:45:00,090 --> 00:45:03,420
TLB 会直接返回而不用遍历页表。

482
00:45:05,240 --> 00:45:07,130
是的， Amiar 。

483
00:45:09,710 --> 00:45:16,970
所以 TLB 把虚拟地址映射到页面的物理地址，

484
00:45:17,150 --> 00:45:21,440
除了虚拟地址的偏移量，

485
00:45:22,490 --> 00:45:26,720
那么缓存页表级别是不是更有效呢。

486
00:45:27,780 --> 00:45:31,260
好的，让我来退一步，

487
00:45:31,410 --> 00:45:34,050
实现 TLB 有很多方式，

488
00:45:34,560 --> 00:45:37,500
最重要的事情是你知道有 TLB ，

489
00:45:38,230 --> 00:45:41,920
而 TLB 实现的准确细节，

490
00:45:41,920 --> 00:45:47,650
我们不会在这个话题上讨论很多细节。

491
00:45:47,920 --> 00:45:51,340
所以这是处理器旁边的一个东西，

492
00:45:51,340 --> 00:45:55,690
大多数对操作系统是隐藏的，操作系统并不知道 TLB 如何操作，

493
00:45:56,270 --> 00:45:59,840
你只需要知道 TLB 存在的原因是，

494
00:46:00,050 --> 00:46:09,940
如果你切换页表，那么操作系统要告诉处理器它在切换页表，

495
00:46:10,740 --> 00:46:14,450
然后 TLB 需要刷新。

496
00:46:16,790 --> 00:46:18,830
因为你会发送旧的条目，

497
00:46:18,830 --> 00:46:23,570
如果你切换到新的页表， TLB 中的条目就可能不是有效的，

498
00:46:23,780 --> 00:46:28,100
所以要删除它们，否则转换可能会出现错误。

499
00:46:28,830 --> 00:46:35,340
所以操作系统知道这里有一个 TLB ，

500
00:46:35,370 --> 00:46:41,670
只是偶尔告诉硬件，我不再使用它们了，因为我要切换页表。

501
00:46:44,150 --> 00:46:55,000
实际上，在 RISC-V 中，刷新 TLB 的指令是 sfence_vma ，

502
00:46:57,230 --> 00:47:01,040
我不是很确定，刷新 TLB 。

503
00:47:01,370 --> 00:47:01,880
Bibic.

504
00:47:04,900 --> 00:47:11,410
我有一个问题，不是关于 TLB ，但是它带来了这个问题，

505
00:47:11,470 --> 00:47:21,370
我们使用的三级页面，是由操作系统还是硬件实现的。

506
00:47:21,640 --> 00:47:25,400
是由硬件实现的，所有这些都在硬件发生的，

507
00:47:25,670 --> 00:47:30,120
MMU 是硬件的一部分，而不是在操作系统中。

508
00:47:30,180 --> 00:47:33,150
我们过一会会看到，当我们查看 xv6 时，

509
00:47:33,390 --> 00:47:37,140
xv6 有一个函数模拟页表遍历，

510
00:47:37,140 --> 00:47:41,220
因为有时， xv6 必须做一些硬件做的事情，

511
00:47:42,040 --> 00:47:48,670
它有一个名叫 walk 的函数，做的事情相同，不过是在软件中。

512
00:47:51,370 --> 00:47:53,380
我能问个问题吗，

513
00:47:54,520 --> 00:48:00,170
所以，在这个方案中，处理器内存在哪里，

514
00:48:00,170 --> 00:48:04,070
是在地址转换之前还是之后。

515
00:48:04,520 --> 00:48:10,580
是的，让我往回切换一下，让我看看。

516
00:48:13,120 --> 00:48:17,410
好的， MMU ，你可以这样认为，

517
00:48:17,410 --> 00:48:22,650
所有这些东西，这一块都在处理器中。

518
00:48:24,350 --> 00:48:27,920
所以，这是 RISC-V 芯片，在它里面是 CPU ，

519
00:48:27,920 --> 00:48:32,030
实际上，这里有多个核心，四核，这是 MMU ，

520
00:48:32,240 --> 00:48:37,580
你可以这样考虑，在 CPU 这一侧，有一个 TLB 。

521
00:48:41,330 --> 00:48:41,960
好的？

522
00:48:44,450 --> 00:48:48,290
有道理，但是我想我的问题是，

523
00:48:48,680 --> 00:48:53,960
缓存，不是说 TLB ，只是说普通的缓存，

524
00:48:53,960 --> 00:48:57,740
比如有时候，我们不是都访问内存。

525
00:48:58,010 --> 00:49:02,060
是的，好想法，我想我在上周一展示了这种方案，

526
00:49:02,060 --> 00:49:05,540
RISC-V 处理器有 l1 缓存， l2 缓存，

527
00:49:05,910 --> 00:49:11,420
其中一些缓存由物理地址索引，一些缓存由虚拟地址索引，

528
00:49:11,900 --> 00:49:15,950
所以由虚拟地址索引的缓存在 MMU 之前，

529
00:49:16,560 --> 00:49:19,620
而由物理地址索引的缓存在 MMU 之后。

530
00:49:25,020 --> 00:49:25,590
这个能理解吗？

531
00:49:25,800 --> 00:49:28,830
我也有一个问题，我的问题是，

532
00:49:28,860 --> 00:49:32,880
你说了， TLB 遍历，

533
00:49:32,880 --> 00:49:38,490
所以把东西放入 TLB ，硬件可以遍历页表，

534
00:49:39,850 --> 00:49:43,720
那么，我们为什么要写 walk 函数，如果硬件可以完成。

535
00:49:44,580 --> 00:49:51,360
好问题，有几个原因，为什么我们需要这么做或者为什么 xv6 需要它，

536
00:49:51,360 --> 00:49:54,060
一个是当它设置初始化页面时，

537
00:49:54,980 --> 00:50:01,310
它需要对三级页表编程，所以它需要模拟三级页表。

538
00:50:02,120 --> 00:50:09,620
另一个例子，你在 syscall 实验中遇到或正在遇到的，

539
00:50:09,800 --> 00:50:11,270
是当你复制，

540
00:50:11,420 --> 00:50:17,480
在 xv6 中，内核有自己的页表，每个用户地址空间有自己的页表，

541
00:50:18,140 --> 00:50:25,250
有时，比如 sysinfo ， sysinfo 结构体存在于用户空间中，

542
00:50:25,460 --> 00:50:29,570
内核需要转换地址让它自己可以读写那个地址。

543
00:50:30,340 --> 00:50:34,420
所以，比如，如果你查看 copyin 或 copyout ，

544
00:50:34,750 --> 00:50:45,790
内核转换用户虚拟地址，使用用户页表获取物理地址，

545
00:50:45,790 --> 00:50:52,030
然后内核获得一个可以用来读写内存地址。

546
00:50:54,570 --> 00:50:59,730
所以，有很多地方可以展示，希望我可以在 10 到 15 分钟内讲到。

547
00:51:00,610 --> 00:51:06,430
我有一个问题，为什么硬件不开放那个 walk 函数，

548
00:51:06,430 --> 00:51:09,130
让我们不需要自己实现，可能还有 bug ，

549
00:51:09,430 --> 00:51:15,970
为什么没有比如一个特权指令，你可以传入虚拟地址，返回物理地址。

550
00:51:16,380 --> 00:51:21,300
好的，这就像存入虚拟地址，然后返回，它会为你做好，

551
00:51:21,780 --> 00:51:27,720
所以，我们会在后面的页表实验中看到，

552
00:51:27,900 --> 00:51:32,250
实际上，这是你们要做的，你么要以稍微不同的方式设置页表，

553
00:51:32,250 --> 00:51:36,750
让你们可以在 copyin 和 copyinstr 中避免 walk 。

554
00:51:42,500 --> 00:51:46,730
我想这个在我们过一会讨论 xv6 时，会变的更清楚。好吗？

555
00:51:49,700 --> 00:51:51,170
好的。

556
00:51:51,800 --> 00:51:58,100
在进入 xv6 之前，我想再说一点，

557
00:51:58,610 --> 00:52:04,000
考虑页表的一种方式，

558
00:52:05,980 --> 00:52:14,520
一种流行的说法，页表提供了某种间接性，

559
00:52:19,670 --> 00:52:31,070
这种间接性是我说过的从虚拟地址到物理地址的映射，

560
00:52:31,520 --> 00:52:36,230
这个映射完全在操作系统的控制中，

561
00:52:38,350 --> 00:52:41,980
像我们看到的，之前几张幻灯片所说的，

562
00:52:42,280 --> 00:52:49,270
这意味着操作系统，因为它完全控制（页表）转换，

563
00:52:49,480 --> 00:52:51,940
它可以做各种有意思的技巧。

564
00:52:52,630 --> 00:52:56,860
比如，一种技巧是，我会在后面讲到，

565
00:52:56,860 --> 00:53:04,270
如果一个页面条目是无效的，硬件会返回页面错误。

566
00:53:04,820 --> 00:53:10,910
作为回应页面错误，操作系统可以更新页表，然后重新执行该指令。

567
00:53:11,610 --> 00:53:18,630
所以通过操纵页表，可以在运行时做很多事情。

568
00:53:19,160 --> 00:53:26,480
我们不会在今天讨论，但是两周后，我们有一节课专门讨论这个主题，

569
00:53:26,480 --> 00:53:30,290
关于有了页表和页面错误，你可以做什么很酷的事情。

570
00:53:31,140 --> 00:53:38,250
但是要记得，这是一种令人难以置信的强大机制，

571
00:53:38,520 --> 00:53:42,510
可以给操作系统带来极大的灵活性。

572
00:53:43,410 --> 00:53:46,320
这也是页表如此流行的一个原因。

573
00:53:49,490 --> 00:53:53,750
好的，下面我要讲的是 xv6 ，

574
00:53:54,580 --> 00:53:59,080
看看这些在 xv6 中是如何发生的。

575
00:53:59,610 --> 00:54:05,700
我要做的第一件事是查看内核页表布局，

576
00:54:05,730 --> 00:54:09,870
它的映射在这张幻灯片上，

577
00:54:10,410 --> 00:54:21,610
这边是内核的虚拟地址空间，

578
00:54:23,440 --> 00:54:28,330
这边是物理内存，你可以把它认为是 DRAM ，

579
00:54:31,760 --> 00:54:35,690
而实际上并不是，让我来退回一点，

580
00:54:35,870 --> 00:54:41,200
一部分是 DRAM ，还有一部分是 IO 设备。

581
00:54:46,060 --> 00:54:52,030
我先讲一下幻灯片的右边的物理内存部分，

582
00:54:52,030 --> 00:54:53,740
过一会讲左边的部分。

583
00:54:54,360 --> 00:54:58,290
幻灯片的右边部分完全是由硬件决定的，

584
00:54:58,940 --> 00:55:02,900
硬件设计师决定它的布局，

585
00:55:02,960 --> 00:55:10,850
像你上周看到的，当内核启动后，它从 0x8000 开始，

586
00:55:11,720 --> 00:55:14,840
这是由硬件设计师决定的，

587
00:55:15,140 --> 00:55:20,420
所以你应该很清楚，如果你查看这块电路板，

588
00:55:20,510 --> 00:55:26,240
这跟我在周一展示的图片很类似，但是更好一点，更容易观察，

589
00:55:26,300 --> 00:55:31,570
这里是 RISC-V 处理器，我们知道在处理器中有四个核心，

590
00:55:31,600 --> 00:55:35,470
还有一个 MMU ，还有一个 TLB ，

591
00:55:35,470 --> 00:55:40,150
或者多个 TLB ，每个 MMU 和每个核心有它自己的 TLB 。

592
00:55:40,800 --> 00:55:47,680
这里是 DRAM 芯片，电路板的设计者决定，

593
00:55:47,890 --> 00:55:53,110
当虚拟地址转换位物理地址之后，

594
00:55:53,200 --> 00:55:59,440
物理地址从 0x8000 开始，指向 DRAM 芯片。

595
00:56:00,660 --> 00:56:04,740
在 0x8000 以下的地址，可能指向不同的 IO 设备。

596
00:56:05,260 --> 00:56:12,130
所以，平台，电路板设计者决定了物理布局。

597
00:56:12,770 --> 00:56:17,210
我想你可以查看物理布局，让我来展示给你，

598
00:56:17,210 --> 00:56:25,670
所以这是我周一展示给你们的手册，

599
00:56:25,730 --> 00:56:32,140
我记得，如果你跳到 31 页。

600
00:56:32,810 --> 00:56:36,140
是的，是这一页，如果你向下滚动，

601
00:56:36,140 --> 00:56:41,900
这里展示了电路板的内存映射，

602
00:56:42,170 --> 00:56:45,470
我们可以看到零地址是保留的，没有任何东西，

603
00:56:46,000 --> 00:56:54,100
如果你继续向下滚动，会看到映射的很多不同东西的信息，

604
00:56:54,100 --> 00:56:59,200
比如，以太网映射在 0x 某个地址，

605
00:57:00,010 --> 00:57:04,720
如果你继续向下，糟糕，太过了，

606
00:57:05,020 --> 00:57:14,800
这里你可以看到 0x8000 ，它是 DDR 内存，片外易失性内存，

607
00:57:15,010 --> 00:57:18,010
它是 DRAM 芯片，我在上一张幻灯片中展示的。

608
00:57:19,520 --> 00:57:24,200
所以你要知道，即使我们讲的是 QEMU ，使用软件（模拟的），

609
00:57:24,230 --> 00:57:28,100
最终任何东西都是由实际的电路板决定的。

610
00:57:30,640 --> 00:57:38,150
好的，回到我的幻灯片，我们来看看这个布局。

611
00:57:38,180 --> 00:57:39,890
是的， Noah ，继续。

612
00:57:41,360 --> 00:57:44,330
是的，当你说这个布局是由硬件决定的，

613
00:57:44,330 --> 00:57:50,720
你说的是 CPU 自己还是 CPU 所在的电路板。

614
00:57:50,780 --> 00:57:52,700
是 CPU 所在的电路板，

615
00:57:52,700 --> 00:57:59,210
因为 CPU 是这个方块中的那个灰色的东西，比如 RISC-V ，

616
00:57:59,450 --> 00:58:04,430
DRAM 芯片在处理器旁边，

617
00:58:04,430 --> 00:58:09,950
是电路板设计者把芯片， DRAM ，很多 IO 设备放在一起。

618
00:58:11,580 --> 00:58:12,030
了解了，谢谢。

619
00:58:12,030 --> 00:58:14,550
操作系统是有很多部分组成的，

620
00:58:14,550 --> 00:58:18,390
CPU 是其中之一，但是 IO 设备也同样重要，

621
00:58:18,390 --> 00:58:23,670
所以当你编写操作系统时，既要处理 CPU ，也要处理 IO 设备，

622
00:58:23,670 --> 00:58:25,680
如果你想通过互联网发送一个包，

623
00:58:25,920 --> 00:58:31,980
必须有人接手，网络驱动， NIC 卡会去做这个，

624
00:58:31,980 --> 00:58:32,970
这才是操作系统。

625
00:58:35,430 --> 00:58:40,350
所以，回到这张图片的右侧，就是物理地址布局，

626
00:58:40,530 --> 00:58:45,390
我们看到底部没有使用，像我在文档中展示的那样，

627
00:58:45,720 --> 00:58:50,040
它的 0x1000 物理地址是 boot ROM ，

628
00:58:50,040 --> 00:58:55,470
所以，当你启动电路板，第一件事就是运行 boot ROM 里面的代码。

629
00:58:55,930 --> 00:59:00,310
当 boot ROM 完成后，它会跳转到 [0x8000] ，

630
00:59:00,490 --> 00:59:04,690
操作系统的工作是需要确保那里有一些数据。

631
00:59:05,430 --> 00:59:08,280
然后，我们还要讨论一些其他设备，

632
00:59:08,280 --> 00:59:13,020
这是中断控制器，我们会在下周讨论，

633
00:59:13,500 --> 00:59:19,290
这是 CLINT ，我们在下周讨论的关于中断的另一个[故事]，

634
00:59:19,470 --> 00:59:21,960
基本上是，多种设备可以产生中断，

635
00:59:21,960 --> 00:59:26,760
所以需要一种方案来路由这些中断到合适的[请求]级别，

636
00:59:26,760 --> 00:59:30,000
这些都是由中断控制器实现的。

637
00:59:30,530 --> 00:59:35,690
稍等一下，让我先讲完这个幻灯片，再回答问题。

638
00:59:36,980 --> 00:59:46,850
这里有一个 UART ，它是与 console 和显示器交互的设备，

639
00:59:47,090 --> 00:59:54,680
这里是 VIRTIO_disk ，属于，它与磁盘交互，

640
00:59:54,860 --> 01:00:03,720
所以当你写入到地址，比如 0x2000 ，这个地址对应 CLINT ，

641
01:00:03,810 --> 01:00:12,330
所以，当你运行保存指令，加载指令，你就是在读写实现 CLINT 的芯片，

642
01:00:13,190 --> 01:00:16,130
我们后面会看这是什么意思，现在你可以认为是，

643
01:00:16,130 --> 01:00:19,820
这是直接与设备交互，而不是读写物理内存。

644
01:00:21,780 --> 01:00:22,650
是的，有什么问题。

645
01:00:24,240 --> 01:00:32,370
所以，我想确认一下 0x8000 以下的地址不存在与 DRAM 中，

646
01:00:33,660 --> 01:00:37,170
如果我们使用这些地址，它们直接指向其他硬件。

647
01:00:37,200 --> 01:00:39,900
是的，回到这张图片，

648
01:00:40,350 --> 01:00:46,660
任何 0x8000 以上的（地址），是 DRAM 芯片。

649
01:00:48,020 --> 01:00:54,710
我不能画出，指出 CLINT ，但是这里是以太网（控制器），

650
01:00:55,980 --> 01:01:01,590
所以这个可写的特殊物理地址，可以（执行）加载保存指令，称为内存映射 IO ，

651
01:01:01,800 --> 01:01:05,340
我们可以（执行）加载保存指令，对以太网卡编程。

652
01:01:09,340 --> 01:01:16,780
我也有一个问题，为什么顶部的很大一块是没有使用，为什么不使用。

653
01:01:17,110 --> 01:01:27,320
好的，你记得不是所有机器，这里是 2 的 56 次方物理地址空间，

654
01:01:27,770 --> 01:01:32,300
但是如果你不需要，你不会在板上插入那么多内存，

655
01:01:32,940 --> 01:01:38,270
所以一些部分没有使用，取决于板上实际有多少 DRAM 芯片。

656
01:01:42,300 --> 01:01:51,190
实际上，在 xv6 中，我想我们只有 128 MB （内存）。

657
01:01:55,360 --> 01:02:03,070
当加载保存指令从 CPU 发出时，

658
01:02:03,100 --> 01:02:09,960
它如何知道路由到对应的 IO ，是已经在 CPU 中了吗，

659
01:02:10,140 --> 01:02:13,590
比如，在 CPU 发出之前，

660
01:02:13,590 --> 01:02:20,310
它知道如果小于 0x8000 ，然后就发送到对应的 IO 设备，

661
01:02:20,310 --> 01:02:26,580
否则就发送到内存，比如 DRAM 芯片。

662
01:02:27,050 --> 01:02:32,900
是的，你可以认为有一个分解器在 RISC-V 块中。

663
01:02:33,230 --> 01:02:36,180
噢，它也在那个块中。好的。

664
01:02:38,140 --> 01:02:41,170
然后，内存管理器进行路由。

665
01:02:44,750 --> 01:02:47,420
好的，弄清楚这些很重要。

666
01:02:51,430 --> 01:02:55,150
好的，现在我想切换到这张图片的左边，

667
01:02:55,630 --> 01:03:02,560
这是 xv6 设置的虚拟地址空间，

668
01:03:02,560 --> 01:03:06,640
当机器启动时，还没有页面，

669
01:03:06,760 --> 01:03:12,310
xv6 设置第一个页表，第一个虚拟地址空间，

670
01:03:12,310 --> 01:03:16,770
是内核使用的虚拟地址空间，我们过一会会在代码中看到，

671
01:03:17,100 --> 01:03:19,410
这是它的布局，

672
01:03:19,440 --> 01:03:25,650
因为我们想让 xv6 保持简单，容易理解，

673
01:03:25,980 --> 01:03:32,430
所以虚拟到物理的映射主要是恒等映射。

674
01:03:38,120 --> 01:03:46,190
基本上它的意思是，虚拟地址 0x2000 映射到物理地址 0x2000 ，

675
01:03:46,280 --> 01:03:49,610
内核使用这种方法设置页表，

676
01:03:49,880 --> 01:03:54,830
这意味着，所有在 PHYSTOP 之下的虚拟地址，

677
01:03:55,810 --> 01:04:02,620
PHYSTOP 是对应于右边的物理地址的最高物理内存。

678
01:04:03,170 --> 01:04:07,220
这也是为什么这些箭头都是直的，因为是恒等映射。

679
01:04:09,290 --> 01:04:09,860
好的？

680
01:04:10,830 --> 01:04:16,680
这里有一些小的改变，有两个东西要说。

681
01:04:17,620 --> 01:04:19,930
Amiar ，稍等一会。

682
01:04:19,930 --> 01:04:23,020
我想先说一下两件重要的东西。

683
01:04:23,500 --> 01:04:35,040
首先，有一些页面，一些映射在内存中位置非常高，

684
01:04:35,070 --> 01:04:42,030
比如，内核栈位于内存的比较高的位置。

685
01:04:42,500 --> 01:04:47,330
它在内存中很高的原因是，我们有一个没有映射的守护页在它下面。

686
01:04:47,840 --> 01:04:55,190
所以，内核栈下面的 PTE 条目没有设置有效位。

687
01:04:55,700 --> 01:05:01,550
所以，如果内核栈溢出，会导致页面错误，

688
01:05:01,820 --> 01:05:05,900
这比乱改内核的其他内存要好，

689
01:05:06,080 --> 01:05:08,870
你得到一个 panic ，你就知道栈出问题了。

690
01:05:10,820 --> 01:05:16,700
当然，我们不想浪费物理内存，所以我们把栈放地很高，

691
01:05:16,940 --> 01:05:22,100
再放一个空的 PTE 守护页在它下面，

692
01:05:22,600 --> 01:05:26,770
守护页不会真正消耗物理内存，

693
01:05:26,770 --> 01:05:30,490
位于虚拟地址空间的高位，所以没有东西消耗。

694
01:05:31,190 --> 01:05:34,970
但是，这也意味着栈页面映射了两次，

695
01:05:35,360 --> 01:05:41,180
一次映射在高地址，一次直接映射在 PHYSTOP 下面的一个地址。

696
01:05:42,590 --> 01:05:48,230
这是页表可以做的所有很酷的事情之一，

697
01:05:48,230 --> 01:05:52,490
你可以映射两次物理地址，也可以不映射物理地址，

698
01:05:52,610 --> 01:05:58,340
它可以是一对一映射，一对多映射，多对多映射，所有这些都可以。

699
01:05:58,930 --> 01:06:03,640
xv6 在很多地方都用到了这些技巧，

700
01:06:03,850 --> 01:06:10,900
守护页是 xv6 使用的很酷的技巧之一，主要用来追踪 bug 。

701
01:06:12,880 --> 01:06:15,730
我想说的第二个东西是权限。

702
01:06:16,590 --> 01:06:23,550
比如，内核文本页面映射位 R-X ，意思是可以读取和执行，

703
01:06:23,760 --> 01:06:29,280
但是你不能写入内核文本，这也是为了避免 bug ，让我们可以尽早捕获它们，

704
01:06:29,430 --> 01:06:34,020
内核数据当然需要写入，所以它映射为 RW- ，

705
01:06:34,230 --> 01:06:42,480
但是你不能执行内核数据页指令，所以执行位没有设置。

706
01:06:45,950 --> 01:06:46,790
这些能理解吗？

707
01:06:48,000 --> 01:06:52,890
我跳过了一两个问题，如果还没有解决，现在可以问。

708
01:06:55,790 --> 01:06:58,010
我们在聊天窗口中有一个问题，

709
01:06:58,620 --> 01:07:04,350
我们是否有多个内核栈对于不同的进程，比如 n 个 kstack 对 n 个进程。

710
01:07:06,790 --> 01:07:14,720
是的，每个用户进程有一个对应的内核栈，我们过一会会看到。

711
01:07:17,350 --> 01:07:17,980
好的？

712
01:07:19,160 --> 01:07:21,290
好的，让我。

713
01:07:21,320 --> 01:07:22,250
Amair ，继续。

714
01:07:24,010 --> 01:07:32,130
所以，其他应用程序的虚拟内存映射在没有使用的物理内存上，还是。

715
01:07:32,430 --> 01:07:37,470
是的，很好的观点，这里有很多虚拟内存，

716
01:07:37,470 --> 01:07:42,190
这里是空闲内存，这里也是空闲内存，

717
01:07:42,610 --> 01:07:50,050
xv6 使用这些空闲内存保存页表和用户进程的页面，

718
01:07:50,200 --> 01:07:54,550
还有用户进程的文本和数据。

719
01:07:55,780 --> 01:07:58,480
如果某个时刻我们有很多用户程序，

720
01:07:58,480 --> 01:08:03,040
会出现内存溢出，然后 fork 或 exec 会返回错误。

721
01:08:04,900 --> 01:08:11,890
但是，这意味着（用户）进程的的虚拟空间比内核的虚拟空间小得多，是吗？

722
01:08:12,540 --> 01:08:18,660
理论上，虚拟空间大小是一样的，但是它会[占用]更少。

723
01:08:22,520 --> 01:08:26,480
让我们看看代码，我想所有这些东西会变得更清楚。

724
01:08:27,690 --> 01:08:31,020
我有一个小问题，

725
01:08:31,020 --> 01:08:38,040
有很多进程，让每个进程一大部分内存映射到相同位置，

726
01:08:38,130 --> 01:08:44,550
是否把这些映射合并在一起是一种优化。

727
01:08:44,580 --> 01:08:47,280
好的， xv6 没有做这个，

728
01:08:47,370 --> 01:08:52,380
在页表实验练习中的一个挑战就是实现这个。

729
01:08:54,540 --> 01:08:55,020
我知道了。

730
01:08:55,170 --> 01:09:01,020
真正的操作系统会做这个，是的，好问题。

731
01:09:02,320 --> 01:09:05,950
我想你知道了，有了页表，任何事情都是可能的。

732
01:09:08,800 --> 01:09:14,850
好的，我们开始平常的事情，再次启动 xv6 ，

733
01:09:14,850 --> 01:09:20,980
你知道 QEMU 用来模拟那个电路板，让我们。

734
01:09:21,670 --> 01:09:27,800
糟糕， -gdb 。

735
01:09:29,930 --> 01:09:33,710
上次，我们看了启动是什么样的，

736
01:09:33,710 --> 01:09:44,600
然后到了 main ，然后是内核的一个函数 kvminit ，它设置了内核地址空间。

737
01:09:45,100 --> 01:09:49,330
我们在上一张幻灯片的图片中看到它的样子，

738
01:09:49,330 --> 01:09:52,390
这里我们看 C 代码，它实际是如何设置的。

739
01:09:58,380 --> 01:10:03,750
为什么，稍等一下，有些东西不像我想那样。

740
01:10:04,350 --> 01:10:06,720
我在对的目录吗。

741
01:10:11,120 --> 01:10:14,210
稍等一会，我来解决一下这个问题。

742
01:10:16,590 --> 01:10:23,390
这是好的，我是说在对的目录。

743
01:10:23,420 --> 01:10:26,450
是的， -gnu-gdb 。

744
01:10:28,080 --> 01:10:35,640
我在 main 设置一个断点来验证，好的，然后我在 kvminit 设置一个断点。

745
01:10:36,340 --> 01:10:37,840
我现在可以单步运行到那里，

746
01:10:38,430 --> 01:10:42,480
下一个 consoleinit printfinit ，我们之前看到过。

747
01:10:43,250 --> 01:10:45,080
物理内存分配器，

748
01:10:47,040 --> 01:10:59,120
发生了我不希望发生的事，怎么回事。

749
01:11:02,660 --> 01:11:04,610
在上课之前是好的。

750
01:11:04,610 --> 01:11:11,140
这里，应该这样，输出（这些东西），好的，有意思。

751
01:11:11,620 --> 01:11:15,580
好的，再一次看看我是不是更幸运，糟糕。

752
01:11:19,280 --> 01:11:20,360
[].

753
01:11:28,890 --> 01:11:33,670
继续，希望能运行到那里，稍等一下。

754
01:11:33,670 --> 01:11:35,530
好的，我们到了 kvminit ，

755
01:11:35,860 --> 01:11:40,660
我们现在在这个函数里，你可以在右边的 emacs 缓存中看到。

756
01:11:41,260 --> 01:11:48,540
我想我已经稍微修改了这个函数，希望我改过了。

757
01:11:53,140 --> 01:11:55,450
我想我改过了，好的，一会会看到，

758
01:11:55,900 --> 01:11:59,350
我们要做的是单步执行这个函数，

759
01:12:00,070 --> 01:12:03,070
使用分隔布局，更容易观察。

760
01:12:03,650 --> 01:12:09,200
首先，内核为顶级页面目录分配了一个物理页面，

761
01:12:10,090 --> 01:12:14,560
然后将其置零，所以所有 PTE 条目都是零。

762
01:12:15,360 --> 01:12:21,000
然后映射每个 IO 设备，一个接一个。

763
01:12:21,630 --> 01:12:27,960
比如， UART0 映射到内核地址空间，

764
01:12:27,960 --> 01:12:30,930
我们可以看一下 memlayout.h 文件，

765
01:12:31,320 --> 01:12:37,350
它将那个文档中的第 31 页转换成很多我们要用的常量。

766
01:12:38,020 --> 01:12:46,650
比如，这里有地址 0x1000 是 URAT0 的地址。

767
01:12:47,140 --> 01:12:55,300
我们可以把它映射到地址空间，通过调用 kvmmap 函数，稍后会看到。

768
01:12:56,040 --> 01:13:03,810
在页表实验的第一个练习中，要求你们实现一个 vmprint 函数，

769
01:13:04,320 --> 01:13:08,010
我也实现了它，我会单步跳过它，

770
01:13:08,010 --> 01:13:16,700
我们会看到内核页表在调用 kvmmap 之后是如何设置的，

771
01:13:16,730 --> 01:13:19,520
我会单步执行，将会打印一些东西。

772
01:13:20,240 --> 01:13:22,160
我们来看看这些输出，

773
01:13:22,160 --> 01:13:30,200
这是页表，这个是顶级页面目录的物理地址，

774
01:13:30,200 --> 01:13:33,770
就是位于 satp 的东西。

775
01:13:34,600 --> 01:13:38,890
我们有一个顶级页面目录的条目 0 ，

776
01:13:38,890 --> 01:13:48,000
它里面也有一个 PTE 条目，包含着中级页表目录的物理地址，

777
01:13:48,580 --> 01:13:55,180
中级页面目录包含一个条目 128 ，指向底部页表目录，

778
01:13:55,180 --> 01:13:58,900
而底部页表目录包含指向物理地址的条目。

779
01:13:59,420 --> 01:14:07,430
可以看到，实际上这个物理地址是 0x1000 对应着 UART0 。

780
01:14:08,900 --> 01:14:15,620
所以，虚拟地址 1000 转换位物理地址 1000 。

781
01:14:16,560 --> 01:14:21,270
我们可以确认一下所有都是正确的，

782
01:14:21,270 --> 01:14:30,720
我们用这个地址 0x10000000L ，对它右移 12 位，

783
01:14:31,700 --> 01:14:38,420
得到高位的 27 位，

784
01:14:39,070 --> 01:14:50,690
再右移 9 位，我用 0x10000 ，右移 9 位，并打印，

785
01:14:53,010 --> 01:14:59,700
结果是 0x80 ，按十进制打印 0x80 ，就是 128 。

786
01:15:01,110 --> 01:15:01,710
好的？

787
01:15:02,310 --> 01:15:05,370
所以，我们看到这些都是有道理的。

788
01:15:05,900 --> 01:15:09,440
在这我们也打印出了标志位，

789
01:15:09,440 --> 01:15:19,520
底部（条目）包含读，写，有效，因为有效位是 1 。关于这个有什么问题吗？

790
01:15:24,760 --> 01:15:32,970
好的，所以内核继续用这个方式设置整个地址空间。

791
01:15:33,820 --> 01:15:38,860
所以，我们对 VIRTIO CLINT PLIC 调用 kvmmap ，

792
01:15:39,440 --> 01:15:44,300
映射内核文本，映射内核数据，

793
01:15:44,480 --> 01:15:46,880
然后是 TRAMPOLINE 页面，我们会在下周讨论它。

794
01:15:47,460 --> 01:15:53,550
我们可以单步执行这个，看看最后的页面目录是什么样的。

795
01:15:55,610 --> 01:15:58,520
所以，下一步，下一步，下一步，下一步。

796
01:15:59,330 --> 01:16:03,650
我们设置了 trampoline ，所以现在可以打印整个页表目录。

797
01:16:04,220 --> 01:16:11,420
我们看到很多 PTE 被设置了，

798
01:16:11,810 --> 01:16:14,690
我不会讲太多细节，

799
01:16:14,870 --> 01:16:23,260
基本上就是填充页面目录，创建一个我们在上一张幻灯片看到的虚拟（地址）映射。

800
01:16:24,810 --> 01:16:29,070
下一步我想做的（事情）更有趣。

801
01:16:29,690 --> 01:16:30,860
是的，我要做的是。

802
01:16:32,270 --> 01:16:35,330
是的，我想到这里，或者我已经到了，

803
01:16:35,360 --> 01:16:39,170
这是 21 行，不，我在 21 行，好的，单步执行。

804
01:16:40,550 --> 01:16:47,620
好的，它已经过去了，但是，让我来重启一下。

805
01:16:51,080 --> 01:17:01,660
我想在 kvminithart 设置一个断点，然后继续。

806
01:17:03,680 --> 01:17:10,280
现在我在 kvminithart 了，在这里可以看到，它写入 satp 寄存器，

807
01:17:10,310 --> 01:17:18,560
所以，内核在启用页表，让 MMU 可以使用我们刚才设置的页表。

808
01:17:19,470 --> 01:17:25,470
一个有趣的问题，好的，我再次切换到分隔模式，

809
01:17:26,020 --> 01:17:33,730
这里的某个地方，是这条指令，

810
01:17:33,940 --> 01:17:41,240
执行这条指令之后，会发生一件非常激动人心的事情。

811
01:17:42,280 --> 01:17:46,360
比如说，完全相同的指令，

812
01:17:46,360 --> 01:17:53,200
但是一旦执行这条指令，转换下一条地址会发生什么。

813
01:17:58,310 --> 01:18:06,050
好的，在执行这条指令之前，还没有启动页表，所以也没有转换，

814
01:18:06,410 --> 01:18:12,080
然后程序计数器加 4 ，然后下一条指令执行，

815
01:18:12,110 --> 01:18:16,220
这时，程序计数器就会使用虚拟页表内存来转换。

816
01:18:17,140 --> 01:18:21,280
所以，你可以认为，这是一个激动人心的时刻，

817
01:18:21,610 --> 01:18:25,360
因为整个地址转换被启用，

818
01:18:25,360 --> 01:18:29,870
每个地址都可能不一样了，

819
01:18:29,870 --> 01:18:34,760
因为在运行（这条指令）之前，使用物理地址，还没有页表和映射，

820
01:18:34,760 --> 01:18:37,340
现在有了虚拟地址的新含义。

821
01:18:38,680 --> 01:18:42,820
实际上这个成果是非常显著的，

822
01:18:42,820 --> 01:18:47,650
因为下一条指令，下一个值是虚拟地址，而不是物理地址，

823
01:18:48,700 --> 01:18:52,090
下一条指令将是 0x80001110 。

824
01:18:52,760 --> 01:18:54,050
为什么这个能成功。

825
01:18:55,960 --> 01:18:59,650
好的，成功的原因是内核设置的页面恒等映射，

826
01:18:59,710 --> 01:19:03,510
在启用虚拟页面硬件之后，

827
01:19:03,750 --> 01:19:08,100
这个转换器会转换成相同的物理地址，

828
01:19:08,250 --> 01:19:12,870
所以，最终我们会执行正确的指令，

829
01:19:12,960 --> 01:19:17,520
因为那条指令通过虚拟硬件[编程]后的内存位置。

830
01:19:19,120 --> 01:19:20,170
这个能理解吗？

831
01:19:22,920 --> 01:19:27,060
再一次，使用虚拟内存编程困难的一个原因是，

832
01:19:27,060 --> 01:19:34,230
因为一旦你执行 satp 指令，加载页表到 satp 寄存器中，

833
01:19:34,260 --> 01:19:36,180
你的世界就完全改变了。

834
01:19:36,690 --> 01:19:40,350
现在每个地址都会使用你设置的页表进行转换。

835
01:19:41,560 --> 01:19:46,990
所以，如果页表设置错误，会发生什么。

836
01:19:53,660 --> 01:19:57,880
有人想回答，或在聊天窗口中回答。

837
01:20:00,510 --> 01:20:02,250
你可能覆盖内核数据。

838
01:20:02,980 --> 01:20:05,020
是的，你可能覆盖内核数据，还会发生什么呢，

839
01:20:05,020 --> 01:20:12,010
是的，页面错误，映射可能错误，地址不能转换，

840
01:20:12,010 --> 01:20:16,480
所以，内核，硬件不会这样做，造成内核停止或死机。

841
01:20:18,770 --> 01:20:19,610
这个能理解吗？

842
01:20:21,000 --> 01:20:27,830
如果你在页表中有 bug ，你会看到这些错误或崩溃。

843
01:20:28,720 --> 01:20:29,920
所以，一个原因，

844
01:20:29,920 --> 01:20:35,980
下一个实验，今晚放出的页表实验比较难，

845
01:20:35,980 --> 01:20:37,630
因为这些 bug 会出现。

846
01:20:38,200 --> 01:20:42,130
如果你不够细心，或者你没有完全理解某些方面，

847
01:20:42,520 --> 01:20:46,690
你可能会遇到内核崩溃，陷入困境之中，

848
01:20:46,690 --> 01:20:52,000
需要花一些时间和精力来调试追踪发生（这种情况）的原因。

849
01:20:53,370 --> 01:20:57,640
这就是虚拟内存编程的难点。

850
01:20:58,320 --> 01:21:04,680
因为它是强大的，[原始的]，如果你错了，会产生严重的后果。

851
01:21:08,090 --> 01:21:13,160
不过，另一方面，它是非常有趣的，我不想以负面结束，

852
01:21:13,310 --> 01:21:18,590
但是，所有这些都让你真正理解虚拟内存，以及它能做什么。

853
01:21:20,180 --> 01:21:22,760
好的，我想我已经超时了，所以，我准备在这里结束，

854
01:21:22,820 --> 01:21:25,820
让大家可以去下一节课或下一个活动，

855
01:21:26,060 --> 01:21:30,470
但是如果你还有任何问题，请稍等，并提问。

856
01:21:31,440 --> 01:21:38,130
周一见，祝你们顺利完成 syscall 实验。

857
01:21:40,920 --> 01:21:43,860
我有一个关于 walk 的问题，

858
01:21:44,190 --> 01:21:53,720
在代码中，返回 PTE 的第一张表，

859
01:21:53,960 --> 01:22:03,460
但是，它是如何工作的，比如其他函数希望真正的 PTE 而不是物理地址。

860
01:22:05,680 --> 01:22:11,620
是的，这个返回页表的 PTE 条目。

861
01:22:12,140 --> 01:22:19,000
内核可以读写页表条目，你现在可以把值放入 PTE 中。

862
01:22:21,180 --> 01:22:25,680
我可以画一张图，来帮助理解。

863
01:22:26,330 --> 01:22:26,900
让我们来看一下。

864
01:22:35,770 --> 01:22:37,690
所以，我们有一个页面目录，

865
01:22:45,000 --> 01:22:48,130
这个 walk 代码，

866
01:22:48,130 --> 01:22:58,910
页面目录有 512 个 PTE ，这是 0 ，这是 511 ，

867
01:22:59,570 --> 01:23:05,120
这个函数的作用是，返回一个指针指向这些 PTE 中的一个，

868
01:23:06,040 --> 01:23:09,520
这只是一个虚拟地址，指向那个特定的 PTE 。

869
01:23:10,210 --> 01:23:15,490
现在内核可以通过写入值来操纵这个 PTE ，

870
01:23:16,020 --> 01:23:22,130
比如（写入）一些物理地址，包括后面的十位权限位。

871
01:23:23,730 --> 01:23:29,340
然后更新页表目录，然后当你把它加载到 satp 中，

872
01:23:29,880 --> 01:23:32,490
这一修改会生效。

873
01:23:35,350 --> 01:23:36,250
这个能理解吗？

874
01:23:37,180 --> 01:23:38,110
是的，能理解。

875
01:23:38,110 --> 01:23:47,620
我想我的问题是为什么它遍历了三个页表，然后只返回第一个 PTE 。

876
01:23:47,890 --> 01:23:53,430
不，返回的是最后一个，让我来仔细一点，

877
01:23:55,350 --> 01:24:00,930
它通过 n 级，从 2 级开始，然后 1 级，再到 0 级，

878
01:24:01,730 --> 01:24:09,740
如果设置了 alloc 位，并且那一级不存在，它会创建一个中间页表目录，

879
01:24:10,580 --> 01:24:13,040
把它置零，然后继续查找。

880
01:24:13,770 --> 01:24:17,580
所以，你总是找到底部 PTE ，

881
01:24:18,580 --> 01:24:23,440
如果 alloc 没有设置，你在第一个 PTE 停止，它没有值。

882
01:24:25,560 --> 01:24:30,270
好的，有道理，这是最后一个，实际上，好的。

883
01:24:31,410 --> 01:24:32,610
好的，谢谢。

884
01:24:36,820 --> 01:24:37,840
还有别的问题吗？

885
01:24:40,820 --> 01:24:45,110
我有一个问题，所有东西都能理解，

886
01:24:45,140 --> 01:24:50,420
直到我们将内核虚拟地址映射到物理地址。

887
01:24:53,800 --> 01:24:57,880
我的理解是，每个进程有它自己的页表，

888
01:24:57,880 --> 01:25:03,520
也是一个三级树，映射它的虚拟地址到物理地址，

889
01:25:03,730 --> 01:25:08,050
但是，当我们把内核虚拟地址映射到物理地址，

890
01:25:08,140 --> 01:25:14,140
我想我们没有考虑到内核虚拟地址[实际的树]，

891
01:25:14,170 --> 01:25:19,150
其他进程的虚拟地址在哪里，

892
01:25:19,390 --> 01:25:29,950
抱歉，是页表树，页表树在物理内存中指向哪里。

893
01:25:30,430 --> 01:25:38,140
是的，所以，回到这张关于内核虚拟地址空间的幻灯片，

894
01:25:38,470 --> 01:25:44,720
当内核分配一个 proc 和为它准备的页表，

895
01:25:44,720 --> 01:25:49,760
它们会分配在内存的这里，没有使用的内存。

896
01:25:50,870 --> 01:26:00,170
内核可能会为用户程序页表分配一些页面，并填充 PTE 。

897
01:26:01,460 --> 01:26:04,640
到了内核运行进程的时候，

898
01:26:04,880 --> 01:26:15,640
它会加载分配给页表的这些页面的根物理地址到 satp 寄存器。

899
01:26:16,660 --> 01:26:24,520
那时，处理器使用内核构建给这个进程的虚拟地址空间运行。

900
01:26:27,140 --> 01:26:32,270
所以，内核给了进程一些内存，

901
01:26:32,270 --> 01:26:41,770
但是，理论上进程的虚拟空间和内核的一样大，但是实际上不是。

902
01:26:42,450 --> 01:26:47,520
是的，这里有一张图片，是用户进程的虚拟地址空间布局，

903
01:26:47,580 --> 01:26:55,350
它也从 0 到 MAXVA ，和内核空间一样的做法，

904
01:26:55,770 --> 01:27:01,540
它有自己的页表，映射那些内核设置的转换。

905
01:27:03,190 --> 01:27:06,670
但是，我们不能使用所有 MAXVA 虚拟地址。

906
01:27:06,670 --> 01:27:08,950
是的，我们不能，我们会内存溢出。

907
01:27:11,620 --> 01:27:16,660
所以，很多进程都比所有虚拟地址空间小得多。

908
01:27:19,940 --> 01:27:20,690
我明白了，谢谢。

909
01:27:23,260 --> 01:27:25,000
我有一个问题。是的。

910
01:27:26,020 --> 01:27:28,120
你能回到 walk 代码吗？

911
01:27:28,450 --> 01:27:33,540
是的，当然，它是我最喜欢的函数之一。

912
01:27:35,280 --> 01:27:42,570
我想，我不理解的是，在你写 satp 寄存器之后，

913
01:27:42,960 --> 01:27:46,770
内核能直接访问物理地址吗，

914
01:27:46,770 --> 01:27:51,240
从代码中看起来，它转换页面到一个物理地址，

915
01:27:51,240 --> 01:27:56,990
但是，如果设置了 satp ，它不会解释为虚拟地址吗。

916
01:27:57,870 --> 01:28:04,830
是的，好的，让我们来看一下 hartinint ，

917
01:28:09,740 --> 01:28:14,500
kvminit ，构建内核地址空间，

918
01:28:16,340 --> 01:28:29,060
内核页表初始化物理-，地址转换为物理地址，并写入 satp 寄存器，

919
01:28:30,380 --> 01:28:38,090
这时，我们使用我们构建的地址空间运行，比如 kvminit 。

920
01:28:39,920 --> 01:28:49,270
kvmmap 只是对每个地址或每个页面调用 walk 。

921
01:28:50,340 --> 01:28:52,260
所以，你的问题是什么？

922
01:28:53,660 --> 01:29:00,260
我想，在设置 satp 之后，它仍然使用相同方式运行。

923
01:29:00,590 --> 01:29:01,850
是的，为什么。

924
01:29:04,590 --> 01:29:09,450
为什么能够成功，能成功的原因是内核（页表）设置是恒等映射。

925
01:29:11,380 --> 01:29:14,820
好的，是的，是的。

926
01:29:15,120 --> 01:29:22,320
很重要，很好的问题，很多事情可以成功，因为这是设置的恒等映射。

927
01:29:24,650 --> 01:29:28,330
我明白了，好的，我想我理解了，是的。

928
01:29:31,360 --> 01:29:37,840
我有一个问题， satp 在哪里存放所有进程的（页表地址）。

929
01:29:38,460 --> 01:29:44,040
每个核心只有一个 satp ，但是在每个 proc 结构体中。

930
01:29:44,780 --> 01:29:45,440
好的。

931
01:29:46,330 --> 01:29:56,100
如果你查看 proc.h ，这里有一个指向页表的指针。

932
01:29:56,160 --> 01:29:57,480
好的，理解了。

933
01:29:58,440 --> 01:30:03,420
也是关于三级页表，

934
01:30:03,420 --> 01:30:10,620
三级页表可以组成完整的地址，

935
01:30:11,040 --> 01:30:17,880
它比使用一个大页表好的地方是什么，我没有完全理解。

936
01:30:17,880 --> 01:30:19,950
好的，一个好问题，

937
01:30:20,040 --> 01:30:24,210
因为在三级页表中，你可以把很多条目留空，

938
01:30:25,060 --> 01:30:30,370
比如，如果你把顶级页表目录中的条目留空，

939
01:30:30,520 --> 01:30:36,070
你就不需要为这些条目创建中级页表或底部页表。

940
01:30:37,070 --> 01:30:43,220
这意味着整个虚拟地址空间的[]根本不需要任何映射。

941
01:30:44,860 --> 01:30:45,700
好的，好的。

942
01:30:45,700 --> 01:30:48,010
你不需要表，它不存在。

943
01:30:48,840 --> 01:30:55,140
我明白了，按需分配这些块，[]，好的，理解了。

944
01:30:55,170 --> 01:30:58,110
是的，你从三个页面开始，

945
01:30:58,110 --> 01:31:02,550
一个顶级，一个中级，一个底部，

946
01:31:03,180 --> 01:31:06,360
然后根据需要，可以创建更多的页表目录。

947
01:31:06,740 --> 01:31:08,000
好的，好的，酷。

948
01:31:09,140 --> 01:31:10,970
太好了，非常感谢。不用谢。

949
01:31:12,930 --> 01:31:14,010
还有别的问题吗？

950
01:31:14,690 --> 01:31:17,900
抱歉，我有另一个问题，一个很小的问题，

951
01:31:17,900 --> 01:31:26,150
但是在 vm.c 的第 43 行，第 41 行，

952
01:31:27,140 --> 01:31:30,650
它说，不，应该是 43 行，我的错，

953
01:31:30,680 --> 01:31:36,530
它说 PHYSTOP-(uint64)etext ，

954
01:31:36,590 --> 01:31:45,570
但是它不会访问我们不应该访问的内存吗，

955
01:31:45,600 --> 01:31:50,040
我不知道有没有道理，但是会这样吗，

956
01:31:51,220 --> 01:31:54,730
我想我不理解它会不会访问到空闲内存。

957
01:31:55,790 --> 01:32:08,400
不，我不这么认为， KERNBASE 0x8000 ，是内核在内存的起始位置，

958
01:32:08,430 --> 01:32:15,320
基本上，这个东西是一个大小，

959
01:32:15,320 --> 01:32:25,830
etext 是内核的最后一个地址，减去 KERNBASE ，得到内核的大小，

960
01:32:26,520 --> 01:32:33,060
我不知道是多少，但是可能是 60 或 90 个页。

961
01:32:34,300 --> 01:32:37,570
所以这个映射是内核文本。

962
01:32:38,350 --> 01:32:48,310
这里有足够的空间，有足够的 DRAM 来映射内核文本。

963
01:32:48,860 --> 01:32:50,540
我不确定我回答了你的问题，但是。

964
01:32:51,140 --> 01:32:57,380
我想，我理解了，我以为 etext 是从某个地方开始的，

965
01:32:57,380 --> 01:32:59,150
好的，我想我理解了，谢谢。

966
01:32:59,150 --> 01:33:02,870
好的， etext 是内核最后一条指令的地址。

967
01:33:03,670 --> 01:33:04,690
好的，好的。

