1
00:00:00,180 --> 00:00:03,590
And can everybody see my screen

2
00:00:03,710 --> 00:00:06,020
or the whiteboard that I shared.

3
00:00:06,890 --> 00:00:07,550
Okay, good.

4
00:00:09,250 --> 00:00:11,650
How are people doing with the lock lab,

5
00:00:11,680 --> 00:00:14,170
let me start there, just ask if,

6
00:00:15,740 --> 00:00:17,060
how progress

7
00:00:17,300 --> 00:00:20,900
and what its more difficult or it's looking okay.

8
00:00:21,680 --> 00:00:24,650
Anybody who want to report on their experience so far.

9
00:00:30,520 --> 00:00:32,560
I hope lots of people have started.

10
00:00:37,130 --> 00:00:37,430
Oh, I.

11
00:00:37,460 --> 00:00:39,920
Yeah, go ahead.

12
00:00:40,250 --> 00:00:41,390
Oh, sorry, go ahead.

13
00:00:42,050 --> 00:00:42,980
Okay, cool.

14
00:00:45,130 --> 00:00:46,660
I'll go, I'll go.

15
00:00:47,440 --> 00:00:48,610
The lock lab,

16
00:00:48,670 --> 00:00:57,420
I think the first part, the the kalloc was not as bad,

17
00:00:57,450 --> 00:01:01,830
well, and then the second part was a bit harder,

18
00:01:01,890 --> 00:01:04,800
well, it's a lot harder in my opinion.

19
00:01:06,180 --> 00:01:10,780
You just have to figure out a,

20
00:01:11,730 --> 00:01:16,530
I guess the hard part was thinking of a solution that,

21
00:01:17,460 --> 00:01:19,410
it's like hey this doesn't cause deadlock,

22
00:01:19,410 --> 00:01:26,300
but then if you think there are cases where like deadlock could happen

23
00:01:26,300 --> 00:01:30,350
if you acquire a [] it's lock again and all that stuff,

24
00:01:30,350 --> 00:01:30,710
but,

25
00:01:32,210 --> 00:01:34,520
yeah, I just have to think, you have to think

26
00:01:34,520 --> 00:01:37,280
like about extra cases and all that stuff

27
00:01:37,280 --> 00:01:39,200
and after that it shouldn't be that bad.

28
00:01:40,130 --> 00:01:43,910
Anybody else who want to share their experience so far?

29
00:01:44,240 --> 00:01:45,140
I want to ask,

30
00:01:45,140 --> 00:01:49,010
are we allowed to do any part of the lab like lock free,

31
00:01:49,010 --> 00:01:51,350
because I know like their first part,

32
00:01:51,350 --> 00:01:54,860
for example it's pretty the instructions said pretty clearly

33
00:01:54,860 --> 00:01:57,170
like make a parallel memory allocator,

34
00:01:57,170 --> 00:02:00,230
but can we do it just lock free

35
00:02:00,230 --> 00:02:03,410
and think, you know leave it as it is.

36
00:02:03,560 --> 00:02:06,920
You're free to do any solution to pass which made great,

37
00:02:07,700 --> 00:02:11,480
it's fine lock free,

38
00:02:11,480 --> 00:02:12,800
I would be,

39
00:02:12,830 --> 00:02:14,120
you are certainly free to do it.

40
00:02:14,510 --> 00:02:16,400
I'd be hesitant to start there,

41
00:02:16,430 --> 00:02:17,330
if I were you,

42
00:02:17,330 --> 00:02:21,110
I would start first with a more fine-grained lock implementation

43
00:02:21,110 --> 00:02:23,210
and then move to the lock free implementation.

44
00:02:24,140 --> 00:02:27,320
So the reason there is not started with a lock free,

45
00:02:27,320 --> 00:02:29,270
because if you go to a fine-grain,

46
00:02:29,270 --> 00:02:31,160
you need to do all of the parallel stuff,

47
00:02:31,160 --> 00:02:33,170
but if you just go directly to a lock free one,

48
00:02:33,170 --> 00:02:36,020
then you can keep it on a single free list

49
00:02:36,020 --> 00:02:40,940
and you just need to, you just need to [],

50
00:02:40,940 --> 00:02:43,070
the free and allocate operations,

51
00:02:43,070 --> 00:02:44,240
which actually isn't that bad.

52
00:02:45,120 --> 00:02:47,010
Yeah, I think maybe in a,

53
00:02:47,010 --> 00:02:49,020
if there's a single list in the case of the kalloc,

54
00:02:49,020 --> 00:02:49,890
that might be the case,

55
00:02:49,890 --> 00:02:54,030
I think you know the lock free [] is going to be a more complicated.

56
00:02:54,360 --> 00:02:56,580
Yeah, that I'm scared to do.

57
00:02:56,640 --> 00:02:59,730
But, that's the right reaction to have.

58
00:03:01,440 --> 00:03:02,520
Anybody else?

59
00:03:04,950 --> 00:03:08,370
I found it a bit hard to debug those problems,

60
00:03:08,370 --> 00:03:11,040
because it's not immediately clear what is happening,

61
00:03:11,040 --> 00:03:12,620
so we have to go

62
00:03:12,620 --> 00:03:18,090
and set with gdb and break break break, and yeah.

63
00:03:18,980 --> 00:03:20,900
Yeah, I think the only,

64
00:03:20,990 --> 00:03:23,300
one reason I'm always scared to get these lock labs,

65
00:03:23,300 --> 00:03:26,030
as I said, labs you know they're harder to debug,

66
00:03:26,510 --> 00:03:30,620
and you know the bug might not show up on every run.

67
00:03:31,200 --> 00:03:35,070
And but hopefully it is very educational,

68
00:03:35,070 --> 00:03:39,270
because learning a program locks inside the kernel is a real thing,

69
00:03:39,270 --> 00:03:43,050
and but it is definitely a core challenge.

70
00:03:44,100 --> 00:03:47,940
One thing about maybe there's a you know for the,

71
00:03:48,330 --> 00:03:52,680
of course, you know the next lab actually doesn't involve basically any concurrency,

72
00:03:53,040 --> 00:03:56,610
and should hopefully that will be much more straightforward.

73
00:03:59,760 --> 00:04:00,150
Okay.

74
00:04:00,150 --> 00:04:01,920
I gue-, I guess, how do you,

75
00:04:02,070 --> 00:04:07,410
how do you efficiently or effectively debug concurrent programs,

76
00:04:07,410 --> 00:04:10,950
like with all those multiple threads using gdb.

77
00:04:10,950 --> 00:04:13,140
I use very basic stuff,

78
00:04:13,260 --> 00:04:15,570
I have use print statements.

79
00:04:15,990 --> 00:04:18,990
But the main thing I rely on is

80
00:04:18,990 --> 00:04:22,230
I sort of tried to write down or assertions for invariants,

81
00:04:22,230 --> 00:04:24,810
that I think should be true at every point.

82
00:04:25,490 --> 00:04:27,650
And if the assertion goes off,

83
00:04:27,650 --> 00:04:30,110
then I know that you know there's something wrong in my thinking

84
00:04:30,110 --> 00:04:31,400
or assertion was wrong.

85
00:04:31,900 --> 00:04:34,060
And then I think for a while

86
00:04:34,090 --> 00:04:36,580
and try to decide what it is,

87
00:04:36,610 --> 00:04:38,140
and then go from there.

88
00:04:38,620 --> 00:04:42,040
The normal,

89
00:04:42,040 --> 00:04:44,830
for many other settings,

90
00:04:44,830 --> 00:04:47,680
there are race detectors that can help you,

91
00:04:47,680 --> 00:04:53,350
and you know basically flag code that may looks like,

92
00:04:53,350 --> 00:04:55,270
it might be having problems

93
00:04:55,360 --> 00:04:57,640
or as prone to race conditions,

94
00:04:57,820 --> 00:05:00,940
but that's a whole set of other tools,

95
00:05:01,060 --> 00:05:03,010
that we're not using.

96
00:05:03,770 --> 00:05:06,770
And it's not that good,

97
00:05:06,770 --> 00:05:08,210
but there's a little bit of a big step

98
00:05:08,210 --> 00:05:10,490
to actually get that all up and going and running.

99
00:05:11,270 --> 00:05:14,480
So that's the other mechanism that people use race detectors.

100
00:05:16,960 --> 00:05:20,920
Basically flag, any any shared variable that is updated or write

101
00:05:20,920 --> 00:05:22,270
without actually holding a lock.

102
00:05:24,460 --> 00:05:25,930
That doesn't help with deadlocks,

103
00:05:25,930 --> 00:05:28,930
for example in this lab in a bcache lock,

104
00:05:28,930 --> 00:05:30,970
you know you get deadlocks,

105
00:05:31,060 --> 00:05:33,280
deadlocks are tend to be easier to do debug, correct,

106
00:05:33,280 --> 00:05:35,560
because you can get the panic

107
00:05:35,560 --> 00:05:38,110
and then you can look at the gdb in the backtrace

108
00:05:38,110 --> 00:05:40,720
and see actually was involved in the deadlock.

109
00:05:44,620 --> 00:05:45,370
Does that make sense?

110
00:05:46,810 --> 00:05:47,830
Thank you.

111
00:05:50,050 --> 00:05:52,210
Okay, another suggestion,

112
00:05:52,210 --> 00:05:54,430
actually somebody posted on the feedback,

113
00:05:54,430 --> 00:05:58,330
is you know classes are tend is getting a little bit lower

114
00:05:58,330 --> 00:05:59,500
than in the beginning of the semester,

115
00:05:59,500 --> 00:06:00,790
and I think we might be small enough,

116
00:06:00,790 --> 00:06:03,910
or the size that it may be perfectly fine

117
00:06:03,910 --> 00:06:05,080
to actually have cameras on.

118
00:06:05,630 --> 00:06:08,210
And so maybe I want to encourage you to

119
00:06:08,210 --> 00:06:10,700
if you ask a question to turn on your camera,

120
00:06:11,210 --> 00:06:14,840
you know will hopefully improve in our experiences,

121
00:06:14,840 --> 00:06:16,160
if you've seen the classroom

122
00:06:16,160 --> 00:06:17,630
as opposed to in a virtual meeting.

123
00:06:18,980 --> 00:06:21,380
And you don't have to look at me.

124
00:06:22,720 --> 00:06:25,900
Okay, so,

125
00:06:25,960 --> 00:06:27,760
okay, today's lecture,

126
00:06:27,850 --> 00:06:29,440
so today's lecture is going to be

127
00:06:29,440 --> 00:06:32,560
about crash safety and crash safety of file systems,

128
00:06:32,800 --> 00:06:35,590
and this is not crash safety in its most general form,

129
00:06:35,590 --> 00:06:38,530
actually I'm really focusing on a particular problem,

130
00:06:41,980 --> 00:06:43,450
or a specific problem,

131
00:06:43,480 --> 00:06:46,750
namely a crash or power failure

132
00:06:47,050 --> 00:06:53,900
can lead on-disk file system

133
00:06:57,060 --> 00:07:00,360
to be in an inconsistent state or an incorrect state.

134
00:07:04,080 --> 00:07:05,850
And what I mean, with an incorrect state is

135
00:07:05,850 --> 00:07:08,760
you know for example a data block belongs two files,

136
00:07:08,790 --> 00:07:13,500
or an inode is allocated to different files.

137
00:07:14,140 --> 00:07:18,940
And so the scenario where this problem might sort of appear is,

138
00:07:18,940 --> 00:07:21,340
let's say you know you're running make,

139
00:07:21,900 --> 00:07:25,530
make pretty file system interact with the file system,

140
00:07:25,740 --> 00:07:26,970
reads writes files

141
00:07:27,180 --> 00:07:31,320
and somewhere during you know that thing, a power failure happens,

142
00:07:33,920 --> 00:07:36,110
you know maybe your laptop run out of battery,

143
00:07:36,290 --> 00:07:40,370
you know maybe the power just dropped to your house,

144
00:07:40,370 --> 00:07:44,000
and you know you reboot,

145
00:07:45,460 --> 00:07:47,980
the power comes back on at some point,

146
00:07:48,370 --> 00:07:51,340
you reboot the machine, machine comes back up

147
00:07:51,370 --> 00:07:54,280
and then you get a prompt again,

148
00:07:54,280 --> 00:07:55,240
you run ls

149
00:07:55,750 --> 00:07:58,450
and you hope basically that your file system is in a good state,

150
00:07:59,200 --> 00:08:01,120
in the state actually can still use it.

151
00:08:01,880 --> 00:08:05,420
And so the particular failures or crashes that we're concerned about are

152
00:08:05,450 --> 00:08:08,300
basically power failures during file system operations

153
00:08:08,510 --> 00:08:11,600
or the kernel panics,

154
00:08:11,630 --> 00:08:14,000
you know while running some file system operation,

155
00:08:14,210 --> 00:08:15,260
xv6 is panics,

156
00:08:15,260 --> 00:08:16,250
most kernels are panics,

157
00:08:16,250 --> 00:08:19,400
you know maybe there're some kernel bug that causes a panic

158
00:08:19,580 --> 00:08:21,560
and you know suddenly your system just fails.

159
00:08:22,350 --> 00:08:23,520
And what you'd like to be the case

160
00:08:23,520 --> 00:08:25,470
that after rebooting you can actually do something,

161
00:08:26,430 --> 00:08:28,080
or you can still use the file system.

162
00:08:28,590 --> 00:08:30,210
And this might be something where you're thinking,

163
00:08:30,210 --> 00:08:31,950
well, how could that not be, right,

164
00:08:31,950 --> 00:08:35,730
because the file system stored on a persistent storage medium

165
00:08:35,730 --> 00:08:37,470
and so if the power fails,

166
00:08:37,470 --> 00:08:39,570
you know that medium should be good,

167
00:08:39,570 --> 00:08:41,100
then so once machine comes back up,

168
00:08:41,100 --> 00:08:43,050
you know all the blocks that you've written should be there.

169
00:08:43,730 --> 00:08:45,620
And we'll see that the tricky cases

170
00:08:45,620 --> 00:08:50,780
that many file system operations have multi-step operations.

171
00:08:51,240 --> 00:08:54,300
And really what is important to note

172
00:08:54,300 --> 00:08:57,840
and if we if we crash just in the wrong place,

173
00:08:57,840 --> 00:08:59,490
in these multi-step operations,

174
00:08:59,580 --> 00:09:02,850
the file system actually may end up being an this inconsistent

175
00:09:02,880 --> 00:09:04,530
for that short period of time

176
00:09:04,650 --> 00:09:06,720
and if the power fail just happened there,

177
00:09:06,900 --> 00:09:07,980
you know something bad could happen.

178
00:09:08,740 --> 00:09:13,450
And so that is sort of the problem that we're focusing on today

179
00:09:13,870 --> 00:09:15,730
and so this is different from the problem

180
00:09:15,730 --> 00:09:18,100
that for example whatever you know there's a power failure

181
00:09:18,100 --> 00:09:19,930
and your disk caught fire

182
00:09:19,930 --> 00:09:22,060
and so there's nothing there anymore

183
00:09:22,090 --> 00:09:23,170
and you need to,

184
00:09:23,380 --> 00:09:26,860
in that case, you need you need there's a completely different problem,

185
00:09:26,860 --> 00:09:28,030
that has different solutions,

186
00:09:28,030 --> 00:09:32,160
you know, for example you have to go back to backup of your file system,

187
00:09:32,160 --> 00:09:34,470
reinstall your file system, etc etc.

188
00:09:35,310 --> 00:09:37,020
So that's the problem we're not worried about.

189
00:09:37,020 --> 00:09:38,040
We're really worried about

190
00:09:38,040 --> 00:09:44,160
the specific problem of failure happening right during a multi-step operation.

191
00:09:46,380 --> 00:09:49,270
Okay, and the solution for that specific problem that

192
00:09:49,270 --> 00:09:53,050
we're going to be exploring is something that is called logging,

193
00:09:53,260 --> 00:09:56,950
and this is a very popular solution,

194
00:09:56,950 --> 00:10:00,970
originally coming out of the database world,

195
00:10:00,970 --> 00:10:04,600
but a lot of file systems that use logging these days.

196
00:10:05,100 --> 00:10:06,690
We're gonna,

197
00:10:06,720 --> 00:10:08,580
it's very one reason it's popular is

198
00:10:08,580 --> 00:10:10,440
because it's a very principle solution,

199
00:10:10,650 --> 00:10:16,440
and we're going to see the implementation of logging in xv6

200
00:10:16,650 --> 00:10:19,230
and of course xv6 has a very simple implementation,

201
00:10:19,230 --> 00:10:22,410
like a bare minimal implementation of logging,

202
00:10:22,470 --> 00:10:24,840
just to demonstrate in the key ideas,

203
00:10:25,270 --> 00:10:29,110
and even that sort of a very bare bone,

204
00:10:29,110 --> 00:10:30,970
log implementation actually has several issues,

205
00:10:30,970 --> 00:10:32,740
that were going to be talking about

206
00:10:32,800 --> 00:10:34,750
and that's why it's worth you know studying it.

207
00:10:35,410 --> 00:10:39,220
One downside as we'll see is the xv6 solution is

208
00:10:39,220 --> 00:10:42,190
because of simplicity, its performance is also not so great,

209
00:10:42,900 --> 00:10:45,900
even though logging systems in principle can get a good performance.

210
00:10:46,170 --> 00:10:49,110
And so what we'll do next week is

211
00:10:49,110 --> 00:10:53,400
actually look how, how to implement a high performance logging system

212
00:10:53,490 --> 00:10:58,680
by studying the logging system the Linux ext3 file system uses,

213
00:10:59,320 --> 00:11:00,820
but that's next week.

214
00:11:01,860 --> 00:11:06,210
Another, may be small a point I want to make today is

215
00:11:06,210 --> 00:11:08,460
this is our last xv6 lecture

216
00:11:08,850 --> 00:11:13,770
and from now on, we're going to be switching to papers,

217
00:11:13,950 --> 00:11:16,080
because in some ways, what we've done is

218
00:11:16,080 --> 00:11:18,480
we've covered you know the basic concepts

219
00:11:18,630 --> 00:11:24,030
and we can start looking at more advance operating system ideas by reading papers.

220
00:11:24,830 --> 00:11:25,550
Okay?

221
00:11:27,130 --> 00:11:28,210
Any questions so far?

222
00:11:34,590 --> 00:11:35,280
Well, good.

223
00:11:38,080 --> 00:11:42,520
Okay, so let me go back a little bit about the scenarios

224
00:11:42,520 --> 00:11:46,990
that were really, that we're focusing about in in this lecture.

225
00:11:47,470 --> 00:11:51,190
So file systems, file system operations,

226
00:11:52,380 --> 00:11:55,080
like creating a file, writing a file,

227
00:11:55,110 --> 00:11:58,170
are multi-step disk operations.

228
00:12:06,400 --> 00:12:09,940
And we saw that last week on Monday,

229
00:12:09,940 --> 00:12:11,770
we talked about how create is implemented,

230
00:12:11,770 --> 00:12:13,690
like creating a file, or writing to a file,

231
00:12:13,690 --> 00:12:16,180
we often see that you know the sequence of events,

232
00:12:16,180 --> 00:12:19,630
or something the sequence of steps are allocated inode,

233
00:12:19,630 --> 00:12:21,370
mark the inode allocated on disk,

234
00:12:21,460 --> 00:12:24,700
then you know write the directory block that contains that inode

235
00:12:24,730 --> 00:12:26,980
and so those are the multi-steps that I'm talking about.

236
00:12:27,540 --> 00:12:30,960
If we get a crash between two of the steps,

237
00:12:31,080 --> 00:12:33,300
that crash can leave,

238
00:12:34,870 --> 00:12:41,720
may leave, may leave the file system invariance violated.

239
00:12:45,440 --> 00:12:50,150
And violent the invariance, I'm talking about are invariance of the form,

240
00:12:50,390 --> 00:12:53,450
you know every block is either free

241
00:12:53,480 --> 00:12:56,900
or allocated to one file and not to two files.

242
00:12:57,420 --> 00:13:00,390
And you know we want to make sure that this happens,

243
00:13:00,390 --> 00:13:05,310
despite you know these failures right between these operations.

244
00:13:06,880 --> 00:13:13,280
Yeah, and the risk is if if the invariance are violated,

245
00:13:13,790 --> 00:13:16,220
that bad things can happen after reboot,

246
00:13:17,510 --> 00:13:20,960
you know the, you might crash again immediately.

247
00:13:21,930 --> 00:13:23,460
Because you know there's some data structure,

248
00:13:23,460 --> 00:13:25,380
the file system you know in a state

249
00:13:25,380 --> 00:13:27,540
that the file system actually can't really deal with,

250
00:13:27,540 --> 00:13:29,640
on this data structures in such a state,

251
00:13:29,760 --> 00:13:32,910
[] that the file system really can't process them anymore,

252
00:13:33,240 --> 00:13:37,730
or more likely you're not crash, no crash,

253
00:13:37,790 --> 00:13:40,460
but you know data may get lost,

254
00:13:41,340 --> 00:13:43,920
or you read or write incorrect data.

255
00:13:52,630 --> 00:13:54,550
And we'll see a couple of examples,

256
00:13:54,550 --> 00:13:56,050
you know to make it more clear,

257
00:13:56,140 --> 00:13:59,260
but so these are the risks that we're worried about.

258
00:14:02,020 --> 00:14:06,700
I don't know if anybody actually every personal life or in your daily life

259
00:14:06,730 --> 00:14:08,920
using computers actually has experienced a problem

260
00:14:08,920 --> 00:14:13,360
where basically, you had a failure in the file system

261
00:14:13,360 --> 00:14:15,670
where you had a failure, had a power failure,

262
00:14:15,670 --> 00:14:17,980
your machine rebooted or your phone restarted

263
00:14:18,190 --> 00:14:23,110
and basically unusable afterwards.

264
00:14:23,980 --> 00:14:25,450
One reason that might be unusual,

265
00:14:25,450 --> 00:14:28,000
because actually the file system just didn't recover correctly.

266
00:14:37,370 --> 00:14:39,230
Okay, so to make it more clear,

267
00:14:39,230 --> 00:14:42,500
let's just let's look at an example in the context of xv6,

268
00:14:42,500 --> 00:14:45,560
I like to make this risk a little bit more concrete,

269
00:14:45,740 --> 00:14:48,560
let's look at an example in the context of xv6

270
00:14:48,770 --> 00:14:51,110
and to see what actually go could go wrong.

271
00:14:52,020 --> 00:14:57,690
So remember the, for Monday, the xv6 file system,

272
00:14:57,690 --> 00:15:00,120
very simple file system has a simple disk layout,

273
00:15:00,510 --> 00:15:04,440
you know super block, a super block,

274
00:15:04,440 --> 00:15:06,750
there's the log, that we're going to be talking about a lot today,

275
00:15:06,750 --> 00:15:08,070
that we didn't talk about on Monday,

276
00:15:08,280 --> 00:15:11,040
where inodes you know set of blocks that actually contain,

277
00:15:11,280 --> 00:15:13,530
each and each block may contain multiply inodes,

278
00:15:13,650 --> 00:15:17,880
and bitmap block to record which blocks are free and which are not free,

279
00:15:18,120 --> 00:15:22,530
and then the data blocks actually contain the actual data of the file system.

280
00:15:23,460 --> 00:15:26,130
You remember from Monday's lecture,

281
00:15:26,130 --> 00:15:27,750
I reproduce the trace here,

282
00:15:27,750 --> 00:15:30,600
you know we looked at actually a how files created

283
00:15:31,020 --> 00:15:34,680
and you know we see that the creation of a single file.

284
00:15:35,370 --> 00:15:36,900
Well, wait a second.

285
00:15:41,460 --> 00:15:46,240
The, the creation of a single file consists of multiple operations,

286
00:15:46,360 --> 00:15:48,520
for example in this particular scenario,

287
00:15:48,520 --> 00:15:51,340
that I've here on the, on on this slide,

288
00:15:51,670 --> 00:15:57,610
we see the, you know inode is allocated

289
00:15:57,670 --> 00:16:01,300
and we know this, because there's block 33 is being written,

290
00:16:01,570 --> 00:16:05,380
do we see that the inode is being initialized,

291
00:16:05,380 --> 00:16:07,090
then write again to block 33,

292
00:16:07,330 --> 00:16:10,030
then we see the block 46 is written

293
00:16:10,030 --> 00:16:11,620
and that reason is written is,

294
00:16:11,620 --> 00:16:15,970
presumably because you know the directory block that actually contains x

295
00:16:16,120 --> 00:16:18,820
and the inode number for x is written to the disk.

296
00:16:19,240 --> 00:16:21,460
Then the inode, root inode updated

297
00:16:21,460 --> 00:16:24,730
to reflect that the directory has grown in size

298
00:16:24,730 --> 00:16:28,630
to contain this particular file x

299
00:16:28,840 --> 00:16:30,820
and then you know inode updated.

300
00:16:31,650 --> 00:16:35,080
So, what we want to understand is

301
00:16:35,080 --> 00:16:38,680
what happens, like what could possibly go wrong, right.

302
00:16:39,040 --> 00:16:44,890
So let's say you know we have a power failure right here,

303
00:16:45,100 --> 00:16:49,060
so here is power failure or kernel crash.

304
00:16:52,160 --> 00:16:53,660
So what happens after the power failure,

305
00:16:53,660 --> 00:16:56,300
correct all the in-memory state is lost,

306
00:16:56,600 --> 00:17:00,260
because in-memory state data that's actually in RAM,

307
00:17:00,260 --> 00:17:03,230
like all the processes, all the file descriptors,

308
00:17:03,960 --> 00:17:06,930
all the in-memory caches are gone,

309
00:17:07,140 --> 00:17:09,420
because memory is not persistent

310
00:17:09,600 --> 00:17:13,110
and the only thing that we have left is what actually is on the disk,

311
00:17:13,650 --> 00:17:18,090
so only the data structures, the bits and bytes,

312
00:17:18,090 --> 00:17:22,200
they're actually sitting on the disk are survived the power failure,

313
00:17:22,410 --> 00:17:27,120
because that actually medium is you know persistence or has durability.

314
00:17:28,100 --> 00:17:29,810
And so we want to know, like want understand,

315
00:17:30,380 --> 00:17:34,370
so if we crash here and we have no additional mechanisms,

316
00:17:34,520 --> 00:17:37,910
or no logging as we're going to be talking about,

317
00:17:37,970 --> 00:17:39,350
we have no additional mechanisms,

318
00:17:39,860 --> 00:17:41,120
how how bad is it.

319
00:17:42,750 --> 00:17:45,300
What risk are we running here?

320
00:17:53,750 --> 00:17:54,380
Anybody?

321
00:17:57,670 --> 00:18:01,060
So basically you know we've written block 33

322
00:18:01,120 --> 00:18:03,520
to record the inode has been allocated,

323
00:18:03,580 --> 00:18:04,690
then we had a power failure

324
00:18:04,690 --> 00:18:05,650
and then we come back up.

325
00:18:07,780 --> 00:18:08,260
Go ahead Brandon.

326
00:18:13,300 --> 00:18:18,280
This does that mean we lose the, lose this block,

327
00:18:18,780 --> 00:18:21,810
it's like it seems like it's populated, but it's actually not.

328
00:18:22,290 --> 00:18:25,830
Yeah, correctly, I think we're losing, we're losing the whole block,

329
00:18:25,830 --> 00:18:28,500
but we used inode x, correct inode x,

330
00:18:29,070 --> 00:18:34,320
and inode for x that was allocated or marked as allocated is allocated on disk,

331
00:18:34,470 --> 00:18:37,020
but we have not put in any,

332
00:18:37,020 --> 00:18:40,350
we've not succeeded, correct, put in any directory.

333
00:18:41,120 --> 00:18:43,880
So basically on the disk, you know there's an inode allocated,

334
00:18:43,880 --> 00:18:45,860
but it doesn't appear in any directory,

335
00:18:46,160 --> 00:18:48,110
so we can't even remove it right.

336
00:18:48,830 --> 00:18:51,410
And so basically what will this cause has to happen is

337
00:18:51,410 --> 00:18:52,970
we lose lose an inode.

338
00:18:57,200 --> 00:18:57,920
Does that make sense?

339
00:19:01,260 --> 00:19:03,360
You might think, well maybe what I should do is,

340
00:19:03,360 --> 00:19:05,100
maybe I should reorder the write.

341
00:19:05,830 --> 00:19:08,560
And, in a way you know then hopefully you know this,

342
00:19:08,560 --> 00:19:09,610
you know we don't lose the inode,

343
00:19:09,610 --> 00:19:11,590
so for example another thing we could try to do is

344
00:19:11,590 --> 00:19:12,820
say well what we'll do is,

345
00:19:12,940 --> 00:19:17,620
we'll write 46 first,

346
00:19:18,230 --> 00:19:21,320
basically update the inode update directory, right,

347
00:19:21,320 --> 00:19:25,920
the directory inode you know write 32

348
00:19:25,950 --> 00:19:29,460
and then will actually mark the inode is allocated on disk,

349
00:19:30,950 --> 00:19:35,900
to mark indicate that mark is allocated.

350
00:19:36,650 --> 00:19:39,470
So we do the same set of operations in a slightly different order.

351
00:19:40,050 --> 00:19:44,580
In the hope that we should avoid this losing of the inode problem.

352
00:19:45,680 --> 00:19:46,910
And would this work?

353
00:19:50,980 --> 00:19:52,960
Well, the thing that we should ask ourselves

354
00:19:52,960 --> 00:19:55,600
like you know let's think about this point in time,

355
00:19:55,810 --> 00:19:57,970
let's say a crash happens like right here

356
00:19:57,970 --> 00:19:59,020
or power failure happens

357
00:19:59,020 --> 00:20:02,690
right between updating the directory basically,

358
00:20:02,690 --> 00:20:05,180
but before we allocated the inode on disk

359
00:20:05,210 --> 00:20:07,460
and now you know when power fails,

360
00:20:07,610 --> 00:20:08,720
machine comes back up

361
00:20:08,960 --> 00:20:10,220
and we look at the file system,

362
00:20:10,250 --> 00:20:12,500
you know what state will the file system be in.

363
00:20:15,200 --> 00:20:17,780
You'll still think it's a free inode.

364
00:20:19,420 --> 00:20:20,410
Yeah, what would happen if,

365
00:20:20,410 --> 00:20:23,440
for example we read you know file x in the directory,

366
00:20:23,650 --> 00:20:24,490
in the root directory,

367
00:20:24,490 --> 00:20:26,620
because it is in there now, correct, this data block.

368
00:20:30,080 --> 00:20:31,250
We're going to be reading the inode,

369
00:20:31,250 --> 00:20:34,160
that actually is not even allocated, correct, marked unallocated.

370
00:20:34,950 --> 00:20:39,480
And worse, what could happen is, correct, inode it might be allocated again,

371
00:20:39,540 --> 00:20:41,250
or it might actually really be allocated,

372
00:20:41,610 --> 00:20:46,560
because marks unallocated to actually in fact a different file, right,

373
00:20:46,950 --> 00:20:50,130
and so now we have two files that might actually,

374
00:20:50,130 --> 00:20:52,500
two files that actually share,

375
00:20:52,500 --> 00:20:53,550
even though they're completely different,

376
00:20:53,550 --> 00:20:54,690
they share the same inode,

377
00:20:55,350 --> 00:20:57,990
for example if one file would be owned by user one

378
00:20:57,990 --> 00:20:58,950
and one by user two,

379
00:20:58,950 --> 00:21:02,130
then basically user two could read user one file data right.

380
00:21:03,770 --> 00:21:05,150
So that's no good, either, right.

381
00:21:11,230 --> 00:21:11,980
Does that make sense?

382
00:21:13,980 --> 00:21:15,870
So basically switching the order

383
00:21:15,870 --> 00:21:17,730
you know it's not really going to solve our problem.

384
00:21:18,500 --> 00:21:21,800
You would just basically get a different problem that we had before.

385
00:21:23,630 --> 00:21:25,160
Okay, let's look at one more example.

386
00:21:25,840 --> 00:21:32,210
Here's the example of writing to file x.

387
00:21:35,120 --> 00:21:36,650
So once we have the files allocated,

388
00:21:36,650 --> 00:21:37,850
let's say that all succeeded,

389
00:21:37,880 --> 00:21:39,950
and now we're executing the write system call

390
00:21:40,160 --> 00:21:43,280
and the write system call also does a multiple writes operations

391
00:21:43,280 --> 00:21:44,300
which we saw on Monday,

392
00:21:44,690 --> 00:21:48,740
for example it will allocate a block, in this case block 45,

393
00:21:49,160 --> 00:21:52,130
so it sets a bit in the free map,

394
00:21:52,130 --> 00:21:55,130
block 45 is the bitmap block,

395
00:21:55,430 --> 00:21:57,980
so it allocates a block in the bitmap,

396
00:21:57,980 --> 00:21:59,510
allocates a bit in the bitmap block

397
00:21:59,510 --> 00:22:03,190
to indicate the the block has to be allocated,

398
00:22:03,580 --> 00:22:06,250
that block turns out to be I guess 595.

399
00:22:06,780 --> 00:22:10,800
And then we write you know the character h you know to 595

400
00:22:10,800 --> 00:22:11,700
and then the character i,

401
00:22:11,700 --> 00:22:12,870
you know we update the inode.

402
00:22:13,990 --> 00:22:15,940
Right, now we can ask ourselves the same question,

403
00:22:15,940 --> 00:22:21,670
like what will happen if we crash,

404
00:22:21,760 --> 00:22:24,940
so for example, let's say we allocate crash right here,

405
00:22:25,000 --> 00:22:28,920
between you know writing the bitmap block,

406
00:22:29,160 --> 00:22:32,850
before we allocate before we actually write a inode.

407
00:22:33,700 --> 00:22:34,780
So crash here.

408
00:22:39,980 --> 00:22:42,350
And so we reboot, we come back up

409
00:22:42,380 --> 00:22:44,360
and this is in a particular state

410
00:22:44,360 --> 00:22:47,600
and you know what, what is the risk?

411
00:22:50,520 --> 00:22:53,430
We use it data block, but we lose it.

412
00:22:53,790 --> 00:22:54,930
Yeah, we lose it again, right,

413
00:22:54,930 --> 00:22:56,550
because the block is allocated,

414
00:22:56,550 --> 00:22:57,930
but doesn't show up in any file,

415
00:22:58,950 --> 00:23:01,890
because it hasn't been written into any inode,

416
00:23:01,890 --> 00:23:03,180
so we lose a data block.

417
00:23:08,680 --> 00:23:09,220
You might think,

418
00:23:09,220 --> 00:23:12,100
okay, well maybe you know just because we wrote them in the wrong order,

419
00:23:12,100 --> 00:23:13,690
what we should have done is

420
00:23:13,990 --> 00:23:17,260
what we should have done is at first write in the inode,

421
00:23:17,650 --> 00:23:22,820
so first write 33 with the, you know with 595

422
00:23:22,910 --> 00:23:26,870
as in the either is an indirect block or direct block.

423
00:23:27,520 --> 00:23:32,680
And then you know actually we will mark the inode, the block is allocated,

424
00:23:32,680 --> 00:23:35,350
so then we'll write you know 45.

425
00:23:37,000 --> 00:23:37,960
If we change the order,

426
00:23:37,960 --> 00:23:40,000
because we want to avoid these lost data block,

427
00:23:40,000 --> 00:23:40,990
we change order in this way.

428
00:23:42,530 --> 00:23:44,630
And now let's consider the case,

429
00:23:44,630 --> 00:23:46,100
if there's a failure right here.

430
00:23:50,370 --> 00:23:51,330
What is the risk?

431
00:23:56,960 --> 00:24:03,800
The size of the file is not compatible with actually how many data blocks are allocated.

432
00:24:04,710 --> 00:24:05,250
That might be,

433
00:24:05,250 --> 00:24:06,750
although I think it's the write of 33

434
00:24:06,750 --> 00:24:10,470
actually update both the size and you know the the block number.

435
00:24:11,970 --> 00:24:12,630
Oh.

436
00:24:13,450 --> 00:24:15,340
So that might be might work out okay.

437
00:24:16,780 --> 00:24:19,180
If there were two separate writes, that would be a problem,

438
00:24:20,950 --> 00:24:22,270
but there's some bigger problem here.

439
00:24:27,400 --> 00:24:28,510
Is that the,

440
00:24:29,620 --> 00:24:32,320
so the file has the,

441
00:24:33,820 --> 00:24:37,180
so things that it has the data block,

442
00:24:37,180 --> 00:24:40,810
but the data block is marked as unallocated

443
00:24:40,900 --> 00:24:45,100
and other files can also use it.

444
00:24:45,220 --> 00:24:47,740
Yeah, that's the real big problem here is that,

445
00:24:47,740 --> 00:24:53,950
you know the the inode things 595, block 595 belonged belonged to that file,

446
00:24:54,130 --> 00:24:58,050
but actually on disk it's still marked as unallocated

447
00:24:58,110 --> 00:25:01,080
and so when later another file was created,

448
00:25:01,110 --> 00:25:04,500
you know that block actually might be used for that other file.

449
00:25:05,140 --> 00:25:09,520
And so now certainly one file things, it owns 595,

450
00:25:09,520 --> 00:25:10,750
but actually other file does,

451
00:25:10,750 --> 00:25:13,150
in fact both files will have 595

452
00:25:13,150 --> 00:25:16,990
in their block numbers for their inode

453
00:25:17,350 --> 00:25:22,630
and basically you know if one user owns that file,

454
00:25:22,630 --> 00:25:23,710
the other user in the other file,

455
00:25:23,710 --> 00:25:26,020
that can actually read write to each other's data, right,

456
00:25:26,020 --> 00:25:27,910
that's clearly not what we want.

457
00:25:28,390 --> 00:25:30,310
You know the file system should guarantee

458
00:25:30,490 --> 00:25:33,430
that every block only belongs in one file

459
00:25:33,430 --> 00:25:35,350
and no other file or is free.

460
00:25:37,630 --> 00:25:38,200
Okay?

461
00:25:38,860 --> 00:25:40,990
So this could lead to security problems,

462
00:25:41,020 --> 00:25:48,070
basically block is shared among multiple files,

463
00:25:49,640 --> 00:25:50,990
and that's definitely wrong.

464
00:25:55,480 --> 00:25:58,600
Does it make sense, in terms of the problems that can appear?

465
00:25:59,300 --> 00:26:02,060
And again, you know the real issue here is,

466
00:26:02,060 --> 00:26:03,950
not to watch the ordering of the writes,

467
00:26:04,190 --> 00:26:05,930
but the real underlying problem here is

468
00:26:05,930 --> 00:26:07,340
that we're just doing multiple writes

469
00:26:07,340 --> 00:26:12,590
and it basically have to show up on disk as an atomic operation.

470
00:26:18,920 --> 00:26:26,760
Okay, so the solution that we're gonna explore in this lecture is logging.

471
00:26:28,380 --> 00:26:29,160
And as I said before,

472
00:26:29,160 --> 00:26:34,080
this is a common solution used in file systems

473
00:26:34,080 --> 00:26:37,590
and originating actually out of the database literature.

474
00:26:37,740 --> 00:26:39,810
And it actually has a couple good properties,

475
00:26:39,870 --> 00:26:44,400
one, it's going to make basically system calls or file system calls atomic,

476
00:26:47,520 --> 00:26:48,540
with that, I mean,

477
00:26:48,720 --> 00:26:50,520
so if a create file

478
00:26:50,520 --> 00:26:52,950
or you can call create you call write,

479
00:26:53,070 --> 00:26:56,040
basically all the effects of that system call

480
00:26:56,040 --> 00:26:58,200
use all appeared altogether or none of them,

481
00:26:58,470 --> 00:27:00,780
so that avoids this problem

482
00:27:00,780 --> 00:27:05,010
of only some subset of the writes actually showing up on disk.

483
00:27:06,800 --> 00:27:09,140
Second good property it has,

484
00:27:09,170 --> 00:27:10,850
it allows for fast recovery.

485
00:27:12,870 --> 00:27:14,250
So after reboot,

486
00:27:14,740 --> 00:27:18,220
turns out we don't actually have to do a lot of work to repair the file system,

487
00:27:18,310 --> 00:27:19,870
actually a very minimal amount of work.

488
00:27:20,730 --> 00:27:23,520
And this is in contrast to some other solution

489
00:27:23,520 --> 00:27:24,840
and I'm not talking about,

490
00:27:24,840 --> 00:27:27,510
which is basically you go and inspect the file system,

491
00:27:27,720 --> 00:27:29,760
maybe you read all the blocks of the file system

492
00:27:29,760 --> 00:27:31,200
or read all the inode blocks,

493
00:27:31,200 --> 00:27:32,700
read all the bitmap blocks

494
00:27:33,000 --> 00:27:34,170
and so check out

495
00:27:34,170 --> 00:27:36,210
whether the file system is still in the correct shape

496
00:27:36,210 --> 00:27:37,320
and maybe repair things.

497
00:27:38,260 --> 00:27:42,130
Logging has this nice property that actually the recovery is fast.

498
00:27:43,020 --> 00:27:47,130
And finally, it is in principle, it can be actually very high performance,

499
00:27:47,610 --> 00:27:50,670
although the one, you know what we're going to be looking

500
00:27:50,670 --> 00:27:52,890
in the context of xv6 is not high performance,

501
00:27:53,070 --> 00:27:55,140
so we're going to look at that next week,

502
00:27:55,170 --> 00:27:56,940
we'll see actually how to build a logging system

503
00:27:56,940 --> 00:28:01,330
that has atomic file system calls faster recovery and high performance,

504
00:28:01,330 --> 00:28:03,190
today we're going to be just focusing on the first two.

505
00:28:05,560 --> 00:28:06,280
Okay.

506
00:28:06,780 --> 00:28:10,590
The basic idea of logging is actually straightforward,

507
00:28:11,330 --> 00:28:15,980
and so basically what you do is you divide this into two pieces,

508
00:28:16,590 --> 00:28:19,350
one is the log, one is the file system,

509
00:28:20,600 --> 00:28:22,760
and file system might be much bigger than log.

510
00:28:23,580 --> 00:28:28,050
And when you need to update the file system,

511
00:28:28,050 --> 00:28:32,820
so update, let's say block 33 or update the bitmap block,

512
00:28:33,360 --> 00:28:36,210
we're actually not going to update the file system blocks,

513
00:28:36,210 --> 00:28:38,940
so we're not going to update bitmap block directly,

514
00:28:38,940 --> 00:28:42,240
instead the only thing we're gonna do on the right is,

515
00:28:42,540 --> 00:28:44,400
so here's our memory,

516
00:28:44,400 --> 00:28:45,660
we have a block in memory,

517
00:28:45,960 --> 00:28:49,290
is say the bitmap block, it's 45

518
00:28:49,650 --> 00:28:51,480
and instead of writing it to 45,

519
00:28:51,480 --> 00:28:52,830
where we normally would have done,

520
00:28:52,950 --> 00:28:55,440
what we're gonna do is actually going to write into the log,

521
00:28:55,740 --> 00:28:56,910
we're going to stick it here

522
00:28:57,090 --> 00:28:59,730
and remember that definitely should go to 45,

523
00:29:01,160 --> 00:29:02,060
we will put it there.

524
00:29:02,760 --> 00:29:04,230
And we do that with all the other writes too,

525
00:29:04,260 --> 00:29:08,460
so for example we'll put inode block there,

526
00:29:08,610 --> 00:29:12,150
you know like maybe 33 I think, if I remember correctly

527
00:29:12,450 --> 00:29:13,710
and we'll stick it in there

528
00:29:13,770 --> 00:29:16,710
and you know, remember that actually has to go to 33.

529
00:29:18,320 --> 00:29:21,950
So basically what we do any write his first log.

530
00:29:24,660 --> 00:29:27,600
And so we don't write directly to the home location of the block,

531
00:29:27,600 --> 00:29:29,970
but we just put it always a log.

532
00:29:30,930 --> 00:29:34,140
Then, at some point when the file system operation is done,

533
00:29:34,470 --> 00:29:35,520
for example as you know,

534
00:29:35,520 --> 00:29:39,540
these four five writes that we saw in the previous slides are in the log,

535
00:29:39,570 --> 00:29:40,710
we commit the operation.

536
00:29:44,830 --> 00:29:47,140
Basically what it means is somewhere in the log,

537
00:29:47,260 --> 00:29:50,440
we just record a record, you know in a fixed location,

538
00:29:50,440 --> 00:29:51,130
that basically says,

539
00:29:51,130 --> 00:29:55,450
okay, well you know there are like five logs in the log,

540
00:29:55,660 --> 00:29:59,800
and that is you know the log, set of log the writes.

541
00:30:01,720 --> 00:30:05,920
And then you know when we have all the writes stably on disk,

542
00:30:05,950 --> 00:30:09,310
we're going to actually install them, was called the installation phase.

543
00:30:10,470 --> 00:30:11,880
And really what that means is,

544
00:30:11,970 --> 00:30:15,630
we're gonna move you know these logs from the log to their home location,

545
00:30:15,630 --> 00:30:17,520
so we know this one has to go to 45,

546
00:30:17,520 --> 00:30:18,690
so we put it at 45,

547
00:30:18,690 --> 00:30:20,160
this one has to go to 33,

548
00:30:20,250 --> 00:30:22,260
we put it to 33, etc etc.

549
00:30:23,420 --> 00:30:24,530
And once we're done,

550
00:30:24,560 --> 00:30:26,360
you know basically we can clean the log

551
00:30:26,690 --> 00:30:27,920
and cleaning the log,

552
00:30:29,190 --> 00:30:33,240
basically you're rewriting, you know basically setting this five to zero.

553
00:30:34,460 --> 00:30:37,370
And that is a basic plan.

554
00:30:38,640 --> 00:30:39,990
And why is this plan good,

555
00:30:40,020 --> 00:30:41,190
well, let's think about it.

556
00:30:41,820 --> 00:30:46,760
Let's say we crash before here, what would happen.

557
00:30:50,900 --> 00:30:52,760
So let me hold that question,

558
00:30:52,790 --> 00:30:56,060
let me actually talk about one thing before asking the question.

559
00:30:57,710 --> 00:31:02,050
Let's say we crash and so we reboot,

560
00:31:02,470 --> 00:31:06,580
and on the reboot, there's basically what the file system does,

561
00:31:07,280 --> 00:31:08,630
it looks at the commit record,

562
00:31:09,900 --> 00:31:11,910
sees what the value of the commit record is,

563
00:31:12,330 --> 00:31:17,260
if it is zero, you know do nothing in our simple scheme.

564
00:31:18,560 --> 00:31:20,300
And if it's bigger to 0,

565
00:31:20,300 --> 00:31:22,370
we know that there are basically blocks in the log

566
00:31:22,370 --> 00:31:24,260
that need to be actually installed.

567
00:31:24,720 --> 00:31:26,940
And we apparently didn't finish the installation,

568
00:31:27,120 --> 00:31:29,100
we crashed you know after the commit,

569
00:31:29,100 --> 00:31:30,540
but before cleaning the log,

570
00:31:30,750 --> 00:31:32,820
so basically we re-install,

571
00:31:37,510 --> 00:31:39,550
and after we re-install, we clean the log.

572
00:31:43,990 --> 00:31:44,710
Okay?

573
00:31:45,290 --> 00:31:47,540
And this scheme is good,

574
00:31:47,930 --> 00:31:51,740
because it actually ensures that no matter where the crash happens,

575
00:31:51,830 --> 00:31:54,350
we're either install all the blocks of the writes

576
00:31:54,350 --> 00:31:55,490
or we install none of them,

577
00:31:55,790 --> 00:31:57,560
but we were never into,

578
00:31:57,650 --> 00:31:59,630
we will never end up in a situation

579
00:31:59,630 --> 00:32:02,420
where we installed some of the writes, but not all of them.

580
00:32:02,950 --> 00:32:04,570
Just to see why this is true,

581
00:32:04,570 --> 00:32:06,850
let's consider a couple cases where things could crash.

582
00:32:07,930 --> 00:32:10,900
So things could crash and between one and two, what will happen,

583
00:32:16,660 --> 00:32:18,550
in what situation do we end up.

584
00:32:23,020 --> 00:32:25,990
Situation in which on recovery, we do nothing

585
00:32:25,990 --> 00:32:30,720
and that's okay, because nothing has been written to the file system.

586
00:32:31,590 --> 00:32:32,670
Yeah exactly,

587
00:32:32,670 --> 00:32:36,120
so this is the case where basically we we just do nothing,

588
00:32:36,270 --> 00:32:39,030
you know as if the system call basically never executed,

589
00:32:39,150 --> 00:32:41,760
because if the failure happened slightly earlier,

590
00:32:41,760 --> 00:32:43,590
right, before the file system calls started.

591
00:32:44,240 --> 00:32:46,250
And so that's perfectly okay, that's acceptable.

592
00:32:47,040 --> 00:32:55,730
Okay, what happens, if we crash, okay, between after committing before being installed?

593
00:32:58,310 --> 00:33:00,320
Then you'll just redo all the installs,

594
00:33:00,320 --> 00:33:02,270
so you'll kind of restore the correct state.

595
00:33:02,870 --> 00:33:04,190
Yeah, so exactly,

596
00:33:04,190 --> 00:33:05,090
so at that point correct,

597
00:33:05,090 --> 00:33:09,110
we have, we know there are all the blocks are in the log

598
00:33:09,140 --> 00:33:11,180
and they'll be all written, because we committed,

599
00:33:11,270 --> 00:33:14,030
so it must be the case that the whole file system operation finished.

600
00:33:14,630 --> 00:33:17,660
So we can basically put them in their location where they should be.

601
00:33:18,760 --> 00:33:20,380
And then we're all in good shape

602
00:33:20,380 --> 00:33:22,120
and so in this case now all the file,

603
00:33:22,120 --> 00:33:25,250
in this case will end up as if the,

604
00:33:25,940 --> 00:33:30,200
it is if the file system call actually completely just before the crash,

605
00:33:30,260 --> 00:33:31,400
there's no difference.

606
00:33:32,280 --> 00:33:32,880
Okay?

607
00:33:33,820 --> 00:33:36,670
So what happens if we crash during install

608
00:33:36,700 --> 00:33:39,310
or like install during install before cleaning,

609
00:33:39,930 --> 00:33:40,770
crash here.

610
00:33:41,070 --> 00:33:42,030
In this case,

611
00:33:42,270 --> 00:33:42,990
in this case

612
00:33:42,990 --> 00:33:44,190
and I will do the third case,

613
00:33:44,550 --> 00:33:48,660
we'll install, during installation, or just before install,

614
00:33:48,690 --> 00:33:50,700
after installing before cleaning.

615
00:33:51,620 --> 00:33:53,690
What, what what, what happened then?

616
00:33:55,420 --> 00:33:56,860
On the.

617
00:33:58,110 --> 00:34:00,660
Oh, sorry, on the next restart,

618
00:34:00,690 --> 00:34:03,180
nothing has really changed,

619
00:34:03,180 --> 00:34:04,950
in terms of the recovery process

620
00:34:05,130 --> 00:34:07,380
and so we're just going to redo the log.

621
00:34:07,680 --> 00:34:08,970
We're going to redo the log again

622
00:34:08,970 --> 00:34:13,770
and we're gonna copy basically the content again you know to the locations right maybe,

623
00:34:13,860 --> 00:34:15,390
in fact we might do it multiple times,

624
00:34:15,970 --> 00:34:16,720
is that okay?

625
00:34:24,410 --> 00:34:27,710
Yes, because those are just writes,

626
00:34:28,490 --> 00:34:33,650
and it's, they are to a specific location that we don't change,

627
00:34:33,650 --> 00:34:35,000
like it's written in the log,

628
00:34:35,000 --> 00:34:38,060
so we know where we should write every time.

629
00:34:38,670 --> 00:34:40,710
Yeah basically every time we do the same write, correct,

630
00:34:40,710 --> 00:34:43,860
so let's say in block 45, you know there's the value 10,

631
00:34:44,570 --> 00:34:47,570
and we're going to write 10 at location 45 every time

632
00:34:48,050 --> 00:34:49,280
and that's exactly what it should be

633
00:34:49,370 --> 00:34:53,090
and repeating that write multiple times doesn't really do any harm, right.

634
00:34:54,160 --> 00:34:55,600
Because we're writing the same value,

635
00:34:55,630 --> 00:34:56,920
that actually should be there anyway.

636
00:34:57,720 --> 00:34:59,100
And so it's perfectly fine,

637
00:34:59,100 --> 00:35:01,590
for us to do re-installation multiple times.

638
00:35:03,440 --> 00:35:06,590
Of course, we shouldn't serve any other file system calls at this particular point of time,

639
00:35:06,590 --> 00:35:09,080
we should do this before we restart the file system,

640
00:35:09,560 --> 00:35:13,610
but while you know what during reboot during recovery,

641
00:35:13,610 --> 00:35:14,990
you know we can just do this, right.

642
00:35:16,080 --> 00:35:19,260
Another way of saying, that is that installation is basically idempotent,

643
00:35:19,290 --> 00:35:21,210
you can just execute it many many times

644
00:35:21,450 --> 00:35:23,580
and will have the same effect yet.

645
00:35:25,780 --> 00:35:28,210
Question about that?

646
00:35:29,720 --> 00:35:32,060
Because the interface is just read and write,

647
00:35:32,060 --> 00:35:36,260
if we had an append, this would not be safe, right?

648
00:35:36,980 --> 00:35:39,080
Yeah yeah, this [],

649
00:35:39,110 --> 00:35:40,610
you can make append safe too,

650
00:35:40,610 --> 00:35:42,710
a more fancy logging schemes,

651
00:35:42,710 --> 00:35:44,120
but for this particular logging scheme,

652
00:35:44,120 --> 00:35:45,410
we don't have to worry about that.

653
00:35:46,620 --> 00:35:49,800
In fact, in some sense, the append is file system level operation

654
00:35:49,890 --> 00:35:53,310
and at that level we can make it a topic

655
00:35:53,310 --> 00:35:56,590
using the logging scheme, that we're, what we have here.

656
00:35:58,280 --> 00:35:59,360
I see, thank you.

657
00:35:59,940 --> 00:36:00,960
I also have a question,

658
00:36:01,560 --> 00:36:05,400
what would happen if the file system crashed while you are committing,

659
00:36:05,400 --> 00:36:07,800
so you want to execute multiple writes

660
00:36:08,100 --> 00:36:10,110
and then you only commit like half of them.

661
00:36:11,480 --> 00:36:13,190
Yeah okay, so can you speak up a little bit more,

662
00:36:13,190 --> 00:36:14,540
because your volume is low.

663
00:36:14,630 --> 00:36:15,470
Oh, yeah sorry,

664
00:36:15,740 --> 00:36:20,810
so if you wanted to like commit multiple writes at once,

665
00:36:20,810 --> 00:36:22,100
like in an atomic way,

666
00:36:22,130 --> 00:36:25,700
but your system crashes in the middle of committing,

667
00:36:25,700 --> 00:36:28,820
so you are only able to commit like half of the writes,

668
00:36:28,970 --> 00:36:30,890
what would happen in that instance?

669
00:36:31,070 --> 00:36:32,990
Okay, so there's a very important point,

670
00:36:32,990 --> 00:36:34,160
I'm glad you ask the question.

671
00:36:34,190 --> 00:36:35,270
So first of all,

672
00:36:35,640 --> 00:36:40,320
the the you commit, in writing this commit operation here, correct,

673
00:36:40,320 --> 00:36:41,610
this you know step two,

674
00:36:41,940 --> 00:36:43,830
you only execute that commit operation

675
00:36:43,860 --> 00:36:45,750
after you've already logged all the writes,

676
00:36:45,750 --> 00:36:47,670
that you were planning to execute, right.

677
00:36:48,660 --> 00:36:50,340
So at the point you do to commit,

678
00:36:50,490 --> 00:36:51,900
all the writes are in the log.

679
00:36:53,320 --> 00:36:56,280
And so, the commit operation itself

680
00:36:56,310 --> 00:36:58,380
is an interesting question, what happens there.

681
00:36:58,620 --> 00:37:02,220
So, the way the way I indicated this on slide,

682
00:37:02,220 --> 00:37:04,680
like commit operation writes a single block,

683
00:37:05,210 --> 00:37:06,860
like a single sector on the disk.

684
00:37:07,360 --> 00:37:11,200
And the standard assumption that file systems make is that

685
00:37:11,200 --> 00:37:16,310
a single block write or single sector write is an atomic operation.

686
00:37:17,060 --> 00:37:18,980
Meaning that if you write it,

687
00:37:19,010 --> 00:37:22,010
the whole sector will be written, or none of the sector will be written.

688
00:37:22,010 --> 00:37:23,900
So the sector will never be written partially.

689
00:37:24,940 --> 00:37:28,690
And so there's always you know clearly you know valid data in that particular sector

690
00:37:28,990 --> 00:37:33,220
and so basically this operation that commit operation writing the log header,

691
00:37:33,580 --> 00:37:37,120
is writing the commit record is the real commit operation,

692
00:37:37,420 --> 00:37:42,010
if that succeeds, and there's basically say of five in the commit header,

693
00:37:42,160 --> 00:37:45,430
you know we know that there are five blocks in the log

694
00:37:45,430 --> 00:37:47,380
and we have to reinstall those five blocks.

695
00:37:48,600 --> 00:37:51,180
If the commit header didn't make it to disk,

696
00:37:51,540 --> 00:37:53,550
then the value will still be 0

697
00:37:53,940 --> 00:37:56,250
and we'll just treat it as if that transaction never happened.

698
00:37:59,010 --> 00:37:59,670
Thank you.

699
00:38:00,300 --> 00:38:03,360
And the key rule that you're sort of hinting at,

700
00:38:03,420 --> 00:38:05,610
that has to be true,

701
00:38:05,700 --> 00:38:07,680
is something what's called the write-ahead rule,

702
00:38:08,070 --> 00:38:12,090
which means that a logging system cannot install writes,

703
00:38:12,150 --> 00:38:15,750
until all the writes into, are into log.

704
00:38:20,000 --> 00:38:22,430
Any more questions about this sort of basic plan?

705
00:38:28,770 --> 00:38:29,430
Okay?

706
00:38:36,530 --> 00:38:37,040
Let's see.

707
00:38:42,300 --> 00:38:43,770
So what I want to,

708
00:38:44,730 --> 00:38:47,910
there are many many different versions of logging schemes

709
00:38:47,910 --> 00:38:50,340
and I sketched out here a very simple one,

710
00:38:50,640 --> 00:38:52,470
you know it's perfectly fine.

711
00:38:52,470 --> 00:38:56,130
You know there schemes where basically the cleaning of the log is postponed,

712
00:38:56,430 --> 00:38:58,680
installation is postponed until later,

713
00:38:58,860 --> 00:39:02,790
but I'm going to run sort of this very simple scheme,

714
00:39:03,000 --> 00:39:07,050
and then next week we'll see more sophisticated logging protocols.

715
00:39:07,480 --> 00:39:09,850
But all those logging protocols, follow this write-ahead rule,

716
00:39:09,850 --> 00:39:12,190
that before you're ready to commit record,

717
00:39:12,400 --> 00:39:16,150
you have to make sure that all the writes are in the log.

718
00:39:18,950 --> 00:39:20,570
But then there's a lot of within that,

719
00:39:20,570 --> 00:39:22,190
still there's a ton of flexibility

720
00:39:22,190 --> 00:39:26,330
in designing a particular logging protocols typically called.

721
00:39:27,460 --> 00:39:29,470
Okay, I'm gonna look a little bit,

722
00:39:29,500 --> 00:39:32,740
how this then is manifest itself in xv6,

723
00:39:32,740 --> 00:39:35,290
you know as a case study and to make things really concrete.

724
00:39:40,000 --> 00:39:41,890
Okay, so in xv6, there's sort of,

725
00:39:42,250 --> 00:39:45,400
you're going to look at two sort of piece of [] you will,

726
00:39:45,550 --> 00:39:47,170
the stuff that is actually on disk,

727
00:39:48,080 --> 00:39:50,540
and that's you know things that are in memory,

728
00:39:55,220 --> 00:39:57,230
in-memory contents will disappear,

729
00:39:57,230 --> 00:39:59,000
on the way we should think about it is that

730
00:39:59,000 --> 00:40:02,450
in-memory content will disappear on a crash or power failure.

731
00:40:04,660 --> 00:40:12,010
And the structure of the xv6 log as always pretty simple,

732
00:40:12,600 --> 00:40:17,430
there's actually, we have one block in the beginning, the header block,

733
00:40:18,020 --> 00:40:19,670
and that's basically our commit record,

734
00:40:19,670 --> 00:40:22,350
you know it contains the number n,

735
00:40:22,350 --> 00:40:24,390
which is like the number of blocks in the log

736
00:40:24,600 --> 00:40:25,920
and then for each block,

737
00:40:28,280 --> 00:40:33,230
the block number, the home location of that block, blah blah blah,

738
00:40:33,230 --> 00:40:34,310
are going to be any of those.

739
00:40:37,960 --> 00:40:40,210
And so, then in the log itself

740
00:40:40,210 --> 00:40:43,180
are basically is the data, that it belongs to that,

741
00:40:43,180 --> 00:40:46,480
so here is the data of bn0,

742
00:40:46,660 --> 00:40:49,690
here's the data of bn1, etc,

743
00:40:50,210 --> 00:40:52,490
to bn-1,

744
00:40:54,460 --> 00:40:55,930
so that's what's in the log.

745
00:40:56,340 --> 00:40:58,620
And there's the only thing, that's sort of in the log,

746
00:40:58,650 --> 00:40:59,700
there's nothing more to it.

747
00:41:00,600 --> 00:41:03,870
Then in memory where, while the file systems running,

748
00:41:03,870 --> 00:41:07,620
there's an in copy version in-memory version of the header,

749
00:41:09,390 --> 00:41:11,370
and it basically has n

750
00:41:11,400 --> 00:41:18,490
and it has array of block numbers, etc.

751
00:41:19,000 --> 00:41:22,150
And then you know these block numbers

752
00:41:22,420 --> 00:41:26,140
refer to block that are sitting in the data,

753
00:41:26,170 --> 00:41:28,960
that actually corresponds to the block numbers

754
00:41:28,960 --> 00:41:31,180
that are sort of sitting in this in-memory data structure,

755
00:41:31,240 --> 00:41:33,160
they live in the block cache,

756
00:41:33,820 --> 00:41:36,160
which you know, but now you're well familiar with.

757
00:41:36,760 --> 00:41:38,800
And so, maybe this is like block 10,

758
00:41:38,800 --> 00:41:41,740
is the first block in the log,

759
00:41:41,740 --> 00:41:44,140
or maybe let me take a more concrete example,

760
00:41:44,140 --> 00:41:46,390
from that lines up with our previous things,

761
00:41:46,390 --> 00:41:48,130
maybe this is like 45,

762
00:41:49,440 --> 00:41:52,110
and basically you know somewhere in the in cache,

763
00:41:52,290 --> 00:41:53,010
the block cache,

764
00:41:53,010 --> 00:41:55,470
there's of course whatever block 45,

765
00:41:55,830 --> 00:41:56,610
here is data.

766
00:41:56,880 --> 00:41:57,510
Okay?

767
00:41:58,200 --> 00:41:59,430
That's sort of the structures,

768
00:41:59,580 --> 00:42:06,790
that the on-disk in-memory file system has

769
00:42:06,790 --> 00:42:08,620
and on-disk file system has,

770
00:42:08,620 --> 00:42:10,240
on-disk file system just has the log,

771
00:42:10,390 --> 00:42:12,160
the in-memory has these data structures

772
00:42:12,160 --> 00:42:15,850
to orchestrate these multi write operations that were going to be doing.

773
00:42:17,080 --> 00:42:17,740
Okay?

774
00:42:20,240 --> 00:42:23,360
So, to make this a little more concrete,

775
00:42:23,360 --> 00:42:24,620
let's look at some code.

776
00:42:25,740 --> 00:42:30,030
Then that will help us understand how everything works.

777
00:42:33,580 --> 00:42:37,640
So let me pull up some code.

778
00:42:38,350 --> 00:42:39,970
Okay, let me put this next to it,

779
00:42:40,890 --> 00:42:42,960
we keep that picture,

780
00:42:42,960 --> 00:42:45,420
so that we can look at if we want to

781
00:42:45,420 --> 00:42:47,490
or I can point to it.

782
00:42:48,490 --> 00:42:49,600
Can everybody see my code?

783
00:42:54,410 --> 00:42:57,920
Somebody have to confirmed they seen emacs window.

784
00:42:58,130 --> 00:42:59,450
Yeah we can see it.

785
00:42:59,450 --> 00:42:59,660
Good.

786
00:43:00,380 --> 00:43:01,280
Is it big enough?

787
00:43:04,080 --> 00:43:05,190
I think it's good.

788
00:43:05,520 --> 00:43:05,790
Okay.

789
00:43:05,790 --> 00:43:06,570
That looks good.

790
00:43:07,140 --> 00:43:07,800
Thank you.

791
00:43:08,440 --> 00:43:10,870
Okay, so let's start with,

792
00:43:11,230 --> 00:43:13,150
you know I I talked about transactions,

793
00:43:13,150 --> 00:43:19,030
where you you know the fact that you know we should not commit until,

794
00:43:19,060 --> 00:43:21,610
we should not write to commit a [], until all the writes have done.

795
00:43:22,420 --> 00:43:24,580
And so this means that you should

796
00:43:24,580 --> 00:43:27,220
file system operations must indicates

797
00:43:27,220 --> 00:43:28,780
what the beginning of transaction is

798
00:43:28,780 --> 00:43:30,730
and particularly at the end of the transaction is.

799
00:43:31,340 --> 00:43:33,770
And the way that happens in xv6,

800
00:43:33,770 --> 00:43:35,510
that every file system call,

801
00:43:36,640 --> 00:43:39,070
here's open corresponds to create,

802
00:43:39,070 --> 00:43:40,960
basically starts with begin_op

803
00:43:41,020 --> 00:43:44,050
and begin_op indicates like, okay I want to start a transaction

804
00:43:44,260 --> 00:43:45,760
and I want all the block writes

805
00:43:45,760 --> 00:43:48,250
that I've been doing between begin_op and end_op

806
00:43:48,250 --> 00:43:50,260
which is basically the end of the transaction

807
00:43:50,620 --> 00:43:51,400
to be atomic,

808
00:43:51,490 --> 00:43:54,400
meaning they should be all applied to, or none of them should applied.

809
00:43:54,940 --> 00:43:55,420
Okay?

810
00:43:55,810 --> 00:44:01,060
So every file system call in xv6 has that structure,

811
00:44:01,120 --> 00:44:02,530
basically has begin_op,

812
00:44:02,560 --> 00:44:05,020
then the code and implements the file system call

813
00:44:05,020 --> 00:44:05,830
and then end_op.

814
00:44:07,080 --> 00:44:09,690
And that end_op is basically where the commit operation happens.

815
00:44:10,430 --> 00:44:13,220
So basically between begin_op and end_op,

816
00:44:13,670 --> 00:44:16,730
on-disk or in-memory data structure should be updated,

817
00:44:16,730 --> 00:44:18,980
whenever the in-memory log may be updated,

818
00:44:18,980 --> 00:44:21,020
the block cache might be updated,

819
00:44:21,020 --> 00:44:24,020
but nothing really happens until end_op

820
00:44:24,230 --> 00:44:25,310
and then end_op time,

821
00:44:25,310 --> 00:44:27,890
we're basically going to put things into the log

822
00:44:28,130 --> 00:44:31,670
and then we are done with putting everything in the log,

823
00:44:31,760 --> 00:44:34,700
will actually you know write to commit record or log header.

824
00:44:36,030 --> 00:44:36,630
Okay?

825
00:44:37,180 --> 00:44:37,570
So let's.

826
00:44:39,280 --> 00:44:40,210
So what is interesting,

827
00:44:40,210 --> 00:44:42,340
of course what happens is every write, correctly,

828
00:44:42,340 --> 00:44:45,640
whenever one of these file system calls does a disk write,

829
00:44:45,970 --> 00:44:48,610
you know something must happen,

830
00:44:48,640 --> 00:44:52,870
so if we go back for example to fs.c,

831
00:44:52,870 --> 00:44:54,130
you know look at ialloc,

832
00:44:54,580 --> 00:44:56,980
ialloc basically what it calls,

833
00:44:56,980 --> 00:44:59,530
it doesn't call bwrite directly,

834
00:44:59,830 --> 00:45:03,160
but it actually calls a log_write.

835
00:45:04,250 --> 00:45:06,320
And so we're going to see what log_write does,

836
00:45:06,590 --> 00:45:10,430
log_write is basically a function implemented by logging system,

837
00:45:10,610 --> 00:45:11,600
and every write

838
00:45:11,630 --> 00:45:14,720
basically a file system call dose between begin_op and end_op,

839
00:45:14,990 --> 00:45:16,640
always goes through log_write.

840
00:45:23,350 --> 00:45:24,490
So here's log_write

841
00:45:24,490 --> 00:45:29,320
and log_write actually reasonable straightforward.

842
00:45:29,900 --> 00:45:34,700
Yeah, you know we've written the block, in the block cache,

843
00:45:34,730 --> 00:45:38,480
so somewhere basically 45, maybe this is like the write to 45,

844
00:45:38,720 --> 00:45:42,590
we've updated you know 45 in the block cache,

845
00:45:42,740 --> 00:45:45,890
now we basically record in the in-memory data structures,

846
00:45:45,890 --> 00:45:47,990
that at some point later, at commit point,

847
00:45:48,200 --> 00:45:50,720
we were able to write this log into log.

848
00:45:51,430 --> 00:45:54,040
And so you know basically you know the code is,

849
00:45:54,280 --> 00:45:54,730
oops,

850
00:45:55,480 --> 00:45:57,040
the code is reasonably straightforward,

851
00:45:57,340 --> 00:46:00,640
it acquired a lock on the header

852
00:46:00,850 --> 00:46:03,310
and basically updates the header,

853
00:46:04,100 --> 00:46:09,890
in particular, what does goes through you know the updates n,

854
00:46:09,890 --> 00:46:11,600
and when actually the first thing it does,

855
00:46:11,600 --> 00:46:15,410
it actually sees if there's already a copy of 45 in the,

856
00:46:16,420 --> 00:46:20,410
if 45 is already recorded as being having to write to written to,

857
00:46:20,740 --> 00:46:21,550
and if that's the case,

858
00:46:21,550 --> 00:46:24,040
nothing has to be done, because 45 will be written to.

859
00:46:24,750 --> 00:46:26,100
And so we're done,

860
00:46:26,370 --> 00:46:28,020
sometimes called log absorption.

861
00:46:30,980 --> 00:46:35,240
If you know block 45 is not in the array yet

862
00:46:35,240 --> 00:46:38,990
or not in the the list of blocks or the array of blocks,

863
00:46:38,990 --> 00:46:40,640
that needs to be written to disk,

864
00:46:40,730 --> 00:46:44,900
then basically you know the only thing, this particular piece of code does is

865
00:46:44,900 --> 00:46:48,710
basically bump up and stick that block number that needs to be written

866
00:46:48,710 --> 00:46:51,710
into the next entry or into that entry.

867
00:46:53,210 --> 00:46:54,440
Then the only other thing it does

868
00:46:54,440 --> 00:46:55,730
and I'll talk about this later,

869
00:46:55,970 --> 00:47:00,020
it will pin the block in the buffer cache

870
00:47:00,260 --> 00:47:03,620
and let me postpone why a little while,

871
00:47:03,650 --> 00:47:05,180
but I will come back to that later,

872
00:47:06,560 --> 00:47:08,360
and that's actually all that log_write there doing.

873
00:47:08,480 --> 00:47:12,440
So every file system call that needs to update a block,

874
00:47:12,470 --> 00:47:14,120
updates the block in the block cache

875
00:47:14,150 --> 00:47:19,130
and it basically it appends it to this in-memory data structure,

876
00:47:19,130 --> 00:47:21,050
unless you know it's already there,

877
00:47:21,140 --> 00:47:22,820
in which case you know just absorbs it.

878
00:47:24,630 --> 00:47:25,380
Does that make sense?

879
00:47:29,190 --> 00:47:33,900
So does it mean that bwrite shouldn't be used by itself at all?

880
00:47:34,200 --> 00:47:35,160
Sorry, say again.

881
00:47:35,760 --> 00:47:39,780
bwrite shouldn't be used by itself, only as.

882
00:47:39,930 --> 00:47:41,640
Yes that's correct,

883
00:47:41,820 --> 00:47:43,950
basically all you, one way to think about is

884
00:47:43,950 --> 00:47:47,640
that every bwrite in the file system is replaced by log_write.

885
00:47:53,820 --> 00:47:58,410
Okay, so now let's see what actually happens at end_op,

886
00:47:58,410 --> 00:48:01,170
because that's where the exciting part happens.

887
00:48:02,160 --> 00:48:08,400
And there's a couple of cases that I just wanna avoid talking about,

888
00:48:08,400 --> 00:48:09,240
a little bit later,

889
00:48:09,270 --> 00:48:13,980
because they even this simple logging system actually has some subtle complexities

890
00:48:13,980 --> 00:48:17,580
and most of the [beginning] of this code deals with these subtle complexities.

891
00:48:18,090 --> 00:48:20,550
But if you want to get a normal case,

892
00:48:20,550 --> 00:48:22,350
you know there's or there's the simple case

893
00:48:22,350 --> 00:48:25,890
where no other file system operations are in progress,

894
00:48:26,160 --> 00:48:28,560
we are executing create file

895
00:48:28,620 --> 00:48:31,260
and basically we're getting to the point where we want to commit.

896
00:48:31,940 --> 00:48:36,050
And so the code is pretty straightforward and calls commit,

897
00:48:36,890 --> 00:48:38,090
so let's look at the commit.

898
00:48:41,680 --> 00:48:42,550
So here's commit,

899
00:48:43,140 --> 00:48:47,340
[] commit does to basically steps basically writes the log,

900
00:48:48,140 --> 00:48:52,500
that's basically writing all these, all these block numbers,

901
00:48:52,500 --> 00:48:55,740
that are sitting you know in the in-memory header,

902
00:48:55,920 --> 00:48:58,560
writes them basically all to the header on disk,

903
00:48:58,770 --> 00:49:00,480
including you know there's number n.

904
00:49:02,360 --> 00:49:03,920
Right, and so let's see,

905
00:49:04,340 --> 00:49:06,890
that is that's what write_head does, sorry,

906
00:49:07,440 --> 00:49:10,230
write_log basically writes you know the blocks

907
00:49:10,230 --> 00:49:15,780
from the buffer cache into their respective into the log itself.

908
00:49:16,280 --> 00:49:18,830
So let's see write_log, right above here,

909
00:49:19,640 --> 00:49:21,440
you see what it does,

910
00:49:21,470 --> 00:49:24,770
it goes through you know this array one at a time

911
00:49:25,100 --> 00:49:30,810
and basically writes that to the log position in the log.

912
00:49:31,500 --> 00:49:36,050
Okay, so read you know the log block, then sticks it in there,

913
00:49:36,290 --> 00:49:39,560
by copying it, and then writing it actually out to the disk.

914
00:49:40,880 --> 00:49:43,970
So this basically ensures that log 45 laid up here,

915
00:49:43,970 --> 00:49:45,680
you know say this is 32,

916
00:49:45,680 --> 00:49:47,510
that will end up there etc etc.

917
00:49:49,050 --> 00:49:49,920
Then, at the end,

918
00:49:49,950 --> 00:49:52,020
so at this point we have not committed yet, correct,

919
00:49:52,020 --> 00:49:53,250
the only thing we've done is

920
00:49:53,250 --> 00:49:55,080
basically putting blocks into the log,

921
00:49:55,470 --> 00:49:57,930
and if we were crash at this particular point in time,

922
00:49:57,930 --> 00:50:01,890
before calling write_head before write_head succeeded,

923
00:50:02,010 --> 00:50:05,520
and basically as if the transaction didn't execute at all.

924
00:50:06,810 --> 00:50:08,610
So let's look at the write_head,

925
00:50:09,430 --> 00:50:12,760
so that write_head is what I called earlier, basically the commit point,

926
00:50:13,770 --> 00:50:17,670
and the commit point, basically you know basically it's straightforward

927
00:50:17,670 --> 00:50:21,590
and reach the head of block from disk,

928
00:50:21,590 --> 00:50:23,420
which is probably sitting in the buffer cache,

929
00:50:23,780 --> 00:50:27,770
it you know puts the copies the end,

930
00:50:27,830 --> 00:50:30,830
you know this end into that block,

931
00:50:30,830 --> 00:50:33,920
puts all the block numbers into that array into that block

932
00:50:34,040 --> 00:50:36,410
and it basically writes that that particular block.

933
00:50:37,210 --> 00:50:38,140
This is the,

934
00:50:38,260 --> 00:50:40,870
this bwrite what is that, is that the commit point?

935
00:50:45,420 --> 00:50:47,820
If a crash happens before this bwrite, what happens then?

936
00:50:57,180 --> 00:50:57,780
Anybody?

937
00:50:58,700 --> 00:51:01,820
If the crash happens before bwrite,

938
00:51:01,820 --> 00:51:07,790
isn't the only modification that we've made to the in memory hb data structure,

939
00:51:08,030 --> 00:51:10,220
so it's not, it's going to be fine.

940
00:51:10,610 --> 00:51:11,630
Yeah, it's gonna be fine,

941
00:51:11,630 --> 00:51:15,830
because basically we may have written db1 zero dbn whatever to log,

942
00:51:15,830 --> 00:51:18,290
but we have not succeeded in writing the log header,

943
00:51:18,980 --> 00:51:21,770
and so will do not, on recovery nothing will happen.

944
00:51:22,950 --> 00:51:25,380
And what happens if there's a crash right after to bwrite,

945
00:51:25,380 --> 00:51:26,490
so like crash here.

946
00:51:32,220 --> 00:51:33,330
And it's no longer zero,

947
00:51:33,330 --> 00:51:36,330
so the log headers correctly read and it's recovered.

948
00:51:36,570 --> 00:51:38,280
Yeah, will be recovered, correct.

949
00:51:38,280 --> 00:51:41,070
Well, at some point, hopefully during recovery as we expect that,

950
00:51:41,070 --> 00:51:44,580
we expect the recovery will actually read the log header

951
00:51:44,580 --> 00:51:46,830
see that there is a 5 in there for example,

952
00:51:47,070 --> 00:51:49,680
and then copy the first 5 logs to their home location.

953
00:51:50,530 --> 00:51:53,320
So this is really this, this, this one line,

954
00:51:53,860 --> 00:51:54,880
there's one disk write,

955
00:51:54,880 --> 00:51:56,770
there's one sector write is really the commit point.

956
00:51:58,440 --> 00:51:58,860
Right?

957
00:52:03,380 --> 00:52:07,010
Before the commitment point, the transaction, is the transaction didn't happen,

958
00:52:07,010 --> 00:52:10,130
after the commit point, the transaction will definitely be finished,

959
00:52:11,470 --> 00:52:12,760
assuming your recovery is correct.

960
00:52:18,220 --> 00:52:22,720
Okay, so let's you know go back to commit.

961
00:52:25,020 --> 00:52:26,910
So commit, after its committed,

962
00:52:26,910 --> 00:52:28,770
it actually installs the transactions,

963
00:52:28,830 --> 00:52:30,510
and that's pretty straightforward,

964
00:52:30,510 --> 00:52:32,670
basically it takes the blocks,

965
00:52:32,670 --> 00:52:34,440
looks at the header where the blocks belongs

966
00:52:34,440 --> 00:52:36,390
and then basically writes into that particular location.

967
00:52:37,660 --> 00:52:40,930
Yeah, so we can actually look at install_trans,

968
00:52:41,930 --> 00:52:43,910
you see that actually that's what it does.

969
00:52:45,110 --> 00:52:46,940
It has a copy of the log header

970
00:52:47,270 --> 00:52:50,750
and use or reads log header,

971
00:52:50,750 --> 00:52:53,720
it reach the destination block the home location,

972
00:52:54,290 --> 00:52:59,030
copies the data from the log block into the destination,

973
00:52:59,360 --> 00:53:01,280
and then writes the buffer to the destination.

974
00:53:03,170 --> 00:53:03,830
Okay?

975
00:53:04,730 --> 00:53:06,440
So basically effectively what this does is

976
00:53:06,440 --> 00:53:08,810
basically you know you go back to this previous slide here

977
00:53:08,810 --> 00:53:12,290
and copies, you know it just does these copies from the log

978
00:53:12,290 --> 00:53:14,780
into the home location or actually in the file system.

979
00:53:17,160 --> 00:53:20,340
And of course you know we might get a failure somewhere in you know this code

980
00:53:20,340 --> 00:53:21,630
or while we're doing this,

981
00:53:21,930 --> 00:53:23,370
but you know it should be okay,

982
00:53:23,370 --> 00:53:25,980
because hopefully in recovery will start over from the beginning.

983
00:53:29,150 --> 00:53:32,540
So let's look at we, so that was installed.

984
00:53:33,160 --> 00:53:34,720
So once install is done,

985
00:53:35,750 --> 00:53:42,980
then basically it sets you know the in-memory header and back to 0

986
00:53:43,100 --> 00:53:44,630
and then writes that log header.

987
00:53:45,500 --> 00:53:51,650
And effectively that causes to cleans the log,

988
00:53:51,650 --> 00:53:53,270
because basically there's now 0 in it.

989
00:53:53,900 --> 00:53:54,500
Question?

990
00:53:56,130 --> 00:54:02,470
So, you have the function you're in just before,

991
00:54:02,740 --> 00:54:06,970
like whereas, does the from to, or to, or something,

992
00:54:07,150 --> 00:54:12,350
so that puts the, the block that you're going to like update,

993
00:54:12,410 --> 00:54:17,030
the log that you're going to update into the buffer cache,

994
00:54:17,840 --> 00:54:19,700
could you make it faster

995
00:54:19,700 --> 00:54:21,950
by not putting into the buffer cache

996
00:54:21,950 --> 00:54:25,770
and just directly writing it to the device instead.

997
00:54:26,680 --> 00:54:30,490
Let me, which function we're talking about?

998
00:54:31,770 --> 00:54:34,110
I forget its name,

999
00:54:34,140 --> 00:54:38,790
it's the one, where you copy, yeah, everything into the log.

1000
00:54:39,030 --> 00:54:41,370
Okay, install install_trans.

1001
00:54:42,920 --> 00:54:45,680
I think so.

1002
00:54:47,160 --> 00:54:48,840
Oh, maybe it was this one.

1003
00:54:50,220 --> 00:54:50,520
So, this.

1004
00:54:50,520 --> 00:54:53,760
I thinking probably of write_head, but it's the same thing.

1005
00:54:54,180 --> 00:54:55,770
Okay, good.

1006
00:54:57,630 --> 00:55:01,490
The only reason, the only reason to this,

1007
00:55:01,490 --> 00:55:03,320
you know basically our interface is not particularly good,

1008
00:55:03,320 --> 00:55:04,610
you could just read straight,

1009
00:55:04,610 --> 00:55:07,370
you know you're wondering why you are doing the read,

1010
00:55:07,980 --> 00:55:09,600
there's no reason to do the read,

1011
00:55:09,600 --> 00:55:11,940
because we're going to write anyway,

1012
00:55:12,210 --> 00:55:13,110
is that the question?

1013
00:55:14,980 --> 00:55:18,760
Yeah, that and you're also doing the memmove.

1014
00:55:19,450 --> 00:55:20,560
And did the memmove, yeah,

1015
00:55:20,620 --> 00:55:23,380
so these are actually a sequence of code can definitely be optimized,

1016
00:55:23,470 --> 00:55:26,140
you can save you know one or two disk writes.

1017
00:55:26,600 --> 00:55:29,690
Just for simplicity, we don't do any of that.

1018
00:55:30,270 --> 00:55:31,200
Okay, thank you.

1019
00:55:35,170 --> 00:55:39,650
Okay, so I think we're in over commit,

1020
00:55:40,410 --> 00:55:43,980
just like, just go back and double check.

1021
00:55:44,540 --> 00:55:46,160
So we did the write_log,

1022
00:55:46,160 --> 00:55:47,210
we did the write_head

1023
00:55:47,270 --> 00:55:49,610
and basically this the cleaning operation,

1024
00:55:50,430 --> 00:55:54,030
we erased you know transaction by sending it to zero.

1025
00:55:54,150 --> 00:55:54,690
Okay?

1026
00:55:55,880 --> 00:55:58,370
So the only thing to further inspect is

1027
00:55:58,370 --> 00:56:00,290
like how, how does recovery work

1028
00:56:00,320 --> 00:56:06,300
and so recovery happens when you know when xv6 starts,

1029
00:56:06,720 --> 00:56:08,370
so now we had a crash,

1030
00:56:08,370 --> 00:56:11,340
and the system failed, we reboot it,

1031
00:56:11,370 --> 00:56:17,070
and the, one of the first things that xv6,

1032
00:56:17,430 --> 00:56:21,180
one of the things that xv6 does during initialization,

1033
00:56:21,210 --> 00:56:22,650
it actually call initlog,

1034
00:56:23,390 --> 00:56:27,050
and initlog basically calls this function recover_from_log

1035
00:56:27,230 --> 00:56:28,790
and so let's see what that does.

1036
00:56:30,110 --> 00:56:34,400
And basically recover_from_log you know calls read_head,

1037
00:56:34,920 --> 00:56:38,220
to basically extract or read the.

1038
00:56:39,300 --> 00:56:42,120
Then, let me see if I can scroll down here a little bit.

1039
00:56:45,580 --> 00:56:47,290
Basically reads the header from disk,

1040
00:56:48,100 --> 00:56:49,360
and sees if n,

1041
00:56:49,920 --> 00:56:52,560
well, doesn't really see if n is zero or not,

1042
00:56:52,560 --> 00:56:54,450
but it just calls install_trans

1043
00:56:54,600 --> 00:56:57,090
and you know this is exactly the same install_trans

1044
00:56:57,090 --> 00:57:00,480
we use look for it, for a look at it a while ago.

1045
00:57:00,720 --> 00:57:02,430
And basically you know look at the n

1046
00:57:02,430 --> 00:57:04,920
and installs all the blocks from 0 to n

1047
00:57:05,220 --> 00:57:07,080
out of the log into their home location.

1048
00:57:07,850 --> 00:57:08,780
And if it's done,

1049
00:57:08,870 --> 00:57:09,890
once it succeeds,

1050
00:57:09,890 --> 00:57:14,020
you know then actually it calls clear log as before.

1051
00:57:14,820 --> 00:57:17,160
And so that's actually all what the recovery does,

1052
00:57:17,160 --> 00:57:20,370
recovery is basically always call does installation.

1053
00:57:21,010 --> 00:57:23,740
And if we crash during installation here,

1054
00:57:24,130 --> 00:57:25,720
no particular problem again, correct,

1055
00:57:25,720 --> 00:57:27,430
because we'll crash, we'll boot,

1056
00:57:27,730 --> 00:57:31,660
xv6 rebooting will call loginit,

1057
00:57:31,840 --> 00:57:33,310
which will call recover_from_log

1058
00:57:33,340 --> 00:57:37,810
and it will basically re-install, replay the log is sometimes called again,

1059
00:57:37,870 --> 00:57:40,270
and this might have, this might end,

1060
00:57:40,330 --> 00:57:43,750
if we crash every time or you know many many times,

1061
00:57:44,020 --> 00:57:47,320
you know we'll re-install or replay the log many many many times,

1062
00:57:47,380 --> 00:57:49,480
they'll tell hopefully at some point it succeeds

1063
00:57:49,600 --> 00:57:52,390
and actually you know gets the whole log written,

1064
00:57:53,320 --> 00:57:54,880
gets the whole log installed,

1065
00:57:54,910 --> 00:57:57,790
you know to the, to home locations.

1066
00:57:59,430 --> 00:58:00,030
Does it make sense?

1067
00:58:03,580 --> 00:58:05,410
I had a question about,

1068
00:58:05,740 --> 00:58:08,800
so if a process just runs normally,

1069
00:58:08,950 --> 00:58:11,560
it writes some data to disk,

1070
00:58:11,920 --> 00:58:13,390
and then at some point after that,

1071
00:58:13,570 --> 00:58:16,870
before it commits and installs the changes,

1072
00:58:17,370 --> 00:58:19,410
there's a failure,

1073
00:58:19,530 --> 00:58:24,380
the process, the further process point of view, nothing happened,

1074
00:58:24,380 --> 00:58:25,910
but something like,

1075
00:58:26,880 --> 00:58:32,430
I guess the failure happened after the process end of what I was doing,

1076
00:58:33,060 --> 00:58:35,100
so, is there anything bad about that?

1077
00:58:36,170 --> 00:58:37,790
Not hundred percent getting it,

1078
00:58:37,790 --> 00:58:41,450
but a short answer is there's nothing bad,

1079
00:58:41,480 --> 00:58:43,490
because the disk won't be updated at all,

1080
00:58:43,520 --> 00:58:47,240
so just as if you know that file system operation didn't happen.

1081
00:58:48,130 --> 00:58:50,960
Alright, I guess.

1082
00:58:50,990 --> 00:58:52,520
Process disappears too,

1083
00:58:52,520 --> 00:58:56,420
but, you know we don't expect the process to survive failures anyway.

1084
00:58:58,150 --> 00:59:00,740
Right or I guess,

1085
00:59:01,200 --> 00:59:04,050
okay I I think that answers my question, thank you.

1086
00:59:05,720 --> 00:59:07,370
Yeah, it's important to remember to

1087
00:59:07,370 --> 00:59:11,180
basically the only thing that really survives failures

1088
00:59:11,210 --> 00:59:13,070
or that's persistence across failures is

1089
00:59:13,070 --> 00:59:15,980
the disk or the state on the disk nothing else, right.

1090
00:59:19,620 --> 00:59:23,580
Okay, so just to make this all concrete one little more to,

1091
00:59:23,580 --> 00:59:24,450
let's.

1092
00:59:25,160 --> 00:59:29,270
I put a statement in bwrite,

1093
00:59:29,270 --> 00:59:31,820
so actually the thing that actually does write to disk,

1094
00:59:31,850 --> 00:59:33,380
like in the block cache.

1095
00:59:33,920 --> 00:59:37,970
And we're going to see what the trace of actual disk writes are.

1096
00:59:38,600 --> 00:59:40,130
Because basically on Monday,

1097
00:59:40,130 --> 00:59:45,210
I sort of, I didn't tell the full truth,

1098
00:59:45,240 --> 00:59:48,000
because basically I put the print statement in log_write

1099
00:59:48,030 --> 00:59:49,560
and not in bwrite,

1100
00:59:49,650 --> 00:59:51,390
and so now I put it in the bwrite

1101
00:59:51,390 --> 00:59:53,670
and so we can actually see all the blocks are being written.

1102
00:59:54,380 --> 00:59:55,970
So we'll do the same thing as before,

1103
00:59:55,970 --> 00:59:57,290
you know echo hi x,

1104
00:59:57,650 --> 00:59:59,930
and just look at actually the actual disk writes.

1105
01:00:01,120 --> 01:00:02,290
And see if that makes sense,

1106
01:00:02,350 --> 01:00:03,820
you know so the first thing to note correctly,

1107
01:00:03,820 --> 01:00:07,390
that this traces way longer than the trace that we looked at last time,

1108
01:00:07,390 --> 01:00:10,600
the fact that we looked at a slide a couple slides ago, right.

1109
01:00:11,480 --> 01:00:12,380
Because you're looking at,

1110
01:00:12,380 --> 01:00:14,120
in fact you know just demonstrate this,

1111
01:00:15,440 --> 01:00:20,210
here was the same echo hi, correct.

1112
01:00:20,980 --> 01:00:26,220
And when we see there's like only it's 5 log_write operations,

1113
01:00:26,400 --> 01:00:32,120
but it turns into many disk operations, correct.

1114
01:00:32,780 --> 01:00:33,650
So let's look at it.

1115
01:00:34,680 --> 01:00:38,910
So what we think bwrite 3 4 and 5 are

1116
01:00:39,000 --> 01:00:40,110
and what is bwrite 2.

1117
01:00:48,710 --> 01:00:49,370
Anybody?

1118
01:00:50,080 --> 01:00:53,620
So writing to the log and then the super block.

1119
01:00:54,580 --> 01:00:55,990
Not the super block.

1120
01:00:56,110 --> 01:00:57,610
No, sorry, that's the log_head.

1121
01:00:57,640 --> 01:01:00,550
Yeah, so just look at, you got it right,

1122
01:01:00,550 --> 01:01:02,290
you know just looking at this picture again, correct,

1123
01:01:02,680 --> 01:01:03,850
the log structure 2,

1124
01:01:03,880 --> 01:01:06,070
so, that's probably the header block

1125
01:01:06,460 --> 01:01:07,720
to commit record if you will,

1126
01:01:08,110 --> 01:01:09,910
and then 3 is the first data block,

1127
01:01:09,910 --> 01:01:11,080
4 is the second data block,

1128
01:01:11,080 --> 01:01:12,310
5 is the third data block.

1129
01:01:13,540 --> 01:01:16,870
So going back, you know this is the first write,

1130
01:01:17,630 --> 01:01:19,790
the second write, the third write,

1131
01:01:20,210 --> 01:01:22,430
they're all going into the log

1132
01:01:22,910 --> 01:01:24,290
and they're written to disk,

1133
01:01:24,890 --> 01:01:26,900
in the log log part of the disk,

1134
01:01:27,170 --> 01:01:30,470
and then this is the commit record header.

1135
01:01:31,060 --> 01:01:32,680
And then presumably what is this face?

1136
01:01:41,720 --> 01:01:42,680
What is this part?

1137
01:01:43,340 --> 01:01:45,080
Is that the bitmap setting?

1138
01:01:45,900 --> 01:01:49,710
No, so what do we think actually stored in this bwrite 3?

1139
01:01:51,980 --> 01:01:57,440
Here you creating the file of the inode for x,

1140
01:01:57,440 --> 01:02:00,170
updating the directory

1141
01:02:00,170 --> 01:02:02,900
and then also actually making the file itself.

1142
01:02:03,360 --> 01:02:05,760
Yeah, and so and we didn't do it here, right,

1143
01:02:05,760 --> 01:02:08,310
because in these bwrites that didn't happen.

1144
01:02:08,900 --> 01:02:09,800
Now we're doing it.

1145
01:02:11,090 --> 01:02:13,700
So what, what what phases of the transaction?

1146
01:02:16,200 --> 01:02:17,940
Installing the changes.

1147
01:02:17,970 --> 01:02:19,440
Yeah, installing the changes, correct,

1148
01:02:19,440 --> 01:02:20,760
what we did here is,

1149
01:02:21,490 --> 01:02:24,260
we log the write,

1150
01:02:24,650 --> 01:02:28,370
then we committed the file system operation the create operation

1151
01:02:28,370 --> 01:02:29,540
and now we're installing it,

1152
01:02:30,430 --> 01:02:32,440
for now we're putting the blocks in their home location.

1153
01:02:34,300 --> 01:02:37,370
And now, and what does this bwrite 2 then?

1154
01:02:44,500 --> 01:02:45,760
Clearing the log.

1155
01:02:45,760 --> 01:02:47,140
Yeah, it's clear log, exactly.

1156
01:02:47,760 --> 01:02:49,260
So basically this, this, this,

1157
01:02:50,510 --> 01:02:53,540
the system call was writing 33 46 32

1158
01:02:53,840 --> 01:02:56,150
and to actually do that using the logging system

1159
01:02:56,150 --> 01:03:01,830
that basically turns into this set of disk write, right.

1160
01:03:01,830 --> 01:03:04,110
Where the first part is installing the log,

1161
01:03:04,110 --> 01:03:06,060
in the first part is actually logging the writes,

1162
01:03:06,060 --> 01:03:07,860
in the second part is installing the log.

1163
01:03:09,860 --> 01:03:11,810
And these are the two writes due to commit records.

1164
01:03:15,040 --> 01:03:15,700
So it makes sense?

1165
01:03:15,790 --> 01:03:21,160
Is it possible to infer where begin_op and end_op would run from this trace?

1166
01:03:21,760 --> 01:03:24,640
Well, so we're sort of no, correct,

1167
01:03:24,640 --> 01:03:27,400
so where did, we don't really know what begin_op start,

1168
01:03:27,400 --> 01:03:30,550
but this is any file system calls starts with the begin_op,

1169
01:03:31,420 --> 01:03:33,250
and it must be the case that,

1170
01:03:33,900 --> 01:03:37,530
the commit record correct is written in end_op,

1171
01:03:37,890 --> 01:03:44,050
so we know that this is the end_op of some file system operation.

1172
01:03:48,010 --> 01:03:48,910
Does that make sense?

1173
01:03:53,270 --> 01:03:58,520
Okay, so that's basically xv6 log logging in action,

1174
01:03:58,880 --> 01:04:01,370
and I want talk about a couple complications,

1175
01:04:01,700 --> 01:04:09,860
and even this dirt simple naive logging scheme actually has complications.

1176
01:04:10,540 --> 01:04:13,480
One thing to immediately note of course is,

1177
01:04:13,960 --> 01:04:17,440
you know is this a very performance implementation?

1178
01:04:18,710 --> 01:04:20,060
You can by looking at this trace.

1179
01:04:26,990 --> 01:04:27,620
No.

1180
01:04:28,190 --> 01:04:29,270
Why not,

1181
01:04:30,320 --> 01:04:32,510
I know this is a basically two simple questions,

1182
01:04:32,510 --> 01:04:34,790
but it's important to ask.

1183
01:04:36,510 --> 01:04:41,230
Like, you're writing the stuff twice right.

1184
01:04:41,260 --> 01:04:42,790
Yeah, you're writing the stuff twice,

1185
01:04:42,790 --> 01:04:44,920
write a file f or a big file f,

1186
01:04:44,950 --> 01:04:46,660
I'm going to write that big file f twice.

1187
01:04:48,000 --> 01:04:51,180
And so, certainly not particularly high performance, right,

1188
01:04:51,180 --> 01:04:53,970
I mean basically re-cutting the performance immediately by a factor of two,

1189
01:04:55,680 --> 01:04:56,940
just to get crash safety.

1190
01:04:57,620 --> 01:05:00,500
And so we'll see on on you

1191
01:05:00,500 --> 01:05:05,570
when you're reading the ext ext3 paper for Monday

1192
01:05:05,660 --> 01:05:07,220
and one thing you should keep in your head,

1193
01:05:07,220 --> 01:05:08,450
while reading is get,

1194
01:05:08,450 --> 01:05:12,060
how, how do I get around for this factor of two.

1195
01:05:15,140 --> 01:05:15,710
Okay?

1196
01:05:16,660 --> 01:05:20,500
Sorry, is it the case that you write the h and the i separately?

1197
01:05:21,460 --> 01:05:23,260
Yeah, I think so.

1198
01:05:23,960 --> 01:05:25,010
Okay.

1199
01:05:25,010 --> 01:05:27,860
I'll, I'll show you in a second why,

1200
01:05:27,980 --> 01:05:29,420
what is happening there.

1201
01:05:31,760 --> 01:05:33,320
Or maybe,

1202
01:05:34,960 --> 01:05:37,420
well, let me not commit too much the answer,

1203
01:05:37,540 --> 01:05:39,580
but I will get back to it.

1204
01:05:40,210 --> 01:05:44,140
Oh, sorry, am I having the empty line, not the h and i, but yeah.

1205
01:05:44,620 --> 01:05:45,070
The new line is a separate write,

1206
01:05:45,100 --> 01:05:49,480
h and i is one write, new line is a separate write.

1207
01:05:49,810 --> 01:05:50,920
Okay, thank you.

1208
01:05:51,760 --> 01:05:52,450
You're welcome.

1209
01:05:52,960 --> 01:05:56,650
Okay, there's complications

1210
01:05:56,740 --> 01:05:59,260
and I want to talk a little bit about these complications.

1211
01:06:05,970 --> 01:06:08,490
Here's our basic scheme, basic data structures,

1212
01:06:08,910 --> 01:06:11,880
and there's three complications I want to talk about.

1213
01:06:15,360 --> 01:06:17,760
Maybe I'll call them challenges, whatever you wanna call them.

1214
01:06:21,490 --> 01:06:23,260
The first is eviction.

1215
01:06:29,080 --> 01:06:30,940
And the issue is as follows,

1216
01:06:31,000 --> 01:06:32,950
let's say we go back to this picture here,

1217
01:06:33,920 --> 01:06:35,840
and you know bcache is full,

1218
01:06:37,950 --> 01:06:42,000
and, and sort of transaction in progress,

1219
01:06:42,090 --> 01:06:45,000
let's see, we've just updated 45,

1220
01:06:45,570 --> 01:06:47,430
it's now done block 45,

1221
01:06:47,430 --> 01:06:48,750
so it's going to write the next block,

1222
01:06:49,530 --> 01:06:50,790
and the cache is full.

1223
01:06:51,700 --> 01:06:56,480
And, the and,

1224
01:06:57,910 --> 01:07:01,150
let's say you know we don't we don't have a solution for this yet,

1225
01:07:01,360 --> 01:07:07,060
but the cache decides, it wants to evict 45 correct,

1226
01:07:07,300 --> 01:07:08,980
and if it wants to evict 45,

1227
01:07:08,980 --> 01:07:10,120
but will mean that will mean,

1228
01:07:10,120 --> 01:07:12,040
we have to write it to its home location.

1229
01:07:13,720 --> 01:07:19,370
How bad would it be to write the block, you know evict 45,

1230
01:07:21,060 --> 01:07:23,250
and write 45 to home location.

1231
01:07:28,600 --> 01:07:29,800
Is that good or bad?

1232
01:07:44,290 --> 01:07:46,270
Would any rule be broken, if we did that?

1233
01:07:47,410 --> 01:07:51,760
I guess, that as if a crash happens

1234
01:07:51,760 --> 01:07:56,290
before the other writes in the same transaction occurs,

1235
01:07:56,290 --> 01:07:59,170
then basically atomicity it is broken.

1236
01:08:02,980 --> 01:08:06,280
That is basically violates this write-ahead rule that I talked about,

1237
01:08:07,610 --> 01:08:09,710
you have to write all the blocks to the log,

1238
01:08:09,710 --> 01:08:12,380
before you write any block to each home location.

1239
01:08:25,780 --> 01:08:27,040
So it has to be the case correct,

1240
01:08:27,040 --> 01:08:31,660
the cache does not evict any block that sits in the log.

1241
01:08:32,640 --> 01:08:33,420
Does that make sense?

1242
01:08:34,750 --> 01:08:43,490
So the solution is don't evict blocks those are in the log.

1243
01:08:49,330 --> 01:08:52,990
And this is exactly what you were showing a little bit earlier

1244
01:08:52,990 --> 01:08:54,490
and said I didn't want to talk about.

1245
01:08:54,880 --> 01:08:58,120
So you go to log_write again,

1246
01:08:58,120 --> 01:08:59,830
just to see for a second there,

1247
01:09:00,480 --> 01:09:03,720
log_write here log_write again

1248
01:09:04,140 --> 01:09:06,780
and here we see this call to bpin,

1249
01:09:07,620 --> 01:09:09,000
and what do you think bpin does,

1250
01:09:11,240 --> 01:09:12,710
name sort of indicates it.

1251
01:09:16,590 --> 01:09:21,970
It pins the block in the, in the cache.

1252
01:09:22,000 --> 01:09:23,260
Yeah, how does it do it,

1253
01:09:23,530 --> 01:09:27,340
since you've been looking at this where your current lab extensively.

1254
01:09:28,890 --> 01:09:29,700
What do you think it does.

1255
01:09:30,840 --> 01:09:33,180
So we can look at the implementation with bpin,

1256
01:09:33,180 --> 01:09:34,710
but we can also guess what it does.

1257
01:09:40,000 --> 01:09:41,560
Doesn't it essentially just make it,

1258
01:09:41,590 --> 01:09:44,740
so that it doesn't get evicted by increasing the ref counts.

1259
01:09:44,770 --> 01:09:46,300
Yeah, exactly this is all thing does,

1260
01:09:46,330 --> 01:09:47,950
bpin just to increases the refcnt

1261
01:09:47,950 --> 01:09:50,080
and we know from the bcache code, correct,

1262
01:09:50,530 --> 01:09:54,520
evict won't evict any blocks we have reference higher than 0.

1263
01:09:56,440 --> 01:10:00,010
And so presumably somewhere later in the logging code,

1264
01:10:00,010 --> 01:10:02,440
when once actually a thing is logged,

1265
01:10:02,440 --> 01:10:05,170
we can actually unpin the block, right.

1266
01:10:06,530 --> 01:10:07,880
Okay, so that's one complication,

1267
01:10:07,880 --> 01:10:09,800
so we have this pinning and unpinning going on.

1268
01:10:11,080 --> 01:10:14,170
Let's look at another complication,

1269
01:10:29,970 --> 01:10:34,260
you know the file system operations must fit in log.

1270
01:10:41,460 --> 01:10:43,650
If you see, we go back to our picture here,

1271
01:10:43,650 --> 01:10:45,570
or actually maybe this is a better picture,

1272
01:10:46,120 --> 01:10:48,040
how big is the log in xv6?

1273
01:10:53,520 --> 01:10:54,600
30 blocks.

1274
01:10:54,630 --> 01:10:56,340
Yeah, 30 blocks, 32 minus 2,

1275
01:10:56,700 --> 01:11:01,110
so you know max size, max log size is 30.

1276
01:11:03,840 --> 01:11:05,250
Of course we could bump it up

1277
01:11:05,640 --> 01:11:08,160
in real file system runs with a much bigger log,

1278
01:11:08,160 --> 01:11:09,360
but it doesn't really matter,

1279
01:11:09,720 --> 01:11:12,090
no matter what, it has to be the case, correct,

1280
01:11:12,090 --> 01:11:15,120
the file system operation must fit in 30 blocks.

1281
01:11:16,010 --> 01:11:19,010
Because if a file system operation would try to write more to 30 blocks,

1282
01:11:19,280 --> 01:11:22,430
that means we would have to spill something on this location

1283
01:11:22,430 --> 01:11:23,480
and we're not allowed to do that,

1284
01:11:23,510 --> 01:11:25,610
because that would violate the write-ahead rule again.

1285
01:11:26,270 --> 01:11:29,600
So it has to be the case that every file system operation fits into the log.

1286
01:11:31,440 --> 01:11:32,190
Does that make sense?

1287
01:11:35,040 --> 01:11:39,050
In fact, you know how do you think we got to 32 or 30?

1288
01:11:50,670 --> 01:11:53,970
Does it have to do anything with how many blocks actually fit?

1289
01:11:55,060 --> 01:11:56,050
You were a way to

1290
01:11:56,110 --> 01:12:01,540
like basically how many blocks does the maximum blocks, correct,

1291
01:12:01,540 --> 01:12:03,190
the file system operation could write.

1292
01:12:04,280 --> 01:12:05,120
And that is really what,

1293
01:12:05,120 --> 01:12:09,110
this number 30 has to be definitely bigger than

1294
01:12:09,110 --> 01:12:21,280
any you know the max number of blocks the file system operation write.

1295
01:12:26,570 --> 01:12:28,610
And so, in fact you know Robert and I did,

1296
01:12:28,610 --> 01:12:30,500
because we went through all the file system operations,

1297
01:12:30,500 --> 01:12:31,070
looked at them

1298
01:12:31,070 --> 01:12:34,460
and decide whether what's the maximum number is

1299
01:12:34,460 --> 01:12:37,040
and it turns out that the actual number is much lower than the 30,

1300
01:12:37,340 --> 01:12:41,120
but you know we'll see in a second a couple interesting complications,

1301
01:12:42,870 --> 01:12:44,850
like, for example the operation that we look so far,

1302
01:12:44,850 --> 01:12:47,280
like creating a file correct is only a handful of blocks,

1303
01:12:47,310 --> 01:12:49,590
the file system operation is like 5 blocks,

1304
01:12:49,920 --> 01:12:54,600
in fact, most operations are a handful of blocks not that many,

1305
01:12:54,690 --> 01:12:58,080
do you think of any operations that might write many many, many blocks?

1306
01:13:13,470 --> 01:13:15,450
You're write on a huge file.

1307
01:13:15,600 --> 01:13:16,890
Yeah, write a huge file, right.

1308
01:13:16,890 --> 01:13:21,280
So, what if we you know, call the write system call

1309
01:13:21,280 --> 01:13:23,650
and we pass the buffer with have a megabyte of data,

1310
01:13:24,680 --> 01:13:25,940
like a thousand blocks.

1311
01:13:27,030 --> 01:13:28,920
It seems like we're being serious trouble right,

1312
01:13:29,100 --> 01:13:31,410
it would violate you know these maximum.

1313
01:13:32,010 --> 01:13:36,290
And so, let's look at write,

1314
01:13:44,080 --> 01:13:44,680
sys_write,

1315
01:13:48,070 --> 01:13:49,870
sys_write calls filewrite,

1316
01:13:51,070 --> 01:13:53,440
filewrite, here's filewrite.

1317
01:13:54,180 --> 01:13:57,810
Okay, so here's an inode, file descriptor inode

1318
01:13:57,840 --> 01:13:58,890
and [] see my code

1319
01:13:59,160 --> 01:14:00,720
or the code that I've on the display

1320
01:14:01,110 --> 01:14:04,380
and notice that what does this code do.

1321
01:14:09,440 --> 01:14:11,840
Yeah, you read the comments write on top here

1322
01:14:11,840 --> 01:14:13,070
and then basically explains it,

1323
01:14:13,070 --> 01:14:14,120
but this is what happens, correct,

1324
01:14:14,120 --> 01:14:17,330
the write is split in many number smaller writes.

1325
01:14:18,710 --> 01:14:21,560
So what really is going on here, correct,

1326
01:14:21,560 --> 01:14:24,350
we are ensuring that the

1327
01:14:25,000 --> 01:14:28,150
the whole write is a whole is not atomic,

1328
01:14:28,180 --> 01:14:31,000
that's okay, you know the write Unix system call semantics,

1329
01:14:31,000 --> 01:14:34,600
don't actually require that actually all the thousand blocks,

1330
01:14:34,630 --> 01:14:37,060
you know a megabyte or actually written atomically

1331
01:14:37,270 --> 01:14:39,970
and just requires that we don't corrupt the file system,

1332
01:14:40,120 --> 01:14:43,570
between don't corrupt the file system while doing it.

1333
01:14:44,090 --> 01:14:46,010
And so basically we,

1334
01:14:46,010 --> 01:14:49,880
yeah, xv6 splits a big write in a number of smaller writes

1335
01:14:49,880 --> 01:14:51,920
and writes them as individual transactions.

1336
01:14:53,160 --> 01:14:55,110
And this would basically ensures that our example,

1337
01:14:55,110 --> 01:14:57,360
if transaction allocates a block number,

1338
01:14:57,360 --> 01:15:00,030
because we need a new block as an intermediate block were,

1339
01:15:00,030 --> 01:15:00,960
because we need a new block,

1340
01:15:00,960 --> 01:15:01,980
because we're going to write to it,

1341
01:15:02,310 --> 01:15:04,320
at least that part is completely atomic

1342
01:15:04,320 --> 01:15:07,230
and the file system will be never left in an incorrect state,

1343
01:15:07,440 --> 01:15:10,020
violating any of the file system invariance.

1344
01:15:10,490 --> 01:15:12,320
And so the write is split in many, many,

1345
01:15:15,150 --> 01:15:18,120
many system in many smaller writes or many transactions.

1346
01:15:19,310 --> 01:15:20,060
Okay?

1347
01:15:20,560 --> 01:15:23,950
In fact, that's the main one that actually is

1348
01:15:25,780 --> 01:15:30,920
write fs split in many, many transactions.

1349
01:15:37,490 --> 01:15:38,510
Any questions about this?

1350
01:15:43,590 --> 01:15:46,470
A note, because you know things are pins correct in cache,

1351
01:15:46,470 --> 01:15:50,100
that means also that the block cache was may bigger than

1352
01:15:51,330 --> 01:15:53,130
the bigger to the logsize.

1353
01:15:57,910 --> 01:15:58,630
Okay.

1354
01:15:59,250 --> 01:16:05,010
So now the final challenge that I want to talk about is

1355
01:16:05,100 --> 01:16:08,660
concurrent file system calls.

1356
01:16:18,110 --> 01:16:19,670
And the issue as follows,

1357
01:16:19,700 --> 01:16:21,950
let me first try to explain what the problem is

1358
01:16:21,980 --> 01:16:23,900
and then we'll see what the solution is.

1359
01:16:25,730 --> 01:16:27,740
So let's say we have our log,

1360
01:16:29,240 --> 01:16:32,030
and, and we're writing

1361
01:16:32,120 --> 01:16:34,760
and maybe there are two transactions executing concurrently.

1362
01:16:36,010 --> 01:16:38,110
And usually imagine for a second,

1363
01:16:38,110 --> 01:16:42,490
that you know they write a lot of blocks,

1364
01:16:42,520 --> 01:16:46,270
so basically t0 is executing t0 is executing

1365
01:16:46,270 --> 01:16:50,870
and there also is the beginning of the log, here end of log.

1366
01:16:51,430 --> 01:16:57,070
And, you know t1 executes some blocks and etc, etc,

1367
01:16:57,310 --> 01:16:59,320
and by the time we run to the end of the log,

1368
01:16:59,590 --> 01:17:00,490
neither one is complete,

1369
01:17:00,490 --> 01:17:03,430
you know, so both have still more writes to do.

1370
01:17:04,600 --> 01:17:10,950
And, at this point, can we commit any of the two transactions?

1371
01:17:14,740 --> 01:17:15,910
No, we can't, correct,

1372
01:17:15,910 --> 01:17:20,140
because if we would commit, transaction that is partially done,

1373
01:17:20,700 --> 01:17:24,420
then we violate the write-ahead rule again

1374
01:17:24,420 --> 01:17:27,510
and you know the purpose actually logging there doesn't work out.

1375
01:17:28,440 --> 01:17:30,840
So it has to be the case,

1376
01:17:30,840 --> 01:17:35,730
that basically a number of concurrent transactions must fit in the log,

1377
01:17:35,790 --> 01:17:55,500
in fact all concurrent operations, must fit.

1378
01:17:55,710 --> 01:17:59,250
And so, in the way,

1379
01:18:00,370 --> 01:18:01,600
so this is sort of a challenge, correct,

1380
01:18:01,600 --> 01:18:03,580
we have a file system call starting

1381
01:18:03,580 --> 01:18:09,400
and you know we gotta arranged basically the that we,

1382
01:18:10,500 --> 01:18:14,250
we basically do a sort of an entrance you know check,

1383
01:18:14,250 --> 01:18:17,580
you know before we actually let the file system operation go,

1384
01:18:17,610 --> 01:18:20,370
we must check whether there actually is enough blocks still,

1385
01:18:20,400 --> 01:18:23,640
you know if we have n file system operations already in progress,

1386
01:18:23,700 --> 01:18:27,540
we have to make sure that if we allow one more guy to start,

1387
01:18:27,630 --> 01:18:29,880
that actually the total number of blocks, right,

1388
01:18:29,880 --> 01:18:31,950
they could write together actually fits in the log.

1389
01:18:33,000 --> 01:18:36,330
And the way you know basically xv6 you know gets around this,

1390
01:18:36,450 --> 01:18:39,690
basically limits the number of concurrent file system calls.

1391
01:18:49,150 --> 01:18:52,540
And the way it basically works is that,

1392
01:18:54,480 --> 01:18:56,730
and begin_op you would see,

1393
01:18:56,730 --> 01:19:00,450
how many outstanding concurrent files with transaction are in progress,

1394
01:19:00,540 --> 01:19:02,490
if there are too many in progress,

1395
01:19:02,520 --> 01:19:05,790
we just stock the current file system operation and goes to sleep

1396
01:19:06,000 --> 01:19:09,450
and it will wait until all the other guys are done and have committed.

1397
01:19:10,870 --> 01:19:13,030
And all the other guys will commit together,

1398
01:19:13,060 --> 01:19:16,240
in fact you know at some point t1 t2, they're basically done,

1399
01:19:16,450 --> 01:19:17,950
maybe t3 in there too,

1400
01:19:18,160 --> 01:19:19,180
they finish

1401
01:19:19,270 --> 01:19:22,060
and then basically in all these transactions

1402
01:19:22,060 --> 01:19:25,300
and in single time a single basically committed together,

1403
01:19:27,870 --> 01:19:29,430
this is sometimes called group commit.

1404
01:19:30,060 --> 01:19:32,250
Because you're committing multiple system calls,

1405
01:19:32,370 --> 01:19:34,290
you know all the ones that were concurrent in action,

1406
01:19:34,650 --> 01:19:38,520
you committed together as a single big transactions,

1407
01:19:38,520 --> 01:19:41,130
so that all there updates are visible.

1408
01:19:41,840 --> 01:19:44,690
So that all there updates, all place, all,

1409
01:19:45,350 --> 01:19:47,330
so that all there updates,

1410
01:19:47,330 --> 01:19:49,160
all take place or none of them take place.

1411
01:19:50,390 --> 01:19:50,990
Okay?

1412
01:19:52,990 --> 01:19:56,620
And we can see that you know, if you go to.

1413
01:19:56,620 --> 01:19:57,460
A quick question.

1414
01:19:58,780 --> 01:19:59,320
Yeah.

1415
01:19:59,320 --> 01:20:04,910
Is that, is the group commit, is the group commit necessary,

1416
01:20:05,210 --> 01:20:09,030
could you say if one system calls finish first,

1417
01:20:09,030 --> 01:20:12,810
just commit it's it's transaction

1418
01:20:12,810 --> 01:20:14,310
and then commit other ones later,

1419
01:20:14,310 --> 01:20:16,080
or is it a necessary property.

1420
01:20:16,140 --> 01:20:18,600
You gotta be very careful,

1421
01:20:18,600 --> 01:20:19,500
because you remember,

1422
01:20:19,500 --> 01:20:22,200
one thing I didn't really state it explicitly as a goal early on

1423
01:20:22,200 --> 01:20:26,250
is that we basically execute the system calls still in the write order, right,

1424
01:20:26,250 --> 01:20:30,510
if a if a if a write,

1425
01:20:30,510 --> 01:20:31,680
if a read observes write

1426
01:20:31,680 --> 01:20:32,670
and then does a write,

1427
01:20:32,850 --> 01:20:33,960
then it has to be the case,

1428
01:20:33,960 --> 01:20:36,390
that that second write happens later than the first write.

1429
01:20:37,120 --> 01:20:39,790
And the reason that this is a log, correct,

1430
01:20:39,790 --> 01:20:43,000
because that basically reflects the order in which the writes haven't happened.

1431
01:20:44,090 --> 01:20:49,700
And so you can really really nearly changed the order of the writes in the log,

1432
01:20:49,700 --> 01:20:54,680
because that maybe actually result into bizarre behavior,

1433
01:20:54,980 --> 01:20:56,930
observable by user programs.

1434
01:20:58,120 --> 01:20:59,050
And so that has to be the case

1435
01:20:59,050 --> 01:21:03,730
that basically you commit you know the operations of these actions in the order they happened,

1436
01:21:05,240 --> 01:21:07,370
we also perform the writes in the order they happened.

1437
01:21:09,250 --> 01:21:14,080
And so in general you know, it's, it's safer,

1438
01:21:14,080 --> 01:21:16,510
you know it's safe to basically commit them all together

1439
01:21:16,600 --> 01:21:17,680
you're always in good [].

1440
01:21:18,510 --> 01:21:19,140
Okay?

1441
01:21:19,880 --> 01:21:20,690
Good question, though.

1442
01:21:23,780 --> 01:21:27,560
Okay I just want to go back to one more thing,

1443
01:21:27,800 --> 01:21:30,380
and then look at the begin_op, yet I talked a little bit,

1444
01:21:30,380 --> 01:21:33,110
because like I don't want to talk about it right now.

1445
01:21:35,460 --> 01:21:39,280
But, there we can see.

1446
01:21:41,000 --> 01:21:42,260
So here's the begin_op,

1447
01:21:43,180 --> 01:21:47,080
first of all, if we're ready committing the log,

1448
01:21:47,080 --> 01:21:48,970
we're just gonna wait until the log has committed,

1449
01:21:49,000 --> 01:21:51,490
because you know we can't write to the log

1450
01:21:51,490 --> 01:21:53,260
while the log actually being installed.

1451
01:21:53,930 --> 01:21:58,280
If we're end,

1452
01:21:58,400 --> 01:22:02,450
concurrent operation that basically makes us go across the logsize,

1453
01:22:02,450 --> 01:22:03,680
we could go to sleep,

1454
01:22:05,080 --> 01:22:09,700
and wait until basically all the preceding concurrent transactions are done,

1455
01:22:10,150 --> 01:22:12,700
and if we're allowed to proceed

1456
01:22:12,730 --> 01:22:15,130
basically are entrance is allowed,

1457
01:22:15,250 --> 01:22:17,530
we increase log.outstanding by 1,

1458
01:22:17,680 --> 01:22:18,970
because they reflect our thing

1459
01:22:18,970 --> 01:22:20,110
and then we basically proceed

1460
01:22:20,110 --> 01:22:21,790
and start doing file system operations.

1461
01:22:22,920 --> 01:22:25,860
And if you look at end_op again, just to.

1462
01:22:26,550 --> 01:22:30,420
So you see the end_op basically decreases log.outstanding by one,

1463
01:22:30,420 --> 01:22:32,010
because one transaction is finished.

1464
01:22:32,590 --> 01:22:37,510
It certainly would be an error in committing states, with panic in that case

1465
01:22:37,810 --> 01:22:41,380
and we actually are the last one from that set of concurrent transactions,

1466
01:22:41,930 --> 01:22:44,510
then, actually, and log.outstanding goes to 0,

1467
01:22:44,510 --> 01:22:45,560
we immediately start committing.

1468
01:22:46,880 --> 01:22:48,170
And then when we're done,

1469
01:22:48,720 --> 01:22:52,410
we're when actually, if we're not the log,

1470
01:22:52,500 --> 01:22:57,020
yeah, yeah, we commit.

1471
01:22:59,460 --> 01:23:02,310
And if there's space you know left,

1472
01:23:02,310 --> 01:23:03,180
we wake up the guy,

1473
01:23:03,180 --> 01:23:04,530
so they can actually start running.

1474
01:23:06,380 --> 01:23:06,920
Okay?

1475
01:23:07,620 --> 01:23:09,990
So even though this dirt simple file system,

1476
01:23:09,990 --> 01:23:13,110
that are just dirt simple logging system that xv6

1477
01:23:13,110 --> 01:23:15,180
actually has a bunch of complications.

1478
01:23:18,160 --> 01:23:19,780
So I'm starting to run out of time,

1479
01:23:19,780 --> 01:23:21,490
so let me wrap up here.

1480
01:23:22,320 --> 01:23:23,640
So in summary,

1481
01:23:26,010 --> 01:23:29,850
you know what we what we talk about is basically logging,

1482
01:23:30,600 --> 01:23:35,180
as a solution for, for crash safety,

1483
01:23:35,890 --> 01:23:41,090
or really for multi-step file system operations.

1484
01:23:43,660 --> 01:23:46,420
And you know if you've seen so far,

1485
01:23:46,510 --> 01:23:48,190
it works great for crash safety,

1486
01:23:48,190 --> 01:23:53,360
but you know performance, and that's going to be the topic for Monday

1487
01:23:53,360 --> 01:23:57,950
and as you read the ext3 file system paper for Monday,

1488
01:23:58,100 --> 01:24:00,110
you know that's the thing you should be thinking about.

1489
01:24:01,900 --> 01:24:03,730
Okay, any more file system questions?

1490
01:24:04,000 --> 01:24:07,180
In fact anybody who has to leave, please feel free to leave,

1491
01:24:07,180 --> 01:24:11,290
but if you want to hang around and ask more questions, you know, please do so.

1492
01:24:14,510 --> 01:24:19,670
Oh, I have a question regarding cache size and the log size,

1493
01:24:19,760 --> 01:24:24,260
so you said that the cache size has to be great as big as the log size,

1494
01:24:24,290 --> 01:24:28,130
but they seem to be the same size for this case,

1495
01:24:28,250 --> 01:24:35,530
so is that means that if the log pins 30 buffers

1496
01:24:35,890 --> 01:24:38,920
and then some other operation tries to do something,

1497
01:24:39,760 --> 01:24:40,600
it just fails,

1498
01:24:40,600 --> 01:24:47,440
because it it runs out of a free slots in the buffer.

1499
01:24:47,470 --> 01:24:51,340
No, maybe let's let's look at the,

1500
01:24:52,830 --> 01:24:54,120
okay, so,

1501
01:24:56,600 --> 01:24:58,130
let me first check one thing.

1502
01:25:02,590 --> 01:25:04,390
Okay, let's go to bio.

1503
01:25:07,070 --> 01:25:08,240
Yeah, okay.

1504
01:25:10,240 --> 01:25:17,780
Let's actually first check NBUF is bigger than size of LOGSIZE, the buffer cache,

1505
01:25:17,780 --> 01:25:19,550
okay, so it's set up to something big.

1506
01:25:20,610 --> 01:25:23,490
So what happens actually if we can't find,

1507
01:25:23,490 --> 01:25:24,930
bget can't find a buffer,

1508
01:25:25,670 --> 01:25:26,780
actually it's panics.

1509
01:25:28,840 --> 01:25:33,630
And, so we we,

1510
01:25:33,630 --> 01:25:35,520
there's no free slot in the buffer cache,

1511
01:25:35,520 --> 01:25:36,600
you know xv6 panic,

1512
01:25:36,600 --> 01:25:37,890
that's not particularly ideal,

1513
01:25:37,920 --> 01:25:39,750
in fact would be terrible

1514
01:25:39,930 --> 01:25:42,210
and so you hope never to be in this situation

1515
01:25:42,210 --> 01:25:45,390
and hopefully picked numbers correctly basically is unlikely to happen.

1516
01:25:46,040 --> 01:25:47,840
But why can't we return an error.

1517
01:25:49,520 --> 01:25:51,740
Because that seems like the obvious thing to do, like,

1518
01:26:05,660 --> 01:26:07,520
if return an error to the caller

1519
01:26:07,520 --> 01:26:11,480
and the caller maybe returns back up to the file system interface

1520
01:26:11,480 --> 01:26:14,150
and just return -1 saying like oh this operation failed.

1521
01:26:15,140 --> 01:26:17,630
Why is that a problem?

1522
01:26:21,060 --> 01:26:22,200
So ready to think about this is

1523
01:26:22,200 --> 01:26:26,460
that you know many file system operations are multi-step operations, right,

1524
01:26:27,030 --> 01:26:28,620
as we've seen now,

1525
01:26:28,710 --> 01:26:31,440
in this lecture and in the previous lecture

1526
01:26:31,740 --> 01:26:37,050
and let's say, we did two writes and then the third write,

1527
01:26:37,080 --> 01:26:38,340
we run into this case,

1528
01:26:38,790 --> 01:26:40,590
where we can't actually do the write,

1529
01:26:40,590 --> 01:26:42,600
because there's no place in the block cache,

1530
01:26:44,380 --> 01:26:46,390
we have done two writes, right.

1531
01:26:47,380 --> 01:26:49,420
Can we just bail out of the file system call.

1532
01:26:53,760 --> 01:26:55,290
Okay, I see right.

1533
01:26:55,500 --> 01:26:56,430
We cannot, correct,

1534
01:26:56,430 --> 01:27:03,710
because we might have updated to in the directory, directory block of some file,

1535
01:27:03,740 --> 01:27:06,320
if we might have to update the directory block in some directory,

1536
01:27:06,350 --> 01:27:09,170
and if we wanted to make this work,

1537
01:27:09,170 --> 01:27:11,900
what we would have to do is undo those changes,

1538
01:27:11,930 --> 01:27:15,310
like any writes that we did before,

1539
01:27:15,310 --> 01:27:17,260
as part of that system call, we have to undo.

1540
01:27:18,770 --> 01:27:20,180
Okay.

1541
01:27:20,180 --> 01:27:23,210
That was painful, that's what we don't do it.

1542
01:27:24,270 --> 01:27:24,900
Does that make sense?

1543
01:27:25,640 --> 01:27:26,990
Okay so it's not a problem,

1544
01:27:26,990 --> 01:27:32,470
if the log the log pins everything

1545
01:27:32,920 --> 01:27:34,540
and there's no more space for cache,

1546
01:27:34,540 --> 01:27:36,820
but it will just panic, okay.

1547
01:27:38,320 --> 01:27:39,970
Yeah, of course this panic never really happen,

1548
01:27:39,970 --> 01:27:43,510
like there's a only corner cases where this hopefully happens.

1549
01:27:45,120 --> 01:27:46,080
I guess you just,

1550
01:27:46,780 --> 01:27:48,400
okay, yeah, that makes sense,

1551
01:27:48,400 --> 01:27:49,990
okay, thank you.

1552
01:27:51,940 --> 01:27:52,960
Any more questions?

1553
01:27:54,120 --> 01:27:55,440
I have a question about,

1554
01:27:55,470 --> 01:28:00,720
I guess following up my earlier one about the group commits,

1555
01:28:01,080 --> 01:28:03,690
I was trying to think of,

1556
01:28:03,990 --> 01:28:06,060
like I think I kind of understand it a high level,

1557
01:28:06,060 --> 01:28:06,930
I was trying to make sure,

1558
01:28:06,930 --> 01:28:11,160
I understand concrete example, why it is important

1559
01:28:11,160 --> 01:28:15,560
and may is this an example that kind of demonstrates its,

1560
01:28:15,560 --> 01:28:17,960
like I guess I was thinking of a situation

1561
01:28:17,960 --> 01:28:22,790
where you have say like this might be convoluted,

1562
01:28:22,790 --> 01:28:27,380
like one process generating a stream of numbers like one to n

1563
01:28:27,680 --> 01:28:30,860
and then two processes consuming,

1564
01:28:31,100 --> 01:28:33,470
that maybe they're listening on the same pipe,

1565
01:28:33,500 --> 01:28:37,910
and say like n like stops an even number,

1566
01:28:38,060 --> 01:28:42,140
one process is consuming and printing out the odd numbers,

1567
01:28:42,140 --> 01:28:45,110
one process is consuming part of the even numbers,

1568
01:28:45,380 --> 01:28:48,200
and if you didn't have group commits,

1569
01:28:48,200 --> 01:28:50,000
so like the correct behavior

1570
01:28:50,000 --> 01:28:54,230
and say they're printing it for like their writing the same file,

1571
01:28:54,600 --> 01:28:57,900
and so the correct behavior would be

1572
01:28:57,930 --> 01:29:00,030
at the end of at the end of all this,

1573
01:29:00,030 --> 01:29:02,310
you would expect the file to have like an even number,

1574
01:29:02,430 --> 01:29:04,080
like the last number,

1575
01:29:04,600 --> 01:29:06,370
but if you didn't have group commits,

1576
01:29:06,370 --> 01:29:13,810
it's possible that the second to last process actually gets committed after the last one

1577
01:29:13,870 --> 01:29:14,920
and it actually see nine,

1578
01:29:14,920 --> 01:29:17,920
is just like a correct example, why this is important.

1579
01:29:17,920 --> 01:29:20,710
I think I have to think a little bit more carefully about it,

1580
01:29:20,800 --> 01:29:24,490
but that is definitely the flavour of the problem,

1581
01:29:24,490 --> 01:29:27,040
you might run into if you reorder system calls.

1582
01:29:28,290 --> 01:29:29,900
Okay, okay.

1583
01:29:30,680 --> 01:29:33,500
I have a great example in the lecture note,

1584
01:29:33,560 --> 01:29:35,990
if the lecture notes,

1585
01:29:35,990 --> 01:29:39,050
you know shell command that really you know behave weirdly

1586
01:29:39,050 --> 01:29:39,980
if you didn't commit to,

1587
01:29:40,700 --> 01:29:42,740
this is not really an issue in some sense from group commit,

1588
01:29:42,740 --> 01:29:45,890
is really an issue that transactions need to be committed in order.

1589
01:29:47,320 --> 01:29:49,520
Mhm, I see,

1590
01:29:49,610 --> 01:29:51,710
and group if it didn't have group commit, then.

1591
01:29:52,100 --> 01:29:54,140
Yeah, people might think

1592
01:29:54,140 --> 01:29:56,960
like well what if you don't have group commit,

1593
01:29:56,960 --> 01:29:58,370
then there's a temptation

1594
01:29:58,370 --> 01:30:00,410
to basically you know commit some later transaction,

1595
01:30:00,410 --> 01:30:01,490
because it's already finished,

1596
01:30:01,490 --> 01:30:02,930
but the first one isn't finished yet,

1597
01:30:03,440 --> 01:30:04,850
and to create space,

1598
01:30:04,850 --> 01:30:05,900
but that's not a solution.

1599
01:30:07,490 --> 01:30:09,590
Okay, that makes sense,

1600
01:30:09,590 --> 01:30:12,140
where in the lecture notes this example of?

1601
01:30:12,140 --> 01:30:12,770
I think shell command,

1602
01:30:13,280 --> 01:30:16,460
where were illustrated by ordering is important.

1603
01:30:17,270 --> 01:30:17,690
Okay.

1604
01:30:17,810 --> 01:30:21,590
It doesn't, it doesn't tie it directly to a group commits,

1605
01:30:21,590 --> 01:30:24,740
but it basically makes the point that ordering system calls is important.

1606
01:30:25,820 --> 01:30:28,850
I see, is this in the the like the text.

