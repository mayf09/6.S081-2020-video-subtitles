1
00:00:00,180 --> 00:00:03,590
每个人都能看到我的屏幕

2
00:00:03,710 --> 00:00:06,020
或我共享的白板吗？

3
00:00:06,890 --> 00:00:07,550
好的，很好。

4
00:00:09,250 --> 00:00:11,650
大家的锁实验做的怎么样了，

5
00:00:11,680 --> 00:00:14,170
让我从这里开始，问一下，

6
00:00:15,740 --> 00:00:17,060
进展如何，

7
00:00:17,300 --> 00:00:20,900
或者困难的是什么，或者还好。

8
00:00:21,680 --> 00:00:24,650
有人想说说自己的感受吗？

9
00:00:30,520 --> 00:00:32,560
我希望很多人已经开始了。

10
00:00:37,130 --> 00:00:37,430
哦，我。

11
00:00:37,460 --> 00:00:39,920
好的，继续。

12
00:00:40,250 --> 00:00:41,390
哦，抱歉，请继续。

13
00:00:42,050 --> 00:00:42,980
好的，很好。

14
00:00:45,130 --> 00:00:46,660
我来，我来继续说。

15
00:00:47,440 --> 00:00:48,610
锁实验，

16
00:00:48,670 --> 00:00:57,420
我想第一部分， kalloc 没那么糟糕，

17
00:00:57,450 --> 00:01:01,830
嗯，然后第二部分就有点难了，

18
00:01:01,890 --> 00:01:04,800
嗯，在我看来要难得多。

19
00:01:06,180 --> 00:01:10,780
你需要想出一个，

20
00:01:11,730 --> 00:01:16,530
我想最困难的部分是想出一个解决方案，

21
00:01:17,460 --> 00:01:19,410
比如这不会引起死锁，

22
00:01:19,410 --> 00:01:26,300
但是如果你认为有可能会出现死锁，

23
00:01:26,300 --> 00:01:30,350
如果你获取一个[]，支持获取锁，所有这些，

24
00:01:30,350 --> 00:01:30,710
但是，

25
00:01:32,210 --> 00:01:34,520
是的，我需要考虑，

26
00:01:34,520 --> 00:01:37,280
比如其他情况或所有东西，

27
00:01:37,280 --> 00:01:39,200
在那之后，情况应该不会那么糟糕。

28
00:01:40,130 --> 00:01:43,910
还有人想分享到目前为止的经验吗？

29
00:01:44,240 --> 00:01:45,140
我想问一下，

30
00:01:45,140 --> 00:01:49,010
我们可以在实验里使用比如无锁，

31
00:01:49,010 --> 00:01:51,350
因为我知道它们的第一部分，

32
00:01:51,350 --> 00:01:54,860
操作指南清晰地表示，

33
00:01:54,860 --> 00:01:57,170
编写一个并行的内存分配器，

34
00:01:57,170 --> 00:02:00,230
但是我们能只用无锁，

35
00:02:00,230 --> 00:02:03,410
并让它保持原样。

36
00:02:03,560 --> 00:02:06,920
你可以自由地做任何能通过的解决方案，

37
00:02:07,700 --> 00:02:11,480
无锁也可以，

38
00:02:11,480 --> 00:02:12,800
我会，

39
00:02:12,830 --> 00:02:14,120
你当然可以自由去做它。

40
00:02:14,510 --> 00:02:16,400
我不会直接从那里开始，

41
00:02:16,430 --> 00:02:17,330
如果我是你，

42
00:02:17,330 --> 00:02:21,110
我会先从一个更细粒度的锁实现开始，

43
00:02:21,110 --> 00:02:23,210
然后转到无锁实现。

44
00:02:24,140 --> 00:02:27,320
所以这里不是从无锁开始的的原因是，

45
00:02:27,320 --> 00:02:29,270
如果你使用一个细粒度的，

46
00:02:29,270 --> 00:02:31,160
你需要做所有并行的东西，

47
00:02:31,160 --> 00:02:33,170
但是如果你直接使用无锁，

48
00:02:33,170 --> 00:02:36,020
你可以将其保留在一个空闲列表中，

49
00:02:36,020 --> 00:02:40,940
你只需要[]，

50
00:02:40,940 --> 00:02:43,070
释放和分配操作，

51
00:02:43,070 --> 00:02:44,240
实际上并没有那么糟糕。

52
00:02:45,120 --> 00:02:47,010
是的，我想也许，在一个，

53
00:02:47,010 --> 00:02:49,020
如果在 kalloc 的情况下只有一个列表，

54
00:02:49,020 --> 00:02:49,890
可能是那种情况，

55
00:02:49,890 --> 00:02:54,030
我想无锁的[]会是一个更复杂的问题。

56
00:02:54,360 --> 00:02:56,580
是的，那是我不敢做的。

57
00:02:56,640 --> 00:02:59,730
但是，这是正确的反应。

58
00:03:01,440 --> 00:03:02,520
还有其他人吗？

59
00:03:04,950 --> 00:03:08,370
我发现调试这些问题有点困难，

60
00:03:08,370 --> 00:03:11,040
因为不能直接地了解发生了什么，

61
00:03:11,040 --> 00:03:12,620
所以我们必须去，

62
00:03:12,620 --> 00:03:18,090
设置 gdb ，中断，中断，中断，是的。

63
00:03:18,980 --> 00:03:20,900
是的，我想惟一的，

64
00:03:20,990 --> 00:03:23,300
我害怕这些锁实验的一个原因是，

65
00:03:23,300 --> 00:03:26,030
像我说过的，这些实验更难调试，

66
00:03:26,510 --> 00:03:30,620
而且 bug 可能不会在每次运行时都出现。

67
00:03:31,200 --> 00:03:35,070
但是，它是非常有教育意义的，

68
00:03:35,070 --> 00:03:39,270
因为学习程序锁在内核中是一件真实的事，

69
00:03:39,270 --> 00:03:43,050
但这绝对是一个核心挑战。

70
00:03:44,100 --> 00:03:47,940
这里可能有一件事，

71
00:03:48,330 --> 00:03:52,680
下一个实验不涉及任何并发，

72
00:03:53,040 --> 00:03:56,610
希望这会更直接。

73
00:03:59,760 --> 00:04:00,150
好的。

74
00:04:00,150 --> 00:04:01,920
我想，你如何，

75
00:04:02,070 --> 00:04:07,410
你如何高效地调试并发程序，

76
00:04:07,410 --> 00:04:10,950
比如所有使用 gdb 的多线程那样。

77
00:04:10,950 --> 00:04:13,140
我使用非常基本的东西，

78
00:04:13,260 --> 00:04:15,570
我使用 print 语句。

79
00:04:15,990 --> 00:04:18,990
我主要依靠的是，

80
00:04:18,990 --> 00:04:22,230
我尝试写下或断言不变量，

81
00:04:22,230 --> 00:04:24,810
在我认为应该是 true 的任何点。

82
00:04:25,490 --> 00:04:27,650
如果断言失败，

83
00:04:27,650 --> 00:04:30,110
然后我知道我的想法有问题，

84
00:04:30,110 --> 00:04:31,400
或者断言是错的。

85
00:04:31,900 --> 00:04:34,060
然后我想一会儿，

86
00:04:34,090 --> 00:04:36,580
试着决定它是什么，

87
00:04:36,610 --> 00:04:38,140
然后从那里出发。

88
00:04:38,620 --> 00:04:42,040
正常的，

89
00:04:42,040 --> 00:04:44,830
对于许多其他设置，

90
00:04:44,830 --> 00:04:47,680
有竞争检测器可以帮助你，

91
00:04:47,680 --> 00:04:53,350
并且标志代码可能看起来，

92
00:04:53,350 --> 00:04:55,270
它可能有问题，

93
00:04:55,360 --> 00:04:57,640
或者受竞争检测器影响，

94
00:04:57,820 --> 00:05:00,940
但那是一整套其他的工具，

95
00:05:01,060 --> 00:05:03,010
我们没有用到的东西。

96
00:05:03,770 --> 00:05:06,770
它也不是那么好，

97
00:05:06,770 --> 00:05:08,210
但这是一大步，

98
00:05:08,210 --> 00:05:10,490
让这些启动并继续运行。

99
00:05:11,270 --> 00:05:14,480
这是人们使用竞争探测器的另一种机制。

100
00:05:16,960 --> 00:05:20,920
基本上标志，任何更新或写入的共享变量，

101
00:05:20,920 --> 00:05:22,270
不需要持有一个锁。

102
00:05:24,460 --> 00:05:25,930
这对解决死锁没有帮助，

103
00:05:25,930 --> 00:05:28,930
比如，在这个实验中的 bcache 锁，

104
00:05:28,930 --> 00:05:30,970
你会遇到死锁，

105
00:05:31,060 --> 00:05:33,280
死锁往往更容易进行调试，

106
00:05:33,280 --> 00:05:35,560
因为你会遇到 panic ，

107
00:05:35,560 --> 00:05:38,110
然后你可以在 gdb 中查看 backtrace ，

108
00:05:38,110 --> 00:05:40,720
看看什么引起了死锁。

109
00:05:44,620 --> 00:05:45,370
这能理解吗？

110
00:05:46,810 --> 00:05:47,830
谢谢。

111
00:05:50,050 --> 00:05:52,210
好的，另一个建议，

112
00:05:52,210 --> 00:05:54,430
有人在反馈中说的，

113
00:05:54,430 --> 00:05:58,330
课程更少了，

114
00:05:58,330 --> 00:05:59,500
比起学起刚开始的时候，

115
00:05:59,500 --> 00:06:00,790
我想我们足够小，

116
00:06:00,790 --> 00:06:03,910
或者人数合适，

117
00:06:03,910 --> 00:06:05,080
打开摄像头。

118
00:06:05,630 --> 00:06:08,210
所以我想鼓励你，

119
00:06:08,210 --> 00:06:10,700
如果你提问，可以打开你的摄像头，

120
00:06:11,210 --> 00:06:14,840
希望能改善我们的体验，

121
00:06:14,840 --> 00:06:16,160
如果你看到的是教室，

122
00:06:16,160 --> 00:06:17,630
而不是虚拟会议。

123
00:06:18,980 --> 00:06:21,380
而且你也不用一直看着我。

124
00:06:22,720 --> 00:06:25,900
好的，那么，

125
00:06:25,960 --> 00:06:27,760
好的，今天的课程，

126
00:06:27,850 --> 00:06:29,440
今天的课程是

127
00:06:29,440 --> 00:06:32,560
关于文件系统的崩溃安全，

128
00:06:32,800 --> 00:06:35,590
这不是一般形式的崩溃安全，

129
00:06:35,590 --> 00:06:38,530
我真正关注的是一个特定的问题，

130
00:06:41,980 --> 00:06:43,450
或者一个特殊的问题，

131
00:06:43,480 --> 00:06:46,750
也就是，崩溃或断电

132
00:06:47,050 --> 00:06:53,900
可能会导致磁盘上的文件系统

133
00:06:57,060 --> 00:07:00,360
处于不一致的状态，或不正确的状态。

134
00:07:04,080 --> 00:07:05,850
我的意思是，不正确的状态是，

135
00:07:05,850 --> 00:07:08,760
比如一个数据块属于两个文件，

136
00:07:08,790 --> 00:07:13,500
或者一个 inode 分配给不同的文件。

137
00:07:14,140 --> 00:07:18,940
所以这个问题可能出现的情况是，

138
00:07:18,940 --> 00:07:21,340
假设你运行 make ，

139
00:07:21,900 --> 00:07:25,530
make 与文件系统交互，

140
00:07:25,740 --> 00:07:26,970
读写文件，

141
00:07:27,180 --> 00:07:31,320
在这个过程中，发生了断电，

142
00:07:33,920 --> 00:07:36,110
可能是你的笔记本电脑没电了，

143
00:07:36,290 --> 00:07:40,370
也许你的房子刚刚断电了，

144
00:07:40,370 --> 00:07:44,000
你重新启动，

145
00:07:45,460 --> 00:07:47,980
当电源在某一时刻恢复，

146
00:07:48,370 --> 00:07:51,340
你重新启动机器，

147
00:07:51,370 --> 00:07:54,280
然后你会再次得到提示符，

148
00:07:54,280 --> 00:07:55,240
你运行 ls ，

149
00:07:55,750 --> 00:07:58,450
并且希望你的文件系统处于良好状态，

150
00:07:59,200 --> 00:08:01,120
在仍然可以使用的状态。

151
00:08:01,880 --> 00:08:05,420
所以，我们关注的特定故障或崩溃是

152
00:08:05,450 --> 00:08:08,300
文件系统操作期间的电源故障，

153
00:08:08,510 --> 00:08:11,600
或者内核死机，

154
00:08:11,630 --> 00:08:14,000
当运行文件系统操作时，

155
00:08:14,210 --> 00:08:15,260
xv6 发生死机，

156
00:08:15,260 --> 00:08:16,250
大多数内核发生死机，

157
00:08:16,250 --> 00:08:19,400
可能是某些内核错误导致死机，

158
00:08:19,580 --> 00:08:21,560
突然之间你的系统失效。

159
00:08:22,350 --> 00:08:23,520
你希望的情况是，

160
00:08:23,520 --> 00:08:25,470
在重启之后，你可以做一些事情，

161
00:08:26,430 --> 00:08:28,080
或者你仍然可以使用文件系统。

162
00:08:28,590 --> 00:08:30,210
这可能会想到一些东西，

163
00:08:30,210 --> 00:08:31,950
这怎么可能不对，

164
00:08:31,950 --> 00:08:35,730
因为文件系统存储在持久化存储介质上，

165
00:08:35,730 --> 00:08:37,470
所以，如果出现电源故障，

166
00:08:37,470 --> 00:08:39,570
介质应该是好的，

167
00:08:39,570 --> 00:08:41,100
那么一旦机器恢复工作，

168
00:08:41,100 --> 00:08:43,050
你写的所有块都应该在那里。

169
00:08:43,730 --> 00:08:45,620
我们将看到许多棘手的情况，

170
00:08:45,620 --> 00:08:50,780
很多文件系统操作是多步操作。

171
00:08:51,240 --> 00:08:54,300
真正需要注意的是

172
00:08:54,300 --> 00:08:57,840
如果我们在错误的地崩溃，

173
00:08:57,840 --> 00:08:59,490
在这些多步操作中，

174
00:08:59,580 --> 00:09:02,850
文件系统可能会不一致，

175
00:09:02,880 --> 00:09:04,530
在很短的时间内，

176
00:09:04,650 --> 00:09:06,720
如果断电正好发生在那里，

177
00:09:06,900 --> 00:09:07,980
可能会有不好的事情发生。

178
00:09:08,740 --> 00:09:13,450
这就是我们今天关注的问题，

179
00:09:13,870 --> 00:09:15,730
这与别的问题不同，

180
00:09:15,730 --> 00:09:18,100
比如，这里出现断电，

181
00:09:18,100 --> 00:09:19,930
并且你的磁盘着火了，

182
00:09:19,930 --> 00:09:22,060
那里什么都没有了，

183
00:09:22,090 --> 00:09:23,170
你需要，

184
00:09:23,380 --> 00:09:26,860
在这种情况下，这是一个完全不同的问题，

185
00:09:26,860 --> 00:09:28,030
有不同的解决方案，

186
00:09:28,030 --> 00:09:32,160
比如，你必须取回你的文件系统备份，

187
00:09:32,160 --> 00:09:34,470
重新安装文件系统，等等。

188
00:09:35,310 --> 00:09:37,020
所以这不是我们关心的问题。

189
00:09:37,020 --> 00:09:38,040
我们真的关心的是

190
00:09:38,040 --> 00:09:44,160
多步操作作过程中发生故障的问题。

191
00:09:46,380 --> 00:09:49,270
好的，这个问题的解决方案是，

192
00:09:49,270 --> 00:09:53,050
我们将要探索的是一种叫做日志的东西，

193
00:09:53,260 --> 00:09:56,950
这是一个非常流行的解决方案，

194
00:09:56,950 --> 00:10:00,970
最初来自数据库世界，

195
00:10:00,970 --> 00:10:04,600
但是现在有很多文件系统使用日志。

196
00:10:05,100 --> 00:10:06,690
我们会，

197
00:10:06,720 --> 00:10:08,580
它很受欢迎的一个原因是

198
00:10:08,580 --> 00:10:10,440
因为这是一个非常规范的解决方案，

199
00:10:10,650 --> 00:10:16,440
我们将看到 xv6 中日志的实现，

200
00:10:16,650 --> 00:10:19,230
当然， xv6 的实现非常简单，

201
00:10:19,230 --> 00:10:22,410
就像日志的最小实现，

202
00:10:22,470 --> 00:10:24,840
只是为了演示关键思想，

203
00:10:25,270 --> 00:10:29,110
即使只是一个基本框架，

204
00:10:29,110 --> 00:10:30,970
日志实现仍然有一些问题，

205
00:10:30,970 --> 00:10:32,740
我们将要讨论，

206
00:10:32,800 --> 00:10:34,750
这就是为什么值得去研究它。

207
00:10:35,410 --> 00:10:39,220
我们会看到 xv6 解决方案的一个缺点是，

208
00:10:39,220 --> 00:10:42,190
因为简单，它的性能也不是很好，

209
00:10:42,900 --> 00:10:45,900
即使日志系统原则上可以获得良好的性能。

210
00:10:46,170 --> 00:10:49,110
所以我们下周要做的是，

211
00:10:49,110 --> 00:10:53,400
看看如何实现一个高性能的日志系统，

212
00:10:53,490 --> 00:10:58,680
通过学习 Linux ext3 文件系统使用的日志系统，

213
00:10:59,320 --> 00:11:00,820
但那是下周的事了。

214
00:11:01,860 --> 00:11:06,210
另一个，今天我想说的一个小点是，

215
00:11:06,210 --> 00:11:08,460
这是我们最后一节 xv6 课，

216
00:11:08,850 --> 00:11:13,770
从现在开始，我们将转向论文，

217
00:11:13,950 --> 00:11:16,080
因为在某些方面，我们所做的是

218
00:11:16,080 --> 00:11:18,480
我们已经涵盖了基本概念，

219
00:11:18,630 --> 00:11:24,030
我们可以通过阅读论文了解更高级的操作系统思想。

220
00:11:24,830 --> 00:11:25,550
好的？

221
00:11:27,130 --> 00:11:28,210
到目前为止，有什么问题吗？

222
00:11:34,590 --> 00:11:35,280
好的，很好。

223
00:11:38,080 --> 00:11:42,520
好的，让我回顾一下这些场景，

224
00:11:42,520 --> 00:11:46,990
我们在这节课中要关注的。

225
00:11:47,470 --> 00:11:51,190
所以，文件系统操作，

226
00:11:52,380 --> 00:11:55,080
比如创建文件，写入文件，

227
00:11:55,110 --> 00:11:58,170
都是多步的磁盘操作。

228
00:12:06,400 --> 00:12:09,940
我们在上周一看到，

229
00:12:09,940 --> 00:12:11,770
我们讨论了 create 是如何实现的，

230
00:12:11,770 --> 00:12:13,690
比如创建文件或写入文件，

231
00:12:13,690 --> 00:12:16,180
我们经常看到事件序列，

232
00:12:16,180 --> 00:12:19,630
或者步骤序列是分配 inode ，

233
00:12:19,630 --> 00:12:21,370
标记在磁盘上分配 inode ，

234
00:12:21,460 --> 00:12:24,700
然后写入包含 inode 的目录，

235
00:12:24,730 --> 00:12:26,980
这就是我所说的多步操作。

236
00:12:27,540 --> 00:12:30,960
如果我们在两个步骤之间崩溃，

237
00:12:31,080 --> 00:12:33,300
这个崩溃可能导致，

238
00:12:34,870 --> 00:12:41,720
可能会破坏文件系统不变性。

239
00:12:45,440 --> 00:12:50,150
破坏不变性，我说的是形式的不变性，

240
00:12:50,390 --> 00:12:53,450
每个块要么是空闲的，

241
00:12:53,480 --> 00:12:56,900
要么分配给一个文件，而不是两个文件。

242
00:12:57,420 --> 00:13:00,390
我们想要确保这件事发生，

243
00:13:00,390 --> 00:13:05,310
即使这些失败发生在这些操作之间。

244
00:13:06,880 --> 00:13:13,280
风险是如果不变性被破坏，

245
00:13:13,790 --> 00:13:16,220
重新启动后可能会发生不好的事情，

246
00:13:17,510 --> 00:13:20,960
你可能马上又会崩溃。

247
00:13:21,930 --> 00:13:23,460
因为有一些数据结构，

248
00:13:23,460 --> 00:13:25,380
文件系统处于一种状态，

249
00:13:25,380 --> 00:13:27,540
文件系统无法处理，

250
00:13:27,540 --> 00:13:29,640
在这个数据结构上这种状态，

251
00:13:29,760 --> 00:13:32,910
文件系统不能再处理它们了，

252
00:13:33,240 --> 00:13:37,730
或者更有可能你没有崩溃，

253
00:13:37,790 --> 00:13:40,460
但是数据可能会丢失，

254
00:13:41,340 --> 00:13:43,920
或者你读取或写入不正确的数据。

255
00:13:52,630 --> 00:13:54,550
我们会看几个例子，

256
00:13:54,550 --> 00:13:56,050
为了更清楚地说明这一点，

257
00:13:56,140 --> 00:13:59,260
但这些都是我们要担心的风险。

258
00:14:02,020 --> 00:14:06,700
我不知道，有没有人在个人生活或日常生活中，

259
00:14:06,730 --> 00:14:08,920
使用电脑时遇到问题，

260
00:14:08,920 --> 00:14:13,360
你在文件系统中出现故障，

261
00:14:13,360 --> 00:14:15,670
你有一个断电故障，

262
00:14:15,670 --> 00:14:17,980
你的机器或你的手机重新启动，

263
00:14:18,190 --> 00:14:23,110
之后就无法使用了。

264
00:14:23,980 --> 00:14:25,450
一个原因可能是不寻常的，

265
00:14:25,450 --> 00:14:28,000
因为文件系统没有正确恢复。

266
00:14:37,370 --> 00:14:39,230
好的，为了说得更清楚，

267
00:14:39,230 --> 00:14:42,500
让我们来看一个关于 xv6 的例子，

268
00:14:42,500 --> 00:14:45,560
我想把这个风险说得更具体一点，

269
00:14:45,740 --> 00:14:48,560
让我们看看 xv6 中的一个例子，

270
00:14:48,770 --> 00:14:51,110
看看会出现什么问题。

271
00:14:52,020 --> 00:14:57,690
记得，周一的 xv6 文件系统，

272
00:14:57,690 --> 00:15:00,120
非常简单的文件系统有一个简单的磁盘布局，

273
00:15:00,510 --> 00:15:04,440
你知道超级块，

274
00:15:04,440 --> 00:15:06,750
这是日志，我们今天要讨论很多，

275
00:15:06,750 --> 00:15:08,070
我们周一没有谈到，

276
00:15:08,280 --> 00:15:11,040
inode 是一些块包含，

277
00:15:11,280 --> 00:15:13,530
每个块可能包含多个 inode ，

278
00:15:13,650 --> 00:15:17,880
位图块来记录哪些块是空闲的，哪些不是，

279
00:15:18,120 --> 00:15:22,530
然后数据块包含文件系统的实际数据。

280
00:15:23,460 --> 00:15:26,130
你还记得，周一的课上，

281
00:15:26,130 --> 00:15:27,750
我分析了这里的输出，

282
00:15:27,750 --> 00:15:30,600
我们了解了文件是如何创建的，

283
00:15:31,020 --> 00:15:34,680
我们看到了单个文件的创建。

284
00:15:35,370 --> 00:15:36,900
好的，稍等一下。

285
00:15:41,460 --> 00:15:46,240
单个文件的创建由多个操作组成，

286
00:15:46,360 --> 00:15:48,520
比如，在这个特定的场景中，

287
00:15:48,520 --> 00:15:51,340
我在幻灯片的这里，

288
00:15:51,670 --> 00:15:57,610
我们看到， inode 被分配，

289
00:15:57,670 --> 00:16:01,300
我们知道这个，因为块 33 正在被写入，

290
00:16:01,570 --> 00:16:05,380
我们看到 inode 正在初始化，

291
00:16:05,380 --> 00:16:07,090
然后再写入块 33 ，

292
00:16:07,330 --> 00:16:10,030
然后我们看到块 46 被写入，

293
00:16:10,030 --> 00:16:11,620
这个写入的原因是，

294
00:16:11,620 --> 00:16:15,970
大概是因为包含 x 的目录块，

295
00:16:16,120 --> 00:16:18,820
并且 x 的 inode 编号被写入磁盘。

296
00:16:19,240 --> 00:16:21,460
然后 root inode 被更新，

297
00:16:21,460 --> 00:16:24,730
反映目录的大小增大，

298
00:16:24,730 --> 00:16:28,630
包含这个特定文件 x ，

299
00:16:28,840 --> 00:16:30,820
然后 inode 更新了。

300
00:16:31,650 --> 00:16:35,080
所以我们想了解的是，

301
00:16:35,080 --> 00:16:38,680
会发生什么，什么会出现问题。

302
00:16:39,040 --> 00:16:44,890
假设我们在这里遇到电源故障，

303
00:16:45,100 --> 00:16:49,060
这是电源故障或内核崩溃。

304
00:16:52,160 --> 00:16:53,660
那么断电后会发生什么，

305
00:16:53,660 --> 00:16:56,300
所有内存中状态都会丢失，

306
00:16:56,600 --> 00:17:00,260
因为内存中的状态数据在 RAM 中，

307
00:17:00,260 --> 00:17:03,230
比如所有进程，所有文件描述符，

308
00:17:03,960 --> 00:17:06,930
所有内存中的缓存都消失了，

309
00:17:07,140 --> 00:17:09,420
因为内存不是持久的，

310
00:17:09,600 --> 00:17:13,110
我们唯一剩下的东西就是磁盘上的，

311
00:17:13,650 --> 00:17:18,090
所以只有数据结构，位和字节，

312
00:17:18,090 --> 00:17:22,200
它们在磁盘上，在断电后仍然存在，

313
00:17:22,410 --> 00:17:27,120
因为那个介质具有耐久性。

314
00:17:28,100 --> 00:17:29,810
所以我们想知道，想理解，

315
00:17:30,380 --> 00:17:34,370
如果我们在这里崩溃，并且没有额外的机制，

316
00:17:34,520 --> 00:17:37,910
或者没有我们将要讨论的日志，

317
00:17:37,970 --> 00:17:39,350
没有额外的机制，

318
00:17:39,860 --> 00:17:41,120
会有多糟糕。

319
00:17:42,750 --> 00:17:45,300
我们在这里有什么风险？

320
00:17:53,750 --> 00:17:54,380
有人知道吗？

321
00:17:57,670 --> 00:18:01,060
基本上，我们写入块 33

322
00:18:01,120 --> 00:18:03,520
来记录已分配的 inode ，

323
00:18:03,580 --> 00:18:04,690
然后我们断电了，

324
00:18:04,690 --> 00:18:05,650
然后我们又恢复了。

325
00:18:07,780 --> 00:18:08,260
继续， Brandon 。

326
00:18:13,300 --> 00:18:18,280
这是不是说我们丢失了这个块，

327
00:18:18,780 --> 00:18:21,810
比如它有数据，但其实不是。

328
00:18:22,290 --> 00:18:25,830
是的，没错，我想我们丢失了整个块，

329
00:18:25,830 --> 00:18:28,500
但是我们使用了 inode x ，

330
00:18:29,070 --> 00:18:34,320
并且标记为已分配的 x 的 inode 已经在磁盘上分配，

331
00:18:34,470 --> 00:18:37,020
但是我们没有放入任何，

332
00:18:37,020 --> 00:18:40,350
我们没有成功放入任何目录里。

333
00:18:41,120 --> 00:18:43,880
所以在磁盘上，分配了一个 inode ，

334
00:18:43,880 --> 00:18:45,860
但它不会出现在任何目录中，

335
00:18:46,160 --> 00:18:48,110
所以我们甚至不能删除它。

336
00:18:48,830 --> 00:18:51,410
所以，这里发生的是

337
00:18:51,410 --> 00:18:52,970
我们丢失了一个 inode 。

338
00:18:57,200 --> 00:18:57,920
这能理解吗？

339
00:19:01,260 --> 00:19:03,360
你可能会想，也许我应该做的是，

340
00:19:03,360 --> 00:19:05,100
也许我应该重新安排写入顺序。

341
00:19:05,830 --> 00:19:08,560
以某种方法，希望这个，

342
00:19:08,560 --> 00:19:09,610
我们不会丢失 inode ，

343
00:19:09,610 --> 00:19:11,590
比如，我们可以试着做的是，

344
00:19:11,590 --> 00:19:12,820
我们要做的是，

345
00:19:12,940 --> 00:19:17,620
我们先写入 46 ，

346
00:19:18,230 --> 00:19:21,320
更新 inode 更新目录，

347
00:19:21,320 --> 00:19:25,920
目录 inode 写入 32 ，

348
00:19:25,950 --> 00:19:29,460
然后在磁盘上标记 inode 已分配，

349
00:19:30,950 --> 00:19:35,900
标记为已分配。

350
00:19:36,650 --> 00:19:39,470
所以，我们以不同的顺序执行相同的一组操作。

351
00:19:40,050 --> 00:19:44,580
希望我们能够避免这种丢失 inode 的问题。

352
00:19:45,680 --> 00:19:46,910
这能行得通吗？

353
00:19:50,980 --> 00:19:52,960
好的，我们应该问自己，

354
00:19:52,960 --> 00:19:55,600
比如，让我们考虑一下这个时间点，

355
00:19:55,810 --> 00:19:57,970
我们假设在这里发生了崩溃，

356
00:19:57,970 --> 00:19:59,020
或者发生电源故障，

357
00:19:59,020 --> 00:20:02,690
正好发生在更新目录之后，

358
00:20:02,690 --> 00:20:05,180
分配磁盘的 inode 之前，

359
00:20:05,210 --> 00:20:07,460
现在电源故障，

360
00:20:07,610 --> 00:20:08,720
机器又恢复了，

361
00:20:08,960 --> 00:20:10,220
我们看看文件系统，

362
00:20:10,250 --> 00:20:12,500
文件系统将处于什么状态。

363
00:20:15,200 --> 00:20:17,780
你会认为它仍然是一个空闲的 inode 。

364
00:20:19,420 --> 00:20:20,410
是的，会发生什么，

365
00:20:20,410 --> 00:20:23,440
比如我们读取目录中的文件 x ，

366
00:20:23,650 --> 00:20:24,490
在根目录中，

367
00:20:24,490 --> 00:20:26,620
因为它现在这里面，这个数据块。

368
00:20:30,080 --> 00:20:31,250
我们将读取的 inode ，

369
00:20:31,250 --> 00:20:34,160
它甚至没有分配，标记为未分配。

370
00:20:34,950 --> 00:20:39,480
更糟糕的是， inode 可能会再次分配，

371
00:20:39,540 --> 00:20:41,250
或者它可能真的被分配了，

372
00:20:41,610 --> 00:20:46,560
因为未分配的标记是在不同的文件，

373
00:20:46,950 --> 00:20:50,130
所以现在我们有两个文件，它们可能，

374
00:20:50,130 --> 00:20:52,500
两个文件共享，

375
00:20:52,500 --> 00:20:53,550
尽管它们完全不同，

376
00:20:53,550 --> 00:20:54,690
但它们共享相同的 inode ，

377
00:20:55,350 --> 00:20:57,990
比如，一个文件属于用户一，

378
00:20:57,990 --> 00:20:58,950
而另一个文件属于用户二，

379
00:20:58,950 --> 00:21:02,130
那么用户而可以读取用户一的文件数据。

380
00:21:03,770 --> 00:21:05,150
所以这也不是好事，对吧。

381
00:21:11,230 --> 00:21:11,980
这能理解吗？

382
00:21:13,980 --> 00:21:15,870
所以改变顺序，

383
00:21:15,870 --> 00:21:17,730
这并不能真正解决我们的问题。

384
00:21:18,500 --> 00:21:21,800
你会遇到我们以前遇到的不同的问题。

385
00:21:23,630 --> 00:21:25,160
好的，我们再看一个例子。

386
00:21:25,840 --> 00:21:32,210
这是写入文件 x 的例子。

387
00:21:35,120 --> 00:21:36,650
所以一旦我们分配了文件，

388
00:21:36,650 --> 00:21:37,850
假设所有文件都成功了，

389
00:21:37,880 --> 00:21:39,950
现在我们执行 write 系统调用，

390
00:21:40,160 --> 00:21:43,280
而 write 系统调用也执行多次写入操作，

391
00:21:43,280 --> 00:21:44,300
我们在周一看到的，

392
00:21:44,690 --> 00:21:48,740
比如，它分配块，在这里是块 45 ，

393
00:21:49,160 --> 00:21:52,130
所以它在空闲映射中设置一位，

394
00:21:52,130 --> 00:21:55,130
块 45 是位图块，

395
00:21:55,430 --> 00:21:57,980
所以它在位图中分配一个块，

396
00:21:57,980 --> 00:21:59,510
在位图块中分配一个位，

397
00:21:59,510 --> 00:22:03,190
表示那个块已经被分配，

398
00:22:03,580 --> 00:22:06,250
那个块，我猜是 595 。

399
00:22:06,780 --> 00:22:10,800
然后我们把字符 h 写如 595 ，

400
00:22:10,800 --> 00:22:11,700
然后是字符 i ，

401
00:22:11,700 --> 00:22:12,870
我们更新 inode 。

402
00:22:13,990 --> 00:22:15,940
好的，现在我们可以问自己同样的问题了，

403
00:22:15,940 --> 00:22:21,670
比如如果我们崩溃会发生什么，

404
00:22:21,760 --> 00:22:24,940
比如，我们在这里崩溃，

405
00:22:25,000 --> 00:22:28,920
在写入位图块之后，

406
00:22:29,160 --> 00:22:32,850
在写入 inode 之前。

407
00:22:33,700 --> 00:22:34,780
所以，在这里崩溃。

408
00:22:39,980 --> 00:22:42,350
所以重新启动后，我们又回来了，

409
00:22:42,380 --> 00:22:44,360
这是一种特殊的状态，

410
00:22:44,360 --> 00:22:47,600
风险是什么？

411
00:22:50,520 --> 00:22:53,430
我们使用了数据块，但我们失去了它。

412
00:22:53,790 --> 00:22:54,930
是的，我们又失去了，

413
00:22:54,930 --> 00:22:56,550
因为块被分配了，

414
00:22:56,550 --> 00:22:57,930
但没有出现在任何文件中，

415
00:22:58,950 --> 00:23:01,890
因为它没有写入任何 inode ，

416
00:23:01,890 --> 00:23:03,180
所以我们丢失了一个数据块。

417
00:23:08,680 --> 00:23:09,220
你可能会想，

418
00:23:09,220 --> 00:23:12,100
好吧，也许是因为我们写入顺序错了，

419
00:23:12,100 --> 00:23:13,690
我们应该做的是，

420
00:23:13,990 --> 00:23:17,260
我们首先应该做的是写入 inode ，

421
00:23:17,650 --> 00:23:22,820
所以先写入 33 ，使用 595 ，

422
00:23:22,910 --> 00:23:26,870
它是间接块或直接块。

423
00:23:27,520 --> 00:23:32,680
然后我们标记 inode 块为已分配，

424
00:23:32,680 --> 00:23:35,350
然后我们写入 45 。

425
00:23:37,000 --> 00:23:37,960
如果我们修改顺序，

426
00:23:37,960 --> 00:23:40,000
因为我们要避免丢失数据块，

427
00:23:40,000 --> 00:23:40,990
我们这样修改顺序。

428
00:23:42,530 --> 00:23:44,630
现在我们考虑这种情况，

429
00:23:44,630 --> 00:23:46,100
如果这里出现故障。

430
00:23:50,370 --> 00:23:51,330
风险是什么？

431
00:23:56,960 --> 00:24:03,800
文件的大小与实际分配的数据块不匹配。

432
00:24:04,710 --> 00:24:05,250
也许是这样，

433
00:24:05,250 --> 00:24:06,750
虽然我认为写入 33

434
00:24:06,750 --> 00:24:10,470
实际上更新了大小和块编号。

435
00:24:11,970 --> 00:24:12,630
噢。

436
00:24:13,450 --> 00:24:15,340
所以这可能是正常的。

437
00:24:16,780 --> 00:24:19,180
如果有两个单独的写入，那将是一个问题，

438
00:24:20,950 --> 00:24:22,270
但这里有个更大的问题。

439
00:24:27,400 --> 00:24:28,510
是不是那个，

440
00:24:29,620 --> 00:24:32,320
所以这个文件里面有，

441
00:24:33,820 --> 00:24:37,180
所以它有数据块，

442
00:24:37,180 --> 00:24:40,810
但是数据块被标记为未分配，

443
00:24:40,900 --> 00:24:45,100
其他文件也可以使用它。

444
00:24:45,220 --> 00:24:47,740
是的，这才是真正的大问题，

445
00:24:47,740 --> 00:24:53,950
inode 块 595 属于那个文件，

446
00:24:54,130 --> 00:24:58,050
但是在磁盘上，它仍标记为未分配，

447
00:24:58,110 --> 00:25:01,080
所以，当稍后创建另一个文件时，

448
00:25:01,110 --> 00:25:04,500
那个块可能会用于另一个文件。

449
00:25:05,140 --> 00:25:09,520
所以现在有一个文件拥有 595 ，

450
00:25:09,520 --> 00:25:10,750
但其他文件也是这样的，

451
00:25:10,750 --> 00:25:13,150
实际上这两个文件都有 595 ，

452
00:25:13,150 --> 00:25:16,990
在它们的 inode 的块编号中，

453
00:25:17,350 --> 00:25:22,630
如果一个用户拥有该文件，

454
00:25:22,630 --> 00:25:23,710
另一个用户拥有另一个文件，

455
00:25:23,710 --> 00:25:26,020
他们可以读写对方的数据，

456
00:25:26,020 --> 00:25:27,910
这显然不是我们想要的。

457
00:25:28,390 --> 00:25:30,310
文件系统应该保证，

458
00:25:30,490 --> 00:25:33,430
每个块只属于一个文件，

459
00:25:33,430 --> 00:25:35,350
不属于其他文件或是空闲的。

460
00:25:37,630 --> 00:25:38,200
好的？

461
00:25:38,860 --> 00:25:40,990
所以这可能会导致安全问题，

462
00:25:41,020 --> 00:25:48,070
块在多个文件之间共享，

463
00:25:49,640 --> 00:25:50,990
这绝对是错的。

464
00:25:55,480 --> 00:25:58,600
关于可能出现的问题，这些能理解吗？

465
00:25:59,300 --> 00:26:02,060
再说一次，这里真正的问题是，

466
00:26:02,060 --> 00:26:03,950
不是看写入的顺序，

467
00:26:04,190 --> 00:26:05,930
但这里真正的根本问题是，

468
00:26:05,930 --> 00:26:07,340
我们在进行多次写入，

469
00:26:07,340 --> 00:26:12,590
它必须以原子操作的形式出现在磁盘上。

470
00:26:18,920 --> 00:26:26,760
好的，所以我们在这节课中要研究的解决方案是日志。

471
00:26:28,380 --> 00:26:29,160
正如我之前所说的，

472
00:26:29,160 --> 00:26:34,080
这是文件系统中常用的解决方案，

473
00:26:34,080 --> 00:26:37,590
来源于数据库资料。

474
00:26:37,740 --> 00:26:39,810
它有几个很好的特性，

475
00:26:39,870 --> 00:26:44,400
其一，它使系统调用或文件系统调用是原子的，

476
00:26:47,520 --> 00:26:48,540
我的意思是，

477
00:26:48,720 --> 00:26:50,520
如果创建文件，

478
00:26:50,520 --> 00:26:52,950
或者调用 create 或 write ，

479
00:26:53,070 --> 00:26:56,040
所有系统调用的作用，

480
00:26:56,040 --> 00:26:58,200
一起出现或完全不出现，

481
00:26:58,470 --> 00:27:00,780
所以，这避免了这个问题，

482
00:27:00,780 --> 00:27:05,010
只有部分写入出现在磁盘上的问题。

483
00:27:06,800 --> 00:27:09,140
它拥有的第二个好的属性，

484
00:27:09,170 --> 00:27:10,850
它允许快速恢复。

485
00:27:12,870 --> 00:27:14,250
所以在重启之后，

486
00:27:14,740 --> 00:27:18,220
我们不需要做很多工作来修复文件系统，

487
00:27:18,310 --> 00:27:19,870
实际上只需要很少的工作。

488
00:27:20,730 --> 00:27:23,520
这与其他一些解决方案形成了鲜明对比，

489
00:27:23,520 --> 00:27:24,840
我没有说的方案，

490
00:27:24,840 --> 00:27:27,510
你去检查文件系统，

491
00:27:27,720 --> 00:27:29,760
可能你读取文件系统的所有块，

492
00:27:29,760 --> 00:27:31,200
或者读取所有 inode 块，

493
00:27:31,200 --> 00:27:32,700
读取所有位图块，

494
00:27:33,000 --> 00:27:34,170
所以检查，

495
00:27:34,170 --> 00:27:36,210
文件系统是否仍处于正确的状态，

496
00:27:36,210 --> 00:27:37,320
或许还可以进行修复。

497
00:27:38,260 --> 00:27:42,130
日志有这个很好的属性，恢复很快。

498
00:27:43,020 --> 00:27:47,130
最后，在原则上，它可以是非常高的性能，

499
00:27:47,610 --> 00:27:50,670
虽然要看的这个，

500
00:27:50,670 --> 00:27:52,890
在 xv6 中看到的不是高性能的，

501
00:27:53,070 --> 00:27:55,140
所以我们下周要看这个，

502
00:27:55,170 --> 00:27:56,940
我们将了解如何构建一个日志系统，

503
00:27:56,940 --> 00:28:01,330
具有原子文件系统调用，更快的恢复和高性能，

504
00:28:01,330 --> 00:28:03,190
今天我们只关注前两个。

505
00:28:05,560 --> 00:28:06,280
好的。

506
00:28:06,780 --> 00:28:10,590
日志的基本思想非常简单，

507
00:28:11,330 --> 00:28:15,980
所以你要做的就是把它分成两部分，

508
00:28:16,590 --> 00:28:19,350
一个是日志，一个是文件系统，

509
00:28:20,600 --> 00:28:22,760
文件系统可能比日志大得多。

510
00:28:23,580 --> 00:28:28,050
当你需要更新文件系统时，

511
00:28:28,050 --> 00:28:32,820
比如更新块 33 或者更新位图块，

512
00:28:33,360 --> 00:28:36,210
我们实际上不会更新文件系统块，

513
00:28:36,210 --> 00:28:38,940
所以我们不会直接更新位图块，

514
00:28:38,940 --> 00:28:42,240
相反，我们要在右边做的唯一一件事是，

515
00:28:42,540 --> 00:28:44,400
这是我们的内存，

516
00:28:44,400 --> 00:28:45,660
我们的内存中有一个块，

517
00:28:45,960 --> 00:28:49,290
比如位图块，它是 45 ，

518
00:28:49,650 --> 00:28:51,480
不是把它写入 45 ，

519
00:28:51,480 --> 00:28:52,830
像平常我们做的那样，

520
00:28:52,950 --> 00:28:55,440
我们实际上要做的是写入日志，

521
00:28:55,740 --> 00:28:56,910
我们把它放在这里，

522
00:28:57,090 --> 00:28:59,730
记住它应该是 45 ，

523
00:29:01,160 --> 00:29:02,060
我们把它放在那里。

524
00:29:02,760 --> 00:29:04,230
我们对所有其他的写入也是这样做的，

525
00:29:04,260 --> 00:29:08,460
比如，我们将 inode 块放在这里，

526
00:29:08,610 --> 00:29:12,150
如果我没记错的话，应该是 33 ，

527
00:29:12,450 --> 00:29:13,710
我们会把它放在这里，

528
00:29:13,770 --> 00:29:16,710
记住这应该是 33 。

529
00:29:18,320 --> 00:29:21,950
所以我们要做的任何写入第一就是日志。

530
00:29:24,660 --> 00:29:27,600
我们不会直接写入块的所在地，

531
00:29:27,600 --> 00:29:29,970
我们只是把它放在日志里。

532
00:29:30,930 --> 00:29:34,140
然后，在文件系统操作完成时，

533
00:29:34,470 --> 00:29:35,520
比如，

534
00:29:35,520 --> 00:29:39,540
我们在前面的幻灯片中看到的四五个写入在日志中，

535
00:29:39,570 --> 00:29:40,710
我们就提交这些操作。

536
00:29:44,830 --> 00:29:47,140
它的意思是在日志里的某个地方，

537
00:29:47,260 --> 00:29:50,440
我们在一个固定的位置标记一个记录，

538
00:29:50,440 --> 00:29:51,130
这表示，

539
00:29:51,130 --> 00:29:55,450
好的，日志里有 5 个日志，

540
00:29:55,660 --> 00:29:59,800
这就是一组写入的日志。

541
00:30:01,720 --> 00:30:05,920
然后，当我们将所有写入放在磁盘上时，

542
00:30:05,950 --> 00:30:09,310
我们要安装它们，被称为安装阶段。

543
00:30:10,470 --> 00:30:11,880
它的意思是，

544
00:30:11,970 --> 00:30:15,630
我们要把这些日志从日志移动到它们的原位置，

545
00:30:15,630 --> 00:30:17,520
我们知道这个到 45 ，

546
00:30:17,520 --> 00:30:18,690
所以我们把它放到 45 ，

547
00:30:18,690 --> 00:30:20,160
这个必须是 33 ，

548
00:30:20,250 --> 00:30:22,260
我们把它放到 33 ，以此类推。

549
00:30:23,420 --> 00:30:24,530
一旦我们完成了，

550
00:30:24,560 --> 00:30:26,360
我们就可以清理日志了，

551
00:30:26,690 --> 00:30:27,920
清理日志，

552
00:30:29,190 --> 00:30:33,240
就是重写，把这个 5 设置为 0 。

553
00:30:34,460 --> 00:30:37,370
这是基本的计划。

554
00:30:38,640 --> 00:30:39,990
为什么这个计划是好的，

555
00:30:40,020 --> 00:30:41,190
好的，让我们想一想。

556
00:30:41,820 --> 00:30:46,760
假设我们在这里之前崩溃，会发生什么。

557
00:30:50,900 --> 00:30:52,760
所以让我暂且不提这个问题，

558
00:30:52,790 --> 00:30:56,060
让我在提问之前讨论一件事。

559
00:30:57,710 --> 00:31:02,050
假设我们崩溃了，并且重新启动，

560
00:31:02,470 --> 00:31:06,580
在重新启动时，文件系统做了什么，

561
00:31:07,280 --> 00:31:08,630
它查看提交记录，

562
00:31:09,900 --> 00:31:11,910
查看提交记录的值，

563
00:31:12,330 --> 00:31:17,260
如果是 0 ，什么都不做，在我们的简单方案中。

564
00:31:18,560 --> 00:31:20,300
如果它大于 0 ，

565
00:31:20,300 --> 00:31:22,370
我们知道日志中有一些块，

566
00:31:22,370 --> 00:31:24,260
需要被安装。

567
00:31:24,720 --> 00:31:26,940
显然我们还没有完成安装，

568
00:31:27,120 --> 00:31:29,100
我们在提交之后崩溃了，

569
00:31:29,100 --> 00:31:30,540
但是在清理日志之前，

570
00:31:30,750 --> 00:31:32,820
所以我们重新安装，

571
00:31:37,510 --> 00:31:39,550
重新安装之后，我们清理日志。

572
00:31:43,990 --> 00:31:44,710
好的?

573
00:31:45,290 --> 00:31:47,540
而且这个方案是好的，

574
00:31:47,930 --> 00:31:51,740
因为它确保了无论崩溃发生在哪里，

575
00:31:51,830 --> 00:31:54,350
我们要么安装了所有的写入块，

576
00:31:54,350 --> 00:31:55,490
要么一个都没有安装，

577
00:31:55,790 --> 00:31:57,560
但是我们从来不会进入，

578
00:31:57,650 --> 00:31:59,630
我们永远不会处于一种情况，

579
00:31:59,630 --> 00:32:02,420
我们安装了一些，而不是所有的写入。

580
00:32:02,950 --> 00:32:04,570
为了弄清为什么这是真的，

581
00:32:04,570 --> 00:32:06,850
让我们来考虑几个可能崩溃的情况。

582
00:32:07,930 --> 00:32:10,900
所以在一到二之间崩溃，会发生什么，

583
00:32:16,660 --> 00:32:18,550
我们会到达什么情况。

584
00:32:23,020 --> 00:32:25,990
在恢复过程中，我们什么都不做，

585
00:32:25,990 --> 00:32:30,720
这是可以的，因为没有任何内容写入文件系统。

586
00:32:31,590 --> 00:32:32,670
是的，就是这样，

587
00:32:32,670 --> 00:32:36,120
所以这就是我们什么都不做的情况，

588
00:32:36,270 --> 00:32:39,030
就像这个系统调用没有执行一样，

589
00:32:39,150 --> 00:32:41,760
因为如果故障发生得稍早一点，

590
00:32:41,760 --> 00:32:43,590
在文件系统调用开始之前。

591
00:32:44,240 --> 00:32:46,250
所以这完全没问题，这是可以接受的。

592
00:32:47,040 --> 00:32:55,730
好的，如果我们在提交之后安装之前崩溃会怎么样？

593
00:32:58,310 --> 00:33:00,320
然后，你只需要重做所有安装，

594
00:33:00,320 --> 00:33:02,270
这样就可以恢复到正确的状态。

595
00:33:02,870 --> 00:33:04,190
是啊，确实如此，

596
00:33:04,190 --> 00:33:05,090
在这一点上，

597
00:33:05,090 --> 00:33:09,110
我们知道所有数据块都在日志中，

598
00:33:09,140 --> 00:33:11,180
它们都会被写下来，因为我们提交了，

599
00:33:11,270 --> 00:33:14,030
所以，它是整个文件系统操作完成的情况。

600
00:33:14,630 --> 00:33:17,660
所以我们可以把它们放到它们应该在的位置。

601
00:33:18,760 --> 00:33:20,380
然后我们都处于好的状态，

602
00:33:20,380 --> 00:33:22,120
所以在这种情况下，所有文件，

603
00:33:22,120 --> 00:33:25,250
在这种情况下，就像，

604
00:33:25,940 --> 00:33:30,200
就像文件系统调用在崩溃之前完成，

605
00:33:30,260 --> 00:33:31,400
没有什么区别。

606
00:33:32,280 --> 00:33:32,880
好的？

607
00:33:33,820 --> 00:33:36,670
那么，如果在安装过程中崩溃会发生什么，

608
00:33:36,700 --> 00:33:39,310
或在清理之前安装过程中，

609
00:33:39,930 --> 00:33:40,770
在这里崩溃。

610
00:33:41,070 --> 00:33:42,030
在这种情况下，

611
00:33:42,270 --> 00:33:42,990
在这种情况下，

612
00:33:42,990 --> 00:33:44,190
我要做第三种情况，

613
00:33:44,550 --> 00:33:48,660
我们安装，在安装过程中，或者在安装之前，

614
00:33:48,690 --> 00:33:50,700
在安装之后清理之前。

615
00:33:51,620 --> 00:33:53,690
然后会发生什么？

616
00:33:55,420 --> 00:33:56,860
在。

617
00:33:58,110 --> 00:34:00,660
哦，抱歉，在下次重启时，

618
00:34:00,690 --> 00:34:03,180
什么都没有改变，

619
00:34:03,180 --> 00:34:04,950
除了恢复进程，

620
00:34:05,130 --> 00:34:07,380
我们只是重做日志。

621
00:34:07,680 --> 00:34:08,970
我们要重做一次日志，

622
00:34:08,970 --> 00:34:13,770
我们要把内容再复制一遍到各个位置，

623
00:34:13,860 --> 00:34:15,390
我们可能要做多次，

624
00:34:15,970 --> 00:34:16,720
这可以吗？

625
00:34:24,410 --> 00:34:27,710
是的，因为这些都是写入，

626
00:34:28,490 --> 00:34:33,650
它们在我们没有改变的特定位置，

627
00:34:33,650 --> 00:34:35,000
就像写入日志里的那样，

628
00:34:35,000 --> 00:34:38,060
所以我们知道每次应该写在哪里。

629
00:34:38,670 --> 00:34:40,710
是的，每次我们写的都一样的，

630
00:34:40,710 --> 00:34:43,860
假设在块 45 中，它的值是 10 ，

631
00:34:44,570 --> 00:34:47,570
我们每次都在 45 位置写入 10

632
00:34:48,050 --> 00:34:49,280
这正是它应该的，

633
00:34:49,370 --> 00:34:53,090
而且多次重复写也不会有什么坏处。

634
00:34:54,160 --> 00:34:55,600
因为我们写的是相同的值，

635
00:34:55,630 --> 00:34:56,920
它就应该在那里。

636
00:34:57,720 --> 00:34:59,100
所以这很好，

637
00:34:59,100 --> 00:35:01,590
我们可以多次重新安装。

638
00:35:03,440 --> 00:35:06,590
当然，在这个时间点，我们不应该执行任何其他文件系统调用，

639
00:35:06,590 --> 00:35:09,080
我们应该在重新启动文件系统之前执行此操作，

640
00:35:09,560 --> 00:35:13,610
但是，在恢复期间重新启动时，

641
00:35:13,610 --> 00:35:14,990
我们可以这样做。

642
00:35:16,080 --> 00:35:19,260
也就是说，安装是幂等的，

643
00:35:19,290 --> 00:35:21,210
你可以多次执行它，

644
00:35:21,450 --> 00:35:23,580
并产生相同的效果。

645
00:35:25,780 --> 00:35:28,210
关于这个的问题？

646
00:35:29,720 --> 00:35:32,060
因为接口只是读和写，

647
00:35:32,060 --> 00:35:36,260
如果我们有追加，这就不安全了，对吧？

648
00:35:36,980 --> 00:35:39,080
是的，这个[]，

649
00:35:39,110 --> 00:35:40,610
你也可以使追加变得安全，

650
00:35:40,610 --> 00:35:42,710
一种更复杂的日志方案，

651
00:35:42,710 --> 00:35:44,120
但是对于这个的日志方案，

652
00:35:44,120 --> 00:35:45,410
我们不必担心这个。

653
00:35:46,620 --> 00:35:49,800
在某种意义上，追加是文件系统级操作，

654
00:35:49,890 --> 00:35:53,310
在这个层面上，我们可以将其作为主题，

655
00:35:53,310 --> 00:35:56,590
使用我们在这里的日志方案。

656
00:35:58,280 --> 00:35:59,360
我明白了，谢谢。

657
00:35:59,940 --> 00:36:00,960
我也有一个问题，

658
00:36:01,560 --> 00:36:05,400
如果在提交时文件系统崩溃，会发生什么情况，

659
00:36:05,400 --> 00:36:07,800
你希望执行多个写入，

660
00:36:08,100 --> 00:36:10,110
然后你只提交其中的一半。

661
00:36:11,480 --> 00:36:13,190
好的，你能说大声点吗，

662
00:36:13,190 --> 00:36:14,540
因为你的声音太小了。

663
00:36:14,630 --> 00:36:15,470
哦，是的，抱歉，

664
00:36:15,740 --> 00:36:20,810
如果你想一次提交多个写入，

665
00:36:20,810 --> 00:36:22,100
比如以原子方式，

666
00:36:22,130 --> 00:36:25,700
但是你的系统在提交的过程中崩溃了，

667
00:36:25,700 --> 00:36:28,820
所以你只能提交一半的写入，

668
00:36:28,970 --> 00:36:30,890
在那种情况下会发生什么？

669
00:36:31,070 --> 00:36:32,990
好的，有一点很重要，

670
00:36:32,990 --> 00:36:34,160
我很高兴你问了这个问题。

671
00:36:34,190 --> 00:36:35,270
所以首先，

672
00:36:35,640 --> 00:36:40,320
你提交，提交操作在这里，

673
00:36:40,320 --> 00:36:41,610
这是第二步，

674
00:36:41,940 --> 00:36:43,830
你提交这些操作，

675
00:36:43,860 --> 00:36:45,750
只在你已经记录了所有写入后，

676
00:36:45,750 --> 00:36:47,670
你打算执行，对吧。

677
00:36:48,660 --> 00:36:50,340
所以，在你提交时，

678
00:36:50,490 --> 00:36:51,900
所有写入都在日志中。

679
00:36:53,320 --> 00:36:56,280
因此，提交操作本身

680
00:36:56,310 --> 00:36:58,380
是一个有趣的问题，在那里发生了什么。

681
00:36:58,620 --> 00:37:02,220
所以，我在幻灯片上标出，

682
00:37:02,220 --> 00:37:04,680
提交操作写入一个块，

683
00:37:05,210 --> 00:37:06,860
磁盘中的一个扇区。

684
00:37:07,360 --> 00:37:11,200
文件系统的标准假设是

685
00:37:11,200 --> 00:37:16,310
单个块写入或单个扇区写入是*原子*操作。

686
00:37:17,060 --> 00:37:18,980
这意味着如果你写入它，

687
00:37:19,010 --> 00:37:22,010
将写入整个扇区，或者任何扇区都不写入。

688
00:37:22,010 --> 00:37:23,900
所以，扇区永远不会被部分写入。

689
00:37:24,940 --> 00:37:28,690
所以在特定扇区总是有效数据，

690
00:37:28,990 --> 00:37:33,220
所以这个提交操作写入日志头，

691
00:37:33,580 --> 00:37:37,120
写入提交记录是真正的提交操作，

692
00:37:37,420 --> 00:37:42,010
如果成功，并且提交头中是 5 ，

693
00:37:42,160 --> 00:37:45,430
我们知道日志中有 5 个块，

694
00:37:45,430 --> 00:37:47,380
我们必须重新安装这 5 个块。

695
00:37:48,600 --> 00:37:51,180
如果提交头没有到达磁盘，

696
00:37:51,540 --> 00:37:53,550
则该值仍为 0 ，

697
00:37:53,940 --> 00:37:56,250
我们就当那个事务从未发生过。

698
00:37:59,010 --> 00:37:59,670
谢谢。

699
00:38:00,300 --> 00:38:03,360
你提到的关键规则，

700
00:38:03,420 --> 00:38:05,610
那必须是真的，

701
00:38:05,700 --> 00:38:07,680
是所谓的预写规则，

702
00:38:08,070 --> 00:38:12,090
意味着日志系统不能安装写入，

703
00:38:12,150 --> 00:38:15,750
直到所有写入到日志中。

704
00:38:20,000 --> 00:38:22,430
关于这个基本方案，有什么问题吗？

705
00:38:28,770 --> 00:38:29,430
好的？

706
00:38:36,530 --> 00:38:37,040
让我们看看。

707
00:38:42,300 --> 00:38:43,770
所以我想，

708
00:38:44,730 --> 00:38:47,910
有很多不同版本的日志方案，

709
00:38:47,910 --> 00:38:50,340
我在这里画了一个非常简单的图，

710
00:38:50,640 --> 00:38:52,470
这完全没问题。

711
00:38:52,470 --> 00:38:56,130
有些方案是推迟清理日志，

712
00:38:56,430 --> 00:38:58,680
安装被推迟，

713
00:38:58,860 --> 00:39:02,790
但我将运行这个非常简单的方案，

714
00:39:03,000 --> 00:39:07,050
下周我们将看到更复杂的日志协议。

715
00:39:07,480 --> 00:39:09,850
但是所有那些记录协议，都遵循这个预写规则，

716
00:39:09,850 --> 00:39:12,190
在你准备提交记录之前，

717
00:39:12,400 --> 00:39:16,150
你必须确保所有写入都在日志中。

718
00:39:18,950 --> 00:39:20,570
但是这里面有很多东西，

719
00:39:20,570 --> 00:39:22,190
尽管如此，仍有很大的灵活性，

720
00:39:22,190 --> 00:39:26,330
在设计特定日志协议方面。

721
00:39:27,460 --> 00:39:29,470
好的，我来看一下，

722
00:39:29,500 --> 00:39:32,740
这是如何在 xv6 中表现出来的，

723
00:39:32,740 --> 00:39:35,290
作为一个案例研究，让事情变得更具体。

724
00:39:40,000 --> 00:39:41,890
好的，在 xv6 中，

725
00:39:42,250 --> 00:39:45,400
你会看到两种类型的[]，

726
00:39:45,550 --> 00:39:47,170
在磁盘上的东西，

727
00:39:48,080 --> 00:39:50,540
和在内存中的东西，

728
00:39:55,220 --> 00:39:57,230
在内存中的内容会丢失，

729
00:39:57,230 --> 00:39:59,000
在此过程中，我们应该考虑的是，

730
00:39:59,000 --> 00:40:02,450
内存中的内容会在崩溃或断电时消失。

731
00:40:04,660 --> 00:40:12,010
xv6 日志的结构一直都非常简单，

732
00:40:12,600 --> 00:40:17,430
我们在开头有一个块， header 块，

733
00:40:18,020 --> 00:40:19,670
这就是我们的提交记录，

734
00:40:19,670 --> 00:40:22,350
它包含数字 n ，

735
00:40:22,350 --> 00:40:24,390
就是日志中的块数，

736
00:40:24,600 --> 00:40:25,920
然后对于每个块，

737
00:40:28,280 --> 00:40:33,230
块编号，那个块的所在位置，等等，

738
00:40:33,230 --> 00:40:34,310
将会是其中的任何一个。

739
00:40:37,960 --> 00:40:40,210
所以，在日志本身中

740
00:40:40,210 --> 00:40:43,180
是属于它的数据，

741
00:40:43,180 --> 00:40:46,480
所以，这是 bn0 的数据，

742
00:40:46,660 --> 00:40:49,690
这是 bn1 的数据，等等，

743
00:40:50,210 --> 00:40:52,490
到 bn-1 ，

744
00:40:54,460 --> 00:40:55,930
这就是日志里的内容。

745
00:40:56,340 --> 00:40:58,620
所以在日志中只有一个东西，

746
00:40:58,650 --> 00:40:59,700
没有更多的了。

747
00:41:00,600 --> 00:41:03,870
然后在内存中，当文件系统运行时，

748
00:41:03,870 --> 00:41:07,620
有一个 header 的拷贝版本在内存中，

749
00:41:09,390 --> 00:41:11,370
它有 n ，

750
00:41:11,400 --> 00:41:18,490
它有块编号数组，等等。

751
00:41:19,000 --> 00:41:22,150
然后这些块编号

752
00:41:22,420 --> 00:41:26,140
指向的是位于数据中的块，

753
00:41:26,170 --> 00:41:28,960
与块编号相对应，

754
00:41:28,960 --> 00:41:31,180
位于内存中数据结构中，

755
00:41:31,240 --> 00:41:33,160
它们在块缓存中，

756
00:41:33,820 --> 00:41:36,160
现在你已经很熟悉了。

757
00:41:36,760 --> 00:41:38,800
所以，也许这是块 10 ，

758
00:41:38,800 --> 00:41:41,740
是日志中的第一个块，

759
00:41:41,740 --> 00:41:44,140
或者让我举一个更具体的例子，

760
00:41:44,140 --> 00:41:46,390
从我们之前的东西来看，

761
00:41:46,390 --> 00:41:48,130
也许这是 45 ，

762
00:41:49,440 --> 00:41:52,110
在缓存中的某个地方，

763
00:41:52,290 --> 00:41:53,010
块缓存，

764
00:41:53,010 --> 00:41:55,470
这里是块 45 ，

765
00:41:55,830 --> 00:41:56,610
这是数据。

766
00:41:56,880 --> 00:41:57,510
好的？

767
00:41:58,200 --> 00:41:59,430
这是一种结构，

768
00:41:59,580 --> 00:42:06,790
内存中的文件系统所具有的，

769
00:42:06,790 --> 00:42:08,620
和在磁盘上的文件系统所具有的，

770
00:42:08,620 --> 00:42:10,240
在磁盘上的文件系统只有日志，

771
00:42:10,390 --> 00:42:12,160
在内存中含有数据结构

772
00:42:12,160 --> 00:42:15,850
用来协调这些将要执行的多次写入操作。

773
00:42:17,080 --> 00:42:17,740
好的？

774
00:42:20,240 --> 00:42:23,360
所以，为了更具体一点，

775
00:42:23,360 --> 00:42:24,620
让我们来看一些代码。

776
00:42:25,740 --> 00:42:30,030
这将帮助我们了解一切是如何运行的。

777
00:42:33,580 --> 00:42:37,640
所以让我调出一些代码。

778
00:42:38,350 --> 00:42:39,970
好的，让我把这个放在它旁边，

779
00:42:40,890 --> 00:42:42,960
我们保留着那张图片，

780
00:42:42,960 --> 00:42:45,420
这样我们想看就可以看看，

781
00:42:45,420 --> 00:42:47,490
或者我可以指向它。

782
00:42:48,490 --> 00:42:49,600
每个人都能看到我的代码吗？

783
00:42:54,410 --> 00:42:57,920
要有人确认他们看到了 emacs 窗口。

784
00:42:58,130 --> 00:42:59,450
是的，我们可以看到它。

785
00:42:59,450 --> 00:42:59,660
好的。

786
00:43:00,380 --> 00:43:01,280
它够大吗？

787
00:43:04,080 --> 00:43:05,190
我觉得挺好的。

788
00:43:05,520 --> 00:43:05,790
好的。

789
00:43:05,790 --> 00:43:06,570
看起来不错。

790
00:43:07,140 --> 00:43:07,800
谢谢。

791
00:43:08,440 --> 00:43:10,870
好的，让我们开始，

792
00:43:11,230 --> 00:43:13,150
我谈到了事务，

793
00:43:13,150 --> 00:43:19,030
我们不应该提交，直到，

794
00:43:19,060 --> 00:43:21,610
我们不应该提交一次写入，直到所有的写入都完成了。

795
00:43:22,420 --> 00:43:24,580
所以，这意味着，

796
00:43:24,580 --> 00:43:27,220
文件系统操作必须指明

797
00:43:27,220 --> 00:43:28,780
事务的开始是什么，

798
00:43:28,780 --> 00:43:30,730
以及事务的结束是什么。

799
00:43:31,340 --> 00:43:33,770
在 xv6 中发生的方式是，

800
00:43:33,770 --> 00:43:35,510
每个文件系统调用，

801
00:43:36,640 --> 00:43:39,070
这里的 open 对应于 create ，

802
00:43:39,070 --> 00:43:40,960
以 begin_op 开始，

803
00:43:41,020 --> 00:43:44,050
begin_op 表示，开始一个事务，

804
00:43:44,260 --> 00:43:45,760
我希望所有的块写入，

805
00:43:45,760 --> 00:43:48,250
我在 begin_op 和 end_op 之间说做的，

806
00:43:48,250 --> 00:43:50,260
end_op 是事务的结束，

807
00:43:50,620 --> 00:43:51,400
这些之间的写入操作都是原子的，

808
00:43:51,490 --> 00:43:54,400
意味着它们全都应用或全不应用。

809
00:43:54,940 --> 00:43:55,420
好的？

810
00:43:55,810 --> 00:44:01,060
所以，每个 xv6 中的文件系统调用都有这样的结构，

811
00:44:01,120 --> 00:44:02,530
有 begin_op ，

812
00:44:02,560 --> 00:44:05,020
然后是实现文件系统调用的代码，

813
00:44:05,020 --> 00:44:05,830
然后是 end_op 。

814
00:44:07,080 --> 00:44:09,690
而 end_op 就是提交操作发生的地方。

815
00:44:10,430 --> 00:44:13,220
所以，在 begin_op 和 end_op 之间，

816
00:44:13,670 --> 00:44:16,730
磁盘上或内存中数据结构应该更新，

817
00:44:16,730 --> 00:44:18,980
无论内存中日志更新，

818
00:44:18,980 --> 00:44:21,020
或者块缓存可能更新，

819
00:44:21,020 --> 00:44:24,020
但是在 end_op 之前什么都不会发生，

820
00:44:24,230 --> 00:44:25,310
然后在 end_op 时，

821
00:44:25,310 --> 00:44:27,890
我们把东西放到日志中，

822
00:44:28,130 --> 00:44:31,670
然后我们完成了把所有的东西放到日志中，

823
00:44:31,760 --> 00:44:34,700
将写入提交记录或日志头。

824
00:44:36,030 --> 00:44:36,630
好的？

825
00:44:37,180 --> 00:44:37,570
那我们开始吧。

826
00:44:39,280 --> 00:44:40,210
所以有趣的是，

827
00:44:40,210 --> 00:44:42,340
当然，每一次写入，

828
00:44:42,340 --> 00:44:45,640
当文件系统调用执行一次磁盘写入时，

829
00:44:45,970 --> 00:44:48,610
一些事情一定会发生，

830
00:44:48,640 --> 00:44:52,870
所以如果我们回到 fs.c ，

831
00:44:52,870 --> 00:44:54,130
查看 ialloc ，

832
00:44:54,580 --> 00:44:56,980
ialloc 调用，

833
00:44:56,980 --> 00:44:59,530
它没有直接调用 bwrite ，

834
00:44:59,830 --> 00:45:03,160
而是调用了 log_write 。

835
00:45:04,250 --> 00:45:06,320
我们将了解 log_write 的作用，

836
00:45:06,590 --> 00:45:10,430
log_write 是日志系统实现的功能，

837
00:45:10,610 --> 00:45:11,600
每个写入，

838
00:45:11,630 --> 00:45:14,720
在 begin_op 和 end_op 之间的文件系统调用，

839
00:45:14,990 --> 00:45:16,640
总是通过 log_write 。

840
00:45:23,350 --> 00:45:24,490
所以这里是 log_write ，

841
00:45:24,490 --> 00:45:29,320
log_write 实际上相当简单。

842
00:45:29,900 --> 00:45:34,700
是的，我们写入块，在块缓存中，

843
00:45:34,730 --> 00:45:38,480
某个地方 45 ，也许是写入到 45 ，

844
00:45:38,720 --> 00:45:42,590
我们已经更新了块缓存中的 45 ，

845
00:45:42,740 --> 00:45:45,890
现在我们记录在内存中的数据结构中，

846
00:45:45,890 --> 00:45:47,990
稍后，在提交的时候，

847
00:45:48,200 --> 00:45:50,720
我们能够将日志写入日志。

848
00:45:51,430 --> 00:45:54,040
所以，你知道代码是，

849
00:45:54,280 --> 00:45:54,730
糟糕，

850
00:45:55,480 --> 00:45:57,040
代码相当简单，

851
00:45:57,340 --> 00:46:00,640
它获取日志头的锁，

852
00:46:00,850 --> 00:46:03,310
并更新日志头，

853
00:46:04,100 --> 00:46:09,890
它说做的是更新 n ，

854
00:46:09,890 --> 00:46:11,600
所做的第一件事是，

855
00:46:11,600 --> 00:46:15,410
如果已经有一份 45 的拷贝，

856
00:46:16,420 --> 00:46:20,410
如果 45 已经被记录为必须写入，

857
00:46:20,740 --> 00:46:21,550
如果是这样情况，

858
00:46:21,550 --> 00:46:24,040
什么都不用做，因为会写入到 45 。

859
00:46:24,750 --> 00:46:26,100
这样我们就完成了，

860
00:46:26,370 --> 00:46:28,020
有时称为日志[吸收]。

861
00:46:30,980 --> 00:46:35,240
如果快 45 不在数组中，

862
00:46:35,240 --> 00:46:38,990
或者不在块列表或块数组中，

863
00:46:38,990 --> 00:46:40,640
需要写入磁盘，

864
00:46:40,730 --> 00:46:44,900
那么这段代码所做的事就是，

865
00:46:44,900 --> 00:46:48,710
增加并将需要写入的块编号放入

866
00:46:48,710 --> 00:46:51,710
下一个条目或这个条目。

867
00:46:53,210 --> 00:46:54,440
然后它做的另一件事，

868
00:46:54,440 --> 00:46:55,730
我稍后会谈到，

869
00:46:55,970 --> 00:47:00,020
它将把块放入缓冲区缓存中，

870
00:47:00,260 --> 00:47:03,620
让我把原因推迟一会，

871
00:47:03,650 --> 00:47:05,180
我稍后会再谈这个问题。

872
00:47:06,560 --> 00:47:08,360
这就是 log_write 所做的全部工作，

873
00:47:08,480 --> 00:47:12,440
所以，每个需要更新块的文件系统调用，

874
00:47:12,470 --> 00:47:14,120
更新块缓存中的块，

875
00:47:14,150 --> 00:47:19,130
它会将它附加到内存中的数据结构中，

876
00:47:19,130 --> 00:47:21,050
除非它已经在那里了，

877
00:47:21,140 --> 00:47:22,820
在这种情况下，只需要吸收它。

878
00:47:24,630 --> 00:47:25,380
这能理解吗？

879
00:47:29,190 --> 00:47:33,900
那么是否意味着 bwrite 根本不应该单独使用？

880
00:47:34,200 --> 00:47:35,160
抱歉，请再说一遍。

881
00:47:35,760 --> 00:47:39,780
bwrite 不应该单独使用，只能用作。

882
00:47:39,930 --> 00:47:41,640
是的，没错，

883
00:47:41,820 --> 00:47:43,950
一种考虑的方式是，

884
00:47:43,950 --> 00:47:47,640
在文件系统中的每个 bwrite 都被 log_write 替换。

885
00:47:53,820 --> 00:47:58,410
好的，现在我们看看 end_op 发生了什么，

886
00:47:58,410 --> 00:48:01,170
因为那是令人兴奋的部分。

887
00:48:02,160 --> 00:48:08,400
有几个案例我暂时不谈，

888
00:48:08,400 --> 00:48:09,240
稍等一会，

889
00:48:09,270 --> 00:48:13,980
因为即使是这个简单的日志系统也有一些微妙的复杂性，

890
00:48:13,980 --> 00:48:17,580
这些代码的大多数开头涉及到这些微妙的复杂性。

891
00:48:18,090 --> 00:48:20,550
但是如果你想得到一个正常的情况，

892
00:48:20,550 --> 00:48:22,350
有一个简单的情况，

893
00:48:22,350 --> 00:48:25,890
没有其他文件系统操作正在进行，

894
00:48:26,160 --> 00:48:28,560
我们正在执行创建文件，

895
00:48:28,620 --> 00:48:31,260
我们已经快到可以提交的地方。

896
00:48:31,940 --> 00:48:36,050
因此代码非常简单并调用 commit ，

897
00:48:36,890 --> 00:48:38,090
所以让我们来看一下 commit 。

898
00:48:41,680 --> 00:48:42,550
这里是 commit ，

899
00:48:43,140 --> 00:48:47,340
[] commit 执行写入日志的步骤，

900
00:48:48,140 --> 00:48:52,500
写入所有这些块编号，

901
00:48:52,500 --> 00:48:55,740
它们位于内存 header 中，

902
00:48:55,920 --> 00:48:58,560
将它们全部写入磁盘上的 header ，

903
00:48:58,770 --> 00:49:00,480
包括数字 n 。

904
00:49:02,360 --> 00:49:03,920
好的，让我们看看，

905
00:49:04,340 --> 00:49:06,890
这是 write_head 所做的，抱歉，

906
00:49:07,440 --> 00:49:10,230
write_log 写入块

907
00:49:10,230 --> 00:49:15,780
从缓冲区缓存到它们各自的日志中。

908
00:49:16,280 --> 00:49:18,830
让我们看看上面的 write_log ，

909
00:49:19,640 --> 00:49:21,440
看它是怎么做的，

910
00:49:21,470 --> 00:49:24,770
它检查这个数组，一次一个，

911
00:49:25,100 --> 00:49:30,810
并且写到日志中的日志位置。

912
00:49:31,500 --> 00:49:36,050
好的，读日志块，然后把它放进去，

913
00:49:36,290 --> 00:49:39,560
复制它，然后把它写入磁盘。

914
00:49:40,880 --> 00:49:43,970
所以这保证日志 45 在这里，

915
00:49:43,970 --> 00:49:45,680
比如说这是 32 ，

916
00:49:45,680 --> 00:49:47,510
它将在那里，等等。

917
00:49:49,050 --> 00:49:49,920
然后，最后，

918
00:49:49,950 --> 00:49:52,020
到目前为止我们还没有提交，

919
00:49:52,020 --> 00:49:53,250
我们所做的唯一一件事是

920
00:49:53,250 --> 00:49:55,080
把数据块放入日志，

921
00:49:55,470 --> 00:49:57,930
如果我们在这个时间点崩溃，

922
00:49:57,930 --> 00:50:01,890
在调用 write_head 之前，在 write_head 成功前，

923
00:50:02,010 --> 00:50:05,520
就像事务根本没有执行一样。

924
00:50:06,810 --> 00:50:08,610
所以让我们来看一下 write_head ，

925
00:50:09,430 --> 00:50:12,760
write_head 是我前面所说的提交点，

926
00:50:13,770 --> 00:50:17,670
提交点很直接，

927
00:50:17,670 --> 00:50:21,590
到达磁盘上块的头，

928
00:50:21,590 --> 00:50:23,420
可能位于缓冲器缓存中，

929
00:50:23,780 --> 00:50:27,770
把拷贝放在最后，

930
00:50:27,830 --> 00:50:30,830
那个块的后面，

931
00:50:30,830 --> 00:50:33,920
把所有块编号放到那个数组，放到那个块，

932
00:50:34,040 --> 00:50:36,410
它写入那个特定的块。

933
00:50:37,210 --> 00:50:38,140
这个，

934
00:50:38,260 --> 00:50:40,870
这个 bwrite 是什么，是那个提交点吗？

935
00:50:45,420 --> 00:50:47,820
如果在 bwrite 之前发生崩溃，会发生什么呢？

936
00:50:57,180 --> 00:50:57,780
有人知道吗？

937
00:50:58,700 --> 00:51:01,820
如果崩溃发生在 bwrite 之前，

938
00:51:01,820 --> 00:51:07,790
是不是我们对内存中 hb 数据结构所做的修改，

939
00:51:08,030 --> 00:51:10,220
它不会，它会好的。

940
00:51:10,610 --> 00:51:11,630
是的，它是好的，

941
00:51:11,630 --> 00:51:15,830
因为我们已经写入了 db0 dbn 到日志中，

942
00:51:15,830 --> 00:51:18,290
但是我们还没有成功写入日志头，

943
00:51:18,980 --> 00:51:21,770
所以，在恢复时，什么都不会发生。

944
00:51:22,950 --> 00:51:25,380
如果正好在 bwrite 后发生崩溃，会发生什么，

945
00:51:25,380 --> 00:51:26,490
比如这里发生了崩溃。

946
00:51:32,220 --> 00:51:33,330
它不再是零，

947
00:51:33,330 --> 00:51:36,330
所以日志头被正确读取并被恢复。

948
00:51:36,570 --> 00:51:38,280
是的，会恢复，对吧。

949
00:51:38,280 --> 00:51:41,070
在某一时刻，像我们期望的一样，在恢复期间，

950
00:51:41,070 --> 00:51:44,580
我们期望恢复会实际读取日志头，

951
00:51:44,580 --> 00:51:46,830
看到其中有一个 5 ，

952
00:51:47,070 --> 00:51:49,680
然后把前 5 个日志复制到原位置。

953
00:51:50,530 --> 00:51:53,320
所以这一行，

954
00:51:53,860 --> 00:51:54,880
这个磁盘写入，

955
00:51:54,880 --> 00:51:56,770
这个扇区写入是真正的提交点。

956
00:51:58,440 --> 00:51:58,860
对吧？

957
00:52:03,380 --> 00:52:07,010
在提交点之前，事务没有发生，

958
00:52:07,010 --> 00:52:10,130
在提交点之后，事务一定完成了，

959
00:52:11,470 --> 00:52:12,760
假设你的恢复是正确的。

960
00:52:18,220 --> 00:52:22,720
好的，让我们回去 commit 。

961
00:52:25,020 --> 00:52:26,910
所以在提交之后，

962
00:52:26,910 --> 00:52:28,770
它安装了事务，

963
00:52:28,830 --> 00:52:30,510
这非常直接，

964
00:52:30,510 --> 00:52:32,670
它使用数据块，

965
00:52:32,670 --> 00:52:34,440
查看数据块所在的头，

966
00:52:34,440 --> 00:52:36,390
然后写入那个特定的位置。

967
00:52:37,660 --> 00:52:40,930
是的，所以我们看看 install_trans ，

968
00:52:41,930 --> 00:52:43,910
看看它是怎么做的。

969
00:52:45,110 --> 00:52:46,940
它有一个日志头的副本，

970
00:52:47,270 --> 00:52:50,750
并且读取日志头，

971
00:52:50,750 --> 00:52:53,720
它到达目的块的原位置，

972
00:52:54,290 --> 00:52:59,030
将数据从日志块复制到目的位置，

973
00:52:59,360 --> 00:53:01,280
然后将缓冲区写入目的位置。

974
00:53:03,170 --> 00:53:03,830
好的？

975
00:53:04,730 --> 00:53:06,440
所以它所做的是

976
00:53:06,440 --> 00:53:08,810
回到上一张幻灯片，

977
00:53:08,810 --> 00:53:12,290
它从日志中复制

978
00:53:12,290 --> 00:53:14,780
到原位置或文件系统中。

979
00:53:17,160 --> 00:53:20,340
当然，我们可能会在这个代码中的某个地方出现故障，

980
00:53:20,340 --> 00:53:21,630
或者在我们做这件事的时候，

981
00:53:21,930 --> 00:53:23,370
但是这是可以的，

982
00:53:23,370 --> 00:53:25,980
因为在恢复中会从头开始。

983
00:53:29,150 --> 00:53:32,540
让我们看看，这就是安装。

984
00:53:33,160 --> 00:53:34,720
所以，一旦安装完成，

985
00:53:35,750 --> 00:53:42,980
它会将内存中的头重新设置为 0 ，

986
00:53:43,100 --> 00:53:44,630
然后写入日志头。

987
00:53:45,500 --> 00:53:51,650
并且引起清理日志，

988
00:53:51,650 --> 00:53:53,270
因为现在是已经是 0 了。

989
00:53:53,900 --> 00:53:54,500
有什么问题？

990
00:53:56,130 --> 00:54:02,470
所以，你刚才说的函数，

991
00:54:02,740 --> 00:54:06,970
比如从什么到什么的东西，

992
00:54:07,150 --> 00:54:12,350
它把你要更新的块，

993
00:54:12,410 --> 00:54:17,030
你要更新的日志到缓冲区缓存中，

994
00:54:17,840 --> 00:54:19,700
是否让它变得更快，

995
00:54:19,700 --> 00:54:21,950
通过不放入缓冲区缓存，

996
00:54:21,950 --> 00:54:25,770
而是直接写入设备。

997
00:54:26,680 --> 00:54:30,490
让我，我们说的是哪个函数？

998
00:54:31,770 --> 00:54:34,110
我忘了它的名字，

999
00:54:34,140 --> 00:54:38,790
就是那个复制所有的东西到日志里。

1000
00:54:39,030 --> 00:54:41,370
好的， install_trans 。

1001
00:54:42,920 --> 00:54:45,680
我想是的。

1002
00:54:47,160 --> 00:54:48,840
哦，也许是这个。

1003
00:54:50,220 --> 00:54:50,520
所以，这个。

1004
00:54:50,520 --> 00:54:53,760
我想可能是 write_head ，但这是一样的。

1005
00:54:54,180 --> 00:54:55,770
好的。

1006
00:54:57,630 --> 00:55:01,490
唯一的原因，

1007
00:55:01,490 --> 00:55:03,320
我们的接口不是特别好，

1008
00:55:03,320 --> 00:55:04,610
你可以直接读，

1009
00:55:04,610 --> 00:55:07,370
你可能在想为什么要读，

1010
00:55:07,980 --> 00:55:09,600
没有理由去读，

1011
00:55:09,600 --> 00:55:11,940
因为我们无论如何都要写，

1012
00:55:12,210 --> 00:55:13,110
是这个问题吗？

1013
00:55:14,980 --> 00:55:18,760
是的，而且你使用了 memmove 。

1014
00:55:19,450 --> 00:55:20,560
使用了 memove ，是的，

1015
00:55:20,620 --> 00:55:23,380
所以这里是绝对可以优化的代码，

1016
00:55:23,470 --> 00:55:26,140
你可以节省一两次磁盘写入。

1017
00:55:26,600 --> 00:55:29,690
为了简单起见，我们没有做任何这样的事情。

1018
00:55:30,270 --> 00:55:31,200
好的，谢谢。

1019
00:55:35,170 --> 00:55:39,650
好的，我想我们已经过了 commit ，

1020
00:55:40,410 --> 00:55:43,980
回去，再检查一下。

1021
00:55:44,540 --> 00:55:46,160
所以我们执行了 write_log ，

1022
00:55:46,160 --> 00:55:47,210
我们执行了 write_head ，

1023
00:55:47,270 --> 00:55:49,610
这里是清理操作，

1024
00:55:50,430 --> 00:55:54,030
我们通过给它设置 0 来清除事务。

1025
00:55:54,150 --> 00:55:54,690
好的？

1026
00:55:55,880 --> 00:55:58,370
所以，唯一需要进一步了解的是，

1027
00:55:58,370 --> 00:56:00,290
恢复是如何进行的，

1028
00:56:00,320 --> 00:56:06,300
所以，恢复发生在 xv6 开始时，

1029
00:56:06,720 --> 00:56:08,370
所以现在我们崩溃了，

1030
00:56:08,370 --> 00:56:11,340
系统出了故障，我们重新启动它，

1031
00:56:11,370 --> 00:56:17,070
xv6 首先做的事情之一，

1032
00:56:17,430 --> 00:56:21,180
xv6 在初始化期间做的一件事，

1033
00:56:21,210 --> 00:56:22,650
它调用 initlog ，

1034
00:56:23,390 --> 00:56:27,050
而 initlog 调用 recover_from_log 函数，

1035
00:56:27,230 --> 00:56:28,790
让我们看看它做了什么。

1036
00:56:30,110 --> 00:56:34,400
recover_from_log 调用 read_head ，

1037
00:56:34,920 --> 00:56:38,220
选取或读取。

1038
00:56:39,300 --> 00:56:42,120
让我看看能不能稍微向下滚动一下。

1039
00:56:45,580 --> 00:56:47,290
从磁盘上读取头，

1040
00:56:48,100 --> 00:56:49,360
查看 n ，

1041
00:56:49,920 --> 00:56:52,560
好的，并不是看 n 是否为 0 ，

1042
00:56:52,560 --> 00:56:54,450
它只是调用 install_trans ，

1043
00:56:54,600 --> 00:56:57,090
这是一样的 install_trans ，

1044
00:56:57,090 --> 00:57:00,480
和我们刚才看到的那个。

1045
00:57:00,720 --> 00:57:02,430
它查看 n ，

1046
00:57:02,430 --> 00:57:04,920
安装从 0 到 n 的所有块

1047
00:57:05,220 --> 00:57:07,080
从日志中到它们的原位置。

1048
00:57:07,850 --> 00:57:08,780
如果它完成了，

1049
00:57:08,870 --> 00:57:09,890
一旦它成功了，

1050
00:57:09,890 --> 00:57:14,020
它也像之前一样清除日志。

1051
00:57:14,820 --> 00:57:17,160
所以，这就是恢复所做的，

1052
00:57:17,160 --> 00:57:20,370
恢复总是调用安装。

1053
00:57:21,010 --> 00:57:23,740
如果我们在安装时发生故障，

1054
00:57:24,130 --> 00:57:25,720
也没有什么问题，

1055
00:57:25,720 --> 00:57:27,430
因为我们崩溃，重启，

1056
00:57:27,730 --> 00:57:31,660
xv6 重启会调用 loginit ，

1057
00:57:31,840 --> 00:57:33,310
它会调用 recover_from_log ，

1058
00:57:33,340 --> 00:57:37,810
并且它会重新安装日志，

1059
00:57:37,870 --> 00:57:40,270
这可能会结束，

1060
00:57:40,330 --> 00:57:43,750
如果我们每次都崩溃或崩溃很多次，

1061
00:57:44,020 --> 00:57:47,320
我们会多次重新安装日志，

1062
00:57:47,380 --> 00:57:49,480
希望在某一时刻它会成功，

1063
00:57:49,600 --> 00:57:52,390
写入所有日志，

1064
00:57:53,320 --> 00:57:54,880
安装整个日志，

1065
00:57:54,910 --> 00:57:57,790
到原位置。

1066
00:57:59,430 --> 00:58:00,030
这能理解吗？

1067
00:58:03,580 --> 00:58:05,410
我有个问题，关于，

1068
00:58:05,740 --> 00:58:08,800
所以，如果一个进程正常运行，

1069
00:58:08,950 --> 00:58:11,560
它写入一些数据到磁盘中，

1070
00:58:11,920 --> 00:58:13,390
然后在之后的某个时刻，

1071
00:58:13,570 --> 00:58:16,870
在提交并安装更改之前，

1072
00:58:17,370 --> 00:58:19,410
有一个失败，

1073
00:58:19,530 --> 00:58:24,380
从更多的过程的角度来看，什么都没有发生，

1074
00:58:24,380 --> 00:58:25,910
但是，

1075
00:58:26,880 --> 00:58:32,430
我想失败发生在我所做的事情结束后，

1076
00:58:33,060 --> 00:58:35,100
这有什么不好吗？

1077
00:58:36,170 --> 00:58:37,790
不是百分之百明白，

1078
00:58:37,790 --> 00:58:41,450
但简短的回答是没什么不好的，

1079
00:58:41,480 --> 00:58:43,490
因为磁盘根本不会更新，

1080
00:58:43,520 --> 00:58:47,240
所以就像文件系统操作没有发生一样。

1081
00:58:48,130 --> 00:58:50,960
好的，我想。

1082
00:58:50,990 --> 00:58:52,520
进程也消失了，

1083
00:58:52,520 --> 00:58:56,420
但是，无论如何我们不希望进程在故障中幸存下来。

1084
00:58:58,150 --> 00:59:00,740
好的，我猜，

1085
00:59:01,200 --> 00:59:04,050
好的，我想这回答了我的问题，谢谢。

1086
00:59:05,720 --> 00:59:07,370
是的，记住这一点很重要

1087
00:59:07,370 --> 00:59:11,180
在失败中幸存下来的唯一一件事，

1088
00:59:11,210 --> 00:59:13,070
或者具有跨失败的持久性是

1089
00:59:13,070 --> 00:59:15,980
磁盘或磁盘上的状态，没有别的。

1090
00:59:19,620 --> 00:59:23,580
好的，为了让这些更具体化，

1091
00:59:23,580 --> 00:59:24,450
让我们。

1092
00:59:25,160 --> 00:59:29,270
我在 bwrite 放了一个打印语句，

1093
00:59:29,270 --> 00:59:31,820
它将内容写入磁盘，

1094
00:59:31,850 --> 00:59:33,380
比如在块缓存中。

1095
00:59:33,920 --> 00:59:37,970
我们要看看磁盘写入的轨迹是什么。

1096
00:59:38,600 --> 00:59:40,130
因为在周一，

1097
00:59:40,130 --> 00:59:45,210
我没有说出全部真相，

1098
00:59:45,240 --> 00:59:48,000
因为我把 print 语句放在 log_write 中，

1099
00:59:48,030 --> 00:59:49,560
而不是在 bwrite 中，

1100
00:59:49,650 --> 00:59:51,390
所以现在我把它放入 bwrite ，

1101
00:59:51,390 --> 00:59:53,670
这样我们就可以看到所有被写入的数据块。

1102
00:59:54,380 --> 00:59:55,970
我们要做一样的事情，

1103
00:59:55,970 --> 00:59:57,290
也就是 echo hi > x ，

1104
00:59:57,650 --> 00:59:59,930
看看真正的磁盘写入。

1105
01:00:01,120 --> 01:00:02,290
看看这是否有意义，

1106
01:00:02,350 --> 01:00:03,820
首先要注意的是，

1107
01:00:03,820 --> 01:00:07,390
这个轨迹比我们上次看到的要长得多，

1108
01:00:07,390 --> 01:00:10,600
我们在几张幻灯片前看过的那张。

1109
01:00:11,480 --> 01:00:12,380
因为你看到，

1110
01:00:12,380 --> 01:00:14,120
刚才演示的，

1111
01:00:15,440 --> 01:00:20,210
这也是一样的 echo hi 。

1112
01:00:20,980 --> 01:00:26,220
我们看到只有 5 个 log_write 操作，

1113
01:00:26,400 --> 01:00:32,120
但是它变成了很多磁盘操作。

1114
01:00:32,780 --> 01:00:33,650
所以让我们来看看它。

1115
01:00:34,680 --> 01:00:38,910
所以我们认为 bwrite 3 4 5 是什么，

1116
01:00:39,000 --> 01:00:40,110
以及 bwrite 2 是什么。

1117
01:00:48,710 --> 01:00:49,370
有人知道吗？

1118
01:00:50,080 --> 01:00:53,620
所以先写入日志，然后写入超级块。

1119
01:00:54,580 --> 01:00:55,990
不是超级块。

1120
01:00:56,110 --> 01:00:57,610
抱歉，是 log_head 。

1121
01:00:57,640 --> 01:01:00,550
是的，看一下，你说对了，

1122
01:01:00,550 --> 01:01:02,290
再看一下这张图片，

1123
01:01:02,680 --> 01:01:03,850
日志结构 2 ，

1124
01:01:03,880 --> 01:01:06,070
这可能是 header 块，

1125
01:01:06,460 --> 01:01:07,720
用来提交记录，

1126
01:01:08,110 --> 01:01:09,910
然后 3 是第一个数据块，

1127
01:01:09,910 --> 01:01:11,080
4 是第二个数据块，

1128
01:01:11,080 --> 01:01:12,310
5 是第三个数据块。

1129
01:01:13,540 --> 01:01:16,870
所以回到这里，这是第一次写入，

1130
01:01:17,630 --> 01:01:19,790
第二次写入，第三次写入，

1131
01:01:20,210 --> 01:01:22,430
它们都会进入日志，

1132
01:01:22,910 --> 01:01:24,290
并被写入磁盘，

1133
01:01:24,890 --> 01:01:26,900
在磁盘的日志部分中，

1134
01:01:27,170 --> 01:01:30,470
然后这是提交记录 header 。

1135
01:01:31,060 --> 01:01:32,680
然后这些是什么？

1136
01:01:41,720 --> 01:01:42,680
这部分是什么？

1137
01:01:43,340 --> 01:01:45,080
这是位图设置吗？

1138
01:01:45,900 --> 01:01:49,710
不，那么我们认为 bwrite 3 保存了什么？

1139
01:01:51,980 --> 01:01:57,440
这里你创建了文件 x 的 inode ，

1140
01:01:57,440 --> 01:02:00,170
更新目录，

1141
01:02:00,170 --> 01:02:02,900
然后也创建了文件本身。

1142
01:02:03,360 --> 01:02:05,760
是的，所以我们没有在这里做，

1143
01:02:05,760 --> 01:02:08,310
因为在这些 bwrite 中没有发生。

1144
01:02:08,900 --> 01:02:09,800
现在我们正在做。

1145
01:02:11,090 --> 01:02:13,700
那么，这是事务的哪个阶段？

1146
01:02:16,200 --> 01:02:17,940
安装更改。

1147
01:02:17,970 --> 01:02:19,440
是的，安装更改，

1148
01:02:19,440 --> 01:02:20,760
我们在这里做的是，

1149
01:02:21,490 --> 01:02:24,260
我们记录写入，

1150
01:02:24,650 --> 01:02:28,370
然后，我们提交文件系统操作，

1151
01:02:28,370 --> 01:02:29,540
现在我们安装它，

1152
01:02:30,430 --> 01:02:32,440
现在我们把块放在它们的原位置上。

1153
01:02:34,300 --> 01:02:37,370
现在， bwrite 2 之后是什么？

1154
01:02:44,500 --> 01:02:45,760
清除日志。

1155
01:02:45,760 --> 01:02:47,140
是的，清除日志。

1156
01:02:47,760 --> 01:02:49,260
所以，这个这个这个，

1157
01:02:50,510 --> 01:02:53,540
系统调用写入 33 46 32 ，

1158
01:02:53,840 --> 01:02:56,150
使用日志系统，

1159
01:02:56,150 --> 01:03:01,830
变成了这组磁盘写入。

1160
01:03:01,830 --> 01:03:04,110
第一部分是安装日志，

1161
01:03:04,110 --> 01:03:06,060
第一部分是记录写入，

1162
01:03:06,060 --> 01:03:07,860
第二部分是安装日志。

1163
01:03:09,860 --> 01:03:11,810
这是提交记录的两个写入。

1164
01:03:15,040 --> 01:03:15,700
所以这能理解吗？

1165
01:03:15,790 --> 01:03:21,160
是否可以从跟踪中找出 begin_op 和 end_op 在哪里？

1166
01:03:21,760 --> 01:03:24,640
嗯，我们不能，

1167
01:03:24,640 --> 01:03:27,400
我们不知道 begin_op 是从哪里开始的，

1168
01:03:27,400 --> 01:03:30,550
但是任何文件系统调用都是以 begin_op 开始的，

1169
01:03:31,420 --> 01:03:33,250
并且必须是这种情况，

1170
01:03:33,900 --> 01:03:37,530
提交记录在 end_op 中，

1171
01:03:37,890 --> 01:03:44,050
我们知道这是一些文件系统操作的 end_op 。

1172
01:03:48,010 --> 01:03:48,910
这能理解吗？

1173
01:03:53,270 --> 01:03:58,520
好的，这是 xv6 日志演示，

1174
01:03:58,880 --> 01:04:01,370
我想讨论一些更复杂的，

1175
01:04:01,700 --> 01:04:09,860
即使是这种很简单日志方案也有其复杂性。

1176
01:04:10,540 --> 01:04:13,480
需要注意的一件事是，

1177
01:04:13,960 --> 01:04:17,440
这是一个很高性能的实现吗？

1178
01:04:18,710 --> 01:04:20,060
你可以看看这个痕迹。

1179
01:04:26,990 --> 01:04:27,620
不是。

1180
01:04:28,190 --> 01:04:29,270
为什么不是，

1181
01:04:30,320 --> 01:04:32,510
我知道这是两个简单的问题，

1182
01:04:32,510 --> 01:04:34,790
但提问很重要。

1183
01:04:36,510 --> 01:04:41,230
比如，一些东西你写了两次。

1184
01:04:41,260 --> 01:04:42,790
是的，一些东西你写了两次，

1185
01:04:42,790 --> 01:04:44,920
写一个大文件 f ，

1186
01:04:44,950 --> 01:04:46,660
我要把那个大文件 f 写两次。

1187
01:04:48,000 --> 01:04:51,180
所以，这当然不是非常高性能的，

1188
01:04:51,180 --> 01:04:53,970
我的意思是，将性能削减了一半，

1189
01:04:55,680 --> 01:04:56,940
为了崩溃安全。

1190
01:04:57,620 --> 01:05:00,500
所以我们会看到，

1191
01:05:00,500 --> 01:05:05,570
在你们阅读周一的 ext3 论文时，

1192
01:05:05,660 --> 01:05:07,220
有一件事你应该记住，

1193
01:05:07,220 --> 01:05:08,450
论文如何，

1194
01:05:08,450 --> 01:05:12,060
如何应对这个倍数 2 。

1195
01:05:15,140 --> 01:05:15,710
好的？

1196
01:05:16,660 --> 01:05:20,500
抱歉，这个情况是不是把 h 和 i 分开写的呢？

1197
01:05:21,460 --> 01:05:23,260
是的，我想是的。

1198
01:05:23,960 --> 01:05:25,010
好的。

1199
01:05:25,010 --> 01:05:27,860
我马上告诉你们为什么，

1200
01:05:27,980 --> 01:05:29,420
那里发生了什么。

1201
01:05:31,760 --> 01:05:33,320
或者，

1202
01:05:34,960 --> 01:05:37,420
让我不要做太多回答，

1203
01:05:37,540 --> 01:05:39,580
但我会回到这个问题上来。

1204
01:05:40,210 --> 01:05:44,140
哦，抱歉，是不是有空行，而不是 h 和 i ，但是。

1205
01:05:44,620 --> 01:05:45,070
换行是一个单独的写入，

1206
01:05:45,100 --> 01:05:49,480
h 和 i 是一个写入，换行是一个单独的写入。

1207
01:05:49,810 --> 01:05:50,920
好的，谢谢。

1208
01:05:51,760 --> 01:05:52,450
不用谢。

1209
01:05:52,960 --> 01:05:56,650
好的，这些是复杂的问题，

1210
01:05:56,740 --> 01:05:59,260
我想稍微谈谈这些复杂的问题。

1211
01:06:05,970 --> 01:06:08,490
这是我们的基本方案，基本数据结构，

1212
01:06:08,910 --> 01:06:11,880
我想要谈的是三个复杂的问题。

1213
01:06:15,360 --> 01:06:17,760
也许我可以把它们叫做挑战，不管你怎么称呼。

1214
01:06:21,490 --> 01:06:23,260
第一个是驱逐。

1215
01:06:29,080 --> 01:06:30,940
问题是这样的，

1216
01:06:31,000 --> 01:06:32,950
让我们回到这张图片，

1217
01:06:33,920 --> 01:06:35,840
bcache 已经满了，

1218
01:06:37,950 --> 01:06:42,000
还有正在进行的事务，

1219
01:06:42,090 --> 01:06:45,000
我们看看，我们刚刚更新了 45 ，

1220
01:06:45,570 --> 01:06:47,430
它现在完成了块 45 ，

1221
01:06:47,430 --> 01:06:48,750
所以它要写下一个块，

1222
01:06:49,530 --> 01:06:50,790
而缓存已经满了。

1223
01:06:51,700 --> 01:06:56,480
然后，这个，

1224
01:06:57,910 --> 01:07:01,150
假设我们没有解决这个问题的办法，

1225
01:07:01,360 --> 01:07:07,060
但是缓存决定驱逐 45 ，

1226
01:07:07,300 --> 01:07:08,980
如果它想驱逐 45 ，

1227
01:07:08,980 --> 01:07:10,120
这意味着

1228
01:07:10,120 --> 01:07:12,040
我们必须把它写入原位置。

1229
01:07:13,720 --> 01:07:19,370
驱逐 45 有什么问题，

1230
01:07:21,060 --> 01:07:23,250
把 45 写入原位置。

1231
01:07:28,600 --> 01:07:29,800
这是好还是坏？

1232
01:07:44,290 --> 01:07:46,270
如果我们那样做，会不会违反规则？

1233
01:07:47,410 --> 01:07:51,760
我想，如果崩溃发生，

1234
01:07:51,760 --> 01:07:56,290
在同一事务中的其他写操作发生之前，

1235
01:07:56,290 --> 01:07:59,170
那么原子性就被打破了。

1236
01:08:02,980 --> 01:08:06,280
这违反了我所说的这个 write-ahead 规则，

1237
01:08:07,610 --> 01:08:09,710
你必须将所有块写入日志，

1238
01:08:09,710 --> 01:08:12,380
在向每个原位置写入块之前。

1239
01:08:25,780 --> 01:08:27,040
所以它必须是这种情况，

1240
01:08:27,040 --> 01:08:31,660
缓存不应该驱逐日志中的任何块。

1241
01:08:32,640 --> 01:08:33,420
这能理解吗？

1242
01:08:34,750 --> 01:08:43,490
所以，解决方案是不要驱逐这些在日志中的块。

1243
01:08:49,330 --> 01:08:52,990
这就是刚才展示的内容，

1244
01:08:52,990 --> 01:08:54,490
我说我不想谈。

1245
01:08:54,880 --> 01:08:58,120
所以再次到 log_write ，

1246
01:08:58,120 --> 01:08:59,830
看看这里，

1247
01:09:00,480 --> 01:09:03,720
这是 log_write ，

1248
01:09:04,140 --> 01:09:06,780
这里我们看到了对 bpin 的调用，

1249
01:09:07,620 --> 01:09:09,000
你认为 bpin 会做什么，

1250
01:09:11,240 --> 01:09:12,710
名字在某种程度上表明了它。

1251
01:09:16,590 --> 01:09:21,970
它把块放入缓存中。

1252
01:09:22,000 --> 01:09:23,260
是的，它怎么做到的，

1253
01:09:23,530 --> 01:09:27,340
因为你已经研究了这个实验。

1254
01:09:28,890 --> 01:09:29,700
你觉得它能做什么。

1255
01:09:30,840 --> 01:09:33,180
我们可以查看 bpin 的实现，

1256
01:09:33,180 --> 01:09:34,710
但我们也可以猜猜它是怎么做的。

1257
01:09:40,000 --> 01:09:41,560
是不是实现它，

1258
01:09:41,590 --> 01:09:44,740
通过增加 refcnt ，它就不会被驱逐出去。

1259
01:09:44,770 --> 01:09:46,300
是的，这就是它说做的事，

1260
01:09:46,330 --> 01:09:47,950
bpin 只是增加 refcnt ，

1261
01:09:47,950 --> 01:09:50,080
而且我们从 bcache 代码中知道，

1262
01:09:50,530 --> 01:09:54,520
驱逐不会驱逐任何引用多于 0 的块。

1263
01:09:56,440 --> 01:10:00,010
所以，在稍后的日志代码中的某个位置，

1264
01:10:00,010 --> 01:10:02,440
一旦一件事已经记录，

1265
01:10:02,440 --> 01:10:05,170
我们可以解锁块。

1266
01:10:06,530 --> 01:10:07,880
好的，这是一个复杂的问题，

1267
01:10:07,880 --> 01:10:09,800
我们有一个固定和解锁的过程。

1268
01:10:11,080 --> 01:10:14,170
我们来看看另一个复杂的问题，

1269
01:10:29,970 --> 01:10:34,260
文件系统操作必须记录在日志中。

1270
01:10:41,460 --> 01:10:43,650
如果我们回到这里的图片，

1271
01:10:43,650 --> 01:10:45,570
或者可能这张图片更好，

1272
01:10:46,120 --> 01:10:48,040
xv6 中的日志有多大？

1273
01:10:53,520 --> 01:10:54,600
30 个块。

1274
01:10:54,630 --> 01:10:56,340
是的， 30 个块， 32 减去 2 ，

1275
01:10:56,700 --> 01:11:01,110
所以最大日志大小是 30 。

1276
01:11:03,840 --> 01:11:05,250
当然，我们可以提高它，

1277
01:11:05,640 --> 01:11:08,160
在真实的文件系统中运行更大的日志，

1278
01:11:08,160 --> 01:11:09,360
但这不重要，

1279
01:11:09,720 --> 01:11:12,090
无论如何，它是这种情况，

1280
01:11:12,090 --> 01:11:15,120
文件系统操作必须适合 30 个数据块。

1281
01:11:16,010 --> 01:11:19,010
因为如果文件系统操作尝试写入超过 30 个块，

1282
01:11:19,280 --> 01:11:22,430
那就意味着我们得在这个地方溢出一些东西，

1283
01:11:22,430 --> 01:11:23,480
我们不允许这么做，

1284
01:11:23,510 --> 01:11:25,610
因为这会再次违反预写规则。

1285
01:11:26,270 --> 01:11:29,600
所以，必须将每个文件系统操作都写入日志中。

1286
01:11:31,440 --> 01:11:32,190
这能理解吗？

1287
01:11:35,040 --> 01:11:39,050
事实上，你知道我们是怎么得到 32 或 30 的？

1288
01:11:50,670 --> 01:11:53,970
它与实际适合多少块，有什么关系吗？

1289
01:11:55,060 --> 01:11:56,050
你需要，

1290
01:11:56,110 --> 01:12:01,540
比如最大块数是多少，

1291
01:12:01,540 --> 01:12:03,190
文件系统操作可以写入的。

1292
01:12:04,280 --> 01:12:05,120
这就是，

1293
01:12:05,120 --> 01:12:09,110
数字 30 必须绝对大于

1294
01:12:09,110 --> 01:12:21,280
文件系统操作可写入的最大数据块数量。

1295
01:12:26,570 --> 01:12:28,610
所以，实际上， Robert 和我这样做的，

1296
01:12:28,610 --> 01:12:30,500
因为我们检查了所有文件系统操作，

1297
01:12:30,500 --> 01:12:31,070
查看它们，

1298
01:12:31,070 --> 01:12:34,460
决定最大数量是多少，

1299
01:12:34,460 --> 01:12:37,040
结果发现数字远远小于 30 ，

1300
01:12:37,340 --> 01:12:41,120
但我们马上会看到一些有趣的困难的问题，

1301
01:12:42,870 --> 01:12:44,850
比如，我们目前看到的操作，

1302
01:12:44,850 --> 01:12:47,280
比如创建文件只有几个块，

1303
01:12:47,310 --> 01:12:49,590
这个文件系统操作有 5 个块，

1304
01:12:49,920 --> 01:12:54,600
事实上，大多数操作都是为数不多的几个块，

1305
01:12:54,690 --> 01:12:58,080
你有想到任何可能会写很多很多块的操作吗？

1306
01:13:13,470 --> 01:13:15,450
你在写入一个大文件。

1307
01:13:15,600 --> 01:13:16,890
是的，写入一个很大的文件。

1308
01:13:16,890 --> 01:13:21,280
所以，如果我们调用 write 系统调用，

1309
01:13:21,280 --> 01:13:23,650
我们传入一个一兆字节数据的缓存，

1310
01:13:24,680 --> 01:13:25,940
比如一千个块。

1311
01:13:27,030 --> 01:13:28,920
看起来我们遇到了很大的麻烦，

1312
01:13:29,100 --> 01:13:31,410
这会违反最大数量。

1313
01:13:32,010 --> 01:13:36,290
所以，让我们看看 write ，

1314
01:13:44,080 --> 01:13:44,680
sys_write ，

1315
01:13:48,070 --> 01:13:49,870
sys_write 调用 filewrite ，

1316
01:13:51,070 --> 01:13:53,440
filewrite ，这里是 filewrite 。

1317
01:13:54,180 --> 01:13:57,810
好的，这里有一个文件描述符 inode ，

1318
01:13:57,840 --> 01:13:58,890
看看我的代码，

1319
01:13:59,160 --> 01:14:00,720
我在显示器上的代码，

1320
01:14:01,110 --> 01:14:04,380
看看这段代码是做什么的。

1321
01:14:09,440 --> 01:14:11,840
是的，你看上面写的评论，

1322
01:14:11,840 --> 01:14:13,070
基本上解释了它，

1323
01:14:13,070 --> 01:14:14,120
这是发生了什么，

1324
01:14:14,120 --> 01:14:17,330
写入被拆分成许多数量较小的写入。

1325
01:14:18,710 --> 01:14:21,560
所以这里到底发生了什么，

1326
01:14:21,560 --> 01:14:24,350
我们确保

1327
01:14:25,000 --> 01:14:28,150
整个写入作为一个整体不是原子的，

1328
01:14:28,180 --> 01:14:31,000
这没关系， Unix 中的 write 系统调用语义，

1329
01:14:31,000 --> 01:14:34,600
并不需要所有的上千个块，

1330
01:14:34,630 --> 01:14:37,060
一兆字节以原子方式写入，

1331
01:14:37,270 --> 01:14:39,970
只是要求我们不要损坏文件系统，

1332
01:14:40,120 --> 01:14:43,570
在写入时，不要损坏文件系统。

1333
01:14:44,090 --> 01:14:46,010
所以我们，

1334
01:14:46,010 --> 01:14:49,880
是的， xv6 将一个大的写入拆分成多个较小的写入，

1335
01:14:49,880 --> 01:14:51,920
并将它们作为单独的事务写入。

1336
01:14:53,160 --> 01:14:55,110
这可以确保我们的示例，

1337
01:14:55,110 --> 01:14:57,360
如果事务分配了一个块编号，

1338
01:14:57,360 --> 01:15:00,030
因为我们需要一个新的块作为中间块，

1339
01:15:00,030 --> 01:15:00,960
我们需要一个新的块，

1340
01:15:00,960 --> 01:15:01,980
因为我们要写入它，

1341
01:15:02,310 --> 01:15:04,320
至少该部分是原子的，

1342
01:15:04,320 --> 01:15:07,230
并且文件系统永远不会处于不正确的状态，

1343
01:15:07,440 --> 01:15:10,020
违反任何文件系统不变性。

1344
01:15:10,490 --> 01:15:12,320
所以，写入拆分为很多

1345
01:15:15,150 --> 01:15:18,120
很多小的写入或很多事务。

1346
01:15:19,310 --> 01:15:20,060
好的？

1347
01:15:20,560 --> 01:15:23,950
实际上，这是一个主要问题，

1348
01:15:25,780 --> 01:15:30,920
写入 fs 拆分为多个事务。

1349
01:15:37,490 --> 01:15:38,510
对于这个，有什么问题吗？

1350
01:15:43,590 --> 01:15:46,470
注意，因为东西放在缓存中，

1351
01:15:46,470 --> 01:15:50,100
这也意味着块缓存可能大于

1352
01:15:51,330 --> 01:15:53,130
大于 logsize 。

1353
01:15:57,910 --> 01:15:58,630
好的。

1354
01:15:59,250 --> 01:16:05,010
现在我想谈的最后一个挑战是

1355
01:16:05,100 --> 01:16:08,660
并发文件系统调用。

1356
01:16:18,110 --> 01:16:19,670
这个问题如下，

1357
01:16:19,700 --> 01:16:21,950
让我先试着解释一下问题是什么，

1358
01:16:21,980 --> 01:16:23,900
然后我们再看看解决方案是什么。

1359
01:16:25,730 --> 01:16:27,740
假设我们有自己的日志，

1360
01:16:29,240 --> 01:16:32,030
我们正在写如，

1361
01:16:32,120 --> 01:16:34,760
可能有两个事务同时执行。

1362
01:16:36,010 --> 01:16:38,110
想象一下，

1363
01:16:38,110 --> 01:16:42,490
它们写入很多块，

1364
01:16:42,520 --> 01:16:46,270
所以 t0 正在执行，

1365
01:16:46,270 --> 01:16:50,870
这里是日志的开头，这里是日志的结尾。

1366
01:16:51,430 --> 01:16:57,070
而且， t1 会执行一些块，等等，

1367
01:16:57,310 --> 01:16:59,320
而当我们到达日志末尾时，

1368
01:16:59,590 --> 01:17:00,490
没有一个是完成的，

1369
01:17:00,490 --> 01:17:03,430
两边都还有更多的写入要做。

1370
01:17:04,600 --> 01:17:10,950
在这个点上，我们可以提交这两个事务中的任何一个吗？

1371
01:17:14,740 --> 01:17:15,910
不，我们不能，

1372
01:17:15,910 --> 01:17:20,140
因为如果我们提交，事务就是部分完成，

1373
01:17:20,700 --> 01:17:24,420
那么我们再次违反了预写规则，

1374
01:17:24,420 --> 01:17:27,510
而且日志的目的是行不通的。

1375
01:17:28,440 --> 01:17:30,840
因此情况必须是，

1376
01:17:30,840 --> 01:17:35,730
多个并发事务可以放入日志中，

1377
01:17:35,790 --> 01:17:55,500
其实所有的并发操作，都必须符合。

1378
01:17:55,710 --> 01:17:59,250
所以，在这种情况下，

1379
01:18:00,370 --> 01:18:01,600
所以这是一种挑战，

1380
01:18:01,600 --> 01:18:03,580
我们有一个文件系统调用开始，

1381
01:18:03,580 --> 01:18:09,400
我们必须安排，

1382
01:18:10,500 --> 01:18:14,250
我们有一个入口做检查，

1383
01:18:14,250 --> 01:18:17,580
在我们运行文件系统操作之前，

1384
01:18:17,610 --> 01:18:20,370
我们必须检查是否还有足够的块，

1385
01:18:20,400 --> 01:18:23,640
如果我们已经有 n 个文件系统操作正在进行，

1386
01:18:23,700 --> 01:18:27,540
我们必须确保，如果我们允许多一个开始，

1387
01:18:27,630 --> 01:18:29,880
块的总数，

1388
01:18:29,880 --> 01:18:31,950
它们可以一起写入，放入日志中。

1389
01:18:33,000 --> 01:18:36,330
xv6 解决这个问题，

1390
01:18:36,450 --> 01:18:39,690
限制并发文件系统调用的数量。

1391
01:18:49,150 --> 01:18:52,540
它的工作方式是，

1392
01:18:54,480 --> 01:18:56,730
我们看到 begin_op ，

1393
01:18:56,730 --> 01:19:00,450
有多少未完成的并发文件正在处理中，

1394
01:19:00,540 --> 01:19:02,490
如果正在进行的太多，

1395
01:19:02,520 --> 01:19:05,790
我们只是存储当前的文件系统操作，然后进入睡眠状态，

1396
01:19:06,000 --> 01:19:09,450
它将等到所有其他文件操作完成并提交。

1397
01:19:10,870 --> 01:19:13,030
所有其他文件操作都会一起提交，

1398
01:19:13,060 --> 01:19:16,240
事实上， t1 t2 ，它们已经完成了，

1399
01:19:16,450 --> 01:19:17,950
可能 t3 也在这里，

1400
01:19:18,160 --> 01:19:19,180
它们完成了，

1401
01:19:19,270 --> 01:19:22,060
然后所有这些事务，

1402
01:19:22,060 --> 01:19:25,300
同一时间一起提交，

1403
01:19:27,870 --> 01:19:29,430
这有时称为组提交。

1404
01:19:30,060 --> 01:19:32,250
因为你提交多个系统调用，

1405
01:19:32,370 --> 01:19:34,290
所有并发运行的系统调用，

1406
01:19:34,650 --> 01:19:38,520
作为一个大事务提交，

1407
01:19:38,520 --> 01:19:41,130
所以所有更新都是可见的。

1408
01:19:41,840 --> 01:19:44,690
所以，所有更新，全部，

1409
01:19:45,350 --> 01:19:47,330
所以，所有这些更新，

1410
01:19:47,330 --> 01:19:49,160
全部发生或一个都没有发生。

1411
01:19:50,390 --> 01:19:50,990
好的？

1412
01:19:52,990 --> 01:19:56,620
我们可以看到，如果你去。

1413
01:19:56,620 --> 01:19:57,460
一个简短的问题。

1414
01:19:58,780 --> 01:19:59,320
嗯。

1415
01:19:59,320 --> 01:20:04,910
这个组提交是否是必须的，

1416
01:20:05,210 --> 01:20:09,030
比如一个系统调用首先完成，

1417
01:20:09,030 --> 01:20:12,810
先提交它的事务，

1418
01:20:12,810 --> 01:20:14,310
然后在提交其他的，

1419
01:20:14,310 --> 01:20:16,080
或者它是必要的。

1420
01:20:16,140 --> 01:20:18,600
你必须非常小心，

1421
01:20:18,600 --> 01:20:19,500
因为你还记得，

1422
01:20:19,500 --> 01:20:22,200
我一开始并没有明确地把它说成是一个目标，

1423
01:20:22,200 --> 01:20:25,230
是因为我们仍按写入顺序执行系统调用，

1424
01:20:26,250 --> 01:20:30,510
如果一个写入，

1425
01:20:30,510 --> 01:20:31,680
如果读取观察到写入，

1426
01:20:31,680 --> 01:20:32,670
然后做一个写入，

1427
01:20:32,850 --> 01:20:33,960
那么必须是，

1428
01:20:33,960 --> 01:20:36,390
第二次写入发生在第一次写入之后。

1429
01:20:37,120 --> 01:20:39,790
这是一个日志，

1430
01:20:39,790 --> 01:20:43,000
因为这反映了还没有发生的写入的顺序。

1431
01:20:44,090 --> 01:20:49,700
所以，你可以修改日志中的写入顺序，

1432
01:20:49,700 --> 01:20:54,680
因为这会产生了怪异的行为。

1433
01:20:54,980 --> 01:20:56,930
从用户程序的角度来看。

1434
01:20:58,120 --> 01:20:59,050
所以必须是这样的，

1435
01:20:59,050 --> 01:21:03,730
你按操作发生的顺序进行提交，

1436
01:21:05,240 --> 01:21:07,370
我们也按照发生的顺序执行写入。

1437
01:21:09,250 --> 01:21:14,080
所以一般来说，它更安全，

1438
01:21:14,080 --> 01:21:16,510
把它们放在一起提交是安全的，

1439
01:21:16,600 --> 01:21:17,680
总是保持良好的[]。

1440
01:21:18,510 --> 01:21:19,140
好的？

1441
01:21:19,880 --> 01:21:20,690
好问题。

1442
01:21:23,780 --> 01:21:27,560
好的，我想回来，看另一件事，

1443
01:21:27,800 --> 01:21:30,380
看看 begin_op ，虽然我说了一点，

1444
01:21:30,380 --> 01:21:33,110
因为，之前我说现在不想谈论这个。

1445
01:21:35,460 --> 01:21:39,280
但是，这里我们可以看到。

1446
01:21:41,000 --> 01:21:42,260
这里是 begin_op ，

1447
01:21:43,180 --> 01:21:47,080
首先，如果准备好提交日志，

1448
01:21:47,080 --> 01:21:48,970
我们就等日志提交，

1449
01:21:49,000 --> 01:21:51,490
因为我们现在不能写入日志，

1450
01:21:51,490 --> 01:21:53,260
在日志安装时。

1451
01:21:53,930 --> 01:21:58,280
如果我们结束了，

1452
01:21:58,400 --> 01:22:02,450
并发操作超过 logsize ，

1453
01:22:02,450 --> 01:22:03,680
我们可以进入睡眠状态，

1454
01:22:05,080 --> 01:22:09,700
等待所有前面的并发事务完成，

1455
01:22:10,150 --> 01:22:12,700
如果我们被允许继续执行，

1456
01:22:12,730 --> 01:22:15,130
就是入口是允许的，

1457
01:22:15,250 --> 01:22:17,530
我们对 log.outstanding 加一，

1458
01:22:17,680 --> 01:22:18,970
因为它们反映了我们的情况，

1459
01:22:18,970 --> 01:22:20,110
然后我们继续，

1460
01:22:20,110 --> 01:22:21,790
并开始执行文件系统操作。

1461
01:22:22,920 --> 01:22:25,860
如果你再看一下 end_op ，为了。

1462
01:22:26,550 --> 01:22:30,420
所以，你可以看到 end_op 将 log.outstanding 减一，

1463
01:22:30,420 --> 01:22:32,010
因为一个事务完成了。

1464
01:22:32,590 --> 01:22:37,510
当然处于提交状态是错误的，引起 panic ，

1465
01:22:37,810 --> 01:22:41,380
如果我们是这组并发事务中的最后一个，

1466
01:22:41,930 --> 01:22:44,510
而且 log.outstanding 是 0 ，

1467
01:22:44,510 --> 01:22:45,560
我们就开始提交。

1468
01:22:46,880 --> 01:22:48,170
然后当我们完成的时候，

1469
01:22:48,720 --> 01:22:52,410
我们，我们不是日志，

1470
01:22:52,500 --> 01:22:57,020
是的，我们提交。

1471
01:22:59,460 --> 01:23:02,310
如果还有剩余空间，

1472
01:23:02,310 --> 01:23:03,180
我们会叫醒那个日志，

1473
01:23:03,180 --> 01:23:04,530
这样就可以开始执行了。

1474
01:23:06,380 --> 01:23:06,920
好的？

1475
01:23:07,620 --> 01:23:09,990
所以即使这个极其简单的文件系统，

1476
01:23:09,990 --> 01:23:13,110
xv6 的非常简单的日志系统，

1477
01:23:13,110 --> 01:23:15,180
也有一堆复杂的东西。

1478
01:23:18,160 --> 01:23:19,780
我的时间快到了，

1479
01:23:19,780 --> 01:23:21,490
我就在这里结束吧。

1480
01:23:22,320 --> 01:23:23,640
所以总而言之，

1481
01:23:26,010 --> 01:23:29,850
我们谈论的是日志，

1482
01:23:30,600 --> 01:23:35,180
作为崩溃安全的解决方案，

1483
01:23:35,890 --> 01:23:41,090
或者是多步文件系统操作的解决方案。

1484
01:23:43,660 --> 01:23:46,420
到目前为止，

1485
01:23:46,510 --> 01:23:48,190
它对崩溃安全非常有效，

1486
01:23:48,190 --> 01:23:53,360
但是性能，这将是周一的主题，

1487
01:23:53,360 --> 01:23:57,950
当你阅读周一的 ext3 文件系统论文时，

1488
01:23:58,100 --> 01:24:00,110
这是你应该考虑的事情。

1489
01:24:01,900 --> 01:24:03,730
好的，还有关于文件系统的问题吗？

1490
01:24:04,000 --> 01:24:07,180
任何要离开的人，请随意离开，

1491
01:24:07,180 --> 01:24:11,290
但如果你还想再多问几个问题，那就继续。

1492
01:24:14,510 --> 01:24:19,670
哦，我有一个关于缓存大小和日志大小的问题，

1493
01:24:19,760 --> 01:24:24,260
所以你说缓存大小必须大于日志大小，

1494
01:24:24,290 --> 01:24:28,130
但在这个示例中，它们的大小似乎是一样的，

1495
01:24:28,250 --> 01:24:35,530
所以这是否意味着如果日志放入 30 个缓存，

1496
01:24:35,890 --> 01:24:38,920
然后一些其他操作试图做一些事情，

1497
01:24:39,760 --> 01:24:40,600
它只是失败了，

1498
01:24:40,600 --> 01:24:47,440
因为缓存中的插槽没有空闲的。

1499
01:24:47,470 --> 01:24:51,340
不，也许我们来看看，

1500
01:24:52,830 --> 01:24:54,120
好的，那么，

1501
01:24:56,600 --> 01:24:58,130
让我先检查一件事。

1502
01:25:02,590 --> 01:25:04,390
好的，我们看看 bio 。

1503
01:25:07,070 --> 01:25:08,240
好的。

1504
01:25:10,240 --> 01:25:17,780
让我们首先检查 NBUF 是否大于 LOGSIZE ，

1505
01:25:17,780 --> 01:25:19,550
好的，它设置为某个大小。

1506
01:25:20,610 --> 01:25:23,490
所以，如果我们找不到，会发生什么，

1507
01:25:23,490 --> 01:25:24,930
bget 找不到缓存，

1508
01:25:25,670 --> 01:25:26,780
实际会引起 panic 。

1509
01:25:28,840 --> 01:25:33,630
所以，我们，

1510
01:25:33,630 --> 01:25:35,520
缓存里没有空闲的位置，

1511
01:25:35,520 --> 01:25:36,600
xv6 引起 panic ，

1512
01:25:36,600 --> 01:25:37,890
这不是很理想，

1513
01:25:37,920 --> 01:25:39,750
事实上会很糟糕，

1514
01:25:39,930 --> 01:25:42,210
所以你希望永远不会出现这种情况，

1515
01:25:42,210 --> 01:25:45,390
希望挑选正确的数字，不太可能发生。

1516
01:25:46,040 --> 01:25:47,840
但是，为什么我们不能返回一个错误。

1517
01:25:49,520 --> 01:25:51,740
因为这似乎是最明显的做法，

1518
01:26:05,660 --> 01:26:07,520
如给给调用方返回一个错误，

1519
01:26:07,520 --> 01:26:11,480
而调用方可能返回给文件系统接口，

1520
01:26:11,480 --> 01:26:14,150
只需要返回 -1 ，表示这个操作失败了。

1521
01:26:15,140 --> 01:26:17,630
为什么这是个问题？

1522
01:26:21,060 --> 01:26:22,200
所以考虑这个是，

1523
01:26:22,200 --> 01:26:26,460
许多文件系统操作都是多步操作，

1524
01:26:27,030 --> 01:26:28,620
正如我们看到的，

1525
01:26:28,710 --> 01:26:31,440
在这节课和上一节课中，

1526
01:26:31,740 --> 01:26:37,050
比如，我们写了两次，然后写第三次，

1527
01:26:37,080 --> 01:26:38,340
我们遇到了这样的情况，

1528
01:26:38,790 --> 01:26:40,590
我们不能进行写入，

1529
01:26:40,590 --> 01:26:42,600
因为块缓存里已经没有地方了，

1530
01:26:44,380 --> 01:26:46,390
我们已经写了两次了。

1531
01:26:47,380 --> 01:26:49,420
我们能不能跳出文件系统调用。

1532
01:26:53,760 --> 01:26:55,290
好的，我明白了。

1533
01:26:55,500 --> 01:26:56,430
我们不能，

1534
01:26:56,430 --> 01:27:03,710
因为我们可能已经更新某个文件的目录块，

1535
01:27:03,740 --> 01:27:06,320
如果我们需要更新某个目录中的目录块，

1536
01:27:06,350 --> 01:27:09,170
如果我们想让它工作，

1537
01:27:09,170 --> 01:27:11,900
我们需要做的就是撤销这些更改，

1538
01:27:11,930 --> 01:27:15,310
就像我们以前所做的任何写入一样，

1539
01:27:15,310 --> 01:27:17,260
作为系统调用的一部分，我们必须撤消。

1540
01:27:18,770 --> 01:27:20,180
好的。

1541
01:27:20,180 --> 01:27:23,210
那很痛苦，这就是我们不做的原因。

1542
01:27:24,270 --> 01:27:24,900
这能理解吗？

1543
01:27:25,640 --> 01:27:26,990
好的，所以这不是问题，

1544
01:27:26,990 --> 01:27:32,470
如果日志记录所有东西，

1545
01:27:32,920 --> 01:27:34,540
缓存中没有更多空间，

1546
01:27:34,540 --> 01:27:36,820
但它只会引起 panic ，好的。

1547
01:27:38,320 --> 01:27:39,970
是的，当然这种 panci 从来没有真正发生过，

1548
01:27:39,970 --> 01:27:43,510
只有极少数的情况可能会发生。

1549
01:27:45,120 --> 01:27:46,080
我想你只是，

1550
01:27:46,780 --> 01:27:48,400
好的，有道理，

1551
01:27:48,400 --> 01:27:49,990
好的，谢谢。

1552
01:27:51,940 --> 01:27:52,960
还有什么问题吗？

1553
01:27:54,120 --> 01:27:55,440
我有个问题是关于，

1554
01:27:55,470 --> 01:28:00,720
我想是关于我之前的组提交，

1555
01:28:01,080 --> 01:28:03,690
我试着去想，

1556
01:28:03,990 --> 01:28:06,060
我想我从高层级上理解了，

1557
01:28:06,060 --> 01:28:06,930
我想确认一下，

1558
01:28:06,930 --> 01:28:11,160
我理解具体的例子，为什么它很重要，

1559
01:28:11,160 --> 01:28:15,560
可能这是一个例子，展示了它，

1560
01:28:15,560 --> 01:28:17,960
我猜我在想这样一种情况，

1561
01:28:17,960 --> 01:28:22,790
你有，这可能是错综复杂的，

1562
01:28:22,790 --> 01:28:27,380
比如一个进程生成 1 到 n 的数字流，

1563
01:28:27,680 --> 01:28:30,860
然后两个进程消耗，

1564
01:28:31,100 --> 01:28:33,470
可能它们在接收同一个管道，

1565
01:28:33,500 --> 01:28:37,910
比如 n 在一个偶数停止，

1566
01:28:38,060 --> 01:28:42,140
一个进程消耗并打印出奇数，

1567
01:28:42,140 --> 01:28:45,110
一个进程是消耗偶数部分，

1568
01:28:45,380 --> 01:28:48,200
如果没有组提交，

1569
01:28:48,200 --> 01:28:50,000
那么正确的行为，

1570
01:28:50,000 --> 01:28:54,230
比如它们打印写入同一个文件，

1571
01:28:54,600 --> 01:28:57,900
所以正确的行为应该是

1572
01:28:57,930 --> 01:29:00,030
在这一切结束的时候，

1573
01:29:00,030 --> 01:29:02,310
你可能希望文件含有偶数，

1574
01:29:02,430 --> 01:29:04,080
即最后一个数字，

1575
01:29:04,600 --> 01:29:06,370
但是如果你没有组提交，

1576
01:29:06,370 --> 01:29:13,810
可能倒数第二个进程在最后一个进程之后提交，

1577
01:29:13,870 --> 01:29:14,920
并且它看到的是 9 ，

1578
01:29:14,920 --> 01:29:17,920
这是不是一个正确的例子，为什么这很重要。

1579
01:29:17,920 --> 01:29:20,710
我想我得仔细考虑一下，

1580
01:29:20,800 --> 01:29:24,490
但这绝对是问题的症结所在，

1581
01:29:24,490 --> 01:29:27,040
如果重新排序系统调用，可能会遇到。

1582
01:29:28,290 --> 01:29:29,900
好的，好的。

1583
01:29:30,680 --> 01:29:33,500
我在讲稿中有一个很好的例子，

1584
01:29:33,560 --> 01:29:35,990
讲稿中的，

1585
01:29:35,990 --> 01:29:39,050
shell 命令的行为会变得奇怪，

1586
01:29:40,700 --> 01:29:42,740
这并不是组提交的问题，

1587
01:29:42,740 --> 01:29:45,890
但确实是一个事务需要按顺序提交的问题。

1588
01:29:47,320 --> 01:29:49,520
嗯，我明白了，

1589
01:29:49,610 --> 01:29:51,710
如果没有组提交，那么。

1590
01:29:52,100 --> 01:29:54,140
是的，人们可能会想

1591
01:29:54,140 --> 01:29:56,960
如果没有组提交，

1592
01:29:56,960 --> 01:29:58,370
然后就会有一种情况，

1593
01:29:58,370 --> 01:30:00,410
就是提交一些后面的事务，

1594
01:30:00,410 --> 01:30:01,490
因为它已经完成了，

1595
01:30:01,490 --> 01:30:02,930
但是第一个还没有完成，

1596
01:30:03,440 --> 01:30:04,850
为了创造空间，

1597
01:30:04,850 --> 01:30:05,900
但这不是解决方法。

1598
01:30:07,490 --> 01:30:09,590
好的，理解了，

1599
01:30:09,590 --> 01:30:12,140
在课堂上的什么地方有这个例子？

1600
01:30:12,140 --> 01:30:12,770
我想是 shell 命令，

1601
01:30:13,280 --> 01:30:16,460
说明了顺序是重要的。

1602
01:30:17,270 --> 01:30:17,690
好的。

1603
01:30:17,810 --> 01:30:21,590
它不是直接与组提交关联的，

1604
01:30:21,590 --> 01:30:24,740
但它说明了对系统调用进行排序很重要。

1605
01:30:25,820 --> 01:30:28,850
我明白了，这是不是像文本那样。

