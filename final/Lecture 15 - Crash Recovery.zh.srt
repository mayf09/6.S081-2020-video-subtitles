1
00:00:00,180 --> 00:00:03,590
每个人都能看到我的屏幕
And can everybody see my screen

2
00:00:03,710 --> 00:00:06,020
或我共享的白板吗？
or the whiteboard that I shared.

3
00:00:06,890 --> 00:00:07,550
好的，很好。
Okay, good.

4
00:00:09,250 --> 00:00:11,650
大家的锁实验做的怎么样了，
How are people doing with the lock lab,

5
00:00:11,680 --> 00:00:14,170
让我从这里开始，问一下，
let me start there, just ask if,

6
00:00:15,740 --> 00:00:17,060
进展如何，
how progress

7
00:00:17,300 --> 00:00:20,900
或者困难的是什么，或者还好。
and what its more difficult or it's looking okay.

8
00:00:21,680 --> 00:00:24,650
有人想说说自己的感受吗？
Anybody who want to report on their experience so far.

9
00:00:30,520 --> 00:00:32,560
我希望很多人已经开始了。
I hope lots of people have started.

10
00:00:37,130 --> 00:00:37,430
哦，我。
Oh, I.

11
00:00:37,460 --> 00:00:39,920
好的，继续。
Yeah, go ahead.

12
00:00:40,250 --> 00:00:41,390
哦，抱歉，请继续。
Oh, sorry, go ahead.

13
00:00:42,050 --> 00:00:42,980
好的，很好。
Okay, cool.

14
00:00:45,130 --> 00:00:46,660
我来，我来继续说。
I'll go, I'll go.

15
00:00:47,440 --> 00:00:48,610
锁实验，
The lock lab,

16
00:00:48,670 --> 00:00:57,420
我想第一部分， kalloc 没那么糟糕，
I think the first part, the the kalloc was not as bad,

17
00:00:57,450 --> 00:01:01,830
嗯，然后第二部分就有点难了，
well, and then the second part was a bit harder,

18
00:01:01,890 --> 00:01:04,800
嗯，在我看来要难得多。
well, it's a lot harder in my opinion.

19
00:01:06,180 --> 00:01:10,780
你需要想出一个，
You just have to figure out a,

20
00:01:11,730 --> 00:01:16,530
我想最困难的部分是想出一个解决方案，
I guess the hard part was thinking of a solution that,

21
00:01:17,460 --> 00:01:19,410
比如这不会引起死锁，
it's like hey this doesn't cause deadlock,

22
00:01:19,410 --> 00:01:26,300
但是如果你认为有可能会出现死锁，
but then if you think there are cases where like deadlock could happen

23
00:01:26,300 --> 00:01:30,350
如果你获取一个[]，支持获取锁，所有这些，
if you acquire a [] it's lock again and all that stuff,

24
00:01:30,350 --> 00:01:30,710
但是，
but,

25
00:01:32,210 --> 00:01:34,520
是的，我需要考虑，
yeah, I just have to think, you have to think

26
00:01:34,520 --> 00:01:37,280
比如其他情况或所有东西，
like about extra cases and all that stuff

27
00:01:37,280 --> 00:01:39,200
在那之后，情况应该不会那么糟糕。
and after that it shouldn't be that bad.

28
00:01:40,130 --> 00:01:43,910
还有人想分享到目前为止的经验吗？
Anybody else who want to share their experience so far?

29
00:01:44,240 --> 00:01:45,140
我想问一下，
I want to ask,

30
00:01:45,140 --> 00:01:49,010
我们可以在实验里使用比如无锁，
are we allowed to do any part of the lab like lock free,

31
00:01:49,010 --> 00:01:51,350
因为我知道它们的第一部分，
because I know like their first part,

32
00:01:51,350 --> 00:01:54,860
操作指南清晰地表示，
for example it's pretty the instructions said pretty clearly

33
00:01:54,860 --> 00:01:57,170
编写一个并行的内存分配器，
like make a parallel memory allocator,

34
00:01:57,170 --> 00:02:00,230
但是我们能只用无锁，
but can we do it just lock free

35
00:02:00,230 --> 00:02:03,410
并让它保持原样。
and think, you know leave it as it is.

36
00:02:03,560 --> 00:02:06,920
你可以自由地做任何能通过的解决方案，
You're free to do any solution to pass which made great,

37
00:02:07,700 --> 00:02:11,480
无锁也可以，
it's fine lock free,

38
00:02:11,480 --> 00:02:12,800
我会，
I would be,

39
00:02:12,830 --> 00:02:14,120
你当然可以自由去做它。
you are certainly free to do it.

40
00:02:14,510 --> 00:02:16,400
我不会直接从那里开始，
I'd be hesitant to start there,

41
00:02:16,430 --> 00:02:17,330
如果我是你，
if I were you,

42
00:02:17,330 --> 00:02:21,110
我会先从一个更细粒度的锁实现开始，
I would start first with a more fine-grained lock implementation

43
00:02:21,110 --> 00:02:23,210
然后转到无锁实现。
and then move to the lock free implementation.

44
00:02:24,140 --> 00:02:27,320
所以这里不是从无锁开始的的原因是，
So the reason there is not started with a lock free,

45
00:02:27,320 --> 00:02:29,270
如果你使用一个细粒度的，
because if you go to a fine-grain,

46
00:02:29,270 --> 00:02:31,160
你需要做所有并行的东西，
you need to do all of the parallel stuff,

47
00:02:31,160 --> 00:02:33,170
但是如果你直接使用无锁，
but if you just go directly to a lock free one,

48
00:02:33,170 --> 00:02:36,020
你可以将其保留在一个空闲列表中，
then you can keep it on a single free list

49
00:02:36,020 --> 00:02:40,940
你只需要[]，
and you just need to, you just need to [],

50
00:02:40,940 --> 00:02:43,070
释放和分配操作，
the free and allocate operations,

51
00:02:43,070 --> 00:02:44,240
实际上并没有那么糟糕。
which actually isn't that bad.

52
00:02:45,120 --> 00:02:47,010
是的，我想也许，在一个，
Yeah, I think maybe in a,

53
00:02:47,010 --> 00:02:49,020
如果在 kalloc 的情况下只有一个列表，
if there's a single list in the case of the kalloc,

54
00:02:49,020 --> 00:02:49,890
可能是那种情况，
that might be the case,

55
00:02:49,890 --> 00:02:54,030
我想无锁的[]会是一个更复杂的问题。
I think you know the lock free [] is going to be a more complicated.

56
00:02:54,360 --> 00:02:56,580
是的，那是我不敢做的。
Yeah, that I'm scared to do.

57
00:02:56,640 --> 00:02:59,730
但是，这是正确的反应。
But, that's the right reaction to have.

58
00:03:01,440 --> 00:03:02,520
还有其他人吗？
Anybody else?

59
00:03:04,950 --> 00:03:08,370
我发现调试这些问题有点困难，
I found it a bit hard to debug those problems,

60
00:03:08,370 --> 00:03:11,040
因为不能直接地了解发生了什么，
because it's not immediately clear what is happening,

61
00:03:11,040 --> 00:03:12,620
所以我们必须去，
so we have to go

62
00:03:12,620 --> 00:03:18,090
设置 gdb ，中断，中断，中断，是的。
and set with gdb and break break break, and yeah.

63
00:03:18,980 --> 00:03:20,900
是的，我想惟一的，
Yeah, I think the only,

64
00:03:20,990 --> 00:03:23,300
我害怕这些锁实验的一个原因是，
one reason I'm always scared to get these lock labs,

65
00:03:23,300 --> 00:03:26,030
像我说过的，这些实验更难调试，
as I said, labs you know they're harder to debug,

66
00:03:26,510 --> 00:03:30,620
而且 bug 可能不会在每次运行时都出现。
and you know the bug might not show up on every run.

67
00:03:31,200 --> 00:03:35,070
但是，它是非常有教育意义的，
And but hopefully it is very educational,

68
00:03:35,070 --> 00:03:39,270
因为学习程序锁在内核中是一件真实的事，
because learning a program locks inside the kernel is a real thing,

69
00:03:39,270 --> 00:03:43,050
但这绝对是一个核心挑战。
and but it is definitely a core challenge.

70
00:03:44,100 --> 00:03:47,940
这里可能有一件事，
One thing about maybe there's a you know for the,

71
00:03:48,330 --> 00:03:52,680
下一个实验不涉及任何并发，
of course, you know the next lab actually doesn't involve basically any concurrency,

72
00:03:53,040 --> 00:03:56,610
希望这会更直接。
and should hopefully that will be much more straightforward.

73
00:03:59,760 --> 00:04:00,150
好的。
Okay.

74
00:04:00,150 --> 00:04:01,920
我想，你如何，
I gue-, I guess, how do you,

75
00:04:02,070 --> 00:04:07,410
你如何高效地调试并发程序，
how do you efficiently or effectively debug concurrent programs,

76
00:04:07,410 --> 00:04:10,950
比如所有使用 gdb 的多线程那样。
like with all those multiple threads using gdb.

77
00:04:10,950 --> 00:04:13,140
我使用非常基本的东西，
I use very basic stuff,

78
00:04:13,260 --> 00:04:15,570
我使用 print 语句。
I have use print statements.

79
00:04:15,990 --> 00:04:18,990
我主要依靠的是，
But the main thing I rely on is

80
00:04:18,990 --> 00:04:22,230
我尝试写下或断言不变量，
I sort of tried to write down or assertions for invariants,

81
00:04:22,230 --> 00:04:24,810
在我认为应该是 true 的任何点。
that I think should be true at every point.

82
00:04:25,490 --> 00:04:27,650
如果断言失败，
And if the assertion goes off,

83
00:04:27,650 --> 00:04:30,110
然后我知道我的想法有问题，
then I know that you know there's something wrong in my thinking

84
00:04:30,110 --> 00:04:31,400
或者断言是错的。
or assertion was wrong.

85
00:04:31,900 --> 00:04:34,060
然后我想一会儿，
And then I think for a while

86
00:04:34,090 --> 00:04:36,580
试着决定它是什么，
and try to decide what it is,

87
00:04:36,610 --> 00:04:38,140
然后从那里出发。
and then go from there.

88
00:04:38,620 --> 00:04:42,040
正常的，
The normal,

89
00:04:42,040 --> 00:04:44,830
对于许多其他设置，
for many other settings,

90
00:04:44,830 --> 00:04:47,680
有竞争检测器可以帮助你，
there are race detectors that can help you,

91
00:04:47,680 --> 00:04:53,350
并且标志代码可能看起来，
and you know basically flag code that may looks like,

92
00:04:53,350 --> 00:04:55,270
它可能有问题，
it might be having problems

93
00:04:55,360 --> 00:04:57,640
或者受竞争检测器影响，
or as prone to race conditions,

94
00:04:57,820 --> 00:05:00,940
但那是一整套其他的工具，
but that's a whole set of other tools,

95
00:05:01,060 --> 00:05:03,010
我们没有用到的东西。
that we're not using.

96
00:05:03,770 --> 00:05:06,770
它也不是那么好，
And it's not that good,

97
00:05:06,770 --> 00:05:08,210
但这是一大步，
but there's a little bit of a big step

98
00:05:08,210 --> 00:05:10,490
让这些启动并继续运行。
to actually get that all up and going and running.

99
00:05:11,270 --> 00:05:14,480
这是人们使用竞争探测器的另一种机制。
So that's the other mechanism that people use race detectors.

100
00:05:16,960 --> 00:05:20,920
基本上标志，任何更新或写入的共享变量，
Basically flag, any any shared variable that is updated or write

101
00:05:20,920 --> 00:05:22,270
不需要持有一个锁。
without actually holding a lock.

102
00:05:24,460 --> 00:05:25,930
这对解决死锁没有帮助，
That doesn't help with deadlocks,

103
00:05:25,930 --> 00:05:28,930
比如，在这个实验中的 bcache 锁，
for example in this lab in a bcache lock,

104
00:05:28,930 --> 00:05:30,970
你会遇到死锁，
you know you get deadlocks,

105
00:05:31,060 --> 00:05:33,280
死锁往往更容易进行调试，
deadlocks are tend to be easier to do debug, correct,

106
00:05:33,280 --> 00:05:35,560
因为你会遇到 panic ，
because you can get the panic

107
00:05:35,560 --> 00:05:38,110
然后你可以在 gdb 中查看 backtrace ，
and then you can look at the gdb in the backtrace

108
00:05:38,110 --> 00:05:40,720
看看什么引起了死锁。
and see actually was involved in the deadlock.

109
00:05:44,620 --> 00:05:45,370
这能理解吗？
Does that make sense?

110
00:05:46,810 --> 00:05:47,830
谢谢。
Thank you.

111
00:05:50,050 --> 00:05:52,210
好的，另一个建议，
Okay, another suggestion,

112
00:05:52,210 --> 00:05:54,430
有人在反馈中说的，
actually somebody posted on the feedback,

113
00:05:54,430 --> 00:05:58,330
课程更少了，
is you know classes are tend is getting a little bit lower

114
00:05:58,330 --> 00:05:59,500
比起学起刚开始的时候，
than in the beginning of the semester,

115
00:05:59,500 --> 00:06:00,790
我想我们足够小，
and I think we might be small enough,

116
00:06:00,790 --> 00:06:03,910
或者人数合适，
or the size that it may be perfectly fine

117
00:06:03,910 --> 00:06:05,080
打开摄像头。
to actually have cameras on.

118
00:06:05,630 --> 00:06:08,210
所以我想鼓励你，
And so maybe I want to encourage you to

119
00:06:08,210 --> 00:06:10,700
如果你提问，可以打开你的摄像头，
if you ask a question to turn on your camera,

120
00:06:11,210 --> 00:06:14,840
希望能改善我们的体验，
you know will hopefully improve in our experiences,

121
00:06:14,840 --> 00:06:16,160
如果你看到的是教室，
if you've seen the classroom

122
00:06:16,160 --> 00:06:17,630
而不是虚拟会议。
as opposed to in a virtual meeting.

123
00:06:18,980 --> 00:06:21,380
而且你也不用一直看着我。
And you don't have to look at me.

124
00:06:22,720 --> 00:06:25,900
好的，那么，
Okay, so,

125
00:06:25,960 --> 00:06:27,760
好的，今天的课程，
okay, today's lecture,

126
00:06:27,850 --> 00:06:29,440
今天的课程是
so today's lecture is going to be

127
00:06:29,440 --> 00:06:32,560
关于文件系统的崩溃安全，
about crash safety and crash safety of file systems,

128
00:06:32,800 --> 00:06:35,590
这不是一般形式的崩溃安全，
and this is not crash safety in its most general form,

129
00:06:35,590 --> 00:06:38,530
我真正关注的是一个特定的问题，
actually I'm really focusing on a particular problem,

130
00:06:41,980 --> 00:06:43,450
或者一个特殊的问题，
or a specific problem,

131
00:06:43,480 --> 00:06:46,750
也就是，崩溃或断电
namely a crash or power failure

132
00:06:47,050 --> 00:06:53,900
可能会导致磁盘上的文件系统
can lead on-disk file system

133
00:06:57,060 --> 00:07:00,360
处于不一致的状态，或不正确的状态。
to be in an inconsistent state or an incorrect state.

134
00:07:04,080 --> 00:07:05,850
我的意思是，不正确的状态是，
And what I mean, with an incorrect state is

135
00:07:05,850 --> 00:07:08,760
比如一个数据块属于两个文件，
you know for example a data block belongs two files,

136
00:07:08,790 --> 00:07:13,500
或者一个 inode 分配给不同的文件。
or an inode is allocated to different files.

137
00:07:14,140 --> 00:07:18,940
所以这个问题可能出现的情况是，
And so the scenario where this problem might sort of appear is,

138
00:07:18,940 --> 00:07:21,340
假设你运行 make ，
let's say you know you're running make,

139
00:07:21,900 --> 00:07:25,530
make 与文件系统交互，
make pretty file system interact with the file system,

140
00:07:25,740 --> 00:07:26,970
读写文件，
reads writes files

141
00:07:27,180 --> 00:07:31,320
在这个过程中，发生了断电，
and somewhere during you know that thing, a power failure happens,

142
00:07:33,920 --> 00:07:36,110
可能是你的笔记本电脑没电了，
you know maybe your laptop run out of battery,

143
00:07:36,290 --> 00:07:40,370
也许你的房子刚刚断电了，
you know maybe the power just dropped to your house,

144
00:07:40,370 --> 00:07:44,000
你重新启动，
and you know you reboot,

145
00:07:45,460 --> 00:07:47,980
当电源在某一时刻恢复，
the power comes back on at some point,

146
00:07:48,370 --> 00:07:51,340
你重新启动机器，
you reboot the machine, machine comes back up

147
00:07:51,370 --> 00:07:54,280
然后你会再次得到提示符，
and then you get a prompt again,

148
00:07:54,280 --> 00:07:55,240
你运行 ls ，
you run ls

149
00:07:55,750 --> 00:07:58,450
并且希望你的文件系统处于良好状态，
and you hope basically that your file system is in a good state,

150
00:07:59,200 --> 00:08:01,120
在仍然可以使用的状态。
in the state actually can still use it.

151
00:08:01,880 --> 00:08:05,420
所以，我们关注的特定故障或崩溃是
And so the particular failures or crashes that we're concerned about are

152
00:08:05,450 --> 00:08:08,300
文件系统操作期间的电源故障，
basically power failures during file system operations

153
00:08:08,510 --> 00:08:11,600
或者内核死机，
or the kernel panics,

154
00:08:11,630 --> 00:08:14,000
当运行文件系统操作时，
you know while running some file system operation,

155
00:08:14,210 --> 00:08:15,260
xv6 发生死机，
xv6 is panics,

156
00:08:15,260 --> 00:08:16,250
大多数内核发生死机，
most kernels are panics,

157
00:08:16,250 --> 00:08:19,400
可能是某些内核错误导致死机，
you know maybe there're some kernel bug that causes a panic

158
00:08:19,580 --> 00:08:21,560
突然之间你的系统失效。
and you know suddenly your system just fails.

159
00:08:22,350 --> 00:08:23,520
你希望的情况是，
And what you'd like to be the case

160
00:08:23,520 --> 00:08:25,470
在重启之后，你可以做一些事情，
that after rebooting you can actually do something,

161
00:08:26,430 --> 00:08:28,080
或者你仍然可以使用文件系统。
or you can still use the file system.

162
00:08:28,590 --> 00:08:30,210
这可能会想到一些东西，
And this might be something where you're thinking,

163
00:08:30,210 --> 00:08:31,950
这怎么可能不对，
well, how could that not be, right,

164
00:08:31,950 --> 00:08:35,730
因为文件系统存储在持久化存储介质上，
because the file system stored on a persistent storage medium

165
00:08:35,730 --> 00:08:37,470
所以，如果出现电源故障，
and so if the power fails,

166
00:08:37,470 --> 00:08:39,570
介质应该是好的，
you know that medium should be good,

167
00:08:39,570 --> 00:08:41,100
那么一旦机器恢复工作，
then so once machine comes back up,

168
00:08:41,100 --> 00:08:43,050
你写的所有块都应该在那里。
you know all the blocks that you've written should be there.

169
00:08:43,730 --> 00:08:45,620
我们将看到许多棘手的情况，
And we'll see that the tricky cases

170
00:08:45,620 --> 00:08:50,780
很多文件系统操作是多步操作。
that many file system operations have multi-step operations.

171
00:08:51,240 --> 00:08:54,300
真正需要注意的是
And really what is important to note

172
00:08:54,300 --> 00:08:57,840
如果我们在错误的地崩溃，
and if we if we crash just in the wrong place,

173
00:08:57,840 --> 00:08:59,490
在这些多步操作中，
in these multi-step operations,

174
00:08:59,580 --> 00:09:02,850
文件系统可能会不一致，
the file system actually may end up being an this inconsistent

175
00:09:02,880 --> 00:09:04,530
在很短的时间内，
for that short period of time

176
00:09:04,650 --> 00:09:06,720
如果断电正好发生在那里，
and if the power fail just happened there,

177
00:09:06,900 --> 00:09:07,980
可能会有不好的事情发生。
you know something bad could happen.

178
00:09:08,740 --> 00:09:13,450
这就是我们今天关注的问题，
And so that is sort of the problem that we're focusing on today

179
00:09:13,870 --> 00:09:15,730
这与别的问题不同，
and so this is different from the problem

180
00:09:15,730 --> 00:09:18,100
比如，这里出现断电，
that for example whatever you know there's a power failure

181
00:09:18,100 --> 00:09:19,930
并且你的磁盘着火了，
and your disk caught fire

182
00:09:19,930 --> 00:09:22,060
那里什么都没有了，
and so there's nothing there anymore

183
00:09:22,090 --> 00:09:23,170
你需要，
and you need to,

184
00:09:23,380 --> 00:09:26,860
在这种情况下，这是一个完全不同的问题，
in that case, you need you need there's a completely different problem,

185
00:09:26,860 --> 00:09:28,030
有不同的解决方案，
that has different solutions,

186
00:09:28,030 --> 00:09:32,160
比如，你必须取回你的文件系统备份，
you know, for example you have to go back to backup of your file system,

187
00:09:32,160 --> 00:09:34,470
重新安装文件系统，等等。
reinstall your file system, etc etc.

188
00:09:35,310 --> 00:09:37,020
所以这不是我们关心的问题。
So that's the problem we're not worried about.

189
00:09:37,020 --> 00:09:38,040
我们真的关心的是
We're really worried about

190
00:09:38,040 --> 00:09:44,160
多步操作作过程中发生故障的问题。
the specific problem of failure happening right during a multi-step operation.

191
00:09:46,380 --> 00:09:49,270
好的，这个问题的解决方案是，
Okay, and the solution for that specific problem that

192
00:09:49,270 --> 00:09:53,050
我们将要探索的是一种叫做日志的东西，
we're going to be exploring is something that is called logging,

193
00:09:53,260 --> 00:09:56,950
这是一个非常流行的解决方案，
and this is a very popular solution,

194
00:09:56,950 --> 00:10:00,970
最初来自数据库世界，
originally coming out of the database world,

195
00:10:00,970 --> 00:10:04,600
但是现在有很多文件系统使用日志。
but a lot of file systems that use logging these days.

196
00:10:05,100 --> 00:10:06,690
我们会，
We're gonna,

197
00:10:06,720 --> 00:10:08,580
它很受欢迎的一个原因是
it's very one reason it's popular is

198
00:10:08,580 --> 00:10:10,440
因为这是一个非常规范的解决方案，
because it's a very principle solution,

199
00:10:10,650 --> 00:10:16,440
我们将看到 xv6 中日志的实现，
and we're going to see the implementation of logging in xv6

200
00:10:16,650 --> 00:10:19,230
当然， xv6 的实现非常简单，
and of course xv6 has a very simple implementation,

201
00:10:19,230 --> 00:10:22,410
就像日志的最小实现，
like a bare minimal implementation of logging,

202
00:10:22,470 --> 00:10:24,840
只是为了演示关键思想，
just to demonstrate in the key ideas,

203
00:10:25,270 --> 00:10:29,110
即使只是一个基本框架，
and even that sort of a very bare bone,

204
00:10:29,110 --> 00:10:30,970
日志实现仍然有一些问题，
log implementation actually has several issues,

205
00:10:30,970 --> 00:10:32,740
我们将要讨论，
that were going to be talking about

206
00:10:32,800 --> 00:10:34,750
这就是为什么值得去研究它。
and that's why it's worth you know studying it.

207
00:10:35,410 --> 00:10:39,220
我们会看到 xv6 解决方案的一个缺点是，
One downside as we'll see is the xv6 solution is

208
00:10:39,220 --> 00:10:42,190
因为简单，它的性能也不是很好，
because of simplicity, its performance is also not so great,

209
00:10:42,900 --> 00:10:45,900
即使日志系统原则上可以获得良好的性能。
even though logging systems in principle can get a good performance.

210
00:10:46,170 --> 00:10:49,110
所以我们下周要做的是，
And so what we'll do next week is

211
00:10:49,110 --> 00:10:53,400
看看如何实现一个高性能的日志系统，
actually look how, how to implement a high performance logging system

212
00:10:53,490 --> 00:10:58,680
通过学习 Linux ext3 文件系统使用的日志系统，
by studying the logging system the Linux ext3 file system uses,

213
00:10:59,320 --> 00:11:00,820
但那是下周的事了。
but that's next week.

214
00:11:01,860 --> 00:11:06,210
另一个，今天我想说的一个小点是，
Another, may be small a point I want to make today is

215
00:11:06,210 --> 00:11:08,460
这是我们最后一节 xv6 课，
this is our last xv6 lecture

216
00:11:08,850 --> 00:11:13,770
从现在开始，我们将转向论文，
and from now on, we're going to be switching to papers,

217
00:11:13,950 --> 00:11:16,080
因为在某些方面，我们所做的是
because in some ways, what we've done is

218
00:11:16,080 --> 00:11:18,480
我们已经涵盖了基本概念，
we've covered you know the basic concepts

219
00:11:18,630 --> 00:11:24,030
我们可以通过阅读论文了解更高级的操作系统思想。
and we can start looking at more advance operating system ideas by reading papers.

220
00:11:24,830 --> 00:11:25,550
好的？
Okay?

221
00:11:27,130 --> 00:11:28,210
到目前为止，有什么问题吗？
Any questions so far?

222
00:11:34,590 --> 00:11:35,280
好的，很好。
Well, good.

223
00:11:38,080 --> 00:11:42,520
好的，让我回顾一下这些场景，
Okay, so let me go back a little bit about the scenarios

224
00:11:42,520 --> 00:11:46,990
我们在这节课中要关注的。
that were really, that we're focusing about in in this lecture.

225
00:11:47,470 --> 00:11:51,190
所以，文件系统操作，
So file systems, file system operations,

226
00:11:52,380 --> 00:11:55,080
比如创建文件，写入文件，
like creating a file, writing a file,

227
00:11:55,110 --> 00:11:58,170
都是多步的磁盘操作。
are multi-step disk operations.

228
00:12:06,400 --> 00:12:09,940
我们在上周一看到，
And we saw that last week on Monday,

229
00:12:09,940 --> 00:12:11,770
我们讨论了 create 是如何实现的，
we talked about how create is implemented,

230
00:12:11,770 --> 00:12:13,690
比如创建文件或写入文件，
like creating a file, or writing to a file,

231
00:12:13,690 --> 00:12:16,180
我们经常看到事件序列，
we often see that you know the sequence of events,

232
00:12:16,180 --> 00:12:19,630
或者步骤序列是分配 inode ，
or something the sequence of steps are allocated inode,

233
00:12:19,630 --> 00:12:21,370
标记在磁盘上分配 inode ，
mark the inode allocated on disk,

234
00:12:21,460 --> 00:12:24,700
然后写入包含 inode 的目录，
then you know write the directory block that contains that inode

235
00:12:24,730 --> 00:12:26,980
这就是我所说的多步操作。
and so those are the multi-steps that I'm talking about.

236
00:12:27,540 --> 00:12:30,960
如果我们在两个步骤之间崩溃，
If we get a crash between two of the steps,

237
00:12:31,080 --> 00:12:33,300
这个崩溃可能导致，
that crash can leave,

238
00:12:34,870 --> 00:12:41,720
可能会破坏文件系统不变性。
may leave, may leave the file system invariance violated.

239
00:12:45,440 --> 00:12:50,150
破坏不变性，我说的是形式的不变性，
And violent the invariance, I'm talking about are invariance of the form,

240
00:12:50,390 --> 00:12:53,450
每个块要么是空闲的，
you know every block is either free

241
00:12:53,480 --> 00:12:56,900
要么分配给一个文件，而不是两个文件。
or allocated to one file and not to two files.

242
00:12:57,420 --> 00:13:00,390
我们想要确保这件事发生，
And you know we want to make sure that this happens,

243
00:13:00,390 --> 00:13:05,310
即使这些失败发生在这些操作之间。
despite you know these failures right between these operations.

244
00:13:06,880 --> 00:13:13,280
风险是如果不变性被破坏，
Yeah, and the risk is if if the invariance are violated,

245
00:13:13,790 --> 00:13:16,220
重新启动后可能会发生不好的事情，
that bad things can happen after reboot,

246
00:13:17,510 --> 00:13:20,960
你可能马上又会崩溃。
you know the, you might crash again immediately.

247
00:13:21,930 --> 00:13:23,460
因为有一些数据结构，
Because you know there's some data structure,

248
00:13:23,460 --> 00:13:25,380
文件系统处于一种状态，
the file system you know in a state

249
00:13:25,380 --> 00:13:27,540
文件系统无法处理，
that the file system actually can't really deal with,

250
00:13:27,540 --> 00:13:29,640
在这个数据结构上这种状态，
on this data structures in such a state,

251
00:13:29,760 --> 00:13:32,910
文件系统不能再处理它们了，
[] that the file system really can't process them anymore,

252
00:13:33,240 --> 00:13:37,730
或者更有可能你没有崩溃，
or more likely you're not crash, no crash,

253
00:13:37,790 --> 00:13:40,460
但是数据可能会丢失，
but you know data may get lost,

254
00:13:41,340 --> 00:13:43,920
或者你读取或写入不正确的数据。
or you read or write incorrect data.

255
00:13:52,630 --> 00:13:54,550
我们会看几个例子，
And we'll see a couple of examples,

256
00:13:54,550 --> 00:13:56,050
为了更清楚地说明这一点，
you know to make it more clear,

257
00:13:56,140 --> 00:13:59,260
但这些都是我们要担心的风险。
but so these are the risks that we're worried about.

258
00:14:02,020 --> 00:14:06,700
我不知道，有没有人在个人生活或日常生活中，
I don't know if anybody actually every personal life or in your daily life

259
00:14:06,730 --> 00:14:08,920
使用电脑时遇到问题，
using computers actually has experienced a problem

260
00:14:08,920 --> 00:14:13,360
你在文件系统中出现故障，
where basically, you had a failure in the file system

261
00:14:13,360 --> 00:14:15,670
你有一个断电故障，
where you had a failure, had a power failure,

262
00:14:15,670 --> 00:14:17,980
你的机器或你的手机重新启动，
your machine rebooted or your phone restarted

263
00:14:18,190 --> 00:14:23,110
之后就无法使用了。
and basically unusable afterwards.

264
00:14:23,980 --> 00:14:25,450
一个原因可能是不寻常的，
One reason that might be unusual,

265
00:14:25,450 --> 00:14:28,000
因为文件系统没有正确恢复。
because actually the file system just didn't recover correctly.

266
00:14:37,370 --> 00:14:39,230
好的，为了说得更清楚，
Okay, so to make it more clear,

267
00:14:39,230 --> 00:14:42,500
让我们来看一个关于 xv6 的例子，
let's just let's look at an example in the context of xv6,

268
00:14:42,500 --> 00:14:45,560
我想把这个风险说得更具体一点，
I like to make this risk a little bit more concrete,

269
00:14:45,740 --> 00:14:48,560
让我们看看 xv6 中的一个例子，
let's look at an example in the context of xv6

270
00:14:48,770 --> 00:14:51,110
看看会出现什么问题。
and to see what actually go could go wrong.

271
00:14:52,020 --> 00:14:57,690
记得，周一的 xv6 文件系统，
So remember the, for Monday, the xv6 file system,

272
00:14:57,690 --> 00:15:00,120
非常简单的文件系统有一个简单的磁盘布局，
very simple file system has a simple disk layout,

273
00:15:00,510 --> 00:15:04,440
你知道超级块，
you know super block, a super block,

274
00:15:04,440 --> 00:15:06,750
这是日志，我们今天要讨论很多，
there's the log, that we're going to be talking about a lot today,

275
00:15:06,750 --> 00:15:08,070
我们周一没有谈到，
that we didn't talk about on Monday,

276
00:15:08,280 --> 00:15:11,040
inode 是一些块包含，
where inodes you know set of blocks that actually contain,

277
00:15:11,280 --> 00:15:13,530
每个块可能包含多个 inode ，
each and each block may contain multiply inodes,

278
00:15:13,650 --> 00:15:17,880
位图块来记录哪些块是空闲的，哪些不是，
and bitmap block to record which blocks are free and which are not free,

279
00:15:18,120 --> 00:15:22,530
然后数据块包含文件系统的实际数据。
and then the data blocks actually contain the actual data of the file system.

280
00:15:23,460 --> 00:15:26,130
你还记得，周一的课上，
You remember from Monday's lecture,

281
00:15:26,130 --> 00:15:27,750
我分析了这里的输出，
I reproduce the trace here,

282
00:15:27,750 --> 00:15:30,600
我们了解了文件是如何创建的，
you know we looked at actually a how files created

283
00:15:31,020 --> 00:15:34,680
我们看到了单个文件的创建。
and you know we see that the creation of a single file.

284
00:15:35,370 --> 00:15:36,900
好的，稍等一下。
Well, wait a second.

285
00:15:41,460 --> 00:15:46,240
单个文件的创建由多个操作组成，
The, the creation of a single file consists of multiple operations,

286
00:15:46,360 --> 00:15:48,520
比如，在这个特定的场景中，
for example in this particular scenario,

287
00:15:48,520 --> 00:15:51,340
我在幻灯片的这里，
that I've here on the, on on this slide,

288
00:15:51,670 --> 00:15:57,610
我们看到， inode 被分配，
we see the, you know inode is allocated

289
00:15:57,670 --> 00:16:01,300
我们知道这个，因为块 33 正在被写入，
and we know this, because there's block 33 is being written,

290
00:16:01,570 --> 00:16:05,380
我们看到 inode 正在初始化，
do we see that the inode is being initialized,

291
00:16:05,380 --> 00:16:07,090
然后再写入块 33 ，
then write again to block 33,

292
00:16:07,330 --> 00:16:10,030
然后我们看到块 46 被写入，
then we see the block 46 is written

293
00:16:10,030 --> 00:16:11,620
这个写入的原因是，
and that reason is written is,

294
00:16:11,620 --> 00:16:15,970
大概是因为包含 x 的目录块，
presumably because you know the directory block that actually contains x

295
00:16:16,120 --> 00:16:18,820
并且 x 的 inode 编号被写入磁盘。
and the inode number for x is written to the disk.

296
00:16:19,240 --> 00:16:21,460
然后 root inode 被更新，
Then the inode, root inode updated

297
00:16:21,460 --> 00:16:24,730
反映目录的大小增大，
to reflect that the directory has grown in size

298
00:16:24,730 --> 00:16:28,630
包含这个特定文件 x ，
to contain this particular file x

299
00:16:28,840 --> 00:16:30,820
然后 inode 更新了。
and then you know inode updated.

300
00:16:31,650 --> 00:16:35,080
所以我们想了解的是，
So, what we want to understand is

301
00:16:35,080 --> 00:16:38,680
会发生什么，什么会出现问题。
what happens, like what could possibly go wrong, right.

302
00:16:39,040 --> 00:16:44,890
假设我们在这里遇到电源故障，
So let's say you know we have a power failure right here,

303
00:16:45,100 --> 00:16:49,060
这是电源故障或内核崩溃。
so here is power failure or kernel crash.

304
00:16:52,160 --> 00:16:53,660
那么断电后会发生什么，
So what happens after the power failure,

305
00:16:53,660 --> 00:16:56,300
所有内存中状态都会丢失，
correct all the in-memory state is lost,

306
00:16:56,600 --> 00:17:00,260
因为内存中的状态数据在 RAM 中，
because in-memory state data that's actually in RAM,

307
00:17:00,260 --> 00:17:03,230
比如所有进程，所有文件描述符，
like all the processes, all the file descriptors,

308
00:17:03,960 --> 00:17:06,930
所有内存中的缓存都消失了，
all the in-memory caches are gone,

309
00:17:07,140 --> 00:17:09,420
因为内存不是持久的，
because memory is not persistent

310
00:17:09,600 --> 00:17:13,110
我们唯一剩下的东西就是磁盘上的，
and the only thing that we have left is what actually is on the disk,

311
00:17:13,650 --> 00:17:18,090
所以只有数据结构，位和字节，
so only the data structures, the bits and bytes,

312
00:17:18,090 --> 00:17:22,200
它们在磁盘上，在断电后仍然存在，
they're actually sitting on the disk are survived the power failure,

313
00:17:22,410 --> 00:17:27,120
因为那个介质具有耐久性。
because that actually medium is you know persistence or has durability.

314
00:17:28,100 --> 00:17:29,810
所以我们想知道，想理解，
And so we want to know, like want understand,

315
00:17:30,380 --> 00:17:34,370
如果我们在这里崩溃，并且没有额外的机制，
so if we crash here and we have no additional mechanisms,

316
00:17:34,520 --> 00:17:37,910
或者没有我们将要讨论的日志，
or no logging as we're going to be talking about,

317
00:17:37,970 --> 00:17:39,350
没有额外的机制，
we have no additional mechanisms,

318
00:17:39,860 --> 00:17:41,120
会有多糟糕。
how how bad is it.

319
00:17:42,750 --> 00:17:45,300
我们在这里有什么风险？
What risk are we running here?

320
00:17:53,750 --> 00:17:54,380
有人知道吗？
Anybody?

321
00:17:57,670 --> 00:18:01,060
基本上，我们写入块 33
So basically you know we've written block 33

322
00:18:01,120 --> 00:18:03,520
来记录已分配的 inode ，
to record the inode has been allocated,

323
00:18:03,580 --> 00:18:04,690
然后我们断电了，
then we had a power failure

324
00:18:04,690 --> 00:18:05,650
然后我们又恢复了。
and then we come back up.

325
00:18:07,780 --> 00:18:08,260
继续， Brandon 。
Go ahead Brandon.

326
00:18:13,300 --> 00:18:18,280
这是不是说我们丢失了这个块，
This does that mean we lose the, lose this block,

327
00:18:18,780 --> 00:18:21,810
比如它有数据，但其实不是。
it's like it seems like it's populated, but it's actually not.

328
00:18:22,290 --> 00:18:25,830
是的，没错，我想我们丢失了整个块，
Yeah, correctly, I think we're losing, we're losing the whole block,

329
00:18:25,830 --> 00:18:28,500
但是我们使用了 inode x ，
but we used inode x, correct inode x,

330
00:18:29,070 --> 00:18:34,320
并且标记为已分配的 x 的 inode 已经在磁盘上分配，
and inode for x that was allocated or marked as allocated is allocated on disk,

331
00:18:34,470 --> 00:18:37,020
但是我们没有放入任何，
but we have not put in any,

332
00:18:37,020 --> 00:18:40,350
我们没有成功放入任何目录里。
we've not succeeded, correct, put in any directory.

333
00:18:41,120 --> 00:18:43,880
所以在磁盘上，分配了一个 inode ，
So basically on the disk, you know there's an inode allocated,

334
00:18:43,880 --> 00:18:45,860
但它不会出现在任何目录中，
but it doesn't appear in any directory,

335
00:18:46,160 --> 00:18:48,110
所以我们甚至不能删除它。
so we can't even remove it right.

336
00:18:48,830 --> 00:18:51,410
所以，这里发生的是
And so basically what will this cause has to happen is

337
00:18:51,410 --> 00:18:52,970
我们丢失了一个 inode 。
we lose lose an inode.

338
00:18:57,200 --> 00:18:57,920
这能理解吗？
Does that make sense?

339
00:19:01,260 --> 00:19:03,360
你可能会想，也许我应该做的是，
You might think, well maybe what I should do is,

340
00:19:03,360 --> 00:19:05,100
也许我应该重新安排写入顺序。
maybe I should reorder the write.

341
00:19:05,830 --> 00:19:08,560
以某种方法，希望这个，
And, in a way you know then hopefully you know this,

342
00:19:08,560 --> 00:19:09,610
我们不会丢失 inode ，
you know we don't lose the inode,

343
00:19:09,610 --> 00:19:11,590
比如，我们可以试着做的是，
so for example another thing we could try to do is

344
00:19:11,590 --> 00:19:12,820
我们要做的是，
say well what we'll do is,

345
00:19:12,940 --> 00:19:17,620
我们先写入 46 ，
we'll write 46 first,

346
00:19:18,230 --> 00:19:21,320
更新 inode 更新目录，
basically update the inode update directory, right,

347
00:19:21,320 --> 00:19:25,920
目录 inode 写入 32 ，
the directory inode you know write 32

348
00:19:25,950 --> 00:19:29,460
然后在磁盘上标记 inode 已分配，
and then will actually mark the inode is allocated on disk,

349
00:19:30,950 --> 00:19:35,900
标记为已分配。
to mark indicate that mark is allocated.

350
00:19:36,650 --> 00:19:39,470
所以，我们以不同的顺序执行相同的一组操作。
So we do the same set of operations in a slightly different order.

351
00:19:40,050 --> 00:19:44,580
希望我们能够避免这种丢失 inode 的问题。
In the hope that we should avoid this losing of the inode problem.

352
00:19:45,680 --> 00:19:46,910
这能行得通吗？
And would this work?

353
00:19:50,980 --> 00:19:52,960
好的，我们应该问自己，
Well, the thing that we should ask ourselves

354
00:19:52,960 --> 00:19:55,600
比如，让我们考虑一下这个时间点，
like you know let's think about this point in time,

355
00:19:55,810 --> 00:19:57,970
我们假设在这里发生了崩溃，
let's say a crash happens like right here

356
00:19:57,970 --> 00:19:59,020
或者发生电源故障，
or power failure happens

357
00:19:59,020 --> 00:20:02,690
正好发生在更新目录之后，
right between updating the directory basically,

358
00:20:02,690 --> 00:20:05,180
分配磁盘的 inode 之前，
but before we allocated the inode on disk

359
00:20:05,210 --> 00:20:07,460
现在电源故障，
and now you know when power fails,

360
00:20:07,610 --> 00:20:08,720
机器又恢复了，
machine comes back up

361
00:20:08,960 --> 00:20:10,220
我们看看文件系统，
and we look at the file system,

362
00:20:10,250 --> 00:20:12,500
文件系统将处于什么状态。
you know what state will the file system be in.

363
00:20:15,200 --> 00:20:17,780
你会认为它仍然是一个空闲的 inode 。
You'll still think it's a free inode.

364
00:20:19,420 --> 00:20:20,410
是的，会发生什么，
Yeah, what would happen if,

365
00:20:20,410 --> 00:20:23,440
比如我们读取目录中的文件 x ，
for example we read you know file x in the directory,

366
00:20:23,650 --> 00:20:24,490
在根目录中，
in the root directory,

367
00:20:24,490 --> 00:20:26,620
因为它现在这里面，这个数据块。
because it is in there now, correct, this data block.

368
00:20:30,080 --> 00:20:31,250
我们将读取的 inode ，
We're going to be reading the inode,

369
00:20:31,250 --> 00:20:34,160
它甚至没有分配，标记为未分配。
that actually is not even allocated, correct, marked unallocated.

370
00:20:34,950 --> 00:20:39,480
更糟糕的是， inode 可能会再次分配，
And worse, what could happen is, correct, inode it might be allocated again,

371
00:20:39,540 --> 00:20:41,250
或者它可能真的被分配了，
or it might actually really be allocated,

372
00:20:41,610 --> 00:20:46,560
因为未分配的标记是在不同的文件，
because marks unallocated to actually in fact a different file, right,

373
00:20:46,950 --> 00:20:50,130
所以现在我们有两个文件，它们可能，
and so now we have two files that might actually,

374
00:20:50,130 --> 00:20:52,500
两个文件共享，
two files that actually share,

375
00:20:52,500 --> 00:20:53,550
尽管它们完全不同，
even though they're completely different,

376
00:20:53,550 --> 00:20:54,690
但它们共享相同的 inode ，
they share the same inode,

377
00:20:55,350 --> 00:20:57,990
比如，一个文件属于用户一，
for example if one file would be owned by user one

378
00:20:57,990 --> 00:20:58,950
而另一个文件属于用户二，
and one by user two,

379
00:20:58,950 --> 00:21:02,130
那么用户而可以读取用户一的文件数据。
then basically user two could read user one file data right.

380
00:21:03,770 --> 00:21:05,150
所以这也不是好事，对吧。
So that's no good, either, right.

381
00:21:11,230 --> 00:21:11,980
这能理解吗？
Does that make sense?

382
00:21:13,980 --> 00:21:15,870
所以改变顺序，
So basically switching the order

383
00:21:15,870 --> 00:21:17,730
这并不能真正解决我们的问题。
you know it's not really going to solve our problem.

384
00:21:18,500 --> 00:21:21,800
你会遇到我们以前遇到的不同的问题。
You would just basically get a different problem that we had before.

385
00:21:23,630 --> 00:21:25,160
好的，我们再看一个例子。
Okay, let's look at one more example.

386
00:21:25,840 --> 00:21:32,210
这是写入文件 x 的例子。
Here's the example of writing to file x.

387
00:21:35,120 --> 00:21:36,650
所以一旦我们分配了文件，
So once we have the files allocated,

388
00:21:36,650 --> 00:21:37,850
假设所有文件都成功了，
let's say that all succeeded,

389
00:21:37,880 --> 00:21:39,950
现在我们执行 write 系统调用，
and now we're executing the write system call

390
00:21:40,160 --> 00:21:43,280
而 write 系统调用也执行多次写入操作，
and the write system call also does a multiple writes operations

391
00:21:43,280 --> 00:21:44,300
我们在周一看到的，
which we saw on Monday,

392
00:21:44,690 --> 00:21:48,740
比如，它分配块，在这里是块 45 ，
for example it will allocate a block, in this case block 45,

393
00:21:49,160 --> 00:21:52,130
所以它在空闲映射中设置一位，
so it sets a bit in the free map,

394
00:21:52,130 --> 00:21:55,130
块 45 是位图块，
block 45 is the bitmap block,

395
00:21:55,430 --> 00:21:57,980
所以它在位图中分配一个块，
so it allocates a block in the bitmap,

396
00:21:57,980 --> 00:21:59,510
在位图块中分配一个位，
allocates a bit in the bitmap block

397
00:21:59,510 --> 00:22:03,190
表示那个块已经被分配，
to indicate the the block has to be allocated,

398
00:22:03,580 --> 00:22:06,250
那个块，我猜是 595 。
that block turns out to be I guess 595.

399
00:22:06,780 --> 00:22:10,800
然后我们把字符 h 写如 595 ，
And then we write you know the character h you know to 595

400
00:22:10,800 --> 00:22:11,700
然后是字符 i ，
and then the character i,

401
00:22:11,700 --> 00:22:12,870
我们更新 inode 。
you know we update the inode.

402
00:22:13,990 --> 00:22:15,940
好的，现在我们可以问自己同样的问题了，
Right, now we can ask ourselves the same question,

403
00:22:15,940 --> 00:22:21,670
比如如果我们崩溃会发生什么，
like what will happen if we crash,

404
00:22:21,760 --> 00:22:24,940
比如，我们在这里崩溃，
so for example, let's say we allocate crash right here,

405
00:22:25,000 --> 00:22:28,920
在写入位图块之后，
between you know writing the bitmap block,

406
00:22:29,160 --> 00:22:32,850
在写入 inode 之前。
before we allocate before we actually write a inode.

407
00:22:33,700 --> 00:22:34,780
所以，在这里崩溃。
So crash here.

408
00:22:39,980 --> 00:22:42,350
所以重新启动后，我们又回来了，
And so we reboot, we come back up

409
00:22:42,380 --> 00:22:44,360
这是一种特殊的状态，
and this is in a particular state

410
00:22:44,360 --> 00:22:47,600
风险是什么？
and you know what, what is the risk?

411
00:22:50,520 --> 00:22:53,430
我们使用了数据块，但我们失去了它。
We use it data block, but we lose it.

412
00:22:53,790 --> 00:22:54,930
是的，我们又失去了，
Yeah, we lose it again, right,

413
00:22:54,930 --> 00:22:56,550
因为块被分配了，
because the block is allocated,

414
00:22:56,550 --> 00:22:57,930
但没有出现在任何文件中，
but doesn't show up in any file,

415
00:22:58,950 --> 00:23:01,890
因为它没有写入任何 inode ，
because it hasn't been written into any inode,

416
00:23:01,890 --> 00:23:03,180
所以我们丢失了一个数据块。
so we lose a data block.

417
00:23:08,680 --> 00:23:09,220
你可能会想，
You might think,

418
00:23:09,220 --> 00:23:12,100
好吧，也许是因为我们写入顺序错了，
okay, well maybe you know just because we wrote them in the wrong order,

419
00:23:12,100 --> 00:23:13,690
我们应该做的是，
what we should have done is

420
00:23:13,990 --> 00:23:17,260
我们首先应该做的是写入 inode ，
what we should have done is at first write in the inode,

421
00:23:17,650 --> 00:23:22,820
所以先写入 33 ，使用 595 ，
so first write 33 with the, you know with 595

422
00:23:22,910 --> 00:23:26,870
它是间接块或直接块。
as in the either is an indirect block or direct block.

423
00:23:27,520 --> 00:23:32,680
然后我们标记 inode 块为已分配，
And then you know actually we will mark the inode, the block is allocated,

424
00:23:32,680 --> 00:23:35,350
然后我们写入 45 。
so then we'll write you know 45.

425
00:23:37,000 --> 00:23:37,960
如果我们修改顺序，
If we change the order,

426
00:23:37,960 --> 00:23:40,000
因为我们要避免丢失数据块，
because we want to avoid these lost data block,

427
00:23:40,000 --> 00:23:40,990
我们这样修改顺序。
we change order in this way.

428
00:23:42,530 --> 00:23:44,630
现在我们考虑这种情况，
And now let's consider the case,

429
00:23:44,630 --> 00:23:46,100
如果这里出现故障。
if there's a failure right here.

430
00:23:50,370 --> 00:23:51,330
风险是什么？
What is the risk?

431
00:23:56,960 --> 00:24:03,800
文件的大小与实际分配的数据块不匹配。
The size of the file is not compatible with actually how many data blocks are allocated.

432
00:24:04,710 --> 00:24:05,250
也许是这样，
That might be,

433
00:24:05,250 --> 00:24:06,750
虽然我认为写入 33
although I think it's the write of 33

434
00:24:06,750 --> 00:24:10,470
实际上更新了大小和块编号。
actually update both the size and you know the the block number.

435
00:24:11,970 --> 00:24:12,630
噢。
Oh.

436
00:24:13,450 --> 00:24:15,340
所以这可能是正常的。
So that might be might work out okay.

437
00:24:16,780 --> 00:24:19,180
如果有两个单独的写入，那将是一个问题，
If there were two separate writes, that would be a problem,

438
00:24:20,950 --> 00:24:22,270
但这里有个更大的问题。
but there's some bigger problem here.

439
00:24:27,400 --> 00:24:28,510
是不是那个，
Is that the,

440
00:24:29,620 --> 00:24:32,320
所以这个文件里面有，
so the file has the,

441
00:24:33,820 --> 00:24:37,180
所以它有数据块，
so things that it has the data block,

442
00:24:37,180 --> 00:24:40,810
但是数据块被标记为未分配，
but the data block is marked as unallocated

443
00:24:40,900 --> 00:24:45,100
其他文件也可以使用它。
and other files can also use it.

444
00:24:45,220 --> 00:24:47,740
是的，这才是真正的大问题，
Yeah, that's the real big problem here is that,

445
00:24:47,740 --> 00:24:53,950
inode 块 595 属于那个文件，
you know the the inode things 595, block 595 belonged belonged to that file,

446
00:24:54,130 --> 00:24:58,050
但是在磁盘上，它仍标记为未分配，
but actually on disk it's still marked as unallocated

447
00:24:58,110 --> 00:25:01,080
所以，当稍后创建另一个文件时，
and so when later another file was created,

448
00:25:01,110 --> 00:25:04,500
那个块可能会用于另一个文件。
you know that block actually might be used for that other file.

449
00:25:05,140 --> 00:25:09,520
所以现在有一个文件拥有 595 ，
And so now certainly one file things, it owns 595,

450
00:25:09,520 --> 00:25:10,750
但其他文件也是这样的，
but actually other file does,

451
00:25:10,750 --> 00:25:13,150
实际上这两个文件都有 595 ，
in fact both files will have 595

452
00:25:13,150 --> 00:25:16,990
在它们的 inode 的块编号中，
in their block numbers for their inode

453
00:25:17,350 --> 00:25:22,630
如果一个用户拥有该文件，
and basically you know if one user owns that file,

454
00:25:22,630 --> 00:25:23,710
另一个用户拥有另一个文件，
the other user in the other file,

455
00:25:23,710 --> 00:25:26,020
他们可以读写对方的数据，
that can actually read write to each other's data, right,

456
00:25:26,020 --> 00:25:27,910
这显然不是我们想要的。
that's clearly not what we want.

457
00:25:28,390 --> 00:25:30,310
文件系统应该保证，
You know the file system should guarantee

458
00:25:30,490 --> 00:25:33,430
每个块只属于一个文件，
that every block only belongs in one file

459
00:25:33,430 --> 00:25:35,350
不属于其他文件或是空闲的。
and no other file or is free.

460
00:25:37,630 --> 00:25:38,200
好的？
Okay?

461
00:25:38,860 --> 00:25:40,990
所以这可能会导致安全问题，
So this could lead to security problems,

462
00:25:41,020 --> 00:25:48,070
块在多个文件之间共享，
basically block is shared among multiple files,

463
00:25:49,640 --> 00:25:50,990
这绝对是错的。
and that's definitely wrong.

464
00:25:55,480 --> 00:25:58,600
关于可能出现的问题，这些能理解吗？
Does it make sense, in terms of the problems that can appear?

465
00:25:59,300 --> 00:26:02,060
再说一次，这里真正的问题是，
And again, you know the real issue here is,

466
00:26:02,060 --> 00:26:03,950
不是看写入的顺序，
not to watch the ordering of the writes,

467
00:26:04,190 --> 00:26:05,930
但这里真正的根本问题是，
but the real underlying problem here is

468
00:26:05,930 --> 00:26:07,340
我们在进行多次写入，
that we're just doing multiple writes

469
00:26:07,340 --> 00:26:12,590
它必须以原子操作的形式出现在磁盘上。
and it basically have to show up on disk as an atomic operation.

470
00:26:18,920 --> 00:26:26,760
好的，所以我们在这节课中要研究的解决方案是日志。
Okay, so the solution that we're gonna explore in this lecture is logging.

471
00:26:28,380 --> 00:26:29,160
正如我之前所说的，
And as I said before,

472
00:26:29,160 --> 00:26:34,080
这是文件系统中常用的解决方案，
this is a common solution used in file systems

473
00:26:34,080 --> 00:26:37,590
来源于数据库资料。
and originating actually out of the database literature.

474
00:26:37,740 --> 00:26:39,810
它有几个很好的特性，
And it actually has a couple good properties,

475
00:26:39,870 --> 00:26:44,400
其一，它使系统调用或文件系统调用是原子的，
one, it's going to make basically system calls or file system calls atomic,

476
00:26:47,520 --> 00:26:48,540
我的意思是，
with that, I mean,

477
00:26:48,720 --> 00:26:50,520
如果创建文件，
so if a create file

478
00:26:50,520 --> 00:26:52,950
或者调用 create 或 write ，
or you can call create you call write,

479
00:26:53,070 --> 00:26:56,040
所有系统调用的作用，
basically all the effects of that system call

480
00:26:56,040 --> 00:26:58,200
一起出现或完全不出现，
use all appeared altogether or none of them,

481
00:26:58,470 --> 00:27:00,780
所以，这避免了这个问题，
so that avoids this problem

482
00:27:00,780 --> 00:27:05,010
只有部分写入出现在磁盘上的问题。
of only some subset of the writes actually showing up on disk.

483
00:27:06,800 --> 00:27:09,140
它拥有的第二个好的属性，
Second good property it has,

484
00:27:09,170 --> 00:27:10,850
它允许快速恢复。
it allows for fast recovery.

485
00:27:12,870 --> 00:27:14,250
所以在重启之后，
So after reboot,

486
00:27:14,740 --> 00:27:18,220
我们不需要做很多工作来修复文件系统，
turns out we don't actually have to do a lot of work to repair the file system,

487
00:27:18,310 --> 00:27:19,870
实际上只需要很少的工作。
actually a very minimal amount of work.

488
00:27:20,730 --> 00:27:23,520
这与其他一些解决方案形成了鲜明对比，
And this is in contrast to some other solution

489
00:27:23,520 --> 00:27:24,840
我没有说的方案，
and I'm not talking about,

490
00:27:24,840 --> 00:27:27,510
你去检查文件系统，
which is basically you go and inspect the file system,

491
00:27:27,720 --> 00:27:29,760
可能你读取文件系统的所有块，
maybe you read all the blocks of the file system

492
00:27:29,760 --> 00:27:31,200
或者读取所有 inode 块，
or read all the inode blocks,

493
00:27:31,200 --> 00:27:32,700
读取所有位图块，
read all the bitmap blocks

494
00:27:33,000 --> 00:27:34,170
所以检查，
and so check out

495
00:27:34,170 --> 00:27:36,210
文件系统是否仍处于正确的状态，
whether the file system is still in the correct shape

496
00:27:36,210 --> 00:27:37,320
或许还可以进行修复。
and maybe repair things.

497
00:27:38,260 --> 00:27:42,130
日志有这个很好的属性，恢复很快。
Logging has this nice property that actually the recovery is fast.

498
00:27:43,020 --> 00:27:47,130
最后，在原则上，它可以是非常高的性能，
And finally, it is in principle, it can be actually very high performance,

499
00:27:47,610 --> 00:27:50,670
虽然要看的这个，
although the one, you know what we're going to be looking

500
00:27:50,670 --> 00:27:52,890
在 xv6 中看到的不是高性能的，
in the context of xv6 is not high performance,

501
00:27:53,070 --> 00:27:55,140
所以我们下周要看这个，
so we're going to look at that next week,

502
00:27:55,170 --> 00:27:56,940
我们将了解如何构建一个日志系统，
we'll see actually how to build a logging system

503
00:27:56,940 --> 00:28:01,330
具有原子文件系统调用，更快的恢复和高性能，
that has atomic file system calls faster recovery and high performance,

504
00:28:01,330 --> 00:28:03,190
今天我们只关注前两个。
today we're going to be just focusing on the first two.

505
00:28:05,560 --> 00:28:06,280
好的。
Okay.

506
00:28:06,780 --> 00:28:10,590
日志的基本思想非常简单，
The basic idea of logging is actually straightforward,

507
00:28:11,330 --> 00:28:15,980
所以你要做的就是把它分成两部分，
and so basically what you do is you divide this into two pieces,

508
00:28:16,590 --> 00:28:19,350
一个是日志，一个是文件系统，
one is the log, one is the file system,

509
00:28:20,600 --> 00:28:22,760
文件系统可能比日志大得多。
and file system might be much bigger than log.

510
00:28:23,580 --> 00:28:28,050
当你需要更新文件系统时，
And when you need to update the file system,

511
00:28:28,050 --> 00:28:32,820
比如更新块 33 或者更新位图块，
so update, let's say block 33 or update the bitmap block,

512
00:28:33,360 --> 00:28:36,210
我们实际上不会更新文件系统块，
we're actually not going to update the file system blocks,

513
00:28:36,210 --> 00:28:38,940
所以我们不会直接更新位图块，
so we're not going to update bitmap block directly,

514
00:28:38,940 --> 00:28:42,240
相反，我们要在右边做的唯一一件事是，
instead the only thing we're gonna do on the right is,

515
00:28:42,540 --> 00:28:44,400
这是我们的内存，
so here's our memory,

516
00:28:44,400 --> 00:28:45,660
我们的内存中有一个块，
we have a block in memory,

517
00:28:45,960 --> 00:28:49,290
比如位图块，它是 45 ，
is say the bitmap block, it's 45

518
00:28:49,650 --> 00:28:51,480
不是把它写入 45 ，
and instead of writing it to 45,

519
00:28:51,480 --> 00:28:52,830
像平常我们做的那样，
where we normally would have done,

520
00:28:52,950 --> 00:28:55,440
我们实际上要做的是写入日志，
what we're gonna do is actually going to write into the log,

521
00:28:55,740 --> 00:28:56,910
我们把它放在这里，
we're going to stick it here

522
00:28:57,090 --> 00:28:59,730
记住它应该是 45 ，
and remember that definitely should go to 45,

523
00:29:01,160 --> 00:29:02,060
我们把它放在那里。
we will put it there.

524
00:29:02,760 --> 00:29:04,230
我们对所有其他的写入也是这样做的，
And we do that with all the other writes too,

525
00:29:04,260 --> 00:29:08,460
比如，我们将 inode 块放在这里，
so for example we'll put inode block there,

526
00:29:08,610 --> 00:29:12,150
如果我没记错的话，应该是 33 ，
you know like maybe 33 I think, if I remember correctly

527
00:29:12,450 --> 00:29:13,710
我们会把它放在这里，
and we'll stick it in there

528
00:29:13,770 --> 00:29:16,710
记住这应该是 33 。
and you know, remember that actually has to go to 33.

529
00:29:18,320 --> 00:29:21,950
所以我们要做的任何写入第一就是日志。
So basically what we do any write his first log.

530
00:29:24,660 --> 00:29:27,600
我们不会直接写入块的所在地，
And so we don't write directly to the home location of the block,

531
00:29:27,600 --> 00:29:29,970
我们只是把它放在日志里。
but we just put it always a log.

532
00:29:30,930 --> 00:29:34,140
然后，在文件系统操作完成时，
Then, at some point when the file system operation is done,

533
00:29:34,470 --> 00:29:35,520
比如，
for example as you know,

534
00:29:35,520 --> 00:29:39,540
我们在前面的幻灯片中看到的四五个写入在日志中，
these four five writes that we saw in the previous slides are in the log,

535
00:29:39,570 --> 00:29:40,710
我们就提交这些操作。
we commit the operation.

536
00:29:44,830 --> 00:29:47,140
它的意思是在日志里的某个地方，
Basically what it means is somewhere in the log,

537
00:29:47,260 --> 00:29:50,440
我们在一个固定的位置标记一个记录，
we just record a record, you know in a fixed location,

538
00:29:50,440 --> 00:29:51,130
这表示，
that basically says,

539
00:29:51,130 --> 00:29:55,450
好的，日志里有 5 个日志，
okay, well you know there are like five logs in the log,

540
00:29:55,660 --> 00:29:59,800
这就是一组写入的日志。
and that is you know the log, set of log the writes.

541
00:30:01,720 --> 00:30:05,920
然后，当我们将所有写入放在磁盘上时，
And then you know when we have all the writes stably on disk,

542
00:30:05,950 --> 00:30:09,310
我们要安装它们，被称为安装阶段。
we're going to actually install them, was called the installation phase.

543
00:30:10,470 --> 00:30:11,880
它的意思是，
And really what that means is,

544
00:30:11,970 --> 00:30:15,630
我们要把这些日志从日志移动到它们的原位置，
we're gonna move you know these logs from the log to their home location,

545
00:30:15,630 --> 00:30:17,520
我们知道这个到 45 ，
so we know this one has to go to 45,

546
00:30:17,520 --> 00:30:18,690
所以我们把它放到 45 ，
so we put it at 45,

547
00:30:18,690 --> 00:30:20,160
这个必须是 33 ，
this one has to go to 33,

548
00:30:20,250 --> 00:30:22,260
我们把它放到 33 ，以此类推。
we put it to 33, etc etc.

549
00:30:23,420 --> 00:30:24,530
一旦我们完成了，
And once we're done,

550
00:30:24,560 --> 00:30:26,360
我们就可以清理日志了，
you know basically we can clean the log

551
00:30:26,690 --> 00:30:27,920
清理日志，
and cleaning the log,

552
00:30:29,190 --> 00:30:33,240
就是重写，把这个 5 设置为 0 。
basically you're rewriting, you know basically setting this five to zero.

553
00:30:34,460 --> 00:30:37,370
这是基本的计划。
And that is a basic plan.

554
00:30:38,640 --> 00:30:39,990
为什么这个计划是好的，
And why is this plan good,

555
00:30:40,020 --> 00:30:41,190
好的，让我们想一想。
well, let's think about it.

556
00:30:41,820 --> 00:30:46,760
假设我们在这里之前崩溃，会发生什么。
Let's say we crash before here, what would happen.

557
00:30:50,900 --> 00:30:52,760
所以让我暂且不提这个问题，
So let me hold that question,

558
00:30:52,790 --> 00:30:56,060
让我在提问之前讨论一件事。
let me actually talk about one thing before asking the question.

559
00:30:57,710 --> 00:31:02,050
假设我们崩溃了，并且重新启动，
Let's say we crash and so we reboot,

560
00:31:02,470 --> 00:31:06,580
在重新启动时，文件系统做了什么，
and on the reboot, there's basically what the file system does,

561
00:31:07,280 --> 00:31:08,630
它查看提交记录，
it looks at the commit record,

562
00:31:09,900 --> 00:31:11,910
查看提交记录的值，
sees what the value of the commit record is,

563
00:31:12,330 --> 00:31:17,260
如果是 0 ，什么都不做，在我们的简单方案中。
if it is zero, you know do nothing in our simple scheme.

564
00:31:18,560 --> 00:31:20,300
如果它大于 0 ，
And if it's bigger to 0,

565
00:31:20,300 --> 00:31:22,370
我们知道日志中有一些块，
we know that there are basically blocks in the log

566
00:31:22,370 --> 00:31:24,260
需要被安装。
that need to be actually installed.

567
00:31:24,720 --> 00:31:26,940
显然我们还没有完成安装，
And we apparently didn't finish the installation,

568
00:31:27,120 --> 00:31:29,100
我们在提交之后崩溃了，
we crashed you know after the commit,

569
00:31:29,100 --> 00:31:30,540
但是在清理日志之前，
but before cleaning the log,

570
00:31:30,750 --> 00:31:32,820
所以我们重新安装，
so basically we re-install,

571
00:31:37,510 --> 00:31:39,550
重新安装之后，我们清理日志。
and after we re-install, we clean the log.

572
00:31:43,990 --> 00:31:44,710
好的?
Okay?

573
00:31:45,290 --> 00:31:47,540
而且这个方案是好的，
And this scheme is good,

574
00:31:47,930 --> 00:31:51,740
因为它确保了无论崩溃发生在哪里，
because it actually ensures that no matter where the crash happens,

575
00:31:51,830 --> 00:31:54,350
我们要么安装了所有的写入块，
we're either install all the blocks of the writes

576
00:31:54,350 --> 00:31:55,490
要么一个都没有安装，
or we install none of them,

577
00:31:55,790 --> 00:31:57,560
但是我们从来不会进入，
but we were never into,

578
00:31:57,650 --> 00:31:59,630
我们永远不会处于一种情况，
we will never end up in a situation

579
00:31:59,630 --> 00:32:02,420
我们安装了一些，而不是所有的写入。
where we installed some of the writes, but not all of them.

580
00:32:02,950 --> 00:32:04,570
为了弄清为什么这是真的，
Just to see why this is true,

581
00:32:04,570 --> 00:32:06,850
让我们来考虑几个可能崩溃的情况。
let's consider a couple cases where things could crash.

582
00:32:07,930 --> 00:32:10,900
所以在一到二之间崩溃，会发生什么，
So things could crash and between one and two, what will happen,

583
00:32:16,660 --> 00:32:18,550
我们会到达什么情况。
in what situation do we end up.

584
00:32:23,020 --> 00:32:25,990
在恢复过程中，我们什么都不做，
Situation in which on recovery, we do nothing

585
00:32:25,990 --> 00:32:30,720
这是可以的，因为没有任何内容写入文件系统。
and that's okay, because nothing has been written to the file system.

586
00:32:31,590 --> 00:32:32,670
是的，就是这样，
Yeah exactly,

587
00:32:32,670 --> 00:32:36,120
所以这就是我们什么都不做的情况，
so this is the case where basically we we just do nothing,

588
00:32:36,270 --> 00:32:39,030
就像这个系统调用没有执行一样，
you know as if the system call basically never executed,

589
00:32:39,150 --> 00:32:41,760
因为如果故障发生得稍早一点，
because if the failure happened slightly earlier,

590
00:32:41,760 --> 00:32:43,590
在文件系统调用开始之前。
right, before the file system calls started.

591
00:32:44,240 --> 00:32:46,250
所以这完全没问题，这是可以接受的。
And so that's perfectly okay, that's acceptable.

592
00:32:47,040 --> 00:32:55,730
好的，如果我们在提交之后安装之前崩溃会怎么样？
Okay, what happens, if we crash, okay, between after committing before being installed?

593
00:32:58,310 --> 00:33:00,320
然后，你只需要重做所有安装，
Then you'll just redo all the installs,

594
00:33:00,320 --> 00:33:02,270
这样就可以恢复到正确的状态。
so you'll kind of restore the correct state.

595
00:33:02,870 --> 00:33:04,190
是啊，确实如此，
Yeah, so exactly,

596
00:33:04,190 --> 00:33:05,090
在这一点上，
so at that point correct,

597
00:33:05,090 --> 00:33:09,110
我们知道所有数据块都在日志中，
we have, we know there are all the blocks are in the log

598
00:33:09,140 --> 00:33:11,180
它们都会被写下来，因为我们提交了，
and they'll be all written, because we committed,

599
00:33:11,270 --> 00:33:14,030
所以，它是整个文件系统操作完成的情况。
so it must be the case that the whole file system operation finished.

600
00:33:14,630 --> 00:33:17,660
所以我们可以把它们放到它们应该在的位置。
So we can basically put them in their location where they should be.

601
00:33:18,760 --> 00:33:20,380
然后我们都处于好的状态，
And then we're all in good shape

602
00:33:20,380 --> 00:33:22,120
所以在这种情况下，所有文件，
and so in this case now all the file,

603
00:33:22,120 --> 00:33:25,250
在这种情况下，就像，
in this case will end up as if the,

604
00:33:25,940 --> 00:33:30,200
就像文件系统调用在崩溃之前完成，
it is if the file system call actually completely just before the crash,

605
00:33:30,260 --> 00:33:31,400
没有什么区别。
there's no difference.

606
00:33:32,280 --> 00:33:32,880
好的？
Okay?

607
00:33:33,820 --> 00:33:36,670
那么，如果在安装过程中崩溃会发生什么，
So what happens if we crash during install

608
00:33:36,700 --> 00:33:39,310
或在清理之前安装过程中，
or like install during install before cleaning,

609
00:33:39,930 --> 00:33:40,770
在这里崩溃。
crash here.

610
00:33:41,070 --> 00:33:42,030
在这种情况下，
In this case,

611
00:33:42,270 --> 00:33:42,990
在这种情况下，
in this case

612
00:33:42,990 --> 00:33:44,190
我要做第三种情况，
and I will do the third case,

613
00:33:44,550 --> 00:33:48,660
我们安装，在安装过程中，或者在安装之前，
we'll install, during installation, or just before install,

614
00:33:48,690 --> 00:33:50,700
在安装之后清理之前。
after installing before cleaning.

615
00:33:51,620 --> 00:33:53,690
然后会发生什么？
What, what what, what happened then?

616
00:33:55,420 --> 00:33:56,860
在。
On the.

617
00:33:58,110 --> 00:34:00,660
哦，抱歉，在下次重启时，
Oh, sorry, on the next restart,

618
00:34:00,690 --> 00:34:03,180
什么都没有改变，
nothing has really changed,

619
00:34:03,180 --> 00:34:04,950
除了恢复进程，
in terms of the recovery process

620
00:34:05,130 --> 00:34:07,380
我们只是重做日志。
and so we're just going to redo the log.

621
00:34:07,680 --> 00:34:08,970
我们要重做一次日志，
We're going to redo the log again

622
00:34:08,970 --> 00:34:13,770
我们要把内容再复制一遍到各个位置，
and we're gonna copy basically the content again you know to the locations right maybe,

623
00:34:13,860 --> 00:34:15,390
我们可能要做多次，
in fact we might do it multiple times,

624
00:34:15,970 --> 00:34:16,720
这可以吗？
is that okay?

625
00:34:24,410 --> 00:34:27,710
是的，因为这些都是写入，
Yes, because those are just writes,

626
00:34:28,490 --> 00:34:33,650
它们在我们没有改变的特定位置，
and it's, they are to a specific location that we don't change,

627
00:34:33,650 --> 00:34:35,000
就像写入日志里的那样，
like it's written in the log,

628
00:34:35,000 --> 00:34:38,060
所以我们知道每次应该写在哪里。
so we know where we should write every time.

629
00:34:38,670 --> 00:34:40,710
是的，每次我们写的都一样的，
Yeah basically every time we do the same write, correct,

630
00:34:40,710 --> 00:34:43,860
假设在块 45 中，它的值是 10 ，
so let's say in block 45, you know there's the value 10,

631
00:34:44,570 --> 00:34:47,570
我们每次都在 45 位置写入 10
and we're going to write 10 at location 45 every time

632
00:34:48,050 --> 00:34:49,280
这正是它应该的，
and that's exactly what it should be

633
00:34:49,370 --> 00:34:53,090
而且多次重复写也不会有什么坏处。
and repeating that write multiple times doesn't really do any harm, right.

634
00:34:54,160 --> 00:34:55,600
因为我们写的是相同的值，
Because we're writing the same value,

635
00:34:55,630 --> 00:34:56,920
它就应该在那里。
that actually should be there anyway.

636
00:34:57,720 --> 00:34:59,100
所以这很好，
And so it's perfectly fine,

637
00:34:59,100 --> 00:35:01,590
我们可以多次重新安装。
for us to do re-installation multiple times.

638
00:35:03,440 --> 00:35:06,590
当然，在这个时间点，我们不应该执行任何其他文件系统调用，
Of course, we shouldn't serve any other file system calls at this particular point of time,

639
00:35:06,590 --> 00:35:09,080
我们应该在重新启动文件系统之前执行此操作，
we should do this before we restart the file system,

640
00:35:09,560 --> 00:35:13,610
但是，在恢复期间重新启动时，
but while you know what during reboot during recovery,

641
00:35:13,610 --> 00:35:14,990
我们可以这样做。
you know we can just do this, right.

642
00:35:16,080 --> 00:35:19,260
也就是说，安装是幂等的，
Another way of saying, that is that installation is basically idempotent,

643
00:35:19,290 --> 00:35:21,210
你可以多次执行它，
you can just execute it many many times

644
00:35:21,450 --> 00:35:23,580
并产生相同的效果。
and will have the same effect yet.

645
00:35:25,780 --> 00:35:28,210
关于这个的问题？
Question about that?

646
00:35:29,720 --> 00:35:32,060
因为接口只是读和写，
Because the interface is just read and write,

647
00:35:32,060 --> 00:35:36,260
如果我们有追加，这就不安全了，对吧？
if we had an append, this would not be safe, right?

648
00:35:36,980 --> 00:35:39,080
是的，这个[]，
Yeah yeah, this [],

649
00:35:39,110 --> 00:35:40,610
你也可以使追加变得安全，
you can make append safe too,

650
00:35:40,610 --> 00:35:42,710
一种更复杂的日志方案，
a more fancy logging schemes,

651
00:35:42,710 --> 00:35:44,120
但是对于这个的日志方案，
but for this particular logging scheme,

652
00:35:44,120 --> 00:35:45,410
我们不必担心这个。
we don't have to worry about that.

653
00:35:46,620 --> 00:35:49,800
在某种意义上，追加是文件系统级操作，
In fact, in some sense, the append is file system level operation

654
00:35:49,890 --> 00:35:53,310
在这个层面上，我们可以将其作为主题，
and at that level we can make it a topic

655
00:35:53,310 --> 00:35:56,590
使用我们在这里的日志方案。
using the logging scheme, that we're, what we have here.

656
00:35:58,280 --> 00:35:59,360
我明白了，谢谢。
I see, thank you.

657
00:35:59,940 --> 00:36:00,960
我也有一个问题，
I also have a question,

658
00:36:01,560 --> 00:36:05,400
如果在提交时文件系统崩溃，会发生什么情况，
what would happen if the file system crashed while you are committing,

659
00:36:05,400 --> 00:36:07,800
你希望执行多个写入，
so you want to execute multiple writes

660
00:36:08,100 --> 00:36:10,110
然后你只提交其中的一半。
and then you only commit like half of them.

661
00:36:11,480 --> 00:36:13,190
好的，你能说大声点吗，
Yeah okay, so can you speak up a little bit more,

662
00:36:13,190 --> 00:36:14,540
因为你的声音太小了。
because your volume is low.

663
00:36:14,630 --> 00:36:15,470
哦，是的，抱歉，
Oh, yeah sorry,

664
00:36:15,740 --> 00:36:20,810
如果你想一次提交多个写入，
so if you wanted to like commit multiple writes at once,

665
00:36:20,810 --> 00:36:22,100
比如以原子方式，
like in an atomic way,

666
00:36:22,130 --> 00:36:25,700
但是你的系统在提交的过程中崩溃了，
but your system crashes in the middle of committing,

667
00:36:25,700 --> 00:36:28,820
所以你只能提交一半的写入，
so you are only able to commit like half of the writes,

668
00:36:28,970 --> 00:36:30,890
在那种情况下会发生什么？
what would happen in that instance?

669
00:36:31,070 --> 00:36:32,990
好的，有一点很重要，
Okay, so there's a very important point,

670
00:36:32,990 --> 00:36:34,160
我很高兴你问了这个问题。
I'm glad you ask the question.

671
00:36:34,190 --> 00:36:35,270
所以首先，
So first of all,

672
00:36:35,640 --> 00:36:40,320
你提交，提交操作在这里，
the the you commit, in writing this commit operation here, correct,

673
00:36:40,320 --> 00:36:41,610
这是第二步，
this you know step two,

674
00:36:41,940 --> 00:36:43,830
你提交这些操作，
you only execute that commit operation

675
00:36:43,860 --> 00:36:45,750
只在你已经记录了所有写入后，
after you've already logged all the writes,

676
00:36:45,750 --> 00:36:47,670
你打算执行，对吧。
that you were planning to execute, right.

677
00:36:48,660 --> 00:36:50,340
所以，在你提交时，
So at the point you do to commit,

678
00:36:50,490 --> 00:36:51,900
所有写入都在日志中。
all the writes are in the log.

679
00:36:53,320 --> 00:36:56,280
因此，提交操作本身
And so, the commit operation itself

680
00:36:56,310 --> 00:36:58,380
是一个有趣的问题，在那里发生了什么。
is an interesting question, what happens there.

681
00:36:58,620 --> 00:37:02,220
所以，我在幻灯片上标出，
So, the way the way I indicated this on slide,

682
00:37:02,220 --> 00:37:04,680
提交操作写入一个块，
like commit operation writes a single block,

683
00:37:05,210 --> 00:37:06,860
磁盘中的一个扇区。
like a single sector on the disk.

684
00:37:07,360 --> 00:37:11,200
文件系统的标准假设是
And the standard assumption that file systems make is that

685
00:37:11,200 --> 00:37:16,310
单个块写入或单个扇区写入是*原子*操作。
a single block write or single sector write is an atomic operation.

686
00:37:17,060 --> 00:37:18,980
这意味着如果你写入它，
Meaning that if you write it,

687
00:37:19,010 --> 00:37:22,010
将写入整个扇区，或者任何扇区都不写入。
the whole sector will be written, or none of the sector will be written.

688
00:37:22,010 --> 00:37:23,900
所以，扇区永远不会被部分写入。
So the sector will never be written partially.

689
00:37:24,940 --> 00:37:28,690
所以在特定扇区总是有效数据，
And so there's always you know clearly you know valid data in that particular sector

690
00:37:28,990 --> 00:37:33,220
所以这个提交操作写入日志头，
and so basically this operation that commit operation writing the log header,

691
00:37:33,580 --> 00:37:37,120
写入提交记录是真正的提交操作，
is writing the commit record is the real commit operation,

692
00:37:37,420 --> 00:37:42,010
如果成功，并且提交头中是 5 ，
if that succeeds, and there's basically say of five in the commit header,

693
00:37:42,160 --> 00:37:45,430
我们知道日志中有 5 个块，
you know we know that there are five blocks in the log

694
00:37:45,430 --> 00:37:47,380
我们必须重新安装这 5 个块。
and we have to reinstall those five blocks.

695
00:37:48,600 --> 00:37:51,180
如果提交头没有到达磁盘，
If the commit header didn't make it to disk,

696
00:37:51,540 --> 00:37:53,550
则该值仍为 0 ，
then the value will still be 0

697
00:37:53,940 --> 00:37:56,250
我们就当那个事务从未发生过。
and we'll just treat it as if that transaction never happened.

698
00:37:59,010 --> 00:37:59,670
谢谢。
Thank you.

699
00:38:00,300 --> 00:38:03,360
你提到的关键规则，
And the key rule that you're sort of hinting at,

700
00:38:03,420 --> 00:38:05,610
那必须是真的，
that has to be true,

701
00:38:05,700 --> 00:38:07,680
是所谓的预写规则，
is something what's called the write-ahead rule,

702
00:38:08,070 --> 00:38:12,090
意味着日志系统不能安装写入，
which means that a logging system cannot install writes,

703
00:38:12,150 --> 00:38:15,750
直到所有写入到日志中。
until all the writes into, are into log.

704
00:38:20,000 --> 00:38:22,430
关于这个基本方案，有什么问题吗？
Any more questions about this sort of basic plan?

705
00:38:28,770 --> 00:38:29,430
好的？
Okay?

706
00:38:36,530 --> 00:38:37,040
让我们看看。
Let's see.

707
00:38:42,300 --> 00:38:43,770
所以我想，
So what I want to,

708
00:38:44,730 --> 00:38:47,910
有很多不同版本的日志方案，
there are many many different versions of logging schemes

709
00:38:47,910 --> 00:38:50,340
我在这里画了一个非常简单的图，
and I sketched out here a very simple one,

710
00:38:50,640 --> 00:38:52,470
这完全没问题。
you know it's perfectly fine.

711
00:38:52,470 --> 00:38:56,130
有些方案是推迟清理日志，
You know there schemes where basically the cleaning of the log is postponed,

712
00:38:56,430 --> 00:38:58,680
安装被推迟，
installation is postponed until later,

713
00:38:58,860 --> 00:39:02,790
但我将运行这个非常简单的方案，
but I'm going to run sort of this very simple scheme,

714
00:39:03,000 --> 00:39:07,050
下周我们将看到更复杂的日志协议。
and then next week we'll see more sophisticated logging protocols.

715
00:39:07,480 --> 00:39:09,850
但是所有那些记录协议，都遵循这个预写规则，
But all those logging protocols, follow this write-ahead rule,

716
00:39:09,850 --> 00:39:12,190
在你准备提交记录之前，
that before you're ready to commit record,

717
00:39:12,400 --> 00:39:16,150
你必须确保所有写入都在日志中。
you have to make sure that all the writes are in the log.

718
00:39:18,950 --> 00:39:20,570
但是这里面有很多东西，
But then there's a lot of within that,

719
00:39:20,570 --> 00:39:22,190
尽管如此，仍有很大的灵活性，
still there's a ton of flexibility

720
00:39:22,190 --> 00:39:26,330
在设计特定日志协议方面。
in designing a particular logging protocols typically called.

721
00:39:27,460 --> 00:39:29,470
好的，我来看一下，
Okay, I'm gonna look a little bit,

722
00:39:29,500 --> 00:39:32,740
这是如何在 xv6 中表现出来的，
how this then is manifest itself in xv6,

723
00:39:32,740 --> 00:39:35,290
作为一个案例研究，让事情变得更具体。
you know as a case study and to make things really concrete.

724
00:39:40,000 --> 00:39:41,890
好的，在 xv6 中，
Okay, so in xv6, there's sort of,

725
00:39:42,250 --> 00:39:45,400
你会看到两种类型的[]，
you're going to look at two sort of piece of [] you will,

726
00:39:45,550 --> 00:39:47,170
在磁盘上的东西，
the stuff that is actually on disk,

727
00:39:48,080 --> 00:39:50,540
和在内存中的东西，
and that's you know things that are in memory,

728
00:39:55,220 --> 00:39:57,230
在内存中的内容会丢失，
in-memory contents will disappear,

729
00:39:57,230 --> 00:39:59,000
在此过程中，我们应该考虑的是，
on the way we should think about it is that

730
00:39:59,000 --> 00:40:02,450
内存中的内容会在崩溃或断电时消失。
in-memory content will disappear on a crash or power failure.

731
00:40:04,660 --> 00:40:12,010
xv6 日志的结构一直都非常简单，
And the structure of the xv6 log as always pretty simple,

732
00:40:12,600 --> 00:40:17,430
我们在开头有一个块， header 块，
there's actually, we have one block in the beginning, the header block,

733
00:40:18,020 --> 00:40:19,670
这就是我们的提交记录，
and that's basically our commit record,

734
00:40:19,670 --> 00:40:22,350
它包含数字 n ，
you know it contains the number n,

735
00:40:22,350 --> 00:40:24,390
就是日志中的块数，
which is like the number of blocks in the log

736
00:40:24,600 --> 00:40:25,920
然后对于每个块，
and then for each block,

737
00:40:28,280 --> 00:40:33,230
块编号，那个块的所在位置，等等，
the block number, the home location of that block, blah blah blah,

738
00:40:33,230 --> 00:40:34,310
将会是其中的任何一个。
are going to be any of those.

739
00:40:37,960 --> 00:40:40,210
所以，在日志本身中
And so, then in the log itself

740
00:40:40,210 --> 00:40:43,180
是属于它的数据，
are basically is the data, that it belongs to that,

741
00:40:43,180 --> 00:40:46,480
所以，这是 bn0 的数据，
so here is the data of bn0,

742
00:40:46,660 --> 00:40:49,690
这是 bn1 的数据，等等，
here's the data of bn1, etc,

743
00:40:50,210 --> 00:40:52,490
到 bn-1 ，
to bn-1,

744
00:40:54,460 --> 00:40:55,930
这就是日志里的内容。
so that's what's in the log.

745
00:40:56,340 --> 00:40:58,620
所以在日志中只有一个东西，
And there's the only thing, that's sort of in the log,

746
00:40:58,650 --> 00:40:59,700
没有更多的了。
there's nothing more to it.

747
00:41:00,600 --> 00:41:03,870
然后在内存中，当文件系统运行时，
Then in memory where, while the file systems running,

748
00:41:03,870 --> 00:41:07,620
有一个 header 的拷贝版本在内存中，
there's an in copy version in-memory version of the header,

749
00:41:09,390 --> 00:41:11,370
它有 n ，
and it basically has n

750
00:41:11,400 --> 00:41:18,490
它有块编号数组，等等。
and it has array of block numbers, etc.

751
00:41:19,000 --> 00:41:22,150
然后这些块编号
And then you know these block numbers

752
00:41:22,420 --> 00:41:26,140
指向的是位于数据中的块，
refer to block that are sitting in the data,

753
00:41:26,170 --> 00:41:28,960
与块编号相对应，
that actually corresponds to the block numbers

754
00:41:28,960 --> 00:41:31,180
位于内存中数据结构中，
that are sort of sitting in this in-memory data structure,

755
00:41:31,240 --> 00:41:33,160
它们在块缓存中，
they live in the block cache,

756
00:41:33,820 --> 00:41:36,160
现在你已经很熟悉了。
which you know, but now you're well familiar with.

757
00:41:36,760 --> 00:41:38,800
所以，也许这是块 10 ，
And so, maybe this is like block 10,

758
00:41:38,800 --> 00:41:41,740
是日志中的第一个块，
is the first block in the log,

759
00:41:41,740 --> 00:41:44,140
或者让我举一个更具体的例子，
or maybe let me take a more concrete example,

760
00:41:44,140 --> 00:41:46,390
从我们之前的东西来看，
from that lines up with our previous things,

761
00:41:46,390 --> 00:41:48,130
也许这是 45 ，
maybe this is like 45,

762
00:41:49,440 --> 00:41:52,110
在缓存中的某个地方，
and basically you know somewhere in the in cache,

763
00:41:52,290 --> 00:41:53,010
块缓存，
the block cache,

764
00:41:53,010 --> 00:41:55,470
这里是块 45 ，
there's of course whatever block 45,

765
00:41:55,830 --> 00:41:56,610
这是数据。
here is data.

766
00:41:56,880 --> 00:41:57,510
好的？
Okay?

767
00:41:58,200 --> 00:41:59,430
这是一种结构，
That's sort of the structures,

768
00:41:59,580 --> 00:42:06,790
内存中的文件系统所具有的，
that the on-disk in-memory file system has

769
00:42:06,790 --> 00:42:08,620
和在磁盘上的文件系统所具有的，
and on-disk file system has,

770
00:42:08,620 --> 00:42:10,240
在磁盘上的文件系统只有日志，
on-disk file system just has the log,

771
00:42:10,390 --> 00:42:12,160
在内存中含有数据结构
the in-memory has these data structures

772
00:42:12,160 --> 00:42:15,850
用来协调这些将要执行的多次写入操作。
to orchestrate these multi write operations that were going to be doing.

773
00:42:17,080 --> 00:42:17,740
好的？
Okay?

774
00:42:20,240 --> 00:42:23,360
所以，为了更具体一点，
So, to make this a little more concrete,

775
00:42:23,360 --> 00:42:24,620
让我们来看一些代码。
let's look at some code.

776
00:42:25,740 --> 00:42:30,030
这将帮助我们了解一切是如何运行的。
Then that will help us understand how everything works.

777
00:42:33,580 --> 00:42:37,640
所以让我调出一些代码。
So let me pull up some code.

778
00:42:38,350 --> 00:42:39,970
好的，让我把这个放在它旁边，
Okay, let me put this next to it,

779
00:42:40,890 --> 00:42:42,960
我们保留着那张图片，
we keep that picture,

780
00:42:42,960 --> 00:42:45,420
这样我们想看就可以看看，
so that we can look at if we want to

781
00:42:45,420 --> 00:42:47,490
或者我可以指向它。
or I can point to it.

782
00:42:48,490 --> 00:42:49,600
每个人都能看到我的代码吗？
Can everybody see my code?

783
00:42:54,410 --> 00:42:57,920
要有人确认他们看到了 emacs 窗口。
Somebody have to confirmed they seen emacs window.

784
00:42:58,130 --> 00:42:59,450
是的，我们可以看到它。
Yeah we can see it.

785
00:42:59,450 --> 00:42:59,660
好的。
Good.

786
00:43:00,380 --> 00:43:01,280
它够大吗？
Is it big enough?

787
00:43:04,080 --> 00:43:05,190
我觉得挺好的。
I think it's good.

788
00:43:05,520 --> 00:43:05,790
好的。
Okay.

789
00:43:05,790 --> 00:43:06,570
看起来不错。
That looks good.

790
00:43:07,140 --> 00:43:07,800
谢谢。
Thank you.

791
00:43:08,440 --> 00:43:10,870
好的，让我们开始，
Okay, so let's start with,

792
00:43:11,230 --> 00:43:13,150
我谈到了事务，
you know I I talked about transactions,

793
00:43:13,150 --> 00:43:19,030
我们不应该提交，直到，
where you you know the fact that you know we should not commit until,

794
00:43:19,060 --> 00:43:21,610
我们不应该提交一次写入，直到所有的写入都完成了。
we should not write to commit a [], until all the writes have done.

795
00:43:22,420 --> 00:43:24,580
所以，这意味着，
And so this means that you should

796
00:43:24,580 --> 00:43:27,220
文件系统操作必须指明
file system operations must indicates

797
00:43:27,220 --> 00:43:28,780
事务的开始是什么，
what the beginning of transaction is

798
00:43:28,780 --> 00:43:30,730
以及事务的结束是什么。
and particularly at the end of the transaction is.

799
00:43:31,340 --> 00:43:33,770
在 xv6 中发生的方式是，
And the way that happens in xv6,

800
00:43:33,770 --> 00:43:35,510
每个文件系统调用，
that every file system call,

801
00:43:36,640 --> 00:43:39,070
这里的 open 对应于 create ，
here's open corresponds to create,

802
00:43:39,070 --> 00:43:40,960
以 begin_op 开始，
basically starts with begin_op

803
00:43:41,020 --> 00:43:44,050
begin_op 表示，开始一个事务，
and begin_op indicates like, okay I want to start a transaction

804
00:43:44,260 --> 00:43:45,760
我希望所有的块写入，
and I want all the block writes

805
00:43:45,760 --> 00:43:48,250
我在 begin_op 和 end_op 之间说做的，
that I've been doing between begin_op and end_op

806
00:43:48,250 --> 00:43:50,260
end_op 是事务的结束，
which is basically the end of the transaction

807
00:43:50,620 --> 00:43:51,400
这些之间的写入操作都是原子的，
to be atomic,

808
00:43:51,490 --> 00:43:54,400
意味着它们全都应用或全不应用。
meaning they should be all applied to, or none of them should applied.

809
00:43:54,940 --> 00:43:55,420
好的？
Okay?

810
00:43:55,810 --> 00:44:01,060
所以，每个 xv6 中的文件系统调用都有这样的结构，
So every file system call in xv6 has that structure,

811
00:44:01,120 --> 00:44:02,530
有 begin_op ，
basically has begin_op,

812
00:44:02,560 --> 00:44:05,020
然后是实现文件系统调用的代码，
then the code and implements the file system call

813
00:44:05,020 --> 00:44:05,830
然后是 end_op 。
and then end_op.

814
00:44:07,080 --> 00:44:09,690
而 end_op 就是提交操作发生的地方。
And that end_op is basically where the commit operation happens.

815
00:44:10,430 --> 00:44:13,220
所以，在 begin_op 和 end_op 之间，
So basically between begin_op and end_op,

816
00:44:13,670 --> 00:44:16,730
磁盘上或内存中数据结构应该更新，
on-disk or in-memory data structure should be updated,

817
00:44:16,730 --> 00:44:18,980
无论内存中日志更新，
whenever the in-memory log may be updated,

818
00:44:18,980 --> 00:44:21,020
或者块缓存可能更新，
the block cache might be updated,

819
00:44:21,020 --> 00:44:24,020
但是在 end_op 之前什么都不会发生，
but nothing really happens until end_op

820
00:44:24,230 --> 00:44:25,310
然后在 end_op 时，
and then end_op time,

821
00:44:25,310 --> 00:44:27,890
我们把东西放到日志中，
we're basically going to put things into the log

822
00:44:28,130 --> 00:44:31,670
然后我们完成了把所有的东西放到日志中，
and then we are done with putting everything in the log,

823
00:44:31,760 --> 00:44:34,700
将写入提交记录或日志头。
will actually you know write to commit record or log header.

824
00:44:36,030 --> 00:44:36,630
好的？
Okay?

825
00:44:37,180 --> 00:44:37,570
那我们开始吧。
So let's.

826
00:44:39,280 --> 00:44:40,210
所以有趣的是，
So what is interesting,

827
00:44:40,210 --> 00:44:42,340
当然，每一次写入，
of course what happens is every write, correctly,

828
00:44:42,340 --> 00:44:45,640
当文件系统调用执行一次磁盘写入时，
whenever one of these file system calls does a disk write,

829
00:44:45,970 --> 00:44:48,610
一些事情一定会发生，
you know something must happen,

830
00:44:48,640 --> 00:44:52,870
所以如果我们回到 fs.c ，
so if we go back for example to fs.c,

831
00:44:52,870 --> 00:44:54,130
查看 ialloc ，
you know look at ialloc,

832
00:44:54,580 --> 00:44:56,980
ialloc 调用，
ialloc basically what it calls,

833
00:44:56,980 --> 00:44:59,530
它没有直接调用 bwrite ，
it doesn't call bwrite directly,

834
00:44:59,830 --> 00:45:03,160
而是调用了 log_write 。
but it actually calls a log_write.

835
00:45:04,250 --> 00:45:06,320
我们将了解 log_write 的作用，
And so we're going to see what log_write does,

836
00:45:06,590 --> 00:45:10,430
log_write 是日志系统实现的功能，
log_write is basically a function implemented by logging system,

837
00:45:10,610 --> 00:45:11,600
每个写入，
and every write

838
00:45:11,630 --> 00:45:14,720
在 begin_op 和 end_op 之间的文件系统调用，
basically a file system call dose between begin_op and end_op,

839
00:45:14,990 --> 00:45:16,640
总是通过 log_write 。
always goes through log_write.

840
00:45:23,350 --> 00:45:24,490
所以这里是 log_write ，
So here's log_write

841
00:45:24,490 --> 00:45:29,320
log_write 实际上相当简单。
and log_write actually reasonable straightforward.

842
00:45:29,900 --> 00:45:34,700
是的，我们写入块，在块缓存中，
Yeah, you know we've written the block, in the block cache,

843
00:45:34,730 --> 00:45:38,480
某个地方 45 ，也许是写入到 45 ，
so somewhere basically 45, maybe this is like the write to 45,

844
00:45:38,720 --> 00:45:42,590
我们已经更新了块缓存中的 45 ，
we've updated you know 45 in the block cache,

845
00:45:42,740 --> 00:45:45,890
现在我们记录在内存中的数据结构中，
now we basically record in the in-memory data structures,

846
00:45:45,890 --> 00:45:47,990
稍后，在提交的时候，
that at some point later, at commit point,

847
00:45:48,200 --> 00:45:50,720
我们能够将日志写入日志。
we were able to write this log into log.

848
00:45:51,430 --> 00:45:54,040
所以，你知道代码是，
And so you know basically you know the code is,

849
00:45:54,280 --> 00:45:54,730
糟糕，
oops,

850
00:45:55,480 --> 00:45:57,040
代码相当简单，
the code is reasonably straightforward,

851
00:45:57,340 --> 00:46:00,640
它获取日志头的锁，
it acquired a lock on the header

852
00:46:00,850 --> 00:46:03,310
并更新日志头，
and basically updates the header,

853
00:46:04,100 --> 00:46:09,890
它说做的是更新 n ，
in particular, what does goes through you know the updates n,

854
00:46:09,890 --> 00:46:11,600
所做的第一件事是，
and when actually the first thing it does,

855
00:46:11,600 --> 00:46:15,410
如果已经有一份 45 的拷贝，
it actually sees if there's already a copy of 45 in the,

856
00:46:16,420 --> 00:46:20,410
如果 45 已经被记录为必须写入，
if 45 is already recorded as being having to write to written to,

857
00:46:20,740 --> 00:46:21,550
如果是这样情况，
and if that's the case,

858
00:46:21,550 --> 00:46:24,040
什么都不用做，因为会写入到 45 。
nothing has to be done, because 45 will be written to.

859
00:46:24,750 --> 00:46:26,100
这样我们就完成了，
And so we're done,

860
00:46:26,370 --> 00:46:28,020
有时称为日志[吸收]。
sometimes called log absorption.

861
00:46:30,980 --> 00:46:35,240
如果快 45 不在数组中，
If you know block 45 is not in the array yet

862
00:46:35,240 --> 00:46:38,990
或者不在块列表或块数组中，
or not in the the list of blocks or the array of blocks,

863
00:46:38,990 --> 00:46:40,640
需要写入磁盘，
that needs to be written to disk,

864
00:46:40,730 --> 00:46:44,900
那么这段代码所做的事就是，
then basically you know the only thing, this particular piece of code does is

865
00:46:44,900 --> 00:46:48,710
增加并将需要写入的块编号放入
basically bump up and stick that block number that needs to be written

866
00:46:48,710 --> 00:46:51,710
下一个条目或这个条目。
into the next entry or into that entry.

867
00:46:53,210 --> 00:46:54,440
然后它做的另一件事，
Then the only other thing it does

868
00:46:54,440 --> 00:46:55,730
我稍后会谈到，
and I'll talk about this later,

869
00:46:55,970 --> 00:47:00,020
它将把块放入缓冲区缓存中，
it will pin the block in the buffer cache

870
00:47:00,260 --> 00:47:03,620
让我把原因推迟一会，
and let me postpone why a little while,

871
00:47:03,650 --> 00:47:05,180
我稍后会再谈这个问题。
but I will come back to that later,

872
00:47:06,560 --> 00:47:08,360
这就是 log_write 所做的全部工作，
and that's actually all that log_write there doing.

873
00:47:08,480 --> 00:47:12,440
所以，每个需要更新块的文件系统调用，
So every file system call that needs to update a block,

874
00:47:12,470 --> 00:47:14,120
更新块缓存中的块，
updates the block in the block cache

875
00:47:14,150 --> 00:47:19,130
它会将它附加到内存中的数据结构中，
and it basically it appends it to this in-memory data structure,

876
00:47:19,130 --> 00:47:21,050
除非它已经在那里了，
unless you know it's already there,

877
00:47:21,140 --> 00:47:22,820
在这种情况下，只需要吸收它。
in which case you know just absorbs it.

878
00:47:24,630 --> 00:47:25,380
这能理解吗？
Does that make sense?

879
00:47:29,190 --> 00:47:33,900
那么是否意味着 bwrite 根本不应该单独使用？
So does it mean that bwrite shouldn't be used by itself at all?

880
00:47:34,200 --> 00:47:35,160
抱歉，请再说一遍。
Sorry, say again.

881
00:47:35,760 --> 00:47:39,780
bwrite 不应该单独使用，只能用作。
bwrite shouldn't be used by itself, only as.

882
00:47:39,930 --> 00:47:41,640
是的，没错，
Yes that's correct,

883
00:47:41,820 --> 00:47:43,950
一种考虑的方式是，
basically all you, one way to think about is

884
00:47:43,950 --> 00:47:47,640
在文件系统中的每个 bwrite 都被 log_write 替换。
that every bwrite in the file system is replaced by log_write.

885
00:47:53,820 --> 00:47:58,410
好的，现在我们看看 end_op 发生了什么，
Okay, so now let's see what actually happens at end_op,

886
00:47:58,410 --> 00:48:01,170
因为那是令人兴奋的部分。
because that's where the exciting part happens.

887
00:48:02,160 --> 00:48:08,400
有几个案例我暂时不谈，
And there's a couple of cases that I just wanna avoid talking about,

888
00:48:08,400 --> 00:48:09,240
稍等一会，
a little bit later,

889
00:48:09,270 --> 00:48:13,980
因为即使是这个简单的日志系统也有一些微妙的复杂性，
because they even this simple logging system actually has some subtle complexities

890
00:48:13,980 --> 00:48:17,580
这些代码的大多数开头涉及到这些微妙的复杂性。
and most of the [beginning] of this code deals with these subtle complexities.

891
00:48:18,090 --> 00:48:20,550
但是如果你想得到一个正常的情况，
But if you want to get a normal case,

892
00:48:20,550 --> 00:48:22,350
有一个简单的情况，
you know there's or there's the simple case

893
00:48:22,350 --> 00:48:25,890
没有其他文件系统操作正在进行，
where no other file system operations are in progress,

894
00:48:26,160 --> 00:48:28,560
我们正在执行创建文件，
we are executing create file

895
00:48:28,620 --> 00:48:31,260
我们已经快到可以提交的地方。
and basically we're getting to the point where we want to commit.

896
00:48:31,940 --> 00:48:36,050
因此代码非常简单并调用 commit ，
And so the code is pretty straightforward and calls commit,

897
00:48:36,890 --> 00:48:38,090
所以让我们来看一下 commit 。
so let's look at the commit.

898
00:48:41,680 --> 00:48:42,550
这里是 commit ，
So here's commit,

899
00:48:43,140 --> 00:48:47,340
[] commit 执行写入日志的步骤，
[] commit does to basically steps basically writes the log,

900
00:48:48,140 --> 00:48:52,500
写入所有这些块编号，
that's basically writing all these, all these block numbers,

901
00:48:52,500 --> 00:48:55,740
它们位于内存 header 中，
that are sitting you know in the in-memory header,

902
00:48:55,920 --> 00:48:58,560
将它们全部写入磁盘上的 header ，
writes them basically all to the header on disk,

903
00:48:58,770 --> 00:49:00,480
包括数字 n 。
including you know there's number n.

904
00:49:02,360 --> 00:49:03,920
好的，让我们看看，
Right, and so let's see,

905
00:49:04,340 --> 00:49:06,890
这是 write_head 所做的，抱歉，
that is that's what write_head does, sorry,

906
00:49:07,440 --> 00:49:10,230
write_log 写入块
write_log basically writes you know the blocks

907
00:49:10,230 --> 00:49:15,780
从缓冲区缓存到它们各自的日志中。
from the buffer cache into their respective into the log itself.

908
00:49:16,280 --> 00:49:18,830
让我们看看上面的 write_log ，
So let's see write_log, right above here,

909
00:49:19,640 --> 00:49:21,440
看它是怎么做的，
you see what it does,

910
00:49:21,470 --> 00:49:24,770
它检查这个数组，一次一个，
it goes through you know this array one at a time

911
00:49:25,100 --> 00:49:30,810
并且写到日志中的日志位置。
and basically writes that to the log position in the log.

912
00:49:31,500 --> 00:49:36,050
好的，读日志块，然后把它放进去，
Okay, so read you know the log block, then sticks it in there,

913
00:49:36,290 --> 00:49:39,560
复制它，然后把它写入磁盘。
by copying it, and then writing it actually out to the disk.

914
00:49:40,880 --> 00:49:43,970
所以这保证日志 45 在这里，
So this basically ensures that log 45 laid up here,

915
00:49:43,970 --> 00:49:45,680
比如说这是 32 ，
you know say this is 32,

916
00:49:45,680 --> 00:49:47,510
它将在那里，等等。
that will end up there etc etc.

917
00:49:49,050 --> 00:49:49,920
然后，最后，
Then, at the end,

918
00:49:49,950 --> 00:49:52,020
到目前为止我们还没有提交，
so at this point we have not committed yet, correct,

919
00:49:52,020 --> 00:49:53,250
我们所做的唯一一件事是
the only thing we've done is

920
00:49:53,250 --> 00:49:55,080
把数据块放入日志，
basically putting blocks into the log,

921
00:49:55,470 --> 00:49:57,930
如果我们在这个时间点崩溃，
and if we were crash at this particular point in time,

922
00:49:57,930 --> 00:50:01,890
在调用 write_head 之前，在 write_head 成功前，
before calling write_head before write_head succeeded,

923
00:50:02,010 --> 00:50:05,520
就像事务根本没有执行一样。
and basically as if the transaction didn't execute at all.

924
00:50:06,810 --> 00:50:08,610
所以让我们来看一下 write_head ，
So let's look at the write_head,

925
00:50:09,430 --> 00:50:12,760
write_head 是我前面所说的提交点，
so that write_head is what I called earlier, basically the commit point,

926
00:50:13,770 --> 00:50:17,670
提交点很直接，
and the commit point, basically you know basically it's straightforward

927
00:50:17,670 --> 00:50:21,590
到达磁盘上块的头，
and reach the head of block from disk,

928
00:50:21,590 --> 00:50:23,420
可能位于缓冲器缓存中，
which is probably sitting in the buffer cache,

929
00:50:23,780 --> 00:50:27,770
把拷贝放在最后，
it you know puts the copies the end,

930
00:50:27,830 --> 00:50:30,830
那个块的后面，
you know this end into that block,

931
00:50:30,830 --> 00:50:33,920
把所有块编号放到那个数组，放到那个块，
puts all the block numbers into that array into that block

932
00:50:34,040 --> 00:50:36,410
它写入那个特定的块。
and it basically writes that that particular block.

933
00:50:37,210 --> 00:50:38,140
这个，
This is the,

934
00:50:38,260 --> 00:50:40,870
这个 bwrite 是什么，是那个提交点吗？
this bwrite what is that, is that the commit point?

935
00:50:45,420 --> 00:50:47,820
如果在 bwrite 之前发生崩溃，会发生什么呢？
If a crash happens before this bwrite, what happens then?

936
00:50:57,180 --> 00:50:57,780
有人知道吗？
Anybody?

937
00:50:58,700 --> 00:51:01,820
如果崩溃发生在 bwrite 之前，
If the crash happens before bwrite,

938
00:51:01,820 --> 00:51:07,790
是不是我们对内存中 hb 数据结构所做的修改，
isn't the only modification that we've made to the in memory hb data structure,

939
00:51:08,030 --> 00:51:10,220
它不会，它会好的。
so it's not, it's going to be fine.

940
00:51:10,610 --> 00:51:11,630
是的，它是好的，
Yeah, it's gonna be fine,

941
00:51:11,630 --> 00:51:15,830
因为我们已经写入了 db0 dbn 到日志中，
because basically we may have written db1 zero dbn whatever to log,

942
00:51:15,830 --> 00:51:18,290
但是我们还没有成功写入日志头，
but we have not succeeded in writing the log header,

943
00:51:18,980 --> 00:51:21,770
所以，在恢复时，什么都不会发生。
and so will do not, on recovery nothing will happen.

944
00:51:22,950 --> 00:51:25,380
如果正好在 bwrite 后发生崩溃，会发生什么，
And what happens if there's a crash right after to bwrite,

945
00:51:25,380 --> 00:51:26,490
比如这里发生了崩溃。
so like crash here.

946
00:51:32,220 --> 00:51:33,330
它不再是零，
And it's no longer zero,

947
00:51:33,330 --> 00:51:36,330
所以日志头被正确读取并被恢复。
so the log headers correctly read and it's recovered.

948
00:51:36,570 --> 00:51:38,280
是的，会恢复，对吧。
Yeah, will be recovered, correct.

949
00:51:38,280 --> 00:51:41,070
在某一时刻，像我们期望的一样，在恢复期间，
Well, at some point, hopefully during recovery as we expect that,

950
00:51:41,070 --> 00:51:44,580
我们期望恢复会实际读取日志头，
we expect the recovery will actually read the log header

951
00:51:44,580 --> 00:51:46,830
看到其中有一个 5 ，
see that there is a 5 in there for example,

952
00:51:47,070 --> 00:51:49,680
然后把前 5 个日志复制到原位置。
and then copy the first 5 logs to their home location.

953
00:51:50,530 --> 00:51:53,320
所以这一行，
So this is really this, this, this one line,

954
00:51:53,860 --> 00:51:54,880
这个磁盘写入，
there's one disk write,

955
00:51:54,880 --> 00:51:56,770
这个扇区写入是真正的提交点。
there's one sector write is really the commit point.

956
00:51:58,440 --> 00:51:58,860
对吧？
Right?

957
00:52:03,380 --> 00:52:07,010
在提交点之前，事务没有发生，
Before the commitment point, the transaction, is the transaction didn't happen,

958
00:52:07,010 --> 00:52:10,130
在提交点之后，事务一定完成了，
after the commit point, the transaction will definitely be finished,

959
00:52:11,470 --> 00:52:12,760
假设你的恢复是正确的。
assuming your recovery is correct.

960
00:52:18,220 --> 00:52:22,720
好的，让我们回去 commit 。
Okay, so let's you know go back to commit.

961
00:52:25,020 --> 00:52:26,910
所以在提交之后，
So commit, after its committed,

962
00:52:26,910 --> 00:52:28,770
它安装了事务，
it actually installs the transactions,

963
00:52:28,830 --> 00:52:30,510
这非常直接，
and that's pretty straightforward,

964
00:52:30,510 --> 00:52:32,670
它使用数据块，
basically it takes the blocks,

965
00:52:32,670 --> 00:52:34,440
查看数据块所在的头，
looks at the header where the blocks belongs

966
00:52:34,440 --> 00:52:36,390
然后写入那个特定的位置。
and then basically writes into that particular location.

967
00:52:37,660 --> 00:52:40,930
是的，所以我们看看 install_trans ，
Yeah, so we can actually look at install_trans,

968
00:52:41,930 --> 00:52:43,910
看看它是怎么做的。
you see that actually that's what it does.

969
00:52:45,110 --> 00:52:46,940
它有一个日志头的副本，
It has a copy of the log header

970
00:52:47,270 --> 00:52:50,750
并且读取日志头，
and use or reads log header,

971
00:52:50,750 --> 00:52:53,720
它到达目的块的原位置，
it reach the destination block the home location,

972
00:52:54,290 --> 00:52:59,030
将数据从日志块复制到目的位置，
copies the data from the log block into the destination,

973
00:52:59,360 --> 00:53:01,280
然后将缓冲区写入目的位置。
and then writes the buffer to the destination.

974
00:53:03,170 --> 00:53:03,830
好的？
Okay?

975
00:53:04,730 --> 00:53:06,440
所以它所做的是
So basically effectively what this does is

976
00:53:06,440 --> 00:53:08,810
回到上一张幻灯片，
basically you know you go back to this previous slide here

977
00:53:08,810 --> 00:53:12,290
它从日志中复制
and copies, you know it just does these copies from the log

978
00:53:12,290 --> 00:53:14,780
到原位置或文件系统中。
into the home location or actually in the file system.

979
00:53:17,160 --> 00:53:20,340
当然，我们可能会在这个代码中的某个地方出现故障，
And of course you know we might get a failure somewhere in you know this code

980
00:53:20,340 --> 00:53:21,630
或者在我们做这件事的时候，
or while we're doing this,

981
00:53:21,930 --> 00:53:23,370
但是这是可以的，
but you know it should be okay,

982
00:53:23,370 --> 00:53:25,980
因为在恢复中会从头开始。
because hopefully in recovery will start over from the beginning.

983
00:53:29,150 --> 00:53:32,540
让我们看看，这就是安装。
So let's look at we, so that was installed.

984
00:53:33,160 --> 00:53:34,720
所以，一旦安装完成，
So once install is done,

985
00:53:35,750 --> 00:53:42,980
它会将内存中的头重新设置为 0 ，
then basically it sets you know the in-memory header and back to 0

986
00:53:43,100 --> 00:53:44,630
然后写入日志头。
and then writes that log header.

987
00:53:45,500 --> 00:53:51,650
并且引起清理日志，
And effectively that causes to cleans the log,

988
00:53:51,650 --> 00:53:53,270
因为现在是已经是 0 了。
because basically there's now 0 in it.

989
00:53:53,900 --> 00:53:54,500
有什么问题？
Question?

990
00:53:56,130 --> 00:54:02,470
所以，你刚才说的函数，
So, you have the function you're in just before,

991
00:54:02,740 --> 00:54:06,970
比如从什么到什么的东西，
like whereas, does the from to, or to, or something,

992
00:54:07,150 --> 00:54:12,350
它把你要更新的块，
so that puts the, the block that you're going to like update,

993
00:54:12,410 --> 00:54:17,030
你要更新的日志到缓冲区缓存中，
the log that you're going to update into the buffer cache,

994
00:54:17,840 --> 00:54:19,700
是否让它变得更快，
could you make it faster

995
00:54:19,700 --> 00:54:21,950
通过不放入缓冲区缓存，
by not putting into the buffer cache

996
00:54:21,950 --> 00:54:25,770
而是直接写入设备。
and just directly writing it to the device instead.

997
00:54:26,680 --> 00:54:30,490
让我，我们说的是哪个函数？
Let me, which function we're talking about?

998
00:54:31,770 --> 00:54:34,110
我忘了它的名字，
I forget its name,

999
00:54:34,140 --> 00:54:38,790
就是那个复制所有的东西到日志里。
it's the one, where you copy, yeah, everything into the log.

1000
00:54:39,030 --> 00:54:41,370
好的， install_trans 。
Okay, install install_trans.

1001
00:54:42,920 --> 00:54:45,680
我想是的。
I think so.

1002
00:54:47,160 --> 00:54:48,840
哦，也许是这个。
Oh, maybe it was this one.

1003
00:54:50,220 --> 00:54:50,520
所以，这个。
So, this.

1004
00:54:50,520 --> 00:54:53,760
我想可能是 write_head ，但这是一样的。
I thinking probably of write_head, but it's the same thing.

1005
00:54:54,180 --> 00:54:55,770
好的。
Okay, good.

1006
00:54:57,630 --> 00:55:01,490
唯一的原因，
The only reason, the only reason to this,

1007
00:55:01,490 --> 00:55:03,320
我们的接口不是特别好，
you know basically our interface is not particularly good,

1008
00:55:03,320 --> 00:55:04,610
你可以直接读，
you could just read straight,

1009
00:55:04,610 --> 00:55:07,370
你可能在想为什么要读，
you know you're wondering why you are doing the read,

1010
00:55:07,980 --> 00:55:09,600
没有理由去读，
there's no reason to do the read,

1011
00:55:09,600 --> 00:55:11,940
因为我们无论如何都要写，
because we're going to write anyway,

1012
00:55:12,210 --> 00:55:13,110
是这个问题吗？
is that the question?

1013
00:55:14,980 --> 00:55:18,760
是的，而且你使用了 memmove 。
Yeah, that and you're also doing the memmove.

1014
00:55:19,450 --> 00:55:20,560
使用了 memove ，是的，
And did the memmove, yeah,

1015
00:55:20,620 --> 00:55:23,380
所以这里是绝对可以优化的代码，
so these are actually a sequence of code can definitely be optimized,

1016
00:55:23,470 --> 00:55:26,140
你可以节省一两次磁盘写入。
you can save you know one or two disk writes.

1017
00:55:26,600 --> 00:55:29,690
为了简单起见，我们没有做任何这样的事情。
Just for simplicity, we don't do any of that.

1018
00:55:30,270 --> 00:55:31,200
好的，谢谢。
Okay, thank you.

1019
00:55:35,170 --> 00:55:39,650
好的，我想我们已经过了 commit ，
Okay, so I think we're in over commit,

1020
00:55:40,410 --> 00:55:43,980
回去，再检查一下。
just like, just go back and double check.

1021
00:55:44,540 --> 00:55:46,160
所以我们执行了 write_log ，
So we did the write_log,

1022
00:55:46,160 --> 00:55:47,210
我们执行了 write_head ，
we did the write_head

1023
00:55:47,270 --> 00:55:49,610
这里是清理操作，
and basically this the cleaning operation,

1024
00:55:50,430 --> 00:55:54,030
我们通过给它设置 0 来清除事务。
we erased you know transaction by sending it to zero.

1025
00:55:54,150 --> 00:55:54,690
好的？
Okay?

1026
00:55:55,880 --> 00:55:58,370
所以，唯一需要进一步了解的是，
So the only thing to further inspect is

1027
00:55:58,370 --> 00:56:00,290
恢复是如何进行的，
like how, how does recovery work

1028
00:56:00,320 --> 00:56:06,300
所以，恢复发生在 xv6 开始时，
and so recovery happens when you know when xv6 starts,

1029
00:56:06,720 --> 00:56:08,370
所以现在我们崩溃了，
so now we had a crash,

1030
00:56:08,370 --> 00:56:11,340
系统出了故障，我们重新启动它，
and the system failed, we reboot it,

1031
00:56:11,370 --> 00:56:17,070
xv6 首先做的事情之一，
and the, one of the first things that xv6,

1032
00:56:17,430 --> 00:56:21,180
xv6 在初始化期间做的一件事，
one of the things that xv6 does during initialization,

1033
00:56:21,210 --> 00:56:22,650
它调用 initlog ，
it actually call initlog,

1034
00:56:23,390 --> 00:56:27,050
而 initlog 调用 recover_from_log 函数，
and initlog basically calls this function recover_from_log

1035
00:56:27,230 --> 00:56:28,790
让我们看看它做了什么。
and so let's see what that does.

1036
00:56:30,110 --> 00:56:34,400
recover_from_log 调用 read_head ，
And basically recover_from_log you know calls read_head,

1037
00:56:34,920 --> 00:56:38,220
选取或读取。
to basically extract or read the.

1038
00:56:39,300 --> 00:56:42,120
让我看看能不能稍微向下滚动一下。
Then, let me see if I can scroll down here a little bit.

1039
00:56:45,580 --> 00:56:47,290
从磁盘上读取头，
Basically reads the header from disk,

1040
00:56:48,100 --> 00:56:49,360
查看 n ，
and sees if n,

1041
00:56:49,920 --> 00:56:52,560
好的，并不是看 n 是否为 0 ，
well, doesn't really see if n is zero or not,

1042
00:56:52,560 --> 00:56:54,450
它只是调用 install_trans ，
but it just calls install_trans

1043
00:56:54,600 --> 00:56:57,090
这是一样的 install_trans ，
and you know this is exactly the same install_trans

1044
00:56:57,090 --> 00:57:00,480
和我们刚才看到的那个。
we use look for it, for a look at it a while ago.

1045
00:57:00,720 --> 00:57:02,430
它查看 n ，
And basically you know look at the n

1046
00:57:02,430 --> 00:57:04,920
安装从 0 到 n 的所有块
and installs all the blocks from 0 to n

1047
00:57:05,220 --> 00:57:07,080
从日志中到它们的原位置。
out of the log into their home location.

1048
00:57:07,850 --> 00:57:08,780
如果它完成了，
And if it's done,

1049
00:57:08,870 --> 00:57:09,890
一旦它成功了，
once it succeeds,

1050
00:57:09,890 --> 00:57:14,020
它也像之前一样清除日志。
you know then actually it calls clear log as before.

1051
00:57:14,820 --> 00:57:17,160
所以，这就是恢复所做的，
And so that's actually all what the recovery does,

1052
00:57:17,160 --> 00:57:20,370
恢复总是调用安装。
recovery is basically always call does installation.

1053
00:57:21,010 --> 00:57:23,740
如果我们在安装时发生故障，
And if we crash during installation here,

1054
00:57:24,130 --> 00:57:25,720
也没有什么问题，
no particular problem again, correct,

1055
00:57:25,720 --> 00:57:27,430
因为我们崩溃，重启，
because we'll crash, we'll boot,

1056
00:57:27,730 --> 00:57:31,660
xv6 重启会调用 loginit ，
xv6 rebooting will call loginit,

1057
00:57:31,840 --> 00:57:33,310
它会调用 recover_from_log ，
which will call recover_from_log

1058
00:57:33,340 --> 00:57:37,810
并且它会重新安装日志，
and it will basically re-install, replay the log is sometimes called again,

1059
00:57:37,870 --> 00:57:40,270
这可能会结束，
and this might have, this might end,

1060
00:57:40,330 --> 00:57:43,750
如果我们每次都崩溃或崩溃很多次，
if we crash every time or you know many many times,

1061
00:57:44,020 --> 00:57:47,320
我们会多次重新安装日志，
you know we'll re-install or replay the log many many many times,

1062
00:57:47,380 --> 00:57:49,480
希望在某一时刻它会成功，
they'll tell hopefully at some point it succeeds

1063
00:57:49,600 --> 00:57:52,390
写入所有日志，
and actually you know gets the whole log written,

1064
00:57:53,320 --> 00:57:54,880
安装整个日志，
gets the whole log installed,

1065
00:57:54,910 --> 00:57:57,790
到原位置。
you know to the, to home locations.

1066
00:57:59,430 --> 00:58:00,030
这能理解吗？
Does it make sense?

1067
00:58:03,580 --> 00:58:05,410
我有个问题，关于，
I had a question about,

1068
00:58:05,740 --> 00:58:08,800
所以，如果一个进程正常运行，
so if a process just runs normally,

1069
00:58:08,950 --> 00:58:11,560
它写入一些数据到磁盘中，
it writes some data to disk,

1070
00:58:11,920 --> 00:58:13,390
然后在之后的某个时刻，
and then at some point after that,

1071
00:58:13,570 --> 00:58:16,870
在提交并安装更改之前，
before it commits and installs the changes,

1072
00:58:17,370 --> 00:58:19,410
有一个失败，
there's a failure,

1073
00:58:19,530 --> 00:58:24,380
从更多的过程的角度来看，什么都没有发生，
the process, the further process point of view, nothing happened,

1074
00:58:24,380 --> 00:58:25,910
但是，
but something like,

1075
00:58:26,880 --> 00:58:32,430
我想失败发生在我所做的事情结束后，
I guess the failure happened after the process end of what I was doing,

1076
00:58:33,060 --> 00:58:35,100
这有什么不好吗？
so, is there anything bad about that?

1077
00:58:36,170 --> 00:58:37,790
不是百分之百明白，
Not hundred percent getting it,

1078
00:58:37,790 --> 00:58:41,450
但简短的回答是没什么不好的，
but a short answer is there's nothing bad,

1079
00:58:41,480 --> 00:58:43,490
因为磁盘根本不会更新，
because the disk won't be updated at all,

1080
00:58:43,520 --> 00:58:47,240
所以就像文件系统操作没有发生一样。
so just as if you know that file system operation didn't happen.

1081
00:58:48,130 --> 00:58:50,960
好的，我想。
Alright, I guess.

1082
00:58:50,990 --> 00:58:52,520
进程也消失了，
Process disappears too,

1083
00:58:52,520 --> 00:58:56,420
但是，无论如何我们不希望进程在故障中幸存下来。
but, you know we don't expect the process to survive failures anyway.

1084
00:58:58,150 --> 00:59:00,740
好的，我猜，
Right or I guess,

1085
00:59:01,200 --> 00:59:04,050
好的，我想这回答了我的问题，谢谢。
okay I I think that answers my question, thank you.

1086
00:59:05,720 --> 00:59:07,370
是的，记住这一点很重要
Yeah, it's important to remember to

1087
00:59:07,370 --> 00:59:11,180
在失败中幸存下来的唯一一件事，
basically the only thing that really survives failures

1088
00:59:11,210 --> 00:59:13,070
或者具有跨失败的持久性是
or that's persistence across failures is

1089
00:59:13,070 --> 00:59:15,980
磁盘或磁盘上的状态，没有别的。
the disk or the state on the disk nothing else, right.

1090
00:59:19,620 --> 00:59:23,580
好的，为了让这些更具体化，
Okay, so just to make this all concrete one little more to,

1091
00:59:23,580 --> 00:59:24,450
让我们。
let's.

1092
00:59:25,160 --> 00:59:29,270
我在 bwrite 放了一个打印语句，
I put a statement in bwrite,

1093
00:59:29,270 --> 00:59:31,820
它将内容写入磁盘，
so actually the thing that actually does write to disk,

1094
00:59:31,850 --> 00:59:33,380
比如在块缓存中。
like in the block cache.

1095
00:59:33,920 --> 00:59:37,970
我们要看看磁盘写入的轨迹是什么。
And we're going to see what the trace of actual disk writes are.

1096
00:59:38,600 --> 00:59:40,130
因为在周一，
Because basically on Monday,

1097
00:59:40,130 --> 00:59:45,210
我没有说出全部真相，
I sort of, I didn't tell the full truth,

1098
00:59:45,240 --> 00:59:48,000
因为我把 print 语句放在 log_write 中，
because basically I put the print statement in log_write

1099
00:59:48,030 --> 00:59:49,560
而不是在 bwrite 中，
and not in bwrite,

1100
00:59:49,650 --> 00:59:51,390
所以现在我把它放入 bwrite ，
and so now I put it in the bwrite

1101
00:59:51,390 --> 00:59:53,670
这样我们就可以看到所有被写入的数据块。
and so we can actually see all the blocks are being written.

1102
00:59:54,380 --> 00:59:55,970
我们要做一样的事情，
So we'll do the same thing as before,

1103
00:59:55,970 --> 00:59:57,290
也就是 echo hi > x ，
you know echo hi x,

1104
00:59:57,650 --> 00:59:59,930
看看真正的磁盘写入。
and just look at actually the actual disk writes.

1105
01:00:01,120 --> 01:00:02,290
看看这是否有意义，
And see if that makes sense,

1106
01:00:02,350 --> 01:00:03,820
首先要注意的是，
you know so the first thing to note correctly,

1107
01:00:03,820 --> 01:00:07,390
这个轨迹比我们上次看到的要长得多，
that this traces way longer than the trace that we looked at last time,

1108
01:00:07,390 --> 01:00:10,600
我们在几张幻灯片前看过的那张。
the fact that we looked at a slide a couple slides ago, right.

1109
01:00:11,480 --> 01:00:12,380
因为你看到，
Because you're looking at,

1110
01:00:12,380 --> 01:00:14,120
刚才演示的，
in fact you know just demonstrate this,

1111
01:00:15,440 --> 01:00:20,210
这也是一样的 echo hi 。
here was the same echo hi, correct.

1112
01:00:20,980 --> 01:00:26,220
我们看到只有 5 个 log_write 操作，
And when we see there's like only it's 5 log_write operations,

1113
01:00:26,400 --> 01:00:32,120
但是它变成了很多磁盘操作。
but it turns into many disk operations, correct.

1114
01:00:32,780 --> 01:00:33,650
所以让我们来看看它。
So let's look at it.

1115
01:00:34,680 --> 01:00:38,910
所以我们认为 bwrite 3 4 5 是什么，
So what we think bwrite 3 4 and 5 are

1116
01:00:39,000 --> 01:00:40,110
以及 bwrite 2 是什么。
and what is bwrite 2.

1117
01:00:48,710 --> 01:00:49,370
有人知道吗？
Anybody?

1118
01:00:50,080 --> 01:00:53,620
所以先写入日志，然后写入超级块。
So writing to the log and then the super block.

1119
01:00:54,580 --> 01:00:55,990
不是超级块。
Not the super block.

1120
01:00:56,110 --> 01:00:57,610
抱歉，是 log_head 。
No, sorry, that's the log_head.

1121
01:00:57,640 --> 01:01:00,550
是的，看一下，你说对了，
Yeah, so just look at, you got it right,

1122
01:01:00,550 --> 01:01:02,290
再看一下这张图片，
you know just looking at this picture again, correct,

1123
01:01:02,680 --> 01:01:03,850
日志结构 2 ，
the log structure 2,

1124
01:01:03,880 --> 01:01:06,070
这可能是 header 块，
so, that's probably the header block

1125
01:01:06,460 --> 01:01:07,720
用来提交记录，
to commit record if you will,

1126
01:01:08,110 --> 01:01:09,910
然后 3 是第一个数据块，
and then 3 is the first data block,

1127
01:01:09,910 --> 01:01:11,080
4 是第二个数据块，
4 is the second data block,

1128
01:01:11,080 --> 01:01:12,310
5 是第三个数据块。
5 is the third data block.

1129
01:01:13,540 --> 01:01:16,870
所以回到这里，这是第一次写入，
So going back, you know this is the first write,

1130
01:01:17,630 --> 01:01:19,790
第二次写入，第三次写入，
the second write, the third write,

1131
01:01:20,210 --> 01:01:22,430
它们都会进入日志，
they're all going into the log

1132
01:01:22,910 --> 01:01:24,290
并被写入磁盘，
and they're written to disk,

1133
01:01:24,890 --> 01:01:26,900
在磁盘的日志部分中，
in the log log part of the disk,

1134
01:01:27,170 --> 01:01:30,470
然后这是提交记录 header 。
and then this is the commit record header.

1135
01:01:31,060 --> 01:01:32,680
然后这些是什么？
And then presumably what is this face?

1136
01:01:41,720 --> 01:01:42,680
这部分是什么？
What is this part?

1137
01:01:43,340 --> 01:01:45,080
这是位图设置吗？
Is that the bitmap setting?

1138
01:01:45,900 --> 01:01:49,710
不，那么我们认为 bwrite 3 保存了什么？
No, so what do we think actually stored in this bwrite 3?

1139
01:01:51,980 --> 01:01:57,440
这里你创建了文件 x 的 inode ，
Here you creating the file of the inode for x,

1140
01:01:57,440 --> 01:02:00,170
更新目录，
updating the directory

1141
01:02:00,170 --> 01:02:02,900
然后也创建了文件本身。
and then also actually making the file itself.

1142
01:02:03,360 --> 01:02:05,760
是的，所以我们没有在这里做，
Yeah, and so and we didn't do it here, right,

1143
01:02:05,760 --> 01:02:08,310
因为在这些 bwrite 中没有发生。
because in these bwrites that didn't happen.

1144
01:02:08,900 --> 01:02:09,800
现在我们正在做。
Now we're doing it.

1145
01:02:11,090 --> 01:02:13,700
那么，这是事务的哪个阶段？
So what, what what phases of the transaction?

1146
01:02:16,200 --> 01:02:17,940
安装更改。
Installing the changes.

1147
01:02:17,970 --> 01:02:19,440
是的，安装更改，
Yeah, installing the changes, correct,

1148
01:02:19,440 --> 01:02:20,760
我们在这里做的是，
what we did here is,

1149
01:02:21,490 --> 01:02:24,260
我们记录写入，
we log the write,

1150
01:02:24,650 --> 01:02:28,370
然后，我们提交文件系统操作，
then we committed the file system operation the create operation

1151
01:02:28,370 --> 01:02:29,540
现在我们安装它，
and now we're installing it,

1152
01:02:30,430 --> 01:02:32,440
现在我们把块放在它们的原位置上。
for now we're putting the blocks in their home location.

1153
01:02:34,300 --> 01:02:37,370
现在， bwrite 2 之后是什么？
And now, and what does this bwrite 2 then?

1154
01:02:44,500 --> 01:02:45,760
清除日志。
Clearing the log.

1155
01:02:45,760 --> 01:02:47,140
是的，清除日志。
Yeah, it's clear log, exactly.

1156
01:02:47,760 --> 01:02:49,260
所以，这个这个这个，
So basically this, this, this,

1157
01:02:50,510 --> 01:02:53,540
系统调用写入 33 46 32 ，
the system call was writing 33 46 32

1158
01:02:53,840 --> 01:02:56,150
使用日志系统，
and to actually do that using the logging system

1159
01:02:56,150 --> 01:03:01,830
变成了这组磁盘写入。
that basically turns into this set of disk write, right.

1160
01:03:01,830 --> 01:03:04,110
第一部分是安装日志，
Where the first part is installing the log,

1161
01:03:04,110 --> 01:03:06,060
第一部分是记录写入，
in the first part is actually logging the writes,

1162
01:03:06,060 --> 01:03:07,860
第二部分是安装日志。
in the second part is installing the log.

1163
01:03:09,860 --> 01:03:11,810
这是提交记录的两个写入。
And these are the two writes due to commit records.

1164
01:03:15,040 --> 01:03:15,700
所以这能理解吗？
So it makes sense?

1165
01:03:15,790 --> 01:03:21,160
是否可以从跟踪中找出 begin_op 和 end_op 在哪里？
Is it possible to infer where begin_op and end_op would run from this trace?

1166
01:03:21,760 --> 01:03:24,640
嗯，我们不能，
Well, so we're sort of no, correct,

1167
01:03:24,640 --> 01:03:27,400
我们不知道 begin_op 是从哪里开始的，
so where did, we don't really know what begin_op start,

1168
01:03:27,400 --> 01:03:30,550
但是任何文件系统调用都是以 begin_op 开始的，
but this is any file system calls starts with the begin_op,

1169
01:03:31,420 --> 01:03:33,250
并且必须是这种情况，
and it must be the case that,

1170
01:03:33,900 --> 01:03:37,530
提交记录在 end_op 中，
the commit record correct is written in end_op,

1171
01:03:37,890 --> 01:03:44,050
我们知道这是一些文件系统操作的 end_op 。
so we know that this is the end_op of some file system operation.

1172
01:03:48,010 --> 01:03:48,910
这能理解吗？
Does that make sense?

1173
01:03:53,270 --> 01:03:58,520
好的，这是 xv6 日志演示，
Okay, so that's basically xv6 log logging in action,

1174
01:03:58,880 --> 01:04:01,370
我想讨论一些更复杂的，
and I want talk about a couple complications,

1175
01:04:01,700 --> 01:04:09,860
即使是这种很简单日志方案也有其复杂性。
and even this dirt simple naive logging scheme actually has complications.

1176
01:04:10,540 --> 01:04:13,480
需要注意的一件事是，
One thing to immediately note of course is,

1177
01:04:13,960 --> 01:04:17,440
这是一个很高性能的实现吗？
you know is this a very performance implementation?

1178
01:04:18,710 --> 01:04:20,060
你可以看看这个痕迹。
You can by looking at this trace.

1179
01:04:26,990 --> 01:04:27,620
不是。
No.

1180
01:04:28,190 --> 01:04:29,270
为什么不是，
Why not,

1181
01:04:30,320 --> 01:04:32,510
我知道这是两个简单的问题，
I know this is a basically two simple questions,

1182
01:04:32,510 --> 01:04:34,790
但提问很重要。
but it's important to ask.

1183
01:04:36,510 --> 01:04:41,230
比如，一些东西你写了两次。
Like, you're writing the stuff twice right.

1184
01:04:41,260 --> 01:04:42,790
是的，一些东西你写了两次，
Yeah, you're writing the stuff twice,

1185
01:04:42,790 --> 01:04:44,920
写一个大文件 f ，
write a file f or a big file f,

1186
01:04:44,950 --> 01:04:46,660
我要把那个大文件 f 写两次。
I'm going to write that big file f twice.

1187
01:04:48,000 --> 01:04:51,180
所以，这当然不是非常高性能的，
And so, certainly not particularly high performance, right,

1188
01:04:51,180 --> 01:04:53,970
我的意思是，将性能削减了一半，
I mean basically re-cutting the performance immediately by a factor of two,

1189
01:04:55,680 --> 01:04:56,940
为了崩溃安全。
just to get crash safety.

1190
01:04:57,620 --> 01:05:00,500
所以我们会看到，
And so we'll see on on you

1191
01:05:00,500 --> 01:05:05,570
在你们阅读周一的 ext3 论文时，
when you're reading the ext ext3 paper for Monday

1192
01:05:05,660 --> 01:05:07,220
有一件事你应该记住，
and one thing you should keep in your head,

1193
01:05:07,220 --> 01:05:08,450
论文如何，
while reading is get,

1194
01:05:08,450 --> 01:05:12,060
如何应对这个倍数 2 。
how, how do I get around for this factor of two.

1195
01:05:15,140 --> 01:05:15,710
好的？
Okay?

1196
01:05:16,660 --> 01:05:20,500
抱歉，这个情况是不是把 h 和 i 分开写的呢？
Sorry, is it the case that you write the h and the i separately?

1197
01:05:21,460 --> 01:05:23,260
是的，我想是的。
Yeah, I think so.

1198
01:05:23,960 --> 01:05:25,010
好的。
Okay.

1199
01:05:25,010 --> 01:05:27,860
我马上告诉你们为什么，
I'll, I'll show you in a second why,

1200
01:05:27,980 --> 01:05:29,420
那里发生了什么。
what is happening there.

1201
01:05:31,760 --> 01:05:33,320
或者，
Or maybe,

1202
01:05:34,960 --> 01:05:37,420
让我不要做太多回答，
well, let me not commit too much the answer,

1203
01:05:37,540 --> 01:05:39,580
但我会回到这个问题上来。
but I will get back to it.

1204
01:05:40,210 --> 01:05:44,140
哦，抱歉，是不是有空行，而不是 h 和 i ，但是。
Oh, sorry, am I having the empty line, not the h and i, but yeah.

1205
01:05:44,620 --> 01:05:45,070
换行是一个单独的写入，
The new line is a separate write,

1206
01:05:45,100 --> 01:05:49,480
h 和 i 是一个写入，换行是一个单独的写入。
h and i is one write, new line is a separate write.

1207
01:05:49,810 --> 01:05:50,920
好的，谢谢。
Okay, thank you.

1208
01:05:51,760 --> 01:05:52,450
不用谢。
You're welcome.

1209
01:05:52,960 --> 01:05:56,650
好的，这些是复杂的问题，
Okay, there's complications

1210
01:05:56,740 --> 01:05:59,260
我想稍微谈谈这些复杂的问题。
and I want to talk a little bit about these complications.

1211
01:06:05,970 --> 01:06:08,490
这是我们的基本方案，基本数据结构，
Here's our basic scheme, basic data structures,

1212
01:06:08,910 --> 01:06:11,880
我想要谈的是三个复杂的问题。
and there's three complications I want to talk about.

1213
01:06:15,360 --> 01:06:17,760
也许我可以把它们叫做挑战，不管你怎么称呼。
Maybe I'll call them challenges, whatever you wanna call them.

1214
01:06:21,490 --> 01:06:23,260
第一个是驱逐。
The first is eviction.

1215
01:06:29,080 --> 01:06:30,940
问题是这样的，
And the issue is as follows,

1216
01:06:31,000 --> 01:06:32,950
让我们回到这张图片，
let's say we go back to this picture here,

1217
01:06:33,920 --> 01:06:35,840
bcache 已经满了，
and you know bcache is full,

1218
01:06:37,950 --> 01:06:42,000
还有正在进行的事务，
and, and sort of transaction in progress,

1219
01:06:42,090 --> 01:06:45,000
我们看看，我们刚刚更新了 45 ，
let's see, we've just updated 45,

1220
01:06:45,570 --> 01:06:47,430
它现在完成了块 45 ，
it's now done block 45,

1221
01:06:47,430 --> 01:06:48,750
所以它要写下一个块，
so it's going to write the next block,

1222
01:06:49,530 --> 01:06:50,790
而缓存已经满了。
and the cache is full.

1223
01:06:51,700 --> 01:06:56,480
然后，这个，
And, the and,

1224
01:06:57,910 --> 01:07:01,150
假设我们没有解决这个问题的办法，
let's say you know we don't we don't have a solution for this yet,

1225
01:07:01,360 --> 01:07:07,060
但是缓存决定驱逐 45 ，
but the cache decides, it wants to evict 45 correct,

1226
01:07:07,300 --> 01:07:08,980
如果它想驱逐 45 ，
and if it wants to evict 45,

1227
01:07:08,980 --> 01:07:10,120
这意味着
but will mean that will mean,

1228
01:07:10,120 --> 01:07:12,040
我们必须把它写入原位置。
we have to write it to its home location.

1229
01:07:13,720 --> 01:07:19,370
驱逐 45 有什么问题，
How bad would it be to write the block, you know evict 45,

1230
01:07:21,060 --> 01:07:23,250
把 45 写入原位置。
and write 45 to home location.

1231
01:07:28,600 --> 01:07:29,800
这是好还是坏？
Is that good or bad?

1232
01:07:44,290 --> 01:07:46,270
如果我们那样做，会不会违反规则？
Would any rule be broken, if we did that?

1233
01:07:47,410 --> 01:07:51,760
我想，如果崩溃发生，
I guess, that as if a crash happens

1234
01:07:51,760 --> 01:07:56,290
在同一事务中的其他写操作发生之前，
before the other writes in the same transaction occurs,

1235
01:07:56,290 --> 01:07:59,170
那么原子性就被打破了。
then basically atomicity it is broken.

1236
01:08:02,980 --> 01:08:06,280
这违反了我所说的这个 write-ahead 规则，
That is basically violates this write-ahead rule that I talked about,

1237
01:08:07,610 --> 01:08:09,710
你必须将所有块写入日志，
you have to write all the blocks to the log,

1238
01:08:09,710 --> 01:08:12,380
在向每个原位置写入块之前。
before you write any block to each home location.

1239
01:08:25,780 --> 01:08:27,040
所以它必须是这种情况，
So it has to be the case correct,

1240
01:08:27,040 --> 01:08:31,660
缓存不应该驱逐日志中的任何块。
the cache does not evict any block that sits in the log.

1241
01:08:32,640 --> 01:08:33,420
这能理解吗？
Does that make sense?

1242
01:08:34,750 --> 01:08:43,490
所以，解决方案是不要驱逐这些在日志中的块。
So the solution is don't evict blocks those are in the log.

1243
01:08:49,330 --> 01:08:52,990
这就是刚才展示的内容，
And this is exactly what you were showing a little bit earlier

1244
01:08:52,990 --> 01:08:54,490
我说我不想谈。
and said I didn't want to talk about.

1245
01:08:54,880 --> 01:08:58,120
所以再次到 log_write ，
So you go to log_write again,

1246
01:08:58,120 --> 01:08:59,830
看看这里，
just to see for a second there,

1247
01:09:00,480 --> 01:09:03,720
这是 log_write ，
log_write here log_write again

1248
01:09:04,140 --> 01:09:06,780
这里我们看到了对 bpin 的调用，
and here we see this call to bpin,

1249
01:09:07,620 --> 01:09:09,000
你认为 bpin 会做什么，
and what do you think bpin does,

1250
01:09:11,240 --> 01:09:12,710
名字在某种程度上表明了它。
name sort of indicates it.

1251
01:09:16,590 --> 01:09:21,970
它把块放入缓存中。
It pins the block in the, in the cache.

1252
01:09:22,000 --> 01:09:23,260
是的，它怎么做到的，
Yeah, how does it do it,

1253
01:09:23,530 --> 01:09:27,340
因为你已经研究了这个实验。
since you've been looking at this where your current lab extensively.

1254
01:09:28,890 --> 01:09:29,700
你觉得它能做什么。
What do you think it does.

1255
01:09:30,840 --> 01:09:33,180
我们可以查看 bpin 的实现，
So we can look at the implementation with bpin,

1256
01:09:33,180 --> 01:09:34,710
但我们也可以猜猜它是怎么做的。
but we can also guess what it does.

1257
01:09:40,000 --> 01:09:41,560
是不是实现它，
Doesn't it essentially just make it,

1258
01:09:41,590 --> 01:09:44,740
通过增加 refcnt ，它就不会被驱逐出去。
so that it doesn't get evicted by increasing the ref counts.

1259
01:09:44,770 --> 01:09:46,300
是的，这就是它说做的事，
Yeah, exactly this is all thing does,

1260
01:09:46,330 --> 01:09:47,950
bpin 只是增加 refcnt ，
bpin just to increases the refcnt

1261
01:09:47,950 --> 01:09:50,080
而且我们从 bcache 代码中知道，
and we know from the bcache code, correct,

1262
01:09:50,530 --> 01:09:54,520
驱逐不会驱逐任何引用多于 0 的块。
evict won't evict any blocks we have reference higher than 0.

1263
01:09:56,440 --> 01:10:00,010
所以，在稍后的日志代码中的某个位置，
And so presumably somewhere later in the logging code,

1264
01:10:00,010 --> 01:10:02,440
一旦一件事已经记录，
when once actually a thing is logged,

1265
01:10:02,440 --> 01:10:05,170
我们可以解锁块。
we can actually unpin the block, right.

1266
01:10:06,530 --> 01:10:07,880
好的，这是一个复杂的问题，
Okay, so that's one complication,

1267
01:10:07,880 --> 01:10:09,800
我们有一个固定和解锁的过程。
so we have this pinning and unpinning going on.

1268
01:10:11,080 --> 01:10:14,170
我们来看看另一个复杂的问题，
Let's look at another complication,

1269
01:10:29,970 --> 01:10:34,260
文件系统操作必须记录在日志中。
you know the file system operations must fit in log.

1270
01:10:41,460 --> 01:10:43,650
如果我们回到这里的图片，
If you see, we go back to our picture here,

1271
01:10:43,650 --> 01:10:45,570
或者可能这张图片更好，
or actually maybe this is a better picture,

1272
01:10:46,120 --> 01:10:48,040
xv6 中的日志有多大？
how big is the log in xv6?

1273
01:10:53,520 --> 01:10:54,600
30 个块。
30 blocks.

1274
01:10:54,630 --> 01:10:56,340
是的， 30 个块， 32 减去 2 ，
Yeah, 30 blocks, 32 minus 2,

1275
01:10:56,700 --> 01:11:01,110
所以最大日志大小是 30 。
so you know max size, max log size is 30.

1276
01:11:03,840 --> 01:11:05,250
当然，我们可以提高它，
Of course we could bump it up

1277
01:11:05,640 --> 01:11:08,160
在真实的文件系统中运行更大的日志，
in real file system runs with a much bigger log,

1278
01:11:08,160 --> 01:11:09,360
但这不重要，
but it doesn't really matter,

1279
01:11:09,720 --> 01:11:12,090
无论如何，它是这种情况，
no matter what, it has to be the case, correct,

1280
01:11:12,090 --> 01:11:15,120
文件系统操作必须适合 30 个数据块。
the file system operation must fit in 30 blocks.

1281
01:11:16,010 --> 01:11:19,010
因为如果文件系统操作尝试写入超过 30 个块，
Because if a file system operation would try to write more to 30 blocks,

1282
01:11:19,280 --> 01:11:22,430
那就意味着我们得在这个地方溢出一些东西，
that means we would have to spill something on this location

1283
01:11:22,430 --> 01:11:23,480
我们不允许这么做，
and we're not allowed to do that,

1284
01:11:23,510 --> 01:11:25,610
因为这会再次违反预写规则。
because that would violate the write-ahead rule again.

1285
01:11:26,270 --> 01:11:29,600
所以，必须将每个文件系统操作都写入日志中。
So it has to be the case that every file system operation fits into the log.

1286
01:11:31,440 --> 01:11:32,190
这能理解吗？
Does that make sense?

1287
01:11:35,040 --> 01:11:39,050
事实上，你知道我们是怎么得到 32 或 30 的？
In fact, you know how do you think we got to 32 or 30?

1288
01:11:50,670 --> 01:11:53,970
它与实际适合多少块，有什么关系吗？
Does it have to do anything with how many blocks actually fit?

1289
01:11:55,060 --> 01:11:56,050
你需要，
You were a way to

1290
01:11:56,110 --> 01:12:01,540
比如最大块数是多少，
like basically how many blocks does the maximum blocks, correct,

1291
01:12:01,540 --> 01:12:03,190
文件系统操作可以写入的。
the file system operation could write.

1292
01:12:04,280 --> 01:12:05,120
这就是，
And that is really what,

1293
01:12:05,120 --> 01:12:09,110
数字 30 必须绝对大于
this number 30 has to be definitely bigger than

1294
01:12:09,110 --> 01:12:21,280
文件系统操作可写入的最大数据块数量。
any you know the max number of blocks the file system operation write.

1295
01:12:26,570 --> 01:12:28,610
所以，实际上， Robert 和我这样做的，
And so, in fact you know Robert and I did,

1296
01:12:28,610 --> 01:12:30,500
因为我们检查了所有文件系统操作，
because we went through all the file system operations,

1297
01:12:30,500 --> 01:12:31,070
查看它们，
looked at them

1298
01:12:31,070 --> 01:12:34,460
决定最大数量是多少，
and decide whether what's the maximum number is

1299
01:12:34,460 --> 01:12:37,040
结果发现数字远远小于 30 ，
and it turns out that the actual number is much lower than the 30,

1300
01:12:37,340 --> 01:12:41,120
但我们马上会看到一些有趣的困难的问题，
but you know we'll see in a second a couple interesting complications,

1301
01:12:42,870 --> 01:12:44,850
比如，我们目前看到的操作，
like, for example the operation that we look so far,

1302
01:12:44,850 --> 01:12:47,280
比如创建文件只有几个块，
like creating a file correct is only a handful of blocks,

1303
01:12:47,310 --> 01:12:49,590
这个文件系统操作有 5 个块，
the file system operation is like 5 blocks,

1304
01:12:49,920 --> 01:12:54,600
事实上，大多数操作都是为数不多的几个块，
in fact, most operations are a handful of blocks not that many,

1305
01:12:54,690 --> 01:12:58,080
你有想到任何可能会写很多很多块的操作吗？
do you think of any operations that might write many many, many blocks?

1306
01:13:13,470 --> 01:13:15,450
你在写入一个大文件。
You're write on a huge file.

1307
01:13:15,600 --> 01:13:16,890
是的，写入一个很大的文件。
Yeah, write a huge file, right.

1308
01:13:16,890 --> 01:13:21,280
所以，如果我们调用 write 系统调用，
So, what if we you know, call the write system call

1309
01:13:21,280 --> 01:13:23,650
我们传入一个一兆字节数据的缓存，
and we pass the buffer with have a megabyte of data,

1310
01:13:24,680 --> 01:13:25,940
比如一千个块。
like a thousand blocks.

1311
01:13:27,030 --> 01:13:28,920
看起来我们遇到了很大的麻烦，
It seems like we're being serious trouble right,

1312
01:13:29,100 --> 01:13:31,410
这会违反最大数量。
it would violate you know these maximum.

1313
01:13:32,010 --> 01:13:36,290
所以，让我们看看 write ，
And so, let's look at write,

1314
01:13:44,080 --> 01:13:44,680
sys_write ，
sys_write,

1315
01:13:48,070 --> 01:13:49,870
sys_write 调用 filewrite ，
sys_write calls filewrite,

1316
01:13:51,070 --> 01:13:53,440
filewrite ，这里是 filewrite 。
filewrite, here's filewrite.

1317
01:13:54,180 --> 01:13:57,810
好的，这里有一个文件描述符 inode ，
Okay, so here's an inode, file descriptor inode

1318
01:13:57,840 --> 01:13:58,890
看看我的代码，
and [] see my code

1319
01:13:59,160 --> 01:14:00,720
我在显示器上的代码，
or the code that I've on the display

1320
01:14:01,110 --> 01:14:04,380
看看这段代码是做什么的。
and notice that what does this code do.

1321
01:14:09,440 --> 01:14:11,840
是的，你看上面写的评论，
Yeah, you read the comments write on top here

1322
01:14:11,840 --> 01:14:13,070
基本上解释了它，
and then basically explains it,

1323
01:14:13,070 --> 01:14:14,120
这是发生了什么，
but this is what happens, correct,

1324
01:14:14,120 --> 01:14:17,330
写入被拆分成许多数量较小的写入。
the write is split in many number smaller writes.

1325
01:14:18,710 --> 01:14:21,560
所以这里到底发生了什么，
So what really is going on here, correct,

1326
01:14:21,560 --> 01:14:24,350
我们确保
we are ensuring that the

1327
01:14:25,000 --> 01:14:28,150
整个写入作为一个整体不是原子的，
the whole write is a whole is not atomic,

1328
01:14:28,180 --> 01:14:31,000
这没关系， Unix 中的 write 系统调用语义，
that's okay, you know the write Unix system call semantics,

1329
01:14:31,000 --> 01:14:34,600
并不需要所有的上千个块，
don't actually require that actually all the thousand blocks,

1330
01:14:34,630 --> 01:14:37,060
一兆字节以原子方式写入，
you know a megabyte or actually written atomically

1331
01:14:37,270 --> 01:14:39,970
只是要求我们不要损坏文件系统，
and just requires that we don't corrupt the file system,

1332
01:14:40,120 --> 01:14:43,570
在写入时，不要损坏文件系统。
between don't corrupt the file system while doing it.

1333
01:14:44,090 --> 01:14:46,010
所以我们，
And so basically we,

1334
01:14:46,010 --> 01:14:49,880
是的， xv6 将一个大的写入拆分成多个较小的写入，
yeah, xv6 splits a big write in a number of smaller writes

1335
01:14:49,880 --> 01:14:51,920
并将它们作为单独的事务写入。
and writes them as individual transactions.

1336
01:14:53,160 --> 01:14:55,110
这可以确保我们的示例，
And this would basically ensures that our example,

1337
01:14:55,110 --> 01:14:57,360
如果事务分配了一个块编号，
if transaction allocates a block number,

1338
01:14:57,360 --> 01:15:00,030
因为我们需要一个新的块作为中间块，
because we need a new block as an intermediate block were,

1339
01:15:00,030 --> 01:15:00,960
我们需要一个新的块，
because we need a new block,

1340
01:15:00,960 --> 01:15:01,980
因为我们要写入它，
because we're going to write to it,

1341
01:15:02,310 --> 01:15:04,320
至少该部分是原子的，
at least that part is completely atomic

1342
01:15:04,320 --> 01:15:07,230
并且文件系统永远不会处于不正确的状态，
and the file system will be never left in an incorrect state,

1343
01:15:07,440 --> 01:15:10,020
违反任何文件系统不变性。
violating any of the file system invariance.

1344
01:15:10,490 --> 01:15:12,320
所以，写入拆分为很多
And so the write is split in many, many,

1345
01:15:15,150 --> 01:15:18,120
很多小的写入或很多事务。
many system in many smaller writes or many transactions.

1346
01:15:19,310 --> 01:15:20,060
好的？
Okay?

1347
01:15:20,560 --> 01:15:23,950
实际上，这是一个主要问题，
In fact, that's the main one that actually is

1348
01:15:25,780 --> 01:15:30,920
写入 fs 拆分为多个事务。
write fs split in many, many transactions.

1349
01:15:37,490 --> 01:15:38,510
对于这个，有什么问题吗？
Any questions about this?

1350
01:15:43,590 --> 01:15:46,470
注意，因为东西放在缓存中，
A note, because you know things are pins correct in cache,

1351
01:15:46,470 --> 01:15:50,100
这也意味着块缓存可能大于
that means also that the block cache was may bigger than

1352
01:15:51,330 --> 01:15:53,130
大于 logsize 。
the bigger to the logsize.

1353
01:15:57,910 --> 01:15:58,630
好的。
Okay.

1354
01:15:59,250 --> 01:16:05,010
现在我想谈的最后一个挑战是
So now the final challenge that I want to talk about is

1355
01:16:05,100 --> 01:16:08,660
并发文件系统调用。
concurrent file system calls.

1356
01:16:18,110 --> 01:16:19,670
这个问题如下，
And the issue as follows,

1357
01:16:19,700 --> 01:16:21,950
让我先试着解释一下问题是什么，
let me first try to explain what the problem is

1358
01:16:21,980 --> 01:16:23,900
然后我们再看看解决方案是什么。
and then we'll see what the solution is.

1359
01:16:25,730 --> 01:16:27,740
假设我们有自己的日志，
So let's say we have our log,

1360
01:16:29,240 --> 01:16:32,030
我们正在写如，
and, and we're writing

1361
01:16:32,120 --> 01:16:34,760
可能有两个事务同时执行。
and maybe there are two transactions executing concurrently.

1362
01:16:36,010 --> 01:16:38,110
想象一下，
And usually imagine for a second,

1363
01:16:38,110 --> 01:16:42,490
它们写入很多块，
that you know they write a lot of blocks,

1364
01:16:42,520 --> 01:16:46,270
所以 t0 正在执行，
so basically t0 is executing t0 is executing

1365
01:16:46,270 --> 01:16:50,870
这里是日志的开头，这里是日志的结尾。
and there also is the beginning of the log, here end of log.

1366
01:16:51,430 --> 01:16:57,070
而且， t1 会执行一些块，等等，
And, you know t1 executes some blocks and etc, etc,

1367
01:16:57,310 --> 01:16:59,320
而当我们到达日志末尾时，
and by the time we run to the end of the log,

1368
01:16:59,590 --> 01:17:00,490
没有一个是完成的，
neither one is complete,

1369
01:17:00,490 --> 01:17:03,430
两边都还有更多的写入要做。
you know, so both have still more writes to do.

1370
01:17:04,600 --> 01:17:10,950
在这个点上，我们可以提交这两个事务中的任何一个吗？
And, at this point, can we commit any of the two transactions?

1371
01:17:14,740 --> 01:17:15,910
不，我们不能，
No, we can't, correct,

1372
01:17:15,910 --> 01:17:20,140
因为如果我们提交，事务就是部分完成，
because if we would commit, transaction that is partially done,

1373
01:17:20,700 --> 01:17:24,420
那么我们再次违反了预写规则，
then we violate the write-ahead rule again

1374
01:17:24,420 --> 01:17:27,510
而且日志的目的是行不通的。
and you know the purpose actually logging there doesn't work out.

1375
01:17:28,440 --> 01:17:30,840
因此情况必须是，
So it has to be the case,

1376
01:17:30,840 --> 01:17:35,730
多个并发事务可以放入日志中，
that basically a number of concurrent transactions must fit in the log,

1377
01:17:35,790 --> 01:17:55,500
其实所有的并发操作，都必须符合。
in fact all concurrent operations, must fit.

1378
01:17:55,710 --> 01:17:59,250
所以，在这种情况下，
And so, in the way,

1379
01:18:00,370 --> 01:18:01,600
所以这是一种挑战，
so this is sort of a challenge, correct,

1380
01:18:01,600 --> 01:18:03,580
我们有一个文件系统调用开始，
we have a file system call starting

1381
01:18:03,580 --> 01:18:09,400
我们必须安排，
and you know we gotta arranged basically the that we,

1382
01:18:10,500 --> 01:18:14,250
我们有一个入口做检查，
we basically do a sort of an entrance you know check,

1383
01:18:14,250 --> 01:18:17,580
在我们运行文件系统操作之前，
you know before we actually let the file system operation go,

1384
01:18:17,610 --> 01:18:20,370
我们必须检查是否还有足够的块，
we must check whether there actually is enough blocks still,

1385
01:18:20,400 --> 01:18:23,640
如果我们已经有 n 个文件系统操作正在进行，
you know if we have n file system operations already in progress,

1386
01:18:23,700 --> 01:18:27,540
我们必须确保，如果我们允许多一个开始，
we have to make sure that if we allow one more guy to start,

1387
01:18:27,630 --> 01:18:29,880
块的总数，
that actually the total number of blocks, right,

1388
01:18:29,880 --> 01:18:31,950
它们可以一起写入，放入日志中。
they could write together actually fits in the log.

1389
01:18:33,000 --> 01:18:36,330
xv6 解决这个问题，
And the way you know basically xv6 you know gets around this,

1390
01:18:36,450 --> 01:18:39,690
限制并发文件系统调用的数量。
basically limits the number of concurrent file system calls.

1391
01:18:49,150 --> 01:18:52,540
它的工作方式是，
And the way it basically works is that,

1392
01:18:54,480 --> 01:18:56,730
我们看到 begin_op ，
and begin_op you would see,

1393
01:18:56,730 --> 01:19:00,450
有多少未完成的并发文件正在处理中，
how many outstanding concurrent files with transaction are in progress,

1394
01:19:00,540 --> 01:19:02,490
如果正在进行的太多，
if there are too many in progress,

1395
01:19:02,520 --> 01:19:05,790
我们只是存储当前的文件系统操作，然后进入睡眠状态，
we just stock the current file system operation and goes to sleep

1396
01:19:06,000 --> 01:19:09,450
它将等到所有其他文件操作完成并提交。
and it will wait until all the other guys are done and have committed.

1397
01:19:10,870 --> 01:19:13,030
所有其他文件操作都会一起提交，
And all the other guys will commit together,

1398
01:19:13,060 --> 01:19:16,240
事实上， t1 t2 ，它们已经完成了，
in fact you know at some point t1 t2, they're basically done,

1399
01:19:16,450 --> 01:19:17,950
可能 t3 也在这里，
maybe t3 in there too,

1400
01:19:18,160 --> 01:19:19,180
它们完成了，
they finish

1401
01:19:19,270 --> 01:19:22,060
然后所有这些事务，
and then basically in all these transactions

1402
01:19:22,060 --> 01:19:25,300
同一时间一起提交，
and in single time a single basically committed together,

1403
01:19:27,870 --> 01:19:29,430
这有时称为组提交。
this is sometimes called group commit.

1404
01:19:30,060 --> 01:19:32,250
因为你提交多个系统调用，
Because you're committing multiple system calls,

1405
01:19:32,370 --> 01:19:34,290
所有并发运行的系统调用，
you know all the ones that were concurrent in action,

1406
01:19:34,650 --> 01:19:38,520
作为一个大事务提交，
you committed together as a single big transactions,

1407
01:19:38,520 --> 01:19:41,130
所以所有更新都是可见的。
so that all there updates are visible.

1408
01:19:41,840 --> 01:19:44,690
所以，所有更新，全部，
So that all there updates, all place, all,

1409
01:19:45,350 --> 01:19:47,330
所以，所有这些更新，
so that all there updates,

1410
01:19:47,330 --> 01:19:49,160
全部发生或一个都没有发生。
all take place or none of them take place.

1411
01:19:50,390 --> 01:19:50,990
好的？
Okay?

1412
01:19:52,990 --> 01:19:56,620
我们可以看到，如果你去。
And we can see that you know, if you go to.

1413
01:19:56,620 --> 01:19:57,460
一个简短的问题。
A quick question.

1414
01:19:58,780 --> 01:19:59,320
嗯。
Yeah.

1415
01:19:59,320 --> 01:20:04,910
这个组提交是否是必须的，
Is that, is the group commit, is the group commit necessary,

1416
01:20:05,210 --> 01:20:09,030
比如一个系统调用首先完成，
could you say if one system calls finish first,

1417
01:20:09,030 --> 01:20:12,810
先提交它的事务，
just commit it's it's transaction

1418
01:20:12,810 --> 01:20:14,310
然后在提交其他的，
and then commit other ones later,

1419
01:20:14,310 --> 01:20:16,080
或者它是必要的。
or is it a necessary property.

1420
01:20:16,140 --> 01:20:18,600
你必须非常小心，
You gotta be very careful,

1421
01:20:18,600 --> 01:20:19,500
因为你还记得，
because you remember,

1422
01:20:19,500 --> 01:20:22,200
我一开始并没有明确地把它说成是一个目标，
one thing I didn't really state it explicitly as a goal early on

1423
01:20:22,200 --> 01:20:25,230
是因为我们仍按写入顺序执行系统调用，
is that we basically execute the system calls still in the write order,

1424
01:20:25,980 --> 01:20:26,250
right,

1425
01:20:26,250 --> 01:20:30,510
如果一个写入，
if a if a if a write,

1426
01:20:30,510 --> 01:20:31,680
如果读取观察到写入，
if a read observes write

1427
01:20:31,680 --> 01:20:32,670
然后做一个写入，
and then does a write,

1428
01:20:32,850 --> 01:20:33,960
那么必须是，
then it has to be the case,

1429
01:20:33,960 --> 01:20:36,390
第二次写入发生在第一次写入之后。
that that second write happens later than the first write.

1430
01:20:37,120 --> 01:20:39,790
这是一个日志，
And the reason that this is a log, correct,

1431
01:20:39,790 --> 01:20:43,000
因为这反映了还没有发生的写入的顺序。
because that basically reflects the order in which the writes haven't happened.

1432
01:20:44,090 --> 01:20:49,700
所以，你可以修改日志中的写入顺序，
And so you can really really nearly changed the order of the writes in the log,

1433
01:20:49,700 --> 01:20:54,680
因为这会产生了怪异的行为。
because that maybe actually result into bizarre behavior,

1434
01:20:54,980 --> 01:20:56,930
从用户程序的角度来看。
observable by user programs.

1435
01:20:58,120 --> 01:20:59,050
所以必须是这样的，
And so that has to be the case

1436
01:20:59,050 --> 01:21:03,730
你按操作发生的顺序进行提交，
that basically you commit you know the operations of these actions in the order they happened,

1437
01:21:05,240 --> 01:21:07,370
我们也按照发生的顺序执行写入。
we also perform the writes in the order they happened.

1438
01:21:09,250 --> 01:21:14,080
所以一般来说，它更安全，
And so in general you know, it's, it's safer,

1439
01:21:14,080 --> 01:21:16,510
把它们放在一起提交是安全的，
you know it's safe to basically commit them all together

1440
01:21:16,600 --> 01:21:17,680
总是保持良好的[]。
you're always in good [].

1441
01:21:18,510 --> 01:21:19,140
好的？
Okay?

1442
01:21:19,880 --> 01:21:20,690
好问题。
Good question, though.

1443
01:21:23,780 --> 01:21:27,560
好的，我想回来，看另一件事，
Okay I just want to go back to one more thing,

1444
01:21:27,800 --> 01:21:30,380
看看 begin_op ，虽然我说了一点，
and then look at the begin_op, yet I talked a little bit,

1445
01:21:30,380 --> 01:21:33,110
因为，之前我说现在不想谈论这个。
because like I don't want to talk about it right now.

1446
01:21:35,460 --> 01:21:39,280
但是，这里我们可以看到。
But, there we can see.

1447
01:21:41,000 --> 01:21:42,260
这里是 begin_op ，
So here's the begin_op,

1448
01:21:43,180 --> 01:21:47,080
首先，如果准备好提交日志，
first of all, if we're ready committing the log,

1449
01:21:47,080 --> 01:21:48,970
我们就等日志提交，
we're just gonna wait until the log has committed,

1450
01:21:49,000 --> 01:21:51,490
因为我们现在不能写入日志，
because you know we can't write to the log

1451
01:21:51,490 --> 01:21:53,260
在日志安装时。
while the log actually being installed.

1452
01:21:53,930 --> 01:21:58,280
如果我们结束了，
If we're end,

1453
01:21:58,400 --> 01:22:02,450
并发操作超过 logsize ，
concurrent operation that basically makes us go across the logsize,

1454
01:22:02,450 --> 01:22:03,680
我们可以进入睡眠状态，
we could go to sleep,

1455
01:22:05,080 --> 01:22:09,700
等待所有前面的并发事务完成，
and wait until basically all the preceding concurrent transactions are done,

1456
01:22:10,150 --> 01:22:12,700
如果我们被允许继续执行，
and if we're allowed to proceed

1457
01:22:12,730 --> 01:22:15,130
就是入口是允许的，
basically are entrance is allowed,

1458
01:22:15,250 --> 01:22:17,530
我们对 log.outstanding 加一，
we increase log.outstanding by 1,

1459
01:22:17,680 --> 01:22:18,970
因为它们反映了我们的情况，
because they reflect our thing

1460
01:22:18,970 --> 01:22:20,110
然后我们继续，
and then we basically proceed

1461
01:22:20,110 --> 01:22:21,790
并开始执行文件系统操作。
and start doing file system operations.

1462
01:22:22,920 --> 01:22:25,860
如果你再看一下 end_op ，为了。
And if you look at end_op again, just to.

1463
01:22:26,550 --> 01:22:30,420
所以，你可以看到 end_op 将 log.outstanding 减一，
So you see the end_op basically decreases log.outstanding by one,

1464
01:22:30,420 --> 01:22:32,010
因为一个事务完成了。
because one transaction is finished.

1465
01:22:32,590 --> 01:22:37,510
当然处于提交状态是错误的，引起 panic ，
It certainly would be an error in committing states, with panic in that case

1466
01:22:37,810 --> 01:22:41,380
如果我们是这组并发事务中的最后一个，
and we actually are the last one from that set of concurrent transactions,

1467
01:22:41,930 --> 01:22:44,510
而且 log.outstanding 是 0 ，
then, actually, and log.outstanding goes to 0,

1468
01:22:44,510 --> 01:22:45,560
我们就开始提交。
we immediately start committing.

1469
01:22:46,880 --> 01:22:48,170
然后当我们完成的时候，
And then when we're done,

1470
01:22:48,720 --> 01:22:52,410
我们，我们不是日志，
we're when actually, if we're not the log,

1471
01:22:52,500 --> 01:22:57,020
是的，我们提交。
yeah, yeah, we commit.

1472
01:22:59,460 --> 01:23:02,310
如果还有剩余空间，
And if there's space you know left,

1473
01:23:02,310 --> 01:23:03,180
我们会叫醒那个日志，
we wake up the guy,

1474
01:23:03,180 --> 01:23:04,530
这样就可以开始执行了。
so they can actually start running.

1475
01:23:06,380 --> 01:23:06,920
好的？
Okay?

1476
01:23:07,620 --> 01:23:09,990
所以即使这个极其简单的文件系统，
So even though this dirt simple file system,

1477
01:23:09,990 --> 01:23:13,110
xv6 的非常简单的日志系统，
that are just dirt simple logging system that xv6

1478
01:23:13,110 --> 01:23:15,180
也有一堆复杂的东西。
actually has a bunch of complications.

1479
01:23:18,160 --> 01:23:19,780
我的时间快到了，
So I'm starting to run out of time,

1480
01:23:19,780 --> 01:23:21,490
我就在这里结束吧。
so let me wrap up here.

1481
01:23:22,320 --> 01:23:23,640
所以总而言之，
So in summary,

1482
01:23:26,010 --> 01:23:29,850
我们谈论的是日志，
you know what we what we talk about is basically logging,

1483
01:23:30,600 --> 01:23:35,180
作为崩溃安全的解决方案，
as a solution for, for crash safety,

1484
01:23:35,890 --> 01:23:41,090
或者是多步文件系统操作的解决方案。
or really for multi-step file system operations.

1485
01:23:43,660 --> 01:23:46,420
到目前为止，
And you know if you've seen so far,

1486
01:23:46,510 --> 01:23:48,190
它对崩溃安全非常有效，
it works great for crash safety,

1487
01:23:48,190 --> 01:23:53,360
但是性能，这将是周一的主题，
but you know performance, and that's going to be the topic for Monday

1488
01:23:53,360 --> 01:23:57,950
当你阅读周一的 ext3 文件系统论文时，
and as you read the ext3 file system paper for Monday,

1489
01:23:58,100 --> 01:24:00,110
这是你应该考虑的事情。
you know that's the thing you should be thinking about.

1490
01:24:01,900 --> 01:24:03,730
好的，还有关于文件系统的问题吗？
Okay, any more file system questions?

1491
01:24:04,000 --> 01:24:07,180
任何要离开的人，请随意离开，
In fact anybody who has to leave, please feel free to leave,

1492
01:24:07,180 --> 01:24:11,290
但如果你还想再多问几个问题，那就继续。
but if you want to hang around and ask more questions, you know, please do so.

1493
01:24:14,510 --> 01:24:19,670
哦，我有一个关于缓存大小和日志大小的问题，
Oh, I have a question regarding cache size and the log size,

1494
01:24:19,760 --> 01:24:24,260
所以你说缓存大小必须大于日志大小，
so you said that the cache size has to be great as big as the log size,

1495
01:24:24,290 --> 01:24:28,130
但在这个示例中，它们的大小似乎是一样的，
but they seem to be the same size for this case,

1496
01:24:28,250 --> 01:24:35,530
所以这是否意味着如果日志放入 30 个缓存，
so is that means that if the log pins 30 buffers

1497
01:24:35,890 --> 01:24:38,920
然后一些其他操作试图做一些事情，
and then some other operation tries to do something,

1498
01:24:39,760 --> 01:24:40,600
它只是失败了，
it just fails,

1499
01:24:40,600 --> 01:24:47,440
因为缓存中的插槽没有空闲的。
because it it runs out of a free slots in the buffer.

1500
01:24:47,470 --> 01:24:51,340
不，也许我们来看看，
No, maybe let's let's look at the,

1501
01:24:52,830 --> 01:24:54,120
好的，那么，
okay, so,

1502
01:24:56,600 --> 01:24:58,130
让我先检查一件事。
let me first check one thing.

1503
01:25:02,590 --> 01:25:04,390
好的，我们看看 bio 。
Okay, let's go to bio.

1504
01:25:07,070 --> 01:25:08,240
好的。
Yeah, okay.

1505
01:25:10,240 --> 01:25:17,780
让我们首先检查 NBUF 是否大于 LOGSIZE ，
Let's actually first check NBUF is bigger than size of LOGSIZE, the buffer cache,

1506
01:25:17,780 --> 01:25:19,550
好的，它设置为某个大小。
okay, so it's set up to something big.

1507
01:25:20,610 --> 01:25:23,490
所以，如果我们找不到，会发生什么，
So what happens actually if we can't find,

1508
01:25:23,490 --> 01:25:24,930
bget 找不到缓存，
bget can't find a buffer,

1509
01:25:25,670 --> 01:25:26,780
实际会引起 panic 。
actually it's panics.

1510
01:25:28,840 --> 01:25:33,630
所以，我们，
And, so we we,

1511
01:25:33,630 --> 01:25:35,520
缓存里没有空闲的位置，
there's no free slot in the buffer cache,

1512
01:25:35,520 --> 01:25:36,600
xv6 引起 panic ，
you know xv6 panic,

1513
01:25:36,600 --> 01:25:37,890
这不是很理想，
that's not particularly ideal,

1514
01:25:37,920 --> 01:25:39,750
事实上会很糟糕，
in fact would be terrible

1515
01:25:39,930 --> 01:25:42,210
所以你希望永远不会出现这种情况，
and so you hope never to be in this situation

1516
01:25:42,210 --> 01:25:45,390
希望挑选正确的数字，不太可能发生。
and hopefully picked numbers correctly basically is unlikely to happen.

1517
01:25:46,040 --> 01:25:47,840
但是，为什么我们不能返回一个错误。
But why can't we return an error.

1518
01:25:49,520 --> 01:25:51,740
因为这似乎是最明显的做法，
Because that seems like the obvious thing to do, like,

1519
01:26:05,660 --> 01:26:07,520
如给给调用方返回一个错误，
if return an error to the caller

1520
01:26:07,520 --> 01:26:11,480
而调用方可能返回给文件系统接口，
and the caller maybe returns back up to the file system interface

1521
01:26:11,480 --> 01:26:14,150
只需要返回 -1 ，表示这个操作失败了。
and just return -1 saying like oh this operation failed.

1522
01:26:15,140 --> 01:26:17,630
为什么这是个问题？
Why is that a problem?

1523
01:26:21,060 --> 01:26:22,200
所以考虑这个是，
So ready to think about this is

1524
01:26:22,200 --> 01:26:26,460
许多文件系统操作都是多步操作，
that you know many file system operations are multi-step operations, right,

1525
01:26:27,030 --> 01:26:28,620
正如我们看到的，
as we've seen now,

1526
01:26:28,710 --> 01:26:31,440
在这节课和上一节课中，
in this lecture and in the previous lecture

1527
01:26:31,740 --> 01:26:37,050
比如，我们写了两次，然后写第三次，
and let's say, we did two writes and then the third write,

1528
01:26:37,080 --> 01:26:38,340
我们遇到了这样的情况，
we run into this case,

1529
01:26:38,790 --> 01:26:40,590
我们不能进行写入，
where we can't actually do the write,

1530
01:26:40,590 --> 01:26:42,600
因为块缓存里已经没有地方了，
because there's no place in the block cache,

1531
01:26:44,380 --> 01:26:46,390
我们已经写了两次了。
we have done two writes, right.

1532
01:26:47,380 --> 01:26:49,420
我们能不能跳出文件系统调用。
Can we just bail out of the file system call.

1533
01:26:53,760 --> 01:26:55,290
好的，我明白了。
Okay, I see right.

1534
01:26:55,500 --> 01:26:56,430
我们不能，
We cannot, correct,

1535
01:26:56,430 --> 01:27:03,710
因为我们可能已经更新某个文件的目录块，
because we might have updated to in the directory, directory block of some file,

1536
01:27:03,740 --> 01:27:06,320
如果我们需要更新某个目录中的目录块，
if we might have to update the directory block in some directory,

1537
01:27:06,350 --> 01:27:09,170
如果我们想让它工作，
and if we wanted to make this work,

1538
01:27:09,170 --> 01:27:11,900
我们需要做的就是撤销这些更改，
what we would have to do is undo those changes,

1539
01:27:11,930 --> 01:27:15,310
就像我们以前所做的任何写入一样，
like any writes that we did before,

1540
01:27:15,310 --> 01:27:17,260
作为系统调用的一部分，我们必须撤消。
as part of that system call, we have to undo.

1541
01:27:18,770 --> 01:27:20,180
好的。
Okay.

1542
01:27:20,180 --> 01:27:23,210
那很痛苦，这就是我们不做的原因。
That was painful, that's what we don't do it.

1543
01:27:24,270 --> 01:27:24,900
这能理解吗？
Does that make sense?

1544
01:27:25,640 --> 01:27:26,990
好的，所以这不是问题，
Okay so it's not a problem,

1545
01:27:26,990 --> 01:27:32,470
如果日志记录所有东西，
if the log the log pins everything

1546
01:27:32,920 --> 01:27:34,540
缓存中没有更多空间，
and there's no more space for cache,

1547
01:27:34,540 --> 01:27:36,820
但它只会引起 panic ，好的。
but it will just panic, okay.

1548
01:27:38,320 --> 01:27:39,970
是的，当然这种 panci 从来没有真正发生过，
Yeah, of course this panic never really happen,

1549
01:27:39,970 --> 01:27:43,510
只有极少数的情况可能会发生。
like there's a only corner cases where this hopefully happens.

1550
01:27:45,120 --> 01:27:46,080
我想你只是，
I guess you just,

1551
01:27:46,780 --> 01:27:48,400
好的，有道理，
okay, yeah, that makes sense,

1552
01:27:48,400 --> 01:27:49,990
好的，谢谢。
okay, thank you.

1553
01:27:51,940 --> 01:27:52,960
还有什么问题吗？
Any more questions?

1554
01:27:54,120 --> 01:27:55,440
我有个问题是关于，
I have a question about,

1555
01:27:55,470 --> 01:28:00,720
我想是关于我之前的组提交，
I guess following up my earlier one about the group commits,

1556
01:28:01,080 --> 01:28:03,690
我试着去想，
I was trying to think of,

1557
01:28:03,990 --> 01:28:06,060
我想我从高层级上理解了，
like I think I kind of understand it a high level,

1558
01:28:06,060 --> 01:28:06,930
我想确认一下，
I was trying to make sure,

1559
01:28:06,930 --> 01:28:11,160
我理解具体的例子，为什么它很重要，
I understand concrete example, why it is important

1560
01:28:11,160 --> 01:28:15,560
可能这是一个例子，展示了它，
and may is this an example that kind of demonstrates its,

1561
01:28:15,560 --> 01:28:17,960
我猜我在想这样一种情况，
like I guess I was thinking of a situation

1562
01:28:17,960 --> 01:28:22,790
你有，这可能是错综复杂的，
where you have say like this might be convoluted,

1563
01:28:22,790 --> 01:28:27,380
比如一个进程生成 1 到 n 的数字流，
like one process generating a stream of numbers like one to n

1564
01:28:27,680 --> 01:28:30,860
然后两个进程消耗，
and then two processes consuming,

1565
01:28:31,100 --> 01:28:33,470
可能它们在接收同一个管道，
that maybe they're listening on the same pipe,

1566
01:28:33,500 --> 01:28:37,910
比如 n 在一个偶数停止，
and say like n like stops an even number,

1567
01:28:38,060 --> 01:28:42,140
一个进程消耗并打印出奇数，
one process is consuming and printing out the odd numbers,

1568
01:28:42,140 --> 01:28:45,110
一个进程是消耗偶数部分，
one process is consuming part of the even numbers,

1569
01:28:45,380 --> 01:28:48,200
如果没有组提交，
and if you didn't have group commits,

1570
01:28:48,200 --> 01:28:50,000
那么正确的行为，
so like the correct behavior

1571
01:28:50,000 --> 01:28:54,230
比如它们打印写入同一个文件，
and say they're printing it for like their writing the same file,

1572
01:28:54,600 --> 01:28:57,900
所以正确的行为应该是
and so the correct behavior would be

1573
01:28:57,930 --> 01:29:00,030
在这一切结束的时候，
at the end of at the end of all this,

1574
01:29:00,030 --> 01:29:02,310
你可能希望文件含有偶数，
you would expect the file to have like an even number,

1575
01:29:02,430 --> 01:29:04,080
即最后一个数字，
like the last number,

1576
01:29:04,600 --> 01:29:06,370
但是如果你没有组提交，
but if you didn't have group commits,

1577
01:29:06,370 --> 01:29:13,810
可能倒数第二个进程在最后一个进程之后提交，
it's possible that the second to last process actually gets committed after the last one

1578
01:29:13,870 --> 01:29:14,920
并且它看到的是 9 ，
and it actually see nine,

1579
01:29:14,920 --> 01:29:17,920
这是不是一个正确的例子，为什么这很重要。
is just like a correct example, why this is important.

1580
01:29:17,920 --> 01:29:20,710
我想我得仔细考虑一下，
I think I have to think a little bit more carefully about it,

1581
01:29:20,800 --> 01:29:24,490
但这绝对是问题的症结所在，
but that is definitely the flavour of the problem,

1582
01:29:24,490 --> 01:29:27,040
如果重新排序系统调用，可能会遇到。
you might run into if you reorder system calls.

1583
01:29:28,290 --> 01:29:29,900
好的，好的。
Okay, okay.

1584
01:29:30,680 --> 01:29:33,500
我在讲稿中有一个很好的例子，
I have a great example in the lecture note,

1585
01:29:33,560 --> 01:29:35,990
讲稿中的，
if the lecture notes,

1586
01:29:35,990 --> 01:29:39,050
shell 命令的行为会变得奇怪，
you know shell command that really you know behave weirdly

1587
01:29:39,050 --> 01:29:39,980
if you didn't commit to,

1588
01:29:40,700 --> 01:29:42,740
这并不是组提交的问题，
this is not really an issue in some sense from group commit,

1589
01:29:42,740 --> 01:29:45,890
但确实是一个事务需要按顺序提交的问题。
is really an issue that transactions need to be committed in order.

1590
01:29:47,320 --> 01:29:49,520
嗯，我明白了，
Mhm, I see,

1591
01:29:49,610 --> 01:29:51,710
如果没有组提交，那么。
and group if it didn't have group commit, then.

1592
01:29:52,100 --> 01:29:54,140
是的，人们可能会想
Yeah, people might think

1593
01:29:54,140 --> 01:29:56,960
如果没有组提交，
like well what if you don't have group commit,

1594
01:29:56,960 --> 01:29:58,370
然后就会有一种情况，
then there's a temptation

1595
01:29:58,370 --> 01:30:00,410
就是提交一些后面的事务，
to basically you know commit some later transaction,

1596
01:30:00,410 --> 01:30:01,490
因为它已经完成了，
because it's already finished,

1597
01:30:01,490 --> 01:30:02,930
但是第一个还没有完成，
but the first one isn't finished yet,

1598
01:30:03,440 --> 01:30:04,850
为了创造空间，
and to create space,

1599
01:30:04,850 --> 01:30:05,900
但这不是解决方法。
but that's not a solution.

1600
01:30:07,490 --> 01:30:09,590
好的，理解了，
Okay, that makes sense,

1601
01:30:09,590 --> 01:30:12,140
在课堂上的什么地方有这个例子？
where in the lecture notes this example of?

1602
01:30:12,140 --> 01:30:12,770
我想是 shell 命令，
I think shell command,

1603
01:30:13,280 --> 01:30:16,460
说明了顺序是重要的。
where were illustrated by ordering is important.

1604
01:30:17,270 --> 01:30:17,690
好的。
Okay.

1605
01:30:17,810 --> 01:30:21,590
它不是直接与组提交关联的，
It doesn't, it doesn't tie it directly to a group commits,

1606
01:30:21,590 --> 01:30:24,740
但它说明了对系统调用进行排序很重要。
but it basically makes the point that ordering system calls is important.

1607
01:30:25,820 --> 01:30:28,850
我明白了，这是不是像文本那样。
I see, is this in the the like the text.

