1
00:00:00,450 --> 00:00:03,390
好的，下午好，无论你在哪里。

2
00:00:04,070 --> 00:00:05,690
嗯，大家都能听到我说话吗，

3
00:00:05,780 --> 00:00:07,580
快速测试一下语音。

4
00:00:09,580 --> 00:00:10,390
是的，是好的。

5
00:00:10,540 --> 00:00:11,440
好的，谢谢。

6
00:00:11,890 --> 00:00:15,640
那么今天我们就来谈一谈，

7
00:00:15,640 --> 00:00:17,500
我没有具体的日程安排，

8
00:00:17,500 --> 00:00:21,250
但基本上我们的计划是回答问题，

9
00:00:21,310 --> 00:00:25,690
你可能对上一个实验或之前的实验有什么问题。

10
00:00:26,330 --> 00:00:28,580
所以我要采取的方法是，

11
00:00:28,910 --> 00:00:33,720
今天，我要介绍一下我们的解决方案。

12
00:00:34,620 --> 00:00:37,260
尤其是我自己的解决方案，

13
00:00:37,710 --> 00:00:39,900
我会讨论一下它们，

14
00:00:40,050 --> 00:00:42,780
希望在我们讨论解决方案时，

15
00:00:43,180 --> 00:00:45,400
你可以打断，

16
00:00:45,400 --> 00:00:47,290
如果我没有回答某个问题，

17
00:00:47,530 --> 00:00:50,440
或者稍等一下，

18
00:00:50,440 --> 00:00:53,230
因为我把你们问的所有问题，

19
00:00:53,380 --> 00:00:55,630
至少在今天上午 11 点之前的，

20
00:00:55,750 --> 00:00:58,060
在最后的课堂讲稿中，

21
00:00:58,090 --> 00:01:00,070
我们会试着去全部过一遍。

22
00:01:03,240 --> 00:01:07,290
我将从页表（pagetable）实验开始，

23
00:01:07,750 --> 00:01:11,350
因为大多数问题都是关于页表的实验，

24
00:01:11,800 --> 00:01:14,590
部分原因是因为它是最难的实验。

25
00:01:15,450 --> 00:01:18,330
所以也许首先有几点解释，

26
00:01:18,330 --> 00:01:22,230
在深入到技术部分之前，

27
00:01:22,560 --> 00:01:26,520
我们来大体上谈一下页表实验。

28
00:01:30,380 --> 00:01:33,050
正如你可能观察到的，

29
00:01:33,050 --> 00:01:35,090
它实际上只有几行代码，

30
00:01:39,920 --> 00:01:42,350
在解决方案上，

31
00:01:42,440 --> 00:01:51,990
但是，不幸的是，必须调试问题。

32
00:01:55,160 --> 00:01:59,990
而且，有一个原因是，

33
00:01:59,990 --> 00:02:01,730
当 bug 真的出现时，

34
00:02:01,850 --> 00:02:05,150
结果是相当极端的，

35
00:02:05,210 --> 00:02:06,560
就像在最坏的情况下，

36
00:02:06,800 --> 00:02:09,500
可能你们中的一些人观察到了最坏的情况，

37
00:02:10,790 --> 00:02:13,490
QEMU 停止或 xv6 停止，

38
00:02:13,490 --> 00:02:17,090
不再打印输出，就是这样，

39
00:02:17,390 --> 00:02:20,930
你的工作就是找出到底哪里出了问题，

40
00:02:21,470 --> 00:02:24,620
在最好的情况下，你会遇到某种内核错误（kernel panic），

41
00:02:25,020 --> 00:02:28,260
取决于，也许这只是一个起点，

42
00:02:28,260 --> 00:02:32,520
或者追查问题的真正根源是错误本身，

43
00:02:32,960 --> 00:02:34,520
可能与其他什么有关，

44
00:02:34,520 --> 00:02:36,410
内核的一些常量被破坏，

45
00:02:36,500 --> 00:02:38,600
但你知道早些时候在外面的某个地方，

46
00:02:38,600 --> 00:02:40,190
可能在设置页表时，

47
00:02:40,190 --> 00:02:43,580
你做错了什么最后引起错误，

48
00:02:43,730 --> 00:02:46,130
你得追踪到底是怎么回事。

49
00:02:46,840 --> 00:02:50,710
所以代码行数更少，很难调试问题，

50
00:02:50,890 --> 00:02:55,720
在生产环境，恶劣的环境中去调试。

51
00:02:56,360 --> 00:03:00,020
如果你做内核调试或内核编程，

52
00:03:00,020 --> 00:03:02,480
你知道，编程环境，调试环境，

53
00:03:02,600 --> 00:03:04,700
更是，你知道的，恶劣的，

54
00:03:05,450 --> 00:03:07,340
正如 Robert 在第一节课中提到的，

55
00:03:07,340 --> 00:03:10,780
是做内核编程的难点之一。

56
00:03:12,900 --> 00:03:16,920
为了让你感觉好点，

57
00:03:16,920 --> 00:03:18,120
这不仅对你来说很难，

58
00:03:18,120 --> 00:03:19,830
你知道对我们来说也很难。

59
00:03:24,600 --> 00:03:26,220
无论是在帮助你方面，

60
00:03:26,220 --> 00:03:28,350
实际上我们做这些实验，

61
00:03:28,350 --> 00:03:29,670
我们也会遇到类似的问题，

62
00:03:29,850 --> 00:03:32,520
我们可能有更多的经验追踪 bug ，

63
00:03:32,760 --> 00:03:34,920
但是你知道它们确实需要时间。

64
00:03:35,400 --> 00:03:36,960
所以我们在帮你的时候，

65
00:03:36,960 --> 00:03:41,210
往往也很难，

66
00:03:41,210 --> 00:03:43,520
因为有一些很小的代码片段，

67
00:03:43,520 --> 00:03:45,650
有一个细节可能有问题，

68
00:03:45,710 --> 00:03:48,530
他们要弄清楚到底什么是小细节，

69
00:03:48,560 --> 00:03:49,760
这并不容易。

70
00:03:50,040 --> 00:03:51,810
当然有一些问题，

71
00:03:51,810 --> 00:03:53,550
我们以前见过，我们也认识到，

72
00:03:53,550 --> 00:03:55,740
例如，我们自己没有犯同样的错误，

73
00:03:55,830 --> 00:03:58,260
但是你们发现的其他一些，

74
00:03:58,260 --> 00:04:00,870
各种不同的破坏内核的方式，

75
00:04:00,930 --> 00:04:03,000
我们以前没见过的。

76
00:04:03,940 --> 00:04:05,470
所以这很难，

77
00:04:05,800 --> 00:04:09,850
根据我们的经验，

78
00:04:11,350 --> 00:04:14,380
对于虚拟内存，这在以往也总是很难，

79
00:04:19,470 --> 00:04:23,580
所以每次第一个虚拟内存实验出现的时候，

80
00:04:23,580 --> 00:04:26,610
不论在 6.S081 中或它的前身 6.828 中，

81
00:04:26,970 --> 00:04:28,710
事实就是这样

82
00:04:28,710 --> 00:04:30,720
你知道那往往是最难的实验，

83
00:04:31,020 --> 00:04:33,930
在所有实验室中，

84
00:04:33,930 --> 00:04:35,400
你知道的，原因有很多，

85
00:04:35,400 --> 00:04:37,080
一种是恶劣环境，

86
00:04:37,080 --> 00:04:39,870
这些 bug 很特殊，

87
00:04:40,110 --> 00:04:43,440
还有部分原因是你还没有

88
00:04:43,440 --> 00:04:45,300
很丰富的内核编程经验，

89
00:04:45,300 --> 00:04:46,860
所以这可以说是第一个实验，

90
00:04:46,860 --> 00:04:48,060
所有这些都结合在一起了。

91
00:04:48,740 --> 00:04:51,200
今年，我们试着让实验变得更简单，

92
00:04:51,200 --> 00:04:52,460
事实上，这是一个新的实验，

93
00:04:52,490 --> 00:04:54,680
一个我们之前没有的实验。

94
00:04:54,980 --> 00:04:56,720
希望实际上，

95
00:04:56,720 --> 00:05:00,470
使引入或转换到虚拟内存变得更容易，

96
00:05:00,800 --> 00:05:03,170
在某些方面我认为是成功的，

97
00:05:03,170 --> 00:05:04,730
在其他方面，这仍然很难，

98
00:05:05,390 --> 00:05:06,260
所以我们不太清楚，

99
00:05:06,260 --> 00:05:07,640
什么是最简单的方法，

100
00:05:07,640 --> 00:05:10,670
引入虚拟内存编程。

101
00:05:11,170 --> 00:05:16,480
下周的惰性分配实验，

102
00:05:16,510 --> 00:05:19,750
实际上曾经是第一个虚拟内存实验。

103
00:05:20,180 --> 00:05:23,540
我猜你们今年会发现，

104
00:05:23,540 --> 00:05:26,300
实验比去年的要容易，

105
00:05:26,420 --> 00:05:30,110
因为你现在在虚拟内存方面有了更多的背景知识。

106
00:05:33,100 --> 00:05:36,430
好的，所以这是一个很好的停止点，

107
00:05:36,430 --> 00:05:38,770
这里我想提出的几个高层次的观点，

108
00:05:38,770 --> 00:05:42,700
在跳到更具技术性和更多细节之前，

109
00:05:42,730 --> 00:05:45,940
所以，如果你有任何问题，现在就是提问题的好时机。

110
00:05:51,450 --> 00:05:52,920
好的。

111
00:05:53,280 --> 00:05:57,730
让我们，快点，你知道，你们中的一些人问到这个，

112
00:05:57,760 --> 00:06:02,980
非常快速地回顾一下具体设置是什么，

113
00:06:03,370 --> 00:06:07,820
所以，基本上，设置页表，

114
00:06:11,270 --> 00:06:16,440
我们在右边画出物理内存，

115
00:06:16,800 --> 00:06:22,260
你知道物理内存，包含部分设备，

116
00:06:23,920 --> 00:06:32,010
它们在这个 0x00 以及更多的零之上，

117
00:06:32,460 --> 00:06:34,710
然后这里是 DRAM 芯片。

118
00:06:37,780 --> 00:06:39,370
我们知道，

119
00:06:39,370 --> 00:06:44,650
QEMU 将内核文本数据放在这里，

120
00:06:45,730 --> 00:06:48,190
在 0x00 之上，

121
00:06:48,280 --> 00:06:49,540
这就是内核所在的地方，

122
00:06:49,660 --> 00:06:51,220
其中一种可能是，

123
00:06:51,730 --> 00:06:54,130
擦掉这个来使用内核。

124
00:06:54,600 --> 00:06:56,430
你知道从字面上它是什么意思，

125
00:06:56,430 --> 00:06:59,010
你知道这是什么，内核就是用户指令，

126
00:07:01,850 --> 00:07:05,300
是你已经看到的汇编指令的二进制版本，

127
00:07:05,480 --> 00:07:10,960
还有一些数据结构位于这些地址。

128
00:07:12,760 --> 00:07:14,800
好的，这就是内存的部分，

129
00:07:14,830 --> 00:07:18,130
然后在另一边，我们有 CPU ，

130
00:07:19,040 --> 00:07:20,390
它执行指令。

131
00:07:20,960 --> 00:07:23,240
CPU 有很多内部指令，

132
00:07:24,140 --> 00:07:26,030
并且有一些寄存器，

133
00:07:26,030 --> 00:07:30,500
你知道 x0 或 r0 等，

134
00:07:30,680 --> 00:07:32,960
还有程序计数器。

135
00:07:33,790 --> 00:07:36,100
你知道在 xv6 启动的时候，

136
00:07:36,100 --> 00:07:41,480
程序计数器包含值 Ox8000 。

137
00:07:44,920 --> 00:07:46,840
这就是它的方式，

138
00:07:46,840 --> 00:07:49,570
CPU 查看这个地址，

139
00:07:49,570 --> 00:07:51,280
找出第一条指令，

140
00:07:51,280 --> 00:07:53,620
它查看第一个指令并解码指令，

141
00:07:53,830 --> 00:07:56,650
然后更新需要更新的 CPU 状态。

142
00:07:58,280 --> 00:08:01,160
页表和其他一些组件，

143
00:08:01,250 --> 00:08:02,990
这个地址包含，

144
00:08:02,990 --> 00:08:09,360
CPU 命令或指令，

145
00:08:09,420 --> 00:08:11,460
比如，跳到某个特定的地址，

146
00:08:11,760 --> 00:08:17,320
并且这些地址通常是虚拟地址。

147
00:08:17,860 --> 00:08:23,410
这是虚拟地址，由 MMU 管理。

148
00:08:24,160 --> 00:08:26,530
然后转换成物理地址，

149
00:08:27,840 --> 00:08:31,860
并且索引到

150
00:08:32,010 --> 00:08:34,260
内存的 IO 部分，

151
00:08:34,260 --> 00:08:36,000
或者内存的 DRAM 部分。

152
00:08:40,040 --> 00:08:42,290
为了控制这个转换发生，

153
00:08:42,290 --> 00:08:44,390
你知道这里有 satp 寄存器，

154
00:08:46,570 --> 00:08:51,550
它包含页表的根地址，

155
00:08:51,580 --> 00:08:53,170
即当前运行的页表。

156
00:08:53,470 --> 00:08:54,550
如果是零，

157
00:08:55,410 --> 00:08:57,990
那么就不会进行转换，

158
00:08:58,170 --> 00:09:01,770
并且虚拟地址直接指向物理地址，

159
00:09:01,800 --> 00:09:03,600
因此，当处理器启动时，

160
00:09:03,870 --> 00:09:05,760
satp 中没有值，

161
00:09:05,760 --> 00:09:08,580
当程序计数器是 0x... 时，

162
00:09:08,580 --> 00:09:11,430
物理地址也是[]，

163
00:09:11,520 --> 00:09:16,200
CPU 从该特定位置获取指令。

164
00:09:17,260 --> 00:09:18,670
一旦，

165
00:09:19,720 --> 00:09:23,470
一旦 satp 包含非零值，

166
00:09:23,880 --> 00:09:28,920
那么，例如，可能，在这里的某个地方，

167
00:09:28,920 --> 00:09:31,410
把图片延伸一些，

168
00:09:31,740 --> 00:09:37,740
我们知道内核实际上最多有 128 兆字节。

169
00:09:38,350 --> 00:09:40,480
所以基本上这些都是空闲内存，

170
00:09:40,480 --> 00:09:44,080
从这里到这里是空闲内存，

171
00:09:44,560 --> 00:09:49,300
空闲内存放在 kalloc.c 中的列表中，

172
00:09:49,300 --> 00:09:50,200
像你之前看到的那样。

173
00:09:50,940 --> 00:09:54,930
并且，这里的某个地方也是根页表，

174
00:09:54,960 --> 00:09:56,910
你知道的，内核页表，

175
00:09:56,940 --> 00:09:58,440
可能这里有一些页面，

176
00:09:58,860 --> 00:10:05,170
是根页表目录。

177
00:10:06,280 --> 00:10:08,770
一旦我们加载该值，

178
00:10:08,800 --> 00:10:11,410
该值对应的物理地址，

179
00:10:11,410 --> 00:10:14,290
进入 satp 地址和寄存器，

180
00:10:14,290 --> 00:10:21,260
假设这个地址是 0x7ff... ，

181
00:10:21,260 --> 00:10:23,480
一个低于 120 兆字节的地址，

182
00:10:23,480 --> 00:10:25,250
所以在内存空闲空间中，

183
00:10:25,550 --> 00:10:28,190
在 satp 中地址，

184
00:10:28,630 --> 00:10:34,490
然后，在这时，处理器或 MMU

185
00:10:34,640 --> 00:10:37,280
将使用根页表执行

186
00:10:37,280 --> 00:10:40,130
从虚拟地址到物理地址的转换。

187
00:10:41,670 --> 00:10:44,880
你可以把这整个东西，

188
00:10:45,090 --> 00:10:47,310
像是一个盒子，

189
00:10:47,310 --> 00:10:49,890
你知道，将它们整合在一起。

190
00:10:51,860 --> 00:10:53,720
你对这张高层次图片有问题吗，

191
00:10:53,720 --> 00:10:57,270
在继续之前，

192
00:10:57,420 --> 00:10:59,610
所以这里要记住的一个关键点是，

193
00:10:59,610 --> 00:11:02,610
页面状态本身也驻留在内存中。

194
00:11:08,500 --> 00:11:09,070
好吧。

195
00:11:11,090 --> 00:11:13,610
好的，那我们跳到，

196
00:11:14,520 --> 00:11:17,790
页表实验的第一部分，

197
00:11:17,790 --> 00:11:21,350
也就是第一部分，

198
00:11:21,350 --> 00:11:28,550
为 init 程序打印页表，

199
00:11:28,730 --> 00:11:35,640
你知道的，解释基本上都在图 3.4 ，

200
00:11:35,640 --> 00:11:37,710
图 3.4 就在这里。

201
00:11:39,980 --> 00:11:41,870
图 3.4 ，

202
00:11:41,870 --> 00:11:44,630
这是图 3.4 ，显示用户地址空间，

203
00:11:44,780 --> 00:11:46,940
让我们看看的用户地址空间，

204
00:11:46,940 --> 00:11:49,160
在进入细节之前，

205
00:11:49,160 --> 00:11:50,600
我们在底部有文本，

206
00:11:50,600 --> 00:11:53,480
这就是程序的指令，

207
00:11:53,570 --> 00:11:55,550
从地址 0 开始，

208
00:11:55,550 --> 00:12:00,590
上方是数据、全局变量，驻留在那里，

209
00:12:00,590 --> 00:12:03,170
然后我们会讨论守护页，

210
00:12:03,170 --> 00:12:06,320
然后是用户程序的堆栈，

211
00:12:06,320 --> 00:12:08,810
内核有自己的堆栈，

212
00:12:08,810 --> 00:12:09,860
多个堆栈，

213
00:12:10,190 --> 00:12:12,020
用户程序有自己的堆栈，

214
00:12:12,230 --> 00:12:15,800
缓冲区，也就是所谓堆内存，空闲内存，

215
00:12:15,920 --> 00:12:20,450
我们可以使用 sbrk 获得更多内存，

216
00:12:20,450 --> 00:12:25,210
sbrk 基本上指向用户地址空间的顶部，

217
00:12:25,210 --> 00:12:26,200
我们想要增加它，

218
00:12:26,290 --> 00:12:29,740
我们调用 sbrk 系统调用

219
00:12:29,770 --> 00:12:33,430
来增加底部部分，

220
00:12:33,430 --> 00:12:35,350
你知道增加到堆里去，

221
00:12:35,830 --> 00:12:39,460
我们还从上一节课中知道，顶端，

222
00:12:39,460 --> 00:12:40,600
有两个页面，

223
00:12:40,600 --> 00:12:44,950
两个特别的页面， trampoline 和 trapframe 页面。

224
00:12:45,260 --> 00:12:48,170
trampoline 页包含了命令，

225
00:12:48,170 --> 00:12:49,730
进出内核的转换的命令，

226
00:12:50,030 --> 00:12:54,140
trapframe 是一个很方便的地方，

227
00:12:54,140 --> 00:12:59,330
存储一些状态，当我们跳入内核时，

228
00:12:59,330 --> 00:13:01,400
因为我们就需要内核，一旦使用寄存器，

229
00:13:01,400 --> 00:13:02,420
我们可以使用寄存器，

230
00:13:02,420 --> 00:13:05,210
因为用户空间程序还有一些在使用。

231
00:13:06,140 --> 00:13:08,270
我不会太多谈论 tramframe 和 trampoline ，

232
00:13:08,270 --> 00:13:09,440
你知道的，它们在这里。

233
00:13:10,340 --> 00:13:14,300
好的，在这张图片的下面一点，

234
00:13:14,300 --> 00:13:18,910
你知道就在那里，是打印出来的，

235
00:13:18,910 --> 00:13:21,640
当我运行它时，从 init 打印出来的。

236
00:13:22,420 --> 00:13:26,380
这是 exec 的第一次成功调用，

237
00:13:26,380 --> 00:13:29,170
我们知道 init 代码中有一些 exec 系统调用，

238
00:13:29,410 --> 00:13:33,340
对于程序 init ，正好在 exec 的末尾，

239
00:13:33,340 --> 00:13:34,630
我们打印出那个页表。

240
00:13:35,460 --> 00:13:38,340
有几个我们可以观察到的东西，

241
00:13:38,550 --> 00:13:40,530
关于这个特殊的页表，

242
00:13:40,770 --> 00:13:42,840
首先，

243
00:13:42,840 --> 00:13:46,800
除了打印出物理 pte ，

244
00:13:46,800 --> 00:13:49,200
物理地址也打印出了标志。

245
00:13:50,040 --> 00:13:53,070
你可以看到，这里的标志是 1 ，

246
00:13:53,280 --> 00:13:55,110
基本上就是这个转换，

247
00:13:55,110 --> 00:14:00,060
或者这个中间页像这个一样，

248
00:14:00,210 --> 00:14:02,250
是有效的独立页，

249
00:14:02,250 --> 00:14:05,940
这对应于二级页面，

250
00:14:05,970 --> 00:14:08,370
然后第二个对应于……。

251
00:14:12,110 --> 00:14:14,150
我很抱歉我刚才画错了箭头，

252
00:14:14,150 --> 00:14:16,010
所以我暂停一下。

253
00:14:17,210 --> 00:14:20,030
在顶端，这是顶层页表，

254
00:14:20,580 --> 00:14:24,210
这个，指向这个特定的页表，

255
00:14:24,650 --> 00:14:28,250
这个，指向那个特定的页表。

256
00:14:29,180 --> 00:14:32,900
或者这就是地址，我们使用一种速记，用来表示，

257
00:14:33,140 --> 00:14:36,830
这是特定页面的基础地址。

258
00:14:37,310 --> 00:14:41,420
你知道，这些页面有 4096 字节，

259
00:14:41,750 --> 00:14:43,730
大小是页的大小，

260
00:14:43,790 --> 00:14:48,050
除以 64 会得到 512 个条目。

261
00:14:49,200 --> 00:14:54,630
好的，我们看这个地址空间的底部部分。

262
00:14:55,020 --> 00:15:01,720
对于 init ，实际上只有有三个页面，

263
00:15:02,080 --> 00:15:03,730
我们做几件事，

264
00:15:03,730 --> 00:15:06,550
可以把这三页区分出来。

265
00:15:06,840 --> 00:15:12,300
我们知道，底部页面对应虚拟地址零，

266
00:15:12,450 --> 00:15:16,530
这个物理地址， 87f640 。

267
00:15:17,080 --> 00:15:19,900
你可以从我们之前的图片中知道，

268
00:15:19,900 --> 00:15:23,680
那就在空闲内存中的某个地方，

269
00:15:23,860 --> 00:15:26,980
内核可以从中分配页面。

270
00:15:28,330 --> 00:15:30,970
最后你看到的是标志，

271
00:15:31,180 --> 00:15:32,830
我们看到标志 1f ，

272
00:15:33,040 --> 00:15:38,080
所以它意味着读取位设置，

273
00:15:38,080 --> 00:15:40,270
有效位设置，读取位设置，写位设置，执行位设置，用户位设置，

274
00:15:41,500 --> 00:15:45,280
所以这个页面可以同时包含数据和文本，

275
00:15:45,570 --> 00:15:49,290
这些权限允许用户程序

276
00:15:49,320 --> 00:15:53,130
在对应的内存执行指令，

277
00:15:53,340 --> 00:15:55,050
并从用户空间执行。

278
00:15:56,700 --> 00:15:58,620
好的，那么也许最有趣的问题是，

279
00:15:58,620 --> 00:15:59,910
第一页有什么问题。

280
00:16:00,660 --> 00:16:02,220
作为一个提示，

281
00:16:02,220 --> 00:16:05,070
你知道，第一页只有 f ，

282
00:16:05,070 --> 00:16:06,360
而没有设置 u 标志位。

283
00:16:06,850 --> 00:16:09,460
所以，你知道第一页是什么吗。

284
00:16:11,880 --> 00:16:12,540
有人知道吗。

285
00:16:15,370 --> 00:16:16,690
是不是守护页。

286
00:16:16,900 --> 00:16:18,970
是的，是守护页。

287
00:16:19,360 --> 00:16:21,520
守护页映射到，

288
00:16:21,580 --> 00:16:23,050
因为它包含 v 标志，

289
00:16:23,050 --> 00:16:24,850
而没有设置 u 标志，

290
00:16:24,850 --> 00:16:27,670
所以任何用户指令试图，

291
00:16:27,700 --> 00:16:30,430
因此，如果用户程序运行超过它的堆栈，

292
00:16:30,430 --> 00:16:33,170
堆栈从顶部向下增长，

293
00:16:33,170 --> 00:16:34,910
所以即使它真的有更多，

294
00:16:35,540 --> 00:16:37,880
堆栈足够大，可以容纳 4096 ，

295
00:16:38,030 --> 00:16:42,080
然后用户程序，你知道的，把东西放到到堆栈上，

296
00:16:42,080 --> 00:16:44,840
堆栈在[]上，它将增长到守护页。

297
00:16:45,140 --> 00:16:46,880
并且因为没有设置 u 标志位，

298
00:16:47,120 --> 00:16:50,720
我们会在内核中得到页面错误或陷阱，

299
00:16:51,020 --> 00:16:56,900
因为 MMU 不能转换地址到，

300
00:16:56,930 --> 00:17:02,120
不能将守护页上的地址转换为物理地址，

301
00:17:02,360 --> 00:17:05,150
因为没有设置 u 标志位，

302
00:17:05,150 --> 00:17:06,500
这会禁止转换。

303
00:17:08,560 --> 00:17:10,060
好的，第二页是什么。

304
00:17:15,740 --> 00:17:19,080
有人知道吗？

305
00:17:19,710 --> 00:17:20,490
堆栈？

306
00:17:20,550 --> 00:17:21,990
是的，这是堆栈页，

307
00:17:22,470 --> 00:17:26,160
堆栈页有 4096 字节，

308
00:17:26,430 --> 00:17:29,760
你会看到，对于权限，这是精心设计的。

309
00:17:30,290 --> 00:17:32,210
它包含所有权限，

310
00:17:32,630 --> 00:17:35,390
我们能不能把它的权限调得更严格一些。

311
00:17:38,230 --> 00:17:42,100
是的，我想可以禁用执行位。

312
00:17:42,390 --> 00:17:45,960
是的，你可以，对 x 位来说，

313
00:17:46,230 --> 00:17:49,920
这将禁止运行堆栈上任何程序代码。

314
00:17:50,750 --> 00:17:53,690
所以，如果你在运行时生成代码并将其放入堆栈，

315
00:17:53,690 --> 00:17:55,010
你就不能去执行，

316
00:17:55,310 --> 00:17:56,900
你知道这可能是件好事。

317
00:17:57,710 --> 00:18:00,380
所以我们可以把权限设置更严格一些。

318
00:18:01,350 --> 00:18:02,940
好的。

319
00:18:03,820 --> 00:18:07,270
所以这是这个的最下面的部分，

320
00:18:07,990 --> 00:18:09,400
页表，

321
00:18:09,400 --> 00:18:11,920
现在让我们来看看剩下的条目，

322
00:18:12,070 --> 00:18:14,170
只剩下两个条目了。

323
00:18:14,560 --> 00:18:18,850
也许标志位是最能说明问题的部分。

324
00:18:19,150 --> 00:18:27,930
这里的 7 ，表示可读，可写，可用。

325
00:18:29,340 --> 00:18:33,790
那么这个是什么，

326
00:18:33,790 --> 00:18:35,440
也许我先分析另一个页的权限，

327
00:18:35,860 --> 00:18:38,950
b 是 1001 （误：应该是 1011），

328
00:18:38,950 --> 00:18:40,600
设置了 x 和可用位，

329
00:18:41,680 --> 00:18:43,990
那么 511 是什么呢？

330
00:18:48,890 --> 00:18:49,550
有人知道吗。

331
00:18:54,070 --> 00:18:56,560
trampoline 和 trap 页面？

332
00:18:57,520 --> 00:19:02,410
对，那么， 511 可能是 trampoline ，

333
00:19:02,410 --> 00:19:04,090
因为它设置了 x 位，

334
00:19:04,360 --> 00:19:05,470
所以我们可以执行，

335
00:19:05,470 --> 00:19:08,680
或者我们允许从该页面执行指令。

336
00:19:08,910 --> 00:19:10,350
所以这一定是 trampoline ，

337
00:19:10,650 --> 00:19:15,380
我们允许对那个页面进行读写，

338
00:19:15,380 --> 00:19:16,820
所以这可能就是 trapframe 页面，

339
00:19:16,820 --> 00:19:21,240
因为这是我们用来恢复和保存寄存器的那个页。

340
00:19:22,230 --> 00:19:26,790
好的，需要注意的一件重要的事是，

341
00:19:26,790 --> 00:19:29,580
这里没有设置 u 标志位，

342
00:19:29,580 --> 00:19:30,750
那么这意味着什么呢，

343
00:19:30,750 --> 00:19:34,230
这意味着用户程序不能执行指令，

344
00:19:34,500 --> 00:19:38,400
页 510 作为 trampoline 页面，

345
00:19:38,900 --> 00:19:40,790
也不能对该页的写入。

346
00:19:41,300 --> 00:19:44,090
因此，只有内核可以从那里执行指令，

347
00:19:44,090 --> 00:19:45,470
而且它只能读写。

348
00:19:47,510 --> 00:19:51,470
所以内核要做这件事，

349
00:19:51,680 --> 00:19:53,810
当用户页表还在使用时，

350
00:19:53,810 --> 00:19:54,920
是不是这个意思。

351
00:19:55,190 --> 00:19:58,310
使得，正如你所知道的， Robert 在上节课中讲解的，

352
00:19:58,370 --> 00:20:01,100
这就是从用户到内核的过渡，

353
00:20:01,100 --> 00:20:02,090
在我们跳到之前，

354
00:20:02,330 --> 00:20:06,200
在我们将内核页表加载到 satp 寄存器之前，

355
00:20:06,230 --> 00:20:07,310
我们需要，

356
00:20:07,340 --> 00:20:10,250
内核需要一些内存来完成它的工作。

357
00:20:11,990 --> 00:20:12,560
好的。

358
00:20:13,200 --> 00:20:13,980
所以在一些事情上，

359
00:20:13,980 --> 00:20:16,680
这张图片有意思的地方。

360
00:20:17,040 --> 00:20:20,640
是的，所有的地址都是 87f630 ，

361
00:20:20,640 --> 00:20:22,290
87f620 ， 87f640 ， 87f610 ，

362
00:20:22,320 --> 00:20:24,630
这些页面或内存

363
00:20:24,750 --> 00:20:28,470
在内核内存范围内，

364
00:20:28,470 --> 00:20:30,720
它们是空闲的。

365
00:20:31,260 --> 00:20:42,940
那么这些地址在物理内存中是连续的吗？

366
00:20:47,040 --> 00:20:47,700
有人知道吗。

367
00:20:49,270 --> 00:20:50,680
不是，它们不一定连续。

368
00:20:51,430 --> 00:20:53,440
不，它们不一定连续，是的，

369
00:20:53,440 --> 00:20:56,320
你知道吗，看这个， 87f6400 ，

370
00:20:56,320 --> 00:20:57,220
如果是连续的，

371
00:20:57,220 --> 00:21:01,270
下一个地址应该是 87f6500 ，

372
00:21:01,270 --> 00:21:02,080
但事实并非如此。

373
00:21:02,680 --> 00:21:06,610
所以关于页表的一个很酷的事情是，

374
00:21:06,730 --> 00:21:10,480
尽管你使用的虚拟地址空间是连续的，

375
00:21:10,510 --> 00:21:11,890
物理地址空间，

376
00:21:11,920 --> 00:21:15,700
或与连续虚拟地址对应的物理页面，

377
00:21:15,760 --> 00:21:17,620
不一定是连续的。

378
00:21:17,880 --> 00:21:19,890
因此，这给了内核很大的灵活性，

379
00:21:19,980 --> 00:21:24,000
在分配和释放页面方面。

380
00:21:25,050 --> 00:21:25,620
好的。

381
00:21:26,910 --> 00:21:28,860
关于第一部分，有什么问题吗。

382
00:21:29,980 --> 00:21:30,850
我有一个问题。

383
00:21:30,970 --> 00:21:31,270
嗯。

384
00:21:32,470 --> 00:21:34,900
你能稍微解释一下 sbrk 吗，

385
00:21:35,020 --> 00:21:38,440
如果我们要在未来的讲座中介绍，

386
00:21:38,440 --> 00:21:40,840
那么也许我们可以先讲一点。

387
00:21:40,870 --> 00:21:42,580
对，其实我们，

388
00:21:42,580 --> 00:21:44,020
我将在星期三谈论它。

389
00:21:44,340 --> 00:21:46,710
这实际上是惰性分配实验的话题。

390
00:21:47,320 --> 00:21:50,650
那么我可能在星期三回答这个问题，

391
00:21:50,650 --> 00:21:53,830
如果到时候还不太清楚，请再问一遍。

392
00:21:54,470 --> 00:21:55,520
好的，谢谢。

393
00:21:57,530 --> 00:21:59,840
有一个问题。

394
00:22:00,170 --> 00:22:05,650
所以，我记得书上说，

395
00:22:05,650 --> 00:22:09,610
trampoline 和 trapframe 位于地址空间的顶部。

396
00:22:11,140 --> 00:22:16,720
而在这里，它位于第一个根页面，

397
00:22:16,720 --> 00:22:19,870
索引是 255 而不是 511 。

398
00:22:20,050 --> 00:22:22,510
好问题，很好，很高兴你问我。

399
00:22:22,510 --> 00:22:26,290
我在 Q&A 问题中看到了，我打算讨论一下，

400
00:22:26,290 --> 00:22:27,070
但是，我忘了。

401
00:22:27,540 --> 00:22:29,280
所以，是的，这里发生了什么，

402
00:22:29,310 --> 00:22:31,560
为什么是 255 而不是 511 。

403
00:22:33,180 --> 00:22:37,590
我们总说 trampoline 位于地址空间的顶端，

404
00:22:37,590 --> 00:22:40,800
它所在的地址空间的顶部，

405
00:22:40,830 --> 00:22:45,030
你知道的，指向顶级目录的 511 条目，

406
00:22:45,690 --> 00:22:47,190
而现在只是 255 。

407
00:22:49,400 --> 00:22:52,250
有人知道为什么是这样吗？

408
00:22:52,610 --> 00:22:54,110
我们说过有一位，

409
00:22:54,320 --> 00:22:57,260
我们要用但其实没有使用的，

410
00:22:57,260 --> 00:23:00,260
因为符号扩展问题，也是为了让它变得更容易，

411
00:23:00,260 --> 00:23:01,910
并且我们不需要那么多内存。

412
00:23:02,480 --> 00:23:04,820
是的，这就是正确的答案，

413
00:23:04,820 --> 00:23:08,000
所以这是愚蠢的技术细节，

414
00:23:08,210 --> 00:23:11,870
所以虚拟地址原则上，

415
00:23:11,930 --> 00:23:14,060
我觉得是 39 位，

416
00:23:14,760 --> 00:23:19,260
但是实际上在 xv6 中，只有 38 个，

417
00:23:20,260 --> 00:23:24,550
因此，顶端的 MAXVA ，

418
00:23:24,580 --> 00:23:27,160
它是 255 条目。

419
00:23:28,080 --> 00:23:29,850
我们不使用 39 位的原因是，

420
00:23:29,850 --> 00:23:32,940
没有特别好的理由，

421
00:23:33,150 --> 00:23:36,660
基本上，如果你设置了第 39 位，

422
00:23:37,190 --> 00:23:42,140
则 64 位地址中的所有剩余位必须为 1 。

423
00:23:42,840 --> 00:23:44,910
我们不想处理这个问题，

424
00:23:44,910 --> 00:23:46,290
如果我们设置了 39 ，

425
00:23:46,290 --> 00:23:49,800
我们也要设置 40 41 42 43 等，

426
00:23:49,830 --> 00:23:50,730
直到 64 。

427
00:23:55,050 --> 00:23:57,210
所以这是解释，能理解吗。

428
00:23:58,370 --> 00:23:58,760
嗯。

429
00:24:00,010 --> 00:24:02,470
这是一个非常好的观察。

430
00:24:04,600 --> 00:24:09,370
我也有一个问题，为什么文本和数据在同一页上。

431
00:24:09,720 --> 00:24:11,280
也是一个很好的问题。

432
00:24:11,370 --> 00:24:12,660
这看起来很愚蠢，

433
00:24:12,660 --> 00:24:14,700
我的意思是为什么不把它们放在单独的页面上，

434
00:24:14,700 --> 00:24:17,340
这样你才能更仔细地设置权限。

435
00:24:18,140 --> 00:24:20,240
主要原因是，

436
00:24:20,240 --> 00:24:22,820
我们这样做是为了简单。

437
00:24:23,150 --> 00:24:25,340
通常 exec 更复杂，

438
00:24:25,370 --> 00:24:27,380
我们想 exec 尽可能简单。

439
00:24:29,210 --> 00:24:35,050
真正的操作系统不会在同一页中包含数据和文本，

440
00:24:35,140 --> 00:24:36,970
事实上，我们必须指定，

441
00:24:36,970 --> 00:24:40,240
如果你查看 makefile 中加载器标志，

442
00:24:40,240 --> 00:24:42,940
你会看到，它有 -N 选项，

443
00:24:42,940 --> 00:24:44,710
它强制数据和文本，

444
00:24:44,710 --> 00:24:48,160
在一个连续的，而不是在单独的页面中。

445
00:24:53,530 --> 00:24:54,730
关于这个，还有什么问题吗。

446
00:24:55,480 --> 00:24:57,130
我有一个后续问题，

447
00:24:57,130 --> 00:24:59,590
关于我们使用的位数。

448
00:24:59,950 --> 00:25:02,860
你说我们只用了 38 位，

449
00:25:03,430 --> 00:25:08,470
硬件仍然提供给我们使用 39 位，

450
00:25:08,470 --> 00:25:12,730
但是我们设计操作系统使用 38 位。

451
00:25:13,100 --> 00:25:13,520
嗯。

452
00:25:14,160 --> 00:25:14,970
所以我们，

453
00:25:14,970 --> 00:25:19,680
如果机器有超过 2 的 38 次方的内存，

454
00:25:20,160 --> 00:25:22,170
我们就不能用那些内存了。

455
00:25:22,710 --> 00:25:25,050
现在我们运行的，我们假设的，

456
00:25:25,050 --> 00:25:28,380
内存远少于 2 的 38 次方，

457
00:25:28,380 --> 00:25:29,700
所以这对我们来说没什么影响。

458
00:25:30,290 --> 00:25:32,960
但是如果是真正的操作系统，我们会做得更好。

459
00:25:36,350 --> 00:25:37,580
所以，只是为了简单。

460
00:25:38,930 --> 00:25:41,210
我们想让你尽可能轻松，

461
00:25:41,210 --> 00:25:43,340
尽可能少阅读代码。

462
00:25:46,890 --> 00:25:47,490
好的。

463
00:25:48,450 --> 00:25:49,650
是的，理解了。

464
00:25:50,750 --> 00:25:54,650
好的，那么现在，让我们切换到第二部分。

465
00:25:55,610 --> 00:25:58,520
让我们来看一张图片，

466
00:25:58,520 --> 00:25:59,990
你可能看了很多次。

467
00:26:00,380 --> 00:26:02,810
内核地址空间，

468
00:26:02,810 --> 00:26:05,300
左边是虚拟地址空间，

469
00:26:05,300 --> 00:26:06,950
右边是物理内存，

470
00:26:07,440 --> 00:26:10,620
你知道这里是 IO 设备，

471
00:26:11,080 --> 00:26:14,110
从这里开始是 DRAM ，

472
00:26:16,090 --> 00:26:24,960
直到 128 兆字节。

473
00:26:24,990 --> 00:26:26,010
因为我们假设，

474
00:26:26,010 --> 00:26:29,730
内存不超过 250（误） 128 兆字节。

475
00:26:30,140 --> 00:26:32,630
所以这部分物理内存就是空闲内存。

476
00:26:33,840 --> 00:26:35,940
从那里开始，这是内核，

477
00:26:36,270 --> 00:26:38,790
哎呀，我画错了。

478
00:26:39,510 --> 00:26:41,040
让我更小心一点，

479
00:26:41,430 --> 00:26:47,480
这里我们有内核文本和数据。

480
00:26:48,160 --> 00:26:53,230
然后上面的内存，就是内核分配器拥有的内存，

481
00:26:53,350 --> 00:26:56,050
从那里我们为用户程序分配内存，

482
00:26:56,050 --> 00:26:58,240
我们为页表等分配内存。

483
00:26:58,330 --> 00:26:59,620
内核为它们分配所有，

484
00:27:00,680 --> 00:27:01,910
直到内存耗尽，

485
00:27:01,910 --> 00:27:04,760
当它用完时，它会达到 128 兆字节，

486
00:27:04,760 --> 00:27:07,400
然后它开始返回错误或系统调用。

487
00:27:08,680 --> 00:27:09,220
好的。

488
00:27:10,490 --> 00:27:16,340
好的，那么让我把第一部分做好，

489
00:27:16,340 --> 00:27:19,820
从某种意义上说，这是任务的第二部分，

490
00:27:19,850 --> 00:27:27,080
就是运行或者复制内核页表，

491
00:27:27,080 --> 00:27:32,150
而且每个进程都有自己的内核页表。

492
00:27:33,060 --> 00:27:37,170
这就是这里的任务，

493
00:27:37,170 --> 00:27:38,850
所以让我进入代码，

494
00:27:38,850 --> 00:27:40,200
让我实际看几件事，

495
00:27:40,580 --> 00:27:42,320
关于它的，更一般的事情。

496
00:27:43,800 --> 00:27:45,180
所以第二部分。

497
00:27:51,160 --> 00:27:56,260
也许你头脑中的第一个问题是，

498
00:27:56,260 --> 00:27:58,600
在某些方面你做了一些微不足道的事，

499
00:27:58,600 --> 00:28:00,100
我们已经有了内核页表，

500
00:28:00,130 --> 00:28:01,900
我们只需复制[]个副本，

501
00:28:02,170 --> 00:28:04,150
每个进程一个副本。

502
00:28:04,690 --> 00:28:07,990
你可能会说，这能有多难，

503
00:28:08,050 --> 00:28:10,990
因为几个原因，这是有些难度的。

504
00:28:11,400 --> 00:28:13,620
一些好的原因，一些不太好的原因，

505
00:28:14,440 --> 00:28:16,120
它比看起来要难。

506
00:28:20,500 --> 00:28:22,600
一个原因是，

507
00:28:22,630 --> 00:28:28,290
xv6 代码很特别，

508
00:28:28,590 --> 00:28:30,120
针对一个内核页表。

509
00:28:39,080 --> 00:28:43,010
你在 kvminit 中看到的。

510
00:28:43,500 --> 00:28:48,240
是的，所以这就有点一概而论，

511
00:28:48,240 --> 00:28:49,590
你知道这需要一些工作，

512
00:28:49,590 --> 00:28:51,660
因为你必须修改 xv6 代码。

513
00:28:54,580 --> 00:28:57,550
如你所见， kvminit 不是完全，

514
00:28:58,360 --> 00:29:02,080
为内核构建页表。

515
00:29:02,230 --> 00:29:04,390
也有一些在 procinit 中，

516
00:29:04,710 --> 00:29:07,620
它添加映射到内核页表。

517
00:29:08,010 --> 00:29:10,830
甚至有一些在 virtio_disk 。

518
00:29:12,040 --> 00:29:14,560
真正与内核页表进行交互。

519
00:29:16,000 --> 00:29:18,850
所以内核中没有唯一的地方，

520
00:29:18,850 --> 00:29:21,430
用于构建内核页表。

521
00:29:22,450 --> 00:29:25,990
第三个原因，为什么这有些复杂，

522
00:29:25,990 --> 00:29:27,640
因为你还得做清理工作。

523
00:29:29,200 --> 00:29:32,920
因为有一个创建这些副本的方面，

524
00:29:32,980 --> 00:29:35,260
所以每次用户进程退出时，

525
00:29:35,560 --> 00:29:39,880
我们还要清理那些使用过的页表，

526
00:29:40,000 --> 00:29:43,390
因为我们希望将它们放回到空闲内存池中，

527
00:29:43,390 --> 00:29:44,650
好让我们以后可以使用它们，

528
00:29:44,800 --> 00:29:46,870
以便我们可以继续运行进程。

529
00:29:48,340 --> 00:29:49,510
这就是那里发生的事情。

530
00:29:51,240 --> 00:29:52,740
这让事情变得有些复杂，

531
00:29:52,740 --> 00:29:54,600
因为我们必须要小心，

532
00:29:54,600 --> 00:29:57,360
在释放内核页表

533
00:29:57,390 --> 00:29:59,040
或内核页表的副本时，

534
00:29:59,220 --> 00:30:00,390
我们当然不想

535
00:30:00,390 --> 00:30:03,450
释放仍在使用中的内存，

536
00:30:03,450 --> 00:30:06,270
或别的页表仍在使用的页表条目。

537
00:30:06,920 --> 00:30:08,150
所以我们得小心，

538
00:30:08,720 --> 00:30:12,860
然后，你知道，很容易出现错误。

539
00:30:14,320 --> 00:30:16,840
当你复制那些页表时。

540
00:30:17,370 --> 00:30:19,800
如果你[得到]一点东西，

541
00:30:19,800 --> 00:30:21,930
你会得到一个很难的 bug 。

542
00:30:24,300 --> 00:30:27,750
这里的一个问题是，我之前说过，

543
00:30:27,960 --> 00:30:30,690
困难的 bug 出现的时间要晚得多。

544
00:30:30,940 --> 00:30:32,470
你已经构建了内核页表，

545
00:30:32,470 --> 00:30:34,540
构建了内核页表的副本，

546
00:30:34,940 --> 00:30:38,090
一切看起来都很好，你装入 satp 寄存器，

547
00:30:38,390 --> 00:30:41,810
甚至内核会运行一小段时间，然后才死机。

548
00:30:42,480 --> 00:30:44,640
结果发现死机的原因，

549
00:30:44,640 --> 00:30:48,120
因为你在页表中犯了个小错误，

550
00:30:48,150 --> 00:30:49,560
在很久很久以前。

551
00:30:49,990 --> 00:30:51,370
所以这就是为什么

552
00:30:51,370 --> 00:30:55,300
它会让内核编程很困难。

553
00:30:56,950 --> 00:30:59,290
你知道，这些困难的 bug ，

554
00:30:59,290 --> 00:31:02,110
基本上都很费时间去追踪。

555
00:31:11,630 --> 00:31:13,520
因为发生的时候，

556
00:31:13,610 --> 00:31:16,820
其实不是 bug 的真正原因，

557
00:31:16,820 --> 00:31:18,350
但是真正的原因，

558
00:31:18,350 --> 00:31:21,590
是你之前设置页表时的某个地方。

559
00:31:23,840 --> 00:31:25,250
好的。

560
00:31:26,310 --> 00:31:28,320
所以结果是，

561
00:31:28,500 --> 00:31:30,360
有两种方法解决这个问题，

562
00:31:30,570 --> 00:31:35,480
你知道，这个实验可以采用两种解决方案。

563
00:31:38,850 --> 00:31:41,250
事实上，你们中的一些人可能混合使用它们，

564
00:31:41,610 --> 00:31:45,750
第一个方法是 copy 方法。

565
00:31:47,550 --> 00:31:51,330
copy 方法从字面上复制内核页表，

566
00:31:51,840 --> 00:31:56,400
所以每次你都需要一个新的内核页表，

567
00:31:56,520 --> 00:31:58,800
你为页表分配页面，

568
00:31:58,800 --> 00:32:02,130
你为它们填充数据，等等。

569
00:32:02,920 --> 00:32:09,150
还有一种方法，第二种方法是，

570
00:32:09,180 --> 00:32:15,890
共享内核页表，

571
00:32:15,890 --> 00:32:18,200
在这种情况下，你要做的是

572
00:32:18,200 --> 00:32:22,460
不是创建一个内核页表的干净副本，

573
00:32:22,700 --> 00:32:26,630
而是共享不会修改的所有条目。

574
00:32:27,300 --> 00:32:29,010
你从任务中知道，

575
00:32:29,010 --> 00:32:32,610
基本上从 CLINT 到 PLIC 地址以上的任何内容，

576
00:32:32,610 --> 00:32:35,280
实际上是不变的，

577
00:32:35,310 --> 00:32:36,960
那里没有你要加载的东西。

578
00:32:37,290 --> 00:32:38,910
在第三部分，

579
00:32:39,060 --> 00:32:40,290
你知道，基本上，

580
00:32:40,440 --> 00:32:43,980
从零开始的所有条目可能是相同的，

581
00:32:44,130 --> 00:32:45,990
所以你可以分享这些条目。

582
00:32:47,020 --> 00:32:50,770
这两种方法都很好。

583
00:32:51,080 --> 00:32:54,950
没有明确的，哪一个更好。

584
00:32:55,100 --> 00:32:57,890
我的解决方案，采取这种方法（共享方法）。

585
00:32:58,240 --> 00:33:02,770
我没有很好的理由，

586
00:33:02,800 --> 00:33:06,970
除了可能部分原因是可以偷懒。

587
00:33:07,210 --> 00:33:08,560
我不想想太多，

588
00:33:08,590 --> 00:33:10,210
内核页表中有什么，

589
00:33:10,210 --> 00:33:13,000
所以我想出所有东西保持不变，

590
00:33:13,210 --> 00:33:14,710
为什么复制它们，

591
00:33:14,710 --> 00:33:17,540
或者复制 pte ，

592
00:33:17,690 --> 00:33:19,280
然后我不得不认真考虑，

593
00:33:19,280 --> 00:33:21,470
这实际上不是内核地址空间的一部分。

594
00:33:22,480 --> 00:33:25,570
这会导致更少代码，

595
00:33:25,570 --> 00:33:26,800
但是我不确定，

596
00:33:26,800 --> 00:33:28,900
比复制解决方案更少。

597
00:33:29,510 --> 00:33:31,130
但重要的是要认识到，

598
00:33:31,130 --> 00:33:35,390
有两种不同的方法来解决这个特定问题。

599
00:33:35,990 --> 00:33:40,340
在这两种情况下，无论你用什么方法，

600
00:33:40,340 --> 00:33:42,380
都有某种实施策略。

601
00:33:42,850 --> 00:33:45,130
你知道我使用的实施策略，

602
00:33:45,130 --> 00:33:47,200
对于几乎任何内核程序，

603
00:33:47,200 --> 00:33:50,140
都是按部就班地做所有事情。

604
00:33:53,120 --> 00:33:55,880
所以我可能，在我的脑海里有一个总的计划，

605
00:33:55,880 --> 00:33:57,440
关于我是如何从头走到尾的，

606
00:33:57,440 --> 00:33:59,660
我要做的所有改变，

607
00:33:59,870 --> 00:34:01,880
但是一旦我开始做这些改变，

608
00:34:01,910 --> 00:34:03,770
我先做一两个，

609
00:34:03,950 --> 00:34:06,350
然后确保它们起作用，

610
00:34:06,350 --> 00:34:08,650
然后继续往前走，

611
00:34:09,160 --> 00:34:11,080
我做的另一件事是，

612
00:34:11,080 --> 00:34:14,110
主要是保留现有代码，

613
00:34:17,750 --> 00:34:21,170
不是修改最初的代码，

614
00:34:21,380 --> 00:34:24,860
我是添加代码，并切换到新代码，

615
00:34:25,040 --> 00:34:26,780
然后[按部就班]，

616
00:34:26,780 --> 00:34:27,770
我这么做的原因是，

617
00:34:27,770 --> 00:34:30,290
我可以很容易地比较新旧代码，

618
00:34:30,620 --> 00:34:33,260
我总是有一个有效的旧解决方案，

619
00:34:33,260 --> 00:34:34,790
我可以直接回到过去，

620
00:34:35,000 --> 00:34:36,980
如果发生了一些奇怪的错误，

621
00:34:36,980 --> 00:34:40,850
然后我可以后退一步，然后再试一次，

622
00:34:40,850 --> 00:34:43,580
所以就像我说的，那样知道我的推理是错的。

623
00:34:44,540 --> 00:34:48,380
小步走，部分原因是，

624
00:34:48,380 --> 00:34:49,940
这些 bug 太难追踪了。

625
00:34:52,960 --> 00:34:58,150
好的，让我切换到代码，

626
00:34:58,300 --> 00:35:02,380
从 vm.c 开始。

627
00:35:02,470 --> 00:35:07,870
这是现有的 kvminit ，

628
00:35:08,290 --> 00:35:11,410
每个人都可以看到代码吗？

629
00:35:14,650 --> 00:35:20,360
好的，任务要求我们

630
00:35:20,360 --> 00:35:22,700
对它（内核页表）做一个副本，

631
00:35:22,970 --> 00:35:26,420
我做的方式是，

632
00:35:26,420 --> 00:35:28,040
让我看看在哪里。

633
00:35:39,820 --> 00:35:41,650
这是我的 uvmcreate ，

634
00:35:41,680 --> 00:35:43,330
那只是无聊的部分，

635
00:35:43,330 --> 00:35:47,110
基本上就是创建分配顶级页目录，

636
00:35:47,110 --> 00:35:49,240
还有 l2 页目录。

637
00:35:49,760 --> 00:35:52,490
然后这里是我的 kvm- ，

638
00:35:52,490 --> 00:35:55,070
相当于 kvminit 。

639
00:35:55,520 --> 00:35:58,370
我在这里获得了顶部的页目录，

640
00:35:58,910 --> 00:36:00,410
在这个位置。

641
00:36:00,710 --> 00:36:07,640
然后，我会复制从内核页表前 511 个条目，

642
00:36:07,640 --> 00:36:11,630
它已经由 kvminit 设置好，

643
00:36:11,630 --> 00:36:15,320
这给了我大部分的内核页表。

644
00:36:15,630 --> 00:36:19,650
然后，我需要映射所有设备，

645
00:36:19,650 --> 00:36:25,270
它们在这里 0 号条目。

646
00:36:25,300 --> 00:36:27,940
因为 0 号条目，我们稍后要修改它，

647
00:36:27,940 --> 00:36:30,250
或者我们会将用户页面映射到底部。

648
00:36:30,760 --> 00:36:34,330
有几个设备在 0 号条目中，

649
00:36:34,330 --> 00:36:39,040
那些的设备需要添加到，

650
00:36:39,040 --> 00:36:42,760
每个进程的内核页表。

651
00:36:44,140 --> 00:36:47,560
所以我回到前面的这张图片上。

652
00:36:51,260 --> 00:36:54,920
让我再次设置内核页表，

653
00:36:56,790 --> 00:37:01,440
可能这张图片跟任何都一样，

654
00:37:01,440 --> 00:37:03,450
所以如果你考虑我的解决方案，

655
00:37:03,600 --> 00:37:10,950
基本上这些条目我只是与现有内核页表共享，

656
00:37:11,250 --> 00:37:15,360
所以我不需要分配任何 l1 或 l2 或 l0 级别，

657
00:37:15,540 --> 00:37:17,130
它们已经存在了，

658
00:37:17,130 --> 00:37:21,180
我唯一做的就是字面意思上的复制 pte 条目。

659
00:37:22,160 --> 00:37:27,500
所以只有底部部分或底部条目，

660
00:37:27,500 --> 00:37:32,480
我需要真正重建或复制，而不只是复制 pte 。

661
00:37:32,850 --> 00:37:38,200
这就覆盖了底部的 1G 字节的地址空间。

662
00:37:39,000 --> 00:37:42,330
在一页中包含 4096 。

663
00:37:45,930 --> 00:37:50,700
所以这个条目包含 512 。

664
00:37:51,060 --> 00:37:53,370
这（最右边的）是 2 兆字节了。

665
00:37:54,360 --> 00:37:55,770
而这（中间的）是一千兆字节，

666
00:37:56,280 --> 00:37:58,950
所以只有一个条目，我需要填充它。

667
00:38:01,810 --> 00:38:02,530
能理解吗?

668
00:38:05,370 --> 00:38:08,760
回到我的代码，基本上，

669
00:38:09,180 --> 00:38:11,220
这就是我所做的一切， kvmcreate 。

670
00:38:12,090 --> 00:38:18,510
在我的 kvmfree 中是清理方案，

671
00:38:18,720 --> 00:38:20,820
但我充分利用了这些知识，

672
00:38:20,820 --> 00:38:24,990
我不需要对条目 1 到 511 做任何事情，

673
00:38:24,990 --> 00:38:26,400
在顶级页目录中。

674
00:38:26,730 --> 00:38:28,920
唯一要处理的条目是

675
00:38:28,920 --> 00:38:33,450
内核顶级目录的底部条目。

676
00:38:33,790 --> 00:38:36,730
它指向一个 l1 条目，

677
00:38:36,730 --> 00:38:39,730
那个 l1 条目，我只需要遍历，

678
00:38:39,940 --> 00:38:44,470
释放旧的 l2 或 l0 条目。

679
00:38:45,010 --> 00:38:46,870
然后，释放 l1 ，

680
00:38:46,870 --> 00:38:47,950
然后是内核页表。

681
00:38:49,420 --> 00:38:53,290
这就是我的 kvmfree 和 kvmcreate 。

682
00:38:54,050 --> 00:38:57,230
这样我就可以创建内核页表进程，

683
00:38:57,230 --> 00:39:01,030
然后在使用完成后释放。

684
00:39:02,360 --> 00:39:03,470
抱歉，提个小问题。

685
00:39:03,710 --> 00:39:05,180
您能再解释一下，

686
00:39:05,180 --> 00:39:09,470
为什么只使用 1 到 512 而不使用 0 ？

687
00:39:10,360 --> 00:39:10,900
是。

688
00:39:10,930 --> 00:39:14,110
好的，那么，

689
00:39:14,110 --> 00:39:17,470
也许最容易的是，让我回到这里的图片。

690
00:39:19,860 --> 00:39:22,470
所以我们有一个内核地址空间。

691
00:39:26,240 --> 00:39:31,970
这个 Ox8000 等等，

692
00:39:32,220 --> 00:39:33,180
在，嗯。

693
00:39:34,270 --> 00:39:38,560
在顶层页面目录中， Ox0 属于哪个条目。

694
00:39:46,150 --> 00:39:47,200
比如。

695
00:39:49,340 --> 00:39:50,240
0 号条目？

696
00:39:50,540 --> 00:39:52,400
不，不是 0 号条目。

697
00:39:53,440 --> 00:39:56,680
所以你知道 0 号条目，

698
00:39:56,680 --> 00:39:58,570
这个条目包含多少？

699
00:40:02,450 --> 00:40:03,320
多少地址空间，

700
00:40:03,320 --> 00:40:07,490
顶层页面目录的底部条目即 0 号条目包含多少。

701
00:40:10,140 --> 00:40:12,690
我认为 CLINT 是

702
00:40:12,690 --> 00:40:16,740
在 0 到 0x2000 之间。

703
00:40:17,730 --> 00:40:19,200
是的，也许我会这么做，

704
00:40:19,200 --> 00:40:20,910
我认为你的方向是正确的，

705
00:40:20,910 --> 00:40:23,790
所以最下面的条目复制了一千兆字节。

706
00:40:24,750 --> 00:40:27,630
我们知道，也许我可以。

707
00:40:29,630 --> 00:40:34,400
我们看到最下面的条目是一千兆字节，

708
00:40:36,860 --> 00:40:39,620
在那一千兆字节有 CLINT 和 PLIC ，

709
00:40:40,380 --> 00:40:44,040
我相信还有 UART 和 VIRTIO_disk 。

710
00:40:44,500 --> 00:40:51,340
然后 KERNBASE 位于一个更高的条目上。

711
00:40:51,340 --> 00:40:52,660
我们可以计算一下，

712
00:40:52,660 --> 00:40:54,700
我们可以取 0x80- ，

713
00:40:54,700 --> 00:40:58,400
移位 12 ，移位 9 ，移位 9 ，

714
00:40:58,640 --> 00:41:03,200
我想，我不记得顶部是什么了。

715
00:41:04,420 --> 00:41:06,940
试着弄清楚，也许我们来试一试。

716
00:41:08,270 --> 00:41:10,430
在演讲中这样做总是有[风险]的，

717
00:41:10,430 --> 00:41:15,970
所以， gdb 。

718
00:41:16,240 --> 00:41:22,190
我们来看看 memlayout.h ，这是 KERNBASE ，

719
00:41:29,240 --> 00:41:31,760
所以我们可以打印。

720
00:41:32,800 --> 00:41:39,430
移位是 12 ，这给了我们，偏移量。

721
00:41:39,430 --> 00:41:40,000
哎呀。

722
00:41:46,280 --> 00:41:51,280
好的，然后我们移位这个值。

723
00:41:51,980 --> 00:41:53,240
我想你可以看到这个。

724
00:41:54,600 --> 00:41:55,470
九。

725
00:41:56,740 --> 00:41:59,890
现在再做一次，

726
00:42:01,480 --> 00:42:02,440
所以这是条目 2 。

727
00:42:03,880 --> 00:42:04,570
能理解吗。

728
00:42:06,270 --> 00:42:08,760
所以我们回到这里来看图片。

729
00:42:11,260 --> 00:42:14,680
KERNBASE 是条目 2 ，

730
00:42:15,400 --> 00:42:18,780
在顶级页目录中。

731
00:42:18,780 --> 00:42:22,680
我们从作业的第三部分了解到，

732
00:42:22,680 --> 00:42:26,990
我们不需要考虑 PLIC 上面的任何东西。

733
00:42:28,480 --> 00:42:32,260
所有这些东西上都在条目 0 。

734
00:42:34,390 --> 00:42:34,990
好的?

735
00:42:36,560 --> 00:42:38,060
所以这回答了之前的问题。

736
00:42:39,620 --> 00:42:40,520
好的，谢谢。

737
00:42:42,860 --> 00:42:46,130
好的，现在我们要做的还剩下的就是，

738
00:42:46,130 --> 00:42:52,860
再次检查调用函数 kvmcreate 的地方，

739
00:42:53,340 --> 00:42:59,910
这将是 allocproc 。

740
00:43:01,270 --> 00:43:03,720
所以，并且。

741
00:43:06,820 --> 00:43:07,240
哎呀。

742
00:43:12,460 --> 00:43:14,470
这里是新进程初始化的地方，

743
00:43:14,470 --> 00:43:17,740
我相信你们都是一样的，

744
00:43:17,740 --> 00:43:21,820
当你在 proc 结构中声明字段时，

745
00:43:22,120 --> 00:43:25,210
它的结果，我们放在内核页表中。

746
00:43:27,080 --> 00:43:29,030
好的，我们需要考虑的另一件事是，

747
00:43:29,030 --> 00:43:30,770
当然我们需要使用页表，

748
00:43:31,150 --> 00:43:34,180
所以，我们需要查看调度器。

749
00:43:34,600 --> 00:43:37,300
基本上，任务多少会告诉你做什么，

750
00:43:37,660 --> 00:43:41,530
在切换到用户进程之前，

751
00:43:41,530 --> 00:43:43,360
你需要切换内核页表，

752
00:43:43,720 --> 00:43:48,610
意味着加载进程内核页表到 satp 。

753
00:43:49,020 --> 00:43:54,060
然后当你完成切换来运行另一个进程，

754
00:43:54,060 --> 00:43:55,770
你从另一个进程返回，

755
00:43:55,770 --> 00:43:57,540
然后你回到并运行调度程序，

756
00:43:57,750 --> 00:44:00,480
你必须切换回主内核页表，

757
00:44:00,980 --> 00:44:02,930
[]内核页表，

758
00:44:02,930 --> 00:44:04,940
因为这才是调度器实际使用的。

759
00:44:07,260 --> 00:44:08,790
为什么我们做这个切换，

760
00:44:09,030 --> 00:44:10,080
为什么这很重要。

761
00:44:16,820 --> 00:44:17,480
有人知道吗？

762
00:44:19,820 --> 00:44:21,950
因为它选择了正确的内核页表，

763
00:44:22,460 --> 00:44:26,030
因为 satp ，当你转到页表条目时，

764
00:44:26,060 --> 00:44:26,930
它选择了，

765
00:44:27,700 --> 00:44:29,980
它选择了正确的页表。

766
00:44:30,770 --> 00:44:36,870
嗯，稍等一下。

767
00:44:40,210 --> 00:44:43,780
是的，所以好的，当我们停下来的时候。

768
00:44:44,210 --> 00:44:46,130
好的，让我换一种方式问这个问题，

769
00:44:46,520 --> 00:44:48,470
这个内核页表是什么时候释放的。

770
00:44:52,000 --> 00:44:53,590
当用户进程完成时，

771
00:44:53,590 --> 00:44:55,000
所以如果我们不交换（页表），

772
00:44:55,000 --> 00:44:56,380
那就意味着，

773
00:44:56,770 --> 00:45:00,430
我们可以使用一个被释放进程的页表，

774
00:45:00,430 --> 00:45:02,260
页表被释放了，

775
00:45:02,470 --> 00:45:05,470
所以，我们不想依赖于当前未运行的进程。

776
00:45:05,710 --> 00:45:09,520
没错，我们永远不能释放当前正在运行的进程的页表。

777
00:45:10,400 --> 00:45:12,410
所以我们要有一个计划，

778
00:45:12,440 --> 00:45:16,250
在进程不再运行时释放它们。

779
00:45:16,860 --> 00:45:19,500
wait 系统调用是我们的退出方式，

780
00:45:19,500 --> 00:45:22,260
wait 系统调用查看有没有子进程，

781
00:45:22,260 --> 00:45:25,020
决定是不是可以清理。

782
00:45:25,350 --> 00:45:26,520
然后把它们清理掉。

783
00:45:27,190 --> 00:45:29,830
也就是说，

784
00:45:29,950 --> 00:45:33,340
当父进程切换进程时，

785
00:45:33,340 --> 00:45:36,460
我们必须保证，

786
00:45:36,860 --> 00:45:39,830
satp 寄存器中加载的页表，

787
00:45:40,040 --> 00:45:42,350
不是，

788
00:45:42,530 --> 00:45:46,090
不是那个将要释放的进程页表。

789
00:45:47,030 --> 00:45:49,700
也可能根本没有进程在运行，

790
00:45:50,150 --> 00:45:52,520
所以调度器有它自己的页表，

791
00:45:52,790 --> 00:45:55,250
所以，所有进程都可以被清理。

792
00:45:59,410 --> 00:46:00,070
能理解吗？

793
00:46:05,860 --> 00:46:07,450
抱歉，我有个问题，

794
00:46:07,480 --> 00:46:12,490
你是不是把 CLINT 映射到

795
00:46:12,970 --> 00:46:16,270
新的进程内核页表中了？

796
00:46:18,030 --> 00:46:18,750
为什么？

797
00:46:18,840 --> 00:46:23,610
因为任务说的我只需要，

798
00:46:24,000 --> 00:46:28,710
用户进程不会比 CLINT 更大，好像是的。

799
00:46:29,460 --> 00:46:33,110
当我映射 PLIC 和 CLINT 时，

800
00:46:33,110 --> 00:46:35,540
我认为任务告诉我们，

801
00:46:36,020 --> 00:46:37,430
什么是最低的那个。

802
00:46:37,460 --> 00:46:41,700
我想 PLIC 是最低的那个，

803
00:46:41,700 --> 00:46:42,840
这告诉我们，

804
00:46:42,840 --> 00:46:47,590
用户进程不会大于 PLIC 地址。

805
00:46:47,590 --> 00:46:48,190
好的。

806
00:46:50,940 --> 00:46:51,900
只是为了简单，

807
00:46:51,960 --> 00:46:52,800
我们可以，

808
00:46:53,490 --> 00:46:55,230
想让它对你来说尽可能简单，

809
00:46:55,230 --> 00:46:57,810
当然，你愿意的话，可以做得更好。

810
00:46:59,260 --> 00:47:02,470
但是，你知道这是最简单的事情。

811
00:47:03,500 --> 00:47:05,750
所以，你需要做一些修改才能让它正常工作。

812
00:47:11,640 --> 00:47:12,660
还有什么问题吗？

813
00:47:13,700 --> 00:47:14,660
我有一个问题，

814
00:47:15,740 --> 00:47:20,570
能不能复制 0 到 512 ，

815
00:47:20,600 --> 00:47:22,190
然后每次切换时，

816
00:47:22,190 --> 00:47:25,580
仍在使用，比如全局根页表，

817
00:47:25,610 --> 00:47:28,820
除了复制第一个根页表，

818
00:47:29,480 --> 00:47:31,820
每次切换进程时，

819
00:47:31,820 --> 00:47:35,960
都复制用户地址到。

820
00:47:36,290 --> 00:47:36,980
是的。

821
00:47:36,980 --> 00:47:38,270
能不能这么做。

822
00:47:39,040 --> 00:47:40,720
理论上，我认为你可以这样做，

823
00:47:40,720 --> 00:47:44,050
所以，不是分配一个进程，再释放它，

824
00:47:44,050 --> 00:47:47,110
你可以在调度程序切换期间动态执行。

825
00:47:47,920 --> 00:47:52,450
嗯，看起来很复杂。

826
00:47:53,270 --> 00:47:55,100
那可能花费更多，

827
00:47:55,100 --> 00:47:58,910
因为，这意味着每次在两个进程之间切换时，

828
00:47:58,910 --> 00:48:02,240
你可能必须复制内核页表的一部分。

829
00:48:02,870 --> 00:48:06,170
所以这可能对性能有影响，

830
00:48:06,170 --> 00:48:07,250
不是一件理想的事情。

831
00:48:07,640 --> 00:48:11,150
任务没有说任何关于它的事，

832
00:48:11,180 --> 00:48:14,090
如果你这样做了，它可能在 usertests 中超时。

833
00:48:18,070 --> 00:48:19,240
是的，我只是想知道，

834
00:48:19,240 --> 00:48:20,350
因为我试过那个方法，

835
00:48:20,350 --> 00:48:22,450
这是一次糟糕的经历，

836
00:48:22,480 --> 00:48:23,890
我想知道这是否可行。

837
00:48:23,890 --> 00:48:27,520
我可以想象的到，但是我认为理论上是可行的，

838
00:48:27,520 --> 00:48:30,850
你可以每次分配新的页表并切换，

839
00:48:31,980 --> 00:48:33,390
并在切换出来的时候释放它。

840
00:48:38,820 --> 00:48:39,720
我不认为这很简单，

841
00:48:39,720 --> 00:48:41,850
但是，你知道，我认为理论上是可行的。

842
00:48:43,410 --> 00:48:45,960
可能对 xv6 做一些其他修改。

843
00:48:48,760 --> 00:48:49,630
还有其他问题吗？

844
00:48:56,660 --> 00:48:57,920
当然另一个改变是，

845
00:48:57,920 --> 00:48:59,720
必须要改的是 usertrapret ，

846
00:48:59,810 --> 00:49:00,890
你必须确保，

847
00:49:00,890 --> 00:49:05,310
你使用进程内核页表运行。{}进程内核页表。

848
00:49:07,390 --> 00:49:07,960
好的？

849
00:49:09,390 --> 00:49:10,980
好的，那我们切换到，

850
00:49:10,980 --> 00:49:12,510
第三部分。

851
00:49:15,420 --> 00:49:21,800
切换回这里。

852
00:49:24,470 --> 00:49:25,340
好的，那么，

853
00:49:25,340 --> 00:49:28,160
这可能不是一张有帮助的图片。

854
00:49:30,620 --> 00:49:31,610
好的，第三部分。

855
00:49:36,820 --> 00:49:39,460
所以基本上我们的计划是，

856
00:49:39,460 --> 00:49:43,250
我们有像之前一样的内核页表，

857
00:49:43,790 --> 00:49:47,480
我们有 PLIC 条目在某个地方。

858
00:49:48,420 --> 00:49:49,830
我们要做的是，

859
00:49:49,830 --> 00:49:53,400
我们将使用 PLIC 下面的所有东西，

860
00:49:53,690 --> 00:49:58,320
来保存用户页表，

861
00:49:58,380 --> 00:50:01,740
我们将把用户页表映射到所有的用户程序中，

862
00:50:01,740 --> 00:50:03,990
用户程序实际上在内核页表中，

863
00:50:05,180 --> 00:50:05,870
在底部。

864
00:50:09,240 --> 00:50:10,560
这就是我们的目标，

865
00:50:10,590 --> 00:50:12,600
第一个要问的问题是，

866
00:50:12,600 --> 00:50:15,360
为什么[]要这么做。

867
00:50:16,180 --> 00:50:18,340
这样有什么好处吗，

868
00:50:18,340 --> 00:50:20,830
我觉得可能，

869
00:50:20,860 --> 00:50:22,510
这可能是一种简单的方式

870
00:50:22,510 --> 00:50:25,970
来理解为什么它很有趣，

871
00:50:26,150 --> 00:50:28,220
是[]与 copyin 比较。

872
00:50:28,930 --> 00:50:31,000
新 copyin 和旧 copyin 。

873
00:50:32,790 --> 00:50:37,270
所以，如果， copyin 发生了什么，

874
00:50:37,270 --> 00:50:42,760
copyin 将数据从用户空间复制到内核地址空间。

875
00:50:43,590 --> 00:50:51,240
但是如果内核没有用户地址映射。

876
00:50:51,760 --> 00:50:57,470
内核必须在这时分配这个页，

877
00:50:57,470 --> 00:51:00,350
因为虚拟地址空间中的页面可以是连续的，

878
00:51:00,350 --> 00:51:02,450
尽管对于物理地址空间，它们不是连续的。

879
00:51:02,990 --> 00:51:04,910
内核在 copyin 上所做的，

880
00:51:04,910 --> 00:51:10,590
将虚拟用户地址转换为物理地址。

881
00:51:11,490 --> 00:51:16,110
由于内核具有所有物理内存映射，

882
00:51:16,320 --> 00:51:21,030
物理地址[也是]有效的内核虚拟地址，

883
00:51:21,270 --> 00:51:24,260
然后它移动那一页的部分，

884
00:51:24,260 --> 00:51:26,690
那些需要复制的物理页。

885
00:51:27,960 --> 00:51:29,460
如果某个数据结构，

886
00:51:29,460 --> 00:51:33,150
跨越两个个页面边界，

887
00:51:33,150 --> 00:51:36,390
比如，在实验 2 中使用的 sysinfo 结构，

888
00:51:36,390 --> 00:51:39,060
可能跨越页表边界，

889
00:51:39,300 --> 00:51:41,010
它会复制，比如可能是，

890
00:51:41,010 --> 00:51:43,530
第一个物理页的一些字节，

891
00:51:43,620 --> 00:51:46,290
然后是第二物理页的一些字节。

892
00:51:48,160 --> 00:51:48,820
这个能理解吗。

893
00:51:52,180 --> 00:51:53,950
这就是内核 copyin 所做的，

894
00:51:54,010 --> 00:51:56,590
目标是让它们使用新的 copyin ，

895
00:51:57,850 --> 00:52:04,650
使内核程序不必担心物理布局，

896
00:52:04,650 --> 00:52:06,990
不占用用户地址空间。

897
00:52:07,430 --> 00:52:09,350
这个新 copyin ，

898
00:52:09,350 --> 00:52:10,850
我们可以看到基本上什么都不做，

899
00:52:10,850 --> 00:52:13,040
没有其他东西，只是复制，

900
00:52:13,360 --> 00:52:17,620
从用户地址直接到内核。

901
00:52:18,020 --> 00:52:20,720
而且我们也不再需要调用 walk 了，

902
00:52:20,930 --> 00:52:22,730
因为我们可以依赖，

903
00:52:22,730 --> 00:52:24,170
我们正确设置页表，

904
00:52:24,170 --> 00:52:26,690
现在，页表硬件将为我们做 walk 。

905
00:52:27,330 --> 00:52:27,690
是的。

906
00:52:28,710 --> 00:52:30,450
这就是我们的目标，

907
00:52:30,960 --> 00:52:35,190
所以这让内核程序员的生活更轻松一点，

908
00:52:35,220 --> 00:52:37,740
这种方法还有没有别的优点。

909
00:52:45,120 --> 00:52:46,770
是不是性能也更好，

910
00:52:46,770 --> 00:52:50,280
因为硬件来做 walk 而不是软件。

911
00:52:51,090 --> 00:52:52,620
是啊，一个方法，

912
00:52:52,620 --> 00:52:54,600
我认为肯定有性能的提高，

913
00:52:54,780 --> 00:52:56,850
考虑这个的一种方式是，

914
00:52:57,210 --> 00:53:00,330
在 copyin 中，如果内核数据结构

915
00:53:00,330 --> 00:53:06,340
或者我们从用户空间复制到内核空间的数据比较大，

916
00:53:06,340 --> 00:53:09,270
我们必须这样做，一次一页，

917
00:53:09,270 --> 00:53:11,910
在每个页面中，我们都必须调用函数 walkaddr ，

918
00:53:11,910 --> 00:53:13,680
然后是内部的 walk 。

919
00:53:14,250 --> 00:53:18,810
所以，这可能是一个昂贵的花费。

920
00:53:19,650 --> 00:53:21,450
有什么例子，

921
00:53:21,450 --> 00:53:25,800
是内核从用户空间复制大量数据。

922
00:53:33,340 --> 00:53:36,730
哪个系统调用可能会从用户空间复制大量数据。

923
00:53:38,550 --> 00:53:39,180
write?

924
00:53:39,600 --> 00:53:41,070
是的， write ，你说得对，

925
00:53:41,070 --> 00:53:47,470
你可以给出任意大小的任意缓冲区。

926
00:53:47,760 --> 00:53:51,240
内核可能将其复制到，

927
00:53:51,240 --> 00:53:54,120
文件系统或管道中。或者放进管子里。

928
00:53:54,810 --> 00:53:57,000
这是很昂贵的。

929
00:54:00,180 --> 00:54:01,950
你想想还有什么好处，

930
00:54:01,950 --> 00:54:03,390
如果用户，

931
00:54:03,660 --> 00:54:06,450
我们在任务中没有研究这个，

932
00:54:06,450 --> 00:54:09,730
应该还有别的优点。

933
00:54:13,060 --> 00:54:14,620
所以如果你想一想，

934
00:54:14,740 --> 00:54:16,450
这里的其中一些代码，

935
00:54:16,450 --> 00:54:18,850
当它把结构移出用户空间，

936
00:54:19,160 --> 00:54:22,010
它将整个结构复制到内核空间。

937
00:54:22,880 --> 00:54:25,610
如果用户空间被映射到内核页表，

938
00:54:25,610 --> 00:54:26,570
我们也一定要这么做吗。

939
00:54:31,630 --> 00:54:34,210
比如，如果我们需要更新结构体中的一个字段。

940
00:54:46,830 --> 00:54:51,440
如果数据结构只是映射到内核地址空间，

941
00:54:51,440 --> 00:54:53,570
那么我们可以读写，

942
00:54:53,570 --> 00:54:56,180
通过 store 指令到特定的数据结构，

943
00:54:56,180 --> 00:54:57,620
我们可以更新一个字段。

944
00:54:58,320 --> 00:54:59,670
与现在内核做的不同，

945
00:54:59,670 --> 00:55:04,170
它将结构体从内核空间复制到用户空间，

946
00:55:04,170 --> 00:55:06,390
然后可能再使用 copyout 退出。

947
00:55:07,110 --> 00:55:09,780
因此，我们将用户空间映射到，

948
00:55:09,780 --> 00:55:11,610
将用户程序映射到内核地址空间，

949
00:55:11,640 --> 00:55:14,250
我们可以更自由地操纵它，

950
00:55:14,280 --> 00:55:16,170
而不是我们现在的做法。

951
00:55:18,620 --> 00:55:19,370
这能理解吗？

952
00:55:19,370 --> 00:55:23,930
就动机而言，为什么许多内核都有这种特殊的结构，

953
00:55:23,930 --> 00:55:28,610
映射底部是用户，

954
00:55:28,790 --> 00:55:32,600
将用户程序映射到内核地址空间的底部。

955
00:55:39,260 --> 00:55:39,830
好的？

956
00:55:44,750 --> 00:55:48,290
好的，让我们看我的代码，

957
00:55:48,320 --> 00:55:51,800
好让你明白实际是什么。

958
00:55:52,980 --> 00:55:57,090
我想有一个函数是关键，

959
00:55:57,270 --> 00:56:01,620
假设我们正在建立有效的用户页表 ，

960
00:56:01,620 --> 00:56:02,400
然后我们需要将

961
00:56:02,400 --> 00:56:07,500
条目从用户页表映射到内核页表，

962
00:56:07,960 --> 00:56:10,720
进程内核页表，

963
00:56:10,720 --> 00:56:13,390
函数 kvmmapuser 就是这样做的。

964
00:56:13,930 --> 00:56:16,090
这挺枯燥的，

965
00:56:16,090 --> 00:56:20,440
工作中主要的几个点是，

966
00:56:20,440 --> 00:56:28,550
是的，那是与 uvmalloc 同样类型的接口，

967
00:56:28,610 --> 00:56:30,110
或者如果，

968
00:56:30,110 --> 00:56:33,320
你从旧尺寸页面转到新尺寸页面。

969
00:56:33,980 --> 00:56:34,610
嗯。

970
00:56:35,190 --> 00:56:39,270
你找到 upte ，

971
00:56:39,300 --> 00:56:45,760
指向特定虚拟地址的 pte 的指针，

972
00:56:45,760 --> 00:56:47,080
在用户页表中。

973
00:56:48,000 --> 00:56:50,610
所以我们来看一下，

974
00:56:51,200 --> 00:56:53,150
如果你看这张图片，

975
00:56:53,150 --> 00:56:54,680
我们有一段时间了，

976
00:56:54,680 --> 00:56:56,840
看这张图片。

977
00:56:57,410 --> 00:56:59,750
这将返回的是，

978
00:56:59,960 --> 00:57:01,640
我们遍历用户页表，

979
00:57:01,640 --> 00:57:04,610
我们找到 upte ，

980
00:57:04,820 --> 00:57:07,010
它映射到特定虚拟地址，

981
00:57:07,010 --> 00:57:10,010
那个地址指向页表中的那个条目。

982
00:57:14,740 --> 00:57:16,060
这就是 walk 所做的。

983
00:57:16,600 --> 00:57:21,010
如果这个东西映射了，它不是零，

984
00:57:21,010 --> 00:57:22,810
那一定意味着，至少答案是，

985
00:57:22,810 --> 00:57:25,840
检查映射是否在那里。

986
00:57:26,520 --> 00:57:28,530
我们检查这是有效的，

987
00:57:28,920 --> 00:57:31,320
这在某种意义上有帮助调试，

988
00:57:31,320 --> 00:57:33,420
你知道我们应该在有效的情况下。

989
00:57:34,070 --> 00:57:36,530
然后我在内核页表中做同样的事情，

990
00:57:37,010 --> 00:57:41,030
我还查看进程内核页表中的虚拟地址，

991
00:57:41,090 --> 00:57:43,940
但这一次我调用 walk 带上 1 ，

992
00:57:44,030 --> 00:57:46,910
因此，如果需要，它会分配中间页。

993
00:57:48,460 --> 00:57:52,450
然后，我得到指向内核 pte 的指针，

994
00:57:52,630 --> 00:57:55,450
我只是将用户 pte 复制到内核 pte 。

995
00:57:56,730 --> 00:58:00,360
可能你们中的很多人调用了 mappages 。

996
00:58:00,620 --> 00:58:04,910
但我是直接将 pte 复制到内核 pte 中，

997
00:58:05,150 --> 00:58:07,340
当然，我要禁用一些位，

998
00:58:07,340 --> 00:58:09,530
稍后我们会讲到，

999
00:58:09,560 --> 00:58:12,680
但是，它的实质是，

1000
00:58:12,680 --> 00:58:15,380
我只是复制内核页面 pte 条目。

1001
00:58:16,730 --> 00:58:17,780
这意味着，

1002
00:58:17,780 --> 00:58:21,920
用户程序的物理内存是共享的，

1003
00:58:22,100 --> 00:58:25,120
在内核空间和用户空间之间。

1004
00:58:28,140 --> 00:58:30,030
好的，能理解吗。

1005
00:58:32,940 --> 00:58:36,090
好的，切换一些位，

1006
00:58:36,150 --> 00:58:39,780
比需要的多一点，

1007
00:58:39,780 --> 00:58:41,490
我关闭了执行位，

1008
00:58:41,490 --> 00:58:43,410
我关闭了写入位，

1009
00:58:43,780 --> 00:58:47,530
因为 copyin 只需要读取，不需要写入，

1010
00:58:47,530 --> 00:58:48,670
copyout 也是这样。

1011
00:58:49,170 --> 00:58:52,260
然后，你也必须切换 u 标志位。

1012
00:58:52,780 --> 00:58:57,580
这是一种 RISC-V 特定的东西，

1013
00:58:57,580 --> 00:58:59,530
如果你在内核模式下运行，

1014
00:58:59,880 --> 00:59:03,600
并且你在 pte 条目中设置了 u 标志位，

1015
00:59:03,630 --> 00:59:06,750
内核就不能访问那个特定页面。

1016
00:59:08,140 --> 00:59:10,630
事实上，你可以，

1017
00:59:10,660 --> 00:59:12,970
这是一个选择，

1018
00:59:13,000 --> 00:59:15,430
你还可以对 RISC-V 硬件进行编程，

1019
00:59:15,550 --> 00:59:18,820
这处于内核模式，并忽略 u 标志位。

1020
00:59:19,720 --> 00:59:24,910
但是 xv6 没有做这一点，

1021
00:59:25,150 --> 00:59:26,680
所以你必须切换 u 标志位。

1022
00:59:30,880 --> 00:59:31,990
有关于 u 标志位的问题吗，

1023
00:59:31,990 --> 00:59:34,120
因为有很多人人问到了它。

1024
00:59:40,510 --> 00:59:43,180
那么这么做只是为了确保，

1025
00:59:43,180 --> 00:59:47,650
内核不会对用户内存做什么坏事。

1026
00:59:48,160 --> 00:59:50,470
是的，那么为什么会这样？

1027
00:59:50,470 --> 00:59:52,960
所以问题是，这是出于调试的原因，

1028
00:59:52,960 --> 00:59:55,180
还是有某种隔离的原因这样做。

1029
00:59:55,860 --> 00:59:59,070
我想这主要是出于调试的原因。

1030
00:59:59,450 --> 01:00:02,150
因为内核反正是完全控制的，

1031
01:00:02,510 --> 01:00:04,940
内核可以修改 satp 寄存器，

1032
01:00:04,940 --> 01:00:08,180
它页可以禁用分页，

1033
01:00:08,180 --> 01:00:11,840
所以不是，保护用户空间不受内核影响，

1034
01:00:12,020 --> 01:00:15,170
我认为主要是为了帮助内核开发，

1035
01:00:15,170 --> 01:00:16,940
从 xv6 来说，

1036
01:00:16,970 --> 01:00:21,320
未修改的 xv6 不应该引用用户页面。

1037
01:00:22,130 --> 01:00:25,400
还有，你知道，

1038
01:00:26,200 --> 01:00:29,890
如果你这样做，会有所帮助，

1039
01:00:29,890 --> 01:00:32,890
出现意外，你会立即得到页面错误，

1040
01:00:32,890 --> 01:00:34,630
内核错误，

1041
01:00:34,630 --> 01:00:36,310
这将有助于内核调试，

1042
01:00:36,620 --> 01:00:38,480
开发人员调试内核。

1043
01:00:41,420 --> 01:00:42,080
能理解吗。

1044
01:00:44,970 --> 01:00:45,990
是的，谢谢。

1045
01:00:47,950 --> 01:00:49,840
我有一个后续的问题，

1046
01:00:51,010 --> 01:00:53,950
我理解了关于用户位的部分，

1047
01:00:53,980 --> 01:00:57,040
但是关于写入和执行位是怎样的？

1048
01:00:57,400 --> 01:00:58,030
是的。

1049
01:00:59,070 --> 01:01:01,680
执行位必须打开吗？

1050
01:01:07,090 --> 01:01:08,680
内核用这个页面做什么？

1051
01:01:12,060 --> 01:01:13,320
它只是读，

1052
01:01:13,320 --> 01:01:14,670
唯一的事情，唯一的指令，

1053
01:01:14,670 --> 01:01:17,190
是从这个页面获取数据，

1054
01:01:17,190 --> 01:01:18,690
memmove 指令和 copyin 。

1055
01:01:20,660 --> 01:01:23,390
所以它只执行加载指令，

1056
01:01:23,960 --> 01:01:27,430
或者从特定页面加载值，

1057
01:01:27,850 --> 01:01:29,650
并且页面应该只包含数据。

1058
01:01:30,180 --> 01:01:33,450
所以内核没有理由写入该页，

1059
01:01:33,480 --> 01:01:35,910
所以出于保守考虑，

1060
01:01:35,940 --> 01:01:37,140
我禁用了写入位。

1061
01:01:37,760 --> 01:01:40,670
并且不应该从该页面执行指令，

1062
01:01:40,910 --> 01:01:42,650
所以我也禁用了执行位。

1063
01:01:43,410 --> 01:01:46,380
再说一次，我认为这主要是出于调试的原因，

1064
01:01:46,650 --> 01:01:49,020
而不是因为隔离的原因。

1065
01:01:52,190 --> 01:01:53,540
好的，理解了，谢谢。

1066
01:02:00,760 --> 01:02:03,550
好的，那么现在我们唯一需要做的是，

1067
01:02:03,550 --> 01:02:04,720
基本上有一些位置，

1068
01:02:04,720 --> 01:02:07,720
这个代码，这个调用函数在什么位置。

1069
01:02:08,360 --> 01:02:11,900
我们看看这些调用的位置，

1070
01:02:11,900 --> 01:02:13,280
了解发生了什么，

1071
01:02:13,830 --> 01:02:15,150
或者怎么使用，

1072
01:02:15,150 --> 01:02:17,130
我想其中一个有趣的是，

1073
01:02:17,130 --> 01:02:18,840
你们中很少人问到，

1074
01:02:19,330 --> 01:02:20,770
就是 fork 。

1075
01:02:22,400 --> 01:02:24,230
确切地说，我们讨论他们两个。

1076
01:02:27,170 --> 01:02:29,480
第一个 fork ，

1077
01:02:34,140 --> 01:02:37,860
这里是对 fork 的调用，

1078
01:02:38,310 --> 01:02:41,610
或者调用 fork 中的 kvmmapuser 。

1079
01:02:42,120 --> 01:02:44,670
它接受 n- ，

1080
01:02:44,910 --> 01:02:48,630
我想大部分人问的主要问题是，

1081
01:02:48,780 --> 01:02:52,650
为什么一定要是新的进程内核页表，

1082
01:02:53,030 --> 01:02:57,020
为什么必须从新进程复制页表，

1083
01:02:57,020 --> 01:03:00,890
而不是当前进程页表，

1084
01:03:00,890 --> 01:03:03,710
因为不管怎样，之后都是一样的，

1085
01:03:03,710 --> 01:03:05,390
基本上，它就是复制了，

1086
01:03:06,910 --> 01:03:08,770
页表中的用户部分，

1087
01:03:08,770 --> 01:03:13,250
那么为什么不使用当前页表来做这件事呢。

1088
01:03:16,520 --> 01:03:18,380
为什么会出现这种情况，

1089
01:03:18,380 --> 01:03:20,390
你必须用新的，

1090
01:03:20,950 --> 01:03:25,630
子进程的的用户页表。

1091
01:03:26,060 --> 01:03:27,050
为什么会这样呢？

1092
01:03:36,380 --> 01:03:38,780
想一下你得到了什么 bug 。

1093
01:03:44,270 --> 01:03:45,620
当你得到 remap 错误时。

1094
01:03:46,550 --> 01:03:49,280
也许不是 remap 错误，可能是那个，

1095
01:03:49,370 --> 01:03:53,030
但我想的不是 remap 的那个。

1096
01:03:56,210 --> 01:03:57,470
你们中的一些人试过，

1097
01:03:57,740 --> 01:03:59,300
你们感觉怎么样？

1098
01:04:06,770 --> 01:04:09,530
线上有人试过吗？

1099
01:04:10,630 --> 01:04:13,960
我记得它们[导致的经历]，

1100
01:04:16,430 --> 01:04:19,730
我觉得这个经历，我没有这个 bug ，

1101
01:04:19,730 --> 01:04:22,520
我认为体验是在 usertest 中的某个地方。

1102
01:04:22,990 --> 01:04:25,990
一个特定的 usertest ，执行大量 fork 和执行，

1103
01:04:26,170 --> 01:04:27,190
你会得到一个问题，

1104
01:04:27,750 --> 01:04:31,680
你会得到一个错误，

1105
01:04:32,010 --> 01:04:36,480
在错误中，出错的是，

1106
01:04:36,820 --> 01:04:39,850
如果从父进程复制，

1107
01:04:40,440 --> 01:04:43,830
如果父进程在子进程之前退出，

1108
01:04:44,450 --> 01:04:50,570
那么父进程页表会被彻底清理掉，

1109
01:04:50,570 --> 01:04:51,530
正如我们之前看到的，

1110
01:04:51,950 --> 01:05:00,550
然后，子进程仍然具有指向父进程页表的指针，

1111
01:05:00,910 --> 01:05:03,100
所以基本上你会，

1112
01:05:03,400 --> 01:05:10,420
基本上子进程中的页表已经处理过，

1113
01:05:10,450 --> 01:05:11,800
而且仍在使用，

1114
01:05:11,800 --> 01:05:13,600
其结果就是各种不良行为，

1115
01:05:13,600 --> 01:05:16,650
因为内核释放页面，

1116
01:05:16,650 --> 01:05:18,540
实际上在里面写入 1 ，

1117
01:05:19,080 --> 01:05:20,400
为了调试的原因，

1118
01:05:20,670 --> 01:05:22,080
所以现在你有，

1119
01:05:22,080 --> 01:05:26,250
无效的 pte 在你的内核页表中。

1120
01:05:29,090 --> 01:05:29,840
这个能理解吗。

1121
01:05:37,950 --> 01:05:39,630
好的，下一个。

1122
01:05:40,700 --> 01:05:43,100
你可以查看 exec.c 。

1123
01:05:43,900 --> 01:05:48,800
在我的解决方案中，是很直截的，

1124
01:05:48,800 --> 01:05:51,080
没有修改 exec 。

1125
01:05:51,410 --> 01:05:53,660
唯一的修改是，

1126
01:05:53,660 --> 01:05:56,480
当然，你知道第一部分的第一个，

1127
01:05:56,880 --> 01:05:58,170
接下来是第三部分，

1128
01:05:58,380 --> 01:06:04,420
将新用户页表映射到内核页表。

1129
01:06:04,720 --> 01:06:06,160
exec 基本上是这样做的，

1130
01:06:06,160 --> 01:06:09,490
我们构建了一个新的用户地址空间，

1131
01:06:09,730 --> 01:06:13,600
这一行复制新用户地址空间到内核页表。

1132
01:06:15,540 --> 01:06:16,170
就是这样。

1133
01:06:21,300 --> 01:06:22,110
有什么问题吗。

1134
01:06:27,110 --> 01:06:28,640
所以，希望在此期间，

1135
01:06:28,970 --> 01:06:33,720
我已经回答了你们提交的很多问题，

1136
01:06:33,750 --> 01:06:36,990
我们可以看看有哪些，

1137
01:06:37,050 --> 01:06:38,550
还有几个问题，

1138
01:06:38,550 --> 01:06:39,810
我还没讨论过。

1139
01:06:40,430 --> 01:06:42,290
所以也许我们可以看看那些，

1140
01:06:42,290 --> 01:06:44,600
或者你有问题要问。

1141
01:06:46,990 --> 01:06:51,600
嗯，我们也要修改 growproc 吗？

1142
01:06:51,780 --> 01:06:54,420
是的，还有几处需要修改，

1143
01:06:55,970 --> 01:06:59,090
在 sbrk 或 growproc 中。

1144
01:06:59,950 --> 01:07:05,280
有一个，我这里有一行，

1145
01:07:05,580 --> 01:07:10,350
类似的方式，也有类似的修改。

1146
01:07:11,830 --> 01:07:13,030
再说一次，[可能在这里]，

1147
01:07:13,030 --> 01:07:14,170
[经常在这里]，

1148
01:07:14,500 --> 01:07:15,910
它可能不得不改变。

1149
01:07:17,650 --> 01:07:23,230
因为你必须将初始化代码中的一页映射到，

1150
01:07:23,230 --> 01:07:25,030
进程中的内核页表。

1151
01:07:26,730 --> 01:07:28,110
因为第一个进程很特别。

1152
01:07:35,560 --> 01:07:38,530
好的，现在我要浏览一下这里的一些问题，

1153
01:07:38,530 --> 01:07:40,270
我把它们放到屏幕上，

1154
01:07:40,270 --> 01:07:41,380
所以你们可以看到它们。

1155
01:07:41,800 --> 01:07:45,130
其实我不一定要把它们全部读出来。

1156
01:07:45,470 --> 01:07:47,030
第一个问题是，

1157
01:07:47,030 --> 01:07:51,290
关于 pte_u 标志位的，

1158
01:07:51,380 --> 01:07:53,090
我想我们已经讨论过了，

1159
01:07:53,570 --> 01:07:55,490
我们还讨论了，

1160
01:07:55,490 --> 01:07:56,480
它不是防止恶意行为的，

1161
01:07:56,480 --> 01:07:58,190
而是主要出于调试的原因。

1162
01:08:00,850 --> 01:08:02,470
类似的问题，比如，

1163
01:08:02,830 --> 01:08:05,440
如果你在管理者模式，你能做任何事情吗，

1164
01:08:05,530 --> 01:08:07,990
因为你可以切换 satp ，

1165
01:08:07,990 --> 01:08:09,100
你可以，嗯。

1166
01:08:09,450 --> 01:08:10,800
答案是肯定的，

1167
01:08:10,920 --> 01:08:13,440
也有可能，所以它是，

1168
01:08:13,440 --> 01:08:15,030
这个 u 标志位不是关于

1169
01:08:15,540 --> 01:08:18,180
保护用户程序不受内核影响，

1170
01:08:18,180 --> 01:08:21,990
实际上是作为标志位帮助内核开发人员，

1171
01:08:21,990 --> 01:08:22,830
用于构建内核。

1172
01:08:24,500 --> 01:08:27,380
另一个特殊的 RISC-V 问题，

1173
01:08:27,500 --> 01:08:30,590
为什么在 proc.h 的 trapframe 中，

1174
01:08:30,590 --> 01:08:33,980
寄存器是这种奇怪的顺序。

1175
01:08:34,370 --> 01:08:36,920
原因是，

1176
01:08:37,190 --> 01:08:39,680
我们之前提到过，

1177
01:08:39,680 --> 01:08:41,690
在上一节课中，

1178
01:08:41,720 --> 01:08:46,010
有一种叫做 RISC-V 压缩指令集的东西，

1179
01:08:46,280 --> 01:08:48,080
它使用一组较少的寄存器。

1180
01:08:48,400 --> 01:08:53,530
所以你必须对指令进行更紧凑的编码。

1181
01:08:53,990 --> 01:08:57,740
那么这个奇怪的顺序反映了一个事实，

1182
01:08:57,740 --> 01:09:00,830
它们是压缩版本，

1183
01:09:01,130 --> 01:09:02,330
是某组寄存器，

1184
01:09:02,330 --> 01:09:03,980
是一种压缩版本，

1185
01:09:03,980 --> 01:09:05,090
我们正在使用的，

1186
01:09:05,180 --> 01:09:06,740
它有一套完整的寄存器。

1187
01:09:07,440 --> 01:09:12,630
而压缩版本，包含 s1 和 s0 ，

1188
01:09:12,930 --> 01:09:14,130
s0 和 s1 ，

1189
01:09:14,130 --> 01:09:15,630
但没有 s2 到 s11 。

1190
01:09:17,380 --> 01:09:18,520
所以这是主要原因。

1191
01:09:26,880 --> 01:09:29,100
我想我已经回答了大部分问题，

1192
01:09:29,100 --> 01:09:30,210
但是如果你看到一个问题，

1193
01:09:30,210 --> 01:09:31,920
我应该讲却没有讲的问题，

1194
01:09:32,130 --> 01:09:33,600
请打断我，

1195
01:09:33,600 --> 01:09:35,670
或者你可以问我还没有讲到的问题，

1196
01:09:38,050 --> 01:09:40,720
请问我。

1197
01:09:40,720 --> 01:09:42,970
这些问题基本上是按照提交的顺序，

1198
01:09:43,000 --> 01:09:44,020
所以这些是。

1199
01:09:48,270 --> 01:09:50,220
好的，这里可能是。

1200
01:09:50,960 --> 01:09:51,710
这有一个问题，

1201
01:09:51,710 --> 01:09:53,720
对于使用分层页表的操作系统来说，

1202
01:09:53,720 --> 01:09:55,100
是否设置过页表页面，

1203
01:09:55,100 --> 01:09:58,010
让层次结构的较低部分是共享的。

1204
01:09:58,560 --> 01:10:01,230
你看到我的解决方案，

1205
01:10:01,230 --> 01:10:04,210
我分享条目 1 到 511 ，

1206
01:10:04,630 --> 01:10:06,070
这是一个标准的技巧，

1207
01:10:06,360 --> 01:10:08,070
很多操作系统都是这么做的。

1208
01:10:17,830 --> 01:10:20,170
我想我们讨论了一下这个特别的问题，

1209
01:10:20,170 --> 01:10:23,440
切换到主内核页表是很重要的，

1210
01:10:23,440 --> 01:10:25,150
因为调度程序，

1211
01:10:25,420 --> 01:10:29,050
可能根本没有要运行的用户进程，

1212
01:10:29,310 --> 01:10:31,620
在调度器中，当然还需要一个页表，

1213
01:10:31,890 --> 01:10:33,900
因此，它与主内核页表一起运行。

1214
01:10:36,590 --> 01:10:37,550
聊天中的问题。

1215
01:10:37,850 --> 01:10:39,260
好的，继续。

1216
01:10:39,290 --> 01:10:41,270
聊天中的内容是什么。

1217
01:10:55,110 --> 01:10:55,860
我可以读出来。

1218
01:10:56,040 --> 01:10:56,880
是的，我看到了。

1219
01:10:56,880 --> 01:10:59,040
所以我想问题是，

1220
01:10:59,040 --> 01:11:00,960
注意到 RISC 特权标准说到，

1221
01:11:00,960 --> 01:11:02,760
隔离的那部分是为了防止 bug ，

1222
01:11:02,760 --> 01:11:06,630
允许用户程序使内核跳转到用户空间中的任意代码。

1223
01:11:07,200 --> 01:11:09,240
对，一个很好的观点，

1224
01:11:09,540 --> 01:11:13,530
所以你可以在这里辩论，

1225
01:11:13,530 --> 01:11:16,680
是隔离属性或内核调试属性。

1226
01:11:16,970 --> 01:11:18,350
显然，内核永远不应该

1227
01:11:18,350 --> 01:11:23,090
直接跳入用户地址空间的任何地址，

1228
01:11:23,450 --> 01:11:28,400
除非我把它视为一种工具，

1229
01:11:28,400 --> 01:11:31,400
来帮助内核调试或捕获这些类型的 bug 。

1230
01:11:33,080 --> 01:11:39,050
以及为什么对于 xv6 我们禁用或设置 u 标志位。

1231
01:11:39,400 --> 01:11:42,460
并且不允许内核引用任何（用户）页面，

1232
01:11:43,050 --> 01:11:48,630
这防止我们，引用用户地址，

1233
01:11:49,070 --> 01:11:51,020
实际上内核会出错。

1234
01:12:02,480 --> 01:12:06,200
我想我也讨论了调度器。

1235
01:12:12,520 --> 01:12:14,170
这里有一个问题，

1236
01:12:14,170 --> 01:12:15,820
xv6 中的管道是如何实现的，

1237
01:12:15,820 --> 01:12:18,280
而且在 pgtlb 实验中修改页表，

1238
01:12:18,280 --> 01:12:19,390
怎样影响这个实现。

1239
01:12:19,940 --> 01:12:24,200
嗯，管道基本上是内核中的一个缓冲内存。

1240
01:12:24,630 --> 01:12:27,210
还有写，当你写管道的时候，

1241
01:12:27,210 --> 01:12:28,560
就是调用 copyin ，

1242
01:12:28,880 --> 01:12:32,420
copyin 将字节从用户空间复制到管道中，

1243
01:12:32,960 --> 01:12:36,050
在某些方面，页表实验的全部内容，

1244
01:12:36,050 --> 01:12:38,510
简化了代码。

1245
01:12:39,220 --> 01:12:42,430
所以你不用调用很多 walk ，

1246
01:12:42,430 --> 01:12:45,530
当你从用户空间写入管道时。

1247
01:12:49,150 --> 01:12:51,040
这个问题我想很多人都在问，

1248
01:12:51,040 --> 01:12:52,990
为什么 uvmfree 和 freewalk ，

1249
01:12:52,990 --> 01:12:54,250
会在叶节点引发错误。

1250
01:12:54,760 --> 01:12:57,700
原因是，

1251
01:12:57,730 --> 01:12:59,680
我们把它放到那里，

1252
01:12:59,680 --> 01:13:02,200
因为它坏了，这是一个迹象，

1253
01:13:02,200 --> 01:13:04,210
xv6 中的一个区域将被破坏。

1254
01:13:04,750 --> 01:13:07,360
这是未修改的 xv6 的不变量，

1255
01:13:07,750 --> 01:13:09,070
在这种情况下，

1256
01:13:10,380 --> 01:13:11,340
这不是真的，

1257
01:13:11,340 --> 01:13:14,010
因此，你必须从根本上避免错误。

1258
01:13:14,360 --> 01:13:16,700
意识到这个错误并不重要，

1259
01:13:16,700 --> 01:13:18,080
你不应该到达那里。

1260
01:13:21,770 --> 01:13:23,570
我觉得我们讨论了不少，

1261
01:13:23,570 --> 01:13:25,040
为什么 vm 复制新的，

1262
01:13:25,040 --> 01:13:27,620
为什么新的 vm 副本是好的。

1263
01:13:34,300 --> 01:13:36,310
好的，还有一个问题，

1264
01:13:36,520 --> 01:13:39,700
我们看一下，可能是一个有趣的，

1265
01:13:39,970 --> 01:13:42,610
一个问题问到了更多的设计问题。

1266
01:13:43,010 --> 01:13:46,040
我需要这张图片。

1267
01:13:46,590 --> 01:13:49,680
我们看一下内核地址空间，

1268
01:13:51,130 --> 01:13:51,790
{} {}，

1269
01:13:52,270 --> 01:13:55,870
我们限制，用户地址用户程序可以更大，

1270
01:13:56,200 --> 01:13:58,690
用户程序最多可以增长到 CLIENT 地址。

1271
01:14:00,000 --> 01:14:03,750
假设我们实际上想要一路增长到这里。

1272
01:14:04,680 --> 01:14:05,580
我们怎么能做到这一点，

1273
01:14:05,640 --> 01:14:06,390
怎么，

1274
01:14:06,720 --> 01:14:09,570
我们应该如何改变设计来允许这个。

1275
01:14:18,250 --> 01:14:18,970
有人知道吗。

1276
01:14:23,390 --> 01:14:26,240
我们是否可以重新映射这些东西，

1277
01:14:26,420 --> 01:14:29,540
比如 CLINT PLIC 和 UART ？

1278
01:14:31,310 --> 01:14:32,450
是的，你会在哪里映射，

1279
01:14:32,570 --> 01:14:34,220
你想在哪里，

1280
01:14:34,580 --> 01:14:36,470
来释放地址空间的那部分，

1281
01:14:36,470 --> 01:14:37,640
你能在哪里做（映射）。

1282
01:14:38,940 --> 01:14:41,970
映射到一个地方，

1283
01:14:41,970 --> 01:14:43,920
在 KERNBASE 之前和，

1284
01:14:43,950 --> 01:14:47,490
在 PHYSTOP 之前和 KERNBASE 之后。

1285
01:14:48,050 --> 01:14:50,930
是啊，或者更好的是在 PHYSTOP 之后，

1286
01:14:51,110 --> 01:14:52,940
这里有大量的自由空间。

1287
01:14:53,360 --> 01:14:55,130
比如地址空间没有使用，

1288
01:14:55,130 --> 01:14:57,110
从这里到那里都是用于物理内存。

1289
01:14:57,620 --> 01:14:59,360
我们可以在这里设置映射，

1290
01:14:59,360 --> 01:15:01,810
例如，我们可以把 UART 放在这里，

1291
01:15:03,720 --> 01:15:04,410
UART0 ，

1292
01:15:04,410 --> 01:15:06,030
我们放在 PHYSTOP 旁边，

1293
01:15:06,030 --> 01:15:07,140
建立一个映射，

1294
01:15:07,140 --> 01:15:11,250
映射到那个特定的物理地址，

1295
01:15:11,250 --> 01:15:13,560
那么现在将释放这些映射，

1296
01:15:13,800 --> 01:15:15,570
我们可以把它用作用户空间，

1297
01:15:15,720 --> 01:15:17,760
同样，我们也可以对 UART0 执行此操作，

1298
01:15:17,760 --> 01:15:20,040
或 VIRTIO_disk ， PLIC 和 CLINT 。

1299
01:15:21,420 --> 01:15:22,470
真正的内核是这样做的。

1300
01:15:24,730 --> 01:15:25,420
这个能理解吗。

1301
01:15:37,000 --> 01:15:38,890
这没有问题吗，

1302
01:15:38,890 --> 01:15:42,280
因为我们会想要同样的映射，

1303
01:15:42,280 --> 01:15:46,540
像原来的内核页表一样。

1304
01:15:48,200 --> 01:15:51,950
好的，我们需要对每个内核页表做这个，

1305
01:15:51,950 --> 01:15:52,970
我们要复制，

1306
01:15:52,970 --> 01:15:55,310
我们必须把在特定的位置把它映射到任何地方。

1307
01:16:00,400 --> 01:16:01,210
我不确定是不是，

1308
01:16:01,210 --> 01:16:03,040
不确定是否回答了你的问题，

1309
01:16:03,040 --> 01:16:05,030
但是我不认为这是一个问题。

1310
01:16:05,800 --> 01:16:09,580
我明白了，所以你也在原来的（页表）中做这个映射。

1311
01:16:09,730 --> 01:16:12,070
是的，我们也得在原来的做这些。

1312
01:16:15,760 --> 01:16:18,430
这很简单，让整个内核统一，

1313
01:16:18,430 --> 01:16:21,460
让 UART0 位于顶端。

1314
01:16:28,850 --> 01:16:30,200
很多人问到，

1315
01:16:30,200 --> 01:16:32,690
为什么我们要将内核堆栈映射到高位置。

1316
01:16:37,190 --> 01:16:38,210
那是什么原因呢？

1317
01:16:38,300 --> 01:16:43,320
在 procinit 中，我们将这些内核堆栈映射到高处，

1318
01:16:43,350 --> 01:16:44,850
如果你采用复制的方法，

1319
01:16:44,850 --> 01:16:47,470
你实际上需要修改 procinit ，

1320
01:16:47,470 --> 01:16:50,130
复制这个映射。

1321
01:16:51,550 --> 01:16:54,610
为什么要在虚拟地址空间高位置？

1322
01:16:59,940 --> 01:17:00,600
有人知道吗？

1323
01:17:09,300 --> 01:17:13,980
是不是因为 RISC-V 中的堆栈向下增长，

1324
01:17:13,980 --> 01:17:15,510
所以你把它放在地址空间的高处，

1325
01:17:15,510 --> 01:17:17,310
让它有向下增长的空间。

1326
01:17:17,780 --> 01:17:21,200
是的，这个方向，要向下增长多少页呢？

1327
01:17:25,650 --> 01:17:27,990
那应该没关系，因为它只有一页，对吧。

1328
01:17:28,140 --> 01:17:29,100
是的，只有一页，

1329
01:17:29,100 --> 01:17:31,710
那么如果你增长超过一页会发生什么呢？

1330
01:17:37,200 --> 01:17:39,780
你到了守护页，对吧。

1331
01:17:40,600 --> 01:17:42,160
而守护页没有映射，

1332
01:17:42,580 --> 01:17:44,170
因此内核将会错误，

1333
01:17:44,540 --> 01:17:47,210
这比覆盖数据结构要好。

1334
01:17:48,950 --> 01:17:50,240
所以它在高处的原因是，

1335
01:17:50,270 --> 01:17:52,370
因为我们在它下面放了一个守护页。

1336
01:17:52,460 --> 01:17:55,490
守护页有没有关联的物理内存？

1337
01:17:59,400 --> 01:17:59,880
没有。

1338
01:18:00,180 --> 01:18:02,640
是的，没有与守护页关联的物理内存，

1339
01:18:02,730 --> 01:18:05,070
所以把它放得很高的一件很酷的事情，

1340
01:18:05,490 --> 01:18:07,140
我们可以放一个守护页面在它下面，

1341
01:18:07,260 --> 01:18:09,570
实际上不会消耗任何物理内存。

1342
01:18:12,690 --> 01:18:13,260
好的。

1343
01:18:13,930 --> 01:18:14,620
能理解吗。

1344
01:18:17,080 --> 01:18:22,890
堆栈页面在物理内存的某个地方，

1345
01:18:22,890 --> 01:18:24,000
但守护页页不是？

1346
01:18:24,360 --> 01:18:24,960
没错。

1347
01:18:26,780 --> 01:18:29,060
再说一次，这是使用虚拟内存可以做的很酷的事情之一。

1348
01:18:30,090 --> 01:18:32,790
有没有可能超过守护页。

1349
01:18:32,820 --> 01:18:34,230
这是个很好的问题

1350
01:18:34,470 --> 01:18:36,360
举个例子，

1351
01:18:36,360 --> 01:18:37,800
你分配了（守护页），

1352
01:18:37,800 --> 01:18:39,450
一个堆栈上的缓冲区，

1353
01:18:39,450 --> 01:18:44,010
它比守护页大，对吧，

1354
01:18:44,010 --> 01:18:47,310
然后进入下一个内核堆栈页面。

1355
01:18:48,070 --> 01:18:49,900
是的，你会有一个严重的 bug 。

1356
01:18:50,510 --> 01:18:52,880
你很可能会遇到这样的情况，

1357
01:18:52,910 --> 01:18:55,790
因为你将使用缓冲的第一个条目，

1358
01:18:56,120 --> 01:18:58,280
然后就会得到页面错误。

1359
01:19:00,640 --> 01:19:01,690
当你走运的时候。

1360
01:19:02,600 --> 01:19:06,620
所以这不是一种绝对有效的内核调试技术，

1361
01:19:06,830 --> 01:19:10,190
但事实证明它非常有效。

1362
01:19:13,070 --> 01:19:13,760
好问题。

1363
01:19:18,980 --> 01:19:19,850
还有什么问题吗。

1364
01:19:20,500 --> 01:19:22,390
我们回到（问题）列表上。

1365
01:19:23,600 --> 01:19:24,770
我们还有几分钟，

1366
01:19:24,770 --> 01:19:26,360
实际上还有一分多钟。

1367
01:19:27,160 --> 01:19:28,600
我有个问题，

1368
01:19:29,170 --> 01:19:33,910
一旦我们有了进程的内核页表，

1369
01:19:33,970 --> 01:19:39,590
这是否意味着在 trap 代码中，

1370
01:19:39,590 --> 01:19:42,440
我们不需要切换页表。

1371
01:19:42,880 --> 01:19:46,960
我认为是一个好问题，一个好的设计问题，

1372
01:19:46,960 --> 01:19:48,910
答案是肯定的，你不需要它，

1373
01:19:48,910 --> 01:19:52,820
因为，主要原因是

1374
01:19:52,820 --> 01:19:54,620
内核或者 trampoline 代码，

1375
01:19:54,620 --> 01:19:55,610
我们经历这些麻烦，

1376
01:19:55,610 --> 01:19:57,410
是因为我们必须复制用户（页表），

1377
01:19:57,870 --> 01:20:01,110
我们必须从内核页表切换到用户页表，

1378
01:20:01,110 --> 01:20:05,040
用户页表或没有其他内核映射的页表。

1379
01:20:05,710 --> 01:20:09,460
嗯，所以，缺点是。

1380
01:20:09,580 --> 01:20:11,770
等等，我不确定这是不是正确的，

1381
01:20:11,770 --> 01:20:14,710
因为内核需要有，

1382
01:20:14,890 --> 01:20:16,660
设置用户标志。

1383
01:20:17,450 --> 01:20:19,880
是的，好的，我有几点想说，

1384
01:20:20,240 --> 01:20:24,860
原则上，你可以简化，

1385
01:20:24,860 --> 01:20:25,700
我这么说吧，

1386
01:20:25,880 --> 01:20:27,470
你可以简化进入退出，

1387
01:20:27,650 --> 01:20:31,130
如果你在内核中有一个单独的页表映射到用户，

1388
01:20:31,130 --> 01:20:32,150
在单独页表中，

1389
01:20:32,150 --> 01:20:33,770
那样你就不用切换了，

1390
01:20:33,980 --> 01:20:36,800
你需要对 xv6 进行更多修改，

1391
01:20:36,800 --> 01:20:37,550
才能做到这一点。

1392
01:20:38,260 --> 01:20:39,610
但是，原则上是可以的，

1393
01:20:39,610 --> 01:20:43,600
事实上，直到最近 Linux 使用，

1394
01:20:43,630 --> 01:20:45,310
这种策略，

1395
01:20:45,310 --> 01:20:52,030
内核和用户代码位于单个页表中，

1396
01:20:52,400 --> 01:20:54,410
依赖 u 标志位，

1397
01:20:54,740 --> 01:20:56,120
来确保，

1398
01:20:56,510 --> 01:21:02,420
用户程序无法修改任何内核页面。

1399
01:21:02,880 --> 01:21:05,820
在这种情况下，进入退出代码稍微简单一些，

1400
01:21:05,850 --> 01:21:07,620
因为你不必切换页表，

1401
01:21:07,620 --> 01:21:09,060
当你进入或离开内核时。

1402
01:21:10,040 --> 01:21:12,770
可能会发生一件事，

1403
01:21:12,770 --> 01:21:14,090
比如，熔断攻击，

1404
01:21:14,090 --> 01:21:18,650
你可能受到侧通道攻击，

1405
01:21:18,930 --> 01:21:21,930
针对侧通道攻击，

1406
01:21:22,200 --> 01:21:25,080
Linux 切换或作为另一种模式运行，

1407
01:21:25,080 --> 01:21:27,600
有两种运行模式，一种称为 kpti 模式。

1408
01:21:28,190 --> 01:21:31,730
在该模式下，反映了 xv6 所做的事情。

1409
01:21:32,080 --> 01:21:34,390
我们有一个单独的内核页表，

1410
01:21:34,390 --> 01:21:36,730
和一个单独的用户空间页表。

1411
01:21:40,800 --> 01:21:43,380
但我还是不明白这为什么管用，

1412
01:21:43,380 --> 01:21:48,810
因此，假设每个用户进程和内核使用相同的页表，

1413
01:21:49,080 --> 01:21:52,680
如果用户内存必须设置用户位，

1414
01:21:52,920 --> 01:21:55,980
内核将无法访问该用户内存。

1415
01:21:56,010 --> 01:22:00,510
好的。

1416
01:22:00,510 --> 01:22:03,780
好的，在英特尔处理器上这不是[规则]，

1417
01:22:04,290 --> 01:22:06,480
因此，英特尔处理器，如果设置了 u 标志位，

1418
01:22:06,480 --> 01:22:08,520
内核仍然可以写入和读取那个页。

1419
01:22:08,960 --> 01:22:10,820
哦，那只是一个 RISC-V 的事情。

1420
01:22:10,910 --> 01:22:13,130
即使在 RISC-V 上，你也可以修改它，

1421
01:22:13,510 --> 01:22:15,730
在 sstatus 寄存器中有一位，

1422
01:22:15,880 --> 01:22:18,070
你可以将其设置为某个位，

1423
01:22:18,310 --> 01:22:19,090
如果你设置了它，

1424
01:22:19,090 --> 01:22:21,040
然后处于内核模式，

1425
01:22:21,160 --> 01:22:22,600
u 标志位会被忽略。

1426
01:22:23,250 --> 01:22:27,540
好的，你是说这个处理器中的一位，

1427
01:22:27,540 --> 01:22:29,400
让我晚了四个小时才睡。

1428
01:22:29,460 --> 01:22:32,610
是的，我对此非常抱歉，

1429
01:22:32,610 --> 01:22:34,560
我早该知道的。

1430
01:22:34,560 --> 01:22:38,100
当你报告后，

1431
01:22:38,100 --> 01:22:40,110
它让我想起了一个 bug ，

1432
01:22:40,110 --> 01:22:41,520
我在夏天遇到的，

1433
01:22:41,520 --> 01:22:42,510
就是那个 bug ，

1434
01:22:43,510 --> 01:22:44,920
但是我忘了这件事。

1435
01:22:46,910 --> 01:22:47,870
所以，我对此道歉。

1436
01:22:48,290 --> 01:22:49,370
不，没关系，

1437
01:22:49,370 --> 01:22:51,770
这是一个很有趣的事情，

1438
01:22:51,770 --> 01:22:53,510
但是在某个时候我就像，

1439
01:22:53,510 --> 01:22:56,900
好吧，要么是我疯了，要么是完全错了，

1440
01:22:56,900 --> 01:22:57,950
所以我去睡觉了，

1441
01:22:57,950 --> 01:22:59,210
然后提交了这个 piazza 问题，

1442
01:22:59,210 --> 01:23:01,280
希望当我醒来的时候，有人会回答，

1443
01:23:01,580 --> 01:23:03,050
幸运的是，情况就是这样。

1444
01:23:03,050 --> 01:23:06,170
所以我可以继续[]。

1445
01:23:08,260 --> 01:23:10,990
好的，我想我们有点超时了，

1446
01:23:11,020 --> 01:23:13,660
希望这些有帮助，

1447
01:23:13,690 --> 01:23:16,660
并回顾了虚拟内存的东西。

1448
01:23:17,010 --> 01:23:18,240
我觉得这件事很重要，

1449
01:23:18,240 --> 01:23:21,480
因为我们还会有三个涉及虚拟内存的实验。

1450
01:23:22,010 --> 01:23:23,780
我希望是，

1451
01:23:23,780 --> 01:23:27,770
在这一次之后，会比这次经历更容易。

1452
01:23:29,420 --> 01:23:30,860
我能问个小问题吗？

1453
01:23:30,950 --> 01:23:33,890
是的，我要留下来，

1454
01:23:33,890 --> 01:23:36,020
所以如果有人想留下来，问更多问题，

1455
01:23:36,020 --> 01:23:37,160
请随意，

1456
01:23:37,160 --> 01:23:39,320
如果你需要上下一节课，也可以走。

1457
01:23:40,620 --> 01:23:43,410
所以基本上，在所有的实验里，

1458
01:23:43,410 --> 01:23:44,520
有很多提到，

1459
01:23:44,520 --> 01:23:47,280
比如，这在未来的实验里可能会有用，

1460
01:23:47,280 --> 01:23:50,430
但是实际上我们从来没有用过我们写的任何代码，

1461
01:23:50,460 --> 01:23:53,350
那个计划是什么，

1462
01:23:53,350 --> 01:23:56,050
我们是否应该只从之前的实验导入代码，

1463
01:23:56,050 --> 01:23:58,300
或者我不想那样，因为如果有 bug ，

1464
01:23:58,300 --> 01:24:00,220
我不想影响下一个实验。

1465
01:24:00,660 --> 01:24:02,250
是的，所以，我们不这么做的一个原因是，

1466
01:24:02,250 --> 01:24:04,620
为什么实验不是建立在彼此之上，

1467
01:24:04,620 --> 01:24:06,090
即使它们可以，

1468
01:24:06,090 --> 01:24:07,770
就是为了避免基本依赖关系，

1469
01:24:07,770 --> 01:24:09,360
比如，如果你在前面的实验中有个 bug ，

1470
01:24:09,360 --> 01:24:11,460
没有被 usertests 检查出，

1471
01:24:11,580 --> 01:24:12,720
或任何其他测试，

1472
01:24:12,900 --> 01:24:14,820
但是会暴露在那个新的实验里，

1473
01:24:14,820 --> 01:24:16,140
那你会很痛苦。

1474
01:24:16,680 --> 01:24:20,160
我提到的原因是，

1475
01:24:20,160 --> 01:24:22,410
这是真实的事情如何发生，

1476
01:24:22,410 --> 01:24:25,050
我们要用页表做更多的事情。

1477
01:24:25,570 --> 01:24:29,440
例如，这个实验考虑简化 copyin ，

1478
01:24:29,560 --> 01:24:33,490
在后面的实验中，我们考虑对 sbrk 的修改，

1479
01:24:33,550 --> 01:24:38,260
基本上，我们离你在这个实验中对内核的修改很远。

1480
01:24:38,860 --> 01:24:41,260
但是你知道，你一直考虑，

1481
01:24:41,260 --> 01:24:44,290
内核页表，用户页表，会对你有帮助。

1482
01:24:45,060 --> 01:24:49,290
另外，它真的可以帮助你经历调试这类问题，

1483
01:24:49,740 --> 01:24:51,360
由于页表不正确（的问题）。

1484
01:24:52,800 --> 01:24:54,090
好的，我只是想确认一下，

1485
01:24:54,120 --> 01:24:55,650
我没有错过，

1486
01:24:55,650 --> 01:24:59,700
因为我没有从实验一复制我的 xargs 代码或别的东西。

1487
01:24:59,760 --> 01:25:02,460
实验目标不同，它们互不依赖。

1488
01:25:04,570 --> 01:25:06,220
好的，谢谢，星期三见。

1489
01:25:06,550 --> 01:25:07,090
星期三见。

1490
01:25:12,470 --> 01:25:16,430
我有一个关于映射更进一步的问题，

1491
01:25:16,430 --> 01:25:20,840
映射使用页表实验中的修改，

1492
01:25:20,960 --> 01:25:23,780
那么是否需要

1493
01:25:23,870 --> 01:25:29,910
trampoline 映射到用户页表。

1494
01:25:30,760 --> 01:25:34,510
好的，我没有想过这个。

1495
01:25:34,810 --> 01:25:37,210
所以如果你，假设内核存在，

1496
01:25:37,210 --> 01:25:39,460
因此，假设我们已经关联了一个页表，

1497
01:25:39,460 --> 01:25:41,260
就像这里显示的一样。

1498
01:25:41,760 --> 01:25:46,200
并且，我们通过 userret 跳出内核。

1499
01:25:46,630 --> 01:25:51,280
我们的目标是，我们还在内核模式下运行，

1500
01:25:51,280 --> 01:25:54,220
所以内核当然可以访问这个页面。

1501
01:25:54,220 --> 01:25:55,300
守护页，

1502
01:25:55,800 --> 01:25:56,250
我展示的，

1503
01:25:56,250 --> 01:25:57,720
不是守护页，

1504
01:25:57,870 --> 01:25:59,190
是 trampoline 页面，

1505
01:26:01,040 --> 01:26:05,180
很可能在某个地方，

1506
01:26:05,180 --> 01:26:09,110
我们需要映射，或许。

1507
01:26:11,670 --> 01:26:14,670
好的，用户 trapframe ，

1508
01:26:14,670 --> 01:26:17,370
我们并不能访问，

1509
01:26:17,430 --> 01:26:18,780
因为我们运行的是内核模式，

1510
01:26:18,780 --> 01:26:20,700
我们知道它在 proc 结构中，

1511
01:26:20,700 --> 01:26:21,930
或者我们可以得到它。

1512
01:26:22,580 --> 01:26:24,440
所以我想我们可以退出。

1513
01:26:25,820 --> 01:26:27,530
当你回来的时候，

1514
01:26:28,410 --> 01:26:30,540
用户代码可以直接运行，

1515
01:26:30,570 --> 01:26:32,250
当然 u 标志位是。

1516
01:26:36,640 --> 01:26:38,230
但是 u 标志位总是设置页面，

1517
01:26:38,230 --> 01:26:40,000
位于用户空间中，

1518
01:26:40,000 --> 01:26:40,990
所以这也是好的，

1519
01:26:41,290 --> 01:26:43,420
因此，当我们重新进入内核时，

1520
01:26:43,450 --> 01:26:44,980
我们仍然使用这个页表，

1521
01:26:44,980 --> 01:26:48,280
这个页表现在已经映射了所有内核。

1522
01:26:48,540 --> 01:26:50,970
我们可以直接复制寄存器，

1523
01:26:50,970 --> 01:26:53,280
我们需要保存到 proc 结构中的（寄存器）。

1524
01:26:54,320 --> 01:26:58,220
而不必查找单独的页面，

1525
01:26:58,220 --> 01:26:59,300
里面有 proc 结构。

1526
01:27:00,410 --> 01:27:03,380
所以我相信修改会相当直接。

1527
01:27:05,070 --> 01:27:07,710
好的，我明白了，谢谢。

1528
01:27:07,800 --> 01:27:09,960
当然，我可能是错的。

1529
01:27:11,040 --> 01:27:14,190
好的，我现在去试一下。

