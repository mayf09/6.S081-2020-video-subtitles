1
00:00:02,580 --> 00:00:06,430
好的，我想开始了。

2
00:00:09,560 --> 00:00:11,450
今天我将谈论虚拟机。

3
00:00:12,090 --> 00:00:16,290
我要讲的课会分成三个部分，

4
00:00:16,290 --> 00:00:20,790
第一部分是所谓的 trap 和模拟虚拟化，

5
00:00:20,790 --> 00:00:25,830
它描述了如何构建自己的虚拟机方案，

6
00:00:26,370 --> 00:00:29,700
比如 RISC-V 在 QEMU 中，

7
00:00:30,000 --> 00:00:31,410
然后我要讨论一下，

8
00:00:31,560 --> 00:00:36,120
最近的支持虚拟化的硬件和微处理器，

9
00:00:36,870 --> 00:00:39,090
然后是关于今天的论文 Dune ，

10
00:00:39,090 --> 00:00:42,600
它使用了这种现代的硬件支持。

11
00:00:43,330 --> 00:00:47,140
好的，那么首先什么是虚拟机，

12
00:00:47,770 --> 00:00:51,160
你可以把它想象成一台计算机的模拟，

13
00:00:51,160 --> 00:00:54,850
它的精确度足以运行操作系统，

14
00:00:55,180 --> 00:01:00,980
所以 QEMU 是一个例子，

15
00:01:00,980 --> 00:01:03,740
你可以认为是一个虚拟机的例子，

16
00:01:04,130 --> 00:01:07,580
我要说的是，

17
00:01:10,880 --> 00:01:14,000
位于硬件之上的最底层，

18
00:01:14,450 --> 00:01:19,520
我们想象一个虚拟机监视器或 VMM ，

19
00:01:20,000 --> 00:01:24,740
这或多或少取代了标准操作系统内核，

20
00:01:26,700 --> 00:01:28,890
虚拟机监视器的工作是

21
00:01:28,890 --> 00:01:34,670
为客户操作系统模拟一组计算机，

22
00:01:34,760 --> 00:01:42,260
所以，在我们通常的表中，在用户空间中，

23
00:01:42,260 --> 00:01:44,240
但现在有了客户空间。

24
00:01:44,540 --> 00:01:49,260
这里是的客户空间，

25
00:01:49,260 --> 00:01:52,020
在这里下面是主机空间。

26
00:01:52,830 --> 00:01:57,480
我们会有一个或多个客户操作系统内核，

27
00:01:57,480 --> 00:02:05,990
我们可能有一个 Linux 内核作为一个客户内核，

28
00:02:07,340 --> 00:02:09,590
而这个 Linux 内核，

29
00:02:09,950 --> 00:02:12,620
它只是认为自己是一个普通的内核，

30
00:02:12,620 --> 00:02:14,060
它运行一系列进程，

31
00:02:14,060 --> 00:02:17,120
可能是 VI 和 C 编译器。

32
00:02:17,750 --> 00:02:20,540
然后我们可能会有其他客户机，

33
00:02:21,900 --> 00:02:25,380
我有其他客户机在这里运行，

34
00:02:25,380 --> 00:02:27,600
也许有另一个 Linux ，

35
00:02:27,600 --> 00:02:30,870
甚至可能是 Windows 这样的其他操作系统，

36
00:02:32,670 --> 00:02:34,230
都在同一台机器上运行，

37
00:02:34,830 --> 00:02:38,830
并且有 Windows 进程运行，

38
00:02:38,830 --> 00:02:42,880
在这个客户机操作系统中。

39
00:02:43,060 --> 00:02:49,180
所以虚拟机监视器运行的地方是主机世界，

40
00:02:49,180 --> 00:02:53,800
这些普通操作系统运行的是客户机世界，

41
00:02:53,860 --> 00:02:58,870
此外，我们还会讲到很多，

42
00:02:58,870 --> 00:03:09,810
在客户机世界中，客户机管理程序是内核运行的模式，

43
00:03:09,810 --> 00:03:13,170
客户机内核运行在客户用户模式。

44
00:03:16,680 --> 00:03:22,920
同样，虚拟机监视器的一般目标是，

45
00:03:22,950 --> 00:03:25,020
为了提供机器的模拟，

46
00:03:25,020 --> 00:03:25,650
这很好，

47
00:03:25,650 --> 00:03:29,370
你可以不加修改地启动普通的 Linux ，普通的 Windows ，

48
00:03:29,820 --> 00:03:32,550
并让它在这个虚拟机内运行，

49
00:03:32,550 --> 00:03:36,060
永远不用怀疑会有什么奇怪的事情发生。

50
00:03:36,820 --> 00:03:40,300
所以，虚拟机监视器必须位于

51
00:03:40,300 --> 00:03:43,750
在某种程度上模拟主管模式和用户模式之间的差异，

52
00:03:43,750 --> 00:03:48,340
它完全模拟实际硬件的工作，

53
00:03:49,000 --> 00:03:49,840
即使那是，

54
00:03:50,540 --> 00:03:52,520
你不可能真的是这样，

55
00:03:53,210 --> 00:03:56,270
这就是我们讨论的客户机管理者模式和客户机用户模式，

56
00:03:56,510 --> 00:03:59,060
VMM 对这两种模式进行模拟。

57
00:03:59,960 --> 00:04:04,640
那么你为什么要使用虚拟机，

58
00:04:05,330 --> 00:04:06,740
有很多原因，

59
00:04:06,740 --> 00:04:12,350
在一台计算机上运行许多不同的客户操作系统，

60
00:04:13,010 --> 00:04:16,010
也许你在经营一家大公司，

61
00:04:16,010 --> 00:04:18,650
你需要很多很多的服务器，

62
00:04:18,650 --> 00:04:22,040
也许域名服务器和安全服务器，或者其他的，

63
00:04:22,190 --> 00:04:25,010
而且它们中的每一个都不会使用太多的资源，

64
00:04:25,040 --> 00:04:28,850
所以为它购买一台物理机器有点浪费时间，

65
00:04:29,090 --> 00:04:31,340
但是你想要运行，

66
00:04:31,340 --> 00:04:34,880
想在单个硬件上运行大量这样的低强度服务器，

67
00:04:34,880 --> 00:04:37,940
你可以通过使用虚拟机来省钱。

68
00:04:39,190 --> 00:04:45,460
虚拟机在云计算中的应用也非常非常广泛，

69
00:04:45,550 --> 00:04:48,550
比如一个像亚马逊 AWS 这样的机构，

70
00:04:48,850 --> 00:04:52,540
他们不想把实体机租给人们，

71
00:04:52,540 --> 00:04:55,300
因为这是一个很难管理的，

72
00:04:55,300 --> 00:04:59,380
他们想要做的是租给他们的客户，

73
00:04:59,470 --> 00:05:06,850
一台机器，亚马逊决定在什么硬件上运行，

74
00:05:06,850 --> 00:05:08,890
是运行一台大一点还是小一点的机器，

75
00:05:08,890 --> 00:05:10,270
亚马逊可以决定，

76
00:05:11,920 --> 00:05:15,070
这是目前的客户，

77
00:05:15,070 --> 00:05:18,040
也许在这块硬件上有两个客户，

78
00:05:18,040 --> 00:05:19,510
但是他们不太使用计算机，

79
00:05:19,510 --> 00:05:23,110
也许它可以把第三个第四个客户放到同一台硬件上，

80
00:05:23,230 --> 00:05:26,170
不花费额外的成本，但是可以获得更多的收入。

81
00:05:26,500 --> 00:05:32,020
所以，这个虚拟机提供了某种额外的灵活性，

82
00:05:32,920 --> 00:05:35,830
这是一种使用的技巧，

83
00:05:35,830 --> 00:05:40,810
我们提升现有的操作系统内核和用户空间，

84
00:05:40,810 --> 00:05:46,090
并且在下面增加一个新的层来提供这种灵活性。

85
00:05:47,220 --> 00:05:50,880
人们使用虚拟机还有其他原因，

86
00:05:50,880 --> 00:05:52,350
一个当然是内核开发，

87
00:05:52,350 --> 00:05:54,690
这就是为什么我们使用 QEMU ，

88
00:05:55,260 --> 00:05:59,160
一种在虚拟环境中运行 xv6 的能力，

89
00:05:59,160 --> 00:06:01,190
而不是在真实计算机中，

90
00:06:01,190 --> 00:06:04,700
使这门课程对我们所有人都更方便，

91
00:06:04,880 --> 00:06:06,920
它还使调试变得更容易，

92
00:06:06,920 --> 00:06:09,050
这是因为，

93
00:06:09,260 --> 00:06:13,400
一旦你运行 xv6 和这个虚拟机环境，

94
00:06:13,400 --> 00:06:16,550
QEMU 使我们更容易提供 GDB 访问，

95
00:06:17,690 --> 00:06:19,940
比起在一台物理计算机上。

96
00:06:21,140 --> 00:06:24,410
人们使用虚拟机的最后一个原因是，

97
00:06:24,440 --> 00:06:26,480
可以有很多技巧可以使用，

98
00:06:26,840 --> 00:06:30,920
利用虚拟机监视器提供的这层额外的间接层，

99
00:06:30,920 --> 00:06:37,790
比如，你可以对整个正在运行的操作系统和用户进程设置检查点，

100
00:06:37,790 --> 00:06:39,560
你可以获取它的一个检查点，

101
00:06:40,010 --> 00:06:42,170
将其隐藏在某个地方，比如磁盘上，

102
00:06:42,170 --> 00:06:44,120
然后恢复这个检查点，

103
00:06:44,300 --> 00:06:48,870
完全相同的操作系统和进程，

104
00:06:48,900 --> 00:06:50,310
像它在检查点时那样，

105
00:06:50,310 --> 00:06:52,980
它对于调试可靠性，

106
00:06:53,100 --> 00:06:56,340
对于克隆虚拟机的内存是有用的，

107
00:06:56,340 --> 00:06:58,350
所以你可以多次运行它。

108
00:06:58,620 --> 00:07:00,180
另一个你可以玩的游戏是，

109
00:07:00,180 --> 00:07:06,060
你可以把一个客户机迁移到另一台计算机上，

110
00:07:06,150 --> 00:07:09,000
如果你在物理计算机上运行客户机操作系统，

111
00:07:09,150 --> 00:07:11,970
你需要关闭或更换物理计算机，

112
00:07:12,120 --> 00:07:16,890
你可以移动正在运行的虚拟机映像，

113
00:07:16,890 --> 00:07:19,740
在不干扰它的情况下，到另一台物理机上，

114
00:07:19,740 --> 00:07:21,390
这样你就可以关闭第一个了。

115
00:07:22,330 --> 00:07:26,020
这是一些例子，说明为什么人们喜欢虚拟机，

116
00:07:26,020 --> 00:07:29,170
人们确实非常广泛地使用虚拟机，

117
00:07:29,500 --> 00:07:31,540
而且它们也有很长的历史，

118
00:07:31,540 --> 00:07:34,060
这个想法最早是在二十世纪六十年代提出的，

119
00:07:34,060 --> 00:07:36,520
它们是随着时间的推移而发展，

120
00:07:36,640 --> 00:07:41,190
直到它们变得非常普遍，很容易使用。

121
00:07:42,690 --> 00:07:46,890
对于这门课，我们调查它们的原因是，

122
00:07:46,890 --> 00:07:51,240
虚拟机监视器提供了一种不同的角度，

123
00:07:51,240 --> 00:07:53,220
关于操作系统，

124
00:07:53,640 --> 00:07:56,640
与我们习惯的进程抽象不同，

125
00:07:56,640 --> 00:07:58,560
我们这里有一些类似的结构，

126
00:07:58,560 --> 00:08:02,130
而是提供了一种不同类型的容器，

127
00:08:02,130 --> 00:08:06,030
它不是进程，而是一种模拟机器，

128
00:08:06,690 --> 00:08:10,920
允许我们考虑我们讨论的所有东西，

129
00:08:11,490 --> 00:08:16,470
从不同的角度思考内存分配、调度保护，

130
00:08:17,790 --> 00:08:18,870
或许能给我们一些建议，

131
00:08:18,870 --> 00:08:21,750
我们可以带回到传统的操作系统内核，

132
00:08:22,050 --> 00:08:24,570
实际上很多方案，

133
00:08:24,900 --> 00:08:28,770
开发设计、开发研究的方案，

134
00:08:28,800 --> 00:08:32,880
已经从传统内核

135
00:08:33,600 --> 00:08:36,930
向下转移到虚拟机监视器本身，

136
00:08:36,930 --> 00:08:38,760
随着它们变得越来越普遍，

137
00:08:38,760 --> 00:08:42,330
所以，在某种意义上，操作系统的话题

138
00:08:42,330 --> 00:08:45,660
向下漂移了一层。

139
00:08:48,090 --> 00:08:52,260
好的，这节课我想讨论的第一部分，

140
00:08:52,440 --> 00:08:59,520
介绍一下我们如何实现自己的虚拟机，

141
00:08:59,550 --> 00:09:03,570
我将使用 RISC-V 作为一种，

142
00:09:04,280 --> 00:09:08,720
假设我们正在尝试模拟 RISC-V 硬件，

143
00:09:08,720 --> 00:09:12,650
让我们可以运行为 RISC-V 设计的 xv6 操作系统。

144
00:09:14,420 --> 00:09:18,800
再重复一下具体的目标，

145
00:09:19,610 --> 00:09:24,020
我们所希望的是一种典型的虚拟机，

146
00:09:24,200 --> 00:09:25,280
我们想要构建的是

147
00:09:25,280 --> 00:09:30,800
客户机软件完全没有意识到，

148
00:09:30,980 --> 00:09:32,990
它在虚拟机中运行，

149
00:09:33,230 --> 00:09:35,210
我们想要构建一些东西，

150
00:09:35,570 --> 00:09:38,600
使客户机软件不可能区分，

151
00:09:38,780 --> 00:09:42,710
确定是在真实机器上运行还是在虚拟机上运行，

152
00:09:42,710 --> 00:09:44,660
我们希望模拟能有那么好的效果。

153
00:09:45,090 --> 00:09:47,400
原因是，我们不想，

154
00:09:47,910 --> 00:09:49,800
我们希望能够，

155
00:09:49,830 --> 00:09:52,080
我们希望能够在我们的虚拟机中运行任何东西，

156
00:09:52,170 --> 00:09:55,200
任何操作系统，甚至可能是我们没有听说过的操作系统，

157
00:09:55,440 --> 00:09:57,330
这意味着，

158
00:09:57,330 --> 00:10:00,510
无论操作系统做什么有趣的事情，

159
00:10:00,510 --> 00:10:01,800
无论它使用硬件的方式是什么，

160
00:10:02,010 --> 00:10:08,620
虚拟机必须提供精确的硬件模拟，

161
00:10:08,620 --> 00:10:11,230
所以，在真实硬件上起作用的任何技巧

162
00:10:11,230 --> 00:10:12,850
也将在虚拟机上起作用。

163
00:10:14,620 --> 00:10:20,290
我们想要的类似目标是，

164
00:10:20,350 --> 00:10:21,670
我们希望没有办法，

165
00:10:21,670 --> 00:10:26,020
不仅客户机无法决定它是否在虚拟机上运行，

166
00:10:26,050 --> 00:10:29,530
而且客户机也无法从虚拟机中逃脱，

167
00:10:29,560 --> 00:10:32,530
人们使用虚拟机的很多原因是

168
00:10:32,530 --> 00:10:37,120
为了对不可信的软件提供严格的限制，

169
00:10:37,240 --> 00:10:40,240
即使不可信操作系统在虚拟机中运行，

170
00:10:40,420 --> 00:10:43,750
比如，如果你是亚马逊，并且销售云服务器，

171
00:10:44,110 --> 00:10:47,770
你的客户通常提供操作系统，

172
00:10:47,800 --> 00:10:50,290
在虚拟机上运行的（操作系统）和应用程序，

173
00:10:50,530 --> 00:10:53,620
天哪，你的客户不是在运行普通的 Linux ，

174
00:10:53,680 --> 00:10:55,960
他们正在运行一个特殊版本的 Linux ，

175
00:10:55,990 --> 00:11:00,880
他们试图突破它的虚拟机，

176
00:11:00,880 --> 00:11:05,590
并闯入亚马逊或其他用户的虚拟机，

177
00:11:05,590 --> 00:11:10,690
或者进入 Amazon 用来实施隔离的虚拟机监视器。

178
00:11:10,960 --> 00:11:13,130
所以，这很重要，

179
00:11:13,370 --> 00:11:16,520
客户机不能突破它们的虚拟机，

180
00:11:16,520 --> 00:11:18,290
它们能够使用内存，

181
00:11:18,650 --> 00:11:21,590
那些虚拟机监视器允许它们使用的内存，

182
00:11:21,770 --> 00:11:23,630
但不能使用其他内存，

183
00:11:24,350 --> 00:11:26,360
同样，它们不应该接触到，

184
00:11:26,600 --> 00:11:31,760
没有权限使用存储设备或网卡之类的东西，

185
00:11:32,120 --> 00:11:34,010
所以你有非常严格的隔离。

186
00:11:34,250 --> 00:11:36,800
并且在许多方面

187
00:11:36,830 --> 00:11:42,650
虚拟机提供了比普通 Unix 进程更严格的隔离，

188
00:11:42,860 --> 00:11:44,990
普通的 Unix 进程通常可以交互，

189
00:11:44,990 --> 00:11:46,400
它们可以杀死对方，

190
00:11:46,400 --> 00:11:50,540
它们也可以读写相同的文件或通过管道进行通信，

191
00:11:50,600 --> 00:11:56,090
但是，在一种通常的虚拟机中，这些都是不可能的，

192
00:11:56,510 --> 00:12:00,650
不同的虚拟机运行在同一台计算机上，

193
00:12:01,580 --> 00:12:05,420
通过虚拟机监视器彼此完全隔离。

194
00:12:05,420 --> 00:12:06,950
所以人们因为安全喜欢它们，

195
00:12:07,160 --> 00:12:09,740
这是一种能够运行不可信软件的方式，

196
00:12:10,790 --> 00:12:13,040
而不必担心它有漏洞或是恶意的。

197
00:12:14,480 --> 00:12:16,730
在实践中，

198
00:12:17,590 --> 00:12:24,610
我将目标定位为完全忠实地模拟物理机，

199
00:12:24,610 --> 00:12:30,340
事实上，由于性能原因，这通常是模糊的，

200
00:12:30,340 --> 00:12:32,170
比如，你会发现，

201
00:12:32,770 --> 00:12:37,810
Linux 和常见的虚拟机监视器有点协同发展，

202
00:12:37,810 --> 00:12:39,580
所以在现实生活中，

203
00:12:39,640 --> 00:12:42,850
Linux 实际上可能意识到它是在虚拟机监视器上运行，

204
00:12:42,850 --> 00:12:46,060
并且利用虚拟机监视的权限达到效率，

205
00:12:46,870 --> 00:12:51,100
Linux 有时会与虚拟机监视器交互，

206
00:12:51,100 --> 00:12:53,920
做一些事情，比如高速访问设备，

207
00:12:54,160 --> 00:12:56,290
但这是一个精心控制的例外情况，

208
00:12:56,530 --> 00:13:01,940
总体策略是完全忠实的模拟。

209
00:13:05,870 --> 00:13:09,410
好的，那么我们怎么才能建造我们自己的虚拟机监视器。

210
00:13:11,760 --> 00:13:15,120
好的，一种可能性是完全用软件来做，

211
00:13:15,150 --> 00:13:19,200
你可以想象写一些像 QEMU 这样的东西，

212
00:13:19,350 --> 00:13:23,070
它解释机器指令，

213
00:13:23,070 --> 00:13:27,150
也就是说你可以编写一个程序来打开 xv6 ，

214
00:13:27,210 --> 00:13:30,870
读取包含 xv6 指令的文件，

215
00:13:30,990 --> 00:13:33,000
你的程序可以查看这些指令，

216
00:13:33,000 --> 00:13:36,390
说，那是一条加载指令或一条移动指令，

217
00:13:36,390 --> 00:13:41,250
你的程序可以模拟 RISC-V 状态，

218
00:13:41,250 --> 00:13:45,060
可以有以软件实现的 32 个寄存器，

219
00:13:45,770 --> 00:13:48,650
当你的软件读取每条指令并将其拆分时，

220
00:13:48,650 --> 00:13:50,090
它会弄清楚是什么指令，

221
00:13:50,090 --> 00:13:56,810
它会将指令应用于这 32 个寄存器和控制寄存器，

222
00:13:56,810 --> 00:13:58,730
这些寄存器都是用软件模拟的。

223
00:13:59,710 --> 00:14:01,210
人们这样做，

224
00:14:01,660 --> 00:14:05,590
理论上上很简单让它发挥作用，

225
00:14:05,590 --> 00:14:09,020
尽管可能要做很多工作才能把所有的细节都做好，

226
00:14:09,500 --> 00:14:21,530
纯软件解释型虚拟机之所以没有被广泛使用，

227
00:14:21,530 --> 00:14:22,520
是因为它们速度慢，

228
00:14:23,380 --> 00:14:24,670
如果你这么做，

229
00:14:24,760 --> 00:14:27,340
你的虚拟机将运行客户机软件

230
00:14:27,340 --> 00:14:32,110
以一个比你使用的硬件慢得多的速度运行，

231
00:14:32,110 --> 00:14:35,260
因为你的虚拟机监控软件必须

232
00:14:35,260 --> 00:14:37,540
查看每条它要执行的指令，

233
00:14:37,720 --> 00:14:41,110
你的机器监视器可能运行数十条指令，

234
00:14:41,380 --> 00:14:44,680
在解释每一条客户机指令的过程中，

235
00:14:44,680 --> 00:14:48,740
所以它会比实际的计算机慢几个数量级，

236
00:14:48,740 --> 00:14:51,050
对于云计算之类的东西，

237
00:14:51,790 --> 00:14:53,770
这是不现实的。

238
00:14:53,860 --> 00:14:58,730
所以，人们不会使用软件解释

239
00:14:59,090 --> 00:15:01,610
来为生产系统构建虚拟机，

240
00:15:02,000 --> 00:15:09,810
取而代之的是，某种核心的，

241
00:15:10,080 --> 00:15:15,840
被广泛使用的主要策略之一是

242
00:15:15,900 --> 00:15:21,030
在实际的 CPU 上运行客户机指令。

243
00:15:24,000 --> 00:15:29,340
所以，如果你要在虚拟机监视器中运行 xv6 ，

244
00:15:29,430 --> 00:15:33,840
你实际上会加载 xv6 内核的指令，

245
00:15:33,870 --> 00:15:37,880
一开始，内存中有完整的 xv6 指令，

246
00:15:37,880 --> 00:15:43,970
然后跳到 xv6 中的第一条指令。

247
00:15:45,410 --> 00:15:49,430
为了让你的计算机实际运行 xv6 中的指令，

248
00:15:49,430 --> 00:15:51,200
当然，这需要你的计算机

249
00:15:51,200 --> 00:15:55,520
具有与 xv6 期望的相同的微处理器，

250
00:15:55,520 --> 00:15:58,490
但那很容易安排。

251
00:15:59,570 --> 00:16:02,770
现在，事实证明你不能真的这么做，

252
00:16:02,800 --> 00:16:05,470
你会遇到麻烦的地方是，

253
00:16:05,470 --> 00:16:12,470
当你的客户机操作系统第一次执行特权指令时。

254
00:16:12,500 --> 00:16:17,760
内核和普通用户代码之间的真正区别是，

255
00:16:17,760 --> 00:16:20,280
我们试图在这里运行的内核，

256
00:16:20,280 --> 00:16:22,950
在虚拟机中，内核使用特权指令，

257
00:16:23,250 --> 00:16:26,220
你的客户机内核，

258
00:16:26,280 --> 00:16:31,110
会尝试将新的页表加载到 RISC-V 的 satp 寄存器中。

259
00:16:32,670 --> 00:16:34,500
所以这开始出现出一个难题，

260
00:16:35,540 --> 00:16:39,440
如果我们将客户机内核作为普通用户进程运行，

261
00:16:39,440 --> 00:16:45,410
比如 Linux 在用户模式中加载 satp 是非法指令，

262
00:16:45,470 --> 00:16:47,210
那么我们的程序就会崩溃，

263
00:16:47,750 --> 00:16:49,040
如果我们愚蠢到

264
00:16:49,040 --> 00:16:54,740
将客户机内核加载并在管理模式下运行它，

265
00:16:55,880 --> 00:17:00,440
有时候，我们的客户机内核将能够修改实际的页表，

266
00:17:00,440 --> 00:17:03,620
将能够逃离它的虚拟机，

267
00:17:03,980 --> 00:17:11,020
因为它可以控制 PTE 的内容，读写任何内存。

268
00:17:11,050 --> 00:17:14,980
所以我们不能使用这种简单的策略，

269
00:17:14,980 --> 00:17:17,770
只是直接运行客户机内核，

270
00:17:18,610 --> 00:17:20,680
相反，我们要使用一些技巧。

271
00:17:21,340 --> 00:17:28,240
第一步，是在用户模式下运行客户机内核，

272
00:17:32,240 --> 00:17:39,900
所以，这是一种基本策略，

273
00:17:39,960 --> 00:17:42,030
我们在用户模式下运行客户机内核，

274
00:17:42,770 --> 00:17:46,340
在 RISC-V 用户模式下，

275
00:17:46,460 --> 00:17:48,350
这意味着，

276
00:17:48,880 --> 00:17:52,510
我们编写自己的虚拟机监视器，

277
00:17:52,930 --> 00:17:55,180
当我们告诉它启动 xv6 时，

278
00:17:55,300 --> 00:17:59,890
它会将 xv6 的内核指令加载到内存中的某个地方，

279
00:18:02,120 --> 00:18:03,980
或许设置一个页表，

280
00:18:03,980 --> 00:18:07,100
这使得 xv6 中，

281
00:18:07,130 --> 00:18:11,240
它的内存从 0 开始到任何较高的内存，

282
00:18:11,360 --> 00:18:15,170
然后是虚拟机监视器，

283
00:18:15,170 --> 00:18:20,830
我们使用 xv6 上遇到的 trap sret 指令，

284
00:18:20,950 --> 00:18:31,180
在用户模式下，跳转到客户机操作系统的第一条指令，

285
00:18:31,600 --> 00:18:33,790
所以，客户机操作系统将单独执行，

286
00:18:33,790 --> 00:18:35,710
很多指令都可以很好地工作，

287
00:18:35,710 --> 00:18:39,100
如果客户机操作系统将两个寄存器加在一起，

288
00:18:39,640 --> 00:18:42,100
从内存中读取、加载或存储就可以了，

289
00:18:42,370 --> 00:18:46,180
并且一旦客户机操作系统使用特权指令，

290
00:18:46,210 --> 00:18:48,790
接下来会发生的是它会 trap ，

291
00:18:48,850 --> 00:18:50,710
RISC-V 硬件引起它，

292
00:18:50,890 --> 00:18:53,410
由于它在用户模式下运行，而不是在管理者模式，

293
00:18:53,560 --> 00:18:56,740
会导致它 trap 回到我们的虚拟机监视器，

294
00:18:56,740 --> 00:18:58,030
我们将获得控制权，

295
00:18:58,450 --> 00:19:03,730
所以如果客户操作系统试图修改 satp 页表指针，

296
00:19:03,910 --> 00:19:07,990
RISC-V CPU 将 trap 进入我们的虚拟机监视器，

297
00:19:07,990 --> 00:19:09,970
我们的软件就会夺回控制权。

298
00:19:10,890 --> 00:19:12,720
而我们的软件能够查看

299
00:19:12,720 --> 00:19:17,130
什么指令导致了 trap ，并采取适当的措施，

300
00:19:17,850 --> 00:19:19,260
但这里最酷的是，

301
00:19:19,260 --> 00:19:24,340
客户及操作系统实际上并没有设置页表指针。

302
00:19:24,460 --> 00:19:28,900
但是 VMM 是如何拦截这个，

303
00:19:28,900 --> 00:19:31,480
它必须设置 trap 处理程序，对吗，

304
00:19:31,510 --> 00:19:35,020
这不是只有特权进程才能做的事情吗，

305
00:19:35,680 --> 00:19:39,100
VMM 只是主机操作系统上的用户程序，对吧。

306
00:19:39,100 --> 00:19:40,720
好的，我假设，

307
00:19:41,940 --> 00:19:46,170
我假设虚拟机监视器在管理者模式下运行，

308
00:19:46,170 --> 00:19:48,150
所以，在这个简单的图中，

309
00:19:48,420 --> 00:19:53,310
虚拟机监视器是在这块硬件上启动的内核，

310
00:19:53,700 --> 00:19:57,720
所以，不是启动 Linux ，而是你要启动的虚拟机监视器，

311
00:19:57,840 --> 00:19:59,280
它在管理模式下启动，

312
00:19:59,280 --> 00:20:01,080
它完全控制硬件，

313
00:20:01,500 --> 00:20:06,120
所以我们可以设置 stvec 和所有其他东西。

314
00:20:06,540 --> 00:20:07,350
理解了。

315
00:20:07,710 --> 00:20:11,910
实际上有些虚拟机监视器就是这样工作的，

316
00:20:11,910 --> 00:20:13,230
你只需在硬件上启动它们，

317
00:20:13,230 --> 00:20:17,160
只有虚拟机监视器在管理程序模式下运行。

318
00:20:17,940 --> 00:20:21,210
事实上，还有很多虚拟机方案，

319
00:20:21,210 --> 00:20:24,270
事实上，启动 Linux ，

320
00:20:25,940 --> 00:20:28,010
然后一旦 Linux 启动并运行，

321
00:20:28,250 --> 00:20:32,300
你加载虚拟的，

322
00:20:32,330 --> 00:20:36,830
实际上 Linux 带有一个虚拟机监视器，

323
00:20:36,830 --> 00:20:38,660
你加载虚拟机监视器，

324
00:20:38,660 --> 00:20:42,830
所谓的可加载内核模块加载到 Linux 中，

325
00:20:43,100 --> 00:20:46,370
并且它以管理者模式在内核中运行。

326
00:20:47,040 --> 00:20:49,800
这就是今天的文件所说的方式，

327
00:20:49,860 --> 00:20:54,220
启动 Linux ，然后运行这个可加载的内核模块，

328
00:20:54,430 --> 00:20:57,460
但重点是虚拟机监控软件，

329
00:20:57,460 --> 00:21:01,120
我们重写的信任的软件运行管理者模式下，

330
00:21:01,620 --> 00:21:04,770
现在，我们可以在用户模式下运行客户机，

331
00:21:05,540 --> 00:21:09,530
但是要安排它看起来像是在管理者模式下运行。

332
00:21:12,540 --> 00:21:16,170
好的，好消息是，

333
00:21:16,170 --> 00:21:22,950
在 RISC-V 上，所有危险的 trap ，

334
00:21:22,950 --> 00:21:26,650
如果你尝试在用户模式下执行此操作，

335
00:21:26,740 --> 00:21:30,490
这就是管理者模式可以执行的所有特权操作，

336
00:21:30,580 --> 00:21:34,870
除了与页表或 PTE 有关的内容，

337
00:21:34,870 --> 00:21:35,950
我们将在稍后讨论，

338
00:21:35,950 --> 00:21:42,050
但每个管理者专用指令都会导致 trap ，

339
00:21:42,050 --> 00:21:44,600
如果你尝试在用户模式下执行。

340
00:21:45,140 --> 00:21:46,850
这意味着每次他们必须停止运行系统，

341
00:21:46,850 --> 00:21:51,230
执行读取 scause 或读写 stvec 或执行任何这些操作，

342
00:21:51,230 --> 00:21:56,420
xv6 用于配置 RISC-V 硬件的特权部分，

343
00:21:56,480 --> 00:21:58,790
将导致 trap 进入虚拟机监视器，

344
00:21:59,990 --> 00:22:01,130
我们将获得控制权。

345
00:22:01,950 --> 00:22:05,000
然后，游戏将成为

346
00:22:05,000 --> 00:22:11,210
虚拟机监视器将会维护虚拟状态，

347
00:22:11,450 --> 00:22:25,450
客户机的虚拟状态信息的整个表，

348
00:22:25,480 --> 00:22:27,880
所以虚拟机监视器将具有，

349
00:22:27,880 --> 00:22:36,760
比如，在软件中实现的虚拟 stvec 寄存器，

350
00:22:36,760 --> 00:22:42,000
以及虚拟 sepc 寄存器，

351
00:22:42,000 --> 00:22:44,520
所有这些受保护的寄存器，

352
00:22:44,520 --> 00:22:46,440
这里有一整组的寄存器，

353
00:22:46,590 --> 00:22:48,480
由虚拟机监视器实现，

354
00:22:48,630 --> 00:22:51,930
当客户机操作系统运行指令时，

355
00:22:51,930 --> 00:22:53,970
它读取这些寄存器中的一个，

356
00:22:54,090 --> 00:22:57,270
它会设 trap ，因为这在用户空间是不合法的，

357
00:22:57,450 --> 00:22:59,970
虚拟机监视器将检查指令，

358
00:23:00,030 --> 00:23:04,290
并说，这是一条指令读取 sepc 寄存器，

359
00:23:04,680 --> 00:23:08,640
所以虚拟机监视器随后将模拟这个指令，

360
00:23:08,700 --> 00:23:13,770
它将从数组中读取虚拟 sepc 的值，

361
00:23:14,640 --> 00:23:18,090
它会将其复制到硬件中，

362
00:23:18,510 --> 00:23:22,890
好的，这里真正发生的事情是，

363
00:23:26,750 --> 00:23:32,820
嗯，我忘了它的名字，

364
00:23:34,400 --> 00:23:36,590
有一条指令，我忘了它的名字，

365
00:23:36,590 --> 00:23:38,900
它是 ssread ，

366
00:23:39,380 --> 00:23:40,850
虽然这不是它的名字，

367
00:23:40,850 --> 00:23:42,800
你给它一个普通的寄存器，

368
00:23:42,800 --> 00:23:45,650
以及一个特权寄存器，比如 sepc ，

369
00:23:46,070 --> 00:23:50,540
所以 trap 虚拟机监视器将读取这个指令，

370
00:23:51,040 --> 00:23:52,750
看到这是一个 ssread ，

371
00:23:52,960 --> 00:24:00,190
虚拟机监视器将复制虚拟 sepc 到 trapframe 的 a0 中，

372
00:24:00,640 --> 00:24:02,560
最后，当进入 VMM 时，

373
00:24:02,560 --> 00:24:05,570
会创建一个 trapframe ，

374
00:24:05,570 --> 00:24:07,880
复制所有客户机寄存器，

375
00:24:07,880 --> 00:24:10,880
复制 sepc 到 trapframe 中的 a0 ，

376
00:24:11,060 --> 00:24:14,300
然后使用 sret 从 trap 返回，

377
00:24:17,000 --> 00:24:20,960
在复制 trapframe 寄存器之后，真正的寄存器，

378
00:24:20,960 --> 00:24:25,750
从 trap 返回到 ssread 指令之后，

379
00:24:25,750 --> 00:24:26,950
并且继续在那里读取，

380
00:24:26,950 --> 00:24:33,170
将 a0 设置为虚拟 sepc 。

381
00:24:33,950 --> 00:24:37,100
现在客户机操作系统将继续运行，

382
00:24:37,580 --> 00:24:41,030
[]没有意识到这里发生了一些有趣的事情，

383
00:24:41,990 --> 00:24:46,490
但它将获得虚拟 sepc 的复制，

384
00:24:46,490 --> 00:24:48,440
保存在 VMM 之中。

385
00:24:50,500 --> 00:24:53,470
那么对这个策略，有什么问题吗？

386
00:24:58,400 --> 00:25:02,930
VMM 如何区分不同的客户机？

387
00:25:04,880 --> 00:25:08,750
它基本上是一样的，

388
00:25:08,750 --> 00:25:13,130
它将为每个客户机保存一个虚拟状态表，

389
00:25:13,520 --> 00:25:16,640
就像 xv6 知道哪个进程正在运行一样，

390
00:25:16,640 --> 00:25:19,490
有一个变量，可能是每个核心的变量表示，

391
00:25:19,610 --> 00:25:21,290
这是我正在运行的进程，

392
00:25:22,260 --> 00:25:26,210
类似地， VMM 将有每个核心的变量，

393
00:25:26,210 --> 00:25:31,490
它指示哪个虚拟机是这些状态结构，

394
00:25:31,520 --> 00:25:33,980
VMM 将知道哪个虚拟机正在运行，

395
00:25:33,980 --> 00:25:37,580
并且在适当的虚拟机状态结构中查找，

396
00:25:38,040 --> 00:25:42,960
查找 sepc 或它正在寻找的任何东西。

397
00:25:43,480 --> 00:25:49,630
它可以为一个客户机分配多个核心吗？

398
00:25:49,810 --> 00:25:53,290
是的，先进的虚拟机监视器可以做到这一点，是的。

399
00:25:56,870 --> 00:25:58,370
所以，如果你，抱歉，请继续。

400
00:25:58,820 --> 00:26:01,820
哦，抱歉，所以客户机操作系统，

401
00:26:02,150 --> 00:26:05,030
它会有一些寄存器，

402
00:26:05,390 --> 00:26:10,070
在实际硬件中是客户操作系统使用的寄存器，

403
00:26:10,250 --> 00:26:15,830
那么为什么我们不使用实际的 sepc ，而使用虚拟的？

404
00:26:23,810 --> 00:26:27,560
原因是虚拟机监视器需要使用这些寄存器，

405
00:26:27,560 --> 00:26:29,780
需要使用真实寄存器，

406
00:26:30,260 --> 00:26:32,270
比如，考虑一下 scause ，

407
00:26:33,280 --> 00:26:35,920
当 trap 发生时，会发生什么，

408
00:26:35,950 --> 00:26:40,180
当客户机操作系统尝试执行任何特权时，

409
00:26:40,180 --> 00:26:41,110
将会发生 trap ，

410
00:26:41,140 --> 00:26:46,810
而硬件设置真实的 scause 寄存器为 trap 的原因，

411
00:26:47,510 --> 00:26:52,190
不管是非法指令还是非特权指令，

412
00:26:52,250 --> 00:26:57,130
但是如果客户机操作系统，

413
00:26:57,340 --> 00:26:58,870
假设客户操作系统

414
00:26:58,870 --> 00:27:03,100
刚刚接受了来自客户用户进程的系统调用，

415
00:27:03,190 --> 00:27:06,850
客户机操作系统需要查看 scause ，

416
00:27:06,940 --> 00:27:12,760
这才是系统调用的正确 scause 的值，

417
00:27:12,790 --> 00:27:14,350
即使可能最后一件事，

418
00:27:14,350 --> 00:27:18,940
客户机操作系统将读取 scause ，

419
00:27:21,280 --> 00:27:23,080
在 trap 处理程序中，

420
00:27:23,080 --> 00:27:23,950
并且它认为，

421
00:27:23,950 --> 00:27:28,990
trap 处理程序处理来自其客户机进程的系统调用，

422
00:27:29,050 --> 00:27:32,230
客户操作系统需要查看的 scause ，

423
00:27:32,260 --> 00:27:34,840
那个值是不是系统调用，

424
00:27:35,340 --> 00:27:37,290
但 scause 将会是，

425
00:27:37,290 --> 00:27:40,440
真正的 scause 寄存器是那个 scause ，

426
00:27:40,440 --> 00:27:42,960
意味着非法指令或非特权指令，

427
00:27:42,990 --> 00:27:46,500
或者违反特权规则的指令，

428
00:27:46,620 --> 00:27:52,990
所以，有些时候你可以，

429
00:27:53,680 --> 00:28:02,180
不管怎么说，一般说来， VMM 是需要看到真实的，

430
00:28:02,210 --> 00:28:05,150
VMM 需要在真实寄存器中看到不同的值，

431
00:28:05,150 --> 00:28:10,010
而操作系统应该在它的寄存器中看到它。

432
00:28:11,950 --> 00:28:12,730
这能理解吗？

433
00:28:12,730 --> 00:28:13,720
谢谢，是的。

434
00:28:17,270 --> 00:28:19,970
好的，这就是所谓的，

435
00:28:19,970 --> 00:28:24,230
这种风格的虚拟机实现的名称，

436
00:28:24,230 --> 00:28:26,000
客户机在用户级别运行，

437
00:28:26,330 --> 00:28:29,990
每当试图做任何有特权的事情时，都会进入 trap ，

438
00:28:29,990 --> 00:28:32,570
然后 VMM 可以模拟特权指令，

439
00:28:32,750 --> 00:28:35,660
它的名字叫 TRAP-AND-EMULATE 。

440
00:28:38,290 --> 00:28:40,360
而且，它很好，

441
00:28:40,360 --> 00:28:43,270
因为你可以自己建造这个，

442
00:28:43,270 --> 00:28:46,270
实际上，你们完全可以用软件为自己建造这个，

443
00:28:46,540 --> 00:28:53,230
比如，你可以将 xv6 修改为 RISC-V 上的虚拟机监视器，

444
00:28:53,860 --> 00:28:56,800
运行虚拟机，也许是普通的 xv6 ，

445
00:28:57,820 --> 00:29:03,490
只需编写在管理者模式下运行的软件。

446
00:29:07,330 --> 00:29:10,630
这里的状态，所有以 s 开头的寄存器，

447
00:29:10,630 --> 00:29:17,260
所有那些管理程序控制寄存器必须是虚拟状态的一部分，

448
00:29:17,470 --> 00:29:21,040
还有一些其他的东西是不能直接接触到的，

449
00:29:22,020 --> 00:29:25,770
那些不需要在这个状态下 s 寄存器，

450
00:29:25,800 --> 00:29:27,090
其中之一是模式，

451
00:29:27,120 --> 00:29:28,920
虚拟机监视器需要知道，

452
00:29:28,920 --> 00:29:35,280
虚拟机运行在客户用户模式还是客户操作系统中，

453
00:29:35,280 --> 00:29:41,370
因为比如如果用户代码执行特权指令，

454
00:29:41,370 --> 00:29:42,960
比如，尝试读取 scause ，

455
00:29:42,990 --> 00:29:45,090
当然这也会导致 trap 进入 VMM ，

456
00:29:45,180 --> 00:29:49,950
但是在这种情况下， VMM 不应该仅仅模拟指令，

457
00:29:50,130 --> 00:29:52,350
因为这不是用户模式下的合法指令，

458
00:29:52,350 --> 00:29:53,880
所以， VMM 必须跟踪

459
00:29:55,260 --> 00:29:59,220
客户机是处于客户机管理者模式还是客户机用户模式，

460
00:29:59,220 --> 00:30:03,090
所以这里也会有一个模式插槽，

461
00:30:03,180 --> 00:30:04,230
VMM 就会知道，

462
00:30:04,230 --> 00:30:10,120
因为当客户机操作系统跳入用户空间时，

463
00:30:10,120 --> 00:30:12,310
它将执行 sret 指令，

464
00:30:12,310 --> 00:30:13,930
sret 是一条特权指令，

465
00:30:13,930 --> 00:30:15,670
所以， VMM 将在那里获得控制权，

466
00:30:15,670 --> 00:30:18,520
然后就会发现客户机正在运行一条 sret 指令，

467
00:30:18,910 --> 00:30:23,140
在其他方面，我将把虚拟机模式从管理者改为用户。

468
00:30:25,490 --> 00:30:32,290
另一个隐藏的状态是 hart 数，也就是核心数，

469
00:30:34,250 --> 00:30:37,490
即使有了特权指令，你也不能直接访问它，

470
00:30:37,910 --> 00:30:43,850
但是 VMM 管理器需要跟踪它现在正在模拟的 hart 。

471
00:30:46,240 --> 00:30:54,450
好的， RISC-V 证明不同的 CPU 有不同的难度，

472
00:30:55,770 --> 00:31:00,750
在 RISC-V 上编写 trap-and-emulate 虚拟机是多么困难，

473
00:31:00,750 --> 00:31:03,060
特别是适应它，

474
00:31:03,060 --> 00:31:05,190
因为设计者必须考虑这些，

475
00:31:05,190 --> 00:31:07,020
在他们设计指令集时，

476
00:31:07,350 --> 00:31:12,000
所以，他们知道 trap-and-emulate 虚拟机的要求是什么，

477
00:31:12,180 --> 00:31:15,930
比如，他们非常努力地确保，

478
00:31:15,930 --> 00:31:20,250
管理者代码可以执行的每一项特权操作会导致 trap ，

479
00:31:20,250 --> 00:31:21,660
如果你尝试在用户模式下执行它，

480
00:31:21,690 --> 00:31:22,830
这是你需要的，

481
00:31:23,040 --> 00:31:28,640
确保虚拟机监视器看到每个特权指令的 trap 。

482
00:31:32,820 --> 00:31:34,140
我有一个简短的问题，

483
00:31:34,170 --> 00:31:38,130
那么，是否有任何运行在客户机操作系统本身中的，

484
00:31:38,280 --> 00:31:40,860
或者它总是 trap 进入虚拟机监视器中？

485
00:31:41,400 --> 00:31:44,220
所有普通指令，

486
00:31:44,670 --> 00:31:47,460
比如如果你只有一条加法指令，

487
00:31:47,460 --> 00:31:51,750
add ，我不知道这个用 RISC-V 汇编怎么写，

488
00:31:51,750 --> 00:31:54,450
但是假设你把 a0 加到 a1 上，

489
00:31:54,450 --> 00:31:56,310
你想把结果放到 a2 里，

490
00:31:56,550 --> 00:32:01,170
这个指令直接在硬件上执行，以全部硬件数度。

491
00:32:01,870 --> 00:32:05,980
如果你使用一个普通的函数调用，

492
00:32:07,970 --> 00:32:09,200
在客户机世界里，

493
00:32:09,410 --> 00:32:14,050
它只是执行，没有什么特殊的，只是一个普通的，

494
00:32:14,080 --> 00:32:17,530
所有指令在用户代码中都是合法的，

495
00:32:18,240 --> 00:32:22,440
这些指令以全速直接执行，

496
00:32:22,650 --> 00:32:24,960
当客户机执行它们的时候。

497
00:32:25,890 --> 00:32:31,920
好的，那么在客户机操作系统中有没有用户模式和内核模式的[外观]呢？

498
00:32:32,920 --> 00:32:34,600
是的，客户机操作系统是，

499
00:32:36,230 --> 00:32:40,010
客户机操作系统没有改变，

500
00:32:40,560 --> 00:32:44,400
我们在这里运行的就是 Linux 内核，

501
00:32:44,400 --> 00:32:46,440
就是 xv6 内核，

502
00:32:46,560 --> 00:32:49,350
当然， xv6 知道，

503
00:32:49,350 --> 00:32:54,140
xv6 内核知道它在管理模式下运行，

504
00:32:54,140 --> 00:32:56,750
当然它不在这里，

505
00:32:56,750 --> 00:32:58,550
但就代码而言，

506
00:32:58,640 --> 00:33:00,530
它肯定是在运行管理模式，

507
00:33:00,530 --> 00:33:03,920
它做各种特权的事情，并期望它们能起作用，

508
00:33:04,400 --> 00:33:08,180
然后它知道何时执行 sret 进入用户空间，

509
00:33:08,180 --> 00:33:11,030
知道现在要进入用户空间了。

510
00:33:13,000 --> 00:33:16,840
VMM 让一切看起来都像是

511
00:33:16,960 --> 00:33:18,220
这些真的在发生，

512
00:33:19,870 --> 00:33:23,080
即使它是在真实的机器里，

513
00:33:23,080 --> 00:33:26,170
在这两个地方，它都处于用户模式，

514
00:33:26,410 --> 00:33:28,630
但这看起来是管理者模式，

515
00:33:28,630 --> 00:33:29,710
这看起来是用户模式。

516
00:33:35,100 --> 00:33:36,780
好的。

517
00:33:38,550 --> 00:33:41,490
好的，当客户机，

518
00:33:41,490 --> 00:33:44,130
当我们执行 sret 进入用户空间时，

519
00:33:44,280 --> 00:33:51,690
sret 特权被幸运地捕获到虚拟机监视器中，

520
00:33:52,290 --> 00:33:55,500
虚拟机监视器将虚拟模式更改为用户模式，

521
00:33:55,980 --> 00:33:57,960
当然，真正的模式仍然是管理者模式，

522
00:33:57,960 --> 00:33:59,250
因为我们还在下面，

523
00:33:59,340 --> 00:34:01,350
将虚拟模式改变为用户模式，

524
00:34:03,810 --> 00:34:07,440
在它从 trap 返回之前，

525
00:34:07,470 --> 00:34:14,700
虚拟机监视器将真实 sepc 设置为虚拟 sepc ，

526
00:34:14,760 --> 00:34:20,880
因为在虚拟机监视器使用自己的 sret 返回时，

527
00:34:21,030 --> 00:34:24,810
程序计数器值，

528
00:34:24,810 --> 00:34:27,210
它作为程序值返回是

529
00:34:27,210 --> 00:34:30,810
客户操作系统想要返回的程序计数器。

530
00:34:31,670 --> 00:34:33,770
这里有一个非常简短的例子，

531
00:34:33,830 --> 00:34:37,880
真实的 sepc 被设置为虚拟的 sepc ，

532
00:34:40,180 --> 00:34:41,920
稍后我会谈到这一点，

533
00:34:41,920 --> 00:34:45,130
虚拟机监视器也会切换页表，

534
00:34:45,130 --> 00:34:48,700
当它返回到虚拟机时，

535
00:34:49,810 --> 00:34:52,540
当客户机用户代码想要，

536
00:34:52,540 --> 00:34:56,290
客户机代码普通指令执行机器，

537
00:34:56,410 --> 00:34:58,030
以全速执行它们，

538
00:34:58,570 --> 00:35:04,060
当客户机代码想要进行系统调用时，

539
00:35:04,330 --> 00:35:06,430
执行 ecall 指令，

540
00:35:07,040 --> 00:35:08,750
这会导致 trap ，

541
00:35:08,780 --> 00:35:11,960
这个 trap 会到达虚拟机监视器，

542
00:35:12,050 --> 00:35:13,730
虚拟机监视器会说，

543
00:35:13,730 --> 00:35:18,140
它的虚拟模式是用户空间，

544
00:35:18,560 --> 00:35:20,720
它会查看指令，

545
00:35:20,720 --> 00:35:23,240
trap 导致 ecall ，

546
00:35:24,230 --> 00:35:25,940
然后虚拟机监视器

547
00:35:26,030 --> 00:35:30,500
修改所有需要修改的虚拟状态，

548
00:35:30,500 --> 00:35:34,910
模拟系统调用 trap 到客户机操作系统中，

549
00:35:35,030 --> 00:35:40,430
所以它会将虚拟 sepc 设置为程序计数器，

550
00:35:40,760 --> 00:35:46,320
ecall 指令将虚拟模式改回管理者模式，

551
00:35:46,470 --> 00:35:49,800
它会将虚拟 scause 设置为系统调用，

552
00:35:50,970 --> 00:35:56,580
它会将真实的 ecp 设置为虚拟的 stvec ，

553
00:35:57,020 --> 00:35:58,190
然后调用 sret ，

554
00:35:58,460 --> 00:36:03,470
从而完全跳转到客户机操作系统 trap 处理程序，

555
00:36:03,920 --> 00:36:07,560
或者是 trampoline 还是别的什么，

556
00:36:07,590 --> 00:36:10,440
这就是虚拟 stvec 所指向的。

557
00:36:16,790 --> 00:36:17,420
好的。

558
00:36:19,260 --> 00:36:23,730
我们还有两个非常重要的东西，

559
00:36:23,730 --> 00:36:26,910
一个是，关于页表，

560
00:36:27,440 --> 00:36:30,800
另一个是，关于设备。

561
00:36:32,440 --> 00:36:39,960
页表，这里有两个部分，

562
00:36:39,990 --> 00:36:41,550
其一是在不同的时间点，

563
00:36:41,550 --> 00:36:45,150
客户机操作系统将修改 satp 寄存器，

564
00:36:46,440 --> 00:36:49,530
当然，它们会变成虚拟机监视器的 trap ，

565
00:36:49,530 --> 00:36:52,440
虚拟机监视器获得了做事的机会，

566
00:36:52,950 --> 00:36:55,740
但是我们不希望虚拟机监视器做的是，

567
00:36:55,740 --> 00:36:58,890
简单地让客户机设置真正的 satp ，

568
00:36:59,600 --> 00:37:03,800
然后在改变了真实的 satp 之后执行，

569
00:37:03,800 --> 00:37:05,990
因为这会让客户机得到任何内存，

570
00:37:05,990 --> 00:37:09,950
不仅是虚拟机监视器分配给它的内存，

571
00:37:10,280 --> 00:37:14,300
所以，我们不能让客户机操作系统简单地设置 satp ，

572
00:37:15,520 --> 00:37:17,320
但我们确实需要对 satp 做点什么，

573
00:37:17,320 --> 00:37:21,550
因为我们需要向客户操作系统提供某种幻觉，

574
00:37:21,550 --> 00:37:24,430
是的，页表可以更改，

575
00:37:24,430 --> 00:37:25,510
并且不仅仅是错觉，

576
00:37:25,510 --> 00:37:31,060
当客户机软件运行加载和存储指令或取出指令来执行时，

577
00:37:31,240 --> 00:37:33,040
我们需要这些东西来自正确的地方，

578
00:37:33,040 --> 00:37:38,620
从客户机操作系统指向其页表条目的位置，

579
00:37:39,940 --> 00:37:43,630
那么当客户机设置 satp 时到底会发生什么，

580
00:37:47,560 --> 00:37:50,200
你知道我们不能，

581
00:37:50,200 --> 00:37:53,140
我们不能直接使用客户机操作系统页表，

582
00:37:53,170 --> 00:37:58,300
但是虚拟机监视器创建一个新的页表，

583
00:37:58,480 --> 00:38:04,960
用来模拟客户操作系统所需的页表，

584
00:38:05,200 --> 00:38:11,230
所以现在页面转换的情况有点不一样，

585
00:38:11,770 --> 00:38:13,120
我们有客户机，

586
00:38:14,380 --> 00:38:17,770
客户机试着设置页表，

587
00:38:17,770 --> 00:38:19,690
所以这是客户机页表，

588
00:38:19,690 --> 00:38:21,550
当然是客户机内核，

589
00:38:22,270 --> 00:38:32,180
它将客户机虚拟地址映射到客户机物理地址，

590
00:38:32,510 --> 00:38:34,430
当然，客户机物理地址是

591
00:38:35,630 --> 00:38:41,150
虚拟机监视器给客户机的 32GB 或其他大小，

592
00:38:41,180 --> 00:38:47,260
模拟物理内存以供其使用，

593
00:38:47,530 --> 00:38:53,500
告诉客户机操作系统，

594
00:38:53,500 --> 00:38:56,740
它的物理地址从 0 开始到 32MB ，

595
00:38:56,740 --> 00:39:00,040
当然，它们不是在真实的硬件上，

596
00:39:00,040 --> 00:39:03,700
有 32GB 的页面，但不是连续的，

597
00:39:05,040 --> 00:39:08,220
不能直接使用客户机物理地址，

598
00:39:08,220 --> 00:39:12,030
因为它们并不对应真实的物理地址，

599
00:39:12,030 --> 00:39:23,710
相反， VMM 将为每个虚拟机维护一个映射，

600
00:39:23,740 --> 00:39:28,600
将客户机物理地址映射到实际物理地址，

601
00:39:28,600 --> 00:39:31,550
我将它称为主机物理地址，

602
00:39:32,090 --> 00:39:34,640
这个映射就像是一个页表，

603
00:39:34,820 --> 00:39:37,760
有每个页面的条目，

604
00:39:37,760 --> 00:39:41,100
客户机认为存在的每个物理页面，

605
00:39:41,340 --> 00:39:46,230
并指示客户机物理地址关联的实际物理页面，

606
00:39:46,230 --> 00:39:48,360
由 VMM 为其分配的，

607
00:39:48,630 --> 00:39:54,810
然后，当客户机将新页表写入 satp 时，

608
00:39:55,110 --> 00:40:02,620
在 trap 处理程序中， VMM 创建所谓的影子页表，

609
00:40:03,270 --> 00:40:09,860
这是 VMM 在真正的 satp 中放入的内容，

610
00:40:10,650 --> 00:40:16,560
这个影子页表由这两个页表的组合构成，

611
00:40:16,560 --> 00:40:24,040
所以它将客户机虚拟地址映射到主机物理地址，

612
00:40:24,040 --> 00:40:27,310
然后通过取得客户机页表中的每个条目，

613
00:40:27,460 --> 00:40:31,120
查看期望的客户机物理地址，

614
00:40:31,420 --> 00:40:35,950
使用 VMM 映射将客户机物理地址转换为实际主机物理地址，

615
00:40:35,950 --> 00:40:40,600
将虚拟物理对放入影子页表中，

616
00:40:41,050 --> 00:40:46,870
然后虚拟机监视器将这个设置为 satp 作为真实页表，

617
00:40:46,870 --> 00:40:51,720
在返回到客户内核之前，

618
00:40:53,840 --> 00:40:55,760
所以客户机内核认为它是一个页表，

619
00:40:55,760 --> 00:40:59,690
但实际上真正的硬件使用的是这个影子页表。

620
00:41:01,290 --> 00:41:02,520
这样一来，

621
00:41:02,940 --> 00:41:07,980
这防止客户机从允许使用的内存中逃脱，

622
00:41:08,220 --> 00:41:13,800
影子页表只能包含主机物理地址，

623
00:41:14,320 --> 00:41:19,560
VMM 为那个客户机分配的，

624
00:41:19,740 --> 00:41:22,650
客户机没有什么可以放在页表中，

625
00:41:22,650 --> 00:41:25,470
允许它访问页面，

626
00:41:25,470 --> 00:41:28,050
虚拟机监视器没有分配给它的页面。

627
00:41:30,940 --> 00:41:33,400
这是这些隔离故事中的一个关键部分，

628
00:41:34,090 --> 00:41:37,210
关于 trap-and-emulate 的页面设置，有什么问题吗？

629
00:41:40,070 --> 00:41:43,040
抱歉，如果操作系统，

630
00:41:43,040 --> 00:41:47,940
客户机想要创建一个新的进程，

631
00:41:47,940 --> 00:41:49,830
一个进程的新的页表，

632
00:41:50,320 --> 00:41:52,420
会发生什么？

633
00:41:52,630 --> 00:41:55,090
客户机像平常一样做，

634
00:41:55,090 --> 00:41:58,120
只是做 Linux 或 xv6 做的事情，

635
00:41:59,020 --> 00:42:01,840
格式化页表条目以生成页表，

636
00:42:01,930 --> 00:42:03,670
然后它执行执行，

637
00:42:03,670 --> 00:42:06,700
将页表的地址分配给 satp ，

638
00:42:06,790 --> 00:42:09,750
这就是客户机操作系统所做的。

639
00:42:11,300 --> 00:42:14,870
但它不能实际分配 satp ，

640
00:42:14,870 --> 00:42:17,180
因为这是一个特权操作，

641
00:42:17,210 --> 00:42:19,700
所以在虚拟机监视器中有一个 trap ，

642
00:42:19,910 --> 00:42:22,760
虚拟机监视器在 trap 中检查指令，

643
00:42:22,760 --> 00:42:27,140
看到客户机正试图分配给 satp ，

644
00:42:27,660 --> 00:42:32,190
然后虚拟机监视器将创建新的影子页表，

645
00:42:32,340 --> 00:42:37,320
根据客户机想要设置的页表的组合，

646
00:42:38,000 --> 00:42:40,400
虚拟机监视器查看页表，

647
00:42:40,610 --> 00:42:43,490
客户机试图设置的页表中的所有 PTE ，

648
00:42:43,730 --> 00:42:48,410
它转换每个客户机页表条目中的物理地址，

649
00:42:48,650 --> 00:42:55,070
通过这个映射获得真实的物理地址或导致真实的错误，

650
00:42:55,400 --> 00:42:59,450
如果客户机尝试使用不允许的物理地址，

651
00:42:59,870 --> 00:43:04,070
然后虚拟机监视器在真正的 satp 安装这个影子页表，

652
00:43:04,430 --> 00:43:06,470
并返回给客户。

653
00:43:08,780 --> 00:43:10,400
哦，好的，好的，我明白了，

654
00:43:10,490 --> 00:43:11,420
好的，谢谢。

655
00:43:11,960 --> 00:43:12,470
好的。

656
00:43:19,160 --> 00:43:19,730
好的。

657
00:43:23,070 --> 00:43:27,330
好的，这个影子页表是一个棘手的方面，

658
00:43:31,510 --> 00:43:33,970
实现虚拟机监视器。

659
00:43:35,250 --> 00:43:37,710
还有另一件事，

660
00:43:37,710 --> 00:43:42,150
客户操作系统可以通过另一种方式与页表交互，

661
00:43:42,150 --> 00:43:43,560
客户机操作系统可能会，

662
00:43:43,770 --> 00:43:49,350
xv6 有时会在页表中直接读写页表项，

663
00:43:50,200 --> 00:43:55,330
xv6 可以修改页表条目，

664
00:43:55,330 --> 00:43:59,200
或者读取页表条目中的脏位，

665
00:43:59,230 --> 00:44:05,950
在 RISC-V 上，如果软件修改了页表条目，

666
00:44:06,370 --> 00:44:07,810
如果你读过 RISC-V 规范，

667
00:44:07,960 --> 00:44:11,890
RISC-V 在这一点上不需要做任何事情，

668
00:44:11,890 --> 00:44:13,750
所以，如果你修改页表条目，

669
00:44:14,170 --> 00:44:17,800
RISC-V 微处理器不承诺

670
00:44:17,800 --> 00:44:21,280
立即观察对页表条目修改，

671
00:44:21,280 --> 00:44:23,260
它可能会暂时完全忽略它，

672
00:44:23,410 --> 00:44:25,480
相反，手册所说的是，

673
00:44:25,600 --> 00:44:27,730
如果你修改页表条目，

674
00:44:27,730 --> 00:44:31,450
你想让硬件 MMU 看到它们，

675
00:44:31,570 --> 00:44:40,620
你必须执行 sfence.vma 指令，

676
00:44:40,770 --> 00:44:43,470
而且规范只有这条指令，

677
00:44:43,470 --> 00:44:47,220
可以让硬件注意你对页表的修改。

678
00:44:47,370 --> 00:44:49,410
所以，如果你正在构建虚拟机监视器，

679
00:44:49,980 --> 00:44:51,720
RISC-V 上的虚拟机监视器

680
00:44:51,720 --> 00:44:57,430
可以完全忽略客户机对页表条目的修改，

681
00:44:57,490 --> 00:45:00,490
但是由于客户机会执行，

682
00:45:00,670 --> 00:45:05,590
在修改页表条目之后执行 sfence.vma 指令，

683
00:45:05,590 --> 00:45:07,270
这是一条特权指令，

684
00:45:07,300 --> 00:45:09,310
因为它以 s 开头，

685
00:45:09,310 --> 00:45:11,440
这将 trap 进入虚拟机监视器，

686
00:45:11,890 --> 00:45:18,560
虚拟机监视器将知道 sfence 被执行，

687
00:45:18,560 --> 00:45:19,520
它查看这条指令，

688
00:45:19,580 --> 00:45:26,520
它将重新扫描客户机的当前页表，

689
00:45:26,700 --> 00:45:29,130
查找已经改变的页表条目，

690
00:45:29,190 --> 00:45:33,990
并且如果这些改变是合法的，则将它们反映到影子页表中，

691
00:45:35,840 --> 00:45:36,710
重新设置，

692
00:45:36,890 --> 00:45:39,170
得到了一个真正的 sfence.vma ，

693
00:45:39,170 --> 00:45:42,320
让真正的硬件关注影子页表，

694
00:45:42,320 --> 00:45:44,990
然后返回到客户机操作系统。

695
00:45:45,410 --> 00:45:46,430
所以这意味着，

696
00:45:46,460 --> 00:45:51,470
MMU 实际上只使用了一个页表，对吧，

697
00:45:51,470 --> 00:45:52,280
就是影子页表，

698
00:45:52,280 --> 00:45:55,280
它没有在使用 EPT 或类似的东西。

699
00:45:55,730 --> 00:45:56,810
现在还没有 EPT 。

700
00:45:56,840 --> 00:46:01,340
好的，所以客户机认为它有一个 gva 到 gpa 的页表，

701
00:46:01,340 --> 00:46:05,120
但并不在 VMM 中进行任何转换，

702
00:46:05,480 --> 00:46:09,530
基于两者的结合制作自己的页表。

703
00:46:09,770 --> 00:46:11,150
是的，

704
00:46:11,150 --> 00:46:13,850
需要说明的是， EPT 是不同的，

705
00:46:13,970 --> 00:46:17,870
完全不同的虚拟机实现，

706
00:46:18,420 --> 00:46:21,120
需要硬件支持的虚拟机设计，

707
00:46:21,390 --> 00:46:22,890
假设这是一个故事，

708
00:46:22,890 --> 00:46:25,920
如何在没有特殊硬件支持的情况下构建虚拟机，

709
00:46:25,920 --> 00:46:29,330
而是使用 trap 特权指令。

710
00:46:31,680 --> 00:46:35,280
这有没有弄乱直接映射？

711
00:46:37,040 --> 00:46:38,990
好的，不会有直接映射，

712
00:46:39,780 --> 00:46:43,260
这允许客户机，

713
00:46:43,290 --> 00:46:49,790
我的意思是，这里客户机内核会正确运行，

714
00:46:50,720 --> 00:46:53,300
客户机内核认为是直接映射，

715
00:46:55,680 --> 00:46:58,620
但它是虚拟世界的直接映射，

716
00:46:58,620 --> 00:47:02,290
但不是真实机器上的直接映射。

717
00:47:05,130 --> 00:47:05,820
但这无关紧要，

718
00:47:05,820 --> 00:47:12,800
因为，因为我们在对客户机耍花招

719
00:47:13,160 --> 00:47:14,930
一切看起来都像是直接映射。

720
00:47:17,780 --> 00:47:18,920
哦，还有一个问题，

721
00:47:19,220 --> 00:47:20,990
你稍后可能会解决这个问题，

722
00:47:20,990 --> 00:47:24,950
但我想知道我们之前讨论 trap 机制的时候，

723
00:47:24,950 --> 00:47:29,220
我们提到了 trap 的高性能成本，

724
00:47:29,670 --> 00:47:35,070
但听起来我们使用 VMM 的性能要高得多。

725
00:47:35,710 --> 00:47:38,410
是的，是的，这里有所有的指令，

726
00:47:38,410 --> 00:47:44,200
如果你的操作系统执行很多特权指令，

727
00:47:44,410 --> 00:47:46,060
而且你花了很多时间在操作系统上，

728
00:47:46,060 --> 00:47:48,040
你可能有相当多的 trap ，

729
00:47:48,580 --> 00:47:50,500
这可能会耗费相当多的性能，

730
00:47:50,500 --> 00:47:51,970
这就是我们的动机，

731
00:47:52,090 --> 00:47:56,020
我们会稍微讨论一下现代硬件对虚拟机的支持，

732
00:47:56,020 --> 00:47:57,700
这就是今天的论文所使用的，

733
00:47:58,030 --> 00:48:02,050
高昂的 trap 成本是很大的动机，

734
00:48:02,200 --> 00:48:07,930
为什么 Intel 和 AMD 觉得有必要增加硬件支持，

735
00:48:07,930 --> 00:48:09,490
以实现更高效率，

736
00:48:10,220 --> 00:48:14,660
或者用少得多的 trap 的虚拟机方案。

737
00:48:16,260 --> 00:48:18,390
是的，这很重要，

738
00:48:18,510 --> 00:48:19,680
但这实际上运行，

739
00:48:19,680 --> 00:48:22,440
我的意思是，很多年来，这就是人们对虚拟机所做的，

740
00:48:22,440 --> 00:48:24,870
它非常成功，而且很管用，

741
00:48:24,870 --> 00:48:26,190
它慢得多，

742
00:48:27,420 --> 00:48:29,400
但不是慢到人们不喜欢它，

743
00:48:29,400 --> 00:48:30,210
人们非常喜欢它。

744
00:48:34,210 --> 00:48:39,340
好的，关于页表的 trap-and-emulate 策略，还有什么问题吗？

745
00:48:44,140 --> 00:48:48,310
好的，最后一段 trap-and-emulate 的故事，

746
00:48:51,220 --> 00:48:52,900
让我来谈谈设备。

747
00:48:56,240 --> 00:48:57,440
所以我在这里说的是，

748
00:48:57,470 --> 00:49:03,740
普通的操作系统希望能够获得磁盘驱动来存储文件系统，

749
00:49:03,740 --> 00:49:06,050
或者是网卡，

750
00:49:06,050 --> 00:49:08,450
或许是在 xv6 中的 UART ，

751
00:49:08,480 --> 00:49:10,700
我们可以和它的控制台交互，

752
00:49:11,090 --> 00:49:16,190
还有声卡，图形适配器，鼠标，键盘，各种各样的东西，

753
00:49:16,310 --> 00:49:18,620
所以操作系统，我们需要，

754
00:49:18,620 --> 00:49:24,470
虚拟机方案必须具有某些规定以允许客户机，

755
00:49:24,860 --> 00:49:29,300
至少欺骗让它们认为所有这些需要的设备都是真实存在的。

756
00:49:30,200 --> 00:49:35,960
人们使用的策略主要有三种。

757
00:49:36,980 --> 00:49:42,290
一种是挑选一些你需要的非常常用的设备，

758
00:49:42,290 --> 00:49:46,010
比如磁盘驱动器，只需进行模拟，

759
00:49:47,070 --> 00:49:50,520
也就是说，你实际上并没有拥有一个真正的设备，

760
00:49:51,030 --> 00:49:57,060
VMM 只是让它看起来这种特定的磁盘驱动器存在，

761
00:49:57,060 --> 00:49:58,710
让客户机和它交互。

762
00:49:59,860 --> 00:50:03,070
驱动这种模拟的方式，

763
00:50:03,130 --> 00:50:06,520
通常客户操作系统将

764
00:50:07,450 --> 00:50:11,470
通过内存映射控制寄存器与设备交互，

765
00:50:11,500 --> 00:50:15,460
这就是 xv6 与 UART 的交互方式，

766
00:50:15,490 --> 00:50:21,820
串行端口，控制台设备，

767
00:50:22,710 --> 00:50:25,110
你可以键入字符，它向你显示字符，

768
00:50:25,320 --> 00:50:28,890
xv6 与映射的控制寄存器交互，

769
00:50:28,890 --> 00:50:34,200
假设硬件已经映射到已知地址，

770
00:50:34,590 --> 00:50:36,720
在内核地址空间的地址中，

771
00:50:37,440 --> 00:50:39,840
所以，你在虚拟机监视器中进行模拟的方式是

772
00:50:40,650 --> 00:50:43,920
不是映射这些页面到客户机，

773
00:50:43,920 --> 00:50:47,490
相反，你应该让这些页面非法，

774
00:50:47,550 --> 00:50:52,230
从而每次客户操作系统尝试使用 UART 硬件时，

775
00:50:52,230 --> 00:50:53,910
无论设备硬件是什么，

776
00:50:54,090 --> 00:50:56,310
VMM 虚拟机监视器将获得 trap ，

777
00:50:56,490 --> 00:50:58,740
虚拟机监视器将查看指令，

778
00:50:58,740 --> 00:51:01,440
哦，它试图在 UART 上发送一个字符，

779
00:51:01,470 --> 00:51:04,500
或者从磁盘读取，或者别的什么，

780
00:51:05,390 --> 00:51:09,020
然后虚拟机监视器将模拟磁盘，

781
00:51:09,020 --> 00:51:12,200
模拟串行设备，

782
00:51:12,590 --> 00:51:16,940
调用它的模拟

783
00:51:16,940 --> 00:51:20,180
来解决如何响应客户机的指令，

784
00:51:20,180 --> 00:51:22,910
然后让客户机继续。

785
00:51:24,460 --> 00:51:25,270
这基本上就是，

786
00:51:25,270 --> 00:51:31,630
QEMU 如何实现 xv6 使用的 UART 控制台设备，

787
00:51:31,780 --> 00:51:35,170
实际上没有物理的串行端口，

788
00:51:35,170 --> 00:51:39,910
但是 QEMU 模仿了一个让 xv6 使用。

789
00:51:40,360 --> 00:51:41,740
所以这是一个普遍的策略，

790
00:51:42,400 --> 00:51:45,220
它的性能可能会非常低，

791
00:51:45,220 --> 00:51:47,950
因为它涉及 trap 和操作系统，

792
00:51:47,950 --> 00:51:50,770
对于每次客户机和设备硬件之间的交互，

793
00:51:51,770 --> 00:51:55,190
但是对于低速的东西，它工作得很好。

794
00:51:55,850 --> 00:51:58,400
第二种经常使用的策略，

795
00:52:00,100 --> 00:52:01,540
实际上，如果你的，

796
00:52:02,350 --> 00:52:06,400
如果你的目标是提供能够启动操作系统，

797
00:52:06,400 --> 00:52:09,880
它们不知道它们是在虚拟机上运行的，

798
00:52:10,090 --> 00:52:12,040
这几乎就是你必须走的路，

799
00:52:14,340 --> 00:52:15,510
别无选择。

800
00:52:15,510 --> 00:52:17,610
但在现代世界中，

801
00:52:17,610 --> 00:52:21,690
通常情况下，操作系统会意识到，

802
00:52:21,690 --> 00:52:23,670
它们是在低水平运行，

803
00:52:23,670 --> 00:52:26,580
至少意识到它们是在虚拟机之上运行，

804
00:52:26,940 --> 00:52:31,410
所以，一种不同的策略是提供虚拟设备，

805
00:52:31,410 --> 00:52:35,180
这并不是试图模仿真实的设备，

806
00:52:35,240 --> 00:52:43,270
而是设计一种特别有效的设备接口，

807
00:52:43,990 --> 00:52:48,580
为客户中的设备驱动程序提供有效的方式，

808
00:52:48,640 --> 00:52:53,200
能够与虚拟机监视器内部的设备进行交互，

809
00:52:53,590 --> 00:52:57,310
所以，你可能没有内存映射控制寄存器，

810
00:52:57,310 --> 00:53:05,140
你可能在内存中有一个命令结构的队列，

811
00:53:05,140 --> 00:53:11,800
客户机操作系统可以将命令写入到那个设备，

812
00:53:12,670 --> 00:53:15,460
事实上， xv6 也使用了其中的一种，

813
00:53:15,460 --> 00:53:23,750
如果你查看 xv6 VIRTIO_DISK virtio_disk.c ，

814
00:53:23,870 --> 00:53:29,750
你将看到客户机和设备驱动程序

815
00:53:29,750 --> 00:53:34,400
与 QEMU 实现的磁盘虚拟设备交互，

816
00:53:34,730 --> 00:53:40,040
它使用很少或几乎不使用，

817
00:53:40,070 --> 00:53:44,510
很少或没有内存映射控制寄存器，

818
00:53:44,510 --> 00:53:46,400
所以它并不依赖于 trap ，

819
00:53:46,520 --> 00:53:51,740
而是，格式化这种命令内存队列，

820
00:53:51,860 --> 00:53:52,820
正如我提到的，

821
00:53:53,980 --> 00:53:56,410
然后 QEMU 查看内存中的这些命令，

822
00:53:56,410 --> 00:53:58,810
不将它们应用于真正的磁盘，

823
00:53:58,810 --> 00:54:03,160
而是到 fs.img 这样的文件，

824
00:54:03,460 --> 00:54:06,580
QEMU 将命令应用到 fs.img ，

825
00:54:06,580 --> 00:54:10,490
而不是使用真正的设备硬件，

826
00:54:11,160 --> 00:54:12,540
这是另一种策略。

827
00:54:13,020 --> 00:54:16,380
人们使用的第三种策略，

828
00:54:16,440 --> 00:54:18,750
所以，这是更高的性能和直接的仿真，

829
00:54:18,750 --> 00:54:22,230
因为你可以设计接口，

830
00:54:22,260 --> 00:54:23,970
所以不需要很多 trap ，

831
00:54:24,150 --> 00:54:31,110
人们使用的最后一种策略是通过真实的设备，

832
00:54:33,910 --> 00:54:37,390
对于网络接口控制器来说，这是一种典型的情况，

833
00:54:37,390 --> 00:54:40,270
它提供了对网络的访问，

834
00:54:40,510 --> 00:54:47,050
现代网络设备具有硬件支持，

835
00:54:47,050 --> 00:54:50,800
用于与多个客户机操作系统交互，

836
00:54:50,800 --> 00:54:52,480
运行在虚拟机器监视器上，

837
00:54:52,570 --> 00:54:54,340
所以，你可以配置现代网卡，

838
00:54:54,400 --> 00:55:00,150
像是多个独立网卡，

839
00:55:00,150 --> 00:55:02,460
每个客户机操作系统对应一个，

840
00:55:02,610 --> 00:55:05,850
然后客户机操作系统可以直接交互，

841
00:55:06,240 --> 00:55:08,460
可以由虚拟机监视器配置，

842
00:55:08,460 --> 00:55:15,150
允许它以直接与它的那一部分网卡交互，

843
00:55:16,080 --> 00:55:17,370
使用很高的效率，

844
00:55:17,840 --> 00:55:21,950
这就是现代高性能的方式，

845
00:55:22,650 --> 00:55:24,750
客户机操作系统可能，

846
00:55:25,440 --> 00:55:27,990
从理论上讲，我认为你可以设计，

847
00:55:28,020 --> 00:55:29,790
你可以设置客户机操作系统，

848
00:55:29,790 --> 00:55:32,750
不知道发生什么奇怪的事情，

849
00:55:32,750 --> 00:55:36,350
但我认为在实践中，客户机操作系统设备驱动程序可能知道，

850
00:55:38,340 --> 00:55:41,340
它们正在与一块特殊的网卡交互。

851
00:55:42,690 --> 00:55:47,040
好的，这些是设备的选项，

852
00:55:47,880 --> 00:55:53,700
事实上，我相信大部分的困难

853
00:55:53,700 --> 00:55:59,420
在今天实现虚拟机监控时，

854
00:55:59,780 --> 00:56:05,720
是试图创造设备模拟和设备驱动程序，

855
00:56:05,720 --> 00:56:09,500
它是足够好的，

856
00:56:09,500 --> 00:56:14,540
它们会在真正的客户操作系统上正常工作，

857
00:56:14,600 --> 00:56:16,610
这可能是大部分的工作，

858
00:56:16,640 --> 00:56:20,880
特别是当你使用这个模拟策略时。

859
00:56:23,540 --> 00:56:24,830
关于设备，有什么问题吗？

860
00:56:32,700 --> 00:56:36,930
好的，我不太明白它们之间的区别，

861
00:56:36,930 --> 00:56:39,360
虚拟和模拟之间的区别，

862
00:56:39,450 --> 00:56:41,730
因为它们不是。

863
00:56:41,730 --> 00:56:43,500
它们是相似的，

864
00:56:43,620 --> 00:56:46,530
这是一种思考它的方式，

865
00:56:46,740 --> 00:56:50,700
如果你在启动一个对虚拟机一无所知的操作系统，

866
00:56:52,100 --> 00:56:54,860
它可能有很多磁盘驱动程序，

867
00:56:54,860 --> 00:56:56,270
但它们都是针对真正的硬件的，

868
00:56:56,300 --> 00:56:58,760
你可以拿出实体的硬件，

869
00:56:58,760 --> 00:56:59,720
你可以出去买，

870
00:56:59,870 --> 00:57:00,350
这意味着，

871
00:57:00,350 --> 00:57:03,020
如果你想在你的虚拟机上启动这种操作系统，

872
00:57:03,200 --> 00:57:08,180
你需要有一个精确的模拟，

873
00:57:08,180 --> 00:57:10,610
你需要从那些真正的硬件中选择一个，

874
00:57:10,610 --> 00:57:14,750
并对那个硬件进行精确的模拟，

875
00:57:15,340 --> 00:57:17,860
所以，然后，

876
00:57:18,450 --> 00:57:21,060
我的意思是，人们完全这样做，所以这是可行的，

877
00:57:21,560 --> 00:57:28,100
这是可用的，除了大多数，

878
00:57:28,190 --> 00:57:32,810
对于真正的硬件，设备接口不是设计好的，

879
00:57:32,810 --> 00:57:34,910
硬件接口设计没有设计为

880
00:57:35,240 --> 00:57:38,630
高效率的使用 trap-and-emulate 虚拟机监视器，

881
00:57:38,750 --> 00:57:41,000
所以，通常是这种情况，

882
00:57:41,210 --> 00:57:46,280
真正的设备需要大量读写它的控制寄存器，

883
00:57:46,900 --> 00:57:49,330
但是虚拟机监视器必须控制

884
00:57:49,330 --> 00:57:51,760
对每次设备控制寄存器的写入，

885
00:57:52,210 --> 00:57:53,830
因为它需要模仿，

886
00:57:54,490 --> 00:57:58,120
这意味着设备控制寄存器的每一次写入

887
00:57:58,120 --> 00:58:00,250
都会导致 trap 进入虚拟机监视器，

888
00:58:00,250 --> 00:58:02,410
可能需要数百个周期，

889
00:58:02,860 --> 00:58:06,160
这意味着这是缓慢的，低效的，

890
00:58:06,340 --> 00:58:08,530
所以这里的不同之处在于，

891
00:58:08,530 --> 00:58:12,190
不是盲目地模仿真实的设备，

892
00:58:12,220 --> 00:58:19,030
一些设计师设计出一个设备接口，

893
00:58:19,060 --> 00:58:21,580
不是由任何真正的硬件实现的，

894
00:58:22,180 --> 00:58:24,100
而是仅由虚拟机监视器实现的，

895
00:58:24,100 --> 00:58:28,000
而且它是以一种不需要太多 trap 的方式设计的，

896
00:58:29,160 --> 00:58:34,230
不是与控制寄存器交互并期望设备立即响应，

897
00:58:34,410 --> 00:58:35,700
这需要一个 trap ，

898
00:58:36,000 --> 00:58:41,220
相反，设备驱动程序和虚拟硬件是解耦的，

899
00:58:41,430 --> 00:58:44,940
而且不需要任何即时的交互。

900
00:58:45,400 --> 00:58:49,960
不过，在这种情况下，客户机需要自己新的驱动，

901
00:58:50,050 --> 00:58:52,390
所以，这需要客户机拥有驱动程序，

902
00:58:52,390 --> 00:58:55,210
对于这个型号的磁盘和那个型号的磁盘，

903
00:58:55,210 --> 00:58:57,490
并且还具有虚拟磁盘的驱动程序。

904
00:58:57,550 --> 00:58:59,800
对， xv6 也是如此，

905
00:58:59,800 --> 00:59:02,770
那么，在功能级别，

906
00:59:02,800 --> 00:59:06,580
你使用这个方案，也许你可以启动任何操作系统，

907
00:59:07,320 --> 00:59:08,490
然而，如果使用这个方案，

908
00:59:08,490 --> 00:59:13,230
你只能启动知道你的虚拟设备的操作系统，

909
00:59:13,230 --> 00:59:15,270
如果你想使用虚拟设备，

910
00:59:15,930 --> 00:59:17,640
事实上，这是一个标准，

911
00:59:18,120 --> 00:59:23,390
由多个不同的虚拟机方案提供的，

912
00:59:23,420 --> 00:59:24,080
所以，使用这个，

913
00:59:24,560 --> 00:59:27,350
除了我们从未在 QEMU 以外的任何设备上进行测试，

914
00:59:27,530 --> 00:59:30,680
这个在 xv6 中的驱动程序可以工作，

915
00:59:31,250 --> 00:59:33,620
可能会被修改以在其他虚拟机上运行。

916
00:59:34,540 --> 00:59:37,540
所以，如果 xv6 是为那个电路板编译的，

917
00:59:37,540 --> 00:59:40,300
您在课程开始时显示的那样，

918
00:59:40,570 --> 00:59:42,760
在那种情况下，你必须使用不同的驱动程序，

919
00:59:42,760 --> 00:59:44,710
根据正在运行的磁盘，对吗？

920
00:59:45,040 --> 00:59:47,560
是的，我想你可以买到磁盘接口，

921
00:59:47,950 --> 00:59:51,700
真实硬件磁盘接口来支持这个接口，

922
00:59:51,700 --> 00:59:54,820
但是大多数磁盘驱动器不支持，

923
00:59:54,820 --> 00:59:57,160
我们必须实现一个新的，像你说的那样，

924
00:59:57,190 --> 01:00:00,790
我们必须为真正的硬件实现一个新的磁盘驱动程序。

925
01:00:03,390 --> 01:00:03,930
是的。

926
01:00:06,680 --> 01:00:07,370
好的。

927
01:00:08,080 --> 01:00:09,550
关于设备，还有其他问题吗？

928
01:00:14,370 --> 01:00:23,180
好了，下一个话题我想谈谈对虚拟机的硬件支持，

929
01:00:27,750 --> 01:00:32,770
特别是英特尔的 VT-x 方案，

930
01:00:33,010 --> 01:00:39,830
那么，促使英特尔和其他硬件提供商

931
01:00:39,830 --> 01:00:44,510
为虚拟机增加直接硬件支持的动机是，

932
01:00:44,570 --> 01:00:47,390
a, 虚拟机使用无处不在，

933
01:00:47,540 --> 01:00:50,480
它们的很多客户都在运行大量的虚拟机，

934
01:00:50,660 --> 01:00:53,630
第二， trap-and-emulate ，正如我刚才所说的那样，

935
01:00:54,080 --> 01:00:56,510
通常引起很多昂贵的陷阱，

936
01:00:56,510 --> 01:00:58,130
所以它的效率不是特别高，

937
01:01:00,280 --> 01:01:03,910
第三种不太有趣的可能的动机是，

938
01:01:04,180 --> 01:01:08,860
尽管 RISC-V 非常适合 trap-and-emulate 虚拟化，

939
01:01:08,950 --> 01:01:13,360
英特尔的 x86 微处理器有许多详细的功能，

940
01:01:13,360 --> 01:01:18,340
使得它可能很难虚拟化，

941
01:01:18,520 --> 01:01:21,730
所以，英特尔试图解决这一问题，

942
01:01:21,730 --> 01:01:25,630
因为它的很多客户都想运行虚拟机监视器。

943
01:01:26,920 --> 01:01:29,370
好的，所以这个硬件是，

944
01:01:29,370 --> 01:01:32,970
重点是它成为，

945
01:01:33,000 --> 01:01:36,510
允许你使用硬件支持创建更快的虚拟机，

946
01:01:36,630 --> 01:01:42,150
另一个动机是使虚拟机的实现变得更容易，

947
01:01:42,920 --> 01:01:46,700
这种支持可能已经存在了十年，

948
01:01:46,700 --> 01:01:50,600
现在非常广泛地用于构建虚拟机。

949
01:01:50,930 --> 01:01:56,630
好的，所以基本策略是

950
01:01:56,660 --> 01:02:00,230
在我的 trap-and-emulate 方案中的所有虚拟状态，

951
01:02:00,500 --> 01:02:05,640
所有虚拟状态由软件的虚拟机监视器管理，

952
01:02:05,820 --> 01:02:11,640
所有虚拟状态都将在硬件中实现，

953
01:02:11,670 --> 01:02:13,680
在这些硬件支持的方案中，

954
01:02:14,850 --> 01:02:20,160
这将允许客户机软件执行特权指令，

955
01:02:20,490 --> 01:02:27,980
直接影响这些虚拟硬件支持的寄存器，而不是使用 trap ，

956
01:02:28,340 --> 01:02:32,870
所以，现在的目标是让客户机能够执行特权指令，而不是 trap 。

957
01:02:33,420 --> 01:02:35,540
这个原因是，

958
01:02:36,200 --> 01:02:37,310
这是有效的，

959
01:02:37,340 --> 01:02:40,460
同样，我们有一个虚拟机监视器，

960
01:02:41,550 --> 01:02:47,170
并且有一个在用户级别的客户机操作系统，

961
01:02:47,590 --> 01:02:52,480
现在我们知道在硬件中，

962
01:02:52,480 --> 01:02:59,680
我们有一个 stvec 和所有那些硬件寄存器，

963
01:03:06,620 --> 01:03:07,640
这些都是，

964
01:03:07,670 --> 01:03:11,060
当我们在新的硬件支持虚拟方案上运行时，

965
01:03:11,060 --> 01:03:12,230
我们运行虚拟机监视器，

966
01:03:12,230 --> 01:03:14,780
我们使用这些寄存器的真实版本，

967
01:03:14,780 --> 01:03:16,160
但是硬件，

968
01:03:16,190 --> 01:03:18,950
当虚拟机监视器告诉硬件，

969
01:03:18,950 --> 01:03:21,320
请切换到客户机模式，

970
01:03:21,770 --> 01:03:25,820
硬件有一套完整的独立寄存器，

971
01:03:27,300 --> 01:03:30,480
专门在客户机模式下使用。

972
01:03:31,360 --> 01:03:34,180
所以客户机模式可以读写这些寄存器，

973
01:03:34,180 --> 01:03:34,750
但它不是，

974
01:03:34,780 --> 01:03:39,850
它读写这些寄存器的硬件复制版本，

975
01:03:39,850 --> 01:03:41,350
而不是真正的寄存器，

976
01:03:41,350 --> 01:03:45,430
并且硬件有一些额外的检查，

977
01:03:45,430 --> 01:03:49,330
它限制客户操作系统所能做的，

978
01:03:49,330 --> 01:03:53,170
确保它不会滥用这些寄存器，从虚拟机中逃出来。

979
01:03:54,240 --> 01:03:57,780
这是最基本的的策略，

980
01:03:58,290 --> 01:04:02,520
并且在这些硬件支持的虚拟机方案的术语中，

981
01:04:02,640 --> 01:04:04,440
名称是 Intel [One] ，

982
01:04:04,830 --> 01:04:08,430
客户机模式称为 non-root ，

983
01:04:10,720 --> 01:04:17,960
而我们使用真正寄存器的主机模式称为 root ，

984
01:04:17,960 --> 01:04:23,390
这里有一组 non-root 虚拟寄存器供虚拟机使用，

985
01:04:23,390 --> 01:04:26,240
而这里有一组寄存器我们在 root 模式下使用。

986
01:04:32,150 --> 01:04:36,520
所以现在当我们在客户机内核中运行时，

987
01:04:38,030 --> 01:04:44,220
它可以执行任何特权指令，而不使用 trap ，

988
01:04:44,520 --> 01:04:46,920
那么当需要读写 stvec 时，

989
01:04:46,950 --> 01:04:52,950
硬件只是读写硬件 stvec 寄存器的 non-root 副本，

990
01:04:53,490 --> 01:04:58,980
所以，所有这些东西都在全速运行，而不需要陷入 VMM ，

991
01:04:58,980 --> 01:05:03,630
所以它比出现大量 trap 的代码要快得多。

992
01:05:07,270 --> 01:05:08,800
这个，你还是需要，

993
01:05:08,800 --> 01:05:12,100
配置这个需要很多东西要做，

994
01:05:12,100 --> 01:05:15,670
当虚拟机监视器要创建新的虚拟机时，

995
01:05:15,670 --> 01:05:17,320
必须要告诉硬件，

996
01:05:17,770 --> 01:05:24,350
所以，在虚拟机监视器内存中，

997
01:05:24,350 --> 01:05:27,960
有虚拟机监视器结构，

998
01:05:27,960 --> 01:05:31,080
它是 VT-x 硬件用来通信的，

999
01:05:31,080 --> 01:05:36,450
被称为 VMCS 虚拟机控制结构，

1000
01:05:37,560 --> 01:05:40,320
当虚拟机监视器想要创建新的虚拟机时，

1001
01:05:40,320 --> 01:05:42,300
它在内存中创建一个，

1002
01:05:42,300 --> 01:05:44,370
并填充一组配置标志，

1003
01:05:44,370 --> 01:05:47,850
并对所有这些寄存器的值做初始化，

1004
01:05:47,850 --> 01:05:51,800
然后告诉 VT-x 硬件，

1005
01:05:51,800 --> 01:05:54,140
我想开始运行一个新的虚拟机，

1006
01:05:54,140 --> 01:05:55,730
这里是初始状态，

1007
01:05:56,150 --> 01:06:00,620
这些是论文提到的新指令，

1008
01:06:00,620 --> 01:06:05,940
有一个 VMLAUNCH ，就像一个新的机器指令，

1009
01:06:05,940 --> 01:06:10,110
你告诉它这个的地址，它开始运行，

1010
01:06:10,870 --> 01:06:13,000
使用这些寄存器开始，

1011
01:06:13,000 --> 01:06:15,490
比如开始运行客户机内核，

1012
01:06:15,850 --> 01:06:18,340
这里还有一个 VMRESUME ，

1013
01:06:19,380 --> 01:06:24,190
因为有时候，会从内核中出来，回到 VMM 中，

1014
01:06:24,190 --> 01:06:25,120
你需要恢复它，

1015
01:06:25,450 --> 01:06:28,840
然后这里的代码可以运行一个名为 VMCALL 的新指令，

1016
01:06:28,840 --> 01:06:34,430
在某种程度上是退出 non-root 模式，

1017
01:06:34,460 --> 01:06:37,670
并且 trap 到 root 模式的虚拟机监视器中。

1018
01:06:39,820 --> 01:06:41,560
当虚拟机监视器

1019
01:06:42,160 --> 01:06:45,490
执行这些指令中的一个跳入到客户机中，

1020
01:06:45,610 --> 01:06:48,520
它可能回来的方式，

1021
01:06:49,420 --> 01:06:52,990
客户机现在可以执行普通特权指令而不使用 trap ，

1022
01:06:53,080 --> 01:06:54,460
但是，原因有很多，

1023
01:06:54,460 --> 01:06:57,190
为什么仍然可以返回到虚拟机模式，

1024
01:06:57,190 --> 01:06:59,610
一个是故意退出，

1025
01:07:00,120 --> 01:07:01,950
而且如果设备中断关闭，

1026
01:07:01,950 --> 01:07:03,690
比如定时器中断关闭，

1027
01:07:03,750 --> 01:07:09,030
所有微处理器将强制陷出，

1028
01:07:09,670 --> 01:07:14,050
non-root 模式的客户机进入 root 模式，在虚拟机监视器中，

1029
01:07:14,140 --> 01:07:19,240
所以，通常情况下，设备中断返回到虚拟机监视器中，

1030
01:07:19,240 --> 01:07:22,630
所以，这意味着客户机操作系统不能占用 CPU ，

1031
01:07:22,840 --> 01:07:26,380
每次定时器硬件到达，虚拟机监视器获得控制，

1032
01:07:26,770 --> 01:07:29,830
如果有多个客户机，

1033
01:07:29,830 --> 01:07:34,900
那么分时计算机使用计时器中断在不同的客户机之间切换。

1034
01:07:40,930 --> 01:07:42,280
好的，这是基本策略，

1035
01:07:42,280 --> 01:07:45,420
基本上有第二组寄存器，

1036
01:07:50,020 --> 01:07:58,440
VT-x 提供的另一个大的机制是页表支持，

1037
01:07:58,680 --> 01:08:02,040
当在客户机世界里执行时，

1038
01:08:02,040 --> 01:08:03,750
我们也需要一个页表，

1039
01:08:04,540 --> 01:08:07,270
我们需要页表有两个原因，

1040
01:08:07,270 --> 01:08:11,260
一个是客户机内核想要能够配置自己的页表，

1041
01:08:11,260 --> 01:08:15,100
希望能够加载 cr3 ，

1042
01:08:15,100 --> 01:08:21,600
它是英特尔中类似 satp 的寄存器，

1043
01:08:21,600 --> 01:08:23,220
所以，我们希望能够，

1044
01:08:23,250 --> 01:08:27,150
或 VT-x 允许客户机内核加载任何值，

1045
01:08:27,180 --> 01:08:32,220
加载到 cr3 寄存器中以设置页表，

1046
01:08:32,220 --> 01:08:36,600
并且硬件遵守客户机内核加载的页表，

1047
01:08:36,930 --> 01:08:39,270
我们知道这是非常好的，

1048
01:08:39,360 --> 01:08:42,750
因为现在这可以加载一个页表而不陷入 VMM ，

1049
01:08:43,480 --> 01:08:48,970
但是我们知道我们不能让客户机内核把任何东西放到它的页表中，

1050
01:08:49,960 --> 01:08:50,680
而不，

1051
01:08:50,920 --> 01:08:53,650
因为这将允许它读写任意内存，

1052
01:08:53,740 --> 01:08:59,320
所以这个 VT-x 方案有另一个重要的寄存器，

1053
01:08:59,320 --> 01:09:02,950
实际上是一个真实的，

1054
01:09:03,220 --> 01:09:05,710
我不知道应该画在哪里，但我会画在这里，

1055
01:09:07,350 --> 01:09:15,070
扩展页表寄存器 EPT ，

1056
01:09:15,070 --> 01:09:16,420
并且虚拟机，

1057
01:09:16,420 --> 01:09:20,360
EPT 指向一个页表，

1058
01:09:21,380 --> 01:09:25,760
它映射到一种或另一种地址，

1059
01:09:25,760 --> 01:09:27,890
并且虚拟机监视器设置，

1060
01:09:27,890 --> 01:09:30,560
当它要运行客户机内核时，

1061
01:09:30,560 --> 01:09:34,070
它为那个内核设置 EPT ，

1062
01:09:34,280 --> 01:09:41,100
告诉硬件这是我要运行的虚拟机的 EPT ，

1063
01:09:41,100 --> 01:09:42,810
然后跳到虚拟机中，

1064
01:09:42,900 --> 01:09:44,580
然后游戏是，

1065
01:09:45,430 --> 01:09:48,470
这台机器上的 MMU ，

1066
01:09:48,500 --> 01:09:50,870
当它转换客户机虚拟地址时，

1067
01:09:50,870 --> 01:09:55,490
它首先将客户机虚拟地址转换为客户机物理地址，

1068
01:09:55,520 --> 01:09:58,950
对于客户机设置的页表，

1069
01:09:58,950 --> 01:10:01,020
然后做另一次转换，

1070
01:10:01,020 --> 01:10:05,790
通过 EPT 将客户机物理地址转换为主机物理地址，

1071
01:10:06,560 --> 01:10:11,930
硬件会自动对每个客户机内存引用执行这个操作，

1072
01:10:11,960 --> 01:10:13,730
这是两级转换，

1073
01:10:14,000 --> 01:10:17,210
所以，这再次给了 VMM 控制，

1074
01:10:17,210 --> 01:10:20,480
客户机允许使用的物理内存，

1075
01:10:20,480 --> 01:10:22,700
客户机可以设置任何页表，

1076
01:10:22,700 --> 01:10:23,930
并且可以非常高效地进行，

1077
01:10:23,930 --> 01:10:26,240
因为它可以直接执行指令，

1078
01:10:26,270 --> 01:10:30,330
但是它仍然受到 EPT 的约束，

1079
01:10:30,330 --> 01:10:32,220
VMM 配置为

1080
01:10:32,220 --> 01:10:37,980
只能使用 VMM 让它使用的物理页面。

1081
01:10:40,560 --> 01:10:41,940
关于 EPT ，有什么问题吗？

1082
01:10:47,350 --> 01:10:49,240
哦，抱歉，我有一个关于 EPT 的问题，

1083
01:10:49,270 --> 01:10:52,840
关于第二组寄存器，

1084
01:10:52,930 --> 01:10:57,400
如果你有两个核心，并且你想添加两个 VMM ，

1085
01:10:57,700 --> 01:11:01,690
你有没有第三组寄存器复制？

1086
01:11:01,690 --> 01:11:06,400
每个核心都有自己的这些寄存器，

1087
01:11:06,850 --> 01:11:09,190
每个核心都有一个独立的，

1088
01:11:10,410 --> 01:11:15,630
独立的 VT-x 硬件的所有实例，

1089
01:11:15,960 --> 01:11:20,160
每个核心都有自己的 32 个通用寄存器，

1090
01:11:20,310 --> 01:11:27,120
它自己的真实控制寄存器和自己的客户机模式虚拟寄存器，

1091
01:11:27,750 --> 01:11:29,880
还有它自己的 EPT 。

1092
01:11:31,010 --> 01:11:33,860
所以你在两个不同的核心上有两个不同的客户机，

1093
01:11:33,860 --> 01:11:35,840
它们都有自己的每个寄存器，

1094
01:11:37,050 --> 01:11:38,190
每个核心都有自己的。

1095
01:11:39,320 --> 01:11:41,240
所以，你也需要一个新的 VMM ？

1096
01:11:41,510 --> 01:11:45,290
好的，我是说，它可以和普通操作系统一样，

1097
01:11:45,290 --> 01:11:47,540
就像 xv6 可以支持多进程，

1098
01:11:47,540 --> 01:11:50,780
它就像 xv6 一样，

1099
01:11:50,810 --> 01:11:57,720
就像 xv6 每个进程都有单独的 proc 结构，

1100
01:11:58,080 --> 01:12:02,790
虚拟机监视器具有单独的 vmm 结构或什么的，

1101
01:12:03,090 --> 01:12:07,410
每个客户机一个，用于跟踪客户机信息。

1102
01:12:08,290 --> 01:12:09,640
好的，我明白了，谢谢。

1103
01:12:10,090 --> 01:12:10,630
好的。

1104
01:12:11,210 --> 01:12:12,770
就像我之前提到的切换，

1105
01:12:13,130 --> 01:12:16,670
如果你有一个核心和三个客户机，

1106
01:12:16,670 --> 01:12:18,650
切换可以由定时器中断驱动，

1107
01:12:18,650 --> 01:12:21,900
它去往虚拟机监视器，而不是客户机。

1108
01:12:26,730 --> 01:12:27,270
好的。

1109
01:12:28,120 --> 01:12:30,130
还有更多关于虚拟机的问题吗，

1110
01:12:30,160 --> 01:12:34,720
在我转到论文之前。

1111
01:12:39,410 --> 01:12:44,590
好的，这篇论文把这个硬件作为一个起点，

1112
01:12:44,890 --> 01:12:48,040
并将其用于其他用途，而不是虚拟机，

1113
01:12:48,460 --> 01:12:50,110
这是论文中非常感兴趣的，

1114
01:12:50,110 --> 01:12:54,850
他们采用了这种专为虚拟机设计的硬件，

1115
01:12:55,180 --> 01:12:55,870
这篇论文说，

1116
01:12:55,870 --> 01:12:59,530
我们可以使用这个硬件来做不只是一个虚拟机。

1117
01:13:00,670 --> 01:13:06,200
他们所做的，从高层次角度来说就是，

1118
01:13:06,260 --> 01:13:10,070
他们想要实现普通的进程，

1119
01:13:10,100 --> 01:13:11,570
现在我们回到 Linux ，

1120
01:13:11,900 --> 01:13:13,850
不再有虚拟机，只有 Linux ，

1121
01:13:13,880 --> 01:13:16,070
假设 VT-x 硬件是 Dune ，

1122
01:13:19,330 --> 01:13:22,110
我们有 Linux ，

1123
01:13:22,140 --> 01:13:28,050
假设我们将 Dune 可加载内核模块加载到 Linux 中，

1124
01:13:28,050 --> 01:13:31,530
现在 Dune 软件在管理员模式下运行，

1125
01:13:31,530 --> 01:13:32,820
作为 Linux 内核的一部分，

1126
01:13:33,670 --> 01:13:36,640
但在很大程度上，我们运行的是 Linux ，

1127
01:13:36,640 --> 01:13:39,160
我们希望运行 Linux 进程。

1128
01:13:41,180 --> 01:13:43,250
所以，这个想要支持的是，

1129
01:13:43,250 --> 01:13:45,500
大多数使用系统调用的进程

1130
01:13:45,500 --> 01:13:49,010
以及所有 Linux 进程可以做的普通事情，

1131
01:13:49,910 --> 01:13:54,560
但是我们想使用这个 VT-x 硬件来提供更多，

1132
01:13:54,590 --> 01:13:59,660
允许普通进程做一些额外的事情，

1133
01:14:01,850 --> 01:14:06,040
所以我们要运行，

1134
01:14:06,040 --> 01:14:08,230
所以， Dune 运行这些进程，

1135
01:14:08,290 --> 01:14:10,690
或允许进程切换到 Dune 模式，

1136
01:14:10,690 --> 01:14:15,310
这意味着不只是由页表隔离，

1137
01:14:15,430 --> 01:14:21,370
现在这个进程被完整的 VT-x 设备隔离，

1138
01:14:21,400 --> 01:14:24,670
所以，对于这个进程， Dune 将要维护，

1139
01:14:25,120 --> 01:14:30,880
这个进程现在具有这个所有虚拟控制寄存器，

1140
01:14:30,880 --> 01:14:33,160
比如它自己的 cr3 ，

1141
01:14:33,160 --> 01:14:35,890
因此，也就有自己的页表，

1142
01:14:36,560 --> 01:14:42,900
因为这个进程将在 non-root 管理员模式下运行，

1143
01:14:42,900 --> 01:14:44,520
所以它可以运行所有的特权指令，

1144
01:14:44,520 --> 01:14:49,080
尽管是 VT-x 实现的虚拟状态。

1145
01:14:50,990 --> 01:14:54,560
所以在 Dune 下，这个进程可以做的一件重要的事情是，

1146
01:14:54,560 --> 01:14:58,790
使用自己的硬件 cr3 设置自己的页表，

1147
01:14:58,820 --> 01:15:03,580
当然 Dune 控制着这个进程的 EPT ，

1148
01:15:03,580 --> 01:15:06,850
所以， EPT 被设置为

1149
01:15:06,850 --> 01:15:10,330
只有这个进程的普通进程内存的条目，

1150
01:15:10,510 --> 01:15:12,700
所以这个进程可以放任何像 cr3 的东西，

1151
01:15:12,700 --> 01:15:16,690
因为 MMU 通过 EPT 转换，

1152
01:15:16,690 --> 01:15:18,580
再通过普通页表转换，

1153
01:15:18,580 --> 01:15:21,550
这个进程仍然不能跳出给它分配的内存，

1154
01:15:21,580 --> 01:15:24,550
所以，这个进程有额外能力，

1155
01:15:24,550 --> 01:15:27,830
相对于其他进程或内核内存，

1156
01:15:27,860 --> 01:15:32,060
它现在有了一种更灵活的方式来设置自己的内存。

1157
01:15:33,700 --> 01:15:37,300
好的，所以 Dune 进程可以做的一件事就是拥有自己的页表，

1158
01:15:37,780 --> 01:15:39,970
实际上，它需要有自己的页表，

1159
01:15:39,970 --> 01:15:42,800
否则，它就不会起作用了，

1160
01:15:43,550 --> 01:15:46,430
进程可以做的另一件事是

1161
01:15:46,460 --> 01:15:56,310
在它的小虚拟机中拥有管理员模式和用户模式，

1162
01:15:56,520 --> 01:15:57,900
并且能够运行，

1163
01:15:57,900 --> 01:16:02,340
能够将管理程序代码自身设置为保护，

1164
01:16:02,730 --> 01:16:05,760
对在访客用户模式下运行的代码。

1165
01:16:06,160 --> 01:16:09,100
所以这篇论文谈到了两种不同的用途，

1166
01:16:09,430 --> 01:16:12,220
可以用 Dune 做的两件不同的事。

1167
01:16:13,090 --> 01:16:18,040
所以，这个能力可以获得，

1168
01:16:18,040 --> 01:16:21,940
对于一个进程，获得对管理者模式而不是用户模式的支持，

1169
01:16:22,900 --> 01:16:29,140
允许它们在沙箱中运行不受信任的插件代码。

1170
01:16:31,660 --> 01:16:32,470
所以这里的想法是，

1171
01:16:32,470 --> 01:16:36,250
也许主程序是一个网络浏览器，

1172
01:16:36,760 --> 01:16:42,160
你可以下载网络浏览器运行的插件，

1173
01:16:42,250 --> 01:16:47,810
也许是一个新的视频解码器，

1174
01:16:47,810 --> 01:16:49,280
或者是新的广告拦截器之类的，

1175
01:16:49,280 --> 01:16:50,810
但是我们并不完全信任那个插件，

1176
01:16:50,810 --> 01:16:53,450
所以我们想以某种方式以有限的特权运行它，

1177
01:16:54,740 --> 01:16:58,670
这是可能的，但在普通 Linux 中做起来有点困难，

1178
01:16:58,670 --> 01:17:04,460
但是有了 Dune ，我们就可以在用户空间中运行插件，

1179
01:17:04,460 --> 01:17:08,510
而且在管理者模式下进程中运行的 Web 浏览器，

1180
01:17:08,570 --> 01:17:10,790
可以配置页表，

1181
01:17:11,910 --> 01:17:14,040
配置不同的页表，

1182
01:17:14,400 --> 01:17:16,260
供这个用户代码使用，

1183
01:17:16,260 --> 01:17:17,970
因为它允许写入 cr3 ，

1184
01:17:18,420 --> 01:17:23,280
这允许它运行这个不受信任的插件代码，

1185
01:17:23,670 --> 01:17:26,160
只允许它受限地访问

1186
01:17:26,190 --> 01:17:29,850
Web 浏览器内存中的一些页面，

1187
01:17:30,850 --> 01:17:33,910
这样即使插件代码是恶意的，

1188
01:17:33,910 --> 01:17:38,260
也不能随意读写主网页浏览器的内存，

1189
01:17:38,930 --> 01:17:43,430
如果用户代码希望进行系统调用，

1190
01:17:44,070 --> 01:17:46,260
但是这些系统调用，

1191
01:17:46,620 --> 01:17:54,400
实际上陷入进程的管理者模式，而不是 Linux 的，

1192
01:17:54,400 --> 01:17:58,480
这个插件代码可能认为它在调用 fork 或读写什么的，

1193
01:17:58,510 --> 01:18:02,650
但实际上这些执行系统调用的尝试

1194
01:18:02,770 --> 01:18:05,960
会陷入 Web 浏览器进程中，

1195
01:18:05,990 --> 01:18:07,130
它们可以做任何事情，

1196
01:18:07,130 --> 01:18:11,390
它们不能执行系统调用，或者别的什么，

1197
01:18:12,350 --> 01:18:16,790
我们的网络浏览器可以完全控制沙盒的插件代码。

1198
01:18:19,740 --> 01:18:21,360
作为一个概述，

1199
01:18:21,360 --> 01:18:24,150
关于使用 Dune 沙箱，有什么问题吗？

1200
01:18:30,280 --> 01:18:31,570
公平地说，这是一种，

1201
01:18:31,570 --> 01:18:36,040
这种效果可以通过使用完全不同的技术来实现，

1202
01:18:36,070 --> 01:18:40,800
使用现有的 Linux 的设施，

1203
01:18:40,800 --> 01:18:46,080
但是 Dune 允许你提供一种特别优雅和高效的方式，

1204
01:18:47,070 --> 01:18:48,840
通过使用 VT-x 硬件。

1205
01:18:51,550 --> 01:18:56,790
论文讨论的使用 Dune 的另一件事是，

1206
01:18:56,790 --> 01:18:58,410
使垃圾收集更快，

1207
01:18:58,800 --> 01:19:00,150
这里是，

1208
01:19:00,150 --> 01:19:05,280
它的工作方式是通过允许垃圾收集，

1209
01:19:05,880 --> 01:19:08,280
我们不再使用沙盒，

1210
01:19:08,280 --> 01:19:10,710
实际上我们甚至不使用用户模式，

1211
01:19:10,710 --> 01:19:12,270
我们只有一个程序，

1212
01:19:12,690 --> 01:19:16,710
假设我们在写任何程序，

1213
01:19:16,710 --> 01:19:18,360
但是在具有垃圾收集的语言中，

1214
01:19:18,360 --> 01:19:21,930
比如 Java 或 Python 之类的，

1215
01:19:22,590 --> 01:19:24,060
垃圾收集可能会很慢，

1216
01:19:25,000 --> 01:19:28,630
有几十种技巧可以让垃圾收集更快，

1217
01:19:28,660 --> 01:19:31,420
但对垃圾收集者来说，重要的一点是，

1218
01:19:31,420 --> 01:19:33,250
垃圾收集器有时，

1219
01:19:33,250 --> 01:19:38,140
许多垃圾收集器跟踪发现内存仍然是活动的，

1220
01:19:38,230 --> 01:19:42,790
通过跟踪从寄存器开始的所有对象的所有指针，

1221
01:19:42,790 --> 01:19:47,050
如果在完成跟踪后没有找到一些对象，

1222
01:19:47,050 --> 01:19:51,310
那么无法到达的对象，没有任何指针关联的，

1223
01:19:51,310 --> 01:19:52,780
它可以被释放。

1224
01:19:53,600 --> 01:19:56,900
但是许多垃圾收集器同时运行，

1225
01:19:56,900 --> 01:19:59,720
与主程序在不同的线程或其他地方，

1226
01:19:59,930 --> 01:20:02,450
所以可能垃圾收集器已经开始跟踪

1227
01:20:02,450 --> 01:20:06,350
来自某组寄存器的指针，

1228
01:20:06,350 --> 01:20:08,510
在这个对象之后有一个指针，

1229
01:20:08,510 --> 01:20:10,190
有指向这些对象的指针，

1230
01:20:10,190 --> 01:20:13,130
并且垃圾收集器跟随这些指针中的每一个，

1231
01:20:13,550 --> 01:20:16,970
向下到达对象的树或图，

1232
01:20:17,270 --> 01:20:21,550
可能垃圾收集器已经到这里了，

1233
01:20:22,220 --> 01:20:23,750
并且跟踪所有这些对象，

1234
01:20:23,750 --> 01:20:28,430
但是因为垃圾收集器与程序本身同时运行，

1235
01:20:28,820 --> 01:20:33,710
也许程序修改了这个对象，垃圾收集器已经追踪过的，

1236
01:20:34,480 --> 01:20:35,530
这是一个糟糕的处理，

1237
01:20:35,560 --> 01:20:39,130
因为现在对象指针列表，

1238
01:20:39,130 --> 01:20:41,770
垃圾收集器决定是活的还是死的或其他的，

1239
01:20:41,770 --> 01:20:42,910
它可能是不正确的，

1240
01:20:42,910 --> 01:20:46,900
因为看过的对象已经被程序修改。

1241
01:20:48,490 --> 01:20:51,220
所以， Dune 使用页表支持，

1242
01:20:51,220 --> 01:20:54,970
为垃圾收集器提供一种检测这种写入的方法，

1243
01:20:55,690 --> 01:21:04,060
特别是 Dune 设置 VT-x 支持的虚拟 cr3 ，

1244
01:21:04,510 --> 01:21:06,100
指向它自己的页表，

1245
01:21:07,000 --> 01:21:11,050
然后使所有这些页表条目有效，

1246
01:21:11,050 --> 01:21:16,330
但是它查看 d 位，每个页表条目有一个脏位，

1247
01:21:16,540 --> 01:21:20,640
在这种情况下，对这页进行了写入，

1248
01:21:20,640 --> 01:21:23,130
如果程序写入某个对象，

1249
01:21:23,250 --> 01:21:26,310
那么相应页面中的脏位，

1250
01:21:27,390 --> 01:21:30,660
在页表中，脏位将会设置，

1251
01:21:30,720 --> 01:21:34,140
所以，垃圾收集器完成了对这些物体的追踪，

1252
01:21:34,170 --> 01:21:36,780
它返回并查看页表中的 d 位，

1253
01:21:36,990 --> 01:21:41,340
定义包含可能已修改的对象的所有页面，

1254
01:21:41,340 --> 01:21:43,260
并重新扫描这些对象，

1255
01:21:43,590 --> 01:21:48,000
事实证明，这种获取 d 位的能力，

1256
01:21:48,330 --> 01:21:51,630
对于普通 Linux 来说是困难和缓慢的，

1257
01:21:52,700 --> 01:21:53,930
我甚至不知道 Linux 是否支持，

1258
01:21:53,930 --> 01:21:57,710
有些操作系统可以进行系统调用来请求 d 位，

1259
01:21:58,610 --> 01:22:00,860
但是如果你使用 Dune 和 VT-x ，

1260
01:22:00,860 --> 01:22:05,450
然后，这个进程可以只使用普通的加载和存储指令

1261
01:22:05,450 --> 01:22:08,930
来获得 PTE 和 d 位，并且非常快。

1262
01:22:09,920 --> 01:22:12,050
所以他们展示了，

1263
01:22:12,050 --> 01:22:17,180
这个技巧对于一些垃圾收集密集型的程序来说，

1264
01:22:17,600 --> 01:22:20,480
大大加快了程序的运行速度。

1265
01:22:23,260 --> 01:22:24,160
有什么问题吗？

1266
01:22:26,500 --> 01:22:34,020
如果沙箱程序想要，

1267
01:22:35,140 --> 01:22:38,470
运行自己的垃圾收集器或类似的东西，会发生什么？

1268
01:22:38,470 --> 01:22:40,270
我明白了，所以你使用，

1269
01:22:40,270 --> 01:22:40,810
好的，

1270
01:22:40,810 --> 01:22:44,230
所以，我们开始使用 Dune ，

1271
01:22:45,130 --> 01:22:48,070
我们有一个 Dune 进程，

1272
01:22:48,070 --> 01:22:55,150
它使用 VT-x 是管理员模式而不是用户模式，

1273
01:22:55,180 --> 01:22:57,280
我们在用户模式下运行一个插件，

1274
01:22:57,280 --> 01:23:00,940
但是插件也是用垃圾收集语言编写的，

1275
01:23:00,940 --> 01:23:04,960
并且希望使用它自己的页表，

1276
01:23:05,710 --> 01:23:09,550
它自己的 cr3 指向它自己的包含 d 位的页表。

1277
01:23:10,660 --> 01:23:12,580
不，那不能工作，

1278
01:23:12,580 --> 01:23:14,890
因为我们将要运行，

1279
01:23:14,890 --> 01:23:18,340
Dune 希望你运行沙箱插件的方式是，

1280
01:23:18,340 --> 01:23:22,270
运行它们并在客户机用户模式下使用它们，

1281
01:23:22,880 --> 01:23:24,980
客户机用户模式不允许，

1282
01:23:25,100 --> 01:23:28,730
就像用户模式不允许考虑 cr3 ，

1283
01:23:29,240 --> 01:23:31,430
所以，在客户机模式下，

1284
01:23:31,430 --> 01:23:34,100
我们不能拥有自己的页表，

1285
01:23:34,100 --> 01:23:37,070
所以我们不能快速访问这个 d 位，

1286
01:23:38,610 --> 01:23:41,400
它只在客户机管理者模式下。

1287
01:23:42,050 --> 01:23:43,190
我们可以有自己的 cr3 ，

1288
01:23:44,210 --> 01:23:46,220
所以你不能，

1289
01:23:46,980 --> 01:23:50,250
没有明显的方法来结合这两种技巧，

1290
01:23:50,610 --> 01:23:53,640
Dune 允许的两种技巧。

1291
01:23:57,380 --> 01:24:04,730
假设某人写了一个浏览器使用了 Dune ，

1292
01:24:04,820 --> 01:24:06,140
那就是说，

1293
01:24:06,740 --> 01:24:09,050
那就很难做了，

1294
01:24:09,050 --> 01:24:12,260
如果有些计算机不支持 Dune 之类的东西，

1295
01:24:12,620 --> 01:24:16,580
比如，让 Chrome 使用 Dune 很难，

1296
01:24:16,700 --> 01:24:19,190
不是每个计算机都有那样的内核模块。

1297
01:24:19,220 --> 01:24:23,630
好的，首先你必须在一台支持 VT-x 的计算机上运行，

1298
01:24:23,840 --> 01:24:25,940
底层计算机支持 VT-x ，

1299
01:24:25,940 --> 01:24:28,310
这意味着很多英特尔芯片，很多。

1300
01:24:29,960 --> 01:24:32,870
所以，如果你需要 VT-x 来运行 Dune ，

1301
01:24:32,870 --> 01:24:34,040
必须加载 Dune ，

1302
01:24:34,040 --> 01:24:36,980
才能运行利用 Dune 的浏览器，

1303
01:24:36,980 --> 01:24:39,080
所以，是的，你必须正确地设置它。

1304
01:24:41,330 --> 01:24:44,060
这是个研究项目，

1305
01:24:45,560 --> 01:24:49,300
它的目的是让人们思考

1306
01:24:49,300 --> 01:24:51,940
可以在现实世界中部署的东西，

1307
01:24:51,940 --> 01:24:54,500
它们看起来很有价值，

1308
01:24:55,220 --> 01:24:56,630
所以就像 Linux ，

1309
01:24:56,630 --> 01:25:01,040
Linux 有成百上千的功能，

1310
01:25:01,040 --> 01:25:05,590
所以，有人决定将 Dune 添加到 Linux 中作为一个标准功能，

1311
01:25:05,590 --> 01:25:07,090
然后可以依赖它，

1312
01:25:07,480 --> 01:25:09,430
Chrome 直接使用它就不成问题了。

1313
01:25:17,710 --> 01:25:18,820
抱歉，从高层级上看，

1314
01:25:18,820 --> 01:25:23,040
Dune 像是创建了一个虚拟机，

1315
01:25:23,040 --> 01:25:26,100
但运行的不是虚拟机，而是运行一个进程。

1316
01:25:26,370 --> 01:25:30,220
或者，是的，你可以用任何一种方式来表达，

1317
01:25:30,220 --> 01:25:36,230
我的意思是，它支持的是进程的抽象，

1318
01:25:37,240 --> 01:25:40,060
但是它使用的不是页表硬件，

1319
01:25:40,450 --> 01:25:43,510
它使用 CPU 硬件来支持进程抽象，

1320
01:25:44,330 --> 01:25:47,120
但是它使用的不是特定的 CPU 硬件，

1321
01:25:47,120 --> 01:25:49,870
而是使用 VT-x 硬件，

1322
01:25:49,870 --> 01:25:52,470
作为一些额外的功能，

1323
01:25:52,800 --> 01:25:57,680
比如，能够设置自己的页面。

1324
01:25:59,010 --> 01:26:00,210
好的，我明白了，

1325
01:26:00,240 --> 01:26:02,940
我记得论文，我读过流程级别的抽象，

1326
01:26:02,940 --> 01:26:04,440
但我不明白它的意思，

1327
01:26:04,440 --> 01:26:05,970
不过，我现在明白了，谢谢。

1328
01:26:11,350 --> 01:26:13,060
好的，现在时间到了，

1329
01:26:13,060 --> 01:26:14,500
我很高兴继续，

1330
01:26:14,620 --> 01:26:17,110
任何人有更多的问题，很乐意回答。

1331
01:26:18,840 --> 01:26:19,860
是的，所以我有个问题，

1332
01:26:19,860 --> 01:26:23,550
特别是关于论文中说的一个东西是，

1333
01:26:23,550 --> 01:26:28,230
如果一个 Dune 中的进程 fork ，

1334
01:26:28,410 --> 01:26:31,140
它变成了一个非 Dune 进程，

1335
01:26:31,140 --> 01:26:34,470
这是不是安全跳出，或者。

1336
01:26:34,770 --> 01:26:35,610
攻击是什么？

1337
01:26:36,960 --> 01:26:39,990
如果你将某项内容作为 Dune 进程运行，

1338
01:26:40,020 --> 01:26:41,820
认为它现在是安全的，

1339
01:26:41,820 --> 01:26:45,840
但是然后它运行，从 fork 逃脱。

1340
01:26:46,020 --> 01:26:47,520
所以，这是一种可能性，

1341
01:26:48,250 --> 01:26:52,720
好的，如果代码在管理者模式下完成，

1342
01:26:53,880 --> 01:26:55,500
这里没有安全问题，

1343
01:26:55,500 --> 01:26:57,120
这些代码，

1344
01:26:57,120 --> 01:27:00,980
因为你已经拥有一些权限，

1345
01:27:00,980 --> 01:27:03,050
它不会获得额外的特权，只是 fork 。

1346
01:27:03,600 --> 01:27:04,260
好的。

1347
01:27:04,590 --> 01:27:08,460
编写代码，也许它使用的是 Dune 沙盒插件，

1348
01:27:09,060 --> 01:27:11,250
我们这里有不可信的代码，

1349
01:27:11,250 --> 01:27:16,960
让它在没有 Dune 的情况下运行是很危险的，

1350
01:27:16,960 --> 01:27:20,110
因为它是不可信的，我们使用 Dune 沙盒，

1351
01:27:20,290 --> 01:27:21,610
所以如果我们 fork ，

1352
01:27:22,590 --> 01:27:26,550
好的，所以这个代码不能 fork ，

1353
01:27:26,550 --> 01:27:28,650
你可以尝试调用 fork 系统调用，

1354
01:27:29,160 --> 01:27:35,150
但是这里的系统调用指令会陷入这个进程的管理者部分，

1355
01:27:35,420 --> 01:27:40,560
假设这一进程的管理者部分是精心编写的，不会被骗，

1356
01:27:40,860 --> 01:27:43,110
所以它不是真正的 fork 。

1357
01:27:43,640 --> 01:27:44,480
所以这是行不通的，

1358
01:27:44,570 --> 01:27:46,340
如果管理者代码，

1359
01:27:46,340 --> 01:27:47,330
它允许被 fork ，

1360
01:27:47,330 --> 01:27:49,340
它允许进行系统调用，

1361
01:27:49,340 --> 01:27:52,190
你可以 fork 这个进程，使用相同的内存镜像，

1362
01:27:52,190 --> 01:27:55,980
所以我们会把插件放在这里，然后。

1363
01:27:56,160 --> 01:27:56,700
我明白了。

1364
01:27:56,940 --> 01:27:59,970
如果你没有意识到 fork 关掉了 Dune ，

1365
01:28:00,580 --> 01:28:01,510
而且，

1366
01:28:05,370 --> 01:28:07,200
我的意思是很难想象这是怎么发生的，

1367
01:28:07,200 --> 01:28:11,220
如果它要恢复插件的执行，

1368
01:28:11,220 --> 01:28:12,930
那将是非常愚蠢的，

1369
01:28:12,990 --> 01:28:14,370
那个插件是一个沙盒，

1370
01:28:14,520 --> 01:28:19,000
事实上，代码跳入沙箱中的这里，

1371
01:28:19,000 --> 01:28:20,380
涉及特权指令，

1372
01:28:20,380 --> 01:28:21,790
就像这张幻灯片上一样，

1373
01:28:22,090 --> 01:28:27,500
因为它切换客户机模式，

1374
01:28:27,500 --> 01:28:28,970
如果你在这里执行那条指令，

1375
01:28:28,970 --> 01:28:30,500
那是非法指令。

1376
01:28:32,160 --> 01:28:35,340
我想我误解的是，

1377
01:28:35,340 --> 01:28:37,860
我认为插件不是一个进程，

1378
01:28:37,860 --> 01:28:42,210
比如 Dune 进程就是沙盒，插件就在里面，

1379
01:28:42,630 --> 01:28:45,240
进程只是可以使用功能，

1380
01:28:45,240 --> 01:28:48,060
来让插件运行得更快。

1381
01:28:48,180 --> 01:28:53,560
是的，我们假设下面的这个软件是聪明的，

1382
01:28:53,560 --> 01:28:57,490
它会小心，

1383
01:28:57,760 --> 01:29:02,060
防止沙箱在现实生活中执行。

1384
01:29:03,360 --> 01:29:09,090
它不是不安全的，对于 Dune 进程有管理者模式，

1385
01:29:09,090 --> 01:29:11,910
因为它实际上是 non-root 模式下的管理员模式，

1386
01:29:11,910 --> 01:29:15,690
与管理者模式一样，在客户机操作系统中。

1387
01:29:15,870 --> 01:29:17,790
比如你可以让它做任何事情，

1388
01:29:17,790 --> 01:29:22,230
但是因为 VT-x 将会像一个虚拟机，

1389
01:29:22,230 --> 01:29:23,340
所以它不会伤害我们。

1390
01:29:23,580 --> 01:29:26,070
没错，它无法从它的地址空间讨论，

1391
01:29:26,070 --> 01:29:30,270
Dune ，一组 EPT 将其约束到它的地址空间。

1392
01:29:33,100 --> 01:29:33,940
理解了。

1393
01:29:35,560 --> 01:29:37,060
所以我还有最后一件事，

1394
01:29:37,060 --> 01:29:42,760
有一段是关于 EPT 的，

1395
01:29:42,760 --> 01:29:48,730
它说用户页表可以扩展地址，

1396
01:29:48,880 --> 01:29:50,950
比如将它们重新映射到原来的布局，

1397
01:29:51,420 --> 01:29:54,330
我不明白整段话的意思。

1398
01:29:54,330 --> 01:29:56,040
所以，我不知道。

1399
01:29:56,040 --> 01:29:57,450
也许这有点太具体了。

1400
01:29:58,280 --> 01:30:00,620
我认为是，

1401
01:30:00,620 --> 01:30:09,840
x86 上的物理地址比虚拟地址具有更少的位数，

1402
01:30:10,340 --> 01:30:11,270
所以我在猜测，

1403
01:30:11,600 --> 01:30:16,040
这意味着 EPT ，

1404
01:30:17,230 --> 01:30:19,900
普通页表将虚拟地址映射到物理地址，

1405
01:30:19,900 --> 01:30:22,120
物理地址有更少的位，

1406
01:30:22,300 --> 01:30:25,150
所以这就构成了，

1407
01:30:25,850 --> 01:30:30,440
也就是说，当 Dune 设置的时候，

1408
01:30:31,100 --> 01:30:33,740
进程的地址空间，

1409
01:30:33,800 --> 01:30:34,760
或者一种方式是，

1410
01:30:34,760 --> 01:30:36,800
当 Dune 为进程设置地址空间时，

1411
01:30:36,950 --> 01:30:44,010
进程地址空间必须适合 Dune 进程的较小位数。

1412
01:30:44,040 --> 01:30:44,610
好的。

1413
01:30:44,640 --> 01:30:46,440
普通进程将使用，

1414
01:30:46,530 --> 01:30:47,430
我不知道数字是多少，

1415
01:30:47,430 --> 01:30:49,620
比如 48 位虚拟地址，

1416
01:30:49,710 --> 01:30:52,890
但也许物理地址只有 36 位，

1417
01:30:53,420 --> 01:30:54,410
同样，这是我编造的。

1418
01:30:54,470 --> 01:30:57,470
普通进程可以使用所有 48 位用于虚拟地址，

1419
01:30:57,500 --> 01:31:00,230
而 Dune 进程只能使用 36 位或其他位。

1420
01:31:00,820 --> 01:31:04,980
所以有不同的规则来适合。

1421
01:31:06,960 --> 01:31:07,620
好的。

1422
01:31:13,220 --> 01:31:15,770
我对 VT-x 方案有一个问题，

1423
01:31:15,830 --> 01:31:18,020
以及我们如何访问页表，

1424
01:31:18,560 --> 01:31:22,490
比如，当我们使用这种方式访问页表时，

1425
01:31:22,640 --> 01:31:25,250
因为我们要去 EPT ，

1426
01:31:25,250 --> 01:31:28,820
然后在那里进行第二次转换，

1427
01:31:28,820 --> 01:31:32,990
从客户物理地址到主机物理地址，

1428
01:31:34,260 --> 01:31:38,640
是不是访问页表的延迟变得更低？

1429
01:31:40,370 --> 01:31:43,940
可能需要更多时间，

1430
01:31:43,940 --> 01:31:47,600
对于硬件 MMU ，使用更多时间来转换地址，

1431
01:31:48,140 --> 01:31:49,730
因为现在它也必须做两次，

1432
01:31:49,790 --> 01:31:53,030
最糟糕的情况要糟糕得多，

1433
01:31:53,030 --> 01:31:56,550
因为，你知道在 RISC-V 上，

1434
01:31:56,550 --> 01:31:59,730
页表有多个级别，

1435
01:31:59,730 --> 01:32:04,470
所以 MMU 生成从这个页表，

1436
01:32:04,470 --> 01:32:05,610
然后是下一层，下一层，

1437
01:32:05,790 --> 01:32:08,850
xv6 中的每一个也具有多个级别，

1438
01:32:09,870 --> 01:32:11,850
所以，在 xv6 中，

1439
01:32:12,440 --> 01:32:14,600
在查找中，在第一个主页表中，

1440
01:32:14,600 --> 01:32:17,210
可能还必须进行多个内存引用，

1441
01:32:17,810 --> 01:32:21,020
多个内存引用中的每一个都必须通过 EPT ，

1442
01:32:21,710 --> 01:32:24,560
而 EPT 也是多级页表，

1443
01:32:24,950 --> 01:32:30,230
所以我甚至不知道最坏情况下的内存引用数量，

1444
01:32:30,230 --> 01:32:32,210
但在 VT-x 下就更糟了，

1445
01:32:32,210 --> 01:32:36,330
这并不是普通的情况，

1446
01:32:36,330 --> 01:32:39,030
所以可能，事实上有很多缓存，

1447
01:32:39,240 --> 01:32:41,670
所以通常不会遇到最坏的情况，但是。

1448
01:32:43,500 --> 01:32:49,330
今天的虚拟机总体上仍然很慢，

1449
01:32:49,600 --> 01:32:53,770
如果是这样的话，我想知道 AWS 是如何运作的，

1450
01:32:53,770 --> 01:32:57,710
如果它看起来很快，而且运行得很好，那么。

1451
01:32:58,070 --> 01:33:02,390
是的，我相信他们用的是 VT-x 硬件，

1452
01:33:03,100 --> 01:33:04,990
他们使用我们所说的支持，

1453
01:33:04,990 --> 01:33:11,320
这也是实现高效设备访问的聪明的设备方案，

1454
01:33:11,470 --> 01:33:17,840
结果是 AWS 虚拟机速度很快，

1455
01:33:19,160 --> 01:33:21,230
或者比真正的电脑慢不了多少。

1456
01:33:22,850 --> 01:33:23,480
好的，非常感谢。

1457
01:33:25,970 --> 01:33:31,580
哦，我还有一个关于 trap-and-emulate 影子拷贝的问题，

1458
01:33:31,610 --> 01:33:34,400
所以你说它就像，

1459
01:33:34,640 --> 01:33:36,410
我知道你会怎么做，

1460
01:33:36,410 --> 01:33:40,460
但它是真的制作影子副本，还是只是，

1461
01:33:41,600 --> 01:33:43,520
我认为它必须是影子复制，

1462
01:33:43,520 --> 01:33:46,850
因为它必须让这个进程自己完成，

1463
01:33:46,850 --> 01:33:49,310
而不是去所有的 trap ，

1464
01:33:49,310 --> 01:33:53,330
它每次做，是否记得前一次。

1465
01:33:53,360 --> 01:33:57,980
好的，所以是的，是的，是的，

1466
01:33:57,980 --> 01:34:01,940
虚拟机监视器必须创建新的页表，

1467
01:34:01,940 --> 01:34:04,390
是的，必须创建一个新的页表，

1468
01:34:04,390 --> 01:34:07,550
它的虚拟机监视器的页表，

1469
01:34:07,550 --> 01:34:10,190
格式化为真实硬件使用的，

1470
01:34:10,220 --> 01:34:14,600
当然，有很多缓存和重用的机会，

1471
01:34:14,600 --> 01:34:17,480
所以它是一个聪明的虚拟机监视器，

1472
01:34:17,480 --> 01:34:21,020
如果它们注意到，客户机修改了一个 PTE ，

1473
01:34:21,740 --> 01:34:24,230
那么虚拟机监视器可能能够

1474
01:34:24,230 --> 01:34:29,460
相应地有限的工作来更新它的影子页面。

1475
01:34:30,400 --> 01:34:31,720
它可能也会保留，

1476
01:34:32,680 --> 01:34:37,870
如果它是多个虚拟机之间的分时复用，

1477
01:34:37,870 --> 01:34:40,060
虚拟机监视器将保持

1478
01:34:40,090 --> 01:34:43,510
未运行的虚拟机的影子页表，

1479
01:34:43,960 --> 01:34:46,330
这样它可以直接重用它们，

1480
01:34:47,320 --> 01:34:49,390
在切换回那个虚拟机时。

1481
01:34:50,070 --> 01:34:51,180
好的，我明白了，

1482
01:34:51,210 --> 01:34:52,200
那是不是意味着你必须，

1483
01:34:52,200 --> 01:34:55,610
比如，你必须记住每个影子副本，

1484
01:34:55,610 --> 01:35:00,800
为每个虚拟机的每个进程。

1485
01:35:03,320 --> 01:35:07,670
是的，有很多页表，

1486
01:35:07,790 --> 01:35:09,200
运行在虚拟机上，

1487
01:35:09,500 --> 01:35:14,090
虚拟机知道客户机执行的所有页表切换。

1488
01:35:14,640 --> 01:35:20,100
维护影子页表的具体问题，

1489
01:35:21,090 --> 01:35:22,470
它消耗了大量的工作。

1490
01:35:23,900 --> 01:35:26,930
好的，非常感谢。

1491
01:35:26,930 --> 01:35:29,000
这是其中之一，

1492
01:35:29,000 --> 01:35:31,070
硬件支持虚拟机，

1493
01:35:31,700 --> 01:35:33,110
变得容易多了。

1494
01:35:34,620 --> 01:35:35,370
哦，好的，好的，

1495
01:35:35,370 --> 01:35:36,510
我明白了，好的。

1496
01:35:36,540 --> 01:35:39,210
因为 EPT 意味着你不需要编造自己的影子页面。

1497
01:35:39,480 --> 01:35:42,900
好的，很好，谢谢。

1498
01:35:43,080 --> 01:35:43,620
好的。

1499
01:35:51,010 --> 01:35:52,330
好的，我得走了，

1500
01:35:52,330 --> 01:35:54,610
但我们周三见，谢谢。

1501
01:35:54,850 --> 01:35:55,810
谢谢。

1502
01:35:56,860 --> 01:35:57,610
谢谢。

1503
01:36:02,010 --> 01:36:04,920
如果你有时间，再问一个问题，

1504
01:36:05,700 --> 01:36:10,290
如果这是关于垃圾收集的，

1505
01:36:10,500 --> 01:36:14,130
如何重新扫描才能看到脏位，

1506
01:36:14,370 --> 01:36:20,050
它像是一个持续的进程，

1507
01:36:20,050 --> 01:36:22,810
它持续无限期地重新扫描，

1508
01:36:22,810 --> 01:36:24,430
因为，它能不能。

1509
01:36:26,300 --> 01:36:27,980
你在问，什么是结束，

1510
01:36:27,980 --> 01:36:30,770
因为总会有新的修改，

1511
01:36:30,860 --> 01:36:33,650
所以实际上这个潜在的问题，

1512
01:36:33,650 --> 01:36:35,390
垃圾收集器所做的是，

1513
01:36:35,630 --> 01:36:40,830
它做一次，完成一次，

1514
01:36:41,100 --> 01:36:44,550
它冻结了所有其他东西，除了垃圾收集器，

1515
01:36:44,550 --> 01:36:45,900
所以不会有其他事情发生，

1516
01:36:46,050 --> 01:36:48,000
然后它会返回并查看脏页，

1517
01:36:48,000 --> 01:36:49,380
当然，其他一切都会被冻结，

1518
01:36:50,040 --> 01:36:52,500
不会再出现脏页，

1519
01:36:52,770 --> 01:36:55,110
然后垃圾收集器查找所有脏页，

1520
01:36:55,110 --> 01:36:56,820
然后它知道它已经完成了，

1521
01:36:56,820 --> 01:36:58,830
完成它任何它应该做的事情，

1522
01:36:58,830 --> 01:36:59,640
并创建一个空闲列表，

1523
01:37:00,150 --> 01:37:03,790
并恢复所有它们已经停止的线程。

1524
01:37:04,440 --> 01:37:06,930
哦，好的，好的，这很有道理，

1525
01:37:06,930 --> 01:37:09,180
我不知道它冻结了其他的一切，但是。

1526
01:37:09,330 --> 01:37:11,250
是的，这是很复杂的东西，

1527
01:37:11,250 --> 01:37:14,160
当然 Dune 论文中没有足够的篇幅

1528
01:37:14,160 --> 01:37:18,570
来解释垃圾收集器的所有细节。

1529
01:37:20,400 --> 01:37:22,500
好的，非常感谢。

1530
01:37:22,620 --> 01:37:24,690
谢谢，再见。

