1
00:00:01,900 --> 00:00:02,590
好的，

2
00:00:04,270 --> 00:00:08,140
欢迎学习 6.S081 操作系统，

3
00:00:08,770 --> 00:00:11,980
我是 Robert ，将和 Frans 一起执教，

4
00:00:12,280 --> 00:00:15,250
David 和 Nicolass 作为助教。

5
00:00:16,450 --> 00:00:18,850
在 zoom 讲座的的时候，

6
00:00:18,850 --> 00:00:19,690
随时可以提问，

7
00:00:19,690 --> 00:00:21,970
你可以讲话打断我，

8
00:00:21,970 --> 00:00:25,390
或者在聊天窗口中输入一些东西。

9
00:00:25,840 --> 00:00:28,450
我们会有一名工作人员查看并替你提问。

10
00:00:29,900 --> 00:00:32,120
顺便说一下，我们会录下这些讲座，

11
00:00:32,120 --> 00:00:33,680
然后把录像开放出来，

12
00:00:33,680 --> 00:00:35,180
这样你们可以复习，

13
00:00:35,180 --> 00:00:37,580
或者对于来不了的人

14
00:00:38,000 --> 00:00:39,620
他们仍然可以看到讲座。

15
00:00:40,710 --> 00:00:45,690
好的，首先我想列出一些课程目标，

16
00:00:45,720 --> 00:00:48,910
第一个目标是，

17
00:00:49,330 --> 00:00:55,270
理解操作系统的设计和实现。

18
00:00:56,310 --> 00:01:01,210
是的，设计是一种高层次的结构，

19
00:01:01,210 --> 00:01:04,510
而实现是实际中代码真正的样子，

20
00:01:04,600 --> 00:01:06,490
我们将做这两个方面花费大量的时间。

21
00:01:07,940 --> 00:01:13,400
为了更深入地理解这是怎么运行的，

22
00:01:13,640 --> 00:01:23,130
你经通过一个小型操作系统获得实践经验，

23
00:01:23,130 --> 00:01:24,720
就是我们的 xv6 操作系统。

24
00:01:25,320 --> 00:01:30,270
而且除了查看现有的操作系统，

25
00:01:30,270 --> 00:01:34,590
你还可以从实验中获得一下经验，

26
00:01:34,590 --> 00:01:38,010
扩展操作系统，改进操作系统，

27
00:01:38,100 --> 00:01:43,740
编写使用操作系统接口的系统软件，

28
00:01:43,740 --> 00:01:44,790
在运行应用程序时。

29
00:01:46,520 --> 00:01:50,420
所以，这是你们在课程中要做的，

30
00:01:52,980 --> 00:01:56,580
在课程中，我们对操作系统

31
00:01:56,580 --> 00:01:58,500
本身的作用也很感兴趣。

32
00:02:00,980 --> 00:02:04,790
所以，我有一系列的东西，

33
00:02:04,790 --> 00:02:08,630
你知道，有很多操作系统，

34
00:02:08,630 --> 00:02:10,310
不同的操作系统，

35
00:02:10,550 --> 00:02:13,550
它们通常有一个共同的目标。

36
00:02:15,150 --> 00:02:19,800
其中之一就是对硬件的抽象，

37
00:02:21,520 --> 00:02:26,170
通常从买一台计算机开始，

38
00:02:26,170 --> 00:02:27,700
计算机包括 CPU 和内存，

39
00:02:27,760 --> 00:02:29,590
但这是一个非常低的层级。

40
00:02:29,940 --> 00:02:31,740
一系列的资源，

41
00:02:31,770 --> 00:02:35,910
拥有更高级别的接口和抽象是非常棒的，

42
00:02:35,910 --> 00:02:37,350
应用程序可以使用它们，

43
00:02:37,980 --> 00:02:43,470
比如为了方便和可移植性而产生的进程或文件系统。

44
00:02:44,360 --> 00:02:48,050
操作系统的另一个非常重要的目标是

45
00:02:48,050 --> 00:02:51,870
在许多应用程序中复用硬件。

46
00:02:52,360 --> 00:02:56,470
你可能运行文本编辑器，编译器，

47
00:02:56,470 --> 00:03:01,010
或者多个不同的数据库服务器，

48
00:03:01,010 --> 00:03:02,360
或者其他什么东西，

49
00:03:02,420 --> 00:03:04,940
能够使用操作系统

50
00:03:04,940 --> 00:03:06,530
同时运行它们是很棒的，

51
00:03:06,530 --> 00:03:10,040
而且所有同时运行的事情不会相互干扰。

52
00:03:11,420 --> 00:03:13,010
这通常叫做多路复用，

53
00:03:13,970 --> 00:03:16,280
因为操作系统上

54
00:03:16,280 --> 00:03:18,260
可能同时发生很多事情，

55
00:03:18,260 --> 00:03:21,620
它们必须不会相互干扰，

56
00:03:21,770 --> 00:03:23,330
即使有 bug 存在，

57
00:03:23,360 --> 00:03:26,510
这也就是所谓的隔离性。

58
00:03:27,120 --> 00:03:32,900
它的主要思想是，不同的活动不应该互相干涉，

59
00:03:33,050 --> 00:03:33,620
另一方面，

60
00:03:33,620 --> 00:03:37,070
不同的活动可以需要干涉，

61
00:03:37,070 --> 00:03:38,840
需要干涉来交互或协作，

62
00:03:38,870 --> 00:03:42,110
比如，如果我使用编辑器创建了一个文件，

63
00:03:42,230 --> 00:03:44,480
我希望编译器可以读取该文件，

64
00:03:44,990 --> 00:03:47,390
我们肯定希望允许这样的的共享。

65
00:03:47,860 --> 00:03:53,390
所有我们希望这种用户想要的共享。

66
00:03:55,670 --> 00:03:59,180
但是在很多情况下，用户不想分享，

67
00:03:59,180 --> 00:04:02,210
可能你登录到类似 Athena 的分时服务器，

68
00:04:02,300 --> 00:04:05,000
你肯定不希望别人读取你的文件，

69
00:04:05,000 --> 00:04:06,890
所以我们需要，想分享的的时候分享，

70
00:04:06,920 --> 00:04:09,380
不想分享的时候不分享。

71
00:04:09,760 --> 00:04:12,850
我们可以称其为安全系统或权限系统，

72
00:04:13,210 --> 00:04:14,500
即一个访问控制系统。

73
00:04:16,650 --> 00:04:19,230
人们看中操作系统的另一个原因是，

74
00:04:19,320 --> 00:04:21,840
如果你为一台计算机的硬件上花了很多钱，

75
00:04:21,870 --> 00:04:23,820
你希望应用程序能够获得

76
00:04:23,880 --> 00:04:28,680
硬件提供的全部性能。

77
00:04:28,800 --> 00:04:33,740
而且，很多都是应用编程。

78
00:04:34,010 --> 00:04:36,830
但是，不可避免的，

79
00:04:36,830 --> 00:04:38,840
操作系统必须确保

80
00:04:38,900 --> 00:04:42,410
它提供的任何服务

81
00:04:42,470 --> 00:04:46,010
都不会阻碍应用程序获得高性能，

82
00:04:46,250 --> 00:04:48,290
所以你希望至少不要阻碍，

83
00:04:48,290 --> 00:04:52,700
甚至可以帮助应用程序获得良好的性能。

84
00:04:55,880 --> 00:05:00,320
最后，大多数操作系统

85
00:05:00,890 --> 00:05:03,170
必须支持很多不同的应用程序，

86
00:05:03,170 --> 00:05:05,990
可能是笔记本电脑运行编辑器，

87
00:05:05,990 --> 00:05:07,550
可能是运行游戏，

88
00:05:07,610 --> 00:05:09,410
也可能操作系统需要支持

89
00:05:09,410 --> 00:05:12,740
数据库服务或云计算，

90
00:05:12,860 --> 00:05:17,960
通常因为操作系统的设计和构建成本很高，

91
00:05:18,620 --> 00:05:21,710
所以人们使用相同的操作系统来执行许多不同的任务，

92
00:05:21,710 --> 00:05:22,250
比如 Linux ，

93
00:05:22,250 --> 00:05:24,950
我相信大多数人都运行一个（操作系统），

94
00:05:24,950 --> 00:05:27,050
在我提到的所有情况下，

95
00:05:27,050 --> 00:05:29,480
所以相同的操作系统必须能够支持，

96
00:05:29,630 --> 00:05:33,950
一系列非常不同的用途。

97
00:05:36,830 --> 00:05:38,840
所以我们希望能够，

98
00:05:39,590 --> 00:05:42,470
同时支持所有这些不同的目标。

99
00:05:44,000 --> 00:05:46,520
我们将在课程中听到更多关于这些的信息。

100
00:05:47,810 --> 00:05:49,760
好的，对于操作系统，

101
00:05:49,790 --> 00:05:55,730
几十年来人们总结出一套设计思想，

102
00:05:56,000 --> 00:05:59,060
在组织事情方面运行良好，

103
00:05:59,310 --> 00:06:03,240
我来给你们展示一下这种经典设计。

104
00:06:05,890 --> 00:06:11,770
也是这门课的标准组织方式，

105
00:06:11,770 --> 00:06:17,100
实际上在很多操作系统上都是很常见的，

106
00:06:17,100 --> 00:06:20,340
所以这是一种操作系统的内部组织方式，

107
00:06:20,400 --> 00:06:29,000
我想用这个方框来表示计算机，

108
00:06:29,810 --> 00:06:33,850
计算机包含许多硬件，

109
00:06:33,850 --> 00:06:34,810
我把它们放在下面，

110
00:06:34,810 --> 00:06:42,040
有 CPU 、 内存、用来存储的磁盘，可能还有网络接口，

111
00:06:42,070 --> 00:06:44,800
这些硬件是最下面一层。

112
00:06:46,180 --> 00:06:49,540
而在顶部，你想要运行各种应用程序，

113
00:06:49,570 --> 00:06:53,200
或许是一个文本编辑器，这里我使用 vi 来表示，

114
00:06:53,590 --> 00:06:56,500
也可能是运行 C 编译器 CC ，

115
00:06:56,770 --> 00:06:59,920
也可以运行很多我们今天会讨论的其他东西，

116
00:06:59,920 --> 00:07:04,260
比如 shell 作为命令行界面，

117
00:07:04,410 --> 00:07:06,330
所以我们有了这些不同的程序在运行。

118
00:07:07,260 --> 00:07:11,430
而且这个运行应用程序的地方，

119
00:07:11,430 --> 00:07:13,260
通常称为用户空间。

120
00:07:14,260 --> 00:07:18,280
与此不同的是，这里有一个单独的程序，

121
00:07:19,440 --> 00:07:23,220
一个特殊的程序，它一直运行着，就是所谓的内核，

122
00:07:23,250 --> 00:07:27,150
内核是计算机资源的守护者，

123
00:07:27,270 --> 00:07:29,970
它在你开机时第一个启动，

124
00:07:30,270 --> 00:07:33,270
只有一个内核来管理数据

125
00:07:33,640 --> 00:07:36,280
帮助管理进程，

126
00:07:36,280 --> 00:07:40,810
并且内核也有很多的数据结构帮助访问，

127
00:07:40,810 --> 00:07:44,130
所有这些不同种类的硬件。

128
00:07:45,020 --> 00:07:48,890
这些用户程序需要使用的硬件。

129
00:07:49,550 --> 00:07:52,340
内核也有很多内置服务，

130
00:07:53,550 --> 00:07:55,260
比如，

131
00:07:55,260 --> 00:07:59,720
通常内核实现了一个文件系统，

132
00:07:59,720 --> 00:08:04,790
它实现了文件名、文件内容和文件夹，

133
00:08:04,790 --> 00:08:07,910
并且知道如何将文件存储在磁盘上，

134
00:08:07,910 --> 00:08:10,850
所以程序访问内核中的文件，

135
00:08:10,850 --> 00:08:14,530
然后文件系统访问磁盘。

136
00:08:15,410 --> 00:08:16,520
在这门课上，

137
00:08:17,460 --> 00:08:21,840
我们主要关注内核内部发生的所有事情，

138
00:08:22,140 --> 00:08:25,770
还有用户程序和内核之间的接口，

139
00:08:27,490 --> 00:08:31,390
还有内核里面的软件结构，

140
00:08:32,110 --> 00:08:37,030
所以我们很关心内核中的这些服务。

141
00:08:38,610 --> 00:08:40,350
其中之一是我提到过的文件系统，

142
00:08:40,380 --> 00:08:44,400
还有对进程的管理，

143
00:08:44,400 --> 00:08:47,250
每个运行的程序被称为进程，

144
00:08:47,250 --> 00:08:49,230
它有自己的内存，

145
00:08:49,230 --> 00:08:53,310
还有共享 CPU 时间。

146
00:08:53,640 --> 00:09:00,730
内核将进程作为内核服务进行管理，

147
00:09:01,300 --> 00:09:05,740
内核管理内存的分配，

148
00:09:05,950 --> 00:09:08,080
不同的进程需要不同数量的内存，

149
00:09:08,080 --> 00:09:13,310
内核复用、划分内存，

150
00:09:13,520 --> 00:09:18,000
给不同的进程分配内存。

151
00:09:24,400 --> 00:09:26,650
正如我提到的，内核影响文件系统，

152
00:09:26,650 --> 00:09:31,030
文件系统实际上分为三个逻辑部分或几个逻辑部分，

153
00:09:31,030 --> 00:09:32,530
但现在，我们可以从

154
00:09:32,530 --> 00:09:36,250
管理文件内容的角度来考虑它，

155
00:09:36,280 --> 00:09:38,140
找到内容在磁盘中的位置。

156
00:09:39,080 --> 00:09:40,610
每个文件内容都是可以变化的，

157
00:09:40,910 --> 00:09:44,150
文件系统也在某种程度上管理一个命名空间，

158
00:09:44,150 --> 00:09:45,620
每个文件都有一个名字，

159
00:09:45,650 --> 00:09:48,560
有一个层级目录，

160
00:09:48,830 --> 00:09:50,630
每个目录中有多个文件，

161
00:09:50,630 --> 00:09:53,360
所有这些都是由文件系统管理的。

162
00:09:54,030 --> 00:09:56,700
通常会有某种安全策略，

163
00:09:57,300 --> 00:09:59,130
有时也称为访问控制。

164
00:10:01,750 --> 00:10:03,130
由内核决定，

165
00:10:03,130 --> 00:10:07,210
当一个进程想要读取，使用资源时，

166
00:10:07,210 --> 00:10:09,370
或许是从磁盘读取东西，使用内存，

167
00:10:09,430 --> 00:10:11,590
内核内部的访问控制机制，

168
00:10:11,590 --> 00:10:14,110
可以决定它是允许还是不允许，

169
00:10:14,290 --> 00:10:15,610
这也会很复杂，

170
00:10:15,610 --> 00:10:18,820
如果我们讨论的是类似 Athena 的分时系统，

171
00:10:18,820 --> 00:10:22,480
在那里，每个进程可能由不同的用户运行，

172
00:10:22,480 --> 00:10:24,910
有不同的访问控制规则，

173
00:10:24,940 --> 00:10:26,890
是否允许访问其内容。

174
00:10:28,830 --> 00:10:31,410
在一个成熟的操作系统中，

175
00:10:31,710 --> 00:10:33,900
还有很多其他的服务，

176
00:10:34,050 --> 00:10:35,580
你知道，通常有某种方式

177
00:10:35,580 --> 00:10:37,650
让不同的进程互相通信，

178
00:10:37,650 --> 00:10:39,420
这称为进程间通信，

179
00:10:40,200 --> 00:10:43,830
通常有很多软件使用网络，

180
00:10:43,830 --> 00:10:48,690
比如用于网络通信的的 TCP/IP 协议，

181
00:10:49,900 --> 00:10:52,330
通常也会支持声卡，

182
00:10:52,330 --> 00:10:54,880
可能会有上百个不同磁盘驱动

183
00:10:54,880 --> 00:10:56,380
和上百个网卡驱动，

184
00:10:56,470 --> 00:10:58,150
所以在一个成熟的操作系统中，

185
00:10:58,150 --> 00:11:00,220
有大量的东西，

186
00:11:00,220 --> 00:11:03,850
这可能会在内核中运行数百万行代码。

187
00:11:05,300 --> 00:11:08,660
这是对内核内部的概述，

188
00:11:09,560 --> 00:11:13,340
我们还对应用程序与内核交互，

189
00:11:13,370 --> 00:11:15,920
以及相关的接口定义感兴趣。

190
00:11:19,060 --> 00:11:27,560
一般，所以这是内核的 API 。

191
00:11:30,610 --> 00:11:32,230
应用程序如何访问内核，

192
00:11:32,500 --> 00:11:35,410
通常是通过系统调用来完成的，

193
00:11:35,410 --> 00:11:40,440
它们看起来像是程序使用的函数调用，

194
00:11:41,100 --> 00:11:42,990
但实际上是跳入内核，

195
00:11:42,990 --> 00:11:47,130
并在执行内核中实现的系统调用，

196
00:11:47,430 --> 00:11:50,520
在这个讲座的后半部分，我会谈到这些，

197
00:11:51,090 --> 00:11:53,100
现在，只是让你初步了解一下。

198
00:11:53,100 --> 00:11:54,960
应用程序代码中

199
00:11:54,960 --> 00:11:57,660
几个不同的系统调用是什么样的。

200
00:12:00,310 --> 00:12:01,510
其中一个是，

201
00:12:01,630 --> 00:12:03,910
如果应用程序想要打开文件，

202
00:12:04,180 --> 00:12:06,670
它可以调用 open 系统调用。

203
00:12:07,420 --> 00:12:10,510
把文件名传给 open 系统调用，

204
00:12:10,720 --> 00:12:14,200
它想要打开一个名为 out 的文件并写入，

205
00:12:14,200 --> 00:12:17,500
下一个参数是 1 ，

206
00:12:17,500 --> 00:12:18,760
我想写那个文件，

207
00:12:19,000 --> 00:12:21,550
这个看起来像函数调用。

208
00:12:22,670 --> 00:12:26,480
open 系统调用实际上是跳入内核的指定代码，

209
00:12:26,480 --> 00:12:28,400
内核可以获得这些参数，

210
00:12:28,700 --> 00:12:30,680
执行一些实现 open 的内核代码，

211
00:12:30,680 --> 00:12:33,470
可能是访问磁盘，然后返回一个值，

212
00:12:33,470 --> 00:12:38,220
这就是文件描述符， fd 表示文件描述符。

213
00:12:38,610 --> 00:12:44,250
程序可以使用文件描述符来访问这个打开的文件。

214
00:12:44,760 --> 00:12:47,160
如果你想写入一个文件，

215
00:12:47,160 --> 00:12:50,930
需要使用系统调用 write ，

216
00:12:51,200 --> 00:12:53,360
你必须向它传递一个文件描述符，

217
00:12:53,360 --> 00:12:55,100
跟 open 返回的类似，

218
00:12:55,700 --> 00:12:59,270
这些是系统调用中传递的参数。

219
00:12:59,770 --> 00:13:01,600
从程序到内核，

220
00:13:01,960 --> 00:13:05,370
你给它一个指向一个字符缓冲区的指针，

221
00:13:05,370 --> 00:13:08,310
在 C 语言中，一个简单的方法是，

222
00:13:08,310 --> 00:13:13,480
使用双引号，然后加上字符串，

223
00:13:13,480 --> 00:13:16,690
字符串中的 \n 表示换行，

224
00:13:17,020 --> 00:13:19,810
第三个参数是字符数。

225
00:13:20,160 --> 00:13:23,190
如果想写入，这里是关键，

226
00:13:23,490 --> 00:13:25,350
把内存中的这个地址传过去，

227
00:13:25,860 --> 00:13:29,400
告诉内核，请把这个地址的 6 个字节

228
00:13:29,610 --> 00:13:32,520
写入到这个文件描述符关联的文件中。

229
00:13:33,750 --> 00:13:37,350
一个更有意思的系统调用

230
00:13:37,350 --> 00:13:40,560
是 fork 系统调用，

231
00:13:40,590 --> 00:13:42,420
它创建一个新的进程，

232
00:13:44,160 --> 00:13:48,000
并返回一个与调用方相同的进程，

233
00:13:48,300 --> 00:13:56,100
fork 返回新创建进程的进程标识符 pid 。

234
00:13:56,100 --> 00:13:59,270
更复杂的[]，我们还会听到更多关于这方面的内容。

235
00:14:00,740 --> 00:14:03,470
同样，这些看起来像函数调用，

236
00:14:04,400 --> 00:14:06,950
但是系统调用很特殊，因为它们跳入内核。

237
00:14:08,200 --> 00:14:10,660
这是初步了解，稍后我们会看到更多。

238
00:14:15,800 --> 00:14:17,570
这是一个简单的概述，

239
00:14:17,600 --> 00:14:25,000
我想提一下为什么我发现操作系统的学习，

240
00:14:25,300 --> 00:14:30,160
既有挑战性，又十分有趣。

241
00:14:32,710 --> 00:14:34,420
为什么值得

242
00:14:35,360 --> 00:14:38,450
值得在这方面开一门课。

243
00:14:39,370 --> 00:14:42,760
这很难的一个原因是，环境是难以应对的，

244
00:14:43,090 --> 00:14:46,360
内核的编程环境是难以应对的，

245
00:14:46,360 --> 00:14:51,860
因为当你在编程时，

246
00:14:51,860 --> 00:14:53,810
当你修改或扩展内核，

247
00:14:53,810 --> 00:14:55,580
或编写新的操作系统内核时，

248
00:14:55,640 --> 00:14:59,060
你提供的是其他人认为已经存在的基础设施，

249
00:14:59,060 --> 00:15:01,280
用来运行他们的程序。

250
00:15:01,640 --> 00:15:04,550
任何人编写应用程序都在操作系统上运行，

251
00:15:04,610 --> 00:15:06,500
当他们编写普通应用程序时，

252
00:15:06,500 --> 00:15:08,990
但是当我们构建操作系统时，

253
00:15:08,990 --> 00:15:12,410
操作系统下直接是硬件，

254
00:15:13,190 --> 00:15:15,620
结果是更难处理。

255
00:15:15,650 --> 00:15:16,310
在本课程中，

256
00:15:16,310 --> 00:15:22,210
我们用到一个叫 QEMU 的硬件模拟器，

257
00:15:22,790 --> 00:15:25,970
它模拟一个 CPU 和一台计算机，

258
00:15:25,970 --> 00:15:27,200
这样做会好一点，

259
00:15:27,200 --> 00:15:30,980
但它仍然是困难的编程环境。

260
00:15:32,360 --> 00:15:34,100
另一个困难又有趣的原因是，

261
00:15:34,100 --> 00:15:36,620
当你在设计操作系统时，

262
00:15:36,620 --> 00:15:39,500
必须解决一系列矛盾。

263
00:15:39,980 --> 00:15:41,690
这需要真正的设计思想，

264
00:15:41,900 --> 00:15:46,220
其中之一是，你希望操作系统要有效率。

265
00:15:46,720 --> 00:15:51,280
这通常意味着它在接近硬件的底层上运行，

266
00:15:51,640 --> 00:15:53,260
但是为了便于使用，

267
00:15:53,290 --> 00:15:56,110
而且现实生活中的人必须

268
00:15:56,380 --> 00:15:57,760
使用你的操作系统编写程序，

269
00:15:57,820 --> 00:16:02,020
所以我们希望它也是一个正确的高层次抽象。

270
00:16:02,660 --> 00:16:04,040
一个可移植的接口，

271
00:16:04,100 --> 00:16:07,910
提供简单的抽象接口需要巧妙的技巧，

272
00:16:08,320 --> 00:16:10,780
便携的但也是高效的。

273
00:16:11,910 --> 00:16:13,950
另一个矛盾是，

274
00:16:13,950 --> 00:16:18,240
我们要提供一个非常强大的操作系统服务，

275
00:16:18,240 --> 00:16:21,270
让操作系统可以承担很多责任。

276
00:16:21,680 --> 00:16:27,750
运行程序像强大的操作系统服务。

277
00:16:28,630 --> 00:16:32,960
但是，我们也希望有简单的接口。

278
00:16:34,770 --> 00:16:38,130
我们不想让程序员使用

279
00:16:38,130 --> 00:16:40,560
一个非常复杂、难以理解的接口，

280
00:16:40,560 --> 00:16:42,600
因为我也不会去理解它们，

281
00:16:42,600 --> 00:16:44,610
他们会发现它很难使用，

282
00:16:45,790 --> 00:16:48,400
所以这是一个很简单的 API ，

283
00:16:48,400 --> 00:16:53,170
所以可以提供一个简单的接口，

284
00:16:53,170 --> 00:16:56,710
并在内部拥有强大机制，

285
00:16:56,830 --> 00:16:58,210
这一直在寻找。

286
00:16:58,700 --> 00:17:04,340
简单的接口提供强大的服务，

287
00:17:04,760 --> 00:17:06,860
嘿， Robert ，有人提问。

288
00:17:07,280 --> 00:17:11,600
系统调用跳入内核有什么特别之处，

289
00:17:11,600 --> 00:17:15,230
与跳转到另一个函数的标准函数调用相比。

290
00:17:18,100 --> 00:17:23,840
好的，内核是一段始终驻留的代码，

291
00:17:23,840 --> 00:17:25,730
它具有特权，

292
00:17:25,760 --> 00:17:29,630
因为内核在机器启动时加载，

293
00:17:30,020 --> 00:17:32,600
内核具有特权，

294
00:17:32,600 --> 00:17:35,300
它可以直接访问各种硬件，

295
00:17:35,300 --> 00:17:39,020
比如磁盘，普通用户程序不能访问，

296
00:17:39,350 --> 00:17:41,780
所以如果你执行一个普通函数调用，

297
00:17:43,920 --> 00:17:46,440
你调用的函数没有，

298
00:17:46,440 --> 00:17:49,320
没有任何关于硬件的特权，

299
00:17:49,530 --> 00:17:51,510
而你在内核执行系统调用，

300
00:17:52,620 --> 00:17:54,000
后面我们会详细讨论这是如何工作的，

301
00:17:54,000 --> 00:17:57,510
这就像当系统调用跳到，

302
00:17:57,510 --> 00:17:59,340
跳到内核时，

303
00:17:59,730 --> 00:18:03,570
然后内核中的系统调用实现获得所有这些特权，

304
00:18:03,570 --> 00:18:11,470
这样它就可以修改各种敏感的受保护的硬件资源，

305
00:18:11,470 --> 00:18:14,140
比如直接访问硬盘，

306
00:18:15,730 --> 00:18:18,700
我们稍后会看到更多关于这些的细节。

307
00:18:20,330 --> 00:18:22,670
好的，我们要说的最后一个矛盾是，

308
00:18:22,670 --> 00:18:25,910
所有操作系统都需要满足你的需求，

309
00:18:25,910 --> 00:18:27,560
尽可能的灵活，

310
00:18:27,560 --> 00:18:28,760
你不想限制它们，

311
00:18:28,970 --> 00:18:33,750
所以你想要很灵活的接口。

312
00:18:33,750 --> 00:18:35,700
但是确实需要在一定程度上约束程序，

313
00:18:35,700 --> 00:18:38,430
因为你必须有一些安全概念。

314
00:18:41,770 --> 00:18:44,770
我们喜欢编程，编程很自由，

315
00:18:44,770 --> 00:18:46,630
但它不能是完全自由的，

316
00:18:46,870 --> 00:18:49,840
因为我们不想让程序直接访问硬件，

317
00:18:49,840 --> 00:18:51,490
或者干扰其他程序，

318
00:18:51,490 --> 00:18:54,220
或者在某种程度上干扰

319
00:18:54,220 --> 00:18:56,830
操作系统本身的操作。

320
00:18:57,360 --> 00:19:00,540
这就是你们需要知道的。

321
00:19:01,490 --> 00:19:02,810
做好这项工作是可能的，

322
00:19:02,810 --> 00:19:03,860
我们将对此进行大量讨论，

323
00:19:03,860 --> 00:19:05,450
但这总是令人费解，

324
00:19:05,450 --> 00:19:10,100
在这两列中同时提供这两个属性。

325
00:19:11,630 --> 00:19:14,390
另一个让操作系统设计变得困难和有趣的是，

326
00:19:14,390 --> 00:19:17,690
操作系统提供了很多功能和服务，

327
00:19:17,690 --> 00:19:19,520
但它们实际上倾向于交互，

328
00:19:19,910 --> 00:19:21,650
而且有时以奇怪的方式进行交互，

329
00:19:21,650 --> 00:19:22,760
这需要很多思考，

330
00:19:22,760 --> 00:19:25,700
即使是我给出的简单示例。

331
00:19:26,640 --> 00:19:29,190
使用 open 和 fork ，这两个交互，

332
00:19:29,190 --> 00:19:34,220
如果一个程序使用 open 系统调用分配文件描述符，

333
00:19:34,700 --> 00:19:38,640
然后使用 fork 分配相同的程序。

334
00:19:39,610 --> 00:19:42,040
fork 的语义是，

335
00:19:42,040 --> 00:19:45,580
你创建一个新进程，它是当前进程的副本，

336
00:19:45,730 --> 00:19:47,830
你打开的这个文件描述符，

337
00:19:49,640 --> 00:19:51,290
实际上是一个副本，

338
00:19:51,290 --> 00:19:55,550
这个文件描述符仍然在子进程中存在并可用,

339
00:19:57,320 --> 00:19:58,370
所以必须仔细考虑，

340
00:19:58,370 --> 00:19:59,660
这就是文件，

341
00:19:59,660 --> 00:20:02,840
打开的文件描述符以这种方式与 fork 交互，

342
00:20:03,230 --> 00:20:07,580
必须找到让子进程能读取到

343
00:20:07,960 --> 00:20:10,690
fork 调用之前创建的文件描述符，

344
00:20:10,930 --> 00:20:12,340
答案是肯定的，

345
00:20:12,580 --> 00:20:14,170
这就是我们要看的操作系统。

346
00:20:17,070 --> 00:20:18,510
好的，其他有趣的事情

347
00:20:18,510 --> 00:20:21,210
我已经提过了，

348
00:20:21,210 --> 00:20:25,080
操作系统必须满足各种各样的用途，

349
00:20:25,110 --> 00:20:30,540
同样的操作系统适用于数据库服务器和智能手机，

350
00:20:31,500 --> 00:20:35,240
而且操作系统，随着时间的推移，

351
00:20:35,270 --> 00:20:38,360
你运行的硬件，得到的硬件，

352
00:20:38,360 --> 00:20:40,130
典型的计算机会发生变化，

353
00:20:40,400 --> 00:20:44,930
可能使用超高速的固态硬盘存储替代机械硬盘。

354
00:20:45,360 --> 00:20:47,010
大概十五年前，

355
00:20:47,070 --> 00:20:52,650
多核计算机从稀有发展到无处不在，

356
00:20:54,030 --> 00:20:57,360
最近我们看到了数量级的提速，

357
00:20:57,360 --> 00:20:58,890
和网络操作速度，

358
00:20:59,190 --> 00:21:01,110
所以这些都需要重新思考。

359
00:21:01,440 --> 00:21:05,220
定期介绍操作系统是如何设计的。

360
00:21:06,510 --> 00:21:10,500
这些就是

361
00:21:10,500 --> 00:21:12,510
你可能选择这门课的原因。

362
00:21:12,510 --> 00:21:14,400
还有一些更实际的原因，

363
00:21:14,400 --> 00:21:17,460
你选择这门课的原因，

364
00:21:17,580 --> 00:21:20,730
一个是如果你对计算机内部发生的事情感兴趣，

365
00:21:20,730 --> 00:21:24,390
想知道并探寻计算机内部的秘密，

366
00:21:24,390 --> 00:21:25,650
当你打开计算机时，

367
00:21:25,710 --> 00:21:27,120
这是一个很好的课程，

368
00:21:27,510 --> 00:21:29,250
类似地，如果你喜欢基础设施，

369
00:21:29,250 --> 00:21:33,240
也就是如果你喜欢建立一种服务，

370
00:21:33,240 --> 00:21:35,910
其他程序可以使用的服务。

371
00:21:36,510 --> 00:21:38,820
当然，这基本上都是关于基础设施的，

372
00:21:38,820 --> 00:21:41,070
因为这就是操作系统。

373
00:21:42,350 --> 00:21:46,670
如果你曾经花费大量时间来跟踪应用程序代码中的 bug ，

374
00:21:46,700 --> 00:21:48,500
或跟踪安全问题，

375
00:21:48,830 --> 00:21:53,360
通常会设计到了解操作系统内部发生了什么，

376
00:21:53,450 --> 00:21:57,710
因为最终是操作系统实施了很多安全措施，

377
00:21:57,710 --> 00:22:00,020
当事情发生错误时，

378
00:22:00,020 --> 00:22:02,090
操作系统必须收拾残局，

379
00:22:02,090 --> 00:22:06,950
通常设计到跟踪 bug ，然后最终。

380
00:22:08,000 --> 00:22:09,440
在聊天中有两个问题，

381
00:22:09,440 --> 00:22:10,580
第一个是，

382
00:22:10,580 --> 00:22:12,620
对于应用程序开发人员来说，

383
00:22:12,620 --> 00:22:15,050
真正深入理解操作系统有多重要，

384
00:22:15,050 --> 00:22:16,730
对于开发应用来说，

385
00:22:17,060 --> 00:22:19,100
它们是否需要称为专家。

386
00:22:19,810 --> 00:22:21,370
你不需要成为专家，

387
00:22:21,370 --> 00:22:23,830
但是如果你花费大量时间

388
00:22:23,830 --> 00:22:26,590
开发、维护和调试应用程序，

389
00:22:26,650 --> 00:22:30,160
你最终会对操作系统有很多了解，

390
00:22:30,160 --> 00:22:32,570
无论你是有意或无意，

391
00:22:32,570 --> 00:22:37,530
它就出现了，而且你经常被迫理解它。

392
00:22:39,640 --> 00:22:41,080
第二个问题是，

393
00:22:41,080 --> 00:22:45,310
像 Python 这样的高级编程语言是否直接使用系统调用，

394
00:22:45,310 --> 00:22:48,160
是否为了方便编写了内置的包装器。

395
00:22:48,710 --> 00:22:53,360
很多高级语言在某种程度上是从操作系统中转移出来的，

396
00:22:53,540 --> 00:22:54,500
这是正确的。

397
00:22:54,500 --> 00:22:59,300
所以，部分原因是许多语言

398
00:22:59,330 --> 00:23:02,780
想要提供可移植的环境，

399
00:23:02,780 --> 00:23:04,430
可以运行在许多不同的操作系统上，

400
00:23:04,430 --> 00:23:06,230
因此它们不一定要致力于

401
00:23:06,230 --> 00:23:09,290
任何一种操作系统的特定系统调用，

402
00:23:09,980 --> 00:23:12,410
所以答案是，

403
00:23:12,410 --> 00:23:13,280
我想问题的答案是，

404
00:23:13,280 --> 00:23:14,810
如果你使用 Python ，

405
00:23:14,810 --> 00:23:18,790
你多少与系统调用接口有些隔离。

406
00:23:18,790 --> 00:23:20,530
Python 内部当然会做，

407
00:23:20,900 --> 00:23:23,360
调用系统调用来完成它的工作。

408
00:23:23,360 --> 00:23:26,380
当然，在 Python 和许多其他语言中，

409
00:23:26,380 --> 00:23:30,740
通常有一种方法可以直接进入系统调用，

410
00:23:30,740 --> 00:23:33,770
无论你使用什么操作系统。

411
00:23:35,480 --> 00:23:36,740
想提问的各位同学，

412
00:23:36,740 --> 00:23:39,050
你可以自己提问，

413
00:23:39,050 --> 00:23:40,250
不一定需要通过聊天提出问题。

414
00:23:43,410 --> 00:23:44,550
好的。

415
00:23:46,020 --> 00:23:52,300
好的，抱歉，现在我要花几分钟，

416
00:23:52,300 --> 00:24:00,130
讨论 6.S081 的课程结构，

417
00:24:01,140 --> 00:24:05,160
然后再回到技术内容部分，

418
00:24:05,430 --> 00:24:08,370
这里有一个课程的网站，

419
00:24:08,370 --> 00:24:09,870
我现在不想写出来，

420
00:24:09,870 --> 00:24:13,470
但是你可以在谷歌上搜索 6.S081 找到它。

421
00:24:14,280 --> 00:24:23,460
这个网站有一个课程表，

422
00:24:23,980 --> 00:24:28,390
课程表上有作业，还有实验作业。

423
00:24:28,740 --> 00:24:31,830
它也有关于课程结构的其他信息，

424
00:24:31,830 --> 00:24:33,570
比如课程的评分标准。

425
00:24:34,240 --> 00:24:38,920
你需要跟踪的另一个重要资源是 Piazza 。

426
00:24:39,960 --> 00:24:42,720
我想，来这里的每个人都是通过 Piazza 。

427
00:24:43,020 --> 00:24:45,600
但是还有，

428
00:24:45,960 --> 00:24:48,150
所以我们定期来做两件主要的事情，

429
00:24:48,150 --> 00:24:52,320
一是人们能够对实验作业提出问题，

430
00:24:52,320 --> 00:24:56,180
工作人员会试着回答这些问题，

431
00:24:56,180 --> 00:24:59,690
你们也可以完全自由地回答彼此的问题，

432
00:25:00,020 --> 00:25:02,270
在 Piazza 上发生的另一件事是，

433
00:25:02,270 --> 00:25:05,180
如果有课程公告，就会发布在上面，

434
00:25:05,500 --> 00:25:07,540
我们会把公告放在 Piazza 上，

435
00:25:07,540 --> 00:25:09,730
所以你应该关注 Piazza 上的公告，

436
00:25:09,730 --> 00:25:12,510
即使你不用它来寻找实验帮助。

437
00:25:13,580 --> 00:25:13,670
是的。

438
00:25:16,700 --> 00:25:20,720
课程的很大一部分就是这些课程。

439
00:25:24,150 --> 00:25:28,620
这个讲座会涉及到操作系统的基本理念。

440
00:25:28,860 --> 00:25:36,330
有些课程会详细研究 xv6 的代码，

441
00:25:36,330 --> 00:25:38,550
这是我们的小型教学操作系统，

442
00:25:39,420 --> 00:25:41,310
讨论它是如何工作的，

443
00:25:41,310 --> 00:25:44,940
我们会在课程中查看代码，演示代码执行过程，

444
00:25:45,810 --> 00:25:47,880
另外，在很多课程之前

445
00:25:47,880 --> 00:25:50,790
我们会先阅读书中的作业，

446
00:25:51,150 --> 00:25:54,090
这本书描述了 xv6 是如何运行的，

447
00:25:54,090 --> 00:25:55,950
以及为什么它是这样设计的。

448
00:25:56,670 --> 00:25:58,590
所以你应该在上课前阅读，

449
00:25:59,370 --> 00:26:01,950
这样就能听懂课程上的讨论，

450
00:26:02,400 --> 00:26:04,950
一些课程专门讲授背景知识，

451
00:26:04,950 --> 00:26:06,420
帮助你做实验。

452
00:26:06,660 --> 00:26:08,910
比如 C 语言是如何工作的，

453
00:26:08,910 --> 00:26:12,750
RISC-V ，也就是我们要使用的微处理器，

454
00:26:13,200 --> 00:26:17,610
你们会发现这对理解如何做实验很有帮助，

455
00:26:17,760 --> 00:26:19,290
在课程快结束的时候，

456
00:26:19,890 --> 00:26:24,360
我们会用一些课讨论一些操作系统论文，

457
00:26:25,080 --> 00:26:28,020
研究论文和该领域的一些经典论文，

458
00:26:28,320 --> 00:26:31,230
会要求你们在课程前阅读这些论文，

459
00:26:31,230 --> 00:26:34,410
然后我们会在课程中讨论这些论文。

460
00:26:34,980 --> 00:26:37,170
对于所有的讲座，

461
00:26:37,290 --> 00:26:40,980
我们要求你在讲座之前，

462
00:26:41,010 --> 00:26:45,090
提交一个关于所读文章的问题。

463
00:26:45,300 --> 00:26:49,040
你们中的很多人都参加了这次讲座，谢谢你们。

464
00:26:49,220 --> 00:26:51,830
我们会查看这些问题来帮助我们。

465
00:26:52,970 --> 00:26:54,800
指导我们讨论什么，

466
00:26:54,800 --> 00:26:58,040
我们会努力回答尽可能多的问题，

467
00:26:58,040 --> 00:27:01,580
尽管很少有时间，不过我们没有时间回答所有问题。

468
00:27:02,800 --> 00:27:05,830
课程的下一个重要部分是实验。

469
00:27:06,400 --> 00:27:10,900
几乎每周都有一个编程实验，

470
00:27:11,770 --> 00:27:13,000
实验的目的是，

471
00:27:13,000 --> 00:27:14,650
帮助你亲身体验

472
00:27:14,650 --> 00:27:19,620
实现和使用操作系统。

473
00:27:20,690 --> 00:27:24,170
下周到期的一个实验是，

474
00:27:24,170 --> 00:27:27,020
关于如何编写

475
00:27:27,020 --> 00:27:29,030
调用系统调用的应用程序，

476
00:27:29,030 --> 00:27:29,900
随后我们会讨论。

477
00:27:31,520 --> 00:27:34,070
与此之后的大多数实验不同，

478
00:27:34,070 --> 00:27:37,820
要么实现基本的操作系统功能，

479
00:27:37,820 --> 00:27:43,940
或想 xv6 操作系统添加内核扩展，

480
00:27:44,780 --> 00:27:46,460
最后一个实验，

481
00:27:46,460 --> 00:27:49,430
是添加一个网络栈，和网络驱动程序，

482
00:27:49,430 --> 00:27:51,500
以便能够通过网络

483
00:27:51,500 --> 00:27:53,300
连接到你运行的操作系统。

484
00:27:55,560 --> 00:27:57,990
如果你对实验有问题，

485
00:27:57,990 --> 00:28:02,810
助教会在办公时间提供帮助。

486
00:28:02,810 --> 00:28:05,990
你也可以把问题发布到 Piazza 上，

487
00:28:06,230 --> 00:28:09,170
而且通常可以从 Piazza 上获得有用的答案，

488
00:28:09,890 --> 00:28:11,810
比在办公时间更快。

489
00:28:13,060 --> 00:28:16,900
我们欢迎你讨论实验，

490
00:28:16,900 --> 00:28:20,410
讨论如何设计实验解决方案，

491
00:28:20,410 --> 00:28:23,410
但是我们要求不要看别人的解决方案。

492
00:28:23,680 --> 00:28:26,350
重复一遍，你编写的所有代码都应该是自己的，

493
00:28:26,350 --> 00:28:30,490
而且你不应该分享代码或查看其他解决方案。

494
00:28:32,740 --> 00:28:41,360
评分，当然，今年主要由实验决定的。

495
00:28:41,480 --> 00:28:49,620
所以 70% 的成绩将是根据你的实验结果，

496
00:28:49,620 --> 00:28:51,240
你提交的代码是否通过测试，

497
00:28:51,240 --> 00:28:54,840
我们评分使用我们提供的相同的测试，

498
00:28:54,840 --> 00:28:57,810
所以如果你的实验通过了我们提供的所有实验，

499
00:28:57,810 --> 00:28:59,940
你就可以得到实验的全部分数。

500
00:29:00,500 --> 00:29:06,320
20% 的分数来自实验检查会议，

501
00:29:08,030 --> 00:29:11,360
你们每个人都将随机选择几个实验，

502
00:29:11,360 --> 00:29:13,040
有一个小组将与你们交谈，

503
00:29:13,280 --> 00:29:14,990
询问你们关于实现实验的问题，

504
00:29:14,990 --> 00:29:19,330
确保你们真的理解发生了什么。

505
00:29:20,180 --> 00:29:21,920
这是实验检查。

506
00:29:23,870 --> 00:29:26,240
还剩 10% 。

507
00:29:28,040 --> 00:29:33,290
很多，比如是或否，一或零的事，

508
00:29:33,290 --> 00:29:34,160
或者他们会，

509
00:29:35,100 --> 00:29:40,080
比如答对了部分问题，

510
00:29:40,080 --> 00:29:41,490
但不是所有问题都答对了，

511
00:29:41,490 --> 00:29:44,350
当他们是这种情况时，分数是怎样的。

512
00:29:45,060 --> 00:29:46,590
你知道，我还没有想过这件事。

513
00:29:47,380 --> 00:29:50,620
当然有部分学分的情况，但是。

514
00:29:51,310 --> 00:29:53,170
它不是二选一的，

515
00:29:53,440 --> 00:29:56,110
你当然可以获得部分学分。

516
00:29:56,940 --> 00:29:57,420
好的。

517
00:29:59,470 --> 00:30:03,070
最后的 10% 是由家庭作业

518
00:30:03,070 --> 00:30:06,580
以及讲座和 Piazza 的参与决定的。

519
00:30:08,900 --> 00:30:14,260
今年不会有考试或小测验。

520
00:30:15,150 --> 00:30:17,670
所以，这意味着大部分的，

521
00:30:18,480 --> 00:30:23,160
你知道 90% 的成绩是由实验决定的。

522
00:30:23,160 --> 00:30:26,700
所以你应该花很多时间在实验上，

523
00:30:26,730 --> 00:30:29,610
确保你早点开始，

524
00:30:29,610 --> 00:30:33,870
有足够的时间完成实验，并解决 bug ，

525
00:30:33,870 --> 00:30:34,980
以获得满分。

526
00:30:37,270 --> 00:30:40,000
你知道，因此这是一门

527
00:30:40,000 --> 00:30:43,510
非常实用的面向软件的课程。

528
00:30:44,580 --> 00:30:48,530
关于课程组织，还有什么问题吗？

529
00:30:53,760 --> 00:30:56,220
在聊天中有几个问题。

530
00:30:56,670 --> 00:30:58,800
第一个是组织管理的问题，

531
00:30:58,950 --> 00:31:03,630
当前， 6.S081 没有像往常一样在系统主修课程中，

532
00:31:03,990 --> 00:31:06,180
以后有没有增加课程的计划。

533
00:31:06,180 --> 00:31:09,750
我想因为它不是批准的高级研究生课程，

534
00:31:09,750 --> 00:31:10,920
它是高级本科课程，

535
00:31:10,920 --> 00:31:13,590
它不能满足安排要求，

536
00:31:13,590 --> 00:31:15,480
所以它不是研究生水平的课程。

537
00:31:15,970 --> 00:31:23,020
但是，我们有唯一的家庭作业来提交问题，

538
00:31:23,020 --> 00:31:25,450
看看日历似乎是这样。

539
00:31:28,360 --> 00:31:32,620
除非我忘了什么，我想就是这样的。

540
00:31:35,140 --> 00:31:39,250
那么，有没有分数比例的情况，

541
00:31:39,250 --> 00:31:42,910
像是百分之 X 的人得 A ，百分之 Y 得 B 等等。

542
00:31:43,510 --> 00:31:52,740
不，不，你知道我们努力给学生自由。

543
00:31:53,320 --> 00:31:58,630
我的评价是你对材料理解得好坏，

544
00:31:59,250 --> 00:32:00,480
并在此基础上给出一个分数，

545
00:32:00,480 --> 00:32:02,880
所以不会有预先设定的比例。

546
00:32:07,950 --> 00:32:09,840
好的，还有其他问题吗？

547
00:32:13,660 --> 00:32:18,160
好的，对于聊天中

548
00:32:18,460 --> 00:32:22,600
询问主修要求的人来说，

549
00:32:22,780 --> 00:32:24,820
我不是百分之百确定，

550
00:32:24,820 --> 00:32:26,770
但 6.S081 不是，

551
00:32:26,890 --> 00:32:30,010
它是课程获得正式编号之前的一个临时编号，

552
00:32:30,010 --> 00:32:33,100
所以它不会出现在任何地方，

553
00:32:33,280 --> 00:32:35,200
如果你需要它来实现主修课程，

554
00:32:35,200 --> 00:32:37,360
我想你最好的选择是填写一份请愿书，

555
00:32:37,360 --> 00:32:40,270
或给 Katrina Kurtz 发送邮件，

556
00:32:40,780 --> 00:32:42,730
查看是什么状态，

557
00:32:43,240 --> 00:32:45,840
我们无法控制

558
00:32:45,840 --> 00:32:50,010
哪些课程满足这些要求。

559
00:32:51,240 --> 00:32:53,700
这门课将使用什么语言，将使用 C 语言。

560
00:32:58,700 --> 00:33:00,170
好的。

561
00:33:02,400 --> 00:33:03,900
好的，对于这堂课剩下的时间，

562
00:33:03,900 --> 00:33:07,050
我想谈一下，

563
00:33:07,050 --> 00:33:10,530
系统调用看起来像应用程序。

564
00:33:11,290 --> 00:33:13,660
你知道，因为系统调用

565
00:33:13,660 --> 00:33:17,860
是操作系统提供服务的接口，

566
00:33:17,860 --> 00:33:20,890
所以这些系统实际是什么样，

567
00:33:20,890 --> 00:33:24,280
应用程序从系统调用中得到什么，

568
00:33:24,280 --> 00:33:28,000
所以理解接口是什么样子是值得的。

569
00:33:29,380 --> 00:33:32,590
你将在第一个实验中使用我们谈到的系统调用，

570
00:33:32,960 --> 00:33:37,130
在后续的实验中，

571
00:33:37,160 --> 00:33:40,220
扩展和增强这些系统调用的内部实现。

572
00:33:40,960 --> 00:33:46,390
我们将演示一些程序的简单示例。

573
00:33:47,980 --> 00:33:53,680
它调用系统调用，我将在 xv6 中运行它们。

574
00:33:54,540 --> 00:33:56,370
我将运行它们，

575
00:33:56,370 --> 00:34:01,700
xv6 是一个简单的类 unix 操作系统，

576
00:34:01,700 --> 00:34:04,130
unix 是一个古老的操作系统，

577
00:34:04,130 --> 00:34:09,320
至少作为许多当前操作系统的基础，

578
00:34:09,320 --> 00:34:12,980
它使用非常广泛，

579
00:34:14,540 --> 00:34:18,920
xv6 我们的教学操作系统要简单地多，

580
00:34:19,400 --> 00:34:21,650
在某种程度上收到 unix 的启发，

581
00:34:21,650 --> 00:34:23,390
具有相同的整体结构，

582
00:34:23,390 --> 00:34:27,860
但是比任何真正的 unix 操作系统都要简单。

583
00:34:30,750 --> 00:34:32,850
它足够简单，

584
00:34:33,120 --> 00:34:36,600
你可以直接阅读

585
00:34:36,600 --> 00:34:38,460
所有的源码，

586
00:34:38,550 --> 00:34:39,840
同时阅读这本书，

587
00:34:40,080 --> 00:34:41,640
在几周时间内。

588
00:34:41,640 --> 00:34:42,780
当然在本学期，

589
00:34:42,780 --> 00:34:47,100
为了理解所有 xv6 内部发生的事情。

590
00:34:49,680 --> 00:34:54,720
xv6 运行在 RISC-V 处理器上，

591
00:34:54,870 --> 00:34:59,340
这也是最近 6.004 课程使用的微处理器。

592
00:34:59,800 --> 00:35:04,960
所以，你们中的很多人可能对 RISC-V 指令集有相当多的了解。

593
00:35:05,780 --> 00:35:10,670
理论上你可以在 RISC-V 计算机上运行 xv6 ，

594
00:35:11,510 --> 00:35:13,880
也已经有人这么做了。

595
00:35:14,560 --> 00:35:18,850
但是我们要在 QEMU 机器仿真器下运行，

596
00:35:18,910 --> 00:35:20,410
只需要把我们得到的写下来。

597
00:35:20,810 --> 00:35:23,180
我们的操作系统是 xv6 ，

598
00:35:23,570 --> 00:35:27,800
运行在 RISC-V 微处理器之上，

599
00:35:28,220 --> 00:35:30,350
不仅是 RISC-V 微处理器，

600
00:35:30,350 --> 00:35:32,870
还有周围的一些硬件，

601
00:35:32,870 --> 00:35:35,930
比如内存和磁盘。

602
00:35:36,280 --> 00:35:40,030
还有控制台界面，我们可以访问它。

603
00:35:40,740 --> 00:35:46,640
我们实际上是在 QEMU 机器模拟器下运行的。

604
00:35:48,440 --> 00:35:50,210
也是在 Linux 下运行的。

605
00:35:50,210 --> 00:35:55,860
所以你可以在没有硬件的情况下运行 xv6 。

606
00:35:56,860 --> 00:36:01,000
好的，现在切换到演示代码。

607
00:36:15,570 --> 00:36:18,720
好的，那么第一件事是，

608
00:36:18,720 --> 00:36:22,410
我已经在我的笔记本电脑上安装了 xv6 ，

609
00:36:22,800 --> 00:36:25,740
我要运行它，输入 make qemu ，

610
00:36:25,740 --> 00:36:28,140
你会在实验中发现做了更多的工作，

611
00:36:28,320 --> 00:36:30,960
它编译 xv6 ，是用 C 编写的，

612
00:36:30,960 --> 00:36:33,480
所以它使用 C 编译器编译，

613
00:36:33,990 --> 00:36:36,570
我应该先输入 make clean 清理一下，

614
00:36:36,930 --> 00:36:38,730
这样你们就可以看到实际的编译过程，

615
00:36:39,000 --> 00:36:40,620
我再输入 make qemu ，

616
00:36:40,620 --> 00:36:44,820
它开始编译和构建 xv6 内核，

617
00:36:44,820 --> 00:36:46,470
以及所有用户程序，

618
00:36:47,010 --> 00:36:49,920
然后在 QEMU 模拟器上运行。

619
00:36:51,860 --> 00:36:53,720
编译过程会花费一些时间。

620
00:36:55,020 --> 00:36:55,080
好的。

621
00:36:56,000 --> 00:36:59,090
现在我们启动并运行 xv6 ，

622
00:36:59,090 --> 00:37:01,700
你看到的 shell 中的 $ 符号，

623
00:37:02,270 --> 00:37:05,990
shell 是 xv6 的命令行界面，

624
00:37:05,990 --> 00:37:08,360
仿造 unix 上的 shell 。

625
00:37:08,360 --> 00:37:12,120
也是如果你登录到 Athena 系统，

626
00:37:12,120 --> 00:37:15,750
就像 Athena shell 显示的那样。

627
00:37:18,180 --> 00:37:23,100
xv6 本身很小，它附带了一些使用程序，

628
00:37:23,130 --> 00:37:25,960
包含比如 ls 程序，

629
00:37:25,960 --> 00:37:31,080
运行 ls ，它会给出一个所有文件的列表，

630
00:37:31,080 --> 00:37:33,300
xv6 只有二十多个文件，

631
00:37:34,020 --> 00:37:39,500
包括 grep kill mkdir 和 rm ，

632
00:37:39,560 --> 00:37:43,390
这些是我们熟悉的 unix 实用程序。

633
00:37:44,930 --> 00:37:46,640
好的，我要演示的第一个程序是，

634
00:37:46,640 --> 00:37:51,770
演示系统调用 copy ，

635
00:38:01,900 --> 00:38:03,580
这里的代码只有一页。

636
00:38:07,320 --> 00:38:12,120
你在这里看到的程序，从第 8 行开始，

637
00:38:12,120 --> 00:38:15,150
main 是 C 语言程序的一种约定，

638
00:38:15,510 --> 00:38:17,370
在第 12 行有一个循环，

639
00:38:17,940 --> 00:38:19,290
一遍又一遍地

640
00:38:19,710 --> 00:38:23,820
在第 13 行读取一些数据作为输入，

641
00:38:23,820 --> 00:38:27,900
然后在第 16 行将刚才读取的数据写入输出。

642
00:38:28,390 --> 00:38:35,550
运行 copy ，在 xv6 中，等待读取输入，

643
00:38:35,550 --> 00:38:37,320
如果我输入一些内容，

644
00:38:37,840 --> 00:38:39,970
它读取并返回给我。

645
00:38:41,640 --> 00:38:43,410
很简单的程序，只是做输入输出。

646
00:38:44,950 --> 00:38:48,880
就像我提到的，如果你不是很了解 C 语言，

647
00:38:48,880 --> 00:38:50,080
Kernighan 和 Ritchie 编写的

648
00:38:50,080 --> 00:38:54,820
C 程序设计语言很值得阅读。

649
00:38:55,180 --> 00:39:00,330
我想在课程网站上有更完整的参考资料，

650
00:39:00,840 --> 00:39:05,100
想你解释使用 C 编程的直接方法。

651
00:39:06,140 --> 00:39:09,200
是的，像我之前提到的，

652
00:39:09,200 --> 00:39:10,580
我们编写这个程序，

653
00:39:10,580 --> 00:39:13,070
使用了两个实际上是三个系统调用，

654
00:39:13,070 --> 00:39:15,950
read write exit 系统调用。

655
00:39:16,460 --> 00:39:19,790
如果你看第 13 行的 read 调用，

656
00:39:20,090 --> 00:39:21,470
它有三个参数，

657
00:39:22,500 --> 00:39:23,970
第一个参数是一个文件描述符，

658
00:39:23,970 --> 00:39:26,700
它实际上是对之前打开的文件的引用。

659
00:39:27,340 --> 00:39:32,230
shell 确保当程序启动时，

660
00:39:32,230 --> 00:39:36,860
默认它的文件描述符 0 连接到控制台输入，

661
00:39:36,860 --> 00:39:41,480
它的文件描述符 1 连接到控制台输出，

662
00:39:41,480 --> 00:39:46,620
这就是为什么我能对 copy 程序输入，并查看输出。

663
00:39:48,700 --> 00:39:52,660
你知道，这些文件描述符期望，

664
00:39:52,660 --> 00:39:55,630
程序期望这些文件描述符已经打开，

665
00:39:55,630 --> 00:39:57,160
并由 shell 为其设置。

666
00:39:57,600 --> 00:40:03,480
0 1 文件描述符是 unix 的普遍约定，

667
00:40:03,480 --> 00:40:05,220
很多 unix 程序希望

668
00:40:05,220 --> 00:40:07,440
[误：从文件描述符 1 读取]，

669
00:40:07,440 --> 00:40:11,190
读取文件描述符 0 ，并写入文件描述符 1 。

670
00:40:12,730 --> 00:40:16,540
read 的第二个参数是一个指向内存的指针。

671
00:40:17,160 --> 00:40:19,500
程序告诉操作系统

672
00:40:19,500 --> 00:40:22,710
从这个内存地址读取数据，

673
00:40:22,710 --> 00:40:23,970
这是 buf 参数，

674
00:40:24,630 --> 00:40:29,750
在第 10 行，在栈上分配了 64 字节的内存。

675
00:40:30,350 --> 00:40:31,520
供 read 读取。

676
00:40:31,700 --> 00:40:33,110
read 的第三个参数是

677
00:40:33,110 --> 00:40:36,080
程序想要读入的最大字节数，

678
00:40:36,470 --> 00:40:40,370
而 buf 的大小最大是 64 字节，

679
00:40:40,730 --> 00:40:42,830
所以 read 读取最多 64 字节，

680
00:40:42,830 --> 00:40:45,860
从文件描述符 0 连接的地方，

681
00:40:45,860 --> 00:40:48,520
在本例中， 0 就是连接到我的终端。

682
00:40:48,820 --> 00:40:54,190
read 的返回值可能是读取到的字节数，

683
00:40:54,640 --> 00:40:58,240
这里是 6 ，

684
00:40:58,240 --> 00:40:59,740
我输入 xyzzy 。

685
00:41:01,150 --> 00:41:02,800
read 也可以从文件中读取，

686
00:41:02,830 --> 00:41:04,090
如果到达文件末尾，

687
00:41:04,090 --> 00:41:05,110
没有更多字节，

688
00:41:05,110 --> 00:41:06,370
read 将返回 0 。

689
00:41:07,160 --> 00:41:08,900
如果发生其他错误，

690
00:41:08,900 --> 00:41:11,180
比如文件描述符不存在，

691
00:41:11,420 --> 00:41:13,160
read 可能会返回 -1 。

692
00:41:13,780 --> 00:41:17,560
在很多例子中，比如在第 16 行。

693
00:41:17,940 --> 00:41:23,190
我的示例代码没有检查系统调用返回是否有错误，

694
00:41:24,540 --> 00:41:27,540
但是你应该比我更小心，

695
00:41:27,540 --> 00:41:30,750
你应该弄清楚系统调用是如何返回错误的，

696
00:41:30,750 --> 00:41:32,640
通常是返回 -1 ，

697
00:41:32,970 --> 00:41:36,360
并检查所有系统调用的返回是否有错误。

698
00:41:37,280 --> 00:41:41,360
如果你想知道系统调用参数和返回值是什么，

699
00:41:41,360 --> 00:41:44,210
这里有一个表格，我想是在书中的第 2 章。

700
00:41:45,140 --> 00:41:51,810
解释了所有 xv6 系统调用参数和返回值。

701
00:41:52,770 --> 00:41:55,230
关于 read 系统调用的问题。

702
00:41:55,440 --> 00:41:57,870
如果我们将最大读取字节数

703
00:41:57,870 --> 00:42:01,200
设置为 buf 大小加 1 ，

704
00:42:01,500 --> 00:42:03,030
所以如果我们尝试读取的大小超过该大小会怎样。

705
00:42:03,030 --> 00:42:06,870
是的，如果有 65 个字节要读取，

706
00:42:06,900 --> 00:42:09,330
操作系统会很高兴地

707
00:42:09,330 --> 00:42:14,750
把这 65 个字节复制到你提供的内存上，

708
00:42:14,780 --> 00:42:18,020
当然还有栈上的其他东西，

709
00:42:18,050 --> 00:42:20,150
可能是返回程序计数器，

710
00:42:20,150 --> 00:42:21,410
或者参数或其他东西，

711
00:42:21,560 --> 00:42:23,570
所以如果你传入 65 个字节，

712
00:42:23,930 --> 00:42:25,460
那么你就是让内核

713
00:42:25,460 --> 00:42:29,550
在栈上意想不到的位置写入垃圾数据。

714
00:42:30,280 --> 00:42:31,360
因此，这是一个 bug ，

715
00:42:31,840 --> 00:42:33,940
它可能会导致你的程序崩溃。

716
00:42:34,420 --> 00:42:36,340
或者做一些其他意想不到的事情，

717
00:42:37,390 --> 00:42:39,580
因此作为一个程序员，在这里必须小心，

718
00:42:39,580 --> 00:42:42,940
没有人使用 C 语言这样使用接口，

719
00:42:43,830 --> 00:42:46,890
很容易编写的代码，

720
00:42:46,920 --> 00:42:49,200
编译器可以通过，并且可以运行，

721
00:42:49,200 --> 00:42:51,000
但是做的是错误的事。

722
00:42:51,660 --> 00:42:57,120
那太糟糕了，但事情就是这样。

723
00:43:00,540 --> 00:43:02,490
好的，有一件事需要注意，

724
00:43:02,490 --> 00:43:06,450
这里的 copy 程序和 read write 系统调用，

725
00:43:06,720 --> 00:43:08,460
它们不关心数据的格式，

726
00:43:08,460 --> 00:43:09,480
它们读写，

727
00:43:09,660 --> 00:43:13,440
只是在 copy 程序中读写，再读写。

728
00:43:13,980 --> 00:43:17,340
只是处理八位字节，使用八位字节流。

729
00:43:17,680 --> 00:43:21,220
如何解释它们，完全取决于应用程序。

730
00:43:21,220 --> 00:43:26,840
应用程序可能会解析数据记录作为 C 代码，

731
00:43:26,840 --> 00:43:27,680
或者其他的格式。

732
00:43:28,890 --> 00:43:35,460
操作系统只知道这是八位字节流。

733
00:43:36,220 --> 00:43:39,940
好的，所以 copy 可以假设

734
00:43:39,940 --> 00:43:42,670
文件描述符已经设置好，

735
00:43:42,850 --> 00:43:46,000
但是我们需要有一种方法来创建文件描述符。

736
00:43:46,280 --> 00:43:51,680
创建文件描述符的最直接的方法是使用 open 系统调用，

737
00:43:51,710 --> 00:43:55,160
这是一个调用 open 的程序代码，

738
00:43:55,720 --> 00:43:56,920
那个，

739
00:43:58,120 --> 00:43:59,770
我使用 open 系统调用。

740
00:44:00,250 --> 00:44:01,570
聊天中有一个问题，

741
00:44:01,600 --> 00:44:04,570
你说的字节流是什么意思。

742
00:44:07,190 --> 00:44:11,840
我的意思是如果一个文件包含一些字节，

743
00:44:12,180 --> 00:44:16,470
然后读取连续一百万字节的内容，

744
00:44:16,860 --> 00:44:19,200
如果你进行连续的 read 调用，

745
00:44:19,200 --> 00:44:20,670
每次 100 字节，

746
00:44:21,160 --> 00:44:22,900
你知道，只会读取第一个 100 字节，

747
00:44:22,900 --> 00:44:24,100
然后是第二个 100 字节，

748
00:44:24,100 --> 00:44:25,810
然后是第三个 100 字节。

749
00:44:27,960 --> 00:44:28,590
就是这样。

750
00:44:32,000 --> 00:44:36,020
好的，那么这个程序调用 open ，我来运行它，

751
00:44:36,720 --> 00:44:41,940
它所做的是创建一个名为 output.txt 的新文件，

752
00:44:41,940 --> 00:44:43,980
然后向其中写入一些字节，

753
00:44:44,520 --> 00:44:45,690
我已经完成了这个操作，

754
00:44:45,690 --> 00:44:46,620
但是我们看不到任何东西，

755
00:44:46,620 --> 00:44:48,690
因为它将数据放到了这个文件中，

756
00:44:48,690 --> 00:44:53,100
但是我们可以查看它创建的 output.txt 文件，

757
00:44:53,490 --> 00:44:57,240
可以看到 ooo 写在那里。

758
00:44:57,390 --> 00:45:02,020
程序中的第 11 行调用了 open 系统调用，

759
00:45:02,380 --> 00:45:04,750
给它一个文件名 output.txt ，

760
00:45:04,750 --> 00:45:10,240
open 中第二个参数中的 O_ 选项或标志，

761
00:45:10,240 --> 00:45:13,930
告诉内核中实现的 open 系统调用，

762
00:45:13,930 --> 00:45:17,590
我们想要使用这个名字创建一个文件，并且写入。

763
00:45:18,860 --> 00:45:21,710
open 返回新分配的文件描述符。

764
00:45:23,740 --> 00:45:25,600
文件描述符只是一个很小的数字，

765
00:45:25,810 --> 00:45:27,400
可能是 2 3 或 4 等。

766
00:45:28,430 --> 00:45:32,270
然后我们将相同的文件描述符与缓冲区一起传递，

767
00:45:32,270 --> 00:45:36,410
有多种方式写入数据，

768
00:45:37,040 --> 00:45:39,770
对于文件描述符索引用的文件。

769
00:45:41,430 --> 00:45:43,860
文件描述符实际上做的是

770
00:45:43,860 --> 00:45:49,410
索引到内核中一个维护进程状态的表中，

771
00:45:49,410 --> 00:45:52,620
就是你运行的每个程序，

772
00:45:52,620 --> 00:45:56,010
内核为每个进程记住一张表，

773
00:45:56,010 --> 00:45:58,500
（表中）通过文件描述符进行索引，

774
00:45:58,830 --> 00:46:03,420
这张表告诉内核每个文件描述符引用的是什么。

775
00:46:05,040 --> 00:46:10,960
好的，关键点是每个进程

776
00:46:10,960 --> 00:46:14,350
都有自己的文件描述符空间。

777
00:46:14,350 --> 00:46:17,420
因此，在运行两个不同的进程前，

778
00:46:17,420 --> 00:46:19,460
两个不同的程序，

779
00:46:19,640 --> 00:46:20,990
它们都会打开一个文件，

780
00:46:20,990 --> 00:46:24,080
它们可能会得到相同的文件描述符编号，

781
00:46:24,350 --> 00:46:28,700
但是因为内核为每个进程维护单独的文件描述符，

782
00:46:29,080 --> 00:46:31,750
所以相同的文件描述符号

783
00:46:31,750 --> 00:46:34,570
在不同的进程中可能引用不同的文件。

784
00:46:37,040 --> 00:46:39,350
关于 open 程序，有什么问题吗？

785
00:46:40,240 --> 00:46:41,620
在聊天中有一个问题，

786
00:46:41,620 --> 00:46:43,720
一个不熟悉 C 语言的人提出的问题，

787
00:46:43,990 --> 00:46:47,830
这些文件和普通的 C 程序有什么不同，

788
00:46:47,830 --> 00:46:50,470
是不是因为我们只使用内核调用，

789
00:46:50,470 --> 00:46:53,710
也就是说，我们能不能用 python 打开或写入文件。

790
00:46:59,440 --> 00:47:00,820
我想我不明白的是，

791
00:47:02,000 --> 00:47:04,160
它是一个 C 程序，打开或写入一个文件。

792
00:47:15,620 --> 00:47:17,750
然后继续下去。

793
00:47:20,640 --> 00:47:26,310
好的，你可能问的是。

794
00:47:26,310 --> 00:47:27,570
也许问题是，

795
00:47:27,570 --> 00:47:30,120
当使用 C 语言做这件事，

796
00:47:30,120 --> 00:47:33,090
除了语法，与使用 python 有什么不同。

797
00:47:34,240 --> 00:47:37,810
它不是。

798
00:47:38,620 --> 00:47:42,840
当然也有办法。

799
00:47:44,410 --> 00:47:49,480
Python 提供了良好的函数调用，打开文件或做这些事。

800
00:47:50,830 --> 00:47:54,040
打开文件，比如读写文件，

801
00:47:54,310 --> 00:47:58,540
通常有一个层级比较高的函数，

802
00:47:58,870 --> 00:48:01,660
比如，没有指向内存的指针。

803
00:48:03,690 --> 00:48:06,420
Python 也为你提供了更多的错误检查，

804
00:48:07,140 --> 00:48:09,840
但是当你在 python 中打开文件，

805
00:48:09,840 --> 00:48:11,010
或在 python 中写文件，

806
00:48:11,010 --> 00:48:17,840
python 调用底层的系统调用。

807
00:48:19,840 --> 00:48:21,220
这个答案怎么样。

808
00:48:25,860 --> 00:48:26,520
我想是的。

809
00:48:27,030 --> 00:48:27,420
好的。

810
00:48:30,980 --> 00:48:32,270
好的。

811
00:48:33,560 --> 00:48:36,350
我在这里讨论，

812
00:48:39,120 --> 00:48:43,140
xv6 是 unix ，比如 shell ，

813
00:48:43,440 --> 00:48:46,500
shell 人们也经常称作命令行接口，

814
00:48:46,890 --> 00:48:50,610
相对更图形化的用户界面。

815
00:48:51,240 --> 00:48:53,370
shell 是，

816
00:48:53,370 --> 00:48:54,450
如果你没有用过 shell ，

817
00:48:54,450 --> 00:48:57,450
shell 是一个非常有用的界面，

818
00:48:57,450 --> 00:49:00,270
对于 unix 系统的系统管理，

819
00:49:01,440 --> 00:49:02,940
他提供了很多实用程序，

820
00:49:02,940 --> 00:49:06,480
来处理文件，开发程序，

821
00:49:06,480 --> 00:49:09,510
以及编写脚本来完成这些事。

822
00:49:09,510 --> 00:49:12,030
所以在继续之前。

823
00:49:12,550 --> 00:49:14,620
我想演示几个 shell 功能，

824
00:49:14,650 --> 00:49:17,290
当你输入东西的时候，

825
00:49:17,770 --> 00:49:20,080
你在高数 shell 运行一个程序，

826
00:49:20,080 --> 00:49:21,100
所以当我输入 ls ，

827
00:49:21,100 --> 00:49:26,790
我的意思是要求 shell 运行名为 ls 的程序，

828
00:49:26,790 --> 00:49:28,290
这真正的含义是

829
00:49:28,290 --> 00:49:31,710
在文件系统中，有一个叫做 ls 的文件

830
00:49:31,710 --> 00:49:34,890
它包含一些指令，一些机器指令，

831
00:49:35,250 --> 00:49:40,170
我要求 shell 运行 ls 文件中的这些指令，

832
00:49:40,770 --> 00:49:44,430
现在 ls 真正做的是，

833
00:49:44,940 --> 00:49:47,220
获取当前目录中的文件列表，

834
00:49:47,250 --> 00:49:49,230
你可以在上面的第 4 行看到，

835
00:49:49,620 --> 00:49:54,420
同其他文件一起， ls 也是存在的。

836
00:49:54,420 --> 00:49:55,380
这个列表，

837
00:49:55,380 --> 00:49:57,660
一个叫做 ls 的文件，

838
00:49:58,140 --> 00:50:00,120
实际上它包含了我刚才运行的指令。

839
00:50:02,370 --> 00:50:05,340
除了运行程序， shell 还为你做了其他事情，

840
00:50:06,360 --> 00:50:08,160
还允许你重定向 IO ，

841
00:50:08,490 --> 00:50:11,040
比如，如果我输入 ls > out ，

842
00:50:11,100 --> 00:50:14,670
意思是要求 shell 运行 ls 命令，

843
00:50:15,030 --> 00:50:17,940
但将其输入重定向到名为 out 的文件。

844
00:50:18,520 --> 00:50:22,130
我运行 ls ，我们看不到任何输出，

845
00:50:22,340 --> 00:50:23,840
因为输出都重定向了。

846
00:50:24,960 --> 00:50:28,380
现在 out 包含一些数据，

847
00:50:28,530 --> 00:50:30,090
我们可以，

848
00:50:30,900 --> 00:50:35,430
cat 命令读取文件并显示其中的内容，

849
00:50:35,430 --> 00:50:36,720
我输入 cat out 。

850
00:50:37,190 --> 00:50:40,790
可以看到这和 ls 的输出是一样的。

851
00:50:41,170 --> 00:50:42,790
你也可以运行命令 grep ，

852
00:50:42,790 --> 00:50:46,060
我给它一个参数 x ， grep x 。

853
00:50:46,520 --> 00:50:48,440
grep 命令通过模式搜索。

854
00:50:49,080 --> 00:50:52,830
同样的，如果我运行 grep x ，

855
00:50:52,830 --> 00:50:57,050
它会搜索包含 x 的输入行，

856
00:50:57,380 --> 00:50:58,250
我也可以重定向，

857
00:50:58,250 --> 00:51:01,190
告诉 shell 把 grep 的输入重定向到 out 文件。

858
00:51:01,700 --> 00:51:05,720
用来查找保存 ls 结果中的 x 实例。

859
00:51:07,150 --> 00:51:11,920
结果是这里有三个文件包含 x 。

860
00:51:14,000 --> 00:51:14,630
嗯。

861
00:51:15,560 --> 00:51:17,420
我们花一些时间在 shell 上，

862
00:51:17,450 --> 00:51:26,540
shell 是 unix 的一种最传统和最基本的接口，

863
00:51:26,540 --> 00:51:28,250
因为在 unix 最初开发的时候，

864
00:51:28,250 --> 00:51:30,860
所有的都是简单的终端接口。

865
00:51:30,860 --> 00:51:32,540
比如我们现在使用的，

866
00:51:32,540 --> 00:51:36,290
unix 最初的主要用途是分时共享，

867
00:51:36,290 --> 00:51:38,510
许多人同时登录到一台机器上，

868
00:51:38,540 --> 00:51:41,780
很像 Athena ，使用 shell 交互。

869
00:51:43,300 --> 00:51:47,650
有一个关于系统调用和编译器的问题，

870
00:51:47,860 --> 00:51:49,750
编译器如何处理系统调用，

871
00:51:49,750 --> 00:51:52,030
是由汇编语言

872
00:51:52,030 --> 00:51:55,210
对操作系统定义的一些代码段做过程调用吗？

873
00:51:57,020 --> 00:51:59,780
有一个特殊的 RISC-V 指令，

874
00:51:59,780 --> 00:52:02,750
程序可以调用它将控制权转到到内核，

875
00:52:02,840 --> 00:52:06,350
所以当你编写 C 代码，调用系统调用，

876
00:52:06,350 --> 00:52:08,060
比如 open write ，

877
00:52:08,600 --> 00:52:14,150
实际上是 open 是 C 库中的一个 C 函数，

878
00:52:14,620 --> 00:52:19,630
但是这个函数中的指令实际上是机器指令，

879
00:52:19,630 --> 00:52:24,280
它不是 open ， open 函数不是一个 C 函数，

880
00:52:24,490 --> 00:52:25,720
而是由汇编语言实现，

881
00:52:25,960 --> 00:52:30,980
在 RISC-V 中，汇编语言的

882
00:52:30,980 --> 00:52:35,010
这个特殊指令叫做 ecall ，

883
00:52:35,010 --> 00:52:38,450
这个特殊指令转移控制权到内核中，

884
00:52:38,900 --> 00:52:42,290
然后内核查看进程内存和寄存器，

885
00:52:42,290 --> 00:52:44,890
找出参数是什么。

886
00:52:50,610 --> 00:52:56,850
好的，下一个例子，我想看的程序是 fork 。

887
00:52:58,420 --> 00:53:04,690
创建进程，这是很简单的 fork 的应用，

888
00:53:04,690 --> 00:53:06,940
在第 12 行，我们调用了 fork ，

889
00:53:06,940 --> 00:53:08,170
fork 所做的是，

890
00:53:08,670 --> 00:53:14,490
创建一个调用进程的指令和数据的内存的复制，

891
00:53:14,490 --> 00:53:17,430
现在我们有两个使用相同内存的进程。

892
00:53:18,010 --> 00:53:21,760
fork 系统调用在两个进程中都会返回，

893
00:53:22,360 --> 00:53:23,920
在原始进程中，

894
00:53:24,430 --> 00:53:27,130
fork 返回进程 id ，

895
00:53:27,130 --> 00:53:30,640
它是一个大于零的整数，

896
00:53:32,100 --> 00:53:36,240
原始进程中， fock 返回的是新创建进程的进程 id ，

897
00:53:36,750 --> 00:53:40,590
而在新进程中， fock 返回 0 。

898
00:53:41,630 --> 00:53:44,660
所以即使两个进程有相同的内存，

899
00:53:45,230 --> 00:53:47,270
你也可以通过

900
00:53:47,720 --> 00:53:50,570
fork 的返回值区分它们。

901
00:53:50,940 --> 00:53:54,660
在第 16 行，你可以看到代码检查并判断，

902
00:53:54,660 --> 00:53:57,150
如果进程 id 等于 0 ，就是子进程，

903
00:53:57,180 --> 00:53:58,710
肯定是在子进程中运行。

904
00:53:59,420 --> 00:54:01,640
当然这里有两个进程，

905
00:54:01,640 --> 00:54:04,670
在另一个进程，调用进程中，

906
00:54:04,670 --> 00:54:08,240
称为父进程，返回的进程 id 大于 0 。

907
00:54:08,640 --> 00:54:13,230
所以子进程会输出 child ，而父进程会输出 parent 。

908
00:54:14,350 --> 00:54:16,480
然后它们都会退出。

909
00:54:16,810 --> 00:54:17,890
我运行 fork ，

910
00:54:19,380 --> 00:54:24,300
我们可以得到，它看起来像是乱码。

911
00:54:25,230 --> 00:54:26,310
实际发生的是，

912
00:54:26,310 --> 00:54:29,190
在调用 fork 之后，两个进程都会运行，

913
00:54:29,220 --> 00:54:30,900
它们同时运行，

914
00:54:31,080 --> 00:54:36,890
QEMU 为我真正模拟了多核微处理器，

915
00:54:36,890 --> 00:54:40,280
所以实际上它们是几乎是同时运行的，

916
00:54:40,280 --> 00:54:41,450
所以当它们产生输出时，

917
00:54:41,850 --> 00:54:43,620
它们产生每个字节，

918
00:54:43,620 --> 00:54:45,390
与另一个进程一起，

919
00:54:45,390 --> 00:54:47,220
产生输出对应的字节，

920
00:54:47,670 --> 00:54:51,690
所以两个进程的输出是交错的。

921
00:54:52,260 --> 00:54:54,330
你可以看到它们都会输出 f ，

922
00:54:54,800 --> 00:54:57,050
它们都会从 fork 返回。

923
00:54:57,800 --> 00:54:59,720
所以你可以看到两个 f ，

924
00:54:59,720 --> 00:55:02,180
两个 o ，两个 r ，等等。

925
00:55:02,920 --> 00:55:03,790
其中之一，

926
00:55:04,700 --> 00:55:07,460
你可以看到第一行末尾的 0 ，

927
00:55:07,880 --> 00:55:09,740
子进程会返回 0 。

928
00:55:10,100 --> 00:55:14,480
我猜父进程应该返回 19 ，

929
00:55:14,960 --> 00:55:17,510
这是子进程的进程 id 19 ，

930
00:55:17,810 --> 00:55:20,510
在 xv6 中，意味着是系统启动以来

931
00:55:20,510 --> 00:55:22,250
创建的第 19 个进程。

932
00:55:22,860 --> 00:55:25,500
其中之一，输出 child ，

933
00:55:25,890 --> 00:55:27,870
你可以看到 c h i l d ，

934
00:55:27,870 --> 00:55:30,120
与另一个交互显示，另一个输出 parent 。

935
00:55:30,670 --> 00:55:34,520
是的，这是 fork 的一种愚蠢的用法，

936
00:55:34,550 --> 00:55:37,310
但是我们可以在这个输出中清楚地看到，

937
00:55:37,310 --> 00:55:39,290
它创建了两个进程。

938
00:55:39,920 --> 00:55:42,110
并且它们都在运行，

939
00:55:42,110 --> 00:55:43,520
返回的两个进程都在运行，

940
00:55:44,710 --> 00:55:47,410
但要注意的是一个输出 child ，另一个输出 parent ，

941
00:55:48,490 --> 00:55:53,150
这很重要， fork 返回的两个进程不同。

942
00:55:59,680 --> 00:56:01,390
有一个提问，

943
00:56:01,390 --> 00:56:05,290
fork 返回的子进程总是和父进程一样，

944
00:56:05,290 --> 00:56:06,400
它们会不一样吗？

945
00:56:08,250 --> 00:56:13,260
在 xv6 中，是一样的，

946
00:56:13,740 --> 00:56:16,830
除了 fork 的返回值。

947
00:56:17,260 --> 00:56:18,880
你知道指令是相同的，

948
00:56:18,880 --> 00:56:21,850
数据是相同的，栈也是相同的，

949
00:56:22,090 --> 00:56:27,560
两个进程

950
00:56:27,560 --> 00:56:31,210
都有自己不同的地址空间，

951
00:56:31,210 --> 00:56:35,530
它们都认为自己的内存从 0 开始，

952
00:56:35,530 --> 00:56:36,820
并向上增长，

953
00:56:37,400 --> 00:56:43,600
但是其实是不同的内存。

954
00:56:45,030 --> 00:56:46,680
在一个更复杂的操作系统中，

955
00:56:46,680 --> 00:56:51,030
有一些细节，我们并不关心，

956
00:56:51,060 --> 00:56:54,180
它们可能偶尔导致父进程与子进程不同，

957
00:56:54,210 --> 00:56:56,580
但在 xv6 中，除了返回值，都是相同的。

958
00:56:57,880 --> 00:56:59,410
所以内存是相同的，

959
00:56:59,410 --> 00:57:04,530
另外，文件描述符表是复制的。

960
00:57:05,260 --> 00:57:08,680
所以，如果父进程打开一些文件，

961
00:57:09,140 --> 00:57:13,220
子进程也会看到一组相同的文件描述符。

962
00:57:13,800 --> 00:57:15,840
虽然子进程看到的是

963
00:57:15,840 --> 00:57:19,640
复制的文件描述符信息表。

964
00:57:21,550 --> 00:57:23,710
我们随后会看到，这是很重要的，

965
00:57:23,710 --> 00:57:29,140
fork 复制打开的文件描述符表和内存。

966
00:57:31,340 --> 00:57:34,980
好的， fork 创建一个新进程，

967
00:57:34,980 --> 00:57:38,250
当我们在 shell 中运行东西时，

968
00:57:39,030 --> 00:57:42,960
shell 实际上创建了一个新进程来运行你输入的命令。

969
00:57:43,320 --> 00:57:45,120
但它需要在其中运行命令，

970
00:57:45,330 --> 00:57:46,890
所以如果我输入 ls ，

971
00:57:47,160 --> 00:57:50,790
我们需要 shell fork 创建一个新进程运行 ls ，

972
00:57:50,790 --> 00:57:55,360
但是这个新进程需要一些方法，

973
00:57:55,360 --> 00:57:57,910
来实际运行 ls 程序中的指令。

974
00:57:58,510 --> 00:58:00,970
这些命令下面是 ls ，

975
00:58:02,320 --> 00:58:04,690
我马上给你们演示一下示例程序。

976
00:58:05,320 --> 00:58:06,310
使用 echo ，

977
00:58:06,310 --> 00:58:08,860
echo 是一个很简单的命令，

978
00:58:09,070 --> 00:58:11,080
只是获取你传递的参数，

979
00:58:11,080 --> 00:58:12,580
然后把它们写到它的输出中。

980
00:58:13,860 --> 00:58:16,470
我准备了一个程序，叫做 exec 。

981
00:58:22,880 --> 00:58:28,390
它运行，它调用 exec 系统调用，

982
00:58:28,390 --> 00:58:32,350
使用你指定的文件中

983
00:58:32,350 --> 00:58:35,440
读取的指令替换调用的进程。

984
00:58:37,110 --> 00:58:39,210
从文件中加载指令，

985
00:58:39,240 --> 00:58:42,720
覆盖当前进程，丢弃当前内存，

986
00:58:42,990 --> 00:58:45,600
然后执行这些指令，

987
00:58:45,600 --> 00:58:49,500
所以 exec 系统调用， exec 在第 12 行，

988
00:58:52,620 --> 00:58:53,880
它的效果是，

989
00:58:53,940 --> 00:58:57,600
操作系统从 echo 文件中加载指令。

990
00:58:57,980 --> 00:59:02,360
在当前进程中，替换当前进程的内存，

991
00:59:02,690 --> 00:59:06,340
然后开始执行那些指令，

992
00:59:06,340 --> 00:59:09,550
并且，你可以传递参数，

993
00:59:09,550 --> 00:59:13,960
echo exec 允许你传递一组命令行参数。

994
00:59:14,670 --> 00:59:16,620
它只是 C 语言中的一组指针，

995
00:59:17,040 --> 00:59:20,860
第 10 行设置了一组字符指针，

996
00:59:20,860 --> 00:59:22,180
本质上就是字符串，

997
00:59:22,600 --> 00:59:24,580
并且将该数组初始化为，

998
00:59:25,040 --> 00:59:29,120
包含字符串 echo this is echo 。

999
00:59:29,480 --> 00:59:32,360
这相当于从命令行运行 echo ，

1000
00:59:32,360 --> 00:59:34,170
使用这三个参数。

1001
00:59:34,170 --> 00:59:34,920
这是 echo 。

1002
00:59:35,340 --> 00:59:41,980
当我运行 exec ，实际上，我看到这个输出 this is echo ，

1003
00:59:41,980 --> 00:59:45,670
即使我运行 exec 命令，

1004
00:59:45,980 --> 00:59:49,370
exec 程序说做的是调用 exec 系统调用，

1005
00:59:49,490 --> 00:59:50,900
将其自身替换为 echo ，

1006
00:59:51,080 --> 00:59:52,880
所以它实际上就是 echo 程序，

1007
00:59:53,320 --> 00:59:55,000
产生这个输出。

1008
00:59:58,600 --> 01:00:02,920
关于 exec 系统调用，有一点很重要，

1009
01:00:03,280 --> 01:00:08,170
exec 保留了当前文件描述符表，

1010
01:00:08,380 --> 01:00:12,940
所以 exec 之前引用的文件描述符 0 1 2 等，

1011
01:00:13,240 --> 01:00:17,170
它们在新程序中也引用相同的东西。

1012
01:00:17,670 --> 01:00:18,990
我们已经加载了新程序的指令。

1013
01:00:20,220 --> 01:00:23,370
另一点是，原始的 exec 不会返回，

1014
01:00:23,610 --> 01:00:28,440
因为 exec 完全替换了当前进程内存，

1015
01:00:28,530 --> 01:00:30,540
没有什么东西让 exec 返回，

1016
01:00:30,540 --> 01:00:32,340
对于 exec ，

1017
01:00:32,990 --> 01:00:35,240
读取文件中的指令，并执行它们，

1018
01:00:35,240 --> 01:00:36,020
就是这样，

1019
01:00:36,410 --> 01:00:38,240
exec 唯一返回的情况是，

1020
01:00:38,240 --> 01:00:40,160
如果发生了一些错误，

1021
01:00:40,400 --> 01:00:43,610
导致操作系统无法为你运行该程序，

1022
01:00:43,940 --> 01:00:46,820
比如，如果程序根本不存在，

1023
01:00:48,080 --> 01:00:50,450
exec 找不到名为 echo 的文件，

1024
01:00:50,540 --> 01:00:53,390
exec 将会返回 -1 ，

1025
01:00:55,520 --> 01:00:58,160
表示出了一些错误，

1026
01:00:58,160 --> 01:00:59,390
它找不到那个文件，

1027
01:00:59,390 --> 01:01:01,220
通常 exec 不会返回，

1028
01:01:01,520 --> 01:01:06,600
它只在内核不能运行文件时返回。

1029
01:01:10,430 --> 01:01:11,360
关于 exec ，有什么问题？

1030
01:01:12,620 --> 01:01:13,640
聊天中的问题是，

1031
01:01:13,640 --> 01:01:16,070
argv 中的最后一个 0 是什么作用？

1032
01:01:18,850 --> 01:01:20,980
它表示数组的结尾，

1033
01:01:21,940 --> 01:01:24,010
C 是低级别语言，

1034
01:01:24,010 --> 01:01:30,490
它没有数组语法，

1035
01:01:32,340 --> 01:01:37,470
对于代码，没有方法找出数组的长度，

1036
01:01:37,500 --> 01:01:39,030
所以告诉内核，

1037
01:01:40,970 --> 01:01:45,140
你知道，数组包含 echo this is echo ，没有其他东西，

1038
01:01:46,560 --> 01:01:50,750
我们把 0 放到最后作为最后一个指针，

1039
01:01:50,990 --> 01:01:53,000
每个在双引号中的字符串实际上是

1040
01:01:53,000 --> 01:01:56,210
一个指向内存中包含这些直接的指针，

1041
01:01:56,720 --> 01:02:00,950
数组中的第五个元素指向零值，

1042
01:02:01,310 --> 01:02:03,770
惯例是值为零的指针

1043
01:02:03,770 --> 01:02:05,180
或所谓的空指针。

1044
01:02:07,050 --> 01:02:10,620
它表示空。

1045
01:02:11,620 --> 01:02:16,570
所以内核中的代码遍历这个数组，

1046
01:02:16,570 --> 01:02:19,920
直到找到值为零的元素。

1047
01:02:24,690 --> 01:02:27,420
好的，

1048
01:02:27,420 --> 01:02:29,490
这就是一个程序如何替换自己，

1049
01:02:30,800 --> 01:02:32,090
使用文件中的另一个程序，

1050
01:02:32,090 --> 01:02:33,800
但实际上我们在 shell 中运行东西，

1051
01:02:33,800 --> 01:02:37,940
比如 echo abc ，或者 ls 或其他，

1052
01:02:38,900 --> 01:02:41,180
我们不希望替换掉 shell ，我们没有，

1053
01:02:41,180 --> 01:02:42,710
shell 只是调用 exec ，

1054
01:02:43,420 --> 01:02:46,630
因为，那样 echo 会替换掉 shell ，

1055
01:02:46,630 --> 01:02:49,160
然后 echo 退出，就全部结束了，

1056
01:02:49,700 --> 01:02:52,040
你知道，我们不想用 echo 来替代 shell ，

1057
01:02:52,040 --> 01:02:54,170
所以 shell 要做的是 fork ，

1058
01:02:54,940 --> 01:02:56,620
然后子进程调用 exec ，

1059
01:02:56,740 --> 01:03:01,180
这是一个很常见的 unix 惯用程序。

1060
01:03:01,600 --> 01:03:04,660
想要运行一个程序，并重新获得控制权，

1061
01:03:04,690 --> 01:03:07,570
要做的就是调用 fork ，再让子进程调用 exec 。

1062
01:03:08,000 --> 01:03:12,050
这里有一个简单的例子， forkexec 程序。

1063
01:03:14,310 --> 01:03:17,550
在这个程序中，在第 12 行调用 fork ，

1064
01:03:17,580 --> 01:03:20,940
在子程序的第 14 行，调用 exec 。

1065
01:03:21,120 --> 01:03:27,700
对于子进程，必须使用 echo 命令替换它自己。

1066
01:03:28,220 --> 01:03:30,890
echo 做完这件事，并退出。

1067
01:03:31,680 --> 01:03:33,720
对于父进程，重新获得了控制权，

1068
01:03:33,720 --> 01:03:39,860
因为当 fork 返回时，在父进程中返回一个大于零的值，

1069
01:03:39,860 --> 01:03:42,440
所以父进程继续执行第十九行，

1070
01:03:42,650 --> 01:03:45,380
unix 也提供了一个 wait 系统调用，

1071
01:03:45,380 --> 01:03:50,720
第 20 行，进程等待 fork 创建的子进程，

1072
01:03:51,080 --> 01:03:55,280
因为当我在命令行上运行一条命令，

1073
01:03:56,330 --> 01:04:01,190
我们希望 shell 等待命令结束，

1074
01:04:01,400 --> 01:04:03,170
在它重新输出提示符之前，

1075
01:04:03,200 --> 01:04:06,050
在它输出 $ 符号等待我输入更多之前。

1076
01:04:06,730 --> 01:04:08,260
wait 系统调用运行进程

1077
01:04:08,890 --> 01:04:11,950
等待它的任何子进程返回，

1078
01:04:12,280 --> 01:04:19,330
这个状态参数是退出子进程的一种方式，

1079
01:04:19,390 --> 01:04:24,190
将一个 32 位整数

1080
01:04:24,400 --> 01:04:27,340
从退出的子进程传递给等待的父进程，

1081
01:04:27,340 --> 01:04:31,450
在第 17 行，退出参数是 1 。

1082
01:04:32,060 --> 01:04:35,540
操作系统将 1

1083
01:04:35,570 --> 01:04:39,650
从退出的子进程传递给第 20 行的 wait ，

1084
01:04:39,650 --> 01:04:43,570
所以 &wait[应该是 &status]

1085
01:04:43,570 --> 01:04:46,720
将状态变量地址传递给内核，

1086
01:04:46,720 --> 01:04:51,520
内核使用子进程的退出参数填充该地址。

1087
01:04:52,770 --> 01:04:54,060
unix 中的约定是，

1088
01:04:54,060 --> 01:04:59,850
如果一个程序成功退出，退出码是零，

1089
01:05:00,430 --> 01:05:03,940
但是它在第 17 行遇到一个问题，

1090
01:05:04,280 --> 01:05:07,970
unix 约定这里应该退出码应该是 1 ，

1091
01:05:08,420 --> 01:05:10,580
如果你关心调用进程的退出状态，

1092
01:05:10,580 --> 01:05:12,260
可以查看使用 wait 查看其状态，

1093
01:05:13,240 --> 01:05:17,280
确定子进程是否成功。

1094
01:05:18,420 --> 01:05:20,130
Morris 教授，我有一个问题。

1095
01:05:20,560 --> 01:05:20,950
好的。

1096
01:05:21,280 --> 01:05:25,090
exec 调用在第 15 行，

1097
01:05:25,090 --> 01:05:26,740
之前我们提到过，

1098
01:05:26,740 --> 01:05:30,370
exec 会完全被 echo 程序替换，

1099
01:05:30,400 --> 01:05:32,440
而不会返回到 forkexec 。

1100
01:05:33,060 --> 01:05:36,930
所以会运行到第十六、十七行吗？

1101
01:05:38,170 --> 01:05:41,190
好的，对于这个 exec 代码不合适，

1102
01:05:41,190 --> 01:05:43,650
因为有一个名为 echo 的程序，

1103
01:05:44,130 --> 01:05:46,560
但是如果我在这里修改代码，

1104
01:05:46,560 --> 01:05:48,420
让我修改一下代码。

1105
01:05:49,470 --> 01:05:51,450
好的，那么首先我来运行一下 forkexec ，

1106
01:05:53,590 --> 01:05:56,740
它实际上使用这些参数执行 echo ，

1107
01:05:56,740 --> 01:05:58,390
我们可以看到输出 this is echo ，

1108
01:05:58,660 --> 01:06:04,700
我们看到子进程退出表示 echo 成功退出，

1109
01:06:05,000 --> 01:06:06,110
而父进程等待。

1110
01:06:06,440 --> 01:06:08,720
让我修改一下代码，

1111
01:06:09,630 --> 01:06:13,320
替换 echo ，而是运行一个不存在的命令。

1112
01:06:15,360 --> 01:06:20,860
我们先使用 Ctrl-a x 退出 QEMU ，

1113
01:06:20,860 --> 01:06:25,120
然后重建所有的东西，重新编译我修改过的程序。

1114
01:06:25,850 --> 01:06:29,180
再次运行 forkexec ，

1115
01:06:29,800 --> 01:06:31,990
这次，因为我们要执行的程序。

1116
01:06:32,760 --> 01:06:39,240
实际上，我们要执行的程序并不存在，

1117
01:06:39,600 --> 01:06:43,230
exec 返回了我们希望它返回的失败的输出，

1118
01:06:43,840 --> 01:06:45,760
返回 1 ，

1119
01:06:45,850 --> 01:06:48,370
你会看到那里的 1 被传回给父进程，

1120
01:06:48,370 --> 01:06:50,440
表示子进程退出的状态是 1 。

1121
01:06:52,280 --> 01:06:57,260
所以，当出现错误时， exec 返回到调用函数。

1122
01:06:57,740 --> 01:06:58,190
好的。

1123
01:07:08,700 --> 01:07:09,570
好的。

1124
01:07:14,680 --> 01:07:17,980
好的，这里需要注意的是，

1125
01:07:17,980 --> 01:07:20,500
我想你们中许多人已经注意到了。

1126
01:07:20,500 --> 01:07:23,430
这是一个常见的习惯用法，

1127
01:07:23,430 --> 01:07:26,100
fork 后面跟着子进程里的 exec ，

1128
01:07:26,580 --> 01:07:31,890
fork 复制整个父进程可能有点浪费，

1129
01:07:32,320 --> 01:07:35,470
因为 exec 会丢弃所有复制的内存，

1130
01:07:35,770 --> 01:07:40,990
并将其替换为你运行的文件的内容，

1131
01:07:40,990 --> 01:07:44,320
所以如果你担心这种情况，

1132
01:07:44,320 --> 01:07:47,290
fork 得到的复制，

1133
01:07:48,160 --> 01:07:50,110
在某种意义上大部分是浪费的，

1134
01:07:50,110 --> 01:07:54,010
因为所有复制的内存都被丢弃并被 exec 替换，

1135
01:07:55,270 --> 01:07:57,940
这种情况对于大程序更明显，

1136
01:07:57,940 --> 01:08:00,610
如果你有个几 GB 的程序调用 fork ，

1137
01:08:01,050 --> 01:08:03,240
它确实复制了所有的内存，

1138
01:08:03,240 --> 01:08:07,260
可能复制只需要不到一秒钟的时间，

1139
01:08:07,740 --> 01:08:09,240
不过这也是个问题。

1140
01:08:12,520 --> 01:08:14,710
但是在本课程的后面，

1141
01:08:14,710 --> 01:08:17,320
你将实现一些优化，

1142
01:08:17,320 --> 01:08:19,810
特别是写入时复制（copy on write） fork ，

1143
01:08:20,080 --> 01:08:26,560
会消除 fork 中几乎所有明显低效的复制，

1144
01:08:26,560 --> 01:08:28,870
只是使用 exec 丢弃复制。

1145
01:08:29,180 --> 01:08:32,390
它使用了一系列涉及到虚拟内存系统的技巧。

1146
01:08:32,920 --> 01:08:36,700
你可以创建一个 fork ，让它懒复制，

1147
01:08:36,730 --> 01:08:40,960
如果 fork 后面跟着 exec ，则不用复制，

1148
01:08:41,420 --> 01:08:43,310
或者你实际上不需要复制，

1149
01:08:43,310 --> 01:08:45,770
因为子进程不会使用复制的内存。

1150
01:08:48,100 --> 01:08:50,410
我想你会发现那是一个有趣的实验。

1151
01:08:51,040 --> 01:08:52,180
聊天中有一个问题，

1152
01:08:52,510 --> 01:08:54,970
为什么父进程

1153
01:08:54,970 --> 01:08:57,820
在子进程调用 exec 之前等待。

1154
01:08:59,240 --> 01:09:02,720
嗯，这只是偶然情况。

1155
01:09:06,940 --> 01:09:09,880
为什么，你知道观察结果是，

1156
01:09:09,970 --> 01:09:11,680
你知道，

1157
01:09:13,130 --> 01:09:17,540
父进程输出可能和子进程输出相交错，

1158
01:09:17,540 --> 01:09:20,990
在我们之前看到的相同区域，使用相同的 fork 示例，

1159
01:09:21,410 --> 01:09:23,420
它只是发生，

1160
01:09:23,630 --> 01:09:25,700
并没有保证这就是输出，

1161
01:09:25,700 --> 01:09:27,260
我们会看到实际上，

1162
01:09:27,260 --> 01:09:29,390
我们不会感到惊讶，

1163
01:09:29,390 --> 01:09:32,960
即使看到输出是以另一种顺序，或另一种交错，

1164
01:09:33,620 --> 01:09:38,990
我怀疑这是怎么回事，这需要一点时间和努力。

1165
01:09:39,770 --> 01:09:41,750
exec 系统造成了一些开销，

1166
01:09:41,750 --> 01:09:43,730
因为它必须加载所有的（指令），

1167
01:09:43,790 --> 01:09:46,730
需要访问文件系统和磁盘，

1168
01:09:46,730 --> 01:09:50,780
将名为 echo 的文件内容从磁盘读取到内存中，

1169
01:09:51,050 --> 01:09:53,180
在分配内存，

1170
01:09:53,180 --> 01:09:55,850
然后释放旧进程内存之后，

1171
01:09:55,850 --> 01:10:00,230
所以 exec 系统调用中有很多机器指令，

1172
01:10:00,860 --> 01:10:03,350
显然，这需要足够长的时间，

1173
01:10:03,350 --> 01:10:06,230
父进程才能完成输出，

1174
01:10:06,580 --> 01:10:09,400
在 exec 完成，开始运行 echo 之前。

1175
01:10:10,400 --> 01:10:11,240
这个解释可以吗？

1176
01:10:15,360 --> 01:10:16,290
另一个问题是，

1177
01:10:16,290 --> 01:10:19,260
有没有一种协定子进程可以等待父进程？

1178
01:10:21,520 --> 01:10:26,770
unix 中没有这种方法，

1179
01:10:28,220 --> 01:10:30,860
没有直接的方法，让子进程可以等待父进程。

1180
01:10:31,930 --> 01:10:33,520
wait 系统调用，

1181
01:10:34,680 --> 01:10:37,380
因为这是唯一可用的机制，

1182
01:10:37,620 --> 01:10:41,130
wait 系统调用会等待值进程。

1183
01:10:41,880 --> 01:10:42,420
就是这样。

1184
01:10:43,620 --> 01:10:45,990
所以 wait 说做的是，

1185
01:10:46,350 --> 01:10:48,720
如果你有子进程的话，

1186
01:10:49,080 --> 01:10:53,970
其中之一退出，就会返回，

1187
01:10:54,330 --> 01:10:55,800
但是如果你没有任何子进程，

1188
01:10:55,800 --> 01:10:56,970
因为你。

1189
01:10:57,360 --> 01:11:00,450
因为在这种简单的情况下，

1190
01:11:02,120 --> 01:11:02,930
只有父进程，

1191
01:11:02,930 --> 01:11:05,360
如果子进程调用 wait ，

1192
01:11:06,890 --> 01:11:08,330
子进程没有任何子进程，

1193
01:11:08,600 --> 01:11:09,200
在这种情况下，

1194
01:11:09,200 --> 01:11:12,500
wait 会直接返回 -1 错误，

1195
01:11:12,500 --> 01:11:14,450
表示这个进程没有任何子进程。

1196
01:11:15,440 --> 01:11:16,940
无论怎样，简短的回答是，

1197
01:11:16,940 --> 01:11:20,180
没有一种方法让子进程等待父进程退出。

1198
01:11:21,930 --> 01:11:22,770
另一个问题是，

1199
01:11:22,770 --> 01:11:26,820
当我们说子进程复制了父进程的所有内存，

1200
01:11:26,820 --> 01:11:29,310
我们到底指什么。

1201
01:11:29,340 --> 01:11:32,970
我想子进程会再次定义变量。

1202
01:11:39,050 --> 01:11:40,250
当你编译这个，

1203
01:11:40,250 --> 01:11:46,790
你知道，在编译之后，

1204
01:11:47,060 --> 01:11:51,020
你的 C 程序只是内存中的一些指令，

1205
01:11:51,470 --> 01:11:52,460
驻留在内存中。

1206
01:11:55,070 --> 01:11:56,720
所以那些是可以复制的。

1207
01:11:57,360 --> 01:11:58,920
因为它们只是内存中的一些字节，

1208
01:11:58,920 --> 01:12:01,740
它们可以复制到其他地方。

1209
01:12:02,370 --> 01:12:04,530
并且使用适当的技巧，

1210
01:12:04,530 --> 01:12:08,840
设置虚拟内存映射，

1211
01:12:08,930 --> 01:12:12,020
使子进程和父进程映射看起来一样，

1212
01:12:12,020 --> 01:12:15,050
你可以复制父进程的内存到子进程，

1213
01:12:15,080 --> 01:12:17,440
然后执行子进程。

1214
01:12:20,660 --> 01:12:22,310
即使我们看到的是 C 程序，

1215
01:12:22,310 --> 01:12:25,610
你也应该把它们看作一些机器指令，

1216
01:12:26,920 --> 01:12:29,200
就是一些内存的字节，可以复制。

1217
01:12:31,280 --> 01:12:33,440
如果一个父进程有多个子进程，

1218
01:12:33,440 --> 01:12:36,230
如果只是等待第一个子进程退出，

1219
01:12:36,230 --> 01:12:38,300
意味着父进程和未完成的子进程

1220
01:12:38,300 --> 01:12:40,040
会有更多交错，

1221
01:12:40,310 --> 01:12:43,820
所以，需要方法来保证所有子进程完成。

1222
01:12:44,340 --> 01:12:47,250
是的，如果你调用 fork 超过一次，

1223
01:12:47,250 --> 01:12:50,700
如果进程调用 fork 两次,

1224
01:12:51,360 --> 01:12:54,810
那么它需要等待所有子进程，

1225
01:12:54,810 --> 01:12:56,760
必须调用 wait 两次，

1226
01:12:56,850 --> 01:13:01,490
每次调用 wait 都会在一个子进程退出时返回，

1227
01:13:01,490 --> 01:13:05,870
当 wait 返回时，你不需要知道是哪个子进程退出，

1228
01:13:06,170 --> 01:13:09,770
wait 会返回子进程的进程 id ，

1229
01:13:09,770 --> 01:13:12,650
所以在 wait 返回后，你可以区分，

1230
01:13:12,860 --> 01:13:14,450
哪一个子进程退出了。

1231
01:13:22,660 --> 01:13:24,610
最后一个例子，

1232
01:13:25,640 --> 01:13:27,170
我想演示一下，

1233
01:13:28,080 --> 01:13:37,460
这些系统调用如何结合在一起实现 IO 重定向，

1234
01:13:37,460 --> 01:13:38,810
你记得，

1235
01:13:38,960 --> 01:13:41,900
shell 为我们提供了方便的语法，

1236
01:13:42,350 --> 01:13:44,180
我可以输入 echo hello > out ，

1237
01:13:44,830 --> 01:13:48,310
这运行 echo 命令和传递给它的参数。

1238
01:13:48,800 --> 01:13:52,670
首先，发送它的输出到 out 文件，我们查看一下。

1239
01:13:53,120 --> 01:13:54,170
或者，

1240
01:13:55,340 --> 01:14:00,620
使用 cat ，用 out 文件作为它的输入，

1241
01:14:01,250 --> 01:14:03,620
我们可以看到它保存了 echo 命令的输出。

1242
01:14:04,980 --> 01:14:11,630
shell 这种设置方式，像下面这样。

1243
01:14:15,320 --> 01:14:20,060
shell 首先 fork ，像第 13 行这样，

1244
01:14:20,150 --> 01:14:23,810
然后在子进程中， shell 修改了

1245
01:14:23,810 --> 01:14:25,520
文件描述符的设置，

1246
01:14:25,520 --> 01:14:28,280
让子进程的文件描述符 1 ，

1247
01:14:28,280 --> 01:14:32,860
按照惯例，大多数程序使用 1 作为输出。

1248
01:14:33,470 --> 01:14:37,430
shell 将子进程的文件描述符 1

1249
01:14:37,430 --> 01:14:40,040
修改为指向输出文件，

1250
01:14:40,430 --> 01:14:42,530
然后可以执行你需要的命令，

1251
01:14:42,590 --> 01:14:47,060
同时保留了父进程 shell 的文件描述符 1 不变，

1252
01:14:47,510 --> 01:14:49,520
这种 fork 的惯用方法，

1253
01:14:49,520 --> 01:14:53,090
在子进程中修改文件描述符，

1254
01:14:53,360 --> 01:14:55,280
是 unix 中一种常用方法，

1255
01:14:55,280 --> 01:14:59,770
重定向你运行的命令的输入、输出，

1256
01:14:59,770 --> 01:15:04,300
但是不影响调用程序的输入、输出，

1257
01:15:04,300 --> 01:15:06,370
因为我们不想重定向 shell 的输出。

1258
01:15:07,150 --> 01:15:11,500
我们只想重定向子进程的输出。

1259
01:15:12,670 --> 01:15:15,490
不管怎样，这种方式是我们调用 fork 的常用方式，

1260
01:15:15,730 --> 01:15:18,370
第 15 行只会在子进程中执行。

1261
01:15:18,860 --> 01:15:21,410
在第 15 行关闭 1 的原因是，

1262
01:15:21,410 --> 01:15:26,530
我们只是对 echo 命令的输出重定向，

1263
01:15:26,530 --> 01:15:28,000
所以当我运行 redirect ，

1264
01:15:28,640 --> 01:15:31,520
程序本身不会产生输出，

1265
01:15:31,520 --> 01:15:35,060
它运行 echo 并把它的输入定向到 output.txt 文件。

1266
01:15:35,540 --> 01:15:39,440
所以当我查看 output.txt ，

1267
01:15:39,770 --> 01:15:41,330
我看到了预期的输出，

1268
01:15:41,750 --> 01:15:43,880
在第 15 行关闭 1 的原因是，

1269
01:15:44,900 --> 01:15:49,160
我们想把输出文件描述符 1

1270
01:15:49,160 --> 01:15:51,560
指向别的东西，

1271
01:15:52,010 --> 01:15:54,650
而我们不想，我们有子进程，

1272
01:15:54,650 --> 01:15:56,690
不想使用父进程的文件描述符 1 ，

1273
01:15:56,690 --> 01:15:58,790
shell 使用它连接控制台,

1274
01:15:59,660 --> 01:16:03,320
第 16 行的 open 调用一定返回 1 ，

1275
01:16:03,320 --> 01:16:07,070
因为 open 的语义是返回

1276
01:16:07,070 --> 01:16:09,490
没有被当前进程使用的

1277
01:16:09,490 --> 01:16:13,450
最小的文件描述符编号，

1278
01:16:13,480 --> 01:16:14,950
而我们刚关闭了 1 。

1279
01:16:15,420 --> 01:16:19,590
并且文件描述符 0 仍然连接到控制台，

1280
01:16:19,590 --> 01:16:20,010
我的意思是，

1281
01:16:20,460 --> 01:16:23,160
open 一定会返回 1 。

1282
01:16:24,290 --> 01:16:29,060
所以在第 16 行之后，文件描述符 1 连接到这个文件。

1283
01:16:30,220 --> 01:16:31,300
我们只是执行 echo ，

1284
01:16:31,300 --> 01:16:33,970
echo 输出到文件描述符 1 ，

1285
01:16:34,330 --> 01:16:35,710
就会写入到这个文件中，

1286
01:16:35,740 --> 01:16:38,380
最酷的是， echo 并不知道发生了什么，

1287
01:16:38,800 --> 01:16:41,620
echo 完全不需要知道 IO 重定向，

1288
01:16:41,650 --> 01:16:44,080
它只是输出到文件描述符 1 。

1289
01:16:45,160 --> 01:16:50,350
只有 shell 知道 IO 重定向。

1290
01:16:52,380 --> 01:16:56,720
这个例子也展示了

1291
01:16:57,110 --> 01:17:00,110
fork 和 exec 之间的巧妙分离，

1292
01:17:00,110 --> 01:17:03,440
fork 和 exec 是分开的系统调用，

1293
01:17:04,220 --> 01:17:06,700
分开的函数

1294
01:17:08,130 --> 01:17:10,440
意味着在子进程在有一段时间，

1295
01:17:10,440 --> 01:17:13,570
在它们之间，从子进程返回，

1296
01:17:13,630 --> 01:17:17,860
我们仍然在运行调用程序指令，

1297
01:17:17,860 --> 01:17:19,810
调用进程，

1298
01:17:20,160 --> 01:17:23,310
即使这些指令在子进程运行，

1299
01:17:23,610 --> 01:17:26,580
也是调用进程指令在运行，

1300
01:17:27,000 --> 01:17:31,260
所以调用进程仍然能够改变事情，

1301
01:17:31,320 --> 01:17:33,660
仍然在控制中直到第 19 行。

1302
01:17:34,380 --> 01:17:36,420
这种在 fork 和 exec 之间的间隔，

1303
01:17:36,780 --> 01:17:38,310
给了 shell 修改，

1304
01:17:38,580 --> 01:17:41,520
比如，修改文件描述符的机会。

1305
01:17:43,180 --> 01:17:45,880
对 redirect 示例，有什么问题吗？

1306
01:17:55,220 --> 01:17:59,000
好的，时间快到了。

1307
01:18:00,410 --> 01:18:01,430
总结一下，

1308
01:18:01,430 --> 01:18:02,300
我们看了 unix ，

1309
01:18:02,300 --> 01:18:08,630
有许多接口， IO ，进程抽象。

1310
01:18:09,230 --> 01:18:10,730
这里的事情，

1311
01:18:10,730 --> 01:18:12,770
接口相对简单，

1312
01:18:12,800 --> 01:18:14,630
只是传递一个整数，

1313
01:18:14,630 --> 01:18:16,490
比如文件描述符和进程 id ，

1314
01:18:16,490 --> 01:18:20,450
作为系统调用的参数传递。

1315
01:18:20,820 --> 01:18:26,440
但是，接口内部函数是相当复杂的，

1316
01:18:26,440 --> 01:18:30,210
比如创建进程，复制进程，

1317
01:18:30,600 --> 01:18:32,820
此外，我还展示了一些例子，

1318
01:18:32,820 --> 01:18:38,340
单独的抽象如何合并在一起使用，

1319
01:18:38,550 --> 01:18:41,850
比如，产生 IO 重定向。

1320
01:18:44,030 --> 01:18:46,100
有一个下周末到期的实验，

1321
01:18:46,970 --> 01:18:50,150
那个实验涉及到编写更多简单使用程序，

1322
01:18:50,150 --> 01:18:52,880
就像我在讨论中展示的那样。

1323
01:18:54,140 --> 01:18:55,370
所以，祝你在实验玩得开心，

1324
01:18:55,400 --> 01:18:57,620
下周上课再见。

1325
01:19:01,520 --> 01:19:02,180
就是这些。

1326
01:19:08,480 --> 01:19:08,780
谢谢。

1327
01:19:15,170 --> 01:19:16,550
既然我是录视频的人，

1328
01:19:16,670 --> 01:19:18,110
我该怎么结束这个呢，

1329
01:19:18,680 --> 01:19:20,210
第一次在课程中录制。

1330
01:19:20,600 --> 01:19:21,710
它们会自己退出。

1331
01:19:22,520 --> 01:19:25,310
我不用做什么操作，退出，它就会保存到一些地方。

1332
01:19:26,220 --> 01:19:27,270
是的。

1333
01:19:27,300 --> 01:19:27,720
太棒了。

1334
01:19:32,010 --> 01:19:36,470
我想会创建一些文件夹并把文件放到里面。

1335
01:19:38,600 --> 01:19:40,640
这节课之后有办公时间，是吗。

1336
01:19:41,930 --> 01:19:42,410
是的。

1337
01:19:42,860 --> 01:19:43,310
完美。

1338
01:19:45,200 --> 01:19:45,710
太酷了。

1339
01:19:50,340 --> 01:19:50,820
好的。

1340
01:19:51,580 --> 01:19:51,970
好的。

1341
01:19:52,450 --> 01:19:54,430
谢谢，下周见，

1342
01:19:54,640 --> 01:19:55,060
谢谢。

