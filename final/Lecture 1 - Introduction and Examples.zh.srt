1
00:00:01,900 --> 00:00:02,590
好的，
Alright,

2
00:00:04,270 --> 00:00:08,140
欢迎学习 6.S081 操作系统，
welcome to 6.S081 operating systems,

3
00:00:08,770 --> 00:00:11,980
我是 Robert ，将和 Frans 一起执教，
I'm Robert I'll be Co lecturing with Frans

4
00:00:12,280 --> 00:00:15,250
David 和 Nicolass 作为助教。
and David and Nicolass of the TAs.

5
00:00:16,450 --> 00:00:18,850
在 zoom 讲座的的时候，
So, please during the zoom lecturers,

6
00:00:18,850 --> 00:00:19,690
随时可以提问，
ask questions,

7
00:00:19,690 --> 00:00:21,970
你可以讲话打断我，
you can either interrupt me by audio

8
00:00:21,970 --> 00:00:25,390
或者在聊天窗口中输入一些东西。
or enter something into the chat window,

9
00:00:25,840 --> 00:00:28,450
我们会有一名工作人员查看并替你提问。
one of the staff will see and ask questions for you.

10
00:00:29,900 --> 00:00:32,120
顺便说一下，我们会录下这些讲座，
By the way, we'll be recording these lectures

11
00:00:32,120 --> 00:00:33,680
然后把录像开放出来，
and then we'll post recordings later,

12
00:00:33,680 --> 00:00:35,180
这样你们可以复习，
so you can review them

13
00:00:35,180 --> 00:00:37,580
或者对于来不了的人
or for people who can't make this time

14
00:00:38,000 --> 00:00:39,620
他们仍然可以看到讲座。
so they can nevertheless see lectures.

15
00:00:40,710 --> 00:00:45,690
好的，首先我想列出一些课程目标，
Alright, I want to start by laying out some of the goals of the course,

16
00:00:45,720 --> 00:00:48,910
第一个目标是，
So, number one is to,

17
00:00:49,330 --> 00:00:55,270
理解操作系统的设计和实现。
understand the design and implementation of operating systems.

18
00:00:56,310 --> 00:01:01,210
是的，设计是一种高层次的结构，
Yeah, design is sort of high level structure

19
00:01:01,210 --> 00:01:04,510
而实现是实际中代码真正的样子，
and implementation is really about what the code looks like,

20
00:01:04,600 --> 00:01:06,490
我们将做这两个方面花费大量的时间。
and we'll be spending a lot of time with both.

21
00:01:07,940 --> 00:01:13,400
为了更深入地理解这是怎么运行的，
And in the interest of getting deep understanding of what's going on,

22
00:01:13,640 --> 00:01:23,130
你经通过一个小型操作系统获得实践经验，
you'll get hands-on experience with a small, a small operating system,

23
00:01:23,130 --> 00:01:24,720
就是我们的 xv6 操作系统。
the xv6 operating system.

24
00:01:25,320 --> 00:01:30,270
而且除了查看现有的操作系统，
And in addition to actually looking at an existing operating system,

25
00:01:30,270 --> 00:01:34,590
你还可以从实验中获得一下经验，
you'll be in the labs get a bunch of experience,

26
00:01:34,590 --> 00:01:38,010
扩展操作系统，改进操作系统，
extending the operating system modifying improving its behavior

27
00:01:38,100 --> 00:01:43,740
编写使用操作系统接口的系统软件，
and writing system software that it uses the operating system interfaces,

28
00:01:43,740 --> 00:01:44,790
在运行应用程序时。
[if it works an application].

29
00:01:46,520 --> 00:01:50,420
所以，这是你们在课程中要做的，
So, this is what you're going to be doing in the course.

30
00:01:52,980 --> 00:01:56,580
在课程中，我们对操作系统
We're also interested in what the purpose of the operating system

31
00:01:56,580 --> 00:01:58,500
本身的作用也很感兴趣。
itself is as well as the course.

32
00:02:00,980 --> 00:02:04,790
所以，我有一系列的东西，
So for that, I have a sort of list of a couple of things

33
00:02:04,790 --> 00:02:08,630
你知道，有很多操作系统，
which you know there's lots of operating system,

34
00:02:08,630 --> 00:02:10,310
不同的操作系统，
different operating systems out there,

35
00:02:10,550 --> 00:02:13,550
它们通常有一个共同的目标。
they typically have a common set of purposes.

36
00:02:15,150 --> 00:02:19,800
其中之一就是对硬件的抽象，
One of them is to abstract the hardware,

37
00:02:21,520 --> 00:02:26,170
通常从买一台计算机开始，
that is what you're given typically as a starting point is you buy a computer,

38
00:02:26,170 --> 00:02:27,700
计算机包括 CPU 和内存，
a computer has a CPU and memory,

39
00:02:27,760 --> 00:02:29,590
但这是一个非常低的层级。
but that's a very low level.

40
00:02:29,940 --> 00:02:31,740
一系列的资源，
A set of resources,

41
00:02:31,770 --> 00:02:35,910
拥有更高级别的接口和抽象是非常棒的，
it's fantastic to have a much higher level interfaces and abstractions

42
00:02:35,910 --> 00:02:37,350
应用程序可以使用它们，
that applications can use,

43
00:02:37,980 --> 00:02:43,470
比如为了方便和可移植性而产生的进程或文件系统。
such as processes or file systems both for convenience and for portability.

44
00:02:44,360 --> 00:02:48,050
操作系统的另一个非常重要的目标是
Another very important task of an operating system is

45
00:02:48,050 --> 00:02:51,870
在许多应用程序中复用硬件。
to multiplex the hardware among many applications.

46
00:02:52,360 --> 00:02:56,470
你可能运行文本编辑器，编译器，
You might be running a text editor, and a compiler,

47
00:02:56,470 --> 00:03:01,010
或者多个不同的数据库服务器，
or maybe a multiple different database servers

48
00:03:01,010 --> 00:03:02,360
或者其他什么东西，
or something on your operating system,

49
00:03:02,420 --> 00:03:04,940
能够使用操作系统
it's fantastic to be able to have the operating system

50
00:03:04,940 --> 00:03:06,530
同时运行它们是很棒的，
run both of them at the same time

51
00:03:06,530 --> 00:03:10,040
而且所有同时运行的事情不会相互干扰。
or all the things are going on at the same time without having them interfere.

52
00:03:11,420 --> 00:03:13,010
这通常叫做多路复用，
That's often called multiplexing,

53
00:03:13,970 --> 00:03:16,280
因为操作系统上
because there may be a lot of things

54
00:03:16,280 --> 00:03:18,260
可能同时发生很多事情，
happening in the operating system at the same time,

55
00:03:18,260 --> 00:03:21,620
它们必须不会相互干扰，
it's critical that they not interfere unintentionally,

56
00:03:21,770 --> 00:03:23,330
即使有 bug 存在，
even if they have bugs

57
00:03:23,360 --> 00:03:26,510
这也就是所谓的隔离性。
and that's a task is called isolation.

58
00:03:27,120 --> 00:03:32,900
它的主要思想是，不同的活动不应该互相干涉，
The idea that, different activities should not be allowed to interfere,

59
00:03:33,050 --> 00:03:33,620
另一方面，
on the other hand,

60
00:03:33,620 --> 00:03:37,070
不同的活动可以需要干涉，
there are times when different activities would like to interfere,

61
00:03:37,070 --> 00:03:38,840
需要干涉来交互或协作，
would like to interact or cooperate,

62
00:03:38,870 --> 00:03:42,110
比如，如果我使用编辑器创建了一个文件，
so for example if I create a file with a text editor,

63
00:03:42,230 --> 00:03:44,480
我希望编译器可以读取该文件，
and I'd like my compiler to read the file

64
00:03:44,990 --> 00:03:47,390
我们肯定希望允许这样的的共享。
and we definitely want to allow that kind of sharing.

65
00:03:47,860 --> 00:03:53,390
所有我们希望这种用户想要的共享。
So we wanna allow sharing [], sort of what the user has in mind.

66
00:03:55,670 --> 00:03:59,180
但是在很多情况下，用户不想分享，
But in many circumstances, the user doesn't want sharing,

67
00:03:59,180 --> 00:04:02,210
可能你登录到类似 Athena 的分时服务器，
maybe you're logged into a time sharing machine like Athena,

68
00:04:02,300 --> 00:04:05,000
你肯定不希望别人读取你的文件，
and you don't want other people to read your files,

69
00:04:05,000 --> 00:04:06,890
所以我们需要，想分享的的时候分享，
so we also need as well sharing we want to,

70
00:04:06,920 --> 00:04:09,380
不想分享的时候不分享。
not share when we don't want to.

71
00:04:09,760 --> 00:04:12,850
我们可以称其为安全系统或权限系统，
Which we could call security or a permission system,

72
00:04:13,210 --> 00:04:14,500
即一个访问控制系统。
an access control system.

73
00:04:16,650 --> 00:04:19,230
人们看中操作系统的另一个原因是，
Another thing that people value in operating systems is

74
00:04:19,320 --> 00:04:21,840
如果你为一台计算机的硬件上花了很多钱，
if you spend a lot of money on the hardware on a computer,

75
00:04:21,870 --> 00:04:23,820
你希望应用程序能够获得
you'd like your application to be able to get

76
00:04:23,880 --> 00:04:28,680
硬件提供的全部性能。
a sort of full performance that a hardware ought to be able to provide.

77
00:04:28,800 --> 00:04:33,740
而且，很多都是应用编程。
And, a lot of that is just application programming.

78
00:04:34,010 --> 00:04:36,830
但是，不可避免的，
But, inevitably, unfortunately, some of it is

79
00:04:36,830 --> 00:04:38,840
操作系统必须确保
the operating system has to make sure that

80
00:04:38,900 --> 00:04:42,410
它提供的任何服务
whatever services it provides

81
00:04:42,470 --> 00:04:46,010
都不会阻碍应用程序获得高性能，
don't get in the way of applications getting high performance,

82
00:04:46,250 --> 00:04:48,290
所以你希望至少不要阻碍，
so you want to at least not get in the way

83
00:04:48,290 --> 00:04:52,700
甚至可以帮助应用程序获得良好的性能。
and maybe even help applications achieve good performance.

84
00:04:55,880 --> 00:05:00,320
最后，大多数操作系统
Finally, with most operating systems

85
00:05:00,890 --> 00:05:03,170
必须支持很多不同的应用程序，
have to support a wide range of different applications,

86
00:05:03,170 --> 00:05:05,990
可能是笔记本电脑运行编辑器，
maybe it's a laptop running a text editor,

87
00:05:05,990 --> 00:05:07,550
可能是运行游戏，
maybe it's running games,

88
00:05:07,610 --> 00:05:09,410
也可能操作系统需要支持
maybe your operating system needs to

89
00:05:09,410 --> 00:05:12,740
数据库服务或云计算，
support database servers or cloud computation,

90
00:05:12,860 --> 00:05:17,960
通常因为操作系统的设计和构建成本很高，
and usually because operating systems are quite expensive to design and build,

91
00:05:18,620 --> 00:05:21,710
所以人们使用相同的操作系统来执行许多不同的任务，
people use the same operating systems for many different tasks,

92
00:05:21,710 --> 00:05:22,250
比如 Linux ，
like Linux,

93
00:05:22,250 --> 00:05:24,950
我相信大多数人都运行一个（操作系统），
for example which I'm sure many of you are running a,

94
00:05:24,950 --> 00:05:27,050
在我提到的所有情况下，
is used in all of the situations I mentioned,

95
00:05:27,050 --> 00:05:29,480
所以相同的操作系统必须能够支持，
so the same operating system really has to be able to support

96
00:05:29,630 --> 00:05:33,950
一系列非常不同的用途。
a range of often quite different uses.

97
00:05:36,830 --> 00:05:38,840
所以我们希望能够，
So we're hoping to be able to support

98
00:05:39,590 --> 00:05:42,470
同时支持所有这些不同的目标。
sort of all these different goals simultaneously.

99
00:05:44,000 --> 00:05:46,520
我们将在课程中听到更多关于这些的信息。
And we'll hear more about all of them during the course.

100
00:05:47,810 --> 00:05:49,760
好的，对于操作系统，
Alright, operating systems,

101
00:05:49,790 --> 00:05:55,730
几十年来人们总结出一套设计思想，
a lot of people worked out a set of design ideas over the decades

102
00:05:56,000 --> 00:05:59,060
在组织事情方面运行良好，
have worked pretty well sort of ways of organizing things,

103
00:05:59,310 --> 00:06:03,240
我来给你们展示一下这种经典设计。
I'm going to lay out for you this sort of classic.

104
00:06:05,890 --> 00:06:11,770
也是这门课的标准组织方式，
A organization sort of standard deal for for this course,

105
00:06:11,770 --> 00:06:17,100
实际上在很多操作系统上都是很常见的，
and is actually quite common around for many operate systems,

106
00:06:17,100 --> 00:06:20,340
所以这是一种操作系统的内部组织方式，
so this is sort of OS internal organization,

107
00:06:20,400 --> 00:06:29,000
我想用这个方框来表示计算机，
or the way I think about it is in terms of a box for the computer,

108
00:06:29,810 --> 00:06:33,850
计算机包含许多硬件，
the computer sort of comes with a bunch of hardware resources,

109
00:06:33,850 --> 00:06:34,810
我把它们放在下面，
which I'll put at the bottom,

110
00:06:34,810 --> 00:06:42,040
有 CPU 、 内存、用来存储的磁盘，可能还有网络接口，
maybe their CPU and ram, disk for storage and maybe a network interface,

111
00:06:42,070 --> 00:06:44,800
这些硬件是最下面一层。
this sort of hardware that's the lowest layer.

112
00:06:46,180 --> 00:06:49,540
而在顶部，你想要运行各种应用程序，
So at the top you want to run various applications,

113
00:06:49,570 --> 00:06:53,200
或许是一个文本编辑器，这里我使用 vi 来表示，
maybe a text editor I have use VI as a text editor,

114
00:06:53,590 --> 00:06:56,500
也可能是运行 C 编译器 CC ，
if you're going to run a C compiler CC,

115
00:06:56,770 --> 00:06:59,920
也可以运行很多我们今天会讨论的其他东西，
you know if you run lots of other things we're gonna talk a lot today,

116
00:06:59,920 --> 00:07:04,260
比如 shell 作为命令行界面，
about the shell which is the command line interface,

117
00:07:04,410 --> 00:07:06,330
所以我们有了这些不同的程序在运行。
so we have all these different programs that are running.

118
00:07:07,260 --> 00:07:11,430
而且这个运行应用程序的地方，
And this is the sort of world in which applications run

119
00:07:11,430 --> 00:07:13,260
通常称为用户空间。
is usually called user space.

120
00:07:14,260 --> 00:07:18,280
与此不同的是，这里有一个单独的程序，
And as distinct from that, there's a single program,

121
00:07:19,440 --> 00:07:23,220
一个特殊的程序，它一直运行着，就是所谓的内核，
a special program, that's always running called the kernel

122
00:07:23,250 --> 00:07:27,150
内核是计算机资源的守护者，
and the kernel is sort of the guardian of the resources of the computer,

123
00:07:27,270 --> 00:07:29,970
它在你开机时第一个启动，
it's what first boots up you turn on the computer,

124
00:07:30,270 --> 00:07:33,270
只有一个内核来管理数据
there's just one of it maintains data,

125
00:07:33,640 --> 00:07:36,280
帮助管理进程，
to help manage each of these processes

126
00:07:36,280 --> 00:07:40,810
并且内核也有很多的数据结构帮助访问，
and the kernel also means lots of data structures to help interface,

127
00:07:40,810 --> 00:07:44,130
所有这些不同种类的硬件。
and all the different kinds of hardware,

128
00:07:45,020 --> 00:07:48,890
这些用户程序需要使用的硬件。
these user programs need to use.

129
00:07:49,550 --> 00:07:52,340
内核也有很多内置服务，
the kernel also has built in a bunch of services,

130
00:07:53,550 --> 00:07:55,260
比如，
and so, for example

131
00:07:55,260 --> 00:07:59,720
通常内核实现了一个文件系统，
there's typically a file system implementation inside the kernel,

132
00:07:59,720 --> 00:08:04,790
它实现了文件名、文件内容和文件夹，
that implements things like file names and file contents and directories

133
00:08:04,790 --> 00:08:07,910
并且知道如何将文件存储在磁盘上，
and understands how to store the files in the disk,

134
00:08:07,910 --> 00:08:10,850
所以程序访问内核中的文件，
so your programs are going to talk to the files inside the kernel

135
00:08:10,850 --> 00:08:14,530
然后文件系统访问磁盘。
and file implementations is going to talk to the disk.

136
00:08:15,410 --> 00:08:16,520
在这门课上，
In this course,

137
00:08:17,460 --> 00:08:21,840
我们主要关注内核内部发生的所有事情，
where we mostly focus on is all the things that has to happen inside the kernel,

138
00:08:22,140 --> 00:08:25,770
还有用户程序和内核之间的接口，
and on the interfaces between user programs and the kernel,

139
00:08:27,490 --> 00:08:31,390
还有内核里面的软件结构，
As well as the structure of the software inside the kernel.

140
00:08:32,110 --> 00:08:37,030
所以我们很关心内核中的这些服务。
So we care a lot about these services inside the kernel.

141
00:08:38,610 --> 00:08:40,350
其中之一是我提到过的文件系统，
One of them is a file system I mentioned,

142
00:08:40,380 --> 00:08:44,400
还有对进程的管理，
there's also management of processes,

143
00:08:44,400 --> 00:08:47,250
每个运行的程序被称为进程，
each of these running programs is called the process,

144
00:08:47,250 --> 00:08:49,230
它有自己的内存，
and it has things like its own memory,

145
00:08:49,230 --> 00:08:53,310
还有共享 CPU 时间。
for example as well as a share of the CPU time.

146
00:08:53,640 --> 00:09:00,730
内核将进程作为内核服务进行管理，
So, kernel manages processes. as a kernel service,

147
00:09:01,300 --> 00:09:05,740
内核管理内存的分配，
kernel manages the allocation of the memory,

148
00:09:05,950 --> 00:09:08,080
不同的进程需要不同数量的内存，
the different processes need different amounts of memory,

149
00:09:08,080 --> 00:09:13,310
内核复用、划分内存，
the kernel multiplexes and divides up the memory,

150
00:09:13,520 --> 00:09:18,000
给不同的进程分配内存。
allocates the memory among all the different processes.

151
00:09:24,400 --> 00:09:26,650
正如我提到的，内核影响文件系统，
The kernel as I mentioned influence the file system,

152
00:09:26,650 --> 00:09:31,030
文件系统实际上分为三个逻辑部分或几个逻辑部分，
file system really comes into a three logical or a bunch of logical parts,

153
00:09:31,030 --> 00:09:32,530
但现在，我们可以从
but for now, we can think of it

154
00:09:32,530 --> 00:09:36,250
管理文件内容的角度来考虑它，
in terms of managing file content that's inside files,

155
00:09:36,280 --> 00:09:38,140
找到内容在磁盘中的位置。
figuring out where on disk.

156
00:09:39,080 --> 00:09:40,610
每个文件内容都是可以变化的，
Each file's content ought to live,

157
00:09:40,910 --> 00:09:44,150
文件系统也在某种程度上管理一个命名空间，
file system also somewhat separately manages a name space,

158
00:09:44,150 --> 00:09:45,620
每个文件都有一个名字，
that each file has a name

159
00:09:45,650 --> 00:09:48,560
有一个层级目录，
and there's a hierarchy of directories,

160
00:09:48,830 --> 00:09:50,630
每个目录中有多个文件，
every directory has a bunch of files in it,

161
00:09:50,630 --> 00:09:53,360
所有这些都是由文件系统管理的。
all that's managed by the file system.

162
00:09:54,030 --> 00:09:56,700
通常会有某种安全策略，
There's typically some sort of security arrangement,

163
00:09:57,300 --> 00:09:59,130
有时也称为访问控制。
maybe we'll call it access control.

164
00:10:01,750 --> 00:10:03,130
由内核决定，
Which the kernel decides

165
00:10:03,130 --> 00:10:07,210
当一个进程想要读取，使用资源时，
that when a given process wants to read, use some resource,

166
00:10:07,210 --> 00:10:09,370
或许是从磁盘读取东西，使用内存，
maybe read something from disk, use some memory,

167
00:10:09,430 --> 00:10:11,590
内核内部的访问控制机制，
the access control machinery inside the kernel

168
00:10:11,590 --> 00:10:14,110
可以决定它是允许还是不允许，
is what gets to decide yes it's allowed is that not allowed,

169
00:10:14,290 --> 00:10:15,610
这也会很复杂，
that can get pretty complicated

170
00:10:15,610 --> 00:10:18,820
如果我们讨论的是类似 Athena 的分时系统，
if we're talking about time sharing systems like Athena systems,

171
00:10:18,820 --> 00:10:22,480
在那里，每个进程可能由不同的用户运行，
where there's you know each of these processes may be run by a different user

172
00:10:22,480 --> 00:10:24,910
有不同的访问控制规则，
and have different access control rules,

173
00:10:24,940 --> 00:10:26,890
是否允许访问其内容。
apply to what it's allowed to get at.

174
00:10:28,830 --> 00:10:31,410
在一个成熟的操作系统中，
And in a real full-blown operating system

175
00:10:31,710 --> 00:10:33,900
还有很多其他的服务，
turns out to be many, many other services,

176
00:10:34,050 --> 00:10:35,580
你知道，通常有某种方式
you know there's typically some way

177
00:10:35,580 --> 00:10:37,650
让不同的进程互相通信，
for different processes to talk to each other,

178
00:10:37,650 --> 00:10:39,420
这称为进程间通信，
called inter process communication,

179
00:10:40,200 --> 00:10:43,830
通常有很多软件使用网络，
there's typically a whole bunch of software associated with the network things,

180
00:10:43,830 --> 00:10:48,690
比如用于网络通信的的 TCP/IP 协议，
like the TCP/IP protocols for talking the network,

181
00:10:49,900 --> 00:10:52,330
通常也会支持声卡，
there's typically support for sound cards,

182
00:10:52,330 --> 00:10:54,880
可能会有上百个不同磁盘驱动
there may be drivers for hundreds of different disks

183
00:10:54,880 --> 00:10:56,380
and hundreds of different network cards,

184
00:10:56,470 --> 00:10:58,150
所以在一个成熟的操作系统中，
so in a full-blown operating system

185
00:10:58,150 --> 00:11:00,220
有大量的东西，
is a huge amount of stuff here

186
00:11:00,220 --> 00:11:03,850
这可能会在内核中运行数百万行代码。
and this may run to millions of lines of code inside the kernel.

187
00:11:05,300 --> 00:11:08,660
这是对内核内部的概述，
So that's sort of a quick overview of whats inside the kernel,

188
00:11:09,560 --> 00:11:13,340
我们还对应用程序与内核交互，
we're also interested in how applications interact with the kernel

189
00:11:13,370 --> 00:11:15,920
以及相关的接口定义感兴趣。
and what that interface looks like.

190
00:11:19,060 --> 00:11:27,560
一般，所以这是内核的 API 。
The usual, so this is the API for the kernel.

191
00:11:30,610 --> 00:11:32,230
应用程序如何访问内核，
How applications get at the kernel,

192
00:11:32,500 --> 00:11:35,410
通常是通过系统调用来完成的，
typically that's done with something called system calls

193
00:11:35,410 --> 00:11:40,440
它们看起来像是程序使用的函数调用，
and these are things that look like function calls that programs can make,

194
00:11:41,100 --> 00:11:42,990
但实际上是跳入内核，
but actually jump into the kernel

195
00:11:42,990 --> 00:11:47,130
并在执行内核中实现的系统调用，
and execute system call implementation in the kernel,

196
00:11:47,430 --> 00:11:50,520
在这个讲座的后半部分，我会谈到这些，
I'll talk a bunch about that in the latter part of this lecture,

197
00:11:51,090 --> 00:11:53,100
现在，只是让你初步了解一下。
for now just to give you a flavor here,

198
00:11:53,100 --> 00:11:54,960
应用程序代码中
what a couple of different system calls

199
00:11:54,960 --> 00:11:57,660
几个不同的系统调用是什么样的。
might look like in the source code of an application.

200
00:12:00,310 --> 00:12:01,510
其中一个是，
One might be that

201
00:12:01,630 --> 00:12:03,910
如果应用程序想要打开文件，
if you want an application wants to open a file,

202
00:12:04,180 --> 00:12:06,670
它可以调用 open 系统调用。
and it calls the open system call,

203
00:12:07,420 --> 00:12:10,510
把文件名传给 open 系统调用，
and tells the open system called the name of the file,

204
00:12:10,720 --> 00:12:14,200
它想要打开一个名为 out 的文件并写入，
so maybe it wants to open a file for writing called out

205
00:12:14,200 --> 00:12:17,500
下一个参数是 1 ，
and next argument here saying 1 in this case.

206
00:12:17,500 --> 00:12:18,760
我想写那个文件，
Saying I want to write that file,

207
00:12:19,000 --> 00:12:21,550
这个看起来像函数调用。
and so this thing that looks like a function call.

208
00:12:22,670 --> 00:12:26,480
open 系统调用实际上是跳入内核的指定代码，
It opens the system calls actually special code that jumps into the kernel

209
00:12:26,480 --> 00:12:28,400
内核可以获得这些参数，
and the kernel can retrieve these arguments,

210
00:12:28,700 --> 00:12:30,680
执行一些实现 open 的内核代码，
executes some kernel code that implements open,

211
00:12:30,680 --> 00:12:33,470
可能是访问磁盘，然后返回一个值，
maybe talks to the disk, and then returns a value

212
00:12:33,470 --> 00:12:38,220
这就是文件描述符， fd 表示文件描述符。
and that's this file descriptor, as fd stands for file descriptor,

213
00:12:38,610 --> 00:12:44,250
程序可以使用文件描述符来访问这个打开的文件。
which is the program can then use as a handle to refer to this open file.

214
00:12:44,760 --> 00:12:47,160
如果你想写入一个文件，
If you want to write to a file,

215
00:12:47,160 --> 00:12:50,930
需要使用系统调用 write ，
the system call did, to do that is called write,

216
00:12:51,200 --> 00:12:53,360
你必须向它传递一个文件描述符，
you have to pass it one of these file descriptors,

217
00:12:53,360 --> 00:12:55,100
跟 open 返回的类似，
the same was returned by open,

218
00:12:55,700 --> 00:12:59,270
这些是系统调用中传递的参数。
these are arguments that are passed in the system call.

219
00:12:59,770 --> 00:13:01,600
从程序到内核，
From the program into the kernel,

220
00:13:01,960 --> 00:13:05,370
你给它一个指向一个字符缓冲区的指针，
and you give it a pointer to a buffer of characters,

221
00:13:05,370 --> 00:13:08,310
在 C 语言中，一个简单的方法是，
so an easy way to do that in the C programming language,

222
00:13:08,310 --> 00:13:13,480
使用双引号，然后加上字符串，
which these examples are written by as double quotes then the string,

223
00:13:13,480 --> 00:13:16,690
字符串中的 \n 表示换行，
the bytes of the string backslash n is a new line

224
00:13:17,020 --> 00:13:19,810
第三个参数是字符数。
and the third argument is the count of characters.

225
00:13:20,160 --> 00:13:23,190
如果想写入，这里是关键，
If you want to write so this really gets point,

226
00:13:23,490 --> 00:13:25,350
把内存中的这个地址传过去，
pass this address in memory,

227
00:13:25,860 --> 00:13:29,400
告诉内核，请把这个地址的 6 个字节
so you're telling the kernel look, please write 6 bytes from this address

228
00:13:29,610 --> 00:13:32,520
写入到这个文件描述符关联的文件中。
to the file that this file descriptor refers to.

229
00:13:33,750 --> 00:13:37,350
一个更有意思的系统调用
A much more exciting system call the encounter

230
00:13:37,350 --> 00:13:40,560
是 fork 系统调用，
is the fork system call fork is the system call,

231
00:13:40,590 --> 00:13:42,420
它创建一个新的进程，
that creates a new process,

232
00:13:44,160 --> 00:13:48,000
并返回一个与调用方相同的进程，
and returns actually creates a process that's identical to the caller

233
00:13:48,300 --> 00:13:56,100
fork 返回新创建进程的进程标识符 pid 。
and fork returns the identifier the process identifier pid of the new process.

234
00:13:56,100 --> 00:13:59,270
更复杂的[]，我们还会听到更多关于这方面的内容。
More complicated than [], we'll hear more about this.

235
00:14:00,740 --> 00:14:03,470
同样，这些看起来像函数调用，
So again, these are all look like function calls,

236
00:14:04,400 --> 00:14:06,950
但是系统调用很特殊，因为它们跳入内核。
but the system calls are special because they jump into the kernel.

237
00:14:08,200 --> 00:14:10,660
这是初步了解，稍后我们会看到更多。
That's taste, we'll see more later.

238
00:14:15,800 --> 00:14:17,570
这是一个简单的概述，
That is a sort of quick overview,

239
00:14:17,600 --> 00:14:25,000
我想提一下为什么我发现操作系统的学习，
I wanna just mention why I find a operating the study of operating systems,

240
00:14:25,300 --> 00:14:30,160
既有挑战性，又十分有趣。
to be both a challenging and interesting.

241
00:14:32,710 --> 00:14:34,420
为什么值得
Why you know why it's maybe worth,

242
00:14:35,360 --> 00:14:38,450
intellectually worth taking a course in this area.

243
00:14:39,370 --> 00:14:42,760
这很难的一个原因是，环境是难以应对的，
So, one reason why it's hard is that the environment is unforgiving,

244
00:14:43,090 --> 00:14:46,360
内核的编程环境是难以应对的，
programming environment inside the kernels unforgiving,

245
00:14:46,360 --> 00:14:51,860
因为当你在编程时，
because you're, your when you're programming,

246
00:14:51,860 --> 00:14:53,810
当你修改或扩展内核，
when you're modifying the kernel or extending the kernel

247
00:14:53,810 --> 00:14:55,580
或编写新的操作系统内核时，
or writing a new operating system kernel,

248
00:14:55,640 --> 00:14:59,060
你提供的是其他人认为已经存在的基础设施，
you're providing the infrastructure that everybody else assumes

249
00:14:59,060 --> 00:15:01,280
用来运行他们的程序。
is already present to run their programs.

250
00:15:01,640 --> 00:15:04,550
任何人编写应用程序都在操作系统上运行，
And then everybody else gets an operating system under their program

251
00:15:04,610 --> 00:15:06,500
当他们编写普通应用程序时，
when they write ordinary application programs,

252
00:15:06,500 --> 00:15:08,990
但是当我们构建操作系统时，
but when we build operating systems

253
00:15:08,990 --> 00:15:12,410
操作系统下直接是硬件，
what we get is the hardware underneath our operating system

254
00:15:13,190 --> 00:15:15,620
结果是更难处理。
which turns out to be more difficult to deal with.

255
00:15:15,650 --> 00:15:16,310
在本课程中，
In this course,

256
00:15:16,310 --> 00:15:22,210
我们用到一个叫 QEMU 的硬件模拟器，
we we get to use a hardware simulator called QEMU.

257
00:15:22,790 --> 00:15:25,970
它模拟一个 CPU 和一台计算机，
That simulates a CPU and a computer

258
00:15:25,970 --> 00:15:27,200
这样做会好一点，
and that makes a little bit better,

259
00:15:27,200 --> 00:15:30,980
但它仍然是困难的编程环境。
but it's still a kind of a difficult, environment programming.

260
00:15:32,360 --> 00:15:34,100
另一个困难又有趣的原因是，
Another reason why it's hard and interesting is

261
00:15:34,100 --> 00:15:36,620
当你在设计操作系统时，
because if you're designing and operating system,

262
00:15:36,620 --> 00:15:39,500
必须解决一系列矛盾。
you have to satisfy a bunch of tensions,

263
00:15:39,980 --> 00:15:41,690
这需要真正的设计思想，
that require real design thought.

264
00:15:41,900 --> 00:15:46,220
其中之一是，你希望操作系统要有效率。
So one is that you'd like your operating system to be both efficient.

265
00:15:46,720 --> 00:15:51,280
这通常意味着它在接近硬件的底层上运行，
Which often means that it operates at a low level close to the hardware,

266
00:15:51,640 --> 00:15:53,260
但是为了便于使用，
but for ease of use,

267
00:15:53,290 --> 00:15:56,110
而且现实生活中的人必须
and because real live people have to write programs

268
00:15:56,380 --> 00:15:57,760
使用你的操作系统编写程序，
that use your operating system,

269
00:15:57,820 --> 00:16:02,020
所以我们希望它也是一个正确的高层次抽象。
we'd like it also to be a right abstract high-level.

270
00:16:02,660 --> 00:16:04,040
一个可移植的接口，
A portable interfaces

271
00:16:04,100 --> 00:16:07,910
提供简单的抽象接口需要巧妙的技巧，
and it's a neat trick to provide a abstract interfaces that are simple.

272
00:16:08,320 --> 00:16:10,780
便携的但也是高效的。
A portable but they are also efficient.

273
00:16:11,910 --> 00:16:13,950
另一个矛盾是，
Another tension is

274
00:16:13,950 --> 00:16:18,240
我们要提供一个非常强大的操作系统服务，
that we'd like to provide a very powerful operating system services,

275
00:16:18,240 --> 00:16:21,270
让操作系统可以承担很多责任。
so that the operating system can shoulder a lot of the burden.

276
00:16:21,680 --> 00:16:27,750
运行程序像强大的操作系统服务。
Running programs like a powerful operating system services.

277
00:16:28,630 --> 00:16:32,960
但是，我们也希望有简单的接口。
But, we also want to have simple interfaces,

278
00:16:34,770 --> 00:16:38,130
我们不想让程序员使用
that we don't want a tremendously complex

279
00:16:38,130 --> 00:16:40,560
一个非常复杂、难以理解的接口，
hard to understand interfaces for programmers to use,

280
00:16:40,560 --> 00:16:42,600
因为我也不会去理解它们，
because I'm not going to understand them,

281
00:16:42,600 --> 00:16:44,610
他们会发现它很难使用，
and they may find it hard to use,

282
00:16:45,790 --> 00:16:48,400
所以这是一个很简单的 API ，
so this is really simple API,

283
00:16:48,400 --> 00:16:53,170
所以可以提供一个简单的接口，
and so this is possible to do to provide a simple interfaces,

284
00:16:53,170 --> 00:16:56,710
并在内部拥有强大机制，
that have powerful a machinery inside them,

285
00:16:56,830 --> 00:16:58,210
这一直在寻找。
will always be searching for.

286
00:16:58,700 --> 00:17:04,340
简单的接口提供强大的服务，
Sort of simple interfaces provide a powerful services.

287
00:17:04,760 --> 00:17:06,860
嘿， Robert ，有人提问。
Hey, Robbery, we've got a question in the chat.

288
00:17:07,280 --> 00:17:11,600
系统调用跳入内核有什么特别之处，
What is unique slash different about saying system calls jump into the kernel,

289
00:17:11,600 --> 00:17:15,230
与跳转到另一个函数的标准函数调用相比。
i.e as opposed to a standard function call that jumps to another function.

290
00:17:18,100 --> 00:17:23,840
好的，内核是一段始终驻留的代码，
Well, the kernel has, the kernel is, a piece of code that's always resident,

291
00:17:23,840 --> 00:17:25,730
它具有特权，
that has special privileges

292
00:17:25,760 --> 00:17:29,630
因为内核在机器启动时加载，
that were that because it booted the machine booted the kernel,

293
00:17:30,020 --> 00:17:32,600
内核具有特权，
kernel has special privileges,

294
00:17:32,600 --> 00:17:35,300
它可以直接访问各种硬件，
it can get directly at all kinds of hardware,

295
00:17:35,300 --> 00:17:39,020
比如磁盘，普通用户程序不能访问，
like the disk device that ordinary user programs can't get at,

296
00:17:39,350 --> 00:17:41,780
所以如果你执行一个普通函数调用，
so if you make a an ordinary function call,

297
00:17:43,920 --> 00:17:46,440
你调用的函数没有，
the function your calling doesn't get it,

298
00:17:46,440 --> 00:17:49,320
没有任何关于硬件的特权，
doesn't get any special privileges with respect to the hardware,

299
00:17:49,530 --> 00:17:51,510
而你在内核执行系统调用，
whereas if you make a system call into the kernel,

300
00:17:52,620 --> 00:17:54,000
后面我们会详细讨论这是如何工作的，
we'll talk about how this works,

301
00:17:54,000 --> 00:17:57,510
这就像当系统调用跳到，
but that ends up as when it jumps into,

302
00:17:57,510 --> 00:17:59,340
跳到内核时，
when the system call jumps into the kernel,

303
00:17:59,730 --> 00:18:03,570
然后内核中的系统调用实现获得所有这些特权，
system call implementation in the kernel then gets all these special privileges,

304
00:18:03,570 --> 00:18:11,470
这样它就可以修改各种敏感的受保护的硬件资源，
so that it can modify all kinds of sensitive and protected hardware resources,

305
00:18:11,470 --> 00:18:14,140
比如直接访问硬盘，
like for example getting directly at the hard disk.

306
00:18:15,730 --> 00:18:18,700
我们稍后会看到更多关于这些的细节。
We'll see a lot more detail for all this shortly.

307
00:18:20,330 --> 00:18:22,670
好的，我们要说的最后一个矛盾是，
Okay, so a final tension that we want

308
00:18:22,670 --> 00:18:25,910
所有操作系统都需要满足你的需求，
that all operating systems need to satisfy your gonna give programs,

309
00:18:25,910 --> 00:18:27,560
尽可能的灵活，
as much flexibility as you can,

310
00:18:27,560 --> 00:18:28,760
你不想限制它们，
you don't want to constrain them,

311
00:18:28,970 --> 00:18:33,750
所以你想要很灵活的接口。
so you want to have very flexible interfaces.

312
00:18:33,750 --> 00:18:35,700
但是确实需要在一定程度上约束程序，
But you do need to constrain program somewhat,

313
00:18:35,700 --> 00:18:38,430
因为你必须有一些安全概念。
because you absolutely have to have some notion of security.

314
00:18:41,770 --> 00:18:44,770
我们喜欢编程，编程很自由，
We love for programs programs complete freedom,

315
00:18:44,770 --> 00:18:46,630
但它不能是完全自由的，
but it can't be complete can't be really complete,

316
00:18:46,870 --> 00:18:49,840
因为我们不想让程序直接访问硬件，
because we don't want programs to get directly at the hardware

317
00:18:49,840 --> 00:18:51,490
或者干扰其他程序，
or to interfere with other programs

318
00:18:51,490 --> 00:18:54,220
或者在某种程度上干扰
or a sort of be able to interfere

319
00:18:54,220 --> 00:18:56,830
操作系统本身的操作。
with the operation of the operating system itself.

320
00:18:57,360 --> 00:19:00,540
这就是你们需要知道的。
So, these are all you know.

321
00:19:01,490 --> 00:19:02,810
做好这项工作是可能的，
It's possible to do a good job

322
00:19:02,810 --> 00:19:03,860
我们将对此进行大量讨论，
and we'll talk a lot about it,

323
00:19:03,860 --> 00:19:05,450
但这总是令人费解，
but it's always a bit of a puzzle

324
00:19:05,450 --> 00:19:10,100
在这两列中同时提供这两个属性。
to provide sort of both of these properties in both of these columns.

325
00:19:11,630 --> 00:19:14,390
另一个让操作系统设计变得困难和有趣的是，
Another thing that makes OS design hard and interesting is

326
00:19:14,390 --> 00:19:17,690
操作系统提供了很多功能和服务，
that operating systems provide a lot of features and a lot of services,

327
00:19:17,690 --> 00:19:19,520
但它们实际上倾向于交互，
but they actually tend to interact

328
00:19:19,910 --> 00:19:21,650
而且有时以奇怪的方式进行交互，
and sometimes in odd ways

329
00:19:21,650 --> 00:19:22,760
这需要很多思考，
that require a lot of thought,

330
00:19:22,760 --> 00:19:25,700
即使是我给出的简单示例。
so even the simple examples I gave.

331
00:19:26,640 --> 00:19:29,190
使用 open 和 fork ，这两个交互，
With open and fork, those two interact actually

332
00:19:29,190 --> 00:19:34,220
如果一个程序使用 open 系统调用分配文件描述符，
if a program allocates a file descriptor with the open system call,

333
00:19:34,700 --> 00:19:38,640
然后使用 fork 分配相同的程序。
and then that same program fork.

334
00:19:39,610 --> 00:19:42,040
fork 的语义是，
And the semantics of fork just turned out to be

335
00:19:42,040 --> 00:19:45,580
你创建一个新进程，它是当前进程的副本，
that you create a new process that's a copy of the current process,

336
00:19:45,730 --> 00:19:47,830
你打开的这个文件描述符，
this file descriptor you opened,

337
00:19:49,640 --> 00:19:51,290
实际上是一个副本，
if that's truly to be a copy,

338
00:19:51,290 --> 00:19:55,550
这个文件描述符仍然在子进程中存在并可用,
this file descriptor still has to be present and usable in the child,

339
00:19:57,320 --> 00:19:58,370
所以必须仔细考虑，
and so that has to be thought,

340
00:19:58,370 --> 00:19:59,660
这就是文件，
through that is the files,

341
00:19:59,660 --> 00:20:02,840
打开的文件描述符以这种方式与 fork 交互，
the opened file descriptors interact with fork in this interesting way

342
00:20:03,230 --> 00:20:07,580
必须找到让子进程能读取到
and somebody has to figure out should the child be able to get at,

343
00:20:07,960 --> 00:20:10,690
fork 调用之前创建的文件描述符，
the file descriptors created before fork is called

344
00:20:10,930 --> 00:20:12,340
答案是肯定的，
and the answer has to be yes,

345
00:20:12,580 --> 00:20:14,170
这就是我们要看的操作系统。
the operating systems we're going to look at.

346
00:20:17,070 --> 00:20:18,510
好的，其他有趣的事情
Alright and so other things that

347
00:20:18,510 --> 00:20:21,210
我已经提过了，
are turned out to be interesting I already mentioned,

348
00:20:21,210 --> 00:20:25,080
操作系统必须满足各种各样的用途，
that operating systems have to cater to a wide variety of uses,

349
00:20:25,110 --> 00:20:30,540
同样的操作系统适用于数据库服务器和智能手机，
the same OS used both for database servers and smartphones, for example.

350
00:20:31,500 --> 00:20:35,240
而且操作系统，随着时间的推移，
And operating systems, as time goes on,

351
00:20:35,270 --> 00:20:38,360
你运行的硬件，得到的硬件，
the hardware that you run, hardware you get,

352
00:20:38,360 --> 00:20:40,130
典型的计算机会发生变化，
but typical computers changes,

353
00:20:40,400 --> 00:20:44,930
可能使用超高速的固态硬盘存储替代机械硬盘。
maybe get superfast ssd storage instead of mechanical hard drive, for example.

354
00:20:45,360 --> 00:20:47,010
大概十五年前，
And about fifteen years ago,

355
00:20:47,070 --> 00:20:52,650
多核计算机从稀有发展到无处不在，
multi core computers went from being rare curiosities to being pervasive

356
00:20:54,030 --> 00:20:57,360
最近我们看到了数量级的提速，
and and recently we've seen order of magnitude speedups

357
00:20:57,360 --> 00:20:58,890
和网络操作速度，
and how fast networks operate

358
00:20:59,190 --> 00:21:01,110
所以这些都需要重新思考。
and so all these require rethinks.

359
00:21:01,440 --> 00:21:05,220
定期介绍操作系统是如何设计的。
Periodically of how operating systems are designed.

360
00:21:06,510 --> 00:21:10,500
这些就是
Now so so those are those are,

361
00:21:10,500 --> 00:21:12,510
你可能选择这门课的原因。
sort of intellectually why you might take the course,

362
00:21:12,510 --> 00:21:14,400
还有一些更实际的原因，
there's also some more practical reasons,

363
00:21:14,400 --> 00:21:17,460
你选择这门课的原因，
why you might be glad to have taken this course,

364
00:21:17,580 --> 00:21:20,730
一个是如果你对计算机内部发生的事情感兴趣，
one is if you're interested in what happens inside computers,

365
00:21:20,730 --> 00:21:24,390
想知道并探寻计算机内部的秘密，
what goes on and saw under the hood a sort of in secret,

366
00:21:24,390 --> 00:21:25,650
当你打开计算机时，
when you turn on your computer,

367
00:21:25,710 --> 00:21:27,120
这是一个很好的课程，
this is a good course to take,

368
00:21:27,510 --> 00:21:29,250
类似地，如果你喜欢基础设施，
similarly if you like infrastructure

369
00:21:29,250 --> 00:21:33,240
也就是如果你喜欢建立一种服务，
that is if if you enjoy building a sort of services

370
00:21:33,240 --> 00:21:35,910
其他程序可以使用的服务。
that other programs can then use them.

371
00:21:36,510 --> 00:21:38,820
当然，这基本上都是关于基础设施的，
This is of course essentially all about infrastructure,

372
00:21:38,820 --> 00:21:41,070
因为这就是操作系统。
because that's that's what operating systems are.

373
00:21:42,350 --> 00:21:46,670
如果你曾经花费大量时间来跟踪应用程序代码中的 bug ，
If you ever need to spend a lot of time tracking down bugs in application code

374
00:21:46,700 --> 00:21:48,500
或跟踪安全问题，
or tracking down security problems

375
00:21:48,830 --> 00:21:53,360
通常会设计到了解操作系统内部发生了什么，
often that involves understanding what was going on inside the operating system,

376
00:21:53,450 --> 00:21:57,710
因为最终是操作系统实施了很多安全措施，
because it's ultimately the operating system that enforces a lot of security,

377
00:21:57,710 --> 00:22:00,020
当事情发生错误时，
and when things go wrong,

378
00:22:00,020 --> 00:22:02,090
操作系统必须收拾残局，
it's the operating system has to pick up the pieces,

379
00:22:02,090 --> 00:22:06,950
通常设计到跟踪 bug ，然后最终。
so that's often involved in tracking down bugs and finally.

380
00:22:08,000 --> 00:22:09,440
在聊天中有两个问题，
Two more questions from the chat,

381
00:22:09,440 --> 00:22:10,580
第一个是，
so the first is

382
00:22:10,580 --> 00:22:12,620
对于应用程序开发人员来说，
how important is it for application developers,

383
00:22:12,620 --> 00:22:15,050
真正深入理解操作系统有多重要，
to truly deeply understand the operating systems

384
00:22:15,050 --> 00:22:16,730
对于开发应用来说，
of developing their applications for,

385
00:22:17,060 --> 00:22:19,100
它们是否需要称为专家。
do they necessarily need to be experts.

386
00:22:19,810 --> 00:22:21,370
你不需要成为专家，
You don't have to be an expert,

387
00:22:21,370 --> 00:22:23,830
但是如果你花费大量时间
but if you spend a lot of time

388
00:22:23,830 --> 00:22:26,590
开发、维护和调试应用程序，
developing and maintaining and debugging applications,

389
00:22:26,650 --> 00:22:30,160
你最终会对操作系统有很多了解，
you'll eventually end up knowing a lot about the operating system,

390
00:22:30,160 --> 00:22:32,570
无论你是有意或无意，
whether you, whether you meant to or not,

391
00:22:32,570 --> 00:22:37,530
它就出现了，而且你经常被迫理解它。
just it just comes up and you're often forced to understand.

392
00:22:39,640 --> 00:22:41,080
第二个问题是，
And the second question is,

393
00:22:41,080 --> 00:22:45,310
像 Python 这样的高级编程语言是否直接使用系统调用，
do high-level programming languages like python use system calls directly,

394
00:22:45,310 --> 00:22:48,160
是否为了方便编写了内置的包装器。
are there built in slash wrappers for convenience.

395
00:22:48,710 --> 00:22:53,360
很多高级语言在某种程度上是从操作系统中转移出来的，
A lot of high-level languages are sort of at one of move from system calls,

396
00:22:53,540 --> 00:22:54,500
这是正确的。
that's absolutely true.

397
00:22:54,500 --> 00:22:59,300
所以，部分原因是许多语言
So, but partially because a lot of languages

398
00:22:59,330 --> 00:23:02,780
想要提供可移植的环境，
want to provide portable a portable environment,

399
00:23:02,780 --> 00:23:04,430
可以运行在许多不同的操作系统上，
that works on many different operating systems,

400
00:23:04,430 --> 00:23:06,230
因此它们不一定要致力于
so they can't necessarily commit to

401
00:23:06,230 --> 00:23:09,290
任何一种操作系统的特定系统调用，
the specific system calls or any one operating system.

402
00:23:09,980 --> 00:23:12,410
所以答案是，
So, the answer,

403
00:23:12,410 --> 00:23:13,280
我想问题的答案是，
the question I think is

404
00:23:13,280 --> 00:23:14,810
如果你使用 Python ，
if you use python,

405
00:23:14,810 --> 00:23:18,790
你多少与系统调用接口有些隔离。
you're somewhat insulated from the system call interface,

406
00:23:18,790 --> 00:23:20,530
Python 内部当然会做，
you know internally of course python makes,

407
00:23:20,900 --> 00:23:23,360
调用系统调用来完成它的工作。
has to make system calls get its work done.

408
00:23:23,360 --> 00:23:26,380
当然，在 Python 和许多其他语言中，
And, certainly in python and many other languages,

409
00:23:26,380 --> 00:23:30,740
通常有一种方法可以直接进入系统调用，
there is usually a way to get directly at the system calls

410
00:23:30,740 --> 00:23:33,770
无论你使用什么操作系统。
whatever your operating system, you're running on.

411
00:23:35,480 --> 00:23:36,740
想提问的各位同学，
And folks for questions,

412
00:23:36,740 --> 00:23:39,050
你可以自己提问，
you can just feel free to jump in yourself and ask questions,

413
00:23:39,050 --> 00:23:40,250
不一定需要通过聊天提出问题。
you don't need to go through the chat.

414
00:23:43,410 --> 00:23:44,550
好的。
Okay.

415
00:23:46,020 --> 00:23:52,300
好的，抱歉，现在我要花几分钟，
Alright, sorry, I'm going to spend a couple of minutes now

416
00:23:52,300 --> 00:24:00,130
讨论 6.S081 的课程结构，
talking about a class structure of 6.S081,

417
00:24:01,140 --> 00:24:05,160
然后再回到技术内容部分，
before switching back to actual technical content.

418
00:24:05,430 --> 00:24:08,370
这里有一个课程的网站，
So there is a website for the course,

419
00:24:08,370 --> 00:24:09,870
我现在不想写出来，
which I don't want to write out just now,

420
00:24:09,870 --> 00:24:13,470
但是你可以在谷歌上搜索 6.S081 找到它。
but it's you can find it by looking for 6.S081 on Google.

421
00:24:14,280 --> 00:24:23,460
这个网站有一个课程表，
And the website, has a schedule,

422
00:24:23,980 --> 00:24:28,390
课程表上有作业，还有实验作业。
it has the assignments on the schedule that has the lab assignments.

423
00:24:28,740 --> 00:24:31,830
它也有关于课程结构的其他信息，
And it has the sort of information about course structure,

424
00:24:31,830 --> 00:24:33,570
比如课程的评分标准。
like the grading policy on it.

425
00:24:34,240 --> 00:24:38,920
你需要跟踪的另一个重要资源是 Piazza 。
The other big resource you're gonna wanna keep track of piazza.

426
00:24:39,960 --> 00:24:42,720
我想，来这里的每个人都是通过 Piazza 。
I guess, everybody was here got here by way piazza,

427
00:24:43,020 --> 00:24:45,600
但是还有，
but as well as,

428
00:24:45,960 --> 00:24:48,150
所以我们定期来做两件主要的事情，
so we used periodically for two main things,

429
00:24:48,150 --> 00:24:52,320
一是人们能够对实验作业提出问题，
one is as a way of people being able to ask questions about the lab assignments,

430
00:24:52,320 --> 00:24:56,180
工作人员会试着回答这些问题，
and a course staff will try to answer these questions,

431
00:24:56,180 --> 00:24:59,690
你们也可以完全自由地回答彼此的问题，
but you should feel absolutely free to answer each other's questions as well

432
00:25:00,020 --> 00:25:02,270
在 Piazza 上发生的另一件事是，
and the other big thing that happens on piazza,

433
00:25:02,270 --> 00:25:05,180
如果有课程公告，就会发布在上面，
if there's announcements there's any announcements about the course.

434
00:25:05,500 --> 00:25:07,540
我们会把公告放在 Piazza 上，
We'll put the announcement on piazza,

435
00:25:07,540 --> 00:25:09,730
所以你应该关注 Piazza 上的公告，
so you should keep an eye on piazza for announcements,

436
00:25:09,730 --> 00:25:12,510
即使你不用它来寻找实验帮助。
even if you're not using it for lab help.

437
00:25:13,580 --> 00:25:13,670
是的。
Yeah.

438
00:25:16,700 --> 00:25:20,720
课程的很大一部分就是这些课程。
The one of the big parts of course is that these lectures.

439
00:25:24,150 --> 00:25:28,620
这个讲座会涉及到操作系统的基本理念。
Lectures will cover basic ideas of operating systems.

440
00:25:28,860 --> 00:25:36,330
有些课程会详细研究 xv6 的代码，
Some of the lectures will be devoted to detailed a study of the code in xv6,

441
00:25:36,330 --> 00:25:38,550
这是我们的小型教学操作系统，
which is our small teaching operating system

442
00:25:39,420 --> 00:25:41,310
讨论它是如何工作的，
and so talk about how it works,

443
00:25:41,310 --> 00:25:44,940
我们会在课程中查看代码，演示代码执行过程，
we'll look at the code and show the code executing during lectures,

444
00:25:45,810 --> 00:25:47,880
另外，在很多课程之前
and in addition, before many of the lectures,

445
00:25:47,880 --> 00:25:50,790
我们会先阅读书中的作业，
we'll be assignments reading assignments from a book,

446
00:25:51,150 --> 00:25:54,090
这本书描述了 xv6 是如何运行的，
that sort of describes how xv6 operates

447
00:25:54,090 --> 00:25:55,950
以及为什么它是这样设计的。
and why it's designed that way.

448
00:25:56,670 --> 00:25:58,590
所以你应该在上课前阅读，
So you do the readings before the class,

449
00:25:59,370 --> 00:26:01,950
这样就能听懂课程上的讨论，
so they do understand the discussion in the class,

450
00:26:02,400 --> 00:26:04,950
一些课程专门讲授背景知识，
some of the lectures are devoted to background

451
00:26:04,950 --> 00:26:06,420
帮助你做实验。
to help you do the labs.

452
00:26:06,660 --> 00:26:08,910
比如 C 语言是如何工作的，
So, like about C works of,

453
00:26:08,910 --> 00:26:12,750
RISC-V ，也就是我们要使用的微处理器，
how the RISC-V which is the microprocessor that we'll be using,

454
00:26:13,200 --> 00:26:17,610
你们会发现这对理解如何做实验很有帮助，
that you'll find helpful in understanding how to do the labs

455
00:26:17,760 --> 00:26:19,290
在课程快结束的时候，
and towards the end of the course,

456
00:26:19,890 --> 00:26:24,360
我们会用一些课讨论一些操作系统论文，
we'll spend some lectures discussing some operating system papers,

457
00:26:25,080 --> 00:26:28,020
研究论文和该领域的一些经典论文，
research papers and some classic papers in the field,

458
00:26:28,320 --> 00:26:31,230
会要求你们在课程前阅读这些论文，
which you will ask that you read before the lecture

459
00:26:31,230 --> 00:26:34,410
然后我们会在课程中讨论这些论文。
and then we'll sort of talk about the papers during the lecture,

460
00:26:34,980 --> 00:26:37,170
对于所有的讲座，
for all the lectures are almost all the lectures,

461
00:26:37,290 --> 00:26:40,980
我们要求你在讲座之前，
we ask that you submit a question about the reading,

462
00:26:41,010 --> 00:26:45,090
提交一个关于所读文章的问题。
for the lecture before the actual time of the lecture.

463
00:26:45,300 --> 00:26:49,040
你们中的很多人都参加了这次讲座，谢谢你们。
Which many or all of you did for this lecture for which thank you,

464
00:26:49,220 --> 00:26:51,830
我们会查看这些问题来帮助我们。
and we will read those questions to help us.

465
00:26:52,970 --> 00:26:54,800
指导我们讨论什么，
Guide us about what to talk about

466
00:26:54,800 --> 00:26:58,040
我们会努力回答尽可能多的问题，
and we'll try to answer as many of the questions as we can,

467
00:26:58,040 --> 00:27:01,580
尽管很少有时间，不过我们没有时间回答所有问题。
although there's rarely time, unfortunately for us to answer all of them.

468
00:27:02,800 --> 00:27:05,830
课程的下一个重要部分是实验。
The next big part of the course of the labs.

469
00:27:06,400 --> 00:27:10,900
几乎每周都有一个编程实验，
There's a programming lab do, almost every week

470
00:27:11,770 --> 00:27:13,000
实验的目的是，
and the point of the labs is

471
00:27:13,000 --> 00:27:14,650
帮助你亲身体验
to help you get hands on experience

472
00:27:14,650 --> 00:27:19,620
实现和使用操作系统。
with implementing and using operating systems.

473
00:27:20,690 --> 00:27:24,170
下周到期的一个实验是，
A lab that's due next week is

474
00:27:24,170 --> 00:27:27,020
关于如何编写
actually about using about writing applications

475
00:27:27,020 --> 00:27:29,030
调用系统调用的应用程序，
that make the call the system calls,

476
00:27:29,030 --> 00:27:29,900
随后我们会讨论。
we'll be talking about.

477
00:27:31,520 --> 00:27:34,070
与此之后的大多数实验不同，
Whereas most of those labs after that are involved,

478
00:27:34,070 --> 00:27:37,820
要么实现基本的操作系统功能，
you either implementing basic operating system features

479
00:27:37,820 --> 00:27:43,940
或想 xv6 操作系统添加内核扩展，
or adding a kernel extensions to the xv6 operating system,

480
00:27:44,780 --> 00:27:46,460
最后一个实验，
the very last lab and one

481
00:27:46,460 --> 00:27:49,430
是添加一个网络栈，和网络驱动程序，
in which you actually add a network stack and a network driver,

482
00:27:49,430 --> 00:27:51,500
以便能够通过网络
so you'll be able to connect in over the network

483
00:27:51,500 --> 00:27:53,300
to the operating system that you run.

484
00:27:55,560 --> 00:27:57,990
如果你对实验有问题，
You should, if you have problems with the lab's,

485
00:27:57,990 --> 00:28:02,810
助教会在办公时间提供帮助。
they'll be office hours that TAs will hold.

486
00:28:02,810 --> 00:28:05,990
你也可以把问题发布到 Piazza 上，
In addition you can post questions to piazza

487
00:28:06,230 --> 00:28:09,170
而且通常可以从 Piazza 上获得有用的答案，
and very often you'll be able to get useful answers from piazza

488
00:28:09,890 --> 00:28:11,810
比在办公时间更快。
more quickly than from office hours.

489
00:28:13,060 --> 00:28:16,900
我们欢迎你讨论实验，
We welcome you discussing the labs talking about the labs,

490
00:28:16,900 --> 00:28:20,410
讨论如何设计实验解决方案，
talking about how to design the lab solutions,

491
00:28:20,410 --> 00:28:23,410
但是我们要求不要看别人的解决方案。
but we ask you please do not look at other people's solutions.

492
00:28:23,680 --> 00:28:26,350
重复一遍，你编写的所有代码都应该是自己的，
Relapse, please all the code you write should be your own

493
00:28:26,350 --> 00:28:30,490
而且你不应该分享代码或查看其他解决方案。
and you shouldn't share code or a look at other solutions.

494
00:28:32,740 --> 00:28:41,360
评分，当然，今年主要由实验决定的。
Grading, of course, will be mostly determined from the labs this year,

495
00:28:41,480 --> 00:28:49,620
所以 70% 的成绩将是根据你的实验结果，
so 70% of the grade will be, based on whether or not your lab,

496
00:28:49,620 --> 00:28:51,240
你提交的代码是否通过测试，
you submit passes the tests

497
00:28:51,240 --> 00:28:54,840
我们评分使用我们提供的相同的测试，
and we for grading, we run the same tests that we supply you,

498
00:28:54,840 --> 00:28:57,810
所以如果你的实验通过了我们提供的所有实验，
so if your lab passes all the tests that we give you,

499
00:28:57,810 --> 00:28:59,940
你就可以得到实验的全部分数。
the chance to show you that full credit for the lab.

500
00:29:00,500 --> 00:29:06,320
20% 的分数来自实验检查会议，
20% of the grade is going to be from lab checkoff meetings

501
00:29:08,030 --> 00:29:11,360
你们每个人都将随机选择几个实验，
for each of you will pick a couple of randomly selected labs

502
00:29:11,360 --> 00:29:13,040
有一个小组将与你们交谈，
and one of the teams will talk to you

503
00:29:13,280 --> 00:29:14,990
询问你们关于实现实验的问题，
and ask you questions about your implementation

504
00:29:14,990 --> 00:29:19,330
确保你们真的理解发生了什么。
just to make sure that are you really understand what's going on.

505
00:29:20,180 --> 00:29:21,920
这是实验检查。
It's a lab check offs.

506
00:29:23,870 --> 00:29:26,240
还剩 10% 。
There's a 10% remaining.

507
00:29:28,040 --> 00:29:33,290
很多，比如是或否，一或零的事，
A lot of, kind of be, like a yes or no, one or zero type of thing

508
00:29:33,290 --> 00:29:34,160
或者他们会，
or would they be,

509
00:29:35,100 --> 00:29:40,080
比如答对了部分问题，
like could someone get, like if they answered some of the questions right,

510
00:29:40,080 --> 00:29:41,490
但不是所有问题都答对了，
but not all the questions right,

511
00:29:41,490 --> 00:29:44,350
当他们是这种情况时，分数是怎样的。
when they get in between, so the grade.

512
00:29:45,060 --> 00:29:46,590
你知道，我还没有想过这件事。
You know I haven't thought this through,

513
00:29:47,380 --> 00:29:50,620
当然有部分学分的情况，但是。
there's certainly room for partial credit, but.

514
00:29:51,310 --> 00:29:53,170
它不是二选一的，
It's not, it won't be binary,

515
00:29:53,440 --> 00:29:56,110
你当然可以获得部分学分。
it'll definitely be you can receive partial credit.

516
00:29:56,940 --> 00:29:57,420
好的。
Okay.

517
00:29:59,470 --> 00:30:03,070
最后的 10% 是由家庭作业
The last 10% is going to be driven by the homework

518
00:30:03,070 --> 00:30:06,580
以及讲座和 Piazza 的参与决定的。
and participation during lecture and piazza.

519
00:30:08,900 --> 00:30:14,260
今年不会有考试或小测验。
There will be no exams or quizzes this year.

520
00:30:15,150 --> 00:30:17,670
所以，这意味着大部分的，
And so what, that means is that most of the,

521
00:30:18,480 --> 00:30:23,160
你知道 90% 的成绩是由实验决定的。
you know 90% of the grade is being driven by the lab.

522
00:30:23,160 --> 00:30:26,700
所以你应该花很多时间在实验上，
So you should spend a lot of time in the labs,

523
00:30:26,730 --> 00:30:29,610
确保你早点开始，
make sure that you start early

524
00:30:29,610 --> 00:30:33,870
有足够的时间完成实验，并解决 bug ，
and have enough time to complete them and work out bugs

525
00:30:33,870 --> 00:30:34,980
以获得满分。
in order to get full credit.

526
00:30:37,270 --> 00:30:40,000
你知道，因此这是一门
And you know as a result of that this is going to be a

527
00:30:40,000 --> 00:30:43,510
非常实用的面向软件的课程。
very kind of hands-on software oriented course.

528
00:30:44,580 --> 00:30:48,530
关于课程组织，还有什么问题吗？
Any questions about the machinery of the course?

529
00:30:53,760 --> 00:30:56,220
在聊天中有几个问题。
We've got a couple questions in chat.

530
00:30:56,670 --> 00:30:58,800
第一个是组织管理的问题，
So the first is a logistical question,

531
00:30:58,950 --> 00:31:03,630
当前， 6.S081 没有像往常一样在系统主修课程中，
currently 6.S081 isn't listed as usual for the system's concentration in the [],

532
00:31:03,990 --> 00:31:06,180
以后有没有增加课程的计划。
are there plans added to the list of classes later.

533
00:31:06,180 --> 00:31:09,750
我想因为它不是批准的高级研究生课程，
I think for that because it's not an AAGS,

534
00:31:09,750 --> 00:31:10,920
它是高级本科课程，
it's an AUS,

535
00:31:10,920 --> 00:31:13,590
它不能满足安排要求，
it can't be used to fulfill arrange requirements,

536
00:31:13,590 --> 00:31:15,480
所以它不是研究生水平的课程。
so it's not a graduate level class.

537
00:31:15,970 --> 00:31:23,020
但是，我们有唯一的家庭作业来提交问题，
But, and then we have is the only homework to submit questions

538
00:31:23,020 --> 00:31:25,450
看看日历似乎是这样。
looking at the calendar that appears to be the case.

539
00:31:28,360 --> 00:31:32,620
除非我忘了什么，我想就是这样的。
Unless I'm forgetting something, I think that's the case, yes.

540
00:31:35,140 --> 00:31:39,250
那么，有没有分数比例的情况，
So have, are there gonna be cutoffs for grades,

541
00:31:39,250 --> 00:31:42,910
像是百分之 X 的人得 A ，百分之 Y 得 B 等等。
like X percent gets in A, Y percent gets a B etc.

542
00:31:43,510 --> 00:31:52,740
不，不，你知道我们努力给学生自由。
No, no, you know we're going to try to free student estimate.

543
00:31:53,320 --> 00:31:58,630
我的评价是你对材料理解得好坏，
I'm impression of how well you've understood the material,

544
00:31:59,250 --> 00:32:00,480
并在此基础上给出一个分数，
and assign a grade based on that,

545
00:32:00,480 --> 00:32:02,880
所以不会有预先设定的比例。
so there's no predetermined cut offs.

546
00:32:07,950 --> 00:32:09,840
好的，还有其他问题吗？
Alright anything else?

547
00:32:13,660 --> 00:32:18,160
好的，对于聊天中
Alright, just real quick for folks in the chat

548
00:32:18,460 --> 00:32:22,600
询问主修要求的人来说，
asking about the concentration requirement,

549
00:32:22,780 --> 00:32:24,820
我不是百分之百确定，
I'm not a hundred percent certain,

550
00:32:24,820 --> 00:32:26,770
但 6.S081 不是，
but 6.S081 is not,

551
00:32:26,890 --> 00:32:30,010
它是课程获得正式编号之前的一个临时编号，
it's a temporary number before the class gets official one,

552
00:32:30,010 --> 00:32:33,100
所以它不会出现在任何地方，
so it certainly won't be listed anywhere,

553
00:32:33,280 --> 00:32:35,200
如果你需要它来实现主修课程，
if you need it to fulfill a concentration,

554
00:32:35,200 --> 00:32:37,360
我想你最好的选择是填写一份请愿书，
I think your best bet is probably to fill out a petition

555
00:32:37,360 --> 00:32:40,270
或给 Katrina Kurtz 发送邮件，
or to email somebody like Katrina Kurtz,

556
00:32:40,780 --> 00:32:42,730
查看是什么状态，
to see a what the status is,

557
00:32:43,240 --> 00:32:45,840
我们无法控制
we don't control, you know,

558
00:32:45,840 --> 00:32:50,010
哪些课程满足这些要求。
what what classes fill these kind of requirements, unfortunately.

559
00:32:51,240 --> 00:32:53,700
这门课将使用什么语言，将使用 C 语言。
And for what language will be using the class, will be in C.

560
00:32:58,700 --> 00:33:00,170
好的。
Alright, um.

561
00:33:02,400 --> 00:33:03,900
好的，对于这堂课剩下的时间，
Alright, for the rest of the lecture,

562
00:33:03,900 --> 00:33:07,050
我想谈一下，
I want to talk about how

563
00:33:07,050 --> 00:33:10,530
系统调用看起来像应用程序。
what system calls look like applications.

564
00:33:11,290 --> 00:33:13,660
你知道，因为系统调用
And you know since the system calls

565
00:33:13,660 --> 00:33:17,860
是操作系统提供服务的接口，
are the interface to the services that the operating system provides

566
00:33:17,860 --> 00:33:20,890
所以这些系统实际是什么样，
is actually pretty important what those systems look like,

567
00:33:20,890 --> 00:33:24,280
应用程序从系统调用中得到什么，
what applications expect from system calls and how they behave,

568
00:33:24,280 --> 00:33:28,000
所以理解接口是什么样子是值得的。
so it's worth understanding what the interface looks like.

569
00:33:29,380 --> 00:33:32,590
你将在第一个实验中使用我们谈到的系统调用，
You'll be using the system calls we talk about in the first lab,

570
00:33:32,960 --> 00:33:37,130
在后续的实验中，
and extending and improving the implementation,

571
00:33:37,160 --> 00:33:40,220
扩展和增强这些系统调用的内部实现。
internal implementation of these system calls in subsequent labs.

572
00:33:40,960 --> 00:33:46,390
我们将演示一些程序的简单示例。
What we're gonna do is show some simple examples of little programs.

573
00:33:47,980 --> 00:33:53,680
它调用系统调用，我将在 xv6 中运行它们。
That call system calls and I'll run them in xv6 four you.

574
00:33:54,540 --> 00:33:56,370
我将运行它们，
I'm gonna run them,

575
00:33:56,370 --> 00:34:01,700
xv6 是一个简单的类 unix 操作系统，
the xv6 is a, it's a unix, a simplified unix like operating system,

576
00:34:01,700 --> 00:34:04,130
unix 是一个古老的操作系统，
unix is a old operating system,

577
00:34:04,130 --> 00:34:09,320
至少作为许多当前操作系统的基础，
that's at least intellectual basis for many present-day operating systems,

578
00:34:09,320 --> 00:34:12,980
它使用非常广泛，
such as Linux and OS X it's in very common use,

579
00:34:14,540 --> 00:34:18,920
xv6 我们的教学操作系统要简单地多，
xv6 our teaching operating system is much simpler

580
00:34:19,400 --> 00:34:21,650
在某种程度上收到 unix 的启发，
and sort of inspired by unix

581
00:34:21,650 --> 00:34:23,390
具有相同的整体结构，
and has the same overall structure,

582
00:34:23,390 --> 00:34:27,860
但是比任何真正的 unix 操作系统都要简单。
but is dramatically simpler than any real unix operating system.

583
00:34:30,750 --> 00:34:32,850
它足够简单，
It's simple enough that hopefully,

584
00:34:33,120 --> 00:34:36,600
你可以直接阅读
you know it would be relatively straightforward,

585
00:34:36,600 --> 00:34:38,460
所有的源码，
for you to read all the source code,

586
00:34:38,550 --> 00:34:39,840
同时阅读这本书，
as well as read the book,

587
00:34:40,080 --> 00:34:41,640
在几周时间内。
in a couple of weeks.

588
00:34:41,640 --> 00:34:42,780
当然在本学期，
Certainly during the semester

589
00:34:42,780 --> 00:34:47,100
为了理解所有 xv6 内部发生的事情。
in order to kind of understand all of what happens inside xv6.

590
00:34:49,680 --> 00:34:54,720
xv6 运行在 RISC-V 处理器上，
xv6 runs on the RISC-V processor, RISC-V microprocessor,

591
00:34:54,870 --> 00:34:59,340
这也是最近 6.004 课程使用的微处理器。
and this is the same microprocessor that's the focus of recent 6.004.

592
00:34:59,800 --> 00:35:04,960
所以，你们中的很多人可能对 RISC-V 指令集有相当多的了解。
So many of you may actually know quite a bit about the RISC-V instruction set.

593
00:35:05,780 --> 00:35:10,670
理论上你可以在 RISC-V 计算机上运行 xv6 ，
In theory you could run xv6 on top of a RISC-V computer

594
00:35:11,510 --> 00:35:13,880
也已经有人这么做了。
and people done that.

595
00:35:14,560 --> 00:35:18,850
但是我们要在 QEMU 机器仿真器下运行，
But we're going to run it under the QEMU machine emulator,

596
00:35:18,910 --> 00:35:20,410
只需要把我们得到的写下来。
just write this down we got.

597
00:35:20,810 --> 00:35:23,180
我们的操作系统是 xv6 ，
Our operating system is xv6,

598
00:35:23,570 --> 00:35:27,800
运行在 RISC-V 微处理器之上，
runs on RISC-V microprocessor

599
00:35:28,220 --> 00:35:30,350
不仅是 RISC-V 微处理器，
and not just RISC-V microprocessor,

600
00:35:30,350 --> 00:35:32,870
还有周围的一些硬件，
but we assume a certain amount of surrounding hardware,

601
00:35:32,870 --> 00:35:35,930
比如内存和磁盘。
like a memory and a disk,

602
00:35:36,280 --> 00:35:40,030
还有控制台界面，我们可以访问它。
and console interface for us to talk to it.

603
00:35:40,740 --> 00:35:46,640
我们实际上是在 QEMU 机器模拟器下运行的。
We actually run under the QEMU machine simulator.

604
00:35:48,440 --> 00:35:50,210
也是在 Linux 下运行的。
So that which runs under Linux.

605
00:35:50,210 --> 00:35:55,860
所以你可以在没有硬件的情况下运行 xv6 。
So all you can actually run xv6 without having that hardware.

606
00:35:56,860 --> 00:36:01,000
好的，现在切换到演示代码。
Okay, so kind of switch to show the code.

607
00:36:15,570 --> 00:36:18,720
好的，那么第一件事是，
Alright, so, first thing is,

608
00:36:18,720 --> 00:36:22,410
我已经在我的笔记本电脑上安装了 xv6 ，
I've setup xv6 on my laptop,

609
00:36:22,800 --> 00:36:25,740
我要运行它，输入 make qemu ，
I'm going to run it type make qemu,

610
00:36:25,740 --> 00:36:28,140
你会在实验中发现做了更多的工作，
but you'll find yourself doing quite a bit during the labs,

611
00:36:28,320 --> 00:36:30,960
它编译 xv6 ，是用 C 编写的，
which compiles xv6 it's written in C,

612
00:36:30,960 --> 00:36:33,480
所以它使用 C 编译器编译，
so it's compiled with C compiler,

613
00:36:33,990 --> 00:36:36,570
我应该先输入 make clean 清理一下，
maybe I'll make clean for you,

614
00:36:36,930 --> 00:36:38,730
这样你们就可以看到实际的编译过程，
so you can see the actual compilation

615
00:36:39,000 --> 00:36:40,620
我再输入 make qemu ，
and I might make qemu,

616
00:36:40,620 --> 00:36:44,820
它开始编译和构建 xv6 内核，
which has the effect of compiling and building xv6 kernel

617
00:36:44,820 --> 00:36:46,470
以及所有用户程序，
and all the user processes

618
00:36:47,010 --> 00:36:49,920
然后在 QEMU 模拟器上运行。
and then running them under the QEMU emulator.

619
00:36:51,860 --> 00:36:53,720
编译过程会花费一些时间。
Takes a moment around the compiles.

620
00:36:55,020 --> 00:36:55,080
好的。
Yeah.

621
00:36:56,000 --> 00:36:59,090
现在我们启动并运行 xv6 ，
And now we're up and running xv6,

622
00:36:59,090 --> 00:37:01,700
你看到的 shell 中的 $ 符号，
and the dollar sign prompt you see as the shell,

623
00:37:02,270 --> 00:37:05,990
shell 是 xv6 的命令行界面，
which is the command line interface to xv6,

624
00:37:05,990 --> 00:37:08,360
仿造 unix 上的 shell 。
modeled after the shell on unix,

625
00:37:08,360 --> 00:37:12,120
也是如果你登录到 Athena 系统，
which is if you log into Athena organization

626
00:37:12,120 --> 00:37:15,750
就像 Athena shell 显示的那样。
and it's it's like the shell that Athena shows you.

627
00:37:18,180 --> 00:37:23,100
xv6 本身很小，它附带了一些使用程序，
Xv6 itself tiny and it comes with a small number of utility programs,

628
00:37:23,130 --> 00:37:25,960
包含比如 ls 程序，
and including for example the ls program

629
00:37:25,960 --> 00:37:31,080
运行 ls ，它会给出一个所有文件的列表，
which about to run run ls and it gives me a list of all the files

630
00:37:31,080 --> 00:37:33,300
xv6 只有二十多个文件，
and xv6 of which there are only about two dozen

631
00:37:34,020 --> 00:37:39,500
包括 grep kill mkdir 和 rm ，
including things like grep and kill and mkdir rm,

632
00:37:39,560 --> 00:37:43,390
这些是我们熟悉的 unix 实用程序。
which may be familiar to us as unix utilities.

633
00:37:44,930 --> 00:37:46,640
好的，我要演示的第一个程序是，
Okay, the first program, I'm gonna show you

634
00:37:46,640 --> 00:37:51,770
演示系统调用 copy ，
to illustrate system calls is a program called copy.

635
00:38:01,900 --> 00:38:03,580
这里的代码只有一页。
Here's the source is just a page.

636
00:38:07,320 --> 00:38:12,120
你在这里看到的程序，从第 8 行开始，
So what you're seeing here is a program that starts on line eight

637
00:38:12,120 --> 00:38:15,150
main 是 C 语言程序的一种约定，
and main is that sort of convention for C programs,

638
00:38:15,510 --> 00:38:17,370
在第 12 行有一个循环，
it sits in a loop at line twelve,

639
00:38:17,940 --> 00:38:19,290
一遍又一遍地
and over and over again,

640
00:38:19,710 --> 00:38:23,820
在第 13 行读取一些数据作为输入，
it reads some data as input and on line thirteen,

641
00:38:23,820 --> 00:38:27,900
然后在第 16 行将刚才读取的数据写入输出。
and then writes the data just read his output on line sixteen.

642
00:38:28,390 --> 00:38:35,550
运行 copy ，在 xv6 中，等待读取输入，
By run copy, in xv6, it's waitng to read input,

643
00:38:35,550 --> 00:38:37,320
如果我输入一些内容，
if I type some input,

644
00:38:37,840 --> 00:38:39,970
它读取并返回给我。
reads it and spits it back up to me.

645
00:38:41,640 --> 00:38:43,410
很简单的程序，只是做输入输出。
Very simple program just does io.

646
00:38:44,950 --> 00:38:48,880
就像我提到的，如果你不是很了解 C 语言，
It's really see as I mentioned, if you don't already know C,

647
00:38:48,880 --> 00:38:50,080
Kernighan 和 Ritchie 编写的
it's worthwhile getting

648
00:38:50,080 --> 00:38:54,820
C 程序设计语言很值得阅读。
the standard C programming language book by Kernighan and Ritchie.

649
00:38:55,180 --> 00:39:00,330
我想在课程网站上有更完整的参考资料，
And I think there's a more full reference to it on the course website

650
00:39:00,840 --> 00:39:05,100
想你解释使用 C 编程的直接方法。
which explains to you and very straightforward way how to program in C.

651
00:39:06,140 --> 00:39:09,200
是的，像我之前提到的，
Yeah, as I mentioned before,

652
00:39:09,200 --> 00:39:10,580
我们编写这个程序，
we even write this program

653
00:39:10,580 --> 00:39:13,070
使用了两个实际上是三个系统调用，
makes two really three system calls

654
00:39:13,070 --> 00:39:15,950
read write exit 系统调用。
read, write and exit, our system calls.

655
00:39:16,460 --> 00:39:19,790
如果你看第 13 行的 read 调用，
If you look at the call to read on line thirteen,

656
00:39:20,090 --> 00:39:21,470
它有三个参数，
it takes three arguments,

657
00:39:22,500 --> 00:39:23,970
第一个参数是一个文件描述符，
the first argument is a file descriptor

658
00:39:23,970 --> 00:39:26,700
它实际上是对之前打开的文件的引用。
which is really a reference to a previously opened file.

659
00:39:27,340 --> 00:39:32,230
shell 确保当程序启动时，
And the shell, ensures that when a program starts,

660
00:39:32,230 --> 00:39:36,860
默认它的文件描述符 0 连接到控制台输入，
by default it's file descriptor zero is connected to the console input

661
00:39:36,860 --> 00:39:41,480
它的文件描述符 1 连接到控制台输出，
and its file descriptor one is connected to the console output

662
00:39:41,480 --> 00:39:46,620
这就是为什么我能对 copy 程序输入，并查看输出。
and that's why I was able to type to this copy program and see the output.

663
00:39:48,700 --> 00:39:52,660
你知道，这些文件描述符期望，
You know these file descriptors are expected

664
00:39:52,660 --> 00:39:55,630
程序期望这些文件描述符已经打开，
the program expected these file descriptors have been previously opened

665
00:39:55,630 --> 00:39:57,160
并由 shell 为其设置。
and set up by the shell for it.

666
00:39:57,600 --> 00:40:03,480
0 1 文件描述符是 unix 的普遍约定，
And zero one file descriptors, pervasive unix convention,

667
00:40:03,480 --> 00:40:05,220
很多 unix 程序希望
many, many unix programs expect to

668
00:40:05,220 --> 00:40:07,440
[误：从文件描述符 1 读取]，
[read from file descriptor one]

669
00:40:07,440 --> 00:40:11,190
读取文件描述符 0 ，并写入文件描述符 1 。
and read file descriptor zero and write to file descriptor one.

670
00:40:12,730 --> 00:40:16,540
read 的第二个参数是一个指向内存的指针。
A second argument to read is a pointer to some memory.

671
00:40:17,160 --> 00:40:19,500
程序告诉操作系统
Where the program is asking the operating system

672
00:40:19,500 --> 00:40:22,710
从这个内存地址读取数据，
to read data into that address in memory,

673
00:40:22,710 --> 00:40:23,970
这是 buf 参数，
so that's the buf argument

674
00:40:24,630 --> 00:40:29,750
在第 10 行，在栈上分配了 64 字节的内存。
and line ten allocate 64 bytes of memory on the stack,

675
00:40:30,350 --> 00:40:31,520
供 read 读取。
for read to read into.

676
00:40:31,700 --> 00:40:33,110
read 的第三个参数是
And the third argument to read is

677
00:40:33,110 --> 00:40:36,080
程序想要读入的最大字节数，
the maximum number of bytes that the program wants to read

678
00:40:36,470 --> 00:40:40,370
而 buf 的大小最大是 64 字节，
and the size of buf as just sixty maximum 64 bytes,

679
00:40:40,730 --> 00:40:42,830
所以 read 读取最多 64 字节，
so the read call reads up to 64 bytes

680
00:40:42,830 --> 00:40:45,860
从文件描述符 0 连接的地方，
from whatever is connected to file descriptor zero

681
00:40:45,860 --> 00:40:48,520
在本例中， 0 就是连接到我的终端。
and that was my terminal in this example,

682
00:40:48,820 --> 00:40:54,190
read 的返回值可能是读取到的字节数，
the return value from read it either it may be sure of the number of bytes read,

683
00:40:54,640 --> 00:40:58,240
这里是 6 ，
which would be six and a piece of,

684
00:40:58,240 --> 00:40:59,740
我输入 xyzzy 。
typing xyzzy by.

685
00:41:01,150 --> 00:41:02,800
read 也可以从文件中读取，
Read might be reading from a file,

686
00:41:02,830 --> 00:41:04,090
如果到达文件末尾，
if it gets to the end of the file,

687
00:41:04,090 --> 00:41:05,110
没有更多字节，
there's no more bytes,

688
00:41:05,110 --> 00:41:06,370
read 将返回 0 。
read will return zero.

689
00:41:07,160 --> 00:41:08,900
如果发生其他错误，
And then some other error occurred,

690
00:41:08,900 --> 00:41:11,180
比如文件描述符不存在，
like the file descriptor doesn't exist,

691
00:41:11,420 --> 00:41:13,160
read 可能会返回 -1 。
read may return minus one.

692
00:41:13,780 --> 00:41:17,560
在很多例子中，比如在第 16 行。
And so in many of these examples like on line sixteen there.

693
00:41:17,940 --> 00:41:23,190
我的示例代码没有检查系统调用返回是否有错误，
I don't, my example code doesn't check system call returns for errors.

694
00:41:24,540 --> 00:41:27,540
但是你应该比我更小心，
But you should be more careful than me,

695
00:41:27,540 --> 00:41:30,750
你应该弄清楚系统调用是如何返回错误的，
the you should figure out how system calls reflect errors,

696
00:41:30,750 --> 00:41:32,640
通常是返回 -1 ，
it's usually a minus one return value

697
00:41:32,970 --> 00:41:36,360
并检查所有系统调用的返回是否有错误。
and check all system called returns for errors.

698
00:41:37,280 --> 00:41:41,360
如果你想知道系统调用参数和返回值是什么，
And if you want to know what the system call arguments and return values are,

699
00:41:41,360 --> 00:41:44,210
这里有一个表格，我想是在书中的第 2 章。
there's a table and I think chapter two in the book,

700
00:41:45,140 --> 00:41:51,810
解释了所有 xv6 系统调用参数和返回值。
explains all of the xv6 system call arguments and return values.

701
00:41:52,770 --> 00:41:55,230
关于 read 系统调用的问题。
The question regarding the read syscall.

702
00:41:55,440 --> 00:41:57,870
如果我们将最大读取字节数
What if we set the max read bytes to

703
00:41:57,870 --> 00:42:01,200
设置为 buf 大小加 1 ，
size of buf to one plus size of buf big,

704
00:42:01,500 --> 00:42:03,030
所以如果我们尝试读取的大小超过该大小会怎样。
so what if we try to read more than the size.

705
00:42:03,030 --> 00:42:06,870
是的，如果有 65 个字节要读取，
Yeah, then if there was 65 bytes to read,

706
00:42:06,900 --> 00:42:09,330
操作系统会很高兴地
then the operating system would happily

707
00:42:09,330 --> 00:42:14,750
把这 65 个字节复制到你提供的内存上，
will just copy those sixty-five bytes to the memory that you provide,

708
00:42:14,780 --> 00:42:18,020
当然还有栈上的其他东西，
and of course there's something else on the stack up there,

709
00:42:18,050 --> 00:42:20,150
可能是返回程序计数器，
maybe the return program counter

710
00:42:20,150 --> 00:42:21,410
或者参数或其他东西，
or an argument or something

711
00:42:21,560 --> 00:42:23,570
所以如果你传入 65 个字节，
and so if you pass 65,

712
00:42:23,930 --> 00:42:25,460
那么你就是让内核
then you're inviting a kernel

713
00:42:25,460 --> 00:42:29,550
在栈上意想不到的位置写入垃圾数据。
to write junk to an unexpected place in your stack.

714
00:42:30,280 --> 00:42:31,360
因此，这是一个 bug ，
And so that's a bug

715
00:42:31,840 --> 00:42:33,940
它可能会导致你的程序崩溃。
and it may cause your [] to crash,

716
00:42:34,420 --> 00:42:36,340
或者做一些其他意想不到的事情，
or do something else unexpected,

717
00:42:37,390 --> 00:42:39,580
因此作为一个程序员，在这里必须小心，
so as a programmer, you have to be careful here,

718
00:42:39,580 --> 00:42:42,940
没有人使用 C 语言这样使用接口，
there's nobody writing in C with these kind of interfaces,

719
00:42:43,830 --> 00:42:46,890
很容易编写的代码，
it's very very easy to write code

720
00:42:46,920 --> 00:42:49,200
编译器可以通过，并且可以运行，
that the compiler is happy with and will run

721
00:42:49,200 --> 00:42:51,000
但是做的是错误的事。
but absolutely does the wrong thing.

722
00:42:51,660 --> 00:42:57,120
那太糟糕了，但事情就是这样。
So that's too bad but it's the way it is.

723
00:43:00,540 --> 00:43:02,490
好的，有一件事需要注意，
Okay, one thing to note is

724
00:43:02,490 --> 00:43:06,450
这里的 copy 程序和 read write 系统调用，
that this copy program and indeed the read write system calls,

725
00:43:06,720 --> 00:43:08,460
它们不关心数据的格式，
they don't care about the format of data,

726
00:43:08,460 --> 00:43:09,480
它们读写，
they're reading or writing

727
00:43:09,660 --> 00:43:13,440
只是在 copy 程序中读写，再读写。
they just read and write read and write in this copy program.

728
00:43:13,980 --> 00:43:17,340
只是处理八位字节，使用八位字节流。
Just deal with eight bit bytes with screams of eight bit bytes.

729
00:43:17,680 --> 00:43:21,220
如何解释它们，完全取决于应用程序。
How you interpret them is totally up to the application,

730
00:43:21,220 --> 00:43:26,840
应用程序可能会解析数据记录作为 C 代码，
so the application maybe parse these data records or as C source code,

731
00:43:26,840 --> 00:43:27,680
或者其他的格式。
or who knows what.

732
00:43:28,890 --> 00:43:35,460
操作系统只知道这是八位字节流。
The operating system, the only things in terms of a stream of eight bit bytes.

733
00:43:36,220 --> 00:43:39,940
好的，所以 copy 可以假设
Okay, so copy, assumed this code, my copy I can assume

734
00:43:39,940 --> 00:43:42,670
文件描述符已经设置好，
that the file descriptors are already set up,

735
00:43:42,850 --> 00:43:46,000
但是我们需要有一种方法来创建文件描述符。
but we need to need to have a way to create file descriptors.

736
00:43:46,280 --> 00:43:51,680
创建文件描述符的最直接的方法是使用 open 系统调用，
And the most straightforward way to do that is with the open system call,

737
00:43:51,710 --> 00:43:55,160
这是一个调用 open 的程序代码，
and so here's the source for a program that called open,

738
00:43:55,720 --> 00:43:56,920
那个，
That,

739
00:43:58,120 --> 00:43:59,770
我使用 open 系统调用。
I use the open system call.

740
00:44:00,250 --> 00:44:01,570
聊天中有一个问题，
A question from the chat,

741
00:44:01,600 --> 00:44:04,570
你说的字节流是什么意思。
what do you mean by a stream of bytes.

742
00:44:07,190 --> 00:44:11,840
我的意思是如果一个文件包含一些字节，
I I just mean that if a file contains a bunch of bytes,

743
00:44:12,180 --> 00:44:16,470
然后读取连续一百万字节的内容，
then read then successive spilling a pile contains a million bytes,

744
00:44:16,860 --> 00:44:19,200
如果你进行连续的 read 调用，
if you make a sequence of read calls,

745
00:44:19,200 --> 00:44:20,670
每次 100 字节，
each for 100 bytes,

746
00:44:21,160 --> 00:44:22,900
你知道，只会读取第一个 100 字节，
you know I'll just read the first hundred bytes

747
00:44:22,900 --> 00:44:24,100
然后是第二个 100 字节，
and then the second hundred bytes and

748
00:44:24,100 --> 00:44:25,810
然后是第三个 100 字节。
then third, the third hundred bytes,

749
00:44:27,960 --> 00:44:28,590
就是这样。
That's all.

750
00:44:32,000 --> 00:44:36,020
好的，那么这个程序调用 open ，我来运行它，
Alright, so this program, called open, I'll run it for you.

751
00:44:36,720 --> 00:44:41,940
它所做的是创建一个名为 output.txt 的新文件，
What it does is open creates a new file called output.txt,

752
00:44:41,940 --> 00:44:43,980
然后向其中写入一些字节，
and then write some bytes to it,

753
00:44:44,520 --> 00:44:45,690
我已经完成了这个操作，
I'm gonna finish this,

754
00:44:45,690 --> 00:44:46,620
但是我们看不到任何东西，
so we don't see anything,

755
00:44:46,620 --> 00:44:48,690
因为它将数据放到了这个文件中，
because it broke data, this file,

756
00:44:48,690 --> 00:44:53,100
但是我们可以查看它创建的 output.txt 文件，
open, but we can look this output.txt file that created it,

757
00:44:53,490 --> 00:44:57,240
可以看到 ooo 写在那里。
and see the "ooo" wrote there,

758
00:44:57,390 --> 00:45:02,020
程序中的第 11 行调用了 open 系统调用，
so an eleven in the program makes the open system call,

759
00:45:02,380 --> 00:45:04,750
给它一个文件名 output.txt ，
give it a filename output.txt

760
00:45:04,750 --> 00:45:10,240
open 中第二个参数中的 O_ 选项或标志，
and the O underscore stuff in the second argument to open or flags

761
00:45:10,240 --> 00:45:13,930
告诉内核中实现的 open 系统调用，
that tell the open system call implementation in the kernel,

762
00:45:13,930 --> 00:45:17,590
我们想要使用这个名字创建一个文件，并且写入。
that we'd like to create a file with its name and we're going to write it,

763
00:45:18,860 --> 00:45:21,710
open 返回新分配的文件描述符。
open returns a newly allocated file descriptor.

764
00:45:23,740 --> 00:45:25,600
文件描述符只是一个很小的数字，
And the file descriptor is just a small number,

765
00:45:25,810 --> 00:45:27,400
可能是 2 3 或 4 等。
probably two or three or four something.

766
00:45:28,430 --> 00:45:32,270
然后我们将相同的文件描述符与缓冲区一起传递，
And then we pass that same file descriptor right along with the buffer

767
00:45:32,270 --> 00:45:36,410
有多种方式写入数据，
and a number of ways to write that writes data,

768
00:45:37,040 --> 00:45:39,770
对于文件描述符索引用的文件。
the file, the file descriptor refers to.

769
00:45:41,430 --> 00:45:43,860
文件描述符实际上做的是
What that file descriptor is actually doing is

770
00:45:43,860 --> 00:45:49,410
索引到内核中一个维护进程状态的表中，
indexing into a little table inside the kernel maintains state for each process,

771
00:45:49,410 --> 00:45:52,620
就是你运行的每个程序，
that's running each program that you run and among other things,

772
00:45:52,620 --> 00:45:56,010
内核为每个进程记住一张表，
the kernel remembers a table for every running process

773
00:45:56,010 --> 00:45:58,500
（表中）通过文件描述符进行索引，
of index by file descriptors

774
00:45:58,830 --> 00:46:03,420
这张表告诉内核每个文件描述符引用的是什么。
and the table sort of tells the kernel what each file descriptor refers to.

775
00:46:05,040 --> 00:46:10,960
好的，关键点是每个进程
Okay, a critical point is that each process

776
00:46:10,960 --> 00:46:14,350
都有自己的文件描述符空间。
has its own sort of space of file descriptors.

777
00:46:14,350 --> 00:46:17,420
因此，在运行两个不同的进程前，
So, before running two different processes,

778
00:46:17,420 --> 00:46:19,460
两个不同的程序，
two different programs and different processes

779
00:46:19,640 --> 00:46:20,990
它们都会打开一个文件，
and they both open a file,

780
00:46:20,990 --> 00:46:24,080
它们可能会得到相同的文件描述符编号，
they may actually get the same number back as a file descriptor,

781
00:46:24,350 --> 00:46:28,700
但是因为内核为每个进程维护单独的文件描述符，
but because the kernel maintains a separate file descriptor for each process,

782
00:46:29,080 --> 00:46:31,750
所以相同的文件描述符号
The same file descriptor number may refer to

783
00:46:31,750 --> 00:46:34,570
在不同的进程中可能引用不同的文件。
different files in different processes.

784
00:46:37,040 --> 00:46:39,350
关于 open 程序，有什么问题吗？
Any questions that open about this little program.

785
00:46:40,240 --> 00:46:41,620
在聊天中有一个问题，
Now we had a question in the chat,

786
00:46:41,620 --> 00:46:43,720
一个不熟悉 C 语言的人提出的问题，
question from someone not familiar with C,

787
00:46:43,990 --> 00:46:47,830
这些文件和普通的 C 程序有什么不同，
how are these files being described different from normal C programs,

788
00:46:47,830 --> 00:46:50,470
是不是因为我们只使用内核调用，
is it because we're only using kernel calls,

789
00:46:50,470 --> 00:46:53,710
也就是说，我们能不能用 python 打开或写入文件。
i.e couldn't we also open or write a file in python.

790
00:46:59,440 --> 00:47:00,820
我想我不明白的是，
I don't think I understand that,

791
00:47:02,000 --> 00:47:04,160
它是一个 C 程序，打开或写入一个文件。
it's a C program, that's opening and writing a file,

792
00:47:15,620 --> 00:47:17,750
然后继续下去。
that's going to move on.

793
00:47:20,640 --> 00:47:26,310
好的，你可能问的是。
Alright so you might ask what actually happens when.

794
00:47:26,310 --> 00:47:27,570
也许问题是，
Maybe the question is

795
00:47:27,570 --> 00:47:30,120
当使用 C 语言做这件事，
when someone is doing it in C,

796
00:47:30,120 --> 00:47:33,090
除了语法，与使用 python 有什么不同。
any different than doing it in python minus the syntax.

797
00:47:34,240 --> 00:47:37,810
它不是。
Well it's not really, um.

798
00:47:38,620 --> 00:47:42,840
当然也有办法。
And, there's certainly ways to, um.

799
00:47:44,410 --> 00:47:49,480
Python 提供了良好的函数调用，打开文件或做这些事。
Python provides nice function calls for opening and doing all these things too.

800
00:47:50,830 --> 00:47:54,040
打开文件，比如读写文件，
Or opening files, for example in reading writing files,

801
00:47:54,310 --> 00:47:58,540
通常有一个层级比较高的函数，
there's a layer of a higher somewhat higher level functions typically,

802
00:47:58,870 --> 00:48:01,660
比如，没有指向内存的指针。
not pointers the memory, for example.

803
00:48:03,690 --> 00:48:06,420
Python 也为你提供了更多的错误检查，
And python has more error checking for you,

804
00:48:07,140 --> 00:48:09,840
但是当你在 python 中打开文件，
but when you open a file in python

805
00:48:09,840 --> 00:48:11,010
或在 python 中写文件，
or write a file on python,

806
00:48:11,010 --> 00:48:17,840
python 调用底层的系统调用。
the python calls you make boil down to system calls just like these.

807
00:48:19,840 --> 00:48:21,220
这个答案怎么样。
Is that a good answer.

808
00:48:25,860 --> 00:48:26,520
我想是的。
Think so.

809
00:48:27,030 --> 00:48:27,420
好的。
Alright.

810
00:48:30,980 --> 00:48:32,270
好的。
Alright.

811
00:48:33,560 --> 00:48:36,350
我在这里讨论，
I've been over here talking to the,

812
00:48:39,120 --> 00:48:43,140
xv6 是 unix ，比如 shell ，
xv6 is unix, like shell

813
00:48:43,440 --> 00:48:46,500
shell 人们也经常称作命令行接口，
and the shell is what people often call the command line interface,

814
00:48:46,890 --> 00:48:50,610
相对更图形化的用户界面。
as opposed to more graphical user interface.

815
00:48:51,240 --> 00:48:53,370
shell 是，
The shell turns,

816
00:48:53,370 --> 00:48:54,450
如果你没有用过 shell ，
if you haven't used the shell,

817
00:48:54,450 --> 00:48:57,450
shell 是一个非常有用的界面，
the shell turns out to be a pretty useful interface

818
00:48:57,450 --> 00:49:00,270
对于 unix 系统的系统管理，
for things like system management of unix systems,

819
00:49:01,440 --> 00:49:02,940
他提供了很多实用程序，
it provides a lot of utilities

820
00:49:02,940 --> 00:49:06,480
来处理文件，开发程序，
for messing around with files and for program development

821
00:49:06,480 --> 00:49:09,510
以及编写脚本来完成这些事。
and on writing scripts to do all these things.

822
00:49:09,510 --> 00:49:12,030
所以在继续之前。
So, some before run.

823
00:49:12,550 --> 00:49:14,620
我想演示几个 shell 功能，
I just want to demonstrate a few shell features.

824
00:49:14,650 --> 00:49:17,290
当你输入东西的时候，
Ordinarily, when you type things,

825
00:49:17,770 --> 00:49:20,080
你在高数 shell 运行一个程序，
you're telling the shell to run a program,

826
00:49:20,080 --> 00:49:21,100
所以当我输入 ls ，
so when I type ls,

827
00:49:21,100 --> 00:49:26,790
我的意思是要求 shell 运行名为 ls 的程序，
what that means is I'm asking the shell to run the program whose name is ls

828
00:49:26,790 --> 00:49:28,290
这真正的含义是
and what that really means is

829
00:49:28,290 --> 00:49:31,710
在文件系统中，有一个叫做 ls 的文件
there's a file in the file system called ls,

830
00:49:31,710 --> 00:49:34,890
它包含一些指令，一些机器指令，
that contains some instructions, some machine instructions

831
00:49:35,250 --> 00:49:40,170
我要求 shell 运行 ls 文件中的这些指令，
and I'm asking the shell to run the instructions that are in the file called ls,

832
00:49:40,770 --> 00:49:44,430
现在 ls 真正做的是，
ls, now ls what it actually does is,

833
00:49:44,940 --> 00:49:47,220
获取当前目录中的文件列表，
get a listing of the files in the current directory,

834
00:49:47,250 --> 00:49:49,230
你可以在上面的第 4 行看到，
and you can see up there on the fourth line,

835
00:49:49,620 --> 00:49:54,420
同其他文件一起， ls 也是存在的。
that among the other files that ls as exists,

836
00:49:54,420 --> 00:49:55,380
这个列表，
and this list is,

837
00:49:55,380 --> 00:49:57,660
一个叫做 ls 的文件，
a file called ls which is in fact

838
00:49:58,140 --> 00:50:00,120
the file containing the instructions I just ran.

839
00:50:02,370 --> 00:50:05,340
除了运行程序， shell 还为你做了其他事情，
The shell does a few other things for you other than running programs

840
00:50:06,360 --> 00:50:08,160
还允许你重定向 IO ，
allows you to redirect io,

841
00:50:08,490 --> 00:50:11,040
比如，如果我输入 ls > out ，
so for example if I say ls greater than out,

842
00:50:11,100 --> 00:50:14,670
意思是要求 shell 运行 ls 命令，
what that means is asking the shell run the ls command,

843
00:50:15,030 --> 00:50:17,940
但将其输入重定向到名为 out 的文件。
but with its output redirected to the file called out.

844
00:50:18,520 --> 00:50:22,130
我运行 ls ，我们看不到任何输出，
I run ls, we don't see any output,

845
00:50:22,340 --> 00:50:23,840
因为输出都重定向了。
because the output all went out.

846
00:50:24,960 --> 00:50:28,380
现在 out 包含一些数据，
Now, I can, out contains a bunch of data,

847
00:50:28,530 --> 00:50:30,090
我们可以，
we could,

848
00:50:30,900 --> 00:50:35,430
cat 命令读取文件并显示其中的内容，
the cat command reads a file and displays the contents of the file,

849
00:50:35,430 --> 00:50:36,720
我输入 cat out 。
so I say cat out.

850
00:50:37,190 --> 00:50:40,790
可以看到这和 ls 的输出是一样的。
Just going to see now the now this is the same output of ls.

851
00:50:41,170 --> 00:50:42,790
You can also run a command like grep

852
00:50:42,790 --> 00:50:46,060
我给它一个参数 x ， grep x 。
and I can give it an argument x and what grep x.

853
00:50:46,520 --> 00:50:48,440
grep 命令通过模式搜索。
The grep command searches for patterns.

854
00:50:49,080 --> 00:50:52,830
同样的，如果我运行 grep x ，
Again if I run grep x,

855
00:50:52,830 --> 00:50:57,050
它会搜索包含 x 的输入行，
it's gonna search for lines of input to contain x,

856
00:50:57,380 --> 00:50:58,250
我也可以重定向，
I can redirect,

857
00:50:58,250 --> 00:51:01,190
告诉 shell 把 grep 的输入重定向到 out 文件。
tell the shell to redirect its input from the file out.

858
00:51:01,700 --> 00:51:05,720
用来查找保存 ls 结果中的 x 实例。
In order to look for instances of x that saved ls output.

859
00:51:07,150 --> 00:51:11,920
结果是这里有三个文件包含 x 。
It turns out there's three files whose names contain x.

860
00:51:14,000 --> 00:51:14,630
嗯。
Um.

861
00:51:15,560 --> 00:51:17,420
我们花一些时间在 shell 上，
We're going to spend a bunch of time with the shell,

862
00:51:17,450 --> 00:51:26,540
shell 是 unix 的一种最传统和最基本的接口，
its shell is sort of the most traditional and fundamental interface of unix,

863
00:51:26,540 --> 00:51:28,250
因为在 unix 最初开发的时候，
because when unix was first developed,

864
00:51:28,250 --> 00:51:30,860
所有的都是简单的终端接口。
all there was was simple terminal interfaces,

865
00:51:30,860 --> 00:51:32,540
比如我们现在使用的，
like the one we're using

866
00:51:32,540 --> 00:51:36,290
unix 最初的主要用途是分时共享，
and the main use of unix originally was time sharing,

867
00:51:36,290 --> 00:51:38,510
许多人同时登录到一台机器上，
a bunch of people logging into the same machine,

868
00:51:38,540 --> 00:51:41,780
很像 Athena ，使用 shell 交互。
much like Athena and talking to shells.

869
00:51:43,300 --> 00:51:47,650
有一个关于系统调用和编译器的问题，
A question about system calls and the compiler,

870
00:51:47,860 --> 00:51:49,750
编译器如何处理系统调用，
how does the compiler handles system calls,

871
00:51:49,750 --> 00:51:52,030
是由汇编语言
does assembly generated make a procedure call

872
00:51:52,030 --> 00:51:55,210
对操作系统定义的一些代码段做过程调用吗？
to some code segment, defined by the operating system.

873
00:51:57,020 --> 00:51:59,780
有一个特殊的 RISC-V 指令，
There's a special RISC-V instruction,

874
00:51:59,780 --> 00:52:02,750
程序可以调用它将控制权转到到内核，
that a program can call that transfers control under the kernel,

875
00:52:02,840 --> 00:52:06,350
所以当你编写 C 代码，调用系统调用，
so indeed when you write C code that makes the system call,

876
00:52:06,350 --> 00:52:08,060
比如 open write ，
like open and write

877
00:52:08,600 --> 00:52:14,150
实际上是 open 是 C 库中的一个 C 函数，
and technically what actually happens is open is a C function in the C library,

878
00:52:14,620 --> 00:52:19,630
但是这个函数中的指令实际上是及其指令，
but the instructions in that function are really machine instructions,

879
00:52:19,630 --> 00:52:24,280
它不是 open ， open 函数不是一个 C 函数，
it's not open, the open function that we calling isn't a C function,

880
00:52:24,490 --> 00:52:25,720
而是由汇编语言实现，
implemented in assembler

881
00:52:25,960 --> 00:52:30,980
在 RISC-V 中，汇编语言的
and the assembly code consists of

882
00:52:30,980 --> 00:52:35,010
这个特殊指令叫做 ecall ，
this special instructions actually called ecall, on RISC-V,

883
00:52:35,010 --> 00:52:38,450
这个特殊指令转移控制权到内核中，
the special instruction that transfers control into the kernel,

884
00:52:38,900 --> 00:52:42,290
然后内核查看进程内存和寄存器，
and then the kernel looks at the processes memory and registers

885
00:52:42,290 --> 00:52:44,890
找出参数是什么。
to figure out what the arguments were.

886
00:52:50,610 --> 00:52:56,850
好的，下一个例子，我想看的程序是 fork 。
Alright the next example, I want to look at is example program that calls fork.

887
00:52:58,420 --> 00:53:04,690
创建进程，这是很简单的 fork 的应用，
Creating process, so this is the very simple use of fork,

888
00:53:04,690 --> 00:53:06,940
在第 12 行，我们调用了 fork ，
at line twelve we're calling fork

889
00:53:06,940 --> 00:53:08,170
fork 所做的是，
and what fork does is

890
00:53:08,670 --> 00:53:14,490
创建一个调用进程的指令和数据的内存的复制，
creates a copy of the memory of instructions and data of the calling process,

891
00:53:14,490 --> 00:53:17,430
现在我们有两个使用相同内存的进程。
now we have two processes with identical memory.

892
00:53:18,010 --> 00:53:21,760
fork 系统调用在两个进程中都会返回，
Fork the fork system call returns in both processes,

893
00:53:22,360 --> 00:53:23,920
在原始进程中，
in the original process,

894
00:53:24,430 --> 00:53:27,130
fork 返回进程 id ，
the fork system call returns the process id

895
00:53:27,130 --> 00:53:30,640
它是一个大于零的整数，
which is a an integer greater than zero,

896
00:53:32,100 --> 00:53:36,240
原始进程中， fock 返回的是新创建进程的进程 id ，
the original process fork returns the process id of the newly created process

897
00:53:36,750 --> 00:53:40,590
而在新进程中， fock 返回 0 。
and in the newly created process fork returns a zero.

898
00:53:41,630 --> 00:53:44,660
所以即使两个进程有相同的内存，
So we sort of break even though the processes have identical memory,

899
00:53:45,230 --> 00:53:47,270
你也可以通过
you can break the symmetry of

900
00:53:47,720 --> 00:53:50,570
fork 的返回值区分它们。
old versus new process by the return value from fork.

901
00:53:50,940 --> 00:53:54,660
在第 16 行，你可以看到代码检查并判断，
And in line sixteen, you can see code checks and say

902
00:53:54,660 --> 00:53:57,150
如果进程 id 等于 0 ，就是子进程，
if the process id is equal zero must be the child,

903
00:53:57,180 --> 00:53:58,710
肯定是在子进程中运行。
you must now be running in the child.

904
00:53:59,420 --> 00:54:01,640
当然这里有两个进程，
Of course there's two processes,

905
00:54:01,640 --> 00:54:04,670
在另一个进程，调用进程中，
in the other process, in the calling process,

906
00:54:04,670 --> 00:54:08,240
称为父进程，返回的进程 id 大于 0 。
which is usually called the parent, process id is greater than zero.

907
00:54:08,640 --> 00:54:13,230
所以子进程会输出 child ，而父进程会输出 parent 。
So the child will print child and the parent will print parent,

908
00:54:14,350 --> 00:54:16,480
然后它们都会退出。
and then they'll both exit.

909
00:54:16,810 --> 00:54:17,890
我运行 fork ，
So when I run fork,

910
00:54:19,380 --> 00:54:24,300
我们可以得到，它看起来像是乱码。
now here we get, so it may look like garbage.

911
00:54:25,230 --> 00:54:26,310
实际发生的是，
What's actually happening is

912
00:54:26,310 --> 00:54:29,190
在调用 fork 之后，两个进程都会运行，
that after the fork, both of these processes are running,

913
00:54:29,220 --> 00:54:30,900
它们同时运行，
they're both running at the same time

914
00:54:31,080 --> 00:54:36,890
QEMU 为我真正模拟了多核微处理器，
and QEMU is actually emulating a multi core microprocessor for me,

915
00:54:36,890 --> 00:54:40,280
所以实际上它们是几乎是同时运行的，
so they really are running at the very same time,

916
00:54:40,280 --> 00:54:41,450
所以当它们产生输出时，
so when they produce output,

917
00:54:41,850 --> 00:54:43,620
它们产生每个字节，
they're producing each byte of their output

918
00:54:43,620 --> 00:54:45,390
与另一个进程一起，
at the same time as the other process is,

919
00:54:45,390 --> 00:54:47,220
产生输出对应的字节，
producing the corresponding bytes of its output,

920
00:54:47,670 --> 00:54:51,690
所以两个进程的输出是交错的。
so the output of the two processes are interleave.

921
00:54:52,260 --> 00:54:54,330
你可以看到它们都会输出 f ，
You can see that they're both typing f,

922
00:54:54,800 --> 00:54:57,050
它们都会从 fork 返回。
they're both gonna type for return.

923
00:54:57,800 --> 00:54:59,720
所以你可以看到两个 f ，
So you can see the f from both of them,

924
00:54:59,720 --> 00:55:02,180
两个 o ，两个 r ，等等。
in the o both of them and they r both and so on.

925
00:55:02,920 --> 00:55:03,790
其中之一，
One of them,

926
00:55:04,700 --> 00:55:07,460
你可以看到第一行末尾的 0 ，
you can see the zero at the end of that first line is,

927
00:55:07,880 --> 00:55:09,740
子进程会返回 0 。
in the child for return zero.

928
00:55:10,100 --> 00:55:14,480
我猜父进程应该返回 19 ，
I'm guessing that the parent fork return nineteen,

929
00:55:14,960 --> 00:55:17,510
这是子进程的进程 id 19 ，
that is the child's process id nineteen,

930
00:55:17,810 --> 00:55:20,510
在 xv6 中，意味着是系统启动以来
under xv6, that basically means the nineteenth process

931
00:55:20,510 --> 00:55:22,250
创建的第 19 个进程。
that was created since boot.

932
00:55:22,860 --> 00:55:25,500
其中之一，输出 child ，
And then one of them prints child

933
00:55:25,890 --> 00:55:27,870
你可以看到 c h i l d ，
and you can see the c h i l d,

934
00:55:27,870 --> 00:55:30,120
与另一个交互显示，另一个输出 parent 。
interleave with that is the other one print parent.

935
00:55:30,670 --> 00:55:34,520
是的，这是 fork 的一种愚蠢的用法，
So, yeah, this is a silly use of fork,

936
00:55:34,550 --> 00:55:37,310
但是我们可以在这个输出中清楚地看到，
but we can see vividly in this output

937
00:55:37,310 --> 00:55:39,290
它创建了两个进程。
that has created two processes that are.

938
00:55:39,920 --> 00:55:42,110
并且它们都在运行，
And both of them are running for returning

939
00:55:42,110 --> 00:55:43,520
返回的两个进程都在运行，
both processes and they're both running.

940
00:55:44,710 --> 00:55:47,410
但要注意的是一个输出 child ，另一个输出 parent ，
But also note that one printed child and the other parent,

941
00:55:48,490 --> 00:55:53,150
这很重要， fork 返回的两个进程不同。
so it's important that fork returns differently and the two processes.

942
00:55:59,680 --> 00:56:01,390
有一个提问，
Question,

943
00:56:01,390 --> 00:56:05,290
fork 返回的子进程总是和父进程一样，
the child process as a result of fork always identical to the parent process

944
00:56:05,290 --> 00:56:06,400
它们会不一样吗？
or could they be different.

945
00:56:08,250 --> 00:56:13,260
在 xv6 中，是一样的，
In xv6 are identical,

946
00:56:13,740 --> 00:56:16,830
除了 fork 的返回值。
except the return value from fork.

947
00:56:17,260 --> 00:56:18,880
你知道指令是相同的，
You know the instructions are the same,

948
00:56:18,880 --> 00:56:21,850
数据是相同的，栈也是相同的，
that data is the same, the stack is the same,

949
00:56:22,090 --> 00:56:27,560
两个进程
also both processes, the process copies

950
00:56:27,560 --> 00:56:31,210
都有自己不同的地址空间，
and they both have their own separate address spaces,

951
00:56:31,210 --> 00:56:35,530
它们都认为自己的内存从 0 开始，
that is they both have they both think that their memory starts at zero

952
00:56:35,530 --> 00:56:36,820
并向上增长，
and goes on up from there,

953
00:56:37,400 --> 00:56:43,600
但是其实是不同的内存。
but it's different it's different different memory, with the two of them.

954
00:56:45,030 --> 00:56:46,680
在一个更复杂的操作系统中，
In a more sophisticated operating system,

955
00:56:46,680 --> 00:56:51,030
有一些细节，我们并不关心，
there are some details which we definitely don't care about them,

956
00:56:51,060 --> 00:56:54,180
它们可能偶尔导致父进程与子进程不同，
they may occasionally cause parent and child to differ,

957
00:56:54,210 --> 00:56:56,580
但在 xv6 中，除了返回值，都是相同的。
but in xv6, they're the same except the return value.

958
00:56:57,880 --> 00:56:59,410
所以内存是相同的，
So the memory is the same,

959
00:56:59,410 --> 00:57:04,530
另外，文件描述符表是复制的。
in addition the file descriptor table is copied.

960
00:57:05,260 --> 00:57:08,680
所以，如果父进程打开一些文件，
So if the parent had some files open,

961
00:57:09,140 --> 00:57:13,220
子进程也会看到一组相同的文件描述符。
and the child sees the same set of file descriptors.

962
00:57:13,800 --> 00:57:15,840
虽然子进程看到的是
Although the child is seeing them

963
00:57:15,840 --> 00:57:19,640
复制的文件描述符信息表。
in a copy of the table of file descriptor information.

964
00:57:21,550 --> 00:57:23,710
我们随后会看到，这是很重要的，
And so we'll see in a moment, that it's quite important

965
00:57:23,710 --> 00:57:29,140
fork 复制打开的文件描述符表和内存。
that a fork copies the table of open file descriptors as well as the memory.

966
00:57:31,340 --> 00:57:34,980
好的， fork 创建一个新进程，
Okay, so fork creates a new process,

967
00:57:34,980 --> 00:57:38,250
当我们在 shell 中运行东西时，
but when we run stuff in the shell,

968
00:57:39,030 --> 00:57:42,960
shell 实际上创建了一个新进程来运行你输入的命令。
the shell indeed creates a new process to run each command that you type,

969
00:57:43,320 --> 00:57:45,120
但它需要在其中运行命令，
but it needs to actually run the command in it,

970
00:57:45,330 --> 00:57:46,890
所以如果我输入 ls ，
so if I type ls,

971
00:57:47,160 --> 00:57:50,790
我们需要 shell fork 创建一个新进程运行 ls ，
we need to shell forks to create a process to run ls,

972
00:57:50,790 --> 00:57:55,360
但是这个新进程需要一些方法，
but there needs to be some way for that new process

973
00:57:55,360 --> 00:57:57,910
来实际运行 ls 程序中的指令。
actually run the instructions from the ls program.

974
00:57:58,510 --> 00:58:00,970
这些命令下面是 ls ，
Below those instructions from the file called ls

975
00:58:02,320 --> 00:58:04,690
我马上给你们演示一下示例程序。
and the example program, I'm gonna show you in a minute.

976
00:58:05,320 --> 00:58:06,310
使用 echo ，
Uses echo,

977
00:58:06,310 --> 00:58:08,860
echo 是一个很简单的命令，
echo is a very simple command,

978
00:58:09,070 --> 00:58:11,080
只是获取你传递的参数，
just takes whatever arguments you pass to it

979
00:58:11,080 --> 00:58:12,580
然后把它们写到它的输出中。
and writes them to its output.

980
00:58:13,860 --> 00:58:16,470
我准备了一个程序，叫做 exec 。
And I prepared for you a programme called exec.

981
00:58:22,880 --> 00:58:28,390
Which a run, which makes the exec system call,

982
00:58:28,390 --> 00:58:32,350
使用你指定的文件中
which replaces the calling process with the instructions

983
00:58:32,350 --> 00:58:35,440
读取的指令替换调用的进程。
read from a particular file, you specify.

984
00:58:37,110 --> 00:58:39,210
从文件中加载指令，
Loads the instructions from that file

985
00:58:39,240 --> 00:58:42,720
覆盖当前进程，丢弃当前内存，
over the current process and discarding its current memory

986
00:58:42,990 --> 00:58:45,600
然后执行这些指令，
and then starts executing those instructions,

987
00:58:45,600 --> 00:58:49,500
所以 exec 系统调用， exec 在第 12 行，
so the call to exec system call exact on line twelve,

988
00:58:52,620 --> 00:58:53,880
它的效果是，
it's going to have the effect of

989
00:58:53,940 --> 00:58:57,600
操作系统从 echo 文件中加载指令。
the operating system loading the instructions from the file called echo.

990
00:58:57,980 --> 00:59:02,360
在当前进程中，替换当前进程的内存，
In the current process sort of replacing the memory of the current process

991
00:59:02,690 --> 00:59:06,340
然后开始执行那些指令，
and then starting to execute those instructions

992
00:59:06,340 --> 00:59:09,550
并且，你可以传递参数，
and in addition, you can pass arguments command line arguments,

993
00:59:09,550 --> 00:59:13,960
echo exec 允许你传递一组命令行参数。
echo exec allows you to pass an array of command line arguments.

994
00:59:14,670 --> 00:59:16,620
它只是 C 语言中的一组指针，
It was just an array of pointers in C,

995
00:59:17,040 --> 00:59:20,860
第 10 行设置了一组字符指针，
line ten sets up an array of character pointers,

996
00:59:20,860 --> 00:59:22,180
本质上就是字符串，
which are essentially strings

997
00:59:22,600 --> 00:59:24,580
并且将该数组初始化为，
and initialize that array to be,

998
00:59:25,040 --> 00:59:29,120
包含字符串 echo this is echo 。
to contain the strings echo this is echo.

999
00:59:29,480 --> 00:59:32,360
这相当于从命令行运行 echo ，
And that's equivalent to calling running echo command

1000
00:59:32,360 --> 00:59:34,170
使用这三个参数。
and with the three arguments,

1001
00:59:34,170 --> 00:59:34,920
这是 echo 。
this is echo.

1002
00:59:35,340 --> 00:59:41,980
当我运行 exec ，实际上，我看到这个输出 this is echo ，
And so when I run exec, indeed, I see this output, this is echo,

1003
00:59:41,980 --> 00:59:45,670
即使我运行 exec 命令，
but even though I ran the exec command exec program,

1004
00:59:45,980 --> 00:59:49,370
exec 程序说做的是调用 exec 系统调用，
what the exec program does is calling the exec system call

1005
00:59:49,490 --> 00:59:50,900
将其自身替换为 echo ，
to replace itself with echo

1006
00:59:51,080 --> 00:59:52,880
所以它实际上就是 echo 程序，
and so it was really the echo program,

1007
00:59:53,320 --> 00:59:55,000
产生这个输出。
producing this output.

1008
00:59:58,600 --> 01:00:02,920
关于 exec 系统调用，有一点很重要，
And something about the exec system call, that's important for us is that

1009
01:00:03,280 --> 01:00:08,170
exec 保留了当前文件描述符表，
it exec preserves the current table of file descriptors,

1010
01:00:08,380 --> 01:00:12,940
所以 exec 之前引用的文件描述符 0 1 2 等，
so whatever file descriptor zero one two etc were referred to before exec,

1011
01:00:13,240 --> 01:00:17,170
它们在新程序中也引用相同的东西。
they refer to the same thing in this new program,

1012
01:00:17,670 --> 01:00:18,990
我们已经加载了新程序的指令。
whose instructions we've loaded.

1013
01:00:20,220 --> 01:00:23,370
另一点是，原始的 exec 不会返回，
Another point is that ordinarily exec does not return,

1014
01:00:23,610 --> 01:00:28,440
因为 exec 完全替换了当前进程内存，
because exec replaces the current processes memory entirely,

1015
01:00:28,530 --> 01:00:30,540
没有什么东西让 exec 返回，
there's nothing for exec to return,

1016
01:00:30,540 --> 01:00:32,340
对于 exec ，
to exec you know,

1017
01:00:32,990 --> 01:00:35,240
读取文件中的指令，并执行它们，
read the instructions for that file and execute them

1018
01:00:35,240 --> 01:00:36,020
就是这样，
and then that's it,

1019
01:00:36,410 --> 01:00:38,240
exec 唯一返回的情况是，
the only time exactly returns is

1020
01:00:38,240 --> 01:00:40,160
如果发生了一些错误，
if some error occurred

1021
01:00:40,400 --> 01:00:43,610
导致操作系统无法为你运行该程序，
that prevented the operating system from running that program for you,

1022
01:00:43,940 --> 01:00:46,820
比如，如果程序根本不存在，
so for example if the program doesn't exist at all,

1023
01:00:48,080 --> 01:00:50,450
exec 找不到名为 echo 的文件，
exec can't find a file called echo,

1024
01:00:50,540 --> 01:00:53,390
exec 将会返回 -1 ，
for example an exec would return negative one,

1025
01:00:55,520 --> 01:00:58,160
表示出了一些错误，
signal that something wrong,

1026
01:00:58,160 --> 01:00:59,390
它找不到那个文件，
it couldn't couldn't find the file,

1027
01:00:59,390 --> 01:01:01,220
通常 exec 不会返回，
so ordinarily exec does not return,

1028
01:01:01,520 --> 01:01:06,600
它只在内核不能运行文件时返回。
it only returns if the kernel couldn't actually run the file.

1029
01:01:10,430 --> 01:01:11,360
关于 exec ，有什么问题？
Questions about exec?

1030
01:01:12,620 --> 01:01:13,640
聊天中的问题是，
The question in the chat is,

1031
01:01:13,640 --> 01:01:16,070
argv 中的最后一个 0 是什么作用？
what is the last zero for in argv?

1032
01:01:18,850 --> 01:01:20,980
它表示数组的结尾，
It marks the end of the array,

1033
01:01:21,940 --> 01:01:24,010
C 是低级别语言，
C is so low level

1034
01:01:24,010 --> 01:01:30,490
它没有数组语法，
that there's no the C array scheme,

1035
01:01:32,340 --> 01:01:37,470
对于代码，没有方法找出数组的长度，
doesn't have a way for code to find out how long the array is

1036
01:01:37,500 --> 01:01:39,030
所以告诉内核，
and so tell the kernel that,

1037
01:01:40,970 --> 01:01:45,140
你知道，数组包含 echo this is echo ，没有其他东西，
you know we met at the array contains echo this is echo and nothing more,

1038
01:01:46,560 --> 01:01:50,750
我们把 0 放到最后作为最后一个指针，
we put zero was the last strip as the last pointer,

1039
01:01:50,990 --> 01:01:53,000
每个在双引号中的字符串实际上是
each of those strings in double quotes is actually

1040
01:01:53,000 --> 01:01:56,210
一个指向内存中包含这些直接的指针，
a pointer to some memory that contains those bytes,

1041
01:01:56,720 --> 01:02:00,950
数组中的第五个元素指向零值，
that fifth element of the array is a pointer's value is zero,

1042
01:02:01,310 --> 01:02:03,770
惯例是值为零的指针
the convention is that a pointer whose value is zero

1043
01:02:03,770 --> 01:02:05,180
或所谓的空指针。
or what's called a null pointer,

1044
01:02:07,050 --> 01:02:10,620
它表示空。
sort of signifies nothing with it,

1045
01:02:11,620 --> 01:02:16,570
所以内核中的代码遍历这个数组，
[], so the code in the kernel has actually walks through this array,

1046
01:02:16,570 --> 01:02:19,920
直到找到值为零的元素。
until it finds it element whose value is zero.

1047
01:02:24,690 --> 01:02:27,420
好的，
Okay, all right,

1048
01:02:27,420 --> 01:02:29,490
这就是一个程序如何替换自己，
so this is how a program can replace itself

1049
01:02:30,800 --> 01:02:32,090
使用文件中的另一个程序，
with another program from a file,

1050
01:02:32,090 --> 01:02:33,800
但实际上我们在 shell 中运行东西，
but actually when we run stuff in the shell,

1051
01:02:33,800 --> 01:02:37,940
比如 echo abc ，或者 ls 或其他，
like echo abc, or ls or anything else,

1052
01:02:38,900 --> 01:02:41,180
我们不希望替换掉 shell ，我们没有，
we don't want to replace the shell, we don't have,

1053
01:02:41,180 --> 01:02:42,710
shell 只是调用 exec ，
shell just call exec,

1054
01:02:43,420 --> 01:02:46,630
因为，那样 echo 会替换掉 shell ，
because, that would replace the shell with the echo command

1055
01:02:46,630 --> 01:02:49,160
然后 echo 退出，就全部结束了，
then echo exited, that would be end,

1056
01:02:49,700 --> 01:02:52,040
你知道，我们不想用 echo 来替代 shell ，
you know we don't want an echo to replace the shell,

1057
01:02:52,040 --> 01:02:54,170
所以 shell 要做的是 fork ，
so the shell actually does is fork,

1058
01:02:54,940 --> 01:02:56,620
然后子进程调用 exec ，
and then the child calls exec

1059
01:02:56,740 --> 01:03:01,180
这是一个很常见的 unix 惯用程序。
and that's an extremely common unix idiom program instead.

1060
01:03:01,600 --> 01:03:04,660
想要运行一个程序，并重新获得控制权，
Want to run a program, but regain control

1061
01:03:04,690 --> 01:03:07,570
要做的就是调用 fork ，再让子进程调用 exec 。
what they do is call fork and have the child called exec.

1062
01:03:08,000 --> 01:03:12,050
这里有一个简单的例子， forkexec 程序。
So here's a simple example, this forkexec program.

1063
01:03:14,310 --> 01:03:17,550
在这个程序中，在第 12 行调用 fork ，
In this program call fork line twelve,

1064
01:03:17,580 --> 01:03:20,940
在子程序的第 14 行，调用 exec 。
in the child sort of line fourteen, we call exec much like before.

1065
01:03:21,120 --> 01:03:27,700
对于子进程，必须使用 echo 命令替换它自己。
For the child process, has to replace itself with the echo command,

1066
01:03:28,220 --> 01:03:30,890
echo 做完这件事，并退出。
echo does this thing and then exits.

1067
01:03:31,680 --> 01:03:33,720
对于父进程，重新获得了控制权，
And then the parent process, regains control

1068
01:03:33,720 --> 01:03:39,860
因为当 fork 返回时，在父进程中返回一个大于零的值，
because when fork returns, greater than zero value in the parent process,

1069
01:03:39,860 --> 01:03:42,440
所以父进程继续执行第十九行，
so the parent process then continues to execute at nineteen

1070
01:03:42,650 --> 01:03:45,380
unix 也提供了一个 wait 系统调用，
and unix provides a wait system call,

1071
01:03:45,380 --> 01:03:50,720
第 20 行，进程等待 fork 创建的子进程，
line 20 for process to wait for for a child that created with fork,

1072
01:03:51,080 --> 01:03:55,280
因为当我在命令行上运行一条命令，
because when I run a command on the command line,

1073
01:03:56,330 --> 01:04:01,190
我们希望 shell 等待命令结束，
we want shell to wait for the command to finish

1074
01:04:01,400 --> 01:04:03,170
在它重新输出提示符之前，
before it prints the prompt again,

1075
01:04:03,200 --> 01:04:06,050
在它输出 $ 符号等待我输入更多之前。
before it prints the dollar sign prompt asking me for more input.

1076
01:04:06,730 --> 01:04:08,260
wait 系统调用运行进程
So it's the wait system call

1077
01:04:08,890 --> 01:04:11,950
等待它的任何子进程返回，
allows a process to wait for any of its children to return

1078
01:04:12,280 --> 01:04:19,330
这个状态参数是退出子进程的一种方式，
and this status argument is that a way for exiting child,

1079
01:04:19,390 --> 01:04:24,190
将一个 32 位整数
to communicate one integer 32 bit value

1080
01:04:24,400 --> 01:04:27,340
from the exiting child to the waiting parents,

1081
01:04:27,340 --> 01:04:31,450
在第 17 行，退出参数是 1 。
on line seventeen that argument to exit that one that's the argument to exit.

1082
01:04:32,060 --> 01:04:35,540
操作系统将 1
The operating system passes that one

1083
01:04:35,570 --> 01:04:39,650
从退出的子进程传递给第 20 行的 wait ，
from the exiting child to the call to wait line twenty,

1084
01:04:39,650 --> 01:04:43,570
所以 &wait[应该是 &status]
so wait the ampersand wait is passing

1085
01:04:43,570 --> 01:04:46,720
将状态变量地址传递给内核，
the address of the status variable to the kernel,

1086
01:04:46,720 --> 01:04:51,520
内核使用子进程的退出参数填充该地址。
the kernel fills in that address with child's argument to exit.

1087
01:04:52,770 --> 01:04:54,060
unix 中的约定是，
And the convention in unix is

1088
01:04:54,060 --> 01:04:59,850
如果一个程序成功退出，退出码是零，
that if a program completes successfully exit exits with status zero,

1089
01:05:00,430 --> 01:05:03,940
但是它在第 17 行遇到一个问题，
but it has encountered an error at line seventeen,

1090
01:05:04,280 --> 01:05:07,970
unix 约定这里应该退出码应该是 1 ，
the unix convention is that you pass one to exit

1091
01:05:08,420 --> 01:05:10,580
如果你关心调用进程的退出状态，
and so if you care the calling process

1092
01:05:10,580 --> 01:05:12,260
可以查看使用 wait 查看其状态，
can look at the status from wait,

1093
01:05:13,240 --> 01:05:17,280
确定子进程是否成功。
decide whether the child completed successfully.

1094
01:05:18,420 --> 01:05:20,130
Morris 教授，我有一个问题。
Professor Morris, quick question.

1095
01:05:20,560 --> 01:05:20,950
好的。
Yes.

1096
01:05:21,280 --> 01:05:25,090
exec 调用在第 15 行，
About the exec call at fifteen,

1097
01:05:25,090 --> 01:05:26,740
之前我们提到过，
we mentioned not a bit ago,

1098
01:05:26,740 --> 01:05:30,370
exec 会完全被 echo 程序替换，
that exec will completely go into the echo program

1099
01:05:30,400 --> 01:05:32,440
而不会返回到 forkexec 。
and not return to forkexec,

1100
01:05:33,060 --> 01:05:36,930
所以会运行到第十六、十七行吗？
, so, would ever reach line sixteen and seventeen.

1101
01:05:38,170 --> 01:05:41,190
好的，对于这个 exec 代码不合适，
Well, not for this exec code,

1102
01:05:41,190 --> 01:05:43,650
因为有一个名为 echo 的程序，
because there happens to be a program called echo,

1103
01:05:44,130 --> 01:05:46,560
但是如果我在这里修改代码，
but if I modify that code here,

1104
01:05:46,560 --> 01:05:48,420
让我修改一下代码。
let me just modify this code.

1105
01:05:49,470 --> 01:05:51,450
好的，那么首先我来运行一下 forkexec ，
Okay so first let me just run forkexec,

1106
01:05:53,590 --> 01:05:56,740
它实际上使用这些参数执行 echo ，
it actually does execute echo with those arguments,

1107
01:05:56,740 --> 01:05:58,390
我们可以看到输出 this is echo ，
we see the output, this is echo,

1108
01:05:58,660 --> 01:06:04,700
我们看到子进程退出表示 echo 成功退出，
and we see the child exited to show that echo exited successfully,

1109
01:06:05,000 --> 01:06:06,110
而父进程等待。
and the parent wait for.

1110
01:06:06,440 --> 01:06:08,720
让我修改一下代码，
Let me just modify the program for you,

1111
01:06:09,630 --> 01:06:13,320
替换 echo ，而是运行一个不存在的命令。
instead of echo going to run some command that doesn't exist,

1112
01:06:15,360 --> 01:06:20,860
我们先使用 Ctrl-a x 退出 QEMU ，
actually the exit out of QEMU, with control a x

1113
01:06:20,860 --> 01:06:25,120
然后重建所有的东西，重新编译我修改过的程序。
and then rebuild the whole thing in order to re-compile. I modified.

1114
01:06:25,850 --> 01:06:29,180
再次运行 forkexec ，
Forkexec now run forkexec back again after modifying it,

1115
01:06:29,800 --> 01:06:31,990
这次，因为我们要执行的程序。
and this time because the program we're asking to.

1116
01:06:32,760 --> 01:06:39,240
实际上，我们要执行的程序并不存在，
Actually, the program, we're asking to execute doesn't exist,

1117
01:06:39,600 --> 01:06:43,230
exec 返回了我们希望它返回的失败的输出，
exec does return we see the exec failed output,

1118
01:06:43,840 --> 01:06:45,760
返回 1 ，
and the exit one

1119
01:06:45,850 --> 01:06:48,370
你会看到那里的 1 被传回给父进程，
you'll see the one there is communicated back to the parent

1120
01:06:48,370 --> 01:06:50,440
表示子进程退出的状态是 1 。
which says the child exited the status one.

1121
01:06:52,280 --> 01:06:57,260
所以，当出现错误时， exec 返回到调用函数。
So exec returns back to the calling function when something went wrong.

1122
01:06:57,740 --> 01:06:58,190
好的。
Yes.

1123
01:07:08,700 --> 01:07:09,570
好的。
Okay good.

1124
01:07:14,680 --> 01:07:17,980
好的，这里需要注意的是，
Alright, something that's going to note here,

1125
01:07:17,980 --> 01:07:20,500
我想你们中许多人已经注意到了。
that actually think many of you already noted is

1126
01:07:20,500 --> 01:07:23,430
这是一个常见的习惯用法，
that, it is a common idiom here,

1127
01:07:23,430 --> 01:07:26,100
fork 后面跟着子进程里的 exec ，
this fork followed by exec in the child

1128
01:07:26,580 --> 01:07:31,890
fork 复制整个父进程可能有点浪费，
and it's potentially a bit wasteful the fork copies the entire parent process,

1129
01:07:32,320 --> 01:07:35,470
因为 exec 会丢弃所有复制的内存，
but exec throws away all that copied memory

1130
01:07:35,770 --> 01:07:40,990
并将其替换为你运行的文件的内容，
and replaces it with, whatever is in the a file that you're running,

1131
01:07:40,990 --> 01:07:44,320
所以如果你担心这种情况，
so you know if you're worried about this kind of stuff,

1132
01:07:44,320 --> 01:07:47,290
fork 得到的复制，
the copy implied by the fork,

1133
01:07:48,160 --> 01:07:50,110
在某种意义上大部分是浪费的，
is in some sense mostly wasted

1134
01:07:50,110 --> 01:07:54,010
因为所有复制的内存都被丢弃并被 exec 替换，
because all that copied memory is just thrown away and replaced by the exec,

1135
01:07:55,270 --> 01:07:57,940
这种情况对于大程序更明显，
and this affects actually would be significant for big programs,

1136
01:07:57,940 --> 01:08:00,610
如果你有个几 GB 的程序调用 fork ，
if you have a multi gigabyte program that calls fork,

1137
01:08:01,050 --> 01:08:03,240
它确实复制了所有的内存，
and it did indeed copy all the memory

1138
01:08:03,240 --> 01:08:07,260
可能复制只需要不到一秒钟的时间，
would actually take a fair fraction of a second perhaps to do the copy,

1139
01:08:07,740 --> 01:08:09,240
不过这也是个问题。
which could be a problem.

1140
01:08:12,520 --> 01:08:14,710
但是在本课程的后面，
But later in the course,

1141
01:08:14,710 --> 01:08:17,320
你将实现一些优化，
you'll actually implement some optimization

1142
01:08:17,320 --> 01:08:19,810
特别是写入时复制（copy on write） fork ，
in particular something called copy on write fork,

1143
01:08:20,080 --> 01:08:26,560
会消除 fork 中几乎所有明显低效的复制，
which will eliminate almost all of the apparent inefficiency of fork copying,

1144
01:08:26,560 --> 01:08:28,870
只是使用 exec 丢弃复制。
only to have exec throw away the copy.

1145
01:08:29,180 --> 01:08:32,390
它使用了一系列涉及到虚拟内存系统的技巧。
It turns out with a bunch of tricks involving a virtual memory system.

1146
01:08:32,920 --> 01:08:36,700
你可以创建一个 fork ，让它懒复制，
You can build a fork, that's lazy about the copy

1147
01:08:36,730 --> 01:08:40,960
如果 fork 后面跟着 exec ，则不用复制，
and that doesn't do in the common case of fork immediately followed by exec,

1148
01:08:41,420 --> 01:08:43,310
或者你实际上不需要复制，
or you don't actually have to do the copy,

1149
01:08:43,310 --> 01:08:45,770
因为子进程不会使用复制的内存。
because the child doesn't actually use most of the memory.

1150
01:08:48,100 --> 01:08:50,410
我想你会发现那是一个有趣的实验。
I think you'll find that's a fun and interesting lab.

1151
01:08:51,040 --> 01:08:52,180
聊天中有一个问题，
Question from chat,

1152
01:08:52,510 --> 01:08:54,970
为什么父进程
why does the parent process parent

1153
01:08:54,970 --> 01:08:57,820
在子进程调用 exec 之前等待。
waiting completely before the child calls exec.

1154
01:08:59,240 --> 01:09:02,720
嗯，这只是偶然情况。
Yeah, it's just chance.

1155
01:09:06,940 --> 01:09:09,880
为什么，你知道观察结果是，
Why is it that you know the observation is that,

1156
01:09:09,970 --> 01:09:11,680
你知道，
you know,

1157
01:09:13,130 --> 01:09:17,540
父进程输出可能和子进程输出相交错，
it could be that the parents output could be interleaved with the child's output

1158
01:09:17,540 --> 01:09:20,990
在我们之前看到的相同区域，使用相同的 fork 示例，
in the same area that we saw before, with similar fork example,

1159
01:09:21,410 --> 01:09:23,420
它只是发生，
it just happens not to be

1160
01:09:23,630 --> 01:09:25,700
并没有保证这就是输出，
there's no guarantee that this is the output,

1161
01:09:25,700 --> 01:09:27,260
我们会看到实际上，
we would see in fact,

1162
01:09:27,260 --> 01:09:29,390
我们不会感到惊讶，
we we shouldn't be surprised

1163
01:09:29,390 --> 01:09:32,960
即使看到输出是以另一种顺序，或另一种交错，
if we saw the lines of the output in the other order or interleaved.

1164
01:09:33,620 --> 01:09:38,990
我怀疑这是怎么回事，这需要一点时间和努力。
I suspect what's going on is that it takes a bit of time and effort.

1165
01:09:39,770 --> 01:09:41,750
exec 系统造成了一些开销，
The exec system caused a little bit expensive,

1166
01:09:41,750 --> 01:09:43,730
因为它必须加载所有的（指令），
because it has to load all those,

1167
01:09:43,790 --> 01:09:46,730
需要访问文件系统和磁盘，
you have to access the file system and access the disk

1168
01:09:46,730 --> 01:09:50,780
将名为 echo 的文件内容从磁盘读取到内存中，
and read the contents of a file called echo of the disk into memory,

1169
01:09:51,050 --> 01:09:53,180
在分配内存，
after allocating some memory

1170
01:09:53,180 --> 01:09:55,850
然后释放旧进程内存之后，
and that even after freeing some memory from the old process,

1171
01:09:55,850 --> 01:10:00,230
所以 exec 系统调用中有很多机器指令，
so there's quite a bit of machinery involved in the exec system call,

1172
01:10:00,860 --> 01:10:03,350
显然，这需要足够长的时间，
and apparently that takes long enough

1173
01:10:03,350 --> 01:10:06,230
父进程才能完成输出，
that the parent can complete producing the output,

1174
01:10:06,580 --> 01:10:09,400
在 exec 完成，开始运行 echo 之前。
before the exec is finished and started running echo.

1175
01:10:10,400 --> 01:10:11,240
这个解释可以吗？
Does that make sense.

1176
01:10:15,360 --> 01:10:16,290
另一个问题是，
Another question,

1177
01:10:16,290 --> 01:10:19,260
有没有一种协定子进程可以等待父进程？
is a convention that the child can wait for the parent.

1178
01:10:21,520 --> 01:10:26,770
unix 中没有这种方法，
There's not a way unix doesn't have a way for the child,

1179
01:10:28,220 --> 01:10:30,860
没有直接的方法，让子进程可以等待父进程。
there's no straightforward way for a child to wait from a parent.

1180
01:10:31,930 --> 01:10:33,520
wait 系统调用，
The wait system call,

1181
01:10:34,680 --> 01:10:37,380
因为这是唯一可用的机制，
because it's the only mechanism available well,

1182
01:10:37,620 --> 01:10:41,130
wait 系统调用会等待值进程。
the wait system call waits for your children.

1183
01:10:41,880 --> 01:10:42,420
就是这样。
And that's it.

1184
01:10:43,620 --> 01:10:45,990
所以 wait 说做的是，
And so what wait what wait does is,

1185
01:10:46,350 --> 01:10:48,720
如果你有子进程的话，
if you have any children,

1186
01:10:49,080 --> 01:10:53,970
其中之一退出，就会返回，
and one of them has already exited what does exit, then we will return,

1187
01:10:54,330 --> 01:10:55,800
但是如果你没有任何子进程，
but you know if you don't have any children

1188
01:10:55,800 --> 01:10:56,970
因为你。
because you are.

1189
01:10:57,360 --> 01:11:00,450
因为在这种简单的情况下，
Because in this simple case,

1190
01:11:02,120 --> 01:11:02,930
只有父进程，
it was just a parent

1191
01:11:02,930 --> 01:11:05,360
如果子进程调用 wait ，
and child if the child called wait,

1192
01:11:06,890 --> 01:11:08,330
子进程没有任何子进程，
the child doesn't have any children

1193
01:11:08,600 --> 01:11:09,200
在这种情况下，
and in that case,

1194
01:11:09,200 --> 01:11:12,500
wait 会直接返回 -1 错误，
wait just returns immediately with a -1 error return,

1195
01:11:12,500 --> 01:11:14,450
表示这个进程没有任何子进程。
saying this process doesn't have any children.

1196
01:11:15,440 --> 01:11:16,940
无论怎样，简短的回答是，
Anyway, the short answer is

1197
01:11:16,940 --> 01:11:20,180
没有一种方法让子进程等待父进程退出。
there's no way for a child to wait for its parent to exit.

1198
01:11:21,930 --> 01:11:22,770
另一个问题是，
And another question,

1199
01:11:22,770 --> 01:11:26,820
当我们说子进程复制了父进程的所有内存，
when we say the child copies all the memory from the parent process,

1200
01:11:26,820 --> 01:11:29,310
我们到底指什么。
what exactly do we refer to by that,

1201
01:11:29,340 --> 01:11:32,970
我想子进程会再次定义变量。
I thought the child is going to define the variables again.

1202
01:11:39,050 --> 01:11:40,250
当你编译这个，
When you compile this,

1203
01:11:40,250 --> 01:11:46,790
你知道，在编译之后，
you know, after compilation,

1204
01:11:47,060 --> 01:11:51,020
你的 C 程序只是内存中的一些指令，
your C program, it's just a bunch of instructions in memory

1205
01:11:51,470 --> 01:11:52,460
驻留在内存中。
that live in RAM.

1206
01:11:55,070 --> 01:11:56,720
所以那些是可以复制的。
And so those can be copied.

1207
01:11:57,360 --> 01:11:58,920
因为它们只是内存中的一些字节，
Because they're just bytes living in RAM,

1208
01:11:58,920 --> 01:12:01,740
它们可以复制到其他地方。
those can be copied somewhere else.

1209
01:12:02,370 --> 01:12:04,530
并且使用适当的技巧，
And with appropriate trick having to do with

1210
01:12:04,530 --> 01:12:08,840
设置虚拟内存映射，
setting up a sort of virtual memory mappings

1211
01:12:08,930 --> 01:12:12,020
使子进程和父进程映射看起来一样，
and make map things look the same in the child and the parent,

1212
01:12:12,020 --> 01:12:15,050
你可以复制父进程的内存到子进程，
you can just copy the parent's memory image to the child

1213
01:12:15,080 --> 01:12:17,440
然后执行子进程。
and executing the child.

1214
01:12:20,660 --> 01:12:22,310
即使我们看到的是 C 程序，
And even though we're looking at C programs,

1215
01:12:22,310 --> 01:12:25,610
你也应该把它们看作一些机器指令，
you should think of them as just a bunch of machine instructions,

1216
01:12:26,920 --> 01:12:29,200
就是一些内存的字节，可以复制。
which is bytes in memory that can be copied.

1217
01:12:31,280 --> 01:12:33,440
如果一个父进程有多个子进程，
If a parent has multiple children

1218
01:12:33,440 --> 01:12:36,230
如果只是等待第一个子进程退出，
would wait just return as soon as the first child finishes

1219
01:12:36,230 --> 01:12:38,300
意味着父进程和未完成的子进程
meaning that there could be some more interleaving

1220
01:12:38,300 --> 01:12:40,040
with the parent and unfinished children

1221
01:12:40,310 --> 01:12:43,820
所以，需要方法来保证所有子进程完成。
with their need to be multiple separate ways to ensure all children finished.

1222
01:12:44,340 --> 01:12:47,250
是的，如果你调用 fork 超过一次，
Yes, yeah, if you call fork more than one,

1223
01:12:47,250 --> 01:12:50,700
如果进程调用 fork 两次,
if a given process calls fork twice,

1224
01:12:51,360 --> 01:12:54,810
那么它需要等待所有子进程，
then it wants to wait for both children

1225
01:12:54,810 --> 01:12:56,760
必须调用 wait 两次，
and has to call wait twice,

1226
01:12:56,850 --> 01:13:01,490
每次调用 wait 都会在一个子进程退出时返回，
each call to wait will return as soon as one of the children exits,

1227
01:13:01,490 --> 01:13:05,870
当 wait 返回时，你不需要知道是哪个子进程退出，
you don't, when wait returns you don't necessarily know which child is exited,

1228
01:13:06,170 --> 01:13:09,770
wait 会返回子进程的进程 id ，
the wait returns the child's process id as its return value,

1229
01:13:09,770 --> 01:13:12,650
所以在 wait 返回后，你可以区分，
so you can tell after wait returns,

1230
01:13:12,860 --> 01:13:14,450
哪一个子进程退出了。
you know which one it was at exit.

1231
01:13:22,660 --> 01:13:24,610
最后一个例子，
As a final example,

1232
01:13:25,640 --> 01:13:27,170
我想演示一下，
I'd like to show,

1233
01:13:28,080 --> 01:13:37,460
这些系统调用如何结合在一起实现 IO 重定向，
how all these facilities combine to implement IO direction,

1234
01:13:37,460 --> 01:13:38,810
你记得，
so if you remember,

1235
01:13:38,960 --> 01:13:41,900
shell 为我们提供了方便的语法，
the shell provides us with this handy syntax,

1236
01:13:42,350 --> 01:13:44,180
我可以输入 echo hello > out ，
I can say echo hello is going out,

1237
01:13:44,830 --> 01:13:48,310
这运行 echo 命令和传递给它的参数。
that runs the echo command that argument sending it.

1238
01:13:48,800 --> 01:13:52,670
首先，发送它的输出到 out 文件，我们查看一下。
First, that sends its output to the file out and looked out.

1239
01:13:53,120 --> 01:13:54,170
或者，
Or yet,

1240
01:13:55,340 --> 01:14:00,620
使用 cat ，用 out 文件作为它的输入，
on the cat and with its input connected from the out file,

1241
01:14:01,250 --> 01:14:03,620
我们可以看到它保存了 echo 命令的输出。
we can see that saved output from the echo command.

1242
01:14:04,980 --> 01:14:11,630
shell 这种设置方式，像下面这样。
The way the shell sets this up, is, as follows.

1243
01:14:15,320 --> 01:14:20,060
shell 首先 fork ，像第 13 行这样，
It, the shell first forks like on line 13

1244
01:14:20,150 --> 01:14:23,810
然后在子进程中， shell 修改了
and then in the child, the shell changes the way

1245
01:14:23,810 --> 01:14:25,520
文件描述符的设置，
the file descriptors are set up,

1246
01:14:25,520 --> 01:14:28,280
让子进程的文件描述符 1 ，
so that the child's file descriptor one,

1247
01:14:28,280 --> 01:14:32,860
按照惯例，大多数程序使用 1 作为输出。
which by convention most programs used for the output.

1248
01:14:33,470 --> 01:14:37,430
shell 将子进程的文件描述符 1
The shell changes the child's file descriptor to one

1249
01:14:37,430 --> 01:14:40,040
to refer to this output file,

1250
01:14:40,430 --> 01:14:42,530
然后可以执行你需要的命令，
and then run whatever commands you wanted

1251
01:14:42,590 --> 01:14:47,060
同时保留了父进程 shell 的文件描述符 1 不变，
and that leaves the parent shell's file descriptor 1 unchanged,

1252
01:14:47,510 --> 01:14:49,520
这种 fork 的惯用方法，
so this idiom of forking

1253
01:14:49,520 --> 01:14:53,090
在子进程中修改文件描述符，
and in a child changing around the file descriptors,

1254
01:14:53,360 --> 01:14:55,280
是 unix 中一种常用方法，
is the usual way in unix,

1255
01:14:55,280 --> 01:14:59,770
重定向你运行的命令的输入、输出，
actually redirect input and output for a command that you run,

1256
01:14:59,770 --> 01:15:04,300
但是不影响调用程序的输入、输出，
but not affect the input and output for a calling program,

1257
01:15:04,300 --> 01:15:06,370
因为我们不想重定向 shell 的输出。
because we don't want to redirect the shell's output.

1258
01:15:07,150 --> 01:15:11,500
我们只想重定向子进程的输出。
We only want to redirect the child programs output.

1259
01:15:12,670 --> 01:15:15,490
不管怎样，这种方式是我们调用 fork 的常用方式，
Anyway, the way this works we call fork usual way,

1260
01:15:15,730 --> 01:15:18,370
第 15 行只会在子进程中执行。
line fifteen only executes in the child.

1261
01:15:18,860 --> 01:15:21,410
在第 15 行关闭 1 的原因是，
The reason for the close one on line fifteen is,

1262
01:15:21,410 --> 01:15:26,530
我们只是对 echo 命令的输出重定向，
that in this program we're redirecting just the output of the echo command,

1263
01:15:26,530 --> 01:15:28,000
所以当我运行 redirect ，
so when I run this redirect,

1264
01:15:28,640 --> 01:15:31,520
程序本身不会产生输出，
program produces no output itself,

1265
01:15:31,520 --> 01:15:35,060
它运行 echo 并把它的输入定向到 output.txt 文件。
it ran echo with its output directly to output.txt.

1266
01:15:35,540 --> 01:15:39,440
所以当我查看 output.txt ，
So when I look at output.txt,

1267
01:15:39,770 --> 01:15:41,330
我看到了预期的输出，
I see this expected output,

1268
01:15:41,750 --> 01:15:43,880
在第 15 行关闭 1 的原因是，
the reason for the close one on line fifteen,

1269
01:15:44,900 --> 01:15:49,160
我们想把输出文件描述符 1
is that we want one as a sort of conventional

1270
01:15:49,160 --> 01:15:51,560
指向别的东西，
output file descriptor to refer to something else,

1271
01:15:52,010 --> 01:15:54,650
而我们不想，我们有子进程，
it happens so we don't, have a child,

1272
01:15:54,650 --> 01:15:56,690
不想使用父进程的文件描述符 1 ，
we don't want to use the father descriptor one

1273
01:15:56,690 --> 01:15:58,790
shell 使用它连接控制台,
that the shell had that's connected to the console,

1274
01:15:59,660 --> 01:16:03,320
第 16 行的 open 调用一定返回 1 ，
the call to open on line sixteen is guaranteed to return one,

1275
01:16:03,320 --> 01:16:07,070
因为 open 的语义是返回
because, the semantics of open are that open returns

1276
01:16:07,070 --> 01:16:09,490
没有被当前进程使用的
the lowest file descriptor number

1277
01:16:09,490 --> 01:16:13,450
最小的文件描述符编号，
that's not currently in use in the calling process

1278
01:16:13,480 --> 01:16:14,950
而我们刚关闭了 1 。
since we just closed one,

1279
01:16:15,420 --> 01:16:19,590
并且文件描述符 0 仍然连接到控制台，
and file descriptor zero is still connected to the console,

1280
01:16:19,590 --> 01:16:20,010
我的意思是，
I mean，

1281
01:16:20,460 --> 01:16:23,160
open 一定会返回 1 。
open is guaranteed to return one.

1282
01:16:24,290 --> 01:16:29,060
所以在第 16 行之后，文件描述符 1 连接到这个文件。
So after the line sixteen file descriptor one is connected to this file.

1283
01:16:30,220 --> 01:16:31,300
我们只是执行 echo ，
We only exec echo,

1284
01:16:31,300 --> 01:16:33,970
echo 输出到文件描述符 1 ，就会写入到这个文件中，
echo just writes its output the file descriptor one

1285
01:16:34,330 --> 01:16:35,710
and now go to this file

1286
01:16:35,740 --> 01:16:38,380
最酷的是， echo 并不知道发生了什么，
and the cool thing about this is echo had no idea what's going on,

1287
01:16:38,800 --> 01:16:41,620
echo 完全不需要知道 IO 重定向，
echo doesn't need to know about IO direction at all,

1288
01:16:41,650 --> 01:16:44,080
它只是输出到文件描述符 1 。
it just writes its output, the file descriptor one.

1289
01:16:45,160 --> 01:16:50,350
只有 shell 知道 IO 重定向。
Only the shell, knows about IO redirection.

1290
01:16:52,380 --> 01:16:56,720
这个例子也展示了
This example also illustrates the sort of kind of

1291
01:16:57,110 --> 01:17:00,110
fork 和 exec 之间的巧妙分离，
neatness of the separation between fork and exec,

1292
01:17:00,110 --> 01:17:03,440
fork 和 exec 是分开的系统调用，
the fact that fork and exec are separate system calls,

1293
01:17:04,220 --> 01:17:06,700
分开的函数
separate functions,

1294
01:17:08,130 --> 01:17:10,440
意味着在子进程在有一段时间，
means that there's a period of time in the child,

1295
01:17:10,440 --> 01:17:13,570
在它们之间，从子进程返回，
between the fork between them for returns in the child

1296
01:17:13,630 --> 01:17:17,860
我们仍然在运行调用程序指令，
and exactly which were still running the calling processes instructions,

1297
01:17:17,860 --> 01:17:19,810
调用进程，
so the calling process,

1298
01:17:20,160 --> 01:17:23,310
即使这些指令在子进程运行，
even though it's running, those instructions are running in the child,

1299
01:17:23,610 --> 01:17:26,580
也是调用进程指令在运行，
it's still the calling processes instructions that are executed

1300
01:17:27,000 --> 01:17:31,260
所以调用进程仍然能够改变事情，
and so the calling process is still able to change things

1301
01:17:31,320 --> 01:17:33,660
仍然在控制中直到第 19 行。
and still in control up until line nineteen.

1302
01:17:34,380 --> 01:17:36,420
这种在 fork 和 exec 之间的间隔，
And this sort of interval between fork and exec,

1303
01:17:36,780 --> 01:17:38,310
给了 shell 修改，
gives the shell chance to

1304
01:17:38,580 --> 01:17:41,520
change what the file descriptor, refer to, for example.

1305
01:17:43,180 --> 01:17:45,880
对 redirect 示例，有什么问题吗？
Any questions about this redirect example.

1306
01:17:55,220 --> 01:17:59,000
好的，时间快到了。
Alright, about out of time.

1307
01:18:00,410 --> 01:18:01,430
总结一下，
Just wrap up,

1308
01:18:01,430 --> 01:18:02,300
我们看了 unix ，
we look at unix,

1309
01:18:02,300 --> 01:18:08,630
有许多接口， IO ，进程抽象。
is a bunch of the interfaces, the unix IO, process abstractions.

1310
01:18:09,230 --> 01:18:10,730
这里的事情，
Thing to take away from this,

1311
01:18:10,730 --> 01:18:12,770
接口相对简单，
is if the interfaces are relatively simple

1312
01:18:12,800 --> 01:18:14,630
只是传递一个整数，
and just pass an integer

1313
01:18:14,630 --> 01:18:16,490
比如文件描述符和进程 id ，
like file descriptors and process ids,

1314
01:18:16,490 --> 01:18:20,450
作为系统调用的参数传递。
back and forth across its arguments system calls.

1315
01:18:20,820 --> 01:18:26,440
但是，接口内部函数是相当复杂的，
But, well, the functionality inside the interface is relatively sophisticated,

1316
01:18:26,440 --> 01:18:30,210
比如创建进程，复制进程，
like creating new processes and copying the current process

1317
01:18:30,600 --> 01:18:32,820
此外，我还展示了一些例子，
and furthermore I show some examples

1318
01:18:32,820 --> 01:18:38,340
单独的抽象如何合并在一起使用，
of ways in which the abstractions individually simple combine in useful ways,

1319
01:18:38,550 --> 01:18:41,850
比如，产生 IO 重定向。
for example to produce IO redirection.

1320
01:18:44,030 --> 01:18:46,100
有一个下周末到期的实验，
There's a lab due at the end of next week

1321
01:18:46,970 --> 01:18:50,150
那个实验涉及到编写更多简单使用程序，
and that lab involves writing more simple utilities

1322
01:18:50,150 --> 01:18:52,880
就像我在讨论中展示的那样。
like the ones I showed that use the system calls that we discuss.

1323
01:18:54,140 --> 01:18:55,370
所以，祝你在实验玩得开心，
So, have fun with that lab

1324
01:18:55,400 --> 01:18:57,620
下周上课再见。
and I'll see you in class next week.

1325
01:19:01,520 --> 01:19:02,180
就是这些。
And that's it.

1326
01:19:08,480 --> 01:19:08,780
谢谢。
Thank you.

1327
01:19:15,170 --> 01:19:16,550
既然我是录视频的人，
Since I'm the one recording,

1328
01:19:16,670 --> 01:19:18,110
我该怎么结束这个呢，
how do I end this,

1329
01:19:18,680 --> 01:19:20,210
第一次在课程中录制。
first time recording in lecture.

1330
01:19:20,600 --> 01:19:21,710
它们会自己退出。
They will be exit.

1331
01:19:22,520 --> 01:19:25,310
我不用做什么操作，退出，它就会保存到一些地方。
Okay, nothing special I can just exit it will be saved somewhere.

1332
01:19:26,220 --> 01:19:27,270
是的。
Yes.

1333
01:19:27,300 --> 01:19:27,720
太棒了。
Awesome.

1334
01:19:32,010 --> 01:19:36,470
我想会创建一些文件夹并把文件放到里面。
I assume will create some directory and sticking a file in that directory.

1335
01:19:38,600 --> 01:19:40,640
这节课之后有办公时间，是吗。
There's also office hours right after this right.

1336
01:19:41,930 --> 01:19:42,410
是的。
Yes.

1337
01:19:42,860 --> 01:19:43,310
完美。
Perfect.

1338
01:19:45,200 --> 01:19:45,710
太酷了。
Cool.

1339
01:19:50,340 --> 01:19:50,820
好的。
Alright.

1340
01:19:51,580 --> 01:19:51,970
好的。
Alright.

1341
01:19:52,450 --> 01:19:54,430
谢谢，下周见，
Thank you and I'll see you next week,

1342
01:19:54,640 --> 01:19:55,060
谢谢。
thanks.

