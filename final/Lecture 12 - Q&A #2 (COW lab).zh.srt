1
00:00:10,990 --> 00:00:11,950
好的。
Alright.

2
00:00:13,470 --> 00:00:15,270
大家早上好，下午好，
Good morning or good afternoon everyone,

3
00:00:15,420 --> 00:00:17,610
我要开始了，
I'm like to get started,

4
00:00:17,670 --> 00:00:19,230
大家能听到我说话吗？
can people hear me?

5
00:00:20,000 --> 00:00:20,660
是的。
Yep.

6
00:00:20,980 --> 00:00:21,400
谢谢。
Thank you.

7
00:00:21,850 --> 00:00:24,700
好的，今天我想做的是
Alright, today, what I'd like to do is

8
00:00:24,940 --> 00:00:28,240
给你们一个机会询问关于 xv6 的问题，
give you a chance to ask questions about xv6

9
00:00:28,240 --> 00:00:29,710
以及最近的实验，
and about the recent labs,

10
00:00:29,980 --> 00:00:33,850
为了给我们提供一些可以谈论的东西，
in order to give us something to talk about,

11
00:00:33,970 --> 00:00:41,090
我会尽可能多地做写入时复制 fork 实验，
I'm going to do as much as I can of the copy-on-write fork lab here,

12
00:00:41,120 --> 00:00:44,030
给我们一些可以考虑的东西，
just to give us something to chew on

13
00:00:44,330 --> 00:00:47,450
你可以随意问任何问题，
and you should feel free to ask any questions you like,

14
00:00:47,630 --> 00:00:51,770
你可以问为什么我的解决方案与你的不同，
you can ask about why my solution is different from your solution

15
00:00:51,770 --> 00:00:54,620
或者为什么 xv6 这样工作，
or why xv6 works the way it does

16
00:00:54,620 --> 00:01:00,660
为什么我们遇到的 bug 以这种方式出现。
or why the bugs that we encounter show up in the way they do.

17
00:01:02,040 --> 00:01:03,390
所以只想提醒一下，
So just to remind you,

18
00:01:03,390 --> 00:01:07,050
虽然我相信不需要提醒你们，
although I'm sure this is I'm sure I don't need to remind you,

19
00:01:07,170 --> 00:01:08,850
写入时复制 fork 的关键点是
the point of copy-on-write fork is

20
00:01:08,850 --> 00:01:14,400
为了避免在 fork 时对未修改页面的复制成本。
to avoid copying costs for pages at fork that are never modified.

21
00:01:15,000 --> 00:01:17,820
我输入了几行代码，
I put in a few lines of code

22
00:01:17,820 --> 00:01:22,920
来测量 memcpy 必须复制的字节数的减少，
to measure the reduction in the number of bytes that memcpy had to copy

23
00:01:23,250 --> 00:01:27,030
对于我的写入时复制解决方案在 usertests 时，
during usertests for my copy-on-write solution

24
00:01:27,030 --> 00:01:31,820
结果发现实际上减少了 90% 的复制量。
and found that actually reduce the amount of copying by 90%.

25
00:01:32,630 --> 00:01:33,800
这是针对 usertests 的，
And this is for usertests

26
00:01:33,800 --> 00:01:36,200
虽然是一个有点怪异的程序，但无所谓，
which is kind of a weird program, but nevertheless,

27
00:01:36,410 --> 00:01:41,570
我认为这很大程度上是因为指令页的复制减少了，
and I think a lot of it is reductions in's copy of the instruction pages,

28
00:01:41,570 --> 00:01:44,810
因为指令页从来不会修改，
because the instruction pages for are never modified,

29
00:01:45,680 --> 00:01:48,290
所以不需要复制它们，
so there's never any point in having copies of them

30
00:01:48,500 --> 00:01:50,570
我认为这就是很多优势的来源。
and I think that's where a lot of the win was from.

31
00:01:51,040 --> 00:01:53,770
并且写入时复制 fork 还减少了 RAM 的使用，
And copy-on-write fork also reduces RAM use,

32
00:01:54,010 --> 00:01:56,860
你需要使用的最大 RAM 量，
the sort of maximum amount of RAM you ever need to use

33
00:01:56,980 --> 00:01:59,500
它减少了你花在 fork 上的时间，
and it reduces the amount of time you spend in fork,

34
00:02:01,040 --> 00:02:02,780
所以 fork 返回得更快。
and so fork returns more quickly.

35
00:02:02,780 --> 00:02:05,840
从另一方面来说，当然总成本可能会更高，
You know on the other hand, of course the total cost may be larger,

36
00:02:05,870 --> 00:02:10,250
因为如果程序最终修改了所有写入时复制页面，
because if programs end up modifying all the copy-on-write pages,

37
00:02:10,520 --> 00:02:14,210
你不得不做所有的复制，再加上所有的页面错误，
you end up having to do all the copies plus take all the page faults,

38
00:02:15,320 --> 00:02:17,450
这可能有点昂贵，
which can be a little bit expensive,

39
00:02:17,450 --> 00:02:22,860
但尽管如此，人们发现，一般说来，这是一种净收益。
but nevertheless, people found that, in general, it's a net benefit.

40
00:02:23,770 --> 00:02:26,020
如你所知，主要的挑战是，
And as you know the main challenges are,

41
00:02:26,410 --> 00:02:30,100
一个挑战是如何避免释放内存，
one challenge is how to avoid freeing memory

42
00:02:30,130 --> 00:02:32,500
现在我们在进程之间共享页面，
and now we're sharing pages among processes,

43
00:02:32,590 --> 00:02:34,900
没有释放它们，
have not de-allocate them, have not free them,

44
00:02:34,900 --> 00:02:37,570
直到最后一个进程完成使用它们。
until the last process is finished using them,

45
00:02:37,720 --> 00:02:39,160
所以任何[]。
so anymore bookkeeping.

46
00:02:39,670 --> 00:02:42,010
另一个有趣的挑战是，
And the other interesting challenge is

47
00:02:42,010 --> 00:02:47,210
特别是 xv6 中的 copyout ，
that there's a in copyout in particular the xv6,

48
00:02:47,240 --> 00:02:51,680
修改用户内存，而无需实际使用 MMU 分页硬件，
modifies user memory without actually going to the MMU paging hardware,

49
00:02:53,410 --> 00:02:55,750
我们必须在这里模仿页面错误。
and we have to mimic page faults here.

50
00:02:57,090 --> 00:02:59,340
我要看实验了，
I'm gonna go to the lab,

51
00:02:59,370 --> 00:03:02,670
从写入时复制实验的开头开始，
starting at the beginning the copy-on-write lab,

52
00:03:02,820 --> 00:03:03,360
在我开始之前，
before I start,

53
00:03:03,360 --> 00:03:05,490
我想提一下，
I just wanna just mentioned

54
00:03:05,490 --> 00:03:09,630
我在做实验时遵循的策略，
the strategy that I think of myself as following when I do labs

55
00:03:09,660 --> 00:03:12,030
我做了很多实验，一年又一年，
and I do a lot of labs from one year to the next,

56
00:03:12,030 --> 00:03:15,000
我不记得做实验的细节了，
I don't remember the details of how to do the labs,

57
00:03:16,890 --> 00:03:18,750
另外，实验也发生了变化。
and in addition labs change.

58
00:03:19,180 --> 00:03:21,250
好的，当我做实验的时候，
Alright, so, when I'm doing the labs,

59
00:03:21,250 --> 00:03:22,570
我总是迈出一小步，
I always take small steps,

60
00:03:22,570 --> 00:03:27,100
我可能会发现要解决的问题的下一个子集，
I may find you know some sort of next subset of the problem to solve,

61
00:03:27,250 --> 00:03:29,230
可能有五到十行代码，
maybe five or ten lines of code,

62
00:03:29,260 --> 00:03:32,590
我编写程序并运行它，然后试着让它工作，
I programmed up and run it and try to get to working,

63
00:03:33,310 --> 00:03:36,910
在我继续下一步之前，
before I go on to the next, proceeding to the next step

64
00:03:36,970 --> 00:03:42,370
这是，而不是整体思考并编写一个完整的解决方案，
and this is you know as opposed to for example thinking through and writing a complete solution,

65
00:03:42,850 --> 00:03:46,360
在开始测试和调试之前，
before starting to test and debug,

66
00:03:46,360 --> 00:03:49,760
它总是一次测试和调试一点，
it always test and debug a little bit at a time,

67
00:03:50,060 --> 00:03:51,560
这很大程度上是因为，
a lot of the reason for that is that,

68
00:03:51,770 --> 00:03:57,110
即使你可能对很多事情都有一些想法，
even though you may, you may have sort of thought through a lot of things,

69
00:03:57,110 --> 00:03:58,130
很多挑战，
a lot of the challenges,

70
00:03:58,130 --> 00:03:59,480
还有很多设计，
and a lot of the design,

71
00:03:59,510 --> 00:04:01,580
你要做什么才能解决实验的问题，
for what you're going to have to do to solve the lab,

72
00:04:01,670 --> 00:04:04,250
我发现至少经常会有惊喜。
I find at least there's often surprises.

73
00:04:04,620 --> 00:04:08,370
所以如果我先实现所有的东西，
And so if I implement everything first,

74
00:04:08,400 --> 00:04:10,980
我可能会发现我浪费了很多时间，
I may find then that I've wasted a lot of time,

75
00:04:10,980 --> 00:04:13,380
因为我没有完全理解这个问题，
because I didn't fully understand the problem,

76
00:04:13,380 --> 00:04:16,290
直到我真正开始调试它。
until I actually got into debugging it.

77
00:04:17,360 --> 00:04:20,930
我在每个点上选择下一步的方式是
And the way I choose the next step at each point is

78
00:04:20,930 --> 00:04:25,430
通常是由测试失败引起的 panic 或崩溃引起的，
usually driven by whatever panic or crash a test failure I see that,

79
00:04:25,430 --> 00:04:28,760
告诉我下一步需要解决的问题。
sort of tells me what I need to fix next.

80
00:04:29,350 --> 00:04:31,330
我在做这个实验，
Well I'm doing this lab,

81
00:04:31,390 --> 00:04:32,650
我会犯几个错误，
I'll make a few mistakes,

82
00:04:32,650 --> 00:04:35,050
这是我上一次做实验时做的，
that I actually made the last time I did the lab,

83
00:04:35,110 --> 00:04:39,430
我们可以一起做一个小的调试练习。
so that we can do a have a little practice debugging together.

84
00:04:41,360 --> 00:04:45,740
再说一遍，你可以随时打断，问任何问题。
Again, feel free to break in at any time and ask questions about anything.

85
00:04:47,040 --> 00:04:52,310
我从写入时复制实验的最新拷贝开始，
I'm starting here with fresh copy of the copy-on-write lab,

86
00:04:53,100 --> 00:04:55,350
和你们所有人一样的源码。
source the same as all of you did.

87
00:04:55,920 --> 00:04:57,600
所以，我要开始了。
So, I'll just fire this up.

88
00:04:58,830 --> 00:05:04,660
并且，运行写入时复制测试，
And, run the copy-on-write tests

89
00:05:04,660 --> 00:05:06,460
也许我很幸运，
and you know maybe I'll get lucky

90
00:05:06,460 --> 00:05:08,590
所有测试都会通过，不需要做任何事，
and all the tests will pass and don't have to do anything,

91
00:05:10,510 --> 00:05:11,890
不好，测试失败了，
too bad, on the test failed,

92
00:05:11,920 --> 00:05:14,320
好的，不用太惊讶。
okay, so not too surprising.

93
00:05:16,680 --> 00:05:19,710
这时好的步骤就是
And you know a good step at this point is

94
00:05:19,710 --> 00:05:21,420
去看看测试，
to go have a look at the tests

95
00:05:21,450 --> 00:05:23,250
弄清楚它想要做什么，
and figure out what it's trying to do,

96
00:05:23,700 --> 00:05:29,130
令人难受的是，有些测试很复杂，很难理解，
and the sad truth is some of the tests are complicated and hard to understand

97
00:05:29,130 --> 00:05:32,130
不一定是测试任何特定的东西，
and don't necessarily test anything specific,

98
00:05:32,130 --> 00:05:35,560
它们只是尝试不同的东西，看看会不会断掉，
they just sort of try different things, see if something will break,

99
00:05:35,620 --> 00:05:37,570
但幸运的是，这个简单的测试，
but luckily with this simple test,

100
00:05:39,190 --> 00:05:40,570
它的作用非常清楚。
it's pretty clear what its doing.

101
00:05:40,930 --> 00:05:42,130
一个问题。
A question.

102
00:05:42,250 --> 00:05:43,180
嗯。
Yeah.

103
00:05:43,210 --> 00:05:45,340
你需要显示一下你的屏幕，我们什么也看不见。
You need to show your screen, we cannot see anything.

104
00:05:45,490 --> 00:05:46,840
哦，天哪。
Oh gosh.

105
00:05:47,450 --> 00:05:49,970
不好意思,
I'm sorry about that,

106
00:05:50,240 --> 00:05:52,850
谢谢你让我知道。
thank you for, thank you for letting me know.

107
00:05:55,280 --> 00:05:56,240
这好了吗？
How is that better?

108
00:05:57,820 --> 00:05:58,360
是的。
Yes.

109
00:05:59,140 --> 00:06:00,100
太棒了，好的。
Brilliant, alright.

110
00:06:00,970 --> 00:06:03,370
好的，这是第一个 bug 。
Okay, well, that's bug number one.

111
00:06:06,030 --> 00:06:09,810
好的，我在这里，
Okay, so I'll just, here I am,

112
00:06:09,810 --> 00:06:11,730
在我的写入时复制测试中，
in my copy-on-write test,

113
00:06:11,850 --> 00:06:16,240
我运行了写入时复制测试，但是失败了。
I ran copy-on-write test, and it fails.

114
00:06:18,690 --> 00:06:20,100
看看这个测试，
Look at the test,

115
00:06:20,100 --> 00:06:23,910
屏幕右边的 simpletest 失败了，
this simpletest on the screen right is actually failed,

116
00:06:24,150 --> 00:06:28,320
这个测试，我们很幸运，它告诉我们它在做什么，
and this test, we're lucky enough, it actually tells us what it's doing

117
00:06:28,680 --> 00:06:35,370
分配 xv6 中超过一半的可用内存，然后 fork ，
and allocates what it knows to be more than half the available memory in xv6 and then forks

118
00:06:36,570 --> 00:06:40,860
当然，这个失败的原因是 fork 复制了一份，
and of course, the reason this fails is that fork makes a copy,

119
00:06:41,040 --> 00:06:45,030
然后 xv6 从字面上复制了，
then ordinary xv6 actually literally makes a copy

120
00:06:45,030 --> 00:06:48,660
所以，如果我们必须复制一半以上的内存，
and so if we have to copy more than half of memory,

121
00:06:48,660 --> 00:06:49,950
就会没有足够的空间。
there's just not enough space for that.

122
00:06:50,910 --> 00:06:54,610
好的，所以，这就是写入时复制的意义所在，
Okay, so, of course, this is what copy-on-write all about,

123
00:06:55,000 --> 00:07:01,330
我们知道游戏是不用复制进程的内存，
and we know that the basic game is that instead of copying the process's memory,

124
00:07:01,360 --> 00:07:05,380
我们只复制它的页表，而不是内存，
we want to just copy its page table and not the memory,

125
00:07:05,740 --> 00:07:10,600
子进程只有一份父进程页表的复制，而不是内存，
the child just has a carbon copy of the parent's page table, instead of memory,

126
00:07:11,240 --> 00:07:13,490
指向所有相同的物理页面。
referring to all the same physical pages.

127
00:07:14,390 --> 00:07:25,290
fork 执行复制的位置在 vm.c 和 uvmcopy 中。
The place where, fork does it's copying is in vm.c and uvmcopy.

128
00:07:27,820 --> 00:07:30,580
所以我们只需修改这个代码，
And so we can just modify this code,

129
00:07:33,320 --> 00:07:36,170
以代替分配页面内存，
to instead of allocating a page memory,

130
00:07:36,870 --> 00:07:40,180
在这里，并复制到上面，
here, and copying onto it,

131
00:07:40,300 --> 00:07:43,270
我们要去掉这三行。
we're going to eliminate those three lines,

132
00:07:43,940 --> 00:07:45,410
取而代之的是，
and instead,

133
00:07:48,880 --> 00:07:50,740
我只是复制页表条目，
I just copied page table entries,

134
00:07:50,920 --> 00:07:53,440
所以，
so um,

135
00:07:55,740 --> 00:08:10,310
实际上就是想 hack 这个 mappages 的复制，
actually just gonna hack, this copy of mappages,

136
00:08:10,460 --> 00:08:12,110
因为我们没有在这里分配内存，
since we didn't actually allocate memory here,

137
00:08:12,110 --> 00:08:13,340
我要把删掉这个 free ，
going to get rid of this free,

138
00:08:13,520 --> 00:08:15,470
我将修复这个 mappages ，
I'm going to fix this mappages,

139
00:08:15,470 --> 00:08:22,780
而不是将 mem 映射到地址 i ，
to instead of mapping mem at address i,

140
00:08:23,260 --> 00:08:25,210
我要映射 pa ，
I'm going to map the pa,

141
00:08:25,210 --> 00:08:28,570
它是我们从父进程页表中取出的物理地址。
which is the physical address, we pulled out of the parents' page table.

142
00:08:29,710 --> 00:08:30,640
这里能明白吗？
So is that clear?

143
00:08:31,650 --> 00:08:33,600
所以这会产生这样的效果
And so this will just have the effect of

144
00:08:33,990 --> 00:08:37,680
将所有父页面映射到子页面的地址空间。
mapping all of the parents pages into the child's address space.

145
00:08:39,280 --> 00:08:41,470
pa 不是已经是 uint64 了吗？
Isn't pa already uint64?

146
00:08:44,940 --> 00:08:45,570
可能吧。
Probably.

147
00:08:45,960 --> 00:08:49,470
或者，如果你强制转换为已经是的类型，是不是很糟糕？
Or is it is it bad, if you were to cast its already that type?

148
00:08:49,470 --> 00:08:53,910
强制转换什么也没做，除了让编译器闭嘴，
The cast does absolutely nothing other than shut the compiler up,

149
00:08:54,540 --> 00:08:56,910
因为地址已经是 64 位，
since it's already, since addresses already 64 bits

150
00:08:56,910 --> 00:08:58,710
你想要 64 位，
and you want 64 64 bit,

151
00:08:58,860 --> 00:09:00,750
那个强制转换不会改变位，
that cast doesn't change the bits,

152
00:09:01,440 --> 00:09:05,430
它只是让类型检查器不那么烦躁，
it just makes the type checker less upset,

153
00:09:05,580 --> 00:09:08,400
但是[]你并不知道是哪一种类型。
but [] you actually don't know whether any of these types are.

154
00:09:10,160 --> 00:09:12,200
但是，有一件事是我们不需要这个 mem 变量。
However, one thing is we don't need this mem variable.

155
00:09:15,550 --> 00:09:18,670
好的，那么你写下 pa ，
Okay, so you write about pa,

156
00:09:21,250 --> 00:09:22,600
天哪，我在想我们是不是完成了。
gosh, I wonder if we're done now.

157
00:09:22,930 --> 00:09:25,660
我们来运行 cowtest ，看看会发生什么，
Let's run the cowtest and see what happens,

158
00:09:25,750 --> 00:09:27,490
绝对没完成。
definitely not done.

159
00:09:28,330 --> 00:09:31,650
好的，我们在这里有，
Okay, so, we got here is,

160
00:09:31,650 --> 00:09:35,600
这个 usertrap 和 scause 2 。
this usertrap with scause of two.

161
00:09:36,740 --> 00:09:38,720
有人记得 scause 2 是什么吗？
Anybody remember what scause two is?

162
00:09:41,410 --> 00:09:42,400
我就直接告诉你吧。
I'll just tell you.

163
00:09:42,430 --> 00:09:44,110
指令失效？
Instruction failure?

164
00:09:44,140 --> 00:09:45,550
这是非法指令，
It's an illegal instruction,

165
00:09:45,550 --> 00:09:49,300
那么我们为什么会得到非法指令。
so why would we getting an illegal instruction now.

166
00:09:51,320 --> 00:09:52,700
这是我们所期待的吗？
Is this what we expected?

167
00:09:58,070 --> 00:10:04,220
我们有没有覆盖有指令的位置？
Did we overwrite them like position where we have instructions?

168
00:10:05,310 --> 00:10:09,960
是的，有些东西破坏了用户程序的指令。
Yes, something is damaging the instructions of the user program.

169
00:10:12,440 --> 00:10:15,800
当然，我们在这里得到错误并不奇怪。
And of course the fault, we're not surprised we get a fault here.

170
00:10:17,180 --> 00:10:20,030
但我们希望是保存的错误，
But we're hoping for write, for stored faults

171
00:10:20,390 --> 00:10:23,480
驱动复制进程和写入时复制。
to drive the copying process and copy-on-write.

172
00:10:24,760 --> 00:10:26,320
我们没有得到保存的错误。
We're not getting the store fault.

173
00:10:31,980 --> 00:10:34,860
对此还有其他假设吗？
Any other hypotheses for this?

174
00:10:35,960 --> 00:10:36,800
It's not really fair,

175
00:10:36,800 --> 00:10:39,440
因为这是我的 bug ，不是你的 bug ，
because like this, my bug not your bug,

176
00:10:39,980 --> 00:10:40,970
但是不管怎样。
but nevertheless.

177
00:10:43,540 --> 00:10:45,190
一定要操作 flags 吗？
Does it have to do the flags?

178
00:10:46,270 --> 00:10:48,190
是的，确实如此。
Yes, it does.

179
00:10:53,520 --> 00:10:55,950
好的，那我把它放在一边，
Okay, so I'll just leave that to the side,

180
00:10:55,950 --> 00:10:57,960
它们会再次出现。
they'll actually come up again.

181
00:10:57,990 --> 00:11:02,430
另一个问题是我们希望出现保存页面错误，
Another question is we're hoping for store page faults,

182
00:11:02,850 --> 00:11:06,030
这将驱动复制进程。
which will drive the copying process.

183
00:11:07,090 --> 00:11:09,010
为什么我们没有得到保存页面错误？
Why didn't we get a store page fault?

184
00:11:21,210 --> 00:11:22,590
好的，嗯。
Alright, um.

185
00:11:23,750 --> 00:11:26,120
为什么我们会得到保存页面错误？
Why would we get a store page fault?

186
00:11:27,400 --> 00:11:32,030
RISC-V 在什么情况下会产生保存页面错误。
Under what circumstances, does the RISC-V generate store page fault.

187
00:11:34,770 --> 00:11:37,470
如果没有设置写标志，我们会得到，
We would get if the write flag is not set,

188
00:11:37,590 --> 00:11:40,770
但现在我们可以正常地写任何东西。
but now we can just write to everything normally.

189
00:11:41,010 --> 00:11:42,510
是的，设置写标志，
Yeah, left the write flag set,

190
00:11:42,510 --> 00:11:43,680
好的，这就是第一个 bug ，
alright, so that's bug one

191
00:11:43,680 --> 00:11:47,040
我上一次做这个实验的时候，
which I did actually make last time I did this lab,

192
00:11:47,040 --> 00:11:49,500
所以，我在父级中设置了写标志，
so I've left the write flag set in the parent,

193
00:11:49,500 --> 00:11:51,930
我没有对写标志做任何事情，
I've done I haven't done anything to the write flags,

194
00:11:51,960 --> 00:11:54,960
这里的标志变量是，
this flags variable here is,

195
00:11:55,750 --> 00:11:58,000
就是我们从父页表获得的，
it's just the way we pulled out of the parents' page table,

196
00:11:58,000 --> 00:11:59,740
它的所有页面都是可写的，
it's all its pages are writable

197
00:12:00,010 --> 00:12:02,680
所以这意味着它在子页表也可写，
and so that means that it's going to be writable on the child two,

198
00:12:02,680 --> 00:12:03,820
我们不会得到保存页面错误，
we won't get store page faults,

199
00:12:03,820 --> 00:12:06,910
所以只是共享一个页面可读写，
so just sharing a page read, write,

200
00:12:07,420 --> 00:12:08,710
这不是我们想要的，
which is not what we wanted,

201
00:12:08,860 --> 00:12:10,780
那我怎么才能关掉，
so how am I going to turn off the,

202
00:12:10,810 --> 00:12:13,360
我该如何写保护这些页面。
how am I gonna write protect these pages.

203
00:12:20,930 --> 00:12:24,360
有什么建议吗，我应该输入什么。
Any proposals, what should I type.

204
00:12:27,730 --> 00:12:28,810
怎么样。
How about.

205
00:12:29,360 --> 00:12:41,120
你可以使用 flags &= ~PTE_W 。
You can do flags and equals the wave sign underscore W.

206
00:12:41,390 --> 00:12:44,150
是的，我们需要一个波浪号，
Yeah, yeah we're gonna need a tilde there,

207
00:12:44,150 --> 00:12:45,500
我把那个波浪标志叫做波浪号，
I call that wave sign tilde,

208
00:12:45,500 --> 00:12:47,630
我们需要波浪号，
the we need to the waves,

209
00:12:47,630 --> 00:12:50,450
我们需要清除 flags 上的这一位，
the it's clear we need to clear this bit on the flags,

210
00:12:50,450 --> 00:12:52,010
我们将保留所有其他 flags 的设置。
we're going to leave all the other flags set.

211
00:12:52,430 --> 00:12:56,030
好的，这样清除了父页表还是子页表的标志？
Okay, so that's gonna with this clear the flag of the parent or the child?

212
00:13:01,870 --> 00:13:02,440
子页表？
Child?

213
00:13:02,590 --> 00:13:03,640
只是子页表。
Just child.

214
00:13:04,040 --> 00:13:05,150
那么我如何清除，
So how do I clear,

215
00:13:05,180 --> 00:13:07,520
我需要清除父页表中的标志吗？
do I also need to clear the flag in the parent?

216
00:13:10,390 --> 00:13:15,790
是的，因为我们希望子页表独立于父页表，
Yes, because we want the child to be independent to the parents,

217
00:13:15,790 --> 00:13:17,020
如果我们写了一些东西，
if we write something,

218
00:13:17,020 --> 00:13:20,650
我们不想让子页表也得到父页表的修改。
we don't want the child to also get them modification from their parents.

219
00:13:20,890 --> 00:13:21,970
完全正确，
That's absolutely right,

220
00:13:22,000 --> 00:13:23,860
我们也需要对父页表进行写保护，
we need to write protect the page at the parent as well,

221
00:13:23,860 --> 00:13:27,310
因为我们不想让子页表看到父页表的修改，
because we don't want the child to see the parents modifications,

222
00:13:27,310 --> 00:13:30,710
所以试图模仿完全不同的副本。
so trying to mimic, having completely separate copies.

223
00:13:30,890 --> 00:13:35,420
那么我能怎么来清除父页表中的标志呢？
So what can I do to clear the flag in the parents' page table?

224
00:13:43,790 --> 00:13:49,160
你可以使用 *pte &= ~PTE ，对吧。
You can do something like star pte and equals not pte, right.

225
00:13:49,720 --> 00:13:51,370
是的，我有父页表的，
Yeah, so I have the parents p-,

226
00:13:51,370 --> 00:13:54,460
一个指向父页表条目的指针，就在 pte 中，
a pointer to the parents' page table entry right here in pte

227
00:13:54,970 --> 00:13:58,780
所以我可以这里清除 PTE 标志，
and so I can clear the PTE flag here too,

228
00:13:58,810 --> 00:13:59,950
这是很方便的。
so that's pretty convenient.

229
00:14:02,160 --> 00:14:07,900
我相信这会使页面的两个拷贝，
And my belief is that enough to make both copies of the page,

230
00:14:07,900 --> 00:14:12,380
页面的两个映射都是只读的。
so both mappings of the page read only.

231
00:14:13,000 --> 00:14:18,220
所以，希望现在我们可以得到写入错误。
So hopefully now we'll start getting write faults.

232
00:14:19,330 --> 00:14:23,620
是否可以清除 PTE_W 位，
Is it possible to do to clear the PTE_W bit,

233
00:14:23,620 --> 00:14:28,000
在 flags = PTE_FLAGS(*pte) 之前，
before you say flags equals PTE_FLAGS of pte,

234
00:14:28,600 --> 00:14:32,110
这样原来的 flags 才是正确的。
and that way like the original flags is just the correct thing.

235
00:14:32,320 --> 00:14:34,810
哦，我明白了，把东西放在这里。
Oh I see, you put away up here.

236
00:14:35,020 --> 00:14:35,470
是的。
Yeah.

237
00:14:35,710 --> 00:14:37,210
好的，我会试一下，
Yeah, I'll get that shot,

238
00:14:46,080 --> 00:14:48,420
似乎正常工作了，那就说得通了。
seems to work, that makes sense.

239
00:14:50,860 --> 00:14:52,750
好了，我现在得到了写入错误，
Okay, so now I get my write fault,

240
00:14:55,230 --> 00:14:56,340
正是我们所希望的，
which is what we're hoping for

241
00:14:56,370 --> 00:14:58,050
这个写入错误意味着
and hopefully what this write fault means is

242
00:14:58,050 --> 00:15:00,300
其他进程试图修改这个页面，
that one of the other processes tried to modify the page

243
00:15:00,300 --> 00:15:03,450
而 RISC-V 对此产生了页面错误。
and the RISC-V generated a page fault from that.

244
00:15:04,080 --> 00:15:06,980
我们要[]它，
And, we're gonna want to [] to that

245
00:15:06,980 --> 00:15:14,300
通过复制这个页面，并映射为读写。
by making a copy of the page and mapping it read write.

246
00:15:14,630 --> 00:15:16,310
在我们这样做之前，
Before we do that,

247
00:15:16,820 --> 00:15:19,760
为了确保我们所看到的，
just to make sure that what we're seeing,

248
00:15:19,760 --> 00:15:23,900
你知道这里的 f ，这个 scause ，
you know this, this, this f here, this scause,

249
00:15:24,260 --> 00:15:26,570
让我想到，
that is sort of making imagine that

250
00:15:26,570 --> 00:15:28,970
我们希望是保存错误，
we're seeing what we want to see namely a store fault,

251
00:15:28,970 --> 00:15:31,580
让我们看看实际发生了什么。
let's actually go look and see where that happened.

252
00:15:33,170 --> 00:15:35,120
我们知道这是进程 id 是 3 ，
We know it's process id 3,

253
00:15:35,150 --> 00:15:36,920
进程 id 1 是 init ，
process id 1 is init,

254
00:15:36,920 --> 00:15:39,890
进程 id 2 是 shell ，
process id 2 is the shell

255
00:15:40,220 --> 00:15:43,190
所以进程 id 3 可能是 cowtest 。
and so maybe process id 3 is going to be cowtest.

256
00:15:43,680 --> 00:15:54,290
我们可以看看 cowtest.asm 。
We can look in, we can look in cowtest.asm.

257
00:15:54,910 --> 00:15:58,180
看看 9da ，
And look for 9da

258
00:15:58,180 --> 00:16:05,630
它是否是一个可以生成保存页面错误的指令。
and see if it makes sense, as a instruction that could generate a store page fault.

259
00:16:08,880 --> 00:16:10,380
糟糕，看起来不太好。
Oops, don't look so good.

260
00:16:14,480 --> 00:16:16,490
我不记得 auipc 是做什么的，
I can't remember what auipc does,

261
00:16:16,490 --> 00:16:18,830
但我不相信它有保存的操作。
but I don't believe it performs a store.

262
00:16:20,120 --> 00:16:21,710
有人想到，发生了什么事吗？
Any guesses what's going on?

263
00:16:29,000 --> 00:16:32,540
如果看到的页面错误有意义，那就太好了。
It'd be nice, if the page fault who are seeing actually make sense.

264
00:16:36,580 --> 00:16:43,480
我告诉你，这个页面错误发生在 shell 中，
I'll tell you, it turns out this page fault occurred in the shell

265
00:16:43,510 --> 00:16:47,620
在 shell fork 之后， exec cowtest 之前，
after the shell fork, but before it exec cowtest

266
00:16:47,770 --> 00:16:50,200
所以，我们查看的是错误的 asm 文件，
and so we're really looking at the wrong asm file,

267
00:16:50,700 --> 00:16:53,370
正确的 asm 文件是 shell.asm 文件，
turns out the right asm file is shell.asm file,

268
00:16:53,370 --> 00:16:55,530
我们去那里找 9da 。
we'll look for 9da there.

269
00:16:56,880 --> 00:17:00,960
是的，在 shell 中， 9da 是一条存储指令，
Yes, and in the shell 9da is a store instruction

270
00:17:01,260 --> 00:17:04,500
它位于这个 parsecmd 函数的开头，
and it's at the beginning of this parsecmd function,

271
00:17:04,500 --> 00:17:07,950
它解析我们输入的 cowtest 命令，
that actually parses the cowtest command that we typed

272
00:17:07,950 --> 00:17:10,770
并如何处理它，也就是 exec ，
and figures out what to do with it, namely call exec,

273
00:17:11,430 --> 00:17:13,320
就像保存到堆栈一样，
as doing a store into the stack,

274
00:17:13,470 --> 00:17:19,380
它是前言，保存被调用者保存寄存器。
it's the preamble that stores the callee saved registers.

275
00:17:20,920 --> 00:17:22,000
这不令人惊讶，
And not surprisingly that,

276
00:17:22,000 --> 00:17:23,860
这应该是我们收到的第一个页面错误，
this should be the first page fault we get,

277
00:17:23,860 --> 00:17:25,510
因为它在堆栈上，
because it's on the stack,

278
00:17:25,540 --> 00:17:28,570
函数在 fork 之后做的第一件事返回是
you know the very first thing those functions do after fork returns is

279
00:17:28,570 --> 00:17:30,280
它们修改在堆栈中的变量，
they modify their variables in the stack

280
00:17:30,280 --> 00:17:34,510
然后砰的一声，不出所料，这导致了保存页面错误。
and boom, unsurprisingly that causes a store page fault.

281
00:17:35,440 --> 00:17:38,040
关于为什么得到错误，有什么问题吗？
Any questions about why we're faulting?

282
00:17:41,600 --> 00:17:42,680
我有一个简短的问题，
I have a quick question,

283
00:17:42,680 --> 00:17:46,670
你怎么知道是在 shell 中而不是 cowtest ？
how did you figure out it was in the shell rather than in cowtest?

284
00:17:47,300 --> 00:17:50,750
因为我在 cowtest 里面看到 9da ，
Because I looked at 9da in cowtest

285
00:17:50,840 --> 00:17:52,520
而那个不是保存指令。
and that is not a store instruction.

286
00:17:53,800 --> 00:17:58,000
我想，天哪，这是怎么回事。
I thought gosh what could possibly be going on.

287
00:17:59,430 --> 00:18:00,570
现在，看看进程 id 。
Now, look at process id.

288
00:18:00,570 --> 00:18:03,270
那么 pid 3 是 shell ，还是。
Three, so is pid 3 to shell or is it.

289
00:18:03,270 --> 00:18:07,110
pid 3 是， pid 2 是打印提示符的 shell ，
Pid 3 is, pid 2 is the shell that printed that prompt,

290
00:18:07,440 --> 00:18:10,590
pid 3 它创建的下一个进程，
pid 3 is the next process that's created

291
00:18:10,860 --> 00:18:15,820
所以最初 shell fork 得到 pid 3 。
and so initially the shell forks to make pid 3.

292
00:18:16,380 --> 00:18:19,050
但 fork 之后，它仍在运行 shell ，
But after the fork, it's still running the shell,

293
00:18:19,230 --> 00:18:23,610
它是 shell 的子进程运行着 shell ，
it's a child of the shell running a copy of the shell,

294
00:18:23,820 --> 00:18:26,790
它将调用 exec 来运行 cowtest ，
it's going to call exec to run cowtest,

295
00:18:26,790 --> 00:18:27,960
但它还没有做，
but it hasn't done it yet,

296
00:18:28,980 --> 00:18:30,540
它没有到达那里，
it hasn't been able to get that far,

297
00:18:30,540 --> 00:18:37,090
因为当它写入堆栈时，得到一个保存页面错误。
with taking a store page fault, when it writes to stack.

298
00:18:38,900 --> 00:18:39,890
那么，您能澄清一下，
So, can you clarify,

299
00:18:39,890 --> 00:18:45,380
这是否意味着进程 id 为 2 的 shell 存在错误，
does that mean that there's an error with the shell related process id 2,

300
00:18:45,380 --> 00:18:50,600
因为它没有正确的数据让子进程拥有正确的数据，
because it doesn't have the proper data in order for the child to have the right data

301
00:18:50,600 --> 00:18:53,810
或者是进程 id 为 3 的错误。
or is it a error with process id 3.

302
00:18:55,190 --> 00:18:59,190
这是一个页面错误，发生在进程 id 3 中。
It's a page fault, that occurs in process id 3.

303
00:19:00,620 --> 00:19:03,320
是的，但是我们看到的 bug 就像。
Right, but the bug that we're seeing right here like.

304
00:19:05,380 --> 00:19:09,160
这是在实现写入时复制 fork ，
This is implementing copy-on-write fork

305
00:19:09,640 --> 00:19:13,870
我们刚才在 vm.c 中所做的是
and what we just did in vm.c was

306
00:19:13,900 --> 00:19:20,440
写保护父进程和子进程中的每一页。
write protect every single page in the parent and the child, right.

307
00:19:20,820 --> 00:19:22,020
这是这行正在做的事情，
That's what this line is doing,

308
00:19:22,320 --> 00:19:27,090
所以，下次父进程或子进程在用户代码有保存时，
so the next time either the parent or the child has a store from user code,

309
00:19:27,710 --> 00:19:30,140
它将保存到写保护页中，
it's going to be a store into a write protected page,

310
00:19:30,170 --> 00:19:31,670
因为每一页都是写保护的，
because every page is write protected,

311
00:19:31,760 --> 00:19:33,650
所以它会导致页面错误。
and so it will cause a page fault.

312
00:19:34,330 --> 00:19:36,760
哦，这就是我们想要的页面错误。
Oh, so this is the proper page fault that we want.

313
00:19:36,790 --> 00:19:40,960
对，我只是在检查那个，
This, right and I was just all I was doing was checking that,

314
00:19:42,430 --> 00:19:45,430
所发生的事情正是我们认为的，
that what's going on is exactly what we think is going on,

315
00:19:45,700 --> 00:19:47,230
而不是其他的 bug 。
as opposed to some other bug.

316
00:19:48,640 --> 00:19:49,960
好的。
Okay alright.

317
00:19:49,960 --> 00:19:51,820
所以我们在这里得到一个保存页面错误，
So we took a page fault here in this store

318
00:19:51,820 --> 00:19:54,670
是 shell 在 fork 之后的第一个保存。
which is presumably the first store the shell does after the fork.

319
00:19:57,090 --> 00:19:59,220
好的，所以现在我们要处理这些，
Okay, so now we have to handle these,

320
00:20:00,020 --> 00:20:04,030
现在你要在这个页面错误中做一些有用的事情。
now you want to do something useful in this page fault.

321
00:20:04,090 --> 00:20:12,530
所以， trap.c 和用户错误中的页面错误处理程序。
So, where's the page fault handlers in trap.c and user fault.

322
00:20:16,020 --> 00:20:20,340
我想我们在哪里插入代码无关紧要。
I think it pretty much doesn't matter where we insert code to.

323
00:20:20,960 --> 00:20:25,400
我是说，这里有很多不同的 uservec 的情况，
I mean, there's all these different cases here that uservec,

324
00:20:25,460 --> 00:20:27,770
uservec 或 usertrap ，
this uservec or usertrap,

325
00:20:27,770 --> 00:20:31,370
usertrap 就是添加另一个 usertrap ，
the usertrap is dealing with just going to throw in another else,

326
00:20:31,700 --> 00:20:35,030
我们只对写入错误感兴趣，
we only interested in write faults,

327
00:20:35,030 --> 00:20:36,890
我们很高兴读这些共享页面，
we're happy to read these shared pages,

328
00:20:36,890 --> 00:20:40,630
因为所有的东西都在那里，只是写[]，
because all that is there, it's just write to on [],

329
00:20:40,630 --> 00:20:41,050
所以。
so.

330
00:20:47,620 --> 00:20:50,850
现在，我相信你知道，
Now, it turns out as, I'm sure you know,

331
00:20:50,850 --> 00:20:52,980
我们将需要使用代码，
that we're going to need to use the code,

332
00:20:52,980 --> 00:20:54,840
我要在两个不同的地方写代码，
I'm about to write from two different places,

333
00:20:54,870 --> 00:20:59,840
我要把它封装在代码中，
I'm going to just wrap it up in the code,

334
00:20:59,840 --> 00:21:04,880
让页面的复制在一个函数中，我称为 cowfault 。
that makes the copy of this page in a function, I'm gonna call cowfault.

335
00:21:05,930 --> 00:21:08,090
它需要知道当前的页表，
It needs to know the current page table

336
00:21:08,540 --> 00:21:13,280
也需要知道我们在 stval 上出错的虚拟地址。
and it needs to know the virtual address that we faulted on stval.

337
00:21:13,960 --> 00:21:17,590
有时它可能会因为内存不足而失败，
Sometimes it can fail, because say it runs out of memory,

338
00:21:18,520 --> 00:21:20,260
可能 kalloc 会失败，
maybe kall- kalloc will fail,

339
00:21:20,260 --> 00:21:21,970
所以我们需要为返回值做好准备。
so we need to prepare for return value.

340
00:21:22,270 --> 00:21:24,610
不管失败的原因是什么，
And pretty much no matter what the failure is,

341
00:21:25,190 --> 00:21:28,770
我们都会杀死这个进程，
we're gonna kill this process, right,

342
00:21:28,830 --> 00:21:29,700
如果我们没有杀死它，
if we didn't kill it,

343
00:21:30,060 --> 00:21:32,940
如果出现失败，我们让 cowfault 返回 -1 ，
we'll have cowfault return -1, if there's a failure,

344
00:21:33,240 --> 00:21:35,220
如果没有失败，则返回 0 。
returns 0, if there's no failure.

345
00:21:35,730 --> 00:21:36,720
如果没有失败，
There's no failure,

346
00:21:36,720 --> 00:21:40,680
我们将依赖于 cowfault 使虚拟地址可写，
then we're going to rely on cowfault having made this virtual address writable,

347
00:21:40,800 --> 00:21:42,540
所以当 usertrap 返回时，
so that when usertrap returns,

348
00:21:42,540 --> 00:21:44,970
这个进程可以继续成功。
the process can actually continue successfully.

349
00:21:47,510 --> 00:21:50,600
为什么这么放，
Why that you put,

350
00:21:50,600 --> 00:21:51,650
有没有理由
like is there a reason

351
00:21:51,770 --> 00:21:56,240
为什么把这一行放在 else if devintr 之上。
why you put this line above the else if which dev- devintr.

352
00:21:59,520 --> 00:22:01,260
我不这样认为,
I don't think so,

353
00:22:01,410 --> 00:22:04,740
它是否正确，取决于 devintr 做了什么，
whether it's correct depends on what devintr does,

354
00:22:04,740 --> 00:22:05,940
查看一下，
just take a look,

355
00:22:05,970 --> 00:22:08,310
风险是 devintr 可能会，
the risk is that devintr might,

356
00:22:10,080 --> 00:22:12,720
因为某种原因看到设备中断，
see a device interrupt for some reason,

357
00:22:12,750 --> 00:22:14,130
即使我们出现了页面错误。
even though we are on a page fault.

358
00:22:14,700 --> 00:22:17,760
所以我们只要看看 devintr ，
So we just gotta check that devintr,

359
00:22:18,340 --> 00:22:23,040
看一下 scause 是 f ，
looks at scause, and scause is f,

360
00:22:23,640 --> 00:22:25,080
它将返回 0 。
it's going to return 0.

361
00:22:25,760 --> 00:22:30,200
所以，我只想确定如果。
So, just want to make sure that if.

362
00:22:32,400 --> 00:22:33,900
是的，如果 devintr 返回 0 ，
Yeah, if devintr returns 0,

363
00:22:33,900 --> 00:22:38,920
那么它将继续执行我们的代码，那很好。
then it's gonna go on to our code, that's fine.

364
00:22:40,220 --> 00:22:40,790
好的。
Okay.

365
00:22:41,430 --> 00:22:42,630
好的，现在我们只需要写。
Okay, now we only need to write.

366
00:22:44,210 --> 00:22:46,550
实际上，有一件事我想在这里提醒，
Actually this one thing I want to observe here

367
00:22:46,700 --> 00:22:49,920
如果出现失败，我们就会杀死这个进程。
and that's that if there's a failure, we kill the process.

368
00:22:50,610 --> 00:22:52,840
所以，这很不幸，
So, this is unfortunate,

369
00:22:52,990 --> 00:22:54,640
那就太棒了，
it would be fantastic,

370
00:22:54,670 --> 00:22:57,220
大多数情况下，
if instead you know most of the time,

371
00:22:57,280 --> 00:23:00,190
进程通过调用系统调用来分配内存或其他什么，
processes allocate memory or whatever by calling system calls,

372
00:23:00,190 --> 00:23:03,670
系统调用可以返回一些错误值 -1 或其他，
the system calls can return some error value -1 or something,

373
00:23:03,670 --> 00:23:06,730
如果出现失败，进程就可以做一些适当的事情，
if there's a failure and the process can then do something appropriate,

374
00:23:08,020 --> 00:23:10,120
它知道如何处理这一失败，
if it knows how in order to deal with that failure,

375
00:23:10,360 --> 00:23:12,400
但是这里，因为没有系统调用，
here though because there's no system call,

376
00:23:12,430 --> 00:23:16,720
没有任何明显的方式来告诉进程出了问题，
there's not any obvious way to tell the process that something went wrong,

377
00:23:17,980 --> 00:23:20,020
这是令人恼火的，
which is irritating,

378
00:23:20,590 --> 00:23:22,270
你可以想象解决这个问题的方法，
you can imagine solutions to this,

379
00:23:22,270 --> 00:23:25,360
例如在一些更复杂的操作系统中，
for example in some more sophisticated operating system,

380
00:23:26,200 --> 00:23:31,720
我们可以有比如 alarm 的用户故障处理程序，
we could have something like the alarm user fault handler that you implemented,

381
00:23:31,720 --> 00:23:32,890
我们可以调用，
that we could call up into

382
00:23:32,890 --> 00:23:35,470
表示我们不能继续你的进程了，
to say look you know we can't continue your process,

383
00:23:35,470 --> 00:23:37,880
因为我们无法修复这个页面错误，
because we can't fix this page fault,

384
00:23:37,940 --> 00:23:39,770
但我们想告诉你出了问题。
but we want to tell you something went wrong.

385
00:23:41,660 --> 00:23:43,400
但我们现在不会这么做，
But we're not gonna do that now,

386
00:23:44,490 --> 00:23:46,230
杀死这个进程要简单得多。
it's much simpler to just kill the process.

387
00:23:46,770 --> 00:23:51,390
好的，所以我们要实现这个 cowfault 程序，
Okay, so we have to implement page, this cowfault program,

388
00:23:51,420 --> 00:23:58,200
使用一个对应当前页表的 pagetable ，
takes a, on a pagetable to current this page table,

389
00:23:58,200 --> 00:24:01,980
这个参数，出现错误的虚拟地址。
this argument, the virtual address that the fault occurred on.

390
00:24:05,780 --> 00:24:08,330
好的，所以我们要考虑的第一个问题，
Okay, so the first question we have to worry about,

391
00:24:08,330 --> 00:24:12,140
什么时候处理用户程序产生的虚拟地址，
when dealing with virtual addresses that the user program produced,

392
00:24:12,170 --> 00:24:12,950
就像这个地址一样，
like this one,

393
00:24:13,070 --> 00:24:17,030
如果它是一个完全疯狂的地址，
is what if it's a completely crazy address,

394
00:24:17,150 --> 00:24:19,610
比如在进程[顶部]上方，
like way up above the top of the process,

395
00:24:19,610 --> 00:24:24,830
如果地址在 trapframe 或 trampoine 页面上，
what if it's an address like in the trapframe or in the trampoline page,

396
00:24:24,830 --> 00:24:28,310
或者在堆栈保护页上。
or in the page, the stack guard page.

397
00:24:33,300 --> 00:24:35,190
所以有人可以想出一种方法，
So can anybody sort of outline a strategy

398
00:24:35,190 --> 00:24:43,720
保护自己不受用户进程故意在疯狂地址上出错的影响。
for defending ourselves against the user process intentionally faulting on crazy addresses.

399
00:24:50,100 --> 00:24:52,950
是不是有个最大虚拟地址。
Isn't there like a max virtual address.

400
00:24:54,090 --> 00:24:57,810
是的，确实会出现，
Yes, yes there is and that will actually come up,

401
00:24:58,170 --> 00:25:06,520
但是用户地址空间的顶部在 MAXVA 下面，
but the top of the user address space is below MAXVA,

402
00:25:08,010 --> 00:25:13,190
而且堆栈保护页面，
and the like the stack guard page,

403
00:25:13,580 --> 00:25:15,260
我们不应该允许，
which we shouldn't be allowing, right,

404
00:25:15,260 --> 00:25:17,120
不应该把它当作写入时复制的东西。
shouldn't be treating as a copy-on-write thing.

405
00:25:17,660 --> 00:25:24,310
好的，我会在这里展示一个解决方案。
Alright, I will, I'll show a solution here.

406
00:25:24,860 --> 00:25:26,660
我们在这里调用 walk 。
We're just gonna call walk for now.

407
00:25:29,910 --> 00:25:32,040
有一件事可能会出错的是，
And one thing that can go wrong is

408
00:25:32,040 --> 00:25:34,500
walk 找不到页表条目，
walk doesn't find a page table entry,

409
00:25:34,890 --> 00:25:39,690
所以，对于进程可能引用的大多数非法页面，
so for most illegal pages that a process might refer to,

410
00:25:39,870 --> 00:25:41,190
没有 pte ，
theres no pte,

411
00:25:41,630 --> 00:25:43,820
而且只有几个例外，
and there's only a few exceptions to that,

412
00:25:43,850 --> 00:25:46,430
所以如果我们检测到非法，
so if we detect the illegal,

413
00:25:46,430 --> 00:25:49,430
如果我们检测到 pte 没有找到，
if we detect detect the pte not found,

414
00:25:49,430 --> 00:25:52,760
从 walk 返回 -1 ，
return value from walk and return -1,

415
00:25:53,370 --> 00:25:55,020
我们几乎处理了所有的情况，
we've handled almost every case,

416
00:25:55,380 --> 00:25:59,820
唯一的情况是 walk 会在哪里返回页表条目，
the only cases I'm aware of, where walk would return a page table entry,

417
00:25:59,820 --> 00:26:01,830
但是我们不想允许对其进行写入，
but we don't want to allow writes to it

418
00:26:02,040 --> 00:26:07,230
是 trampoline tramframe 和堆栈保护页面，
are for the trampoline trapframe and stack guard pages,

419
00:26:07,780 --> 00:26:10,210
这些都没有 PTE_U 。
and those all have PTE_U clear.

420
00:26:11,700 --> 00:26:15,780
所以我要检测非法地址的方法是
So the way I'm going to detect crazy addresses illegal addresses is

421
00:26:15,780 --> 00:26:21,050
通过检查 PTE_U 是否被设置，
by checking that PTE_U is set,

422
00:26:22,700 --> 00:26:26,630
另外，只要检查一下 PTE_V ，
and also, just checks look at PTE_V,

423
00:26:29,500 --> 00:26:30,820
如果其中任何一个没有设置，
and if either of those is clear,

424
00:26:30,820 --> 00:26:36,160
那我们就知道这是个不好的地址，
then we know this is like not an okay address,

425
00:26:37,540 --> 00:26:40,300
只需返回 -1 ，杀死进程，
and just return -1, so killed process,

426
00:26:40,990 --> 00:26:51,580
所以我相信处理了所有的非法地址，
so I believe taking care of all the, illegal addresses,

427
00:26:51,580 --> 00:26:54,370
用户进程可以使用的。
the user process could use, try to use.

428
00:26:55,800 --> 00:26:57,510
好的，我们怎么才能知道，
Alright, how can we find out,

429
00:26:57,510 --> 00:26:58,290
我们想要一份拷贝，
we want to do a copy,

430
00:26:58,290 --> 00:27:01,950
现在我们想要这个进程页面的复制，
now we want to make this process copy of the page,

431
00:27:02,430 --> 00:27:04,410
我们怎样才能找到要复制的页面。
how do we find the page to copy from.

432
00:27:05,270 --> 00:27:06,620
这里我有个问题。
I have a question here.

433
00:27:06,770 --> 00:27:07,310
请说。
Please.

434
00:27:07,780 --> 00:27:14,890
使用 PTE_U 来判断页面是否，
Wouldn't the strategy of using the PTE_U to judge if the pages,

435
00:27:15,550 --> 00:27:19,660
如果是合法的写入时复制页面，
if they're, if it's a legit page for copy-on-write,

436
00:27:19,810 --> 00:27:23,980
这个策略是不是对长期进程不友好，
wouldn't this strategy not be very good for the long-term process,

437
00:27:23,980 --> 00:27:29,290
也许你会地址空间中添加一些其他部分，
maybe you add some other part to the address space,

438
00:27:29,290 --> 00:27:32,460
它可能是可写的，
which is which is supposed to be a writable,

439
00:27:32,550 --> 00:27:35,130
它们应该是只是可读的，
which are only supposed to be readable,

440
00:27:35,220 --> 00:27:37,470
但这在这里没有考虑到，
but that doesn't get taken care of here,

441
00:27:37,710 --> 00:27:39,540
你还得再回来一次。
as in you'll have to come back here again.

442
00:27:40,050 --> 00:27:41,370
你说得对，
You're absolutely right,

443
00:27:41,400 --> 00:27:46,490
如果我们要添加任何其他有趣的分页功能，
if we are to add any other interesting paging feature,

444
00:27:46,520 --> 00:27:49,130
比如懒分页，
like maybe lazy page allocation, for example,

445
00:27:49,940 --> 00:27:51,500
我们必须重新审视这些决定，
we have to revisit these decisions

446
00:27:51,500 --> 00:27:53,630
然后想出一些其他的策略来决定，
and come up with some other strategy for deciding

447
00:27:53,840 --> 00:27:55,670
这是不是写入时复制页面，
is this a copy-on-write page,

448
00:27:55,670 --> 00:27:58,010
这是不是一个懒分配页面，
is this a lazy allocation page,

449
00:27:58,010 --> 00:28:00,650
这是不是一个调出到磁盘的页面，
is this a page-out to disk pages,

450
00:28:00,650 --> 00:28:02,450
比如内存映射文件。
to say memory map file.

451
00:28:02,840 --> 00:28:05,780
我们需要更复杂的，
And we need more sophisticated,

452
00:28:06,470 --> 00:28:08,420
最终我认为，
you know, in the end I think,

453
00:28:09,040 --> 00:28:13,120
大多数正式的操作系统都保留了自己的数据结构，
and most serious operating systems actually keep their own data structure,

454
00:28:13,820 --> 00:28:16,220
不是一个页表，
nothing to do with, you know not a page table,

455
00:28:16,220 --> 00:28:17,750
而是某种程度上模仿页表，
but sort of mimicking a page table,

456
00:28:17,810 --> 00:28:20,120
它描述了进程的地址空间，
that describes the process's address space

457
00:28:20,120 --> 00:28:22,670
并在描述了每个页面的含义，
and sort of describes what each page means

458
00:28:22,670 --> 00:28:23,750
以及它的状态是什么，
and what its state is

459
00:28:23,780 --> 00:28:25,220
我们必须参考那张表。
and we have to consult that table.

460
00:28:27,230 --> 00:28:28,550
但是对这个实验来说，
But for this lab,

461
00:28:28,820 --> 00:28:30,530
因为我们没有其他功能，
since we don't have those other features

462
00:28:30,530 --> 00:28:33,020
我们不确定它们会是什么样子，
and we're not sure what they would be,

463
00:28:33,800 --> 00:28:35,330
我只想做些简单的事，
I'm just gonna do something straightforward

464
00:28:35,360 --> 00:28:37,040
事实上，我们不得不回来修复它，
and indeed we would have to come back and fix it,

465
00:28:37,190 --> 00:28:40,040
如果我们把 xv6 做得更复杂。
if we made xv6 more sophisticated.

466
00:28:41,740 --> 00:28:46,630
如果 va 大于 MAXVA ，不会产生 panic 吗，
And wouldn't that panic if va is more than MAXVA,

467
00:28:46,630 --> 00:28:47,800
因为 walk 。
because of the walk.

468
00:28:51,630 --> 00:28:54,150
[]，会的。
[] me, you would.

469
00:28:58,630 --> 00:29:01,240
看看这个，也许是这个过程。
Now, look at that, maybe it's the process.

470
00:29:03,310 --> 00:29:04,750
是的，我想你是对的。
Yeah, I think you're right.

471
00:29:05,660 --> 00:29:06,470
太糟糕了。
That's too bad.

472
00:29:06,710 --> 00:29:09,720
好的，你说得对，
Okay, so we're certainly, you're right,

473
00:29:09,720 --> 00:29:11,730
好的，在这件事上我错了。
alright, well I was wrong about this.

474
00:29:12,680 --> 00:29:16,880
等等，如果你检查 MAXVA ，能直接返回 -1 吗？
Wait, can you just return a -1, if you just check the MAXVA.

475
00:29:16,910 --> 00:29:18,260
我认为观察到的情况是，
I think the observation is

476
00:29:18,260 --> 00:29:24,950
如果用户试图编写程序写入非常大的地址，
that if the user tries to intentionally program tries to write to very large address,

477
00:29:25,500 --> 00:29:29,310
当然，你不能避免这个，
of course, you can't expect to survive that,

478
00:29:30,660 --> 00:29:34,830
但是在这里是用一个非常大的地址调用 walk ，
but what we would do here is call walk with a very large address

479
00:29:35,070 --> 00:29:38,010
看看这里， walk 的实现，
and looking at here, the implementation of walk in the,

480
00:29:39,780 --> 00:29:40,830
它会产生一个 panic 。
and it's going to panic.

481
00:29:42,120 --> 00:29:45,210
然后我们就可以使用相同的方法 walk 地址，
Then we can just use the same approaches walk address,

482
00:29:45,210 --> 00:29:46,590
我也有同样的 bug ，
does I had this same bug,

483
00:29:47,180 --> 00:29:50,030
你可以像其他人说的那样返回 -1 ，
you can just return -1 like other people are saying,

484
00:29:50,060 --> 00:29:53,450
如果在 walk 之前 va 大于 MAXVA 。
if va is greater than MAXVA before walk.

485
00:29:55,300 --> 00:29:58,300
让我失望的是，测试似乎没有测试这一点。
What I'm upset about is that the tests don't seem to test this.

486
00:29:59,720 --> 00:30:01,730
因为我没有把这个放进我的解决方案里。
Because I didn't put this in my solution.

487
00:30:03,050 --> 00:30:03,860
好的。
Okay.

488
00:30:08,350 --> 00:30:08,890
好的。
Okay.

489
00:30:10,200 --> 00:30:12,240
好的，那么我们怎么才能找到，
Okay, so how do we find,

490
00:30:12,240 --> 00:30:14,520
我们想要复制页面，
that we need, we want to copy the page,

491
00:30:14,790 --> 00:30:16,920
如何获得指向页面的指针，
how do I get a pointer to the page

492
00:30:16,920 --> 00:30:19,870
指向我可以复制的页面的指针。
to the pointer to something I can copy.

493
00:30:22,720 --> 00:30:24,040
PTE2PA 。
The PTE2PA.

494
00:30:24,310 --> 00:30:27,780
是的，所以，它在 pte ，
Yeah, so, it's just in the pte,

495
00:30:33,790 --> 00:30:36,100
我要复制到哪里，
where am I gonna copy to,

496
00:30:41,040 --> 00:30:42,240
我应该复制到什么地方。
what should I copy to.

497
00:30:44,140 --> 00:30:45,640
一个几乎被分配的页面。
A nearly allocated page.

498
00:30:46,000 --> 00:30:48,790
是的，所以我调用 kalloc ，
Yeah, so I just called kalloc,

499
00:30:50,190 --> 00:30:53,040
当然， kalloc 可能会失败，
of course kalloc is likely to fail,

500
00:30:53,040 --> 00:30:56,010
所以我会捕获它，
so I'm gonna catch that,

501
00:30:57,520 --> 00:30:59,260
我们要看看这个，
we're actually gonna see this,

502
00:31:01,770 --> 00:31:03,900
所以我放一个 print 语句，这样我们就知道了。
so I'm gonna put a print statement, so we know.

503
00:31:05,670 --> 00:31:06,150
好的，我们。
Okay, we.

504
00:31:06,150 --> 00:31:09,060
那不是 pa2 吗，那个等于。
Is that pa2, that equal.

505
00:31:10,390 --> 00:31:14,390
嘿，我留了这个错误，
Hey, I actually made this error

506
00:31:14,390 --> 00:31:15,680
我想重现它，
and I wanted to reproduce it,

507
00:31:15,680 --> 00:31:17,000
这样我们才能追踪到它，
so that we would have to track it down,

508
00:31:17,000 --> 00:31:20,150
对我来说，你太聪明了。
but you're too clever for me.

509
00:31:21,320 --> 00:31:27,520
我要从 pa1 复制到 pa2 。
I want to copy two pa2 from pa1.

510
00:31:31,330 --> 00:31:34,480
好的，那么我该怎么，我需要做些什么，
Okay, so how can I, what do I need to do

511
00:31:34,480 --> 00:31:41,400
为了映射新的页面 pa2 进入地址空间。
in order to map this page, this new page pa2 into the address space.

512
00:31:46,340 --> 00:31:47,390
我应该输入什么？
What should I type?

513
00:31:48,610 --> 00:31:50,350
有两种方法，
There's like two broad ways,

514
00:31:50,350 --> 00:31:54,700
可以使用已存在的取消映射和映射，
there's either unmapping and then mapping with the built-in that exist,

515
00:31:55,180 --> 00:31:58,030
或者你可以操纵这些位。
or you could manipulate the bits.

516
00:31:58,510 --> 00:32:01,180
是的，我太懒了，
Yeah I am way too lazy

517
00:32:01,180 --> 00:32:04,330
不想解决如何使用 munmap 和 mmap ，
to figure out how to use munmap and mmap,

518
00:32:04,330 --> 00:32:08,550
所以我在这里创造一个新的页表条目。
so I'm gonna just cook up a new page table entry right here.

519
00:32:13,400 --> 00:32:14,840
我有个问题，
I have a question,

520
00:32:14,870 --> 00:32:18,530
实际上我几乎在每个实验都遇到了这个问题，
so actually I ran into this issue in almost every lab

521
00:32:18,530 --> 00:32:23,390
因为某种原因，我需要重新映射，
in which I somehow needed to re-map things

522
00:32:23,390 --> 00:32:27,590
因为它经常发生，
and because it occurred too often,

523
00:32:27,590 --> 00:32:33,960
我实现了一个可以重新映射，
I implemented a map that which could re-map basically,

524
00:32:34,290 --> 00:32:39,120
我想知道这是不是一个糟糕的设计，
and I was wondering is that a bad design choices,

525
00:32:39,120 --> 00:32:40,740
比如危险，所以。
like dangerous, so.

526
00:32:41,010 --> 00:32:44,100
不，这完全合理，
No, no, that's totally reasonable,

527
00:32:44,100 --> 00:32:46,260
xv6 中的函数是，
you know the functions in xv6 are,

528
00:32:47,140 --> 00:32:52,030
专门针对现有的 xv6 ，
are you know specialized to xv6 as it exists,

529
00:32:52,450 --> 00:32:58,520
它们假设其他代码是如何工作的，
and so they you know they make assumptions about how the other code works,

530
00:32:58,520 --> 00:32:59,660
它们产生 panic ，
they have panics in them,

531
00:32:59,660 --> 00:33:03,350
捕获以意外方式使用它们的代码，
that are intended to catch other code using them in unexpected ways,

532
00:33:03,350 --> 00:33:05,330
但是如果你改变了 xv6 的工作方式，
but if you change the way xv6 works

533
00:33:05,330 --> 00:33:06,590
你需要做不同的事情，
and you need to do different things,

534
00:33:06,590 --> 00:33:07,940
它是完全合理的，
then it's totally reasonable

535
00:33:07,940 --> 00:33:13,710
你需要能够在重新映射时没有 panic ，
to modify you know you need to be able to re-map this without a panic,

536
00:33:13,710 --> 00:33:16,050
旧的 xv6 不需要这样做。
well, old xv6 never needs to do that.

537
00:33:18,440 --> 00:33:19,550
如果你的代码这样做了，
If your code does so,

538
00:33:19,670 --> 00:33:22,250
你可以随意修改所需的任何内容。
you should feel free to modify anything you need to.

539
00:33:25,340 --> 00:33:29,060
好的，所以，方法就在这里，
Okay, so okay, so the deal is here,

540
00:33:29,060 --> 00:33:30,440
我们有一个写保护的页面，
we had a write protected page

541
00:33:30,440 --> 00:33:32,450
可能与另一个进程共享，
that was probably shared with another process,

542
00:33:32,480 --> 00:33:35,420
在这里，我们必须对另一个进程做些什么，
what do we have to do to that other process at this point,

543
00:33:39,240 --> 00:33:40,920
我们需要对另一个进程做些什么。
what do we need to do to the other process.

544
00:33:46,340 --> 00:33:48,980
我们可以什么都不做，
We can just not do anything,

545
00:33:48,980 --> 00:33:51,080
然后当出现页面错误时，
and then when it page faults,

546
00:33:51,560 --> 00:33:55,970
我们分配一个新页面并删除原始页面。
we allocate a new page and remove the original one.

547
00:33:56,550 --> 00:33:57,420
完全正确，
That's absolutely right,

548
00:33:57,630 --> 00:33:58,980
所以你可以想象做一件事，
so you could imagine doing something,

549
00:33:58,980 --> 00:34:01,350
但是要正确地做它是相当复杂的，
but it would be quite complex to do it correctly

550
00:34:01,740 --> 00:34:03,630
所以我们什么都不做，
and so we just do nothing,

551
00:34:03,870 --> 00:34:06,780
如果另一个进程从来没有写入这一页，
and if the other process never write this page,

552
00:34:06,780 --> 00:34:07,950
那么就不是问题，
well it's not a problem,

553
00:34:08,070 --> 00:34:09,120
如果它写了这一页，
if it does write a page,

554
00:34:09,120 --> 00:34:10,590
那么它就会经历这一切，
then it will go through all this,

555
00:34:10,590 --> 00:34:15,090
它会复制一份，也会安全地进行，
it will make a copy and it'll proceed safely as well,

556
00:34:15,600 --> 00:34:17,400
所以什么都不做，是完全合理的。
so doing nothing is totally reasonable.

557
00:34:18,540 --> 00:34:21,270
好的，现在我们将返回，
Okay, so now we're going to return,

558
00:34:21,270 --> 00:34:24,180
返回值是 0 ，因为没有错误，
the return value of 0, since there was no error

559
00:34:24,360 --> 00:34:27,180
希望这个过程会。
and hopefully the process will.

560
00:34:29,000 --> 00:34:32,030
也许我们应该释放物理页面，
Maybe we should should free the physical page right,

561
00:34:32,810 --> 00:34:34,100
或者我们还没有到那一步。
or are we not there yet.

562
00:34:34,490 --> 00:34:36,140
我们没有。
We are not.

563
00:34:38,030 --> 00:34:41,300
我想我们要单步了，我们不应该，是的。
I guess we're going steps, we shouldn't, yeah.

564
00:34:41,570 --> 00:34:44,270
如果我这么做了，会发生什么。
So if I did this, what would happen.

565
00:34:44,930 --> 00:34:47,480
它们肯定会崩溃，是的。
Well they would definitely crash, right, alright.

566
00:34:47,480 --> 00:34:48,440
所以我们不要这样做，
So let's not do this

567
00:34:49,880 --> 00:34:53,020
或者我不知道我们会不会崩溃，
or I don't know if we'll crash,

568
00:34:53,020 --> 00:34:54,490
但是我们，
but we would then be,

569
00:34:54,760 --> 00:34:56,920
如果我们释放页面，
if we if we free the page,

570
00:34:57,190 --> 00:34:59,500
它肯定是 pa1 ，
it would be presumably pa1,

571
00:34:59,500 --> 00:35:01,480
因为我们不会释放 pa2 ，
because we don't have free pa2,

572
00:35:01,780 --> 00:35:03,340
因为我们用的是 pa2 ，
because we're using pa2,

573
00:35:03,340 --> 00:35:07,180
如果我们释放 pa1 ，这意味着另一个进程会有问题，
if we free pa1, that means the other process has got a problem,

574
00:35:07,720 --> 00:35:09,520
它现在已经映射到地址空间，
it has now mapped into its address space

575
00:35:09,520 --> 00:35:12,940
大概是使用执行指令，我不知道是什么，
and presumably using executing instructions in, I don't know what,

576
00:35:13,360 --> 00:35:14,920
我们刚刚释放的页面，
a page that we just freed

577
00:35:14,920 --> 00:35:16,930
可能会被重新用于其他目的，
and might be reusing for some other purpose,

578
00:35:17,480 --> 00:35:18,770
写些别的东西，
writing something else over,

579
00:35:18,950 --> 00:35:24,090
所以我不愿意释放它，尽管它是。
so I'm reluctant to free it, although it's.

580
00:35:26,880 --> 00:35:31,230
是的，很遗憾，出现很多事情，
Oh yeah, so sadly, among many other things,

581
00:35:31,960 --> 00:35:39,560
在原始的 xv6 中， walk 不会从 vm.c 以外调用，
xv6 walk is never called from outside of the vm.c, in ordinary xv6,

582
00:35:39,560 --> 00:35:41,270
但是现在我们正在做。
but now we're doing it.

583
00:35:51,120 --> 00:35:52,890
好了，我们到哪儿了。
Alright, where were we.

584
00:35:59,230 --> 00:36:03,790
好的，记得我们得到的第一个页面是 scause 2 ，
Okay, remeber the very first page what we got was scause 2,

585
00:36:04,210 --> 00:36:07,090
为什么我们会得到 scause 2 页面错误。
why are we getting scause 2 page faults.

586
00:36:14,300 --> 00:36:15,650
这是非法指令，
It's an illegal instruction,

587
00:36:20,920 --> 00:36:22,180
这是下一个问题，
like this is the next problem,

588
00:36:22,630 --> 00:36:24,430
我们现在必须解决这个问题。
we have to solve this problem now.

589
00:36:26,020 --> 00:36:26,950
出了什么问题，
What's gone wrong,

590
00:36:32,300 --> 00:36:36,050
或者猜一下可能出了什么问题？
or what are what are some plausible guesses for what might have gone wrong.

591
00:36:43,270 --> 00:36:46,210
所以当我输入 cowtest ，
So the sequence we when I type cowtest,

592
00:36:46,240 --> 00:36:50,800
我们认为发生的情况是 shell fork 是写入时复制 fork 。
what we think happens is that the shell fork is copy-on-write fork.

593
00:36:51,710 --> 00:36:57,300
我们有个子进程在运行 shell 指令，
We have a child running the shell's instructions,

594
00:36:58,280 --> 00:37:01,460
可能接受保存错误，
probably taking store faults,

595
00:37:01,460 --> 00:37:03,500
但是为了处理这些保存错误，
but for handling those store faults correctly

596
00:37:03,620 --> 00:37:05,390
然后子进程执行，
and then the child execs,

597
00:37:05,900 --> 00:37:08,360
子进程复制 shell 执行 cowtest 。
the child copy the shell execs cowtest.

598
00:37:13,920 --> 00:37:16,920
这可能会对父进程 shell 造成什么坏事。
What bad thing might that do to the parent shell.

599
00:37:22,480 --> 00:37:23,740
当你调用 exec 的时候，
Well, when you call exec,

600
00:37:23,740 --> 00:37:30,100
exec 的实现冻结了所有进程的当前页面，
the implementation of exec freeze up all the process's current pages,

601
00:37:31,140 --> 00:37:36,750
然后分配新页面将文件加载到你的 exec 中。
and then allocates new pages to load the file into your exec.

602
00:37:39,160 --> 00:37:40,870
子进程会发生什么，
What's going to happen in the child,

603
00:37:40,990 --> 00:37:42,610
子进程 shell 调用 exec ，
the child shell calls exec,

604
00:37:42,610 --> 00:37:44,560
它冻结了所有的页面，
it freeze all of its pages,

605
00:37:50,630 --> 00:37:52,610
这会对父进程 shell 造成什么影响。
what's that gonna do to the parent shell.

606
00:37:52,670 --> 00:37:53,960
会不会。
Is it gonna end up.

607
00:37:54,050 --> 00:37:55,280
哦，对不起。
Oh sorry.

608
00:37:56,260 --> 00:38:02,710
它会不会意外地释放 shell 的页面。
Is it going to accidentally free the shell's page pages.

609
00:38:02,980 --> 00:38:05,500
是的，我们会释放 shell 的每一个页面，
Yes, we're gonna free every single one of shell's pages,

610
00:38:05,500 --> 00:38:08,630
除了一两个要写入的页面。
except the one or two that the that were written.

611
00:38:08,840 --> 00:38:11,330
所以这包括了 shell 指令页面，
So this includes the shells instruction pages,

612
00:38:11,630 --> 00:38:14,060
然后我们要重新分配它们，
and then we're going to reallocate them,

613
00:38:14,060 --> 00:38:17,180
它们会立即被 exec 重新分配，用来存放其他东西，
they're going to be instantly reallocated by exec to hold other stuff,

614
00:38:17,180 --> 00:38:19,910
从我们运行的 cowtest 文件中加载，
loaded from the file that we're running cowtest,

615
00:38:20,090 --> 00:38:22,430
所以这会彻底改变 shell 的任何东西，
so that's going to totally change everything in the shell underfoot

616
00:38:22,460 --> 00:38:25,700
不出所料，它会立即崩溃。
and unsurprisingly, it's going to instantly crash.

617
00:38:26,840 --> 00:38:30,050
所以，我们没有以某种方式释放这些页面，
So, we have not free those pages somehow,

618
00:38:32,700 --> 00:38:34,080
它们看不到这个。
they don't see that.

619
00:38:34,740 --> 00:38:35,580
我有一个简短的问题，
A quick question,

620
00:38:35,700 --> 00:38:38,790
这里的 sepc 指向哪里，
what does the sepc here point to

621
00:38:38,790 --> 00:38:41,520
你能从哪个汇编文件中找到那个指令吗？
which assembly file would you find that instruction?

622
00:38:42,960 --> 00:38:43,830
好。
Well.

623
00:38:53,270 --> 00:38:55,570
你说它是 shell ，它是。
You said its shell, right, it's the.

624
00:38:55,630 --> 00:38:58,240
上次是因为其他错误，
Last time was for some other fault,

625
00:38:58,270 --> 00:39:00,070
在那里它是 shell ，
somewhere else it would shell,

626
00:39:00,100 --> 00:39:01,510
这里，我不知道是什么，
what it is here I actually don't know,

627
00:39:01,510 --> 00:39:02,350
我从来没有，
I never,

628
00:39:03,200 --> 00:39:06,680
我没有花时间去追查这件事。
I did not unfortunately take the time to track this down.

629
00:39:07,500 --> 00:39:11,490
所以这个问题可能有多个答案，
The, so one problem with any answer,

630
00:39:11,490 --> 00:39:13,200
即使我能给你答案，
even if I could give you an answer,

631
00:39:13,230 --> 00:39:16,680
所以答案是 shell 或者 cowtest ，
so the answer is either the shell or cowtest,

632
00:39:17,370 --> 00:39:24,130
对于进程 id 3 ，也可能是 cowtest 。
for process id 3, that again is the, it's probably cowtest.

633
00:39:25,140 --> 00:39:27,270
我只是说我不完全知道这是怎么回事，
I just say I don't completely know what's going on here,

634
00:39:27,390 --> 00:39:31,470
查看 asm 文件可能没有帮助，
looking at the asm file is unlikely to be helpful,

635
00:39:31,650 --> 00:39:35,190
因为我们认为已经发生的整个问题是，
because the whole problem that we believe has happened is that,

636
00:39:36,590 --> 00:39:41,300
保存指令的页面被释放并重新使用，
the page holding instructions was freed and reused,

637
00:39:41,420 --> 00:39:47,780
所以，它们不再执行 asm 文件中的指令，
and so they were therefore not executing the instructions in the asm file anymore,

638
00:39:48,260 --> 00:39:50,150
或者执行一些垃圾，
or executing some garbage,

639
00:39:52,370 --> 00:39:54,530
所以我们可以看看地址 1004 ，但是它，
so we could look at address 1004 but it,

640
00:39:55,970 --> 00:39:57,980
它不会真正告诉我们发生了什么。
it wouldn't really tell us what had happened.

641
00:39:58,740 --> 00:40:01,530
我们可能使用调试器找出这一点，
We might we probably could find this out using the debugger,

642
00:40:02,400 --> 00:40:07,150
我们可以在 gdb 中打断，然后查看指令，
we could break in gdb and then look at the instructions,

643
00:40:07,150 --> 00:40:12,100
它实际上是一个 1004 指向的虚拟地址。
it's actually at whatever virtual address 1004 points to.

644
00:40:13,190 --> 00:40:16,880
更进一步的问题，关于那个[]，
Quick follow-up question, about that [],

645
00:40:17,240 --> 00:40:22,190
所以我的理解是我们得到了一个非法指令错误，
so my understanding is that we're getting an invalid instruction fault,

646
00:40:22,190 --> 00:40:28,180
因为我们改变了指令页指令物理内存，
because like we're changing the instruction page instruction physical memory underfoot,

647
00:40:28,180 --> 00:40:30,880
那些内存被写了别的东西，
and like the memories just being written to something else,

648
00:40:30,940 --> 00:40:36,270
有没有可能，比如某些幸运的情况下，
is it possible that, like in some lucky case,

649
00:40:36,270 --> 00:40:38,560
它们正在被重写，
that they are being rewritten,

650
00:40:38,680 --> 00:40:39,700
但是当我们再次查看它时，
but when we look at it again,

651
00:40:39,700 --> 00:40:42,670
它正在被重写为有效的指令页，
it's being rewritten to valid instruction pages,

652
00:40:42,670 --> 00:40:46,270
所以我们开始执行随机指令，
so we actually to start executing like random instructions

653
00:40:46,270 --> 00:40:48,280
却没有得到非法指令错误，
and we don't actually get an invalid instruction fault,

654
00:40:48,280 --> 00:40:49,210
我们得到一些其他错误。
we get some other fault.

655
00:40:49,480 --> 00:40:52,450
是的，绝对的。
Yes, absolutely, absolutely.

656
00:40:53,440 --> 00:40:58,420
是的，我是说什么事都有可能发生。
Yeah, yeah I mean really we're now, like anything could happen.

657
00:40:58,630 --> 00:40:59,170
我明白了。
I see.

658
00:40:59,320 --> 00:41:01,210
我猜不到，
I would not have been able to guess,

659
00:41:01,240 --> 00:41:04,570
如果我没有做这个实验，
if I had not done this lab,

660
00:41:04,940 --> 00:41:08,540
在这里，我猜不出会出什么问题。
I wouldn't be able to guess what will go wrong at this point.

661
00:41:11,720 --> 00:41:16,850
事实上，我认为我在这一点上还看到了其他奇怪的事情发生。
Indeed I think I've seen other strange things happen at this point.

662
00:41:18,540 --> 00:41:21,450
可能是第一页数据有垃圾，
It's maybe the data, may be the first page that has garbage

663
00:41:21,450 --> 00:41:22,770
它里面有数据，
and it actually has data

664
00:41:22,770 --> 00:41:26,100
并且 shell 会遍历完整的垃圾数据，
and shell trips over some complete garbage data,

665
00:41:26,130 --> 00:41:28,440
比如堆栈，而不是指令。
like stack, instead of instructions.

666
00:41:30,940 --> 00:41:32,710
好的，所以我们不想马上释放页面，
Okay, so we don't want to free the page right away,

667
00:41:32,710 --> 00:41:36,850
我们只想在页面真的不再使用的时候释放它。
we, we only want to free the page when it's really not being used anymore.

668
00:41:39,730 --> 00:41:45,160
那么有没有人能提出标准，
So can anybody propose criterion

669
00:41:45,160 --> 00:41:50,230
何时应该或不应该释放每个页面的内存？
for when we should or shouldn't free the page for each page of memory?

670
00:41:51,080 --> 00:41:54,980
我们可以记录有多少次，
We could keep track of like how many times are

671
00:41:54,980 --> 00:41:58,580
就像在 kalloc 中，无论你什么时候，
like basically whenever in kalloc whenever you,

672
00:41:59,250 --> 00:42:02,310
你应该递增和递减某些类型变量，
you should increment and decrement some type variable

673
00:42:02,490 --> 00:42:05,610
并保持所有不同地址的数组。
and keep an array of like all the different addresses.

674
00:42:05,820 --> 00:42:07,260
是的，没错。
Yes, yeah exactly.

675
00:42:07,260 --> 00:42:09,240
所以，考虑这个问题的一种方式是，
So, one way to think about this is

676
00:42:09,240 --> 00:42:15,720
我们只想在页面引用为零的情况下，释放该页面，
that we want to only free a page, when there's zero page tables that refer to it,

677
00:42:15,960 --> 00:42:17,970
但是，可能会有很多，
but there could be many,

678
00:42:17,970 --> 00:42:21,210
如果一个程序 fork 再 fork ，
if a program forks and forks again forks again,

679
00:42:21,210 --> 00:42:24,360
我们现在可以有三到四个不同的进程，
boy, we can now have like three or four different processes,

680
00:42:24,360 --> 00:42:27,900
都引用写入时复制 fork 到这一页，
that all refer to copy-on-write fork to this one page,

681
00:42:28,560 --> 00:42:31,230
所以这个计数，
so that this, you know this count of

682
00:42:31,230 --> 00:42:33,600
有多少页表引用一个页面，
how many times how many page tables refer to a page

683
00:42:33,600 --> 00:42:34,920
因为 fork 继续增长，
and go up due to fork

684
00:42:35,130 --> 00:42:38,040
当进程退出时，可以下降，
and they can go back down when a process exits

685
00:42:38,040 --> 00:42:43,260
或者调用 exec ，它会清除所有页表条目的引用，它会将所有这些引用从页表条目中清除，
or calls exec you know it clears all these references out of its page table entry

686
00:42:43,320 --> 00:42:47,490
或者如果进程进行写入并导致写入错误，
or if a process actually does a write and causes a write fault,

687
00:42:47,670 --> 00:42:51,660
这也是我们减少一个引用的情况，
that's also a situation in which we have one fewer reference,

688
00:42:52,230 --> 00:42:54,660
减少一个到页面的页表引用。
fewer page tables referring to a page.

689
00:42:55,210 --> 00:42:56,530
所以我们需要一个计数，
So we want to keep a count,

690
00:42:56,800 --> 00:43:01,930
我们想要通过计算引用页面的页表条目来进行计数。
and we want to count by counting the number of page table entries that refer to a page.

691
00:43:02,840 --> 00:43:05,600
所以我们需要考虑如何保持这个计数，
So we need to think about how to maintain this count,

692
00:43:05,600 --> 00:43:06,890
什么时候增加它，
and when to increment it,

693
00:43:07,280 --> 00:43:11,000
在代码中的什么位置递增和递减。
exactly where in the code to increment it and decrement it.

694
00:43:12,870 --> 00:43:15,030
好的，所以它们，
Okay so they,

695
00:43:15,940 --> 00:43:18,220
如果，你可能意识到，
if there's as you maybe aware,

696
00:43:18,220 --> 00:43:23,110
有多种方法可以维持这一计数，
there's multiple ways to maintain this count,

697
00:43:23,740 --> 00:43:29,740
我的方法是创建一个名为 refcount 的数组，
the way I do it is I make an array called refcount,

698
00:43:29,860 --> 00:43:32,910
给每一页一个计数。
just gonna have it for every page a count.

699
00:43:33,640 --> 00:43:36,130
我们需要知道有多少条目在 refcount 中，
We need to know how many entries are in refcount,

700
00:43:36,430 --> 00:43:38,140
在 xv6 中，很简单，
in xv6, so simple,

701
00:43:38,380 --> 00:43:43,630
它只使用固定数量的物理内存，
that it just has it just uses a fixed amount of memory, physical memory,

702
00:43:43,660 --> 00:43:46,390
我们只需要对每页物理内存一个计数，
we only need to keep a count per page of physical memory,

703
00:43:46,600 --> 00:43:51,540
我们知道，根据对 kinit 的观察，
we know that, from inspecting kinit,

704
00:43:51,810 --> 00:43:57,620
xv6 仅使用 PHYSTOP ，物理内存量，
that xv6 uses only PHYSTOP, amount of physical memory,

705
00:43:58,130 --> 00:44:01,190
我们只需要保持每页的计数，而不是每字节，
we only need to keep a count per page, not per byte,

706
00:44:01,190 --> 00:44:04,220
所以我们要把 PHYSTOP 除以 4096 ，
so we're going to divide PHYSTOP by 4096,

707
00:44:04,710 --> 00:44:06,330
这就是我们需要的数组元素。
that's how many array elements we need.

708
00:44:09,150 --> 00:44:11,160
在更正式的操作系统中，
In a more serious operating system,

709
00:44:11,160 --> 00:44:12,870
我们不知道有多少内存可用，
we don't know how much memory is available,

710
00:44:13,460 --> 00:44:15,230
除非我们检查硬件，
until we inspect the hardware,

711
00:44:15,230 --> 00:44:20,570
我们不得不动态分配这个数组。
we might have to, we would have to allocate this array dynamically.

712
00:44:20,990 --> 00:44:23,890
有什么问题吗，把计数放在哪里？
Any questions about, where to put the counts?

713
00:44:28,410 --> 00:44:29,370
好的。
Alright.

714
00:44:29,730 --> 00:44:30,090
事实上。
Actually.

715
00:44:30,090 --> 00:44:30,720
是。
Yes.

716
00:44:30,750 --> 00:44:34,710
我在想，你直接使用 4096 是什么原因，
I'm wondering is there a reason that you're using 4096 specifically

717
00:44:34,710 --> 00:44:36,540
而不是页面大小的宏。
and not the page size macro.

718
00:44:37,850 --> 00:44:40,820
是的，原因是我记得 4096 ，
Yeah the reason is that I can remember 4096

719
00:44:40,970 --> 00:44:43,610
我不记得页面大小宏的名称了，
and I don't remember the name of the page size macro,

720
00:44:43,910 --> 00:44:45,470
不过，如果你愿意的话，我很乐意用。
but I'm happy to use it, if you like.

721
00:44:47,850 --> 00:44:52,530
实际上，如果 xv6 的目的是可移植的，
It actually if if xv6 was intended to be portable

722
00:44:52,530 --> 00:44:56,100
并且能够在具有不同页面大小的各种不同的机器上运行，
and to be able to run on all kinds of different machines with different page sizes,

723
00:44:56,160 --> 00:44:57,960
我们必须对此更加小心，
we have to be much more careful about this,

724
00:44:57,960 --> 00:45:02,280
但是有 500 种方式使得 xv6 完全不能移植。
but there's 500 ways in which xv6 is totally not portable.

725
00:45:04,390 --> 00:45:08,830
所以，我不担心这件事。
So, I don't worry about it.

726
00:45:09,250 --> 00:45:12,850
我猜页面大小是由硬件决定的，在哪里。
Page sizes determined in hardware and I guess where.

727
00:45:15,100 --> 00:45:21,670
在硬件中，RISC-V 手册上说，页面是多大。
In the hardware, that RISC-V manual says, how big a pages.

728
00:45:22,560 --> 00:45:24,060
是的，因为，
Yeah, because the,

729
00:45:24,940 --> 00:45:30,030
是 MMU 接受虚拟地址，
it's the MMU that takes a virtual address

730
00:45:30,030 --> 00:45:32,250
并使用它来索引页表。
and uses it to index into the page table.

731
00:45:32,550 --> 00:45:36,660
哦，对，因为地址转换是在硬件中进行的，
Oh, right right, because the address translation happens in hardware,

732
00:45:36,660 --> 00:45:39,600
所以硬件必须知道页面大小，好的。
so the hardware has to know how big pages are, okay.

733
00:45:40,260 --> 00:45:41,340
它是可配置的，
It's configurable,

734
00:45:41,340 --> 00:45:44,880
但是有几种不同的策略可以告诉硬件使用，
but you know there's a couple different strategies you can tell the hardware to use,

735
00:45:44,880 --> 00:45:48,360
但是我们告诉它使用 4096 字节的页面。
but we tell it to use 4096 byte pages.

736
00:45:49,670 --> 00:45:50,240
好的。
Okay.

737
00:45:50,630 --> 00:45:52,370
抱歉，教授，
Where, sorry professor,

738
00:45:52,400 --> 00:45:54,470
哪里，我想这是个 C 的问题，
so where are, I guess is a C question,

739
00:45:54,470 --> 00:46:00,080
所以我们的全局变量比如 refcount 存储在哪里，
so in where our global variables like refcount stored,

740
00:46:00,690 --> 00:46:05,940
比如它们与特定的处理器绑定吗？
like what, like are they associated with specific processor?

741
00:46:05,970 --> 00:46:07,440
这是内核，
This is the kernel,

742
00:46:08,200 --> 00:46:13,180
所发生的是可执行文件，
what's going on is that the file, the executable file,

743
00:46:16,420 --> 00:46:20,290
编译器和加载器或链接器产生的，
that the compiler and the loader or linker produces,

744
00:46:22,270 --> 00:46:25,060
有这种，
has this sort of this,

745
00:46:25,120 --> 00:46:28,690
表明有多少数据，
indicates how much data,

746
00:46:28,690 --> 00:46:31,780
程序中所有全局变量的总大小是多少。
how the total size of all the global variables in the program.

747
00:46:32,760 --> 00:46:35,810
我们看不到这些代码，
And, so we don't see the code for this,

748
00:46:35,810 --> 00:46:38,690
但是当 QEMU 加载内核时，
but when QEMU loads the kernel,

749
00:46:41,710 --> 00:46:45,280
实际上是这样的，
well what's really going on is

750
00:46:45,280 --> 00:46:46,450
当你编译的时候，
when you compile,

751
00:46:46,600 --> 00:46:51,590
程序调用链接器，计算基于，
the program call the linker figures out based on,

752
00:46:51,620 --> 00:46:54,110
查看所有全局变量及其大小，
look at all the global variables and their sizes

753
00:46:54,230 --> 00:46:56,690
并在内存中分配一个地址，
and assigns an address in memory,

754
00:46:57,340 --> 00:46:59,650
是的，分配给每个全局变量。
yeah, to each global variable.

755
00:47:04,340 --> 00:47:06,080
这就是它在内存中的地方。
And that's where it lives in memory.

756
00:47:08,090 --> 00:47:18,970
我是说，我们只是安排，
I mean, and, we just arrange that the you know,

757
00:47:18,970 --> 00:47:25,480
所以 xv6 内核使用 10000 字节各种全局变量，
so xv6 kernel uses you know 10,000 bytes of various global variables,

758
00:47:26,090 --> 00:47:29,150
并且在引导过程将其加载到存储器中的任何地方，
and wherever the boot process loads it into memory,

759
00:47:29,180 --> 00:47:31,460
比如在地址一百万处，
say at address a million,

760
00:47:31,460 --> 00:47:39,110
它就使用这些地址用于全局变量。
it just uses those addresses for the global variables.

761
00:47:39,200 --> 00:47:39,920
我明白了，
I see,

762
00:47:39,920 --> 00:47:42,380
这是不是跟这个类似，
is this, is this similar to how,

763
00:47:42,410 --> 00:47:47,810
就像在磁盘上只有一份程序的指令的副本，
like there's only one copy of like the instructions for a program on disk

764
00:47:47,810 --> 00:47:52,760
这个程序只有一份全局变量的副本。
and there's only like one copy of a kind of global variables for that program on this.

765
00:47:55,330 --> 00:48:00,130
好的，一个程序，
Well, a program this,

766
00:48:00,130 --> 00:48:05,010
好的，我不知道该怎么回答，
well, I'm not really sure how to answer this,

767
00:48:05,010 --> 00:48:11,980
我的意思是，当你声明一个全局变量时，比如 int x ，
I mean the the, when you declare a global variable, like int x,

768
00:48:12,440 --> 00:48:15,590
当你编译时，编译编译器和链接器决定
when you compile, the compiler and the linker just decide

769
00:48:15,650 --> 00:48:18,080
基于谁知道它是什么或者它是可配置的，
based on who knows what or it's configurable,

770
00:48:18,080 --> 00:48:20,600
但是它们决定了变量的地址，
but they decide the address for that variable,

771
00:48:20,810 --> 00:48:23,780
它们决定 x 地址定为 1000 ，
they decide alright boy x is going to address 1000,

772
00:48:24,580 --> 00:48:26,980
然后代码读取或写入 x ，
and then the code that reads or write x,

773
00:48:26,980 --> 00:48:30,760
如果我们有代码 refcount[0] 等于 1 ，
you know if we have code that says refcount of zero equals one,

774
00:48:31,990 --> 00:48:37,190
但是编译只是把内存设置在 1000 地址，
you know, but that compiled into was just setting the memory at address a thousand

775
00:48:37,190 --> 00:48:39,890
或者链接器决定把 refcount 放在哪里，
or wherever we linker decided to put refcount

776
00:48:39,950 --> 00:48:44,900
进行存储，设置存储器地址 1001 。
which is does a store to set the memory address 1001.

777
00:48:50,790 --> 00:48:55,310
是的，它不是，
Yeah, it's not,

778
00:48:55,820 --> 00:48:58,010
它实际上是类似的事情，
it's actually almost exactly the same thing

779
00:48:58,010 --> 00:49:00,200
和你运行普通用户程序时发生的。
that happens when you run an ordinary user program.

780
00:49:02,980 --> 00:49:06,670
链接器和编译器决定内存全局变量的位置。
You know the linker and compiler decide where memory global variables are.

781
00:49:07,400 --> 00:49:11,460
它们就在那里，而且可以工作。
They just being right there and, and it just works.

782
00:49:13,050 --> 00:49:15,480
我很抱歉，这不是一个很好的解释。
I'm sorry, that's not much of an explanation.

783
00:49:18,560 --> 00:49:25,160
好的，只需定义此全局计数数组，每个物理页一个，
Alright, so just a define this global array of counts one per physical page

784
00:49:25,730 --> 00:49:29,470
我们需要在不同的地方修改这些计数，
and we need to modify these counts in various places,

785
00:49:29,530 --> 00:49:31,900
当然，当我们第一次分配页面时，
certainly when we first allocate a page,

786
00:49:31,930 --> 00:49:35,230
我们会说它有一个引用，
we're going to say that it has one reference,

787
00:49:35,230 --> 00:49:38,890
因为我们把页面地址给调用 kalloc 的程序，
because we return the address of the page to whoever called kalloc

788
00:49:39,130 --> 00:49:43,390
这时，只有该程序引用了这个页面，
and at the moment only that program has a reference to this page,

789
00:49:43,390 --> 00:49:56,400
因此，我将此页面的引用计数设置为 1 。
so I'm just gonna set the refcount for this page to be 1.

790
00:49:56,400 --> 00:49:58,800
所以，首先我要计算一下页码，
So first of all I'm just going to calculate the page number,

791
00:49:58,800 --> 00:50:06,260
它是页面的地址除以 4096 ，即页码。
which is the address of the page divided by 4096, the page number.

792
00:50:08,690 --> 00:50:12,170
然后我将设置
And then I'm going to set

793
00:50:12,260 --> 00:50:15,260
刚分配的页面的引用计数为 1 。
the reference count for the page we just allocated to 1.

794
00:50:21,920 --> 00:50:23,240
有关于这些代码的问题吗？
Any questions about this code?

795
00:50:27,570 --> 00:50:32,490
因为我知道引用计数会有 bug ，
Just because I know that I'm going to have bugs with reference counting,

796
00:50:33,120 --> 00:50:36,120
我在这里做了一些合理性检查，
I'm actually do a little bit of a sanity check here

797
00:50:36,120 --> 00:50:43,540
只是，引用计数应该是 0 ，
and just, the you know the reference count really should be zero,

798
00:50:43,540 --> 00:50:45,790
如果我们刚刚分配的页面是释放的，
if the pages we just allocated a page was free,

799
00:50:45,940 --> 00:50:48,010
最好它的引用计数为 0 。
boy it better have a reference count of zero.

800
00:50:54,140 --> 00:50:55,550
对这个代码，有什么问题吗？
Any questions about this code?

801
00:51:00,490 --> 00:51:03,520
好的，通常我们希望增加引用计数
Alright, so in general we want to increment the reference count

802
00:51:03,520 --> 00:51:05,920
我们增加，
when we add,

803
00:51:06,720 --> 00:51:11,580
当写入时复制 fork 添加指向现有页的页表条目时，
when copy-on-write fork adds a page table entry that points to an existing page

804
00:51:12,000 --> 00:51:13,110
我们想要，
and we want to,

805
00:51:13,820 --> 00:51:17,030
实际上，我们想要减少引用计数，
actually, we want to decrement the reference count,

806
00:51:17,760 --> 00:51:19,440
事实证明，在很多地方，
as it turns out in many places,

807
00:51:19,590 --> 00:51:21,570
例如，当进程退出时，
for example when a process exits,

808
00:51:21,750 --> 00:51:24,090
我们需要递减其所有页的引用计数，
we need to decrement the reference count of all its pages,

809
00:51:24,090 --> 00:51:25,680
当你调用 exec 时，
when you call exec,

810
00:51:26,620 --> 00:51:28,840
它释放所有当前内存，
and that frees all the current memory,

811
00:51:28,840 --> 00:51:29,830
因为它会取代它，
because it's going to replace it,

812
00:51:29,830 --> 00:51:31,480
我们想要减少所有的引用计数，
we want to decrement all those reference counts,

813
00:51:31,480 --> 00:51:33,760
当发生写入时复制页面错误时，
when a copy-on-write page fault happens

814
00:51:33,760 --> 00:51:35,110
然后我们复制了一份，
and we make a copy,

815
00:51:35,350 --> 00:51:38,260
我们想要减少旧页面上的引用计数，
we want to decrement reference count on the old page,

816
00:51:38,410 --> 00:51:42,940
这些位置都是可以同时释放页面的，
it turns out these are all the same places that concurrently free a page,

817
00:51:42,940 --> 00:51:44,440
因为当前的 xv6 ，
because the current xv6,

818
00:51:44,800 --> 00:51:48,070
考虑每个页面只有一个引用，
think there's only ever one reference to each page,

819
00:51:48,070 --> 00:51:50,500
所以在大多数我们想要减少的地方，
so in most of the places we care about where we want to decrement,

820
00:51:50,500 --> 00:51:52,060
并发调用 kfree ，
there's concurrently a call kfree,

821
00:51:52,300 --> 00:51:53,800
所以我要做的是
so what I'm gonna do is

822
00:51:53,860 --> 00:51:57,610
修改 kfree 使其具有稍微不同的语义，
modify kfree to be have somewhat different semantics

823
00:51:57,610 --> 00:51:59,920
使 kfree 成为，
and to have kfree be,

824
00:52:00,250 --> 00:52:04,180
某种可以减少引用计数的函数，
sort of a function that decrements the reference count

825
00:52:04,300 --> 00:52:07,840
并且仅当引用计数降至零时才释放页面。
and free the page only if the reference count has dropped to zero.

826
00:52:08,890 --> 00:52:12,310
我的意思是，我会修复所有调用 kfree 的地方。
I mean, I'll just automatically fix all the places that call kfree.

827
00:52:16,830 --> 00:52:20,150
好的，我们需要检查，
Alright so, we need to actually do the check,

828
00:52:21,770 --> 00:52:24,470
在我们用垃圾数据填满页面之前。
before we fill the page with junk.

829
00:52:25,300 --> 00:52:28,090
所以，这让事情变得有点复杂，
So, this makes a little bit more complicated,

830
00:52:28,090 --> 00:52:31,840
因为即使在 kfree 中已经有一个锁的临界区，
because even though there's a critical section with locks in kfree already,

831
00:52:31,960 --> 00:52:32,800
我们也不能使用它，
we can't use it,

832
00:52:32,800 --> 00:52:35,830
因为它发生在我们将页面填满垃圾数据之后。
because it happens after the point at which we filled the page with garbage.

833
00:52:37,680 --> 00:52:41,130
所以，我们需要一个锁，
So, we need a lock,

834
00:52:41,130 --> 00:52:43,480
因为我们可能释放同一页面，
because we could be free

835
00:52:43,480 --> 00:52:46,810
在同一时间从多个不同的内核，
in the same page at the same time from multiple different cores,

836
00:52:47,260 --> 00:52:52,010
同样，我要找到页码，
again I'm gonna find the page number

837
00:52:52,010 --> 00:52:57,030
通过将物理地址除以 4096 。
by dividing the physical address by 4096.

838
00:52:58,160 --> 00:53:03,800
我想再一次 panic ，只是一次合理性检查，
I want to panic, again, just a sanity check,

839
00:53:04,620 --> 00:53:06,330
如果我们要释放一页的话，
gosh, you know if we're freeing a page,

840
00:53:06,330 --> 00:53:08,700
最好有超过零的引用计数。
that better have more than zero refcounts.

841
00:53:15,210 --> 00:53:19,830
如果页面有多个引用计数，我们需要返回。
We need to return if the page has more than one reference count to it.

842
00:53:20,820 --> 00:53:25,570
实际上，让我们减少引用计数，
Actually, let's decrement the reference count,

843
00:53:26,470 --> 00:53:29,560
我们想在解锁后返回，
we want to return after we release locks

844
00:53:29,560 --> 00:53:31,000
我们必须记住一个变量，
and we have to remember a variable,

845
00:53:31,000 --> 00:53:33,670
我将记住该页面是否有更多引用，
I'm gonna remember whether the page has more references

846
00:53:33,670 --> 00:53:35,350
然后释放锁，然后返回，
and then release locks and then return,

847
00:53:35,620 --> 00:53:37,840
所以我将创建一个临时变量，
so I'm gonna make a temporary variable

848
00:53:37,840 --> 00:53:44,130
该变量包含，然后释放，
which has the and release,

849
00:53:46,640 --> 00:53:50,240
如果还有引用这个页面的话，
then say if there's still references this page,

850
00:53:50,240 --> 00:53:52,070
我们就返回，不要释放它。
let's just return and not free it.

851
00:53:52,750 --> 00:53:55,690
只有当引用计数降到零时，我们才释放它。
And only if the reference count drop to zero, we free it.

852
00:53:57,360 --> 00:53:58,230
有什么问题吗？
Any questions?

853
00:53:58,620 --> 00:53:59,640
你能不能再解释一下，
Can you explain again,

854
00:53:59,640 --> 00:54:03,480
为什么要在这个过程中取得 kmem->lock ？
why you have to acquire the kmem lock this process?

855
00:54:04,220 --> 00:54:06,650
为什么整段都要获取它？
Why have to acquire it all?

856
00:54:07,160 --> 00:54:10,280
是的，当你在做页码计算的时候。
Yeah when you're doing the page number calculations and.

857
00:54:10,730 --> 00:54:12,530
是这一行，
It's this line,

858
00:54:14,350 --> 00:54:18,010
这一行和下一行是问题的关键，
really is this line, the next line of the problem,

859
00:54:18,010 --> 00:54:21,130
问题是，在这个页面上，
the issue is that on this page,

860
00:54:21,220 --> 00:54:23,830
我们现在可能有多个对它的引用，
we now is likely has more than one reference to it

861
00:54:23,890 --> 00:54:26,530
如果两个进程有相同的引用，
and so if two processes with a reference to the same

862
00:54:26,680 --> 00:54:28,960
有指向相同页面的页表条目，
with the page table entry point at the same page,

863
00:54:29,200 --> 00:54:32,050
如果它们同时在不同的核心上退出，
if they both exit at the same time on different cores,

864
00:54:32,260 --> 00:54:35,890
它们会同时对相同的页面调用 kfree 。
they're both gonna call kfree for the same page at the same time.

865
00:54:38,740 --> 00:54:43,180
你可以为引用计数变量创建一个新的锁，
Could you just create a new lock for the reference count variable

866
00:54:43,180 --> 00:54:44,530
然后使用它吗？
and use that as well?

867
00:54:48,610 --> 00:54:49,150
是的。
Yes.

868
00:54:51,340 --> 00:54:52,330
是的，基本上，
Yeah, basically everybody,

869
00:54:52,330 --> 00:54:54,370
所有操纵这些计数的代码
you know all code that manipulates these counts

870
00:54:54,370 --> 00:54:55,420
都需要使用相同的锁，
need to use the same lock,

871
00:54:55,420 --> 00:54:58,450
但我觉得锁是什么并不重要。
but I don't think it matters what lock is.

872
00:55:00,980 --> 00:55:04,610
好的，这就解决了大部分我们关心的减少的问题，
Okay, so this takes care of decre-, most of the decrement we care about,

873
00:55:04,610 --> 00:55:05,630
每一次释放页面，
every time the page is free,

874
00:55:05,630 --> 00:55:08,900
我们只有在引用计数为零的情况下才释放。
we're really gonna you know only free if the reference counts fails to zero.

875
00:55:09,020 --> 00:55:12,680
我们也需要增加引用计数，
We also need to increment the reference count,

876
00:55:12,980 --> 00:55:14,900
我们需要在哪里增加引用计数。
where do we need to increment the reference count.

877
00:55:22,240 --> 00:55:25,090
好的，因为我知道我们需要做好这件事，
Well, because I know we're going to need to do it right,

878
00:55:25,090 --> 00:55:29,320
任何人都可以调用的函数。
the function that anybody can call.

879
00:55:41,460 --> 00:55:43,620
再一次，如果有什么不正常，我想引起 panic ，
Again I want to panic if something is weird,

880
00:55:43,620 --> 00:55:45,240
所以如果地址很奇怪，
so if the address is wacky,

881
00:55:45,930 --> 00:55:50,750
我当然不想超出数组的末尾。
I'm certainly don't want to go beyond the end of the array.

882
00:55:52,820 --> 00:55:56,210
或者如果我们不想增加页面的引用计数，
Or if we don't want to increment the reference count of page,

883
00:55:56,210 --> 00:55:57,770
引用计数为零，
reference counts currently zero,

884
00:55:58,470 --> 00:56:00,270
这也是一个错误，
that's also an error,

885
00:56:04,440 --> 00:56:05,490
我只是把这些放在这里，
I'm just putting these in there,

886
00:56:05,490 --> 00:56:07,740
因为从我的代码经验中知道，
because I know from experience with my code

887
00:56:07,740 --> 00:56:10,740
正是那种地方，我会有 bug 。
that this is exactly the kind of place, I'm going to have a bug in.

888
00:56:25,610 --> 00:56:27,710
好的，我应该从哪里调用增加。
All right, where should I call increment from.

889
00:56:30,860 --> 00:56:33,110
你有 uvmcopy ，当你。
You have uvmcopy when you.

890
00:56:35,060 --> 00:56:40,950
我认为 uvmcopy 是唯一另一个引用页面的地方。
I think uvmcopy is the only place that makes another reference to a page.

891
00:56:46,600 --> 00:56:49,000
好的，我这么做了，
Alright gosh, I'm going with this well,

892
00:56:49,000 --> 00:56:51,010
这几乎无关紧要。
it almost doesn't really matter.

893
00:56:52,400 --> 00:56:55,010
我们创造了另一个对 pa 的引用，
We're making another reference to pa,

894
00:56:55,040 --> 00:56:58,570
所以我想使用 incref(pa) 。
so I want to say incref(pa).

895
00:57:01,850 --> 00:57:06,150
很可能会遇到来自编译器的问题，
Or, likely to run into trouble from the compiler,

896
00:57:06,150 --> 00:57:11,850
如果我们不把它的定义放在 traps.h 中。
if we don't put a definition for it in traps.h whatever.

897
00:57:12,580 --> 00:57:13,210
好的,
Okay,

898
00:57:18,450 --> 00:57:19,530
让我们看看。
let's see.

899
00:57:39,230 --> 00:57:40,490
那太快了，
That was pretty quick,

900
00:57:41,950 --> 00:57:44,800
那是 kfree ref ，
that was kfree ref,

901
00:57:45,970 --> 00:57:47,260
kfree 不高兴。
kfree is unhappy.

902
00:57:50,380 --> 00:57:54,010
好的，这是在引导过程的早期，
Okay, well here's the time we don't know, is very early in the boot process

903
00:57:54,010 --> 00:57:56,680
也许是出了什么问题的一个线索。
which is maybe a hint it to what's going wrong.

904
00:57:57,310 --> 00:58:02,800
如果有人有任何猜测，我很乐意听听，
If anybody has any guesses, I'd be happy to hear them,

905
00:58:02,800 --> 00:58:05,830
同时，启动调试器，尝试获取回溯信息。
meanwhile just fire up the debugger try to get backtrace.

906
00:58:06,660 --> 00:58:08,250
这是在 kinit 中，
It is during kinit,

907
00:58:08,250 --> 00:58:13,020
因为你正在尝试将内容放入链表，
because you're trying to put things into the linked list

908
00:58:13,020 --> 00:58:15,030
但是链表尚未分配。
and you haven't allocated yet.

909
00:58:16,360 --> 00:58:22,780
所以，当你尝试将所有内容加载到链表中时，
So you in when you trying to load everything into a linked list,

910
00:58:23,140 --> 00:58:26,170
在那之前你没有调用 kalloc 。
you haven't called kalloc before that.

911
00:58:26,500 --> 00:58:27,790
是的，完全正确，
Yeah that's exactly right,

912
00:58:28,090 --> 00:58:31,410
所以，请看这里的操作，
so, see that in action here,

913
00:58:31,440 --> 00:58:32,940
好的，我得到 panic ，
okay I got the panic,

914
00:58:32,940 --> 00:58:35,100
输入 where ，它在，
type where and it's in,

915
00:58:36,290 --> 00:58:38,030
这里是 kfree 被调用，并引起 panic ，
here's kfree being called and paniced

916
00:58:38,030 --> 00:58:40,010
它一开始就是从 freerange 调用的，
and it's being called from freerange right at the beginning,

917
00:58:40,010 --> 00:58:43,040
当我们在初始化空闲列表时，
when we're initializing the free list indeed,

918
00:58:43,400 --> 00:58:47,300
所以在 freerange 有一些需要修复的东西，
so there's something to be fixed in freerange,

919
00:58:47,330 --> 00:58:50,120
问题是我调用 kfree ，
the problem is I'm calling kfree,

920
00:58:50,120 --> 00:58:51,620
如你所说，我调用 kfree ，
as, as you said I'm calling kfree,

921
00:58:51,620 --> 00:58:53,300
但是当然，所有的引用计数都是零，
but of course, all the reference counts are zero

922
00:58:53,300 --> 00:58:55,490
当参考计数为 0 时， kfree 会出现 panic ，
and kfree panics at the reference count of zero,

923
00:58:55,820 --> 00:59:03,500
所以我把这个改为。
so I'll just, I'll just hack this to be.

924
00:59:11,100 --> 00:59:11,610
这个怎么样。
How about that.

925
00:59:20,300 --> 00:59:23,180
好的，我们现在可以启动了，
Oh okay, we managed to boot now,

926
00:59:24,380 --> 00:59:25,220
干得不错，
by wonderful done,

927
00:59:25,220 --> 00:59:26,030
让我们看看。
let's see.

928
00:59:30,160 --> 00:59:32,530
好的，让我们再运行一次 cowtest 。
Okay, so let's run the cowtest again.

929
00:59:34,290 --> 00:59:36,420
嗯，我们通过了这个 simple 测试，
Um, we pass this simple test,

930
00:59:36,420 --> 00:59:39,600
我们通过了 simple 测试，这很棒。
aha, so we passed the simple test, which is great.

931
00:59:41,490 --> 00:59:45,450
我们通过了一次 three 测试，
And we passed one time through the three test,

932
00:59:45,510 --> 00:59:47,550
但是我们没有通过，
but we didn't pass,

933
00:59:48,190 --> 00:59:50,860
我们没有通过第二次 three 测试，
we didn't make it through the second time to the three test

934
00:59:51,700 --> 00:59:57,310
test 测试触发了我添加到 trap 的打印语句，
and the three test triggered the print statement that I added to trap

935
00:59:57,310 --> 01:00:00,100
输出 cow kalloc failed ，
which said cow kalloc failed,

936
01:00:00,280 --> 01:00:03,570
只有在我们内存不足的情况下才会打印出来。
which only would print it if we're out of memory.

937
01:00:05,030 --> 01:00:06,170
所以我们内存不足了。
So we're out of memory.

938
01:00:09,550 --> 01:00:10,660
为什么我们内存不足了。
Why are we out of memory.

939
01:00:17,220 --> 01:00:21,120
所以我们每次分配的时候都会更新引用计数，
So we've updated reference counts every time we've allocated,

940
01:00:21,600 --> 01:00:27,090
但是当我们释放的时候，没有减少计数。
but we haven't called decrement counts, whenever we've tried to free right.

941
01:00:27,450 --> 01:00:29,310
那么我应该在哪里加上。
So where should I add the.

942
01:00:31,670 --> 01:00:33,260
嗯，按照你目前的方法，
Well, with your current approach,

943
01:00:33,260 --> 01:00:38,090
我认为 pa1 的引用计数需要减少，
I think pa1 that reference count needs to get decrement,

944
01:00:38,090 --> 01:00:39,620
所以我们需要 kfree 它。
so we would need to kfree it.

945
01:00:39,980 --> 01:00:41,300
是的，就是这样。
Yeah exactly.

946
01:00:41,330 --> 01:00:47,730
我想可能是有人在 45 分钟前提出了这个问题，
So, I think somebody actually possibly brought this up, 45 minutes ago,

947
01:00:47,910 --> 01:00:48,900
让我们看看，
let's see,

948
01:00:48,930 --> 01:00:52,700
让我们释放 pa1 ，而不是 pa2 。
let's free pa1, not pa2.

949
01:00:53,320 --> 01:00:56,480
好的，现在 kfree 的意思是，
Okay, and so now what kfree means,

950
01:00:56,480 --> 01:00:58,850
不是释放这个页面，
now is don't is not free this page,

951
01:00:58,880 --> 01:01:02,330
kfree 的意思是减少这个页面上的引用计数，
it's what kfree means is decrement the refcount on this page

952
01:01:02,360 --> 01:01:03,650
如果是零的话，才释放它，
and free if it's zero

953
01:01:03,860 --> 01:01:06,950
以此类推，在只有一个 fork 的简单情况下，
and so forth in a simple situation, where there was just one fork

954
01:01:07,130 --> 01:01:09,500
所以有两个对页面的引用，
and so there were two references to the page,

955
01:01:09,830 --> 01:01:13,220
我们在复制中得到了写入错误，
and we've taken a write fault to make a copy,

956
01:01:13,250 --> 01:01:16,580
现在 kfree 要做的就是将计数减为 1 ，
where now all kfree is going to do is decrement the count to be one

957
01:01:16,580 --> 01:01:18,950
现在另一个进程可以使用这个页面，
and now the other process can use the page,

958
01:01:19,130 --> 01:01:20,840
我们并不是要释放它。
we're not actually gonna free it.

959
01:01:23,020 --> 01:01:25,810
好的，希望现在，
Okay so hopefully now,

960
01:01:27,340 --> 01:01:37,810
我们不会在 cowtest 中内存不足。
we'll, not run out of memory in the cowtest.

961
01:01:41,830 --> 01:01:42,790
嗯，我喜欢它，
Um, I love it,

962
01:01:42,880 --> 01:01:45,040
好的，我们通过了 three 测试，
okay, we made it through the three test,

963
01:01:45,730 --> 01:01:47,170
没有内存不足。
without running out of memory.

964
01:01:51,420 --> 01:01:51,930
好的，
Alright,

965
01:01:54,140 --> 01:01:55,940
遗憾的是，我们还没有完成，
we're not done, sadly,

966
01:01:55,940 --> 01:02:02,890
我们在 file 测试中有一个有趣的错误，
we have this interesting error in the file test,

967
01:02:02,890 --> 01:02:04,720
那么让我们来看一下 file 测试。
so let's take a look at the file test.

968
01:02:11,820 --> 01:02:13,560
好的，这是 filetest ，
Alright, so here's the filetest

969
01:02:13,890 --> 01:02:16,050
它在测试的注释中说，
and it says right in the comments of the test,

970
01:02:16,050 --> 01:02:18,090
它测试 copyout ，
that it's investigating copyout,

971
01:02:18,090 --> 01:02:22,910
所以，是很好的线索，我们的问题在哪里，
so, good hint of where our problem is going to be,

972
01:02:23,300 --> 01:02:26,210
实际上失败的事情是，
the thing that actually failed is,

973
01:02:26,630 --> 01:02:29,090
我的意思是你必须稍微发挥你的想象力，
I mean you have to use your imagination a little bit,

974
01:02:29,090 --> 01:02:32,330
但是，错误信息似乎是这个，
but, the error message seems to be this one,

975
01:02:32,330 --> 01:02:35,330
同时从两个不同的进程打印。
printed from two different processes at the same time.

976
01:02:37,440 --> 01:02:39,990
事实上，这个测试是一个循环，
And indeed, this is a loop, this test is a loop,

977
01:02:40,560 --> 01:02:43,830
四次迭代，就是 fork ，
that for four iterations, just forks

978
01:02:43,830 --> 01:02:47,130
因此它将产生四个并发进程，
and so it's going to produce four concurrent processes,

979
01:02:47,340 --> 01:02:50,340
这个错误消息将被交错，
this error message will be interleaved,

980
01:02:50,490 --> 01:02:52,320
所以我们需要知道读取失败的原因，
so we need to know why that read failed,

981
01:02:52,320 --> 01:02:53,880
如果我们想了解 bug 是什么，
if we want to understand what the bug is,

982
01:02:53,910 --> 01:02:56,010
我们需要知道读取失败的原因。
we need to know why the read failed.

983
01:02:56,220 --> 01:02:58,770
第一步可能是找出读取返回了什么，
The first step is maybe to figure out what the read actually returned,

984
01:02:58,770 --> 01:02:59,910
我们所知道的是，
all we know is that,

985
01:03:00,870 --> 01:03:05,210
它返回了除了 sizeof(i) 之外的其他东西，
it returned something other than sizeof i,

986
01:03:05,240 --> 01:03:06,830
但是我们不知道它返回了什么，
but we don't know what it returns,

987
01:03:06,830 --> 01:03:09,830
所以我要捕获返回值，
so I'm going to capture the return value,

988
01:03:15,680 --> 01:03:18,830
我要打印返回值。
and I'm going to print the return value, at least know.

989
01:03:21,930 --> 01:03:23,730
哦，我有个问题，抱歉，
Oh, I have a question, sorry,

990
01:03:23,790 --> 01:03:27,660
看起来有三个线程失败了，
it seems like three of the threads failed,

991
01:03:27,660 --> 01:03:30,520
但是，其中一个并没有结束，
but, one of them didn't end,

992
01:03:31,150 --> 01:03:32,830
它还在运行，
it's like still running,

993
01:03:33,280 --> 01:03:34,630
为什么它没有失败？
why is it not failing?

994
01:03:35,490 --> 01:03:37,170
为什么第三个线程没有失败？
Why did the third thread not fail?

995
01:03:38,700 --> 01:03:42,240
第四个，如果你做 cowtest 然后 echo ，
The fourth if you, if you do cowtest and then echo,

996
01:03:42,760 --> 01:03:45,040
另一个还会继续运行，
that other one is still going to be running

997
01:03:45,040 --> 01:03:46,840
你会看到更多的输出。
and you're gonna see more output.

998
01:03:49,290 --> 01:03:51,240
是的，三个失败了，一个没有。
Yes, three failed and one didn't.

999
01:03:53,230 --> 01:03:57,640
嗯，让我们先调查一下为什么它们中的任何一个都失败了，
Um, let's just finish investigating why any of them failed,

1000
01:03:57,790 --> 01:03:59,680
然后我可以猜一猜，
and then I can make a guess

1001
01:04:00,040 --> 01:04:03,460
虽然不知道为什么其中一个没有失败。
although I don't really know why one of them didn't fail.

1002
01:04:05,110 --> 01:04:08,500
好的，这里发生的情况是， read 返回的是 -1 。
Okay, so, what's happening here is that read returning -1.

1003
01:04:09,740 --> 01:04:11,570
那么为什么 read 返回的是 -1 。
So why is read returning -1.

1004
01:04:12,870 --> 01:04:14,370
你可能会假设，
You might hypothesize

1005
01:04:14,370 --> 01:04:17,670
我们将这个 buf 传递给 read ，
that the you know we were passing this buffer into read,

1006
01:04:18,060 --> 01:04:20,190
你可能会想象，
you might imagine that the,

1007
01:04:20,340 --> 01:04:22,650
你知道 read 需要做一些事情，
you know read, and read needs to do something

1008
01:04:22,650 --> 01:04:28,560
也就是调用 copyout 将文件数据复制到这个缓冲区中，
namely called copyout to copy file data into this into this buffer,

1009
01:04:29,120 --> 01:04:30,110
我们传递给 read 的，
that we passed to read,

1010
01:04:30,110 --> 01:04:31,370
也许它出了什么问题，
maybe something's going wrong with that

1011
01:04:31,370 --> 01:04:33,200
它与写入是复制 fork 的关系。
and its relationship to copy-on-write fork.

1012
01:04:33,440 --> 01:04:34,880
那么让我们来看看 read ，
So let's take a look at read,

1013
01:04:38,530 --> 01:04:40,150
看看它为什么会失败。
and see why it's failing.

1014
01:04:40,730 --> 01:04:44,440
找出，为什么 read ，
Track down, why read,

1015
01:04:44,470 --> 01:04:46,450
好的，那么让我们来捕捉，
alright, so let's capture the,

1016
01:04:46,480 --> 01:04:49,840
read 所有 sys_read 调用 fileread ，
read all sys_read does this calls calls fileread

1017
01:04:50,170 --> 01:04:52,000
在获取一组参数之后。
after fetching a bunch of arguments.

1018
01:04:55,010 --> 01:04:57,110
所以我们修复这个，
So we'll fix this to,

1019
01:04:58,480 --> 01:05:01,540
走进一步，来理解什么东西出错了。
take one step closer to understanding why things are going wrong.

1020
01:05:05,310 --> 01:05:09,770
我们希望 cc 会为 -1 。
We are expecting cc to be -1.

1021
01:05:18,500 --> 01:05:20,090
嗯，有意思，
Um, that's interesting,

1022
01:05:20,390 --> 01:05:24,410
我们没有看到 cc 等于 -1 。
we never saw cc minus equals -1.

1023
01:05:25,060 --> 01:05:27,010
事实上，失败发生了，
In fact, the failure occurred,

1024
01:05:27,310 --> 01:05:30,010
失败从这里开始发生，
a failure starts occurring here,

1025
01:05:30,040 --> 01:05:36,010
在我们得到任何相应的 cc 打印语句之前，
before we get any corresponding cc print statements

1026
01:05:36,010 --> 01:05:37,570
它根本不是 -1 ，
and it's not -1 at all,

1027
01:05:37,570 --> 01:05:39,790
而是 4 ，这是一个非失败值。
it's four, which is a non failure value.

1028
01:05:42,620 --> 01:05:43,520
所以这意味着，
So what that means is,

1029
01:05:43,520 --> 01:05:46,040
在调用 fileread 之前的一些事情，
that something before the call the fileread

1030
01:05:46,520 --> 01:05:50,780
一定触发了这次返回，
must have caused must have triggered this return,

1031
01:05:50,930 --> 01:05:52,460
这里的其中一个函数，
so one of these functions here,

1032
01:05:53,580 --> 01:05:56,070
导致 read 返回 -1 。
has caused read to return -1.

1033
01:05:58,690 --> 01:06:00,940
请随意猜猜，在我输入时。
Please feel free to guess while I'm typing.

1034
01:06:03,980 --> 01:06:05,690
顺便说一下，这对我来说完全是个意外，
This was a complete surprise to me by the way,

1035
01:06:05,690 --> 01:06:08,050
当我追踪到它的时候。
when I tracked it down.

1036
01:06:08,950 --> 01:06:11,260
哦，我想这个文件是描述符。
Oh, I think the file is descriptor.

1037
01:06:12,010 --> 01:06:14,260
是的，文件描述符，我看到了，
Yeah, the file descriptor, I saw,

1038
01:06:14,260 --> 01:06:18,430
我所期望的是 fileread 失败是由于某些原因，
what I expected was that fileread was failing due to something

1039
01:06:18,430 --> 01:06:23,290
而且 copyout 对写入时复制的页面做不正确的事情，
and copyout not doing the right thing with copy-on-write pages,

1040
01:06:24,220 --> 01:06:25,990
但这不是失败的地方。
but that is not at all where the failure is.

1041
01:06:26,290 --> 01:06:28,890
好的，如果我们想找出，
Okay, so, if we want to find out,

1042
01:06:28,890 --> 01:06:32,190
它是 argfd 或者 argint 或者 argaddr 失败，
like it's either argfd or argint or argaddr, that's failing,

1043
01:06:32,280 --> 01:06:33,690
让我们从 argfd 开始，
let's start with argfd,

1044
01:06:34,050 --> 01:06:36,180
我要把打印语句放在这里，
I'm just gonna stick print statements in here,

1045
01:06:36,180 --> 01:06:40,910
帮助我找出，
to help me figure out,

1046
01:06:40,910 --> 01:06:43,760
这些失败情况中的哪一个触发了，
which one of these failure cases actually triggering triggering,

1047
01:06:43,850 --> 01:06:45,890
有两个地方返回的是 -1 ，
so like two places it returns -1,

1048
01:06:46,280 --> 01:06:49,760
这个是 fd 本身出了问题，
this one there's something wrong with the fd itself,

1049
01:06:52,580 --> 01:06:56,700
所以我们在 argfd 返回 -1 的地方添加打印语句。
so we're gonna get these print statements on cases where argfd returns -1.

1050
01:07:05,950 --> 01:07:10,000
是的，这是什么意思， fd 。
Yeah, what is this mean, fd.

1051
01:07:10,060 --> 01:07:16,560
好的，我们希望这些 fd 打印输出，发生在错误之前，
Alright, so the that we expect these fd printouts to occur, just before the error,

1052
01:07:16,710 --> 01:07:18,600
所以我们看到的是 fd 9 ，
so we saw is fd 9,

1053
01:07:18,600 --> 01:07:22,450
它是 fd 9 ，这会导致错误，
it was fd 9, this causes the error,

1054
01:07:22,810 --> 01:07:25,120
所以 fd 9 没有通过这三个测试中的一个，
so fd 9 failed one of these three tests,

1055
01:07:25,120 --> 01:07:27,040
但我们知道它不小于零，
but we know it's not less than zero,

1056
01:07:27,370 --> 01:07:32,350
我碰巧知道它不大于等于 NOFILE ，即打开的文件数，
I happen to know it's not greater than equal to NOFILE, a number of open files,

1057
01:07:32,350 --> 01:07:36,670
这意味着 ofile 数组 9 ，
and so that means that the ofile array for 9,

1058
01:07:36,670 --> 01:07:38,200
文件描述符 9 必须为 0 ，
file descriptor 9 must have been 0,

1059
01:07:38,200 --> 01:07:41,410
也就是说，在这个进程中，没有文件描述符 9 。
that is in this process, there is no file descriptor 9.

1060
01:07:43,700 --> 01:07:47,500
所以不知道什么原因，写入时复制测试，
So somehow, copy-on-write test,

1061
01:07:49,680 --> 01:07:55,920
这个代码和写入时复制测试传递了无效文件描述符来读取。
this code and copy-on-write test is passing an invalid file descriptor to read.

1062
01:07:56,580 --> 01:08:00,560
所以，文件描述符来自 fds ，
So, file descriptor in comes from fds,

1063
01:08:00,620 --> 01:08:03,930
fds 来自对管道的调用。
fds comes from a call to pipe.

1064
01:08:06,710 --> 01:08:07,460
怎么会，
How could I,

1065
01:08:07,460 --> 01:08:08,840
通常 pipe 如果没有失败，
usually pipe, if it doesn't fail,

1066
01:08:08,840 --> 01:08:10,280
它会将文件描述符留在数组中，
it leaves the file descriptor in the array,

1067
01:08:10,280 --> 01:08:11,420
那么这怎么会出错呢。
so how could this go wrong.

1068
01:08:18,860 --> 01:08:23,270
哦，我们都知道答案一定是什么什么 copyout 。
Oh, we all know the answer has to be blah blah blah copyout.

1069
01:08:25,880 --> 01:08:27,290
那么缺失的部分是什么。
So what's the missing piece.

1070
01:08:38,060 --> 01:08:42,100
我是说，我想有一件事能帮我找到这件事，
I mean, I guess like one thing that help me track this down

1071
01:08:42,100 --> 01:08:47,450
因为我意识到首先 fd 不应该是 9 ，
as I realized at least first of all fd should not be 9,

1072
01:08:47,480 --> 01:08:51,110
在每一次迭代中， 9 都是你所期望的值，
on every iteration 9 is kind of the value that you would expect,

1073
01:08:52,470 --> 01:08:54,240
在上一次迭代的基础上增加一些，
kind of add on the last iteration,

1074
01:08:54,240 --> 01:08:56,310
这像是对管道的最高调用。
that's kind of like the highest call to pipe.

1075
01:08:56,310 --> 01:08:58,560
是的，它们都会得到 9 ，你说得对。
Yeah yeah, they all got 9, you're right.

1076
01:08:58,980 --> 01:09:02,550
有什么东西使内存变得奇怪。
There's something they're kind of touching each other's memory strange.

1077
01:09:03,010 --> 01:09:04,660
是的，完全正确。
Yeah, that's exactly right.

1078
01:09:04,810 --> 01:09:07,950
所以， fds 管道，
So, you know the fds pipe,

1079
01:09:07,950 --> 01:09:11,400
管道转换文件描述符的方式是它调用 copyout ，
the way pipe turns the file descriptors is that it calls copyout,

1080
01:09:12,380 --> 01:09:16,880
将分配的文件描述符号复制到调用方的地址空间。
to copy the file descriptor number that is allocated into the caller's address space.

1081
01:09:17,150 --> 01:09:19,700
我们这里用的是写入时复制 fork ，
Well, we're using copy-on-write fork here,

1082
01:09:19,700 --> 01:09:21,500
所以如果我们不小心，
so if we're not careful,

1083
01:09:21,530 --> 01:09:24,530
至少最初只有一个页面，
so at least initially there's just one page

1084
01:09:24,530 --> 01:09:26,360
它在所有进程之间共享。
and it's shared among all the processes.

1085
01:09:26,570 --> 01:09:28,640
所以第一个调用管道的进程，
So the first process that calls pipe,

1086
01:09:29,780 --> 01:09:30,980
如果出现问题，
if something goes wrong,

1087
01:09:31,220 --> 01:09:35,840
管道系统调用可能会写入共享页面，
the pipe system call might conceivably write the shared page,

1088
01:09:36,700 --> 01:09:40,900
然后该文件描述符的值将被所有进程看到，
and that value that file descriptor will then be seen by all the processes,

1089
01:09:40,900 --> 01:09:44,170
而不仅仅是实际分配描述符的进程。
instead of just the process that actually allocated the descriptor.

1090
01:09:46,660 --> 01:09:50,440
它们看到这个是一种假设风险。
They really see this as a kind of at least hypothetical risk.

1091
01:09:54,030 --> 01:09:55,260
那么让我们来看看，
So let's look at what,

1092
01:09:55,440 --> 01:09:56,280
试着想象一下，
try to imagine,

1093
01:09:56,340 --> 01:10:00,450
因此，首先让我们看看 sysfile ，
so first let's look sysfile

1094
01:10:00,480 --> 01:10:11,460
看看管道是如何复制出分配的文件描述符的，
to see how pipe copies out the file descriptors that allocates

1095
01:10:12,540 --> 01:10:16,820
事实上，在这里有两个调用 copyout ，
and indeed down here, these two calls to copyout

1096
01:10:17,000 --> 01:10:18,950
复制管道数组中的两个元素，
to copy the two elements of that pipe array,

1097
01:10:18,950 --> 01:10:21,380
所以，管道使用 copyout
so pipe is using copyout

1098
01:10:21,380 --> 01:10:25,830
将文件描述符复制到用户空间的数组中。
to copy the file descriptor numbers into the array in user space.

1099
01:10:26,420 --> 01:10:27,680
那么， copyout 做了什么呢。
So what is copyout do.

1100
01:10:31,500 --> 01:10:35,520
嗯，它查找虚拟地址以找到物理地址。
Well, it looks up the virtual address to find a physical address.

1101
01:10:37,100 --> 01:10:45,620
然后它会写入复制该物理地址，仅此而已。
And then its writes, copies over that physical address and that's it.

1102
01:10:46,180 --> 01:10:49,030
因此，它没有做的一件事是
So, one thing it is not doing is

1103
01:10:49,030 --> 01:10:52,090
检查写权限，没有查看 PTE_W 。
checking for write permission, doesn't look at PTE_W.

1104
01:10:53,590 --> 01:10:54,790
因此，对于这个页面，
And so with this page,

1105
01:10:54,790 --> 01:10:58,420
在这个虚拟地址指向的写入时复制的共享页面，
at this virtual address refers to a copy-on-write shared page,

1106
01:10:58,600 --> 01:11:01,840
copyout 根本不知道，它会继续写下去。
copyout just has no idea it just goes ahead and writes it.

1107
01:11:02,580 --> 01:11:06,330
所以我的意思是，当管道调用 copyout 时，
So I mean indeed, when pipe calls copyout,

1108
01:11:06,330 --> 01:11:08,460
它会写一个共享页面，
it's going to be writing a shared page,

1109
01:11:08,460 --> 01:11:11,610
所有 fork 进程都可以看到这个修改，
that all of the forked processes see this modification,

1110
01:11:11,910 --> 01:11:13,770
而不仅仅是调用管道的进程。
not just the process that called pipe.

1111
01:11:15,270 --> 01:11:18,000
对于为什么会发生这个，有什么问题吗？
Any questions about, why this is happening?

1112
01:11:25,570 --> 01:11:26,140
好的。
Okay.

1113
01:11:29,000 --> 01:11:33,080
好的，你们都知道我们需要修改 copyout ，
Alright, so as you all know we need to modify copyout to

1114
01:11:33,080 --> 01:11:37,340
由于 copyout 是查找虚拟地址并将其转换为物理地址，
since copyout is looking up a virtual address and translating into a physical address,

1115
01:11:37,340 --> 01:11:39,110
但是它没有使用 MMU ，
but it is not using the MMU,

1116
01:11:39,350 --> 01:11:41,690
所以 MMU 没有捕捉到写入错误，
so the MMU doesn't catch the write fault,

1117
01:11:41,720 --> 01:11:43,730
因为 MMU 没有参与，
because the MMU is not involved,

1118
01:11:45,290 --> 01:11:47,390
walkaddr 查看页表本身
walkaddr looks at the page table itself

1119
01:11:47,390 --> 01:11:51,560
而不是让 MMU 为它查看页表。
instead of basically getting there MMU to look at the page table for it.

1120
01:11:54,040 --> 01:11:58,210
好的，那么，我们需要修改 copyout ，
Okay, so, we need to modify copyout,

1121
01:11:58,270 --> 01:11:59,740
我们不想调用 walkaddr ，
we don't wanna call walkaddr,

1122
01:11:59,740 --> 01:12:01,690
walkaddr 只产生一个物理地址，
walkaddr just produces a physical address,

1123
01:12:01,720 --> 01:12:03,730
我们实际上需要页表条目，
we actually want the page table entry,

1124
01:12:03,820 --> 01:12:06,040
因为我们想要查看权限位，
because we want to look at the permission bits,

1125
01:12:06,070 --> 01:12:09,970
查看它是否是写入时复制受保护的页面，
to see if it's a copy-on-write protected page,

1126
01:12:10,210 --> 01:12:11,710
所以我们将调用 walk 。
so we're going to call walk instead.

1127
01:12:20,770 --> 01:12:23,650
我们需要检查所有常见的错误，
We need to check all the usual errors,

1128
01:12:24,510 --> 01:12:26,280
所以可能根本就没有映射，
so maybe there's no mapping at all,

1129
01:12:29,260 --> 01:12:31,330
也许不是有效的映射，
maybe it's not a valid mapping,

1130
01:12:33,450 --> 01:12:38,190
或者可能是用户代码不允许使用的映射，
or maybe it's a mapping that the user code is not allowed to use,

1131
01:12:38,430 --> 01:12:41,550
在所有这些情况下，这都是个错误，
in all those cases, it's an error,

1132
01:12:41,550 --> 01:12:43,380
但这一次，我们可以返回一个错误，
but this time we can actually return an error,

1133
01:12:43,560 --> 01:12:46,650
调用 read 返回 -1 ，而不是终止进程，
actually call read to return -1 instead of killing the process,

1134
01:12:46,680 --> 01:12:47,460
那就好了。
that's nice.

1135
01:12:50,690 --> 01:12:53,810
接下来，我们需要知道如何检查它是否是写入时复制页面。
Next we need to know how to check whether it's a copy-on-write page.

1136
01:12:54,080 --> 01:12:57,680
有没有什么想法可以让我们
Any, any ideas for how we can

1137
01:12:59,340 --> 01:13:01,080
检查我们是否应该复制，
check whether we should apply copy

1138
01:13:01,080 --> 01:13:03,270
我们是否应该在这一点上进行复制。
whether we should do a copy at this point.

1139
01:13:11,130 --> 01:13:13,320
写入时复制页面
What's different about between copy-on-write pages

1140
01:13:13,320 --> 01:13:15,360
和普通的非共享页面有什么不同？
and just sort of ordinary unshared pages?

1141
01:13:18,170 --> 01:13:20,030
引用的数量会更大吗？
Would the reference count to be large?

1142
01:13:21,000 --> 01:13:22,200
嗯，这是很好的观点，
Um, that's a good point,

1143
01:13:22,200 --> 01:13:27,760
如果引用计数大于 1 ，
if the reference count was greater than one,

1144
01:13:27,760 --> 01:13:31,450
这当然是一个非常好的线索，
that's certainly a very strong hint,

1145
01:13:31,450 --> 01:13:33,160
那是一个写入时复制页面。
that's a copy-on-write page.

1146
01:13:33,900 --> 01:13:36,090
但是，如果引用计数为 1 ，
But if the reference count is one,

1147
01:13:36,360 --> 01:13:38,700
是否意味着它不是写入时复制页面。
does that mean it's not a copy-on-write page.

1148
01:13:45,900 --> 01:13:48,930
如果你 fork 了，子进程出现写入时复制错误，
It turns out if you fork and the child takes a copy-on-write fault

1149
01:13:48,930 --> 01:13:53,100
做了复制，将引用计数减少到 1 ，
and makes a copy that reduces the reference count to one,

1150
01:13:53,520 --> 01:13:55,800
但是该页在父进程中仍然是写保护的。
but the page is still write protected in the parent.

1151
01:13:59,550 --> 01:14:04,550
在这种情况下，我们也许可以不受影响地进行修改，
And actually probably we could get away with modifying in that case,

1152
01:14:04,580 --> 01:14:08,550
所以我想我们可以检查一下引用数量，
so I think we actually could check the reference count,

1153
01:14:09,980 --> 01:14:12,920
并且仅被视为写入时复制页面，
and only treated as a copy-on-write page,

1154
01:14:12,920 --> 01:14:14,510
如果引用计数大于零，
if the reference count greater than zero,

1155
01:14:14,690 --> 01:14:19,010
但是我要做的是不同的，甚至更容易的捷径，
but what I'm gonna do is different, even easier shortcut

1156
01:14:19,850 --> 01:14:22,100
如果页面是写保护的，
and say if the page is write protected,

1157
01:14:22,310 --> 01:14:25,460
那么页面可以被写保护的唯一方式，
the only way a page can be write protected

1158
01:14:25,610 --> 01:14:27,800
并且设置了 PTE_U 位，
and have the PTE_U bit set,

1159
01:14:28,460 --> 01:14:32,540
在这个版本的 xv6 中，它是写入时复制页面。
in this version of xv6 is it's a copy-on-write page.

1160
01:14:35,170 --> 01:14:38,470
因此，与检查引用计数相比，这为我节省了一点打字时间，
So this has saved me a little bit of typing compared to checking the reference count,

1161
01:14:38,800 --> 01:14:42,790
我们已经在 trap.c 中编写了处理此问题的代码。
we already wrote the code to deal with this in trap.c.

1162
01:14:46,180 --> 01:14:49,070
所以我就从这里调用那个代码。
So I'm just gonna call that code from here.

1163
01:14:51,840 --> 01:14:54,900
我们仍然需要处理可能的错误返回，
We still have to deal with the possible error return,

1164
01:14:54,900 --> 01:15:00,140
如果是个疯狂的地址。
if it's a, a crazy address.

1165
01:15:00,700 --> 01:15:01,600
哦，事实上，我们没有。
Oh, actually, we don't.

1166
01:15:11,880 --> 01:15:12,630
好的。
Alright.

1167
01:15:15,000 --> 01:15:18,280
好的，所以页面不能写入，
Alright, so the pages not write at all,

1168
01:15:18,280 --> 01:15:20,080
我们会调用 cowfault ，
we're just going to copy-on-write fault

1169
01:15:20,230 --> 01:15:23,980
并且 cowfault 会复制并设置页面可写，
and copy-on-write fault does the copy and it makes the page writable,

1170
01:15:25,210 --> 01:15:30,100
所以我想我们在这一点上就快做完了，
so I think we're, we're almost done at this point,

1171
01:15:30,340 --> 01:15:32,950
然而，如果 copyin ，
however if copyin,

1172
01:15:32,950 --> 01:15:35,950
如果 cowfault 没有产生一个。
if cowfault did make a.

1173
01:15:42,310 --> 01:15:42,910
我们删除这个。
We gonna get rid of this.

1174
01:15:43,420 --> 01:15:45,820
如果 cowfault 制作了复制，
If cowfault did make a copy,

1175
01:15:45,820 --> 01:15:49,330
它将修改页表条目中的物理地址，
it's going to modify the physical address in the page table entry,

1176
01:15:49,480 --> 01:15:52,690
因此我们必须再次从页表条目中取出物理地址，
so we have to pull that physical address out of the page table entry again,

1177
01:15:52,690 --> 01:15:53,770
防止它被修改，
in case it was changed,

1178
01:15:53,980 --> 01:15:55,120
我正要这么做，
I'm just gonna do that,

1179
01:15:55,120 --> 01:16:00,770
我们这里有页表条目。
since we have the page table entry right here.

1180
01:16:02,420 --> 01:16:06,320
我认为这或多或少已经足够了。
And I think this is more or less enough.

1181
01:16:07,590 --> 01:16:12,630
那么，关于 copyout 的修改，有什么问题吗？
So, any any questions about the modification to copyout?

1182
01:16:15,940 --> 01:16:20,800
好的，我要做一个 cowfault 的全局声明。
Alright I got to make a global declaration for cowfault.

1183
01:16:37,190 --> 01:16:37,820
漂亮。
Ah beautiful.

1184
01:16:43,870 --> 01:16:46,480
好的，看起来不错。
Alright, that's looking great.

1185
01:16:46,510 --> 01:16:47,920
有没有人知道我们已经完成了。
Anybody happen to know if we're done.

1186
01:16:57,820 --> 01:16:58,660
完成或没有，
We may or not be,

1187
01:16:58,660 --> 01:17:00,790
我们还必须通过 usertests 。
we also have to pass usertests.

1188
01:17:02,680 --> 01:17:07,950
哦，好的，让我删掉这些输出语句。
Oh, alright, let me get rid of this print statements.

1189
01:17:25,540 --> 01:17:29,590
我认为 execout 测试故意分配了大量内存。
I think the execout test intentionally allocates a lot of memory.

1190
01:17:33,260 --> 01:17:39,130
好的，在我们等待用户测试结果的同时，有任何问题吗？
Alright, any questions, while we wait for the verdict from usertests.

1191
01:17:44,140 --> 01:17:45,340
哦， usertests 不开心，
Oh, usertests was unhappy,

1192
01:17:45,340 --> 01:17:48,130
我想这是一块熟悉的破损，
I think this is a familiar piece of damage

1193
01:17:48,130 --> 01:17:50,050
有人已经提出来了，
which somebody's brought up already,

1194
01:17:50,050 --> 01:17:56,720
这是 walk 中的 panic ，
it's, it's the panic at walk

1195
01:17:57,020 --> 01:17:58,070
如果用户进程，
if the user process,

1196
01:17:58,070 --> 01:18:01,460
usertest 我认为是故意做的。
usertests actually I think does intentionally.

1197
01:18:01,610 --> 01:18:04,340
我们看看 usertests 。
We'll take a look at usertests.

1198
01:18:09,540 --> 01:18:11,550
这是 copyout 测试，
And it's the copyout test,

1199
01:18:14,090 --> 01:18:15,950
甚至在它的评论中说，
and even says in the comment,

1200
01:18:15,950 --> 01:18:18,380
它将荒谬的指针传递给系统调用。
it passes ridiculous pointers to system call.

1201
01:18:18,680 --> 01:18:22,970
好的，那么我们面临的是 copyout ，
Alright, so what we're faced with is copyout,

1202
01:18:23,560 --> 01:18:25,060
我们传入一个荒谬的指针，
we pass in a ridiculous pointer,

1203
01:18:25,060 --> 01:18:27,610
使用那个荒谬的指针调用 walk ，
it's simply called walk with that ridiculous pointer

1204
01:18:28,060 --> 01:18:30,790
然后 walk panic 了，
and walk panics,

1205
01:18:30,790 --> 01:18:32,050
如果你给它一个荒谬的指针。
if you give it a ridiculous pointer.

1206
01:18:32,110 --> 01:18:36,350
所以，就像有人提到的，
So, as somebody mentioned,

1207
01:18:36,680 --> 01:18:41,210
我们不能用荒谬的指针来调用 walk ，
we need to not call walk with ridiculous pointers,

1208
01:18:42,970 --> 01:18:44,530
是什么， MAXVA 还是什么。
what is it, MAXVA or something.

1209
01:18:46,440 --> 01:18:46,980
好的。
Alright.

1210
01:18:47,570 --> 01:18:51,590
当然，我们完全有权返回错误
Of course, we're totally entitled to return an error

1211
01:18:51,590 --> 01:18:56,300
如果用户进程传递这个超出的指针。
if the user process pass this outbound pointer.

1212
01:19:00,050 --> 01:19:02,900
好的，我希望现在可以通过。
Alright, I'm just hoping it passes now.

1213
01:19:05,090 --> 01:19:06,710
我没有发现任何其他问题。
I'm not aware of any other problems.

1214
01:19:09,600 --> 01:19:13,150
好了，有什么问题。
Okay, questions.

1215
01:19:16,490 --> 01:19:19,190
我想我的问题更宽泛，
I guess my question is more broad,

1216
01:19:19,580 --> 01:19:23,870
当我们用小步走的时候，
like we saw when we were doing that with small steps,

1217
01:19:23,960 --> 01:19:29,710
我们在这里得到了随机的其他的 bug ，
we're getting random bugs at this point that others have,

1218
01:19:29,770 --> 01:19:32,770
如果我们从头开始做实验，
and if we're doing the lab from scratch,

1219
01:19:32,800 --> 01:19:37,980
那么有那么多奇怪的 bug 不会让人迷惑吗，
then wouldn't it be confusing to get all of those weird bugs,

1220
01:19:38,720 --> 01:19:41,450
你怎么，
and how would how would you,

1221
01:19:42,000 --> 01:19:44,850
你怎么知道是不是你写的东西有 bug ，
how do you know whether it's bug with something you wrote

1222
01:19:44,880 --> 01:19:47,940
或者你没有，而是其余部分的 bug 。
or a bug because you didn't write the rest of it.

1223
01:19:48,540 --> 01:19:50,310
我想我不能回答你的问题。
I'm afraid I cannot answer your question.

1224
01:19:51,980 --> 01:19:54,110
关于 bug 的可悲事实，
The the sad truth about bugs,

1225
01:19:54,110 --> 01:19:58,430
特别是对内核页面表做了一些有趣的事情而导致的错误，
particularly bugs caused by doing funny things to page tables inside the kernel,

1226
01:19:58,850 --> 01:20:03,700
就是每个 bug 都是不同的。
is that every bug, you know every bug is different.

1227
01:20:04,500 --> 01:20:09,420
什么才是追踪漏洞的制胜策略，
And how you know what turns out to be the winning strategy for tracking a bug down,

1228
01:20:10,540 --> 01:20:13,180
这完全取决于 bug 的本质。
it just depends totally on the nature of the bug.

1229
01:20:15,330 --> 01:20:16,530
通常，
My usual,

1230
01:20:16,620 --> 01:20:17,400
我不是，
you know I'm not,

1231
01:20:18,040 --> 01:20:19,480
我有一些，
I have some,

1232
01:20:19,870 --> 01:20:21,610
我有一些策略，
I have a collection of strategies

1233
01:20:21,610 --> 01:20:24,580
有时有用，有时没用，
that are sometimes helpful and sometimes not,

1234
01:20:25,160 --> 01:20:26,360
比如我坚信，
like I'm a huge believer,

1235
01:20:26,360 --> 01:20:28,160
我将打印语句放入代码中，
I'm putting print statements into the code

1236
01:20:28,160 --> 01:20:32,270
以便收集信息或验证假设。
in order to gather information or to verify hypotheses.

1237
01:20:34,720 --> 01:20:37,240
我经常会花时间看看代码，
I'll often spend time just looking at the code,

1238
01:20:37,360 --> 01:20:41,650
只是为了给自己来点头脑风暴，
just for the purpose of generating sort of brainstorming with myself,

1239
01:20:41,650 --> 01:20:43,510
试着生成一些东西，
just try to generate you know things

1240
01:20:43,510 --> 01:20:45,850
在这一点上可能出错的东西，
that could possibly be going wrong at this point,

1241
01:20:46,330 --> 01:20:48,700
然后将打印语句放到[] panic 或其他地方，
and then put print statements in [] panics or something

1242
01:20:48,700 --> 01:20:55,270
试图排除各种猜测问题可能是什么东西。
to try to rule in and rule out various guesses at what the problem might be.

1243
01:20:55,890 --> 01:20:57,480
另一种可能是，
Another possibility is that

1244
01:20:57,810 --> 01:21:00,690
你做了一些，你的代码起作用了，
you know you've made some you know your code worked

1245
01:21:00,690 --> 01:21:02,580
或者没有显示这个错误之类的，
or didn't show this error or something,

1246
01:21:02,850 --> 01:21:05,100
你知道半小时前你做了一些改变，
you know half an hour ago and you made some changes,

1247
01:21:05,100 --> 01:21:06,180
现在你有了一些 bug ，
and now you have some bug,

1248
01:21:06,360 --> 01:21:07,560
另一种可能性是，
another possibility is

1249
01:21:07,560 --> 01:21:12,230
你可以返回到没有错误的代码版本，
to if you can, you know back up to a version of the code that didn't have the bug

1250
01:21:12,230 --> 01:21:15,050
然后一点一点地添加更改，直到错误出现。
and sort of add your changes bit by bit until the bug shows up.

1251
01:21:16,560 --> 01:21:17,580
现在，这些都是，
Now, these are,

1252
01:21:17,610 --> 01:21:20,640
我不知道有什么策略总是奏效的，
I don't know any strategy that always works

1253
01:21:20,640 --> 01:21:22,230
或者甚至有超过一小部分的时间在工作。
or even works more than a fraction of the time.

1254
01:21:25,260 --> 01:21:28,260
但真相是你们在这堂课上学到的东西的一部分，
But the truth is part of what you're learning in this class

1255
01:21:28,290 --> 01:21:30,060
在学习操作系统的同时，
as well as learning about operating systems,

1256
01:21:30,630 --> 01:21:33,960
你正在获得编写和调试代码的经验。
you know you're getting experience writing and debugging code.

1257
01:21:37,860 --> 01:21:39,060
抱歉，没有更多的帮助。
Sorry, not to be more helpful.

1258
01:21:42,950 --> 01:21:43,850
还有其他问题吗？
Other questions?

1259
01:21:52,650 --> 01:21:57,630
好了，我们快下课了。
Alright, we're at the end of class time.

1260
01:22:00,580 --> 01:22:01,900
我很乐意多说几句，
I'm happy to talk more,

1261
01:22:02,790 --> 01:22:06,480
但是这节课的正式部分我们已经讲完了。
but we're done with the formal part of this class.

1262
01:22:10,930 --> 01:22:14,320
好的，我们星期三见。
Alright and to see you all on Wednesday.

1263
01:22:15,390 --> 01:22:17,160
哦，抱歉，我还有另一个问题，
Oh, sorry I actually have another question,

1264
01:22:17,190 --> 01:22:24,340
当我们第一次看到写入错误时，
when we were seeing our first write fault,

1265
01:22:24,460 --> 01:22:29,920
之后我们也看到了对于 shell 非法指令的错误，
we also saw after that for the shell illegal instruction fault

1266
01:22:30,100 --> 01:22:32,860
然后是初始化过程的一些东西，
and then something for the init process,

1267
01:22:33,510 --> 01:22:34,320
那是什么。
what was that.

1268
01:22:39,620 --> 01:22:48,480
好的，我没有一个想法。
Well, I don't have a theory.

1269
01:22:48,600 --> 01:22:53,700
初始化进程，我认为不会与任何东西共享页面。
Init process, I don't think would share pages with anything.

1270
01:22:55,090 --> 01:22:57,460
我只是不知道，很抱歉。
I I just don't know, I'm sorry.

1271
01:22:58,070 --> 01:22:58,520
我们可以。
We could.

1272
01:23:01,890 --> 01:23:02,790
我不得不后退一步，
I would have to back up,

1273
01:23:02,790 --> 01:23:04,050
这发生得很早，
this happened very early,

1274
01:23:04,050 --> 01:23:05,280
当我做实验的时候，
when I was doing the lab,

1275
01:23:05,310 --> 01:23:07,410
我们只需要复制页表，其他什么都不用。
we just had to copy the page table, nothing else.

1276
01:23:07,410 --> 01:23:07,920
是的。
Yeah.

1277
01:23:08,440 --> 01:23:13,300
我想它是，比如 scause f 对于 shell ，
I think it was, like scause f for the shell

1278
01:23:13,420 --> 01:23:20,650
我想可能是 scause c 对于 init 进程。
and I think scause c for the init process, maybe.

1279
01:23:21,810 --> 01:23:23,190
好的，让我看看，
Alright, let me let's see,

1280
01:23:23,190 --> 01:23:27,360
如果你是对的，让我们来看看，我们可以。
if you really, let's let's we can.

1281
01:23:32,270 --> 01:23:42,250
让我们从头开始重建实验，
Let's reconstruct the lab from scratch,

1282
01:23:44,100 --> 01:23:45,420
克隆。
clone.

1283
01:24:07,740 --> 01:24:10,110
好的，我们刚才讲的这一点，
Okay, this point we've just made,

1284
01:24:11,260 --> 01:24:14,290
我刚刚修改了 uvmcopy 。
I just made a change to uvmcopy right.

1285
01:24:16,700 --> 01:24:21,180
所以我们在这里不能做什么，
So we were, what are we not doing here,

1286
01:24:21,180 --> 01:24:24,690
我们没有分配，也没有 memmove 。
we're not allocating and we're not doing memmove.

1287
01:24:27,420 --> 01:24:29,520
但我们会，
But we are,

1288
01:24:34,160 --> 01:24:39,340
我们会把 pa 传给 mappages ，
we're gonna pass pa to mappages

1289
01:24:39,340 --> 01:24:43,180
我想在我第一次跑任何东西的时候。
and I think the very first the very first time I ran anything.

1290
01:24:43,800 --> 01:24:45,450
我想这就是当时的状态。
I think this was the state of play.

1291
01:24:46,050 --> 01:24:48,660
那是在我们做完 flag 之后，所以。
It was after we did the flag, so so.

1292
01:24:48,660 --> 01:24:49,020
好的。
Okay.

1293
01:24:55,490 --> 01:24:57,140
好的，让我们清楚。
Alright, so let's clear.

1294
01:25:11,790 --> 01:25:12,750
看起来不错。
That looks good.

1295
01:25:35,420 --> 01:25:38,210
好的，我们有一个 c ，
Alright, we got a c,

1296
01:25:38,210 --> 01:25:41,450
让我们看看 c 指令页面错误，
well let's see c instruction page fault,

1297
01:25:41,450 --> 01:25:44,900
好的，所以 scause 2 ，
so okay so scause 2,

1298
01:25:46,390 --> 01:25:50,350
我们认为一个共享的进程 id 2 ，
you know, as you know we think a shared process id 2,

1299
01:25:50,350 --> 01:25:53,380
你说得对，是进程 id 1 。
man you're right, it's process id 1.

1300
01:26:00,740 --> 01:26:03,170
我没有一个想法来解释为什么进程 id 1。
I just don't have a theory for why process id 1.

1301
01:26:05,510 --> 01:26:06,770
为什么失控了。
Why it's out of control.

1302
01:26:07,490 --> 01:26:10,070
让我们看看它是做什么的。
Let's let's let's look at what it does.

1303
01:26:14,340 --> 01:26:15,060
我看看 init 。
I just see init.

1304
01:26:33,520 --> 01:26:34,960
好的，它执行这个 shell 。
Okay, it exec this shell.

1305
01:26:39,580 --> 01:26:42,310
我不知道。
I don't know.

1306
01:26:42,400 --> 01:26:45,220
好的，我有个主意，
You know, okay, oh here's an idea,

1307
01:26:45,310 --> 01:26:48,070
进程 id 2 出现错误并退出。
process id 2 is taken a fault and it's exited.

1308
01:26:48,850 --> 01:26:49,450
所以你之后做了 fork 。
So you do fork later.

1309
01:26:49,450 --> 01:26:52,450
是的，那就是这个等待 init ，
Yeah, so that means that this wait to init,

1310
01:26:52,450 --> 01:26:55,660
它返回了，
it has returned, right,

1311
01:26:55,810 --> 01:26:58,030
让我们回到循环中，再次调用 fork ，
let's go back around the loop and call fork again

1312
01:26:58,030 --> 01:26:59,410
所以，在 fork 之后，
and so you know after fork,

1313
01:26:59,560 --> 01:27:03,980
我们现在共享，或者取决于所有这些损坏代码。
we're now sharing or you know depending on all this damage code.

1314
01:27:07,460 --> 01:27:08,690
哦，好的，我明白了。
Oh, okay, I see.

1315
01:27:09,270 --> 01:27:11,220
哦，是的，那是非常令人困惑的。
Oh, yeah, that's that's very confusing.

1316
01:27:11,740 --> 01:27:15,040
哦，是的，这些错误完全是[]，
Oh, yeah, these errors are just like complete [],

1317
01:27:15,070 --> 01:27:18,460
因为我们违反了各种直觉，
because we violated all sorts of intuitions

1318
01:27:18,460 --> 01:27:19,480
关于事情是如何运作的。
about how things should work.

1319
01:27:21,120 --> 01:27:21,870
好的。
Okay.

