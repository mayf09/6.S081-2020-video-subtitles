1
00:00:10,990 --> 00:00:11,950
好的。

2
00:00:13,470 --> 00:00:15,270
大家早上好，下午好，

3
00:00:15,420 --> 00:00:17,610
我要开始了，

4
00:00:17,670 --> 00:00:19,230
大家能听到我说话吗？

5
00:00:20,000 --> 00:00:20,660
是的。

6
00:00:20,980 --> 00:00:21,400
谢谢。

7
00:00:21,850 --> 00:00:24,700
好的，今天我想做的是

8
00:00:24,940 --> 00:00:28,240
给你们一个机会询问关于 xv6 的问题，

9
00:00:28,240 --> 00:00:29,710
以及最近的实验，

10
00:00:29,980 --> 00:00:33,850
为了给我们提供一些可以谈论的东西，

11
00:00:33,970 --> 00:00:41,090
我会尽可能多地做写入时复制 fork 实验，

12
00:00:41,120 --> 00:00:44,030
给我们一些可以考虑的东西，

13
00:00:44,330 --> 00:00:47,450
你可以随意问任何问题，

14
00:00:47,630 --> 00:00:51,770
你可以问为什么我的解决方案与你的不同，

15
00:00:51,770 --> 00:00:54,620
或者为什么 xv6 这样工作，

16
00:00:54,620 --> 00:01:00,660
为什么我们遇到的 bug 以这种方式出现。

17
00:01:02,040 --> 00:01:03,390
所以只想提醒一下，

18
00:01:03,390 --> 00:01:07,050
虽然我相信不需要提醒你们，

19
00:01:07,170 --> 00:01:08,850
写入时复制 fork 的关键点是

20
00:01:08,850 --> 00:01:14,400
为了避免在 fork 时对未修改页面的复制成本。

21
00:01:15,000 --> 00:01:17,820
我输入了几行代码，

22
00:01:17,820 --> 00:01:22,920
来测量 memcpy 必须复制的字节数的减少，

23
00:01:23,250 --> 00:01:27,030
对于我的写入时复制解决方案在 usertests 时，

24
00:01:27,030 --> 00:01:31,820
结果发现实际上减少了 90% 的复制量。

25
00:01:32,630 --> 00:01:33,800
这是针对 usertests 的，

26
00:01:33,800 --> 00:01:36,200
虽然是一个有点怪异的程序，但无所谓，

27
00:01:36,410 --> 00:01:41,570
我认为这很大程度上是因为指令页的复制减少了，

28
00:01:41,570 --> 00:01:44,810
因为指令页从来不会修改，

29
00:01:45,680 --> 00:01:48,290
所以不需要复制它们，

30
00:01:48,500 --> 00:01:50,570
我认为这就是很多优势的来源。

31
00:01:51,040 --> 00:01:53,770
并且写入时复制 fork 还减少了 RAM 的使用，

32
00:01:54,010 --> 00:01:56,860
你需要使用的最大 RAM 量，

33
00:01:56,980 --> 00:01:59,500
它减少了你花在 fork 上的时间，

34
00:02:01,040 --> 00:02:02,780
所以 fork 返回得更快。

35
00:02:02,780 --> 00:02:05,840
从另一方面来说，当然总成本可能会更高，

36
00:02:05,870 --> 00:02:10,250
因为如果程序最终修改了所有写入时复制页面，

37
00:02:10,520 --> 00:02:14,210
你不得不做所有的复制，再加上所有的页面错误，

38
00:02:15,320 --> 00:02:17,450
这可能有点昂贵，

39
00:02:17,450 --> 00:02:22,860
但尽管如此，人们发现，一般说来，这是一种净收益。

40
00:02:23,770 --> 00:02:26,020
如你所知，主要的挑战是，

41
00:02:26,410 --> 00:02:30,100
一个挑战是如何避免释放内存，

42
00:02:30,130 --> 00:02:32,500
现在我们在进程之间共享页面，

43
00:02:32,590 --> 00:02:34,900
没有释放它们，

44
00:02:34,900 --> 00:02:37,570
直到最后一个进程完成使用它们。

45
00:02:37,720 --> 00:02:39,160
所以任何[]。

46
00:02:39,670 --> 00:02:42,010
另一个有趣的挑战是，

47
00:02:42,010 --> 00:02:47,210
特别是 xv6 中的 copyout ，

48
00:02:47,240 --> 00:02:51,680
修改用户内存，而无需实际使用 MMU 分页硬件，

49
00:02:53,410 --> 00:02:55,750
我们必须在这里模仿页面错误。

50
00:02:57,090 --> 00:02:59,340
我要看实验了，

51
00:02:59,370 --> 00:03:02,670
从写入时复制实验的开头开始，

52
00:03:02,820 --> 00:03:03,360
在我开始之前，

53
00:03:03,360 --> 00:03:05,490
我想提一下，

54
00:03:05,490 --> 00:03:09,630
我在做实验时遵循的策略，

55
00:03:09,660 --> 00:03:12,030
我做了很多实验，一年又一年，

56
00:03:12,030 --> 00:03:15,000
我不记得做实验的细节了，

57
00:03:16,890 --> 00:03:18,750
另外，实验也发生了变化。

58
00:03:19,180 --> 00:03:21,250
好的，当我做实验的时候，

59
00:03:21,250 --> 00:03:22,570
我总是迈出一小步，

60
00:03:22,570 --> 00:03:27,100
我可能会发现要解决的问题的下一个子集，

61
00:03:27,250 --> 00:03:29,230
可能有五到十行代码，

62
00:03:29,260 --> 00:03:32,590
我编写程序并运行它，然后试着让它工作，

63
00:03:33,310 --> 00:03:36,910
在我继续下一步之前，

64
00:03:36,970 --> 00:03:42,370
这是，而不是整体思考并编写一个完整的解决方案，

65
00:03:42,850 --> 00:03:46,360
在开始测试和调试之前，

66
00:03:46,360 --> 00:03:49,760
它总是一次测试和调试一点，

67
00:03:50,060 --> 00:03:51,560
这很大程度上是因为，

68
00:03:51,770 --> 00:03:57,110
即使你可能对很多事情都有一些想法，

69
00:03:57,110 --> 00:03:58,130
很多挑战，

70
00:03:58,130 --> 00:03:59,480
还有很多设计，

71
00:03:59,510 --> 00:04:01,580
你要做什么才能解决实验的问题，

72
00:04:01,670 --> 00:04:04,250
我发现至少经常会有惊喜。

73
00:04:04,620 --> 00:04:08,370
所以如果我先实现所有的东西，

74
00:04:08,400 --> 00:04:10,980
我可能会发现我浪费了很多时间，

75
00:04:10,980 --> 00:04:13,380
因为我没有完全理解这个问题，

76
00:04:13,380 --> 00:04:16,290
直到我真正开始调试它。

77
00:04:17,360 --> 00:04:20,930
我在每个点上选择下一步的方式是

78
00:04:20,930 --> 00:04:25,430
通常是由测试失败引起的 panic 或崩溃引起的，

79
00:04:25,430 --> 00:04:28,760
告诉我下一步需要解决的问题。

80
00:04:29,350 --> 00:04:31,330
我在做这个实验，

81
00:04:31,390 --> 00:04:32,650
我会犯几个错误，

82
00:04:32,650 --> 00:04:35,050
这是我上一次做实验时做的，

83
00:04:35,110 --> 00:04:39,430
我们可以一起做一个小的调试练习。

84
00:04:41,360 --> 00:04:45,740
再说一遍，你可以随时打断，问任何问题。

85
00:04:47,040 --> 00:04:52,310
我从写入时复制实验的最新拷贝开始，

86
00:04:53,100 --> 00:04:55,350
和你们所有人一样的源码。

87
00:04:55,920 --> 00:04:57,600
所以，我要开始了。

88
00:04:58,830 --> 00:05:04,660
并且，运行写入时复制测试，

89
00:05:04,660 --> 00:05:06,460
也许我很幸运，

90
00:05:06,460 --> 00:05:08,590
所有测试都会通过，不需要做任何事，

91
00:05:10,510 --> 00:05:11,890
不好，测试失败了，

92
00:05:11,920 --> 00:05:14,320
好的，不用太惊讶。

93
00:05:16,680 --> 00:05:19,710
这时好的步骤就是

94
00:05:19,710 --> 00:05:21,420
去看看测试，

95
00:05:21,450 --> 00:05:23,250
弄清楚它想要做什么，

96
00:05:23,700 --> 00:05:29,130
令人难受的是，有些测试很复杂，很难理解，

97
00:05:29,130 --> 00:05:32,130
不一定是测试任何特定的东西，

98
00:05:32,130 --> 00:05:35,560
它们只是尝试不同的东西，看看会不会断掉，

99
00:05:35,620 --> 00:05:37,570
但幸运的是，这个简单的测试，

100
00:05:39,190 --> 00:05:40,570
它的作用非常清楚。

101
00:05:40,930 --> 00:05:42,130
一个问题。

102
00:05:42,250 --> 00:05:43,180
嗯。

103
00:05:43,210 --> 00:05:45,340
你需要显示一下你的屏幕，我们什么也看不见。

104
00:05:45,490 --> 00:05:46,840
哦，天哪。

105
00:05:47,450 --> 00:05:49,970
不好意思,

106
00:05:50,240 --> 00:05:52,850
谢谢你让我知道。

107
00:05:55,280 --> 00:05:56,240
这好了吗？

108
00:05:57,820 --> 00:05:58,360
是的。

109
00:05:59,140 --> 00:06:00,100
太棒了，好的。

110
00:06:00,970 --> 00:06:03,370
好的，这是第一个 bug 。

111
00:06:06,030 --> 00:06:09,810
好的，我在这里，

112
00:06:09,810 --> 00:06:11,730
在我的写入时复制测试中，

113
00:06:11,850 --> 00:06:16,240
我运行了写入时复制测试，但是失败了。

114
00:06:18,690 --> 00:06:20,100
看看这个测试，

115
00:06:20,100 --> 00:06:23,910
屏幕右边的 simpletest 失败了，

116
00:06:24,150 --> 00:06:28,320
这个测试，我们很幸运，它告诉我们它在做什么，

117
00:06:28,680 --> 00:06:35,370
分配 xv6 中超过一半的可用内存，然后 fork ，

118
00:06:36,570 --> 00:06:40,860
当然，这个失败的原因是 fork 复制了一份，

119
00:06:41,040 --> 00:06:45,030
然后 xv6 从字面上复制了，

120
00:06:45,030 --> 00:06:48,660
所以，如果我们必须复制一半以上的内存，

121
00:06:48,660 --> 00:06:49,950
就会没有足够的空间。

122
00:06:50,910 --> 00:06:54,610
好的，所以，这就是写入时复制的意义所在，

123
00:06:55,000 --> 00:07:01,330
我们知道游戏是不用复制进程的内存，

124
00:07:01,360 --> 00:07:05,380
我们只复制它的页表，而不是内存，

125
00:07:05,740 --> 00:07:10,600
子进程只有一份父进程页表的复制，而不是内存，

126
00:07:11,240 --> 00:07:13,490
指向所有相同的物理页面。

127
00:07:14,390 --> 00:07:25,290
fork 执行复制的位置在 vm.c 和 uvmcopy 中。

128
00:07:27,820 --> 00:07:30,580
所以我们只需修改这个代码，

129
00:07:33,320 --> 00:07:36,170
以代替分配页面内存，

130
00:07:36,870 --> 00:07:40,180
在这里，并复制到上面，

131
00:07:40,300 --> 00:07:43,270
我们要去掉这三行。

132
00:07:43,940 --> 00:07:45,410
取而代之的是，

133
00:07:48,880 --> 00:07:50,740
我只是复制页表条目，

134
00:07:50,920 --> 00:07:53,440
所以，

135
00:07:55,740 --> 00:08:10,310
实际上就是想 hack 这个 mappages 的复制，

136
00:08:10,460 --> 00:08:12,110
因为我们没有在这里分配内存，

137
00:08:12,110 --> 00:08:13,340
我要把删掉这个 free ，

138
00:08:13,520 --> 00:08:15,470
我将修复这个 mappages ，

139
00:08:15,470 --> 00:08:22,780
而不是将 mem 映射到地址 i ，

140
00:08:23,260 --> 00:08:25,210
我要映射 pa ，

141
00:08:25,210 --> 00:08:28,570
它是我们从父进程页表中取出的物理地址。

142
00:08:29,710 --> 00:08:30,640
这里能明白吗？

143
00:08:31,650 --> 00:08:33,600
所以这会产生这样的效果

144
00:08:33,990 --> 00:08:37,680
将所有父页面映射到子页面的地址空间。

145
00:08:39,280 --> 00:08:41,470
pa 不是已经是 uint64 了吗？

146
00:08:44,940 --> 00:08:45,570
可能吧。

147
00:08:45,960 --> 00:08:49,470
或者，如果你强制转换为已经是的类型，是不是很糟糕？

148
00:08:49,470 --> 00:08:53,910
强制转换什么也没做，除了让编译器闭嘴，

149
00:08:54,540 --> 00:08:56,910
因为地址已经是 64 位，

150
00:08:56,910 --> 00:08:58,710
你想要 64 位，

151
00:08:58,860 --> 00:09:00,750
那个强制转换不会改变位，

152
00:09:01,440 --> 00:09:05,430
它只是让类型检查器不那么烦躁，

153
00:09:05,580 --> 00:09:08,400
但是[]你并不知道是哪一种类型。

154
00:09:10,160 --> 00:09:12,200
但是，有一件事是我们不需要这个 mem 变量。

155
00:09:15,550 --> 00:09:18,670
好的，那么你写下 pa ，

156
00:09:21,250 --> 00:09:22,600
天哪，我在想我们是不是完成了。

157
00:09:22,930 --> 00:09:25,660
我们来运行 cowtest ，看看会发生什么，

158
00:09:25,750 --> 00:09:27,490
绝对没完成。

159
00:09:28,330 --> 00:09:31,650
好的，我们在这里有，

160
00:09:31,650 --> 00:09:35,600
这个 usertrap 和 scause 2 。

161
00:09:36,740 --> 00:09:38,720
有人记得 scause 2 是什么吗？

162
00:09:41,410 --> 00:09:42,400
我就直接告诉你吧。

163
00:09:42,430 --> 00:09:44,110
指令失效？

164
00:09:44,140 --> 00:09:45,550
这是非法指令，

165
00:09:45,550 --> 00:09:49,300
那么我们为什么会得到非法指令。

166
00:09:51,320 --> 00:09:52,700
这是我们所期待的吗？

167
00:09:58,070 --> 00:10:04,220
我们有没有覆盖有指令的位置？

168
00:10:05,310 --> 00:10:09,960
是的，有些东西破坏了用户程序的指令。

169
00:10:12,440 --> 00:10:15,800
当然，我们在这里得到错误并不奇怪。

170
00:10:17,180 --> 00:10:20,030
但我们希望是保存的错误，

171
00:10:20,390 --> 00:10:23,480
驱动复制进程和写入时复制。

172
00:10:24,760 --> 00:10:26,320
我们没有得到保存的错误。

173
00:10:31,980 --> 00:10:34,860
对此还有其他假设吗？

174
00:10:35,960 --> 00:10:36,800
这并不公平，

175
00:10:36,800 --> 00:10:39,440
因为这是我的 bug ，不是你的 bug ，

176
00:10:39,980 --> 00:10:40,970
但是不管怎样。

177
00:10:43,540 --> 00:10:45,190
一定要操作 flags 吗？

178
00:10:46,270 --> 00:10:48,190
是的，确实如此。

179
00:10:53,520 --> 00:10:55,950
好的，那我把它放在一边，

180
00:10:55,950 --> 00:10:57,960
它们会再次出现。

181
00:10:57,990 --> 00:11:02,430
另一个问题是我们希望出现保存页面错误，

182
00:11:02,850 --> 00:11:06,030
这将驱动复制进程。

183
00:11:07,090 --> 00:11:09,010
为什么我们没有得到保存页面错误？

184
00:11:21,210 --> 00:11:22,590
好的，嗯。

185
00:11:23,750 --> 00:11:26,120
为什么我们会得到保存页面错误？

186
00:11:27,400 --> 00:11:32,030
RISC-V 在什么情况下会产生保存页面错误。

187
00:11:34,770 --> 00:11:37,470
如果没有设置写标志，我们会得到，

188
00:11:37,590 --> 00:11:40,770
但现在我们可以正常地写任何东西。

189
00:11:41,010 --> 00:11:42,510
是的，设置写标志，

190
00:11:42,510 --> 00:11:43,680
好的，这就是第一个 bug ，

191
00:11:43,680 --> 00:11:47,040
我上一次做这个实验的时候，

192
00:11:47,040 --> 00:11:49,500
所以，我在父级中设置了写标志，

193
00:11:49,500 --> 00:11:51,930
我没有对写标志做任何事情，

194
00:11:51,960 --> 00:11:54,960
这里的标志变量是，

195
00:11:55,750 --> 00:11:58,000
就是我们从父页表获得的，

196
00:11:58,000 --> 00:11:59,740
它的所有页面都是可写的，

197
00:12:00,010 --> 00:12:02,680
所以这意味着它在子页表也可写，

198
00:12:02,680 --> 00:12:03,820
我们不会得到保存页面错误，

199
00:12:03,820 --> 00:12:06,910
所以只是共享一个页面可读写，

200
00:12:07,420 --> 00:12:08,710
这不是我们想要的，

201
00:12:08,860 --> 00:12:10,780
那我怎么才能关掉，

202
00:12:10,810 --> 00:12:13,360
我该如何写保护这些页面。

203
00:12:20,930 --> 00:12:24,360
有什么建议吗，我应该输入什么。

204
00:12:27,730 --> 00:12:28,810
怎么样。

205
00:12:29,360 --> 00:12:41,120
你可以使用 flags &= ~PTE_W 。

206
00:12:41,390 --> 00:12:44,150
是的，我们需要一个波浪号，

207
00:12:44,150 --> 00:12:45,500
我把那个波浪标志叫做波浪号，

208
00:12:45,500 --> 00:12:47,630
我们需要波浪号，

209
00:12:47,630 --> 00:12:50,450
我们需要清除 flags 上的这一位，

210
00:12:50,450 --> 00:12:52,010
我们将保留所有其他 flags 的设置。

211
00:12:52,430 --> 00:12:56,030
好的，这样清除了父页表还是子页表的标志？

212
00:13:01,870 --> 00:13:02,440
子页表？

213
00:13:02,590 --> 00:13:03,640
只是子页表。

214
00:13:04,040 --> 00:13:05,150
那么我如何清除，

215
00:13:05,180 --> 00:13:07,520
我需要清除父页表中的标志吗？

216
00:13:10,390 --> 00:13:15,790
是的，因为我们希望子页表独立于父页表，

217
00:13:15,790 --> 00:13:17,020
如果我们写了一些东西，

218
00:13:17,020 --> 00:13:20,650
我们不想让子页表也得到父页表的修改。

219
00:13:20,890 --> 00:13:21,970
完全正确，

220
00:13:22,000 --> 00:13:23,860
我们也需要对父页表进行写保护，

221
00:13:23,860 --> 00:13:27,310
因为我们不想让子页表看到父页表的修改，

222
00:13:27,310 --> 00:13:30,710
所以试图模仿完全不同的副本。

223
00:13:30,890 --> 00:13:35,420
那么我能怎么来清除父页表中的标志呢？

224
00:13:43,790 --> 00:13:49,160
你可以使用 *pte &= ~PTE ，对吧。

225
00:13:49,720 --> 00:13:51,370
是的，我有父页表的，

226
00:13:51,370 --> 00:13:54,460
一个指向父页表条目的指针，就在 pte 中，

227
00:13:54,970 --> 00:13:58,780
所以我可以这里清除 PTE 标志，

228
00:13:58,810 --> 00:13:59,950
这是很方便的。

229
00:14:02,160 --> 00:14:07,900
我相信这会使页面的两个拷贝，

230
00:14:07,900 --> 00:14:12,380
页面的两个映射都是只读的。

231
00:14:13,000 --> 00:14:18,220
所以，希望现在我们可以得到写入错误。

232
00:14:19,330 --> 00:14:23,620
是否可以清除 PTE_W 位，

233
00:14:23,620 --> 00:14:28,000
在 flags = PTE_FLAGS(*pte) 之前，

234
00:14:28,600 --> 00:14:32,110
这样原来的 flags 才是正确的。

235
00:14:32,320 --> 00:14:34,810
哦，我明白了，把东西放在这里。

236
00:14:35,020 --> 00:14:35,470
是的。

237
00:14:35,710 --> 00:14:37,210
好的，我会试一下，

238
00:14:46,080 --> 00:14:48,420
似乎正常工作了，那就说得通了。

239
00:14:50,860 --> 00:14:52,750
好了，我现在得到了写入错误，

240
00:14:55,230 --> 00:14:56,340
正是我们所希望的，

241
00:14:56,370 --> 00:14:58,050
这个写入错误意味着

242
00:14:58,050 --> 00:15:00,300
其他进程试图修改这个页面，

243
00:15:00,300 --> 00:15:03,450
而 RISC-V 对此产生了页面错误。

244
00:15:04,080 --> 00:15:06,980
我们要[]它，

245
00:15:06,980 --> 00:15:14,300
通过复制这个页面，并映射为读写。

246
00:15:14,630 --> 00:15:16,310
在我们这样做之前，

247
00:15:16,820 --> 00:15:19,760
为了确保我们所看到的，

248
00:15:19,760 --> 00:15:23,900
你知道这里的 f ，这个 scause ，

249
00:15:24,260 --> 00:15:26,570
让我想到，

250
00:15:26,570 --> 00:15:28,970
我们希望是保存错误，

251
00:15:28,970 --> 00:15:31,580
让我们看看实际发生了什么。

252
00:15:33,170 --> 00:15:35,120
我们知道这是进程 id 是 3 ，

253
00:15:35,150 --> 00:15:36,920
进程 id 1 是 init ，

254
00:15:36,920 --> 00:15:39,890
进程 id 2 是 shell ，

255
00:15:40,220 --> 00:15:43,190
所以进程 id 3 可能是 cowtest 。

256
00:15:43,680 --> 00:15:54,290
我们可以看看 cowtest.asm 。

257
00:15:54,910 --> 00:15:58,180
看看 9da ，

258
00:15:58,180 --> 00:16:05,630
它是否是一个可以生成保存页面错误的指令。

259
00:16:08,880 --> 00:16:10,380
糟糕，看起来不太好。

260
00:16:14,480 --> 00:16:16,490
我不记得 auipc 是做什么的，

261
00:16:16,490 --> 00:16:18,830
但我不相信它有保存的操作。

262
00:16:20,120 --> 00:16:21,710
有人想到，发生了什么事吗？

263
00:16:29,000 --> 00:16:32,540
如果看到的页面错误有意义，那就太好了。

264
00:16:36,580 --> 00:16:43,480
我告诉你，这个页面错误发生在 shell 中，

265
00:16:43,510 --> 00:16:47,620
在 shell fork 之后， exec cowtest 之前，

266
00:16:47,770 --> 00:16:50,200
所以，我们查看的是错误的 asm 文件，

267
00:16:50,700 --> 00:16:53,370
正确的 asm 文件是 shell.asm 文件，

268
00:16:53,370 --> 00:16:55,530
我们去那里找 9da 。

269
00:16:56,880 --> 00:17:00,960
是的，在 shell 中， 9da 是一条存储指令，

270
00:17:01,260 --> 00:17:04,500
它位于这个 parsecmd 函数的开头，

271
00:17:04,500 --> 00:17:07,950
它解析我们输入的 cowtest 命令，

272
00:17:07,950 --> 00:17:10,770
并如何处理它，也就是 exec ，

273
00:17:11,430 --> 00:17:13,320
就像保存到堆栈一样，

274
00:17:13,470 --> 00:17:19,380
它是前言，保存被调用者保存寄存器。

275
00:17:20,920 --> 00:17:22,000
这不令人惊讶，

276
00:17:22,000 --> 00:17:23,860
这应该是我们收到的第一个页面错误，

277
00:17:23,860 --> 00:17:25,510
因为它在堆栈上，

278
00:17:25,540 --> 00:17:28,570
函数在 fork 之后做的第一件事返回是

279
00:17:28,570 --> 00:17:30,280
它们修改在堆栈中的变量，

280
00:17:30,280 --> 00:17:34,510
然后砰的一声，不出所料，这导致了保存页面错误。

281
00:17:35,440 --> 00:17:38,040
关于为什么得到错误，有什么问题吗？

282
00:17:41,600 --> 00:17:42,680
我有一个简短的问题，

283
00:17:42,680 --> 00:17:46,670
你怎么知道是在 shell 中而不是 cowtest ？

284
00:17:47,300 --> 00:17:50,750
因为我在 cowtest 里面看到 9da ，

285
00:17:50,840 --> 00:17:52,520
而那个不是保存指令。

286
00:17:53,800 --> 00:17:58,000
我想，天哪，这是怎么回事。

287
00:17:59,430 --> 00:18:00,570
现在，看看进程 id 。

288
00:18:00,570 --> 00:18:03,270
那么 pid 3 是 shell ，还是。

289
00:18:03,270 --> 00:18:07,110
pid 3 是， pid 2 是打印提示符的 shell ，

290
00:18:07,440 --> 00:18:10,590
pid 3 它创建的下一个进程，

291
00:18:10,860 --> 00:18:15,820
所以最初 shell fork 得到 pid 3 。

292
00:18:16,380 --> 00:18:19,050
但 fork 之后，它仍在运行 shell ，

293
00:18:19,230 --> 00:18:23,610
它是 shell 的子进程运行着 shell ，

294
00:18:23,820 --> 00:18:26,790
它将调用 exec 来运行 cowtest ，

295
00:18:26,790 --> 00:18:27,960
但它还没有做，

296
00:18:28,980 --> 00:18:30,540
它没有到达那里，

297
00:18:30,540 --> 00:18:37,090
因为当它写入堆栈时，得到一个保存页面错误。

298
00:18:38,900 --> 00:18:39,890
那么，您能澄清一下，

299
00:18:39,890 --> 00:18:45,380
这是否意味着进程 id 为 2 的 shell 存在错误，

300
00:18:45,380 --> 00:18:50,600
因为它没有正确的数据让子进程拥有正确的数据，

301
00:18:50,600 --> 00:18:53,810
或者是进程 id 为 3 的错误。

302
00:18:55,190 --> 00:18:59,190
这是一个页面错误，发生在进程 id 3 中。

303
00:19:00,620 --> 00:19:03,320
是的，但是我们看到的 bug 就像。

304
00:19:05,380 --> 00:19:09,160
这是在实现写入时复制 fork ，

305
00:19:09,640 --> 00:19:13,870
我们刚才在 vm.c 中所做的是

306
00:19:13,900 --> 00:19:20,440
写保护父进程和子进程中的每一页。

307
00:19:20,820 --> 00:19:22,020
这是这行正在做的事情，

308
00:19:22,320 --> 00:19:27,090
所以，下次父进程或子进程在用户代码有保存时，

309
00:19:27,710 --> 00:19:30,140
它将保存到写保护页中，

310
00:19:30,170 --> 00:19:31,670
因为每一页都是写保护的，

311
00:19:31,760 --> 00:19:33,650
所以它会导致页面错误。

312
00:19:34,330 --> 00:19:36,760
哦，这就是我们想要的页面错误。

313
00:19:36,790 --> 00:19:40,960
对，我只是在检查那个，

314
00:19:42,430 --> 00:19:45,430
所发生的事情正是我们认为的，

315
00:19:45,700 --> 00:19:47,230
而不是其他的 bug 。

316
00:19:48,640 --> 00:19:49,960
好的。

317
00:19:49,960 --> 00:19:51,820
所以我们在这里得到一个保存页面错误，

318
00:19:51,820 --> 00:19:54,670
是 shell 在 fork 之后的第一个保存。

319
00:19:57,090 --> 00:19:59,220
好的，所以现在我们要处理这些，

320
00:20:00,020 --> 00:20:04,030
现在你要在这个页面错误中做一些有用的事情。

321
00:20:04,090 --> 00:20:12,530
所以， trap.c 和用户错误中的页面错误处理程序。

322
00:20:16,020 --> 00:20:20,340
我想我们在哪里插入代码无关紧要。

323
00:20:20,960 --> 00:20:25,400
我是说，这里有很多不同的 uservec 的情况，

324
00:20:25,460 --> 00:20:27,770
uservec 或 usertrap ，

325
00:20:27,770 --> 00:20:31,370
usertrap 就是添加另一个 usertrap ，

326
00:20:31,700 --> 00:20:35,030
我们只对写入错误感兴趣，

327
00:20:35,030 --> 00:20:36,890
我们很高兴读这些共享页面，

328
00:20:36,890 --> 00:20:40,630
因为所有的东西都在那里，只是写[]，

329
00:20:40,630 --> 00:20:41,050
所以。

330
00:20:47,620 --> 00:20:50,850
现在，我相信你知道，

331
00:20:50,850 --> 00:20:52,980
我们将需要使用代码，

332
00:20:52,980 --> 00:20:54,840
我要在两个不同的地方写代码，

333
00:20:54,870 --> 00:20:59,840
我要把它封装在代码中，

334
00:20:59,840 --> 00:21:04,880
让页面的复制在一个函数中，我称为 cowfault 。

335
00:21:05,930 --> 00:21:08,090
它需要知道当前的页表，

336
00:21:08,540 --> 00:21:13,280
也需要知道我们在 stval 上出错的虚拟地址。

337
00:21:13,960 --> 00:21:17,590
有时它可能会因为内存不足而失败，

338
00:21:18,520 --> 00:21:20,260
可能 kalloc 会失败，

339
00:21:20,260 --> 00:21:21,970
所以我们需要为返回值做好准备。

340
00:21:22,270 --> 00:21:24,610
不管失败的原因是什么，

341
00:21:25,190 --> 00:21:28,770
我们都会杀死这个进程，

342
00:21:28,830 --> 00:21:29,700
如果我们没有杀死它，

343
00:21:30,060 --> 00:21:32,940
如果出现失败，我们让 cowfault 返回 -1 ，

344
00:21:33,240 --> 00:21:35,220
如果没有失败，则返回 0 。

345
00:21:35,730 --> 00:21:36,720
如果没有失败，

346
00:21:36,720 --> 00:21:40,680
我们将依赖于 cowfault 使虚拟地址可写，

347
00:21:40,800 --> 00:21:42,540
所以当 usertrap 返回时，

348
00:21:42,540 --> 00:21:44,970
这个进程可以继续成功。

349
00:21:47,510 --> 00:21:50,600
为什么这么放，

350
00:21:50,600 --> 00:21:51,650
有没有理由

351
00:21:51,770 --> 00:21:56,240
为什么把这一行放在 else if devintr 之上。

352
00:21:59,520 --> 00:22:01,260
我不这样认为,

353
00:22:01,410 --> 00:22:04,740
它是否正确，取决于 devintr 做了什么，

354
00:22:04,740 --> 00:22:05,940
查看一下，

355
00:22:05,970 --> 00:22:08,310
风险是 devintr 可能会，

356
00:22:10,080 --> 00:22:12,720
因为某种原因看到设备中断，

357
00:22:12,750 --> 00:22:14,130
即使我们出现了页面错误。

358
00:22:14,700 --> 00:22:17,760
所以我们只要看看 devintr ，

359
00:22:18,340 --> 00:22:23,040
看一下 scause 是 f ，

360
00:22:23,640 --> 00:22:25,080
它将返回 0 。

361
00:22:25,760 --> 00:22:30,200
所以，我只想确定如果。

362
00:22:32,400 --> 00:22:33,900
是的，如果 devintr 返回 0 ，

363
00:22:33,900 --> 00:22:38,920
那么它将继续执行我们的代码，那很好。

364
00:22:40,220 --> 00:22:40,790
好的。

365
00:22:41,430 --> 00:22:42,630
好的，现在我们只需要写。

366
00:22:44,210 --> 00:22:46,550
实际上，有一件事我想在这里提醒，

367
00:22:46,700 --> 00:22:49,920
如果出现失败，我们就会杀死这个进程。

368
00:22:50,610 --> 00:22:52,840
所以，这很不幸，

369
00:22:52,990 --> 00:22:54,640
那就太棒了，

370
00:22:54,670 --> 00:22:57,220
大多数情况下，

371
00:22:57,280 --> 00:23:00,190
进程通过调用系统调用来分配内存或其他什么，

372
00:23:00,190 --> 00:23:03,670
系统调用可以返回一些错误值 -1 或其他，

373
00:23:03,670 --> 00:23:06,730
如果出现失败，进程就可以做一些适当的事情，

374
00:23:08,020 --> 00:23:10,120
它知道如何处理这一失败，

375
00:23:10,360 --> 00:23:12,400
但是这里，因为没有系统调用，

376
00:23:12,430 --> 00:23:16,720
没有任何明显的方式来告诉进程出了问题，

377
00:23:17,980 --> 00:23:20,020
这是令人恼火的，

378
00:23:20,590 --> 00:23:22,270
你可以想象解决这个问题的方法，

379
00:23:22,270 --> 00:23:25,360
例如在一些更复杂的操作系统中，

380
00:23:26,200 --> 00:23:31,720
我们可以有比如 alarm 的用户故障处理程序，

381
00:23:31,720 --> 00:23:32,890
我们可以调用，

382
00:23:32,890 --> 00:23:35,470
表示我们不能继续你的进程了，

383
00:23:35,470 --> 00:23:37,880
因为我们无法修复这个页面错误，

384
00:23:37,940 --> 00:23:39,770
但我们想告诉你出了问题。

385
00:23:41,660 --> 00:23:43,400
但我们现在不会这么做，

386
00:23:44,490 --> 00:23:46,230
杀死这个进程要简单得多。

387
00:23:46,770 --> 00:23:51,390
好的，所以我们要实现这个 cowfault 程序，

388
00:23:51,420 --> 00:23:58,200
使用一个对应当前页表的 pagetable ，

389
00:23:58,200 --> 00:24:01,980
这个参数，出现错误的虚拟地址。

390
00:24:05,780 --> 00:24:08,330
好的，所以我们要考虑的第一个问题，

391
00:24:08,330 --> 00:24:12,140
什么时候处理用户程序产生的虚拟地址，

392
00:24:12,170 --> 00:24:12,950
就像这个地址一样，

393
00:24:13,070 --> 00:24:17,030
如果它是一个完全疯狂的地址，

394
00:24:17,150 --> 00:24:19,610
比如在进程[顶部]上方，

395
00:24:19,610 --> 00:24:24,830
如果地址在 trapframe 或 trampoine 页面上，

396
00:24:24,830 --> 00:24:28,310
或者在堆栈保护页上。

397
00:24:33,300 --> 00:24:35,190
所以有人可以想出一种方法，

398
00:24:35,190 --> 00:24:43,720
保护自己不受用户进程故意在疯狂地址上出错的影响。

399
00:24:50,100 --> 00:24:52,950
是不是有个最大虚拟地址。

400
00:24:54,090 --> 00:24:57,810
是的，确实会出现，

401
00:24:58,170 --> 00:25:06,520
但是用户地址空间的顶部在 MAXVA 下面，

402
00:25:08,010 --> 00:25:13,190
而且堆栈保护页面，

403
00:25:13,580 --> 00:25:15,260
我们不应该允许，

404
00:25:15,260 --> 00:25:17,120
不应该把它当作写入时复制的东西。

405
00:25:17,660 --> 00:25:24,310
好的，我会在这里展示一个解决方案。

406
00:25:24,860 --> 00:25:26,660
我们在这里调用 walk 。

407
00:25:29,910 --> 00:25:32,040
有一件事可能会出错的是，

408
00:25:32,040 --> 00:25:34,500
walk 找不到页表条目，

409
00:25:34,890 --> 00:25:39,690
所以，对于进程可能引用的大多数非法页面，

410
00:25:39,870 --> 00:25:41,190
没有 pte ，

411
00:25:41,630 --> 00:25:43,820
而且只有几个例外，

412
00:25:43,850 --> 00:25:46,430
所以如果我们检测到非法，

413
00:25:46,430 --> 00:25:49,430
如果我们检测到 pte 没有找到，

414
00:25:49,430 --> 00:25:52,760
从 walk 返回 -1 ，

415
00:25:53,370 --> 00:25:55,020
我们几乎处理了所有的情况，

416
00:25:55,380 --> 00:25:59,820
唯一的情况是 walk 会在哪里返回页表条目，

417
00:25:59,820 --> 00:26:01,830
但是我们不想允许对其进行写入，

418
00:26:02,040 --> 00:26:07,230
是 trampoline tramframe 和堆栈保护页面，

419
00:26:07,780 --> 00:26:10,210
这些都没有 PTE_U 。

420
00:26:11,700 --> 00:26:15,780
所以我要检测非法地址的方法是

421
00:26:15,780 --> 00:26:21,050
通过检查 PTE_U 是否被设置，

422
00:26:22,700 --> 00:26:26,630
另外，只要检查一下 PTE_V ，

423
00:26:29,500 --> 00:26:30,820
如果其中任何一个没有设置，

424
00:26:30,820 --> 00:26:36,160
那我们就知道这是个不好的地址，

425
00:26:37,540 --> 00:26:40,300
只需返回 -1 ，杀死进程，

426
00:26:40,990 --> 00:26:51,580
所以我相信处理了所有的非法地址，

427
00:26:51,580 --> 00:26:54,370
用户进程可以使用的。

428
00:26:55,800 --> 00:26:57,510
好的，我们怎么才能知道，

429
00:26:57,510 --> 00:26:58,290
我们想要一份拷贝，

430
00:26:58,290 --> 00:27:01,950
现在我们想要这个进程页面的复制，

431
00:27:02,430 --> 00:27:04,410
我们怎样才能找到要复制的页面。

432
00:27:05,270 --> 00:27:06,620
这里我有个问题。

433
00:27:06,770 --> 00:27:07,310
请说。

434
00:27:07,780 --> 00:27:14,890
使用 PTE_U 来判断页面是否，

435
00:27:15,550 --> 00:27:19,660
如果是合法的写入时复制页面，

436
00:27:19,810 --> 00:27:23,980
这个策略是不是对长期进程不友好，

437
00:27:23,980 --> 00:27:29,290
也许你会地址空间中添加一些其他部分，

438
00:27:29,290 --> 00:27:32,460
它可能是可写的，

439
00:27:32,550 --> 00:27:35,130
它们应该是只是可读的，

440
00:27:35,220 --> 00:27:37,470
但这在这里没有考虑到，

441
00:27:37,710 --> 00:27:39,540
你还得再回来一次。

442
00:27:40,050 --> 00:27:41,370
你说得对，

443
00:27:41,400 --> 00:27:46,490
如果我们要添加任何其他有趣的分页功能，

444
00:27:46,520 --> 00:27:49,130
比如懒分页，

445
00:27:49,940 --> 00:27:51,500
我们必须重新审视这些决定，

446
00:27:51,500 --> 00:27:53,630
然后想出一些其他的策略来决定，

447
00:27:53,840 --> 00:27:55,670
这是不是写入时复制页面，

448
00:27:55,670 --> 00:27:58,010
这是不是一个懒分配页面，

449
00:27:58,010 --> 00:28:00,650
这是不是一个调出到磁盘的页面，

450
00:28:00,650 --> 00:28:02,450
比如内存映射文件。

451
00:28:02,840 --> 00:28:05,780
我们需要更复杂的，

452
00:28:06,470 --> 00:28:08,420
最终我认为，

453
00:28:09,040 --> 00:28:13,120
大多数正式的操作系统都保留了自己的数据结构，

454
00:28:13,820 --> 00:28:16,220
不是一个页表，

455
00:28:16,220 --> 00:28:17,750
而是某种程度上模仿页表，

456
00:28:17,810 --> 00:28:20,120
它描述了进程的地址空间，

457
00:28:20,120 --> 00:28:22,670
并在描述了每个页面的含义，

458
00:28:22,670 --> 00:28:23,750
以及它的状态是什么，

459
00:28:23,780 --> 00:28:25,220
我们必须参考那张表。

460
00:28:27,230 --> 00:28:28,550
但是对这个实验来说，

461
00:28:28,820 --> 00:28:30,530
因为我们没有其他功能，

462
00:28:30,530 --> 00:28:33,020
我们不确定它们会是什么样子，

463
00:28:33,800 --> 00:28:35,330
我只想做些简单的事，

464
00:28:35,360 --> 00:28:37,040
事实上，我们不得不回来修复它，

465
00:28:37,190 --> 00:28:40,040
如果我们把 xv6 做得更复杂。

466
00:28:41,740 --> 00:28:46,630
如果 va 大于 MAXVA ，不会产生 panic 吗，

467
00:28:46,630 --> 00:28:47,800
因为 walk 。

468
00:28:51,630 --> 00:28:54,150
[]，会的。

469
00:28:58,630 --> 00:29:01,240
看看这个，也许是这个过程。

470
00:29:03,310 --> 00:29:04,750
是的，我想你是对的。

471
00:29:05,660 --> 00:29:06,470
太糟糕了。

472
00:29:06,710 --> 00:29:09,720
好的，你说得对，

473
00:29:09,720 --> 00:29:11,730
好的，在这件事上我错了。

474
00:29:12,680 --> 00:29:16,880
等等，如果你检查 MAXVA ，能直接返回 -1 吗？

475
00:29:16,910 --> 00:29:18,260
我认为观察到的情况是，

476
00:29:18,260 --> 00:29:24,950
如果用户试图编写程序写入非常大的地址，

477
00:29:25,500 --> 00:29:29,310
当然，你不能避免这个，

478
00:29:30,660 --> 00:29:34,830
但是在这里是用一个非常大的地址调用 walk ，

479
00:29:35,070 --> 00:29:38,010
看看这里， walk 的实现，

480
00:29:39,780 --> 00:29:40,830
它会产生一个 panic 。

481
00:29:42,120 --> 00:29:45,210
然后我们就可以使用相同的方法 walk 地址，

482
00:29:45,210 --> 00:29:46,590
我也有同样的 bug ，

483
00:29:47,180 --> 00:29:50,030
你可以像其他人说的那样返回 -1 ，

484
00:29:50,060 --> 00:29:53,450
如果在 walk 之前 va 大于 MAXVA 。

485
00:29:55,300 --> 00:29:58,300
让我失望的是，测试似乎没有测试这一点。

486
00:29:59,720 --> 00:30:01,730
因为我没有把这个放进我的解决方案里。

487
00:30:03,050 --> 00:30:03,860
好的。

488
00:30:08,350 --> 00:30:08,890
好的。

489
00:30:10,200 --> 00:30:12,240
好的，那么我们怎么才能找到，

490
00:30:12,240 --> 00:30:14,520
我们想要复制页面，

491
00:30:14,790 --> 00:30:16,920
如何获得指向页面的指针，

492
00:30:16,920 --> 00:30:19,870
指向我可以复制的页面的指针。

493
00:30:22,720 --> 00:30:24,040
PTE2PA 。

494
00:30:24,310 --> 00:30:27,780
是的，所以，它在 pte ，

495
00:30:33,790 --> 00:30:36,100
我要复制到哪里，

496
00:30:41,040 --> 00:30:42,240
我应该复制到什么地方。

497
00:30:44,140 --> 00:30:45,640
一个几乎被分配的页面。

498
00:30:46,000 --> 00:30:48,790
是的，所以我调用 kalloc ，

499
00:30:50,190 --> 00:30:53,040
当然， kalloc 可能会失败，

500
00:30:53,040 --> 00:30:56,010
所以我会捕获它，

501
00:30:57,520 --> 00:30:59,260
我们要看看这个，

502
00:31:01,770 --> 00:31:03,900
所以我放一个 print 语句，这样我们就知道了。

503
00:31:05,670 --> 00:31:06,150
好的，我们。

504
00:31:06,150 --> 00:31:09,060
那不是 pa2 吗，那个等于。

505
00:31:10,390 --> 00:31:14,390
嘿，我留了这个错误，

506
00:31:14,390 --> 00:31:15,680
我想重现它，

507
00:31:15,680 --> 00:31:17,000
这样我们才能追踪到它，

508
00:31:17,000 --> 00:31:20,150
对我来说，你太聪明了。

509
00:31:21,320 --> 00:31:27,520
我要从 pa1 复制到 pa2 。

510
00:31:31,330 --> 00:31:34,480
好的，那么我该怎么，我需要做些什么，

511
00:31:34,480 --> 00:31:41,400
为了映射新的页面 pa2 进入地址空间。

512
00:31:46,340 --> 00:31:47,390
我应该输入什么？

513
00:31:48,610 --> 00:31:50,350
有两种方法，

514
00:31:50,350 --> 00:31:54,700
可以使用已存在的取消映射和映射，

515
00:31:55,180 --> 00:31:58,030
或者你可以操纵这些位。

516
00:31:58,510 --> 00:32:01,180
是的，我太懒了，

517
00:32:01,180 --> 00:32:04,330
不想解决如何使用 munmap 和 mmap ，

518
00:32:04,330 --> 00:32:08,550
所以我在这里创造一个新的页表条目。

519
00:32:13,400 --> 00:32:14,840
我有个问题，

520
00:32:14,870 --> 00:32:18,530
实际上我几乎在每个实验都遇到了这个问题，

521
00:32:18,530 --> 00:32:23,390
因为某种原因，我需要重新映射，

522
00:32:23,390 --> 00:32:27,590
因为它经常发生，

523
00:32:27,590 --> 00:32:33,960
我实现了一个可以重新映射，

524
00:32:34,290 --> 00:32:39,120
我想知道这是不是一个糟糕的设计，

525
00:32:39,120 --> 00:32:40,740
比如危险，所以。

526
00:32:41,010 --> 00:32:44,100
不，这完全合理，

527
00:32:44,100 --> 00:32:46,260
xv6 中的函数是，

528
00:32:47,140 --> 00:32:52,030
专门针对现有的 xv6 ，

529
00:32:52,450 --> 00:32:58,520
它们假设其他代码是如何工作的，

530
00:32:58,520 --> 00:32:59,660
它们产生 panic ，

531
00:32:59,660 --> 00:33:03,350
捕获以意外方式使用它们的代码，

532
00:33:03,350 --> 00:33:05,330
但是如果你改变了 xv6 的工作方式，

533
00:33:05,330 --> 00:33:06,590
你需要做不同的事情，

534
00:33:06,590 --> 00:33:07,940
它是完全合理的，

535
00:33:07,940 --> 00:33:13,710
你需要能够在重新映射时没有 panic ，

536
00:33:13,710 --> 00:33:16,050
旧的 xv6 不需要这样做。

537
00:33:18,440 --> 00:33:19,550
如果你的代码这样做了，

538
00:33:19,670 --> 00:33:22,250
你可以随意修改所需的任何内容。

539
00:33:25,340 --> 00:33:29,060
好的，所以，方法就在这里，

540
00:33:29,060 --> 00:33:30,440
我们有一个写保护的页面，

541
00:33:30,440 --> 00:33:32,450
可能与另一个进程共享，

542
00:33:32,480 --> 00:33:35,420
在这里，我们必须对另一个进程做些什么，

543
00:33:39,240 --> 00:33:40,920
我们需要对另一个进程做些什么。

544
00:33:46,340 --> 00:33:48,980
我们可以什么都不做，

545
00:33:48,980 --> 00:33:51,080
然后当出现页面错误时，

546
00:33:51,560 --> 00:33:55,970
我们分配一个新页面并删除原始页面。

547
00:33:56,550 --> 00:33:57,420
完全正确，

548
00:33:57,630 --> 00:33:58,980
所以你可以想象做一件事，

549
00:33:58,980 --> 00:34:01,350
但是要正确地做它是相当复杂的，

550
00:34:01,740 --> 00:34:03,630
所以我们什么都不做，

551
00:34:03,870 --> 00:34:06,780
如果另一个进程从来没有写入这一页，

552
00:34:06,780 --> 00:34:07,950
那么就不是问题，

553
00:34:08,070 --> 00:34:09,120
如果它写了这一页，

554
00:34:09,120 --> 00:34:10,590
那么它就会经历这一切，

555
00:34:10,590 --> 00:34:15,090
它会复制一份，也会安全地进行，

556
00:34:15,600 --> 00:34:17,400
所以什么都不做，是完全合理的。

557
00:34:18,540 --> 00:34:21,270
好的，现在我们将返回，

558
00:34:21,270 --> 00:34:24,180
返回值是 0 ，因为没有错误，

559
00:34:24,360 --> 00:34:27,180
希望这个过程会。

560
00:34:29,000 --> 00:34:32,030
也许我们应该释放物理页面，

561
00:34:32,810 --> 00:34:34,100
或者我们还没有到那一步。

562
00:34:34,490 --> 00:34:36,140
我们没有。

563
00:34:38,030 --> 00:34:41,300
我想我们要单步了，我们不应该，是的。

564
00:34:41,570 --> 00:34:44,270
如果我这么做了，会发生什么。

565
00:34:44,930 --> 00:34:47,480
它们肯定会崩溃，是的。

566
00:34:47,480 --> 00:34:48,440
所以我们不要这样做，

567
00:34:49,880 --> 00:34:53,020
或者我不知道我们会不会崩溃，

568
00:34:53,020 --> 00:34:54,490
但是我们，

569
00:34:54,760 --> 00:34:56,920
如果我们释放页面，

570
00:34:57,190 --> 00:34:59,500
它肯定是 pa1 ，

571
00:34:59,500 --> 00:35:01,480
因为我们不会释放 pa2 ，

572
00:35:01,780 --> 00:35:03,340
因为我们用的是 pa2 ，

573
00:35:03,340 --> 00:35:07,180
如果我们释放 pa1 ，这意味着另一个进程会有问题，

574
00:35:07,720 --> 00:35:09,520
它现在已经映射到地址空间，

575
00:35:09,520 --> 00:35:12,940
大概是使用执行指令，我不知道是什么，

576
00:35:13,360 --> 00:35:14,920
我们刚刚释放的页面，

577
00:35:14,920 --> 00:35:16,930
可能会被重新用于其他目的，

578
00:35:17,480 --> 00:35:18,770
写些别的东西，

579
00:35:18,950 --> 00:35:24,090
所以我不愿意释放它，尽管它是。

580
00:35:26,880 --> 00:35:31,230
是的，很遗憾，出现很多事情，

581
00:35:31,960 --> 00:35:39,560
在原始的 xv6 中， walk 不会从 vm.c 以外调用，

582
00:35:39,560 --> 00:35:41,270
但是现在我们正在做。

583
00:35:51,120 --> 00:35:52,890
好了，我们到哪儿了。

584
00:35:59,230 --> 00:36:03,790
好的，记得我们得到的第一个页面是 scause 2 ，

585
00:36:04,210 --> 00:36:07,090
为什么我们会得到 scause 2 页面错误。

586
00:36:14,300 --> 00:36:15,650
这是非法指令，

587
00:36:20,920 --> 00:36:22,180
这是下一个问题，

588
00:36:22,630 --> 00:36:24,430
我们现在必须解决这个问题。

589
00:36:26,020 --> 00:36:26,950
出了什么问题，

590
00:36:32,300 --> 00:36:36,050
或者猜一下可能出了什么问题？

591
00:36:43,270 --> 00:36:46,210
所以当我输入 cowtest ，

592
00:36:46,240 --> 00:36:50,800
我们认为发生的情况是 shell fork 是写入时复制 fork 。

593
00:36:51,710 --> 00:36:57,300
我们有个子进程在运行 shell 指令，

594
00:36:58,280 --> 00:37:01,460
可能接受保存错误，

595
00:37:01,460 --> 00:37:03,500
但是为了处理这些保存错误，

596
00:37:03,620 --> 00:37:05,390
然后子进程执行，

597
00:37:05,900 --> 00:37:08,360
子进程复制 shell 执行 cowtest 。

598
00:37:13,920 --> 00:37:16,920
这可能会对父进程 shell 造成什么坏事。

599
00:37:22,480 --> 00:37:23,740
当你调用 exec 的时候，

600
00:37:23,740 --> 00:37:30,100
exec 的实现冻结了所有进程的当前页面，

601
00:37:31,140 --> 00:37:36,750
然后分配新页面将文件加载到你的 exec 中。

602
00:37:39,160 --> 00:37:40,870
子进程会发生什么，

603
00:37:40,990 --> 00:37:42,610
子进程 shell 调用 exec ，

604
00:37:42,610 --> 00:37:44,560
它冻结了所有的页面，

605
00:37:50,630 --> 00:37:52,610
这会对父进程 shell 造成什么影响。

606
00:37:52,670 --> 00:37:53,960
会不会。

607
00:37:54,050 --> 00:37:55,280
哦，对不起。

608
00:37:56,260 --> 00:38:02,710
它会不会意外地释放 shell 的页面。

609
00:38:02,980 --> 00:38:05,500
是的，我们会释放 shell 的每一个页面，

610
00:38:05,500 --> 00:38:08,630
除了一两个要写入的页面。

611
00:38:08,840 --> 00:38:11,330
所以这包括了 shell 指令页面，

612
00:38:11,630 --> 00:38:14,060
然后我们要重新分配它们，

613
00:38:14,060 --> 00:38:17,180
它们会立即被 exec 重新分配，用来存放其他东西，

614
00:38:17,180 --> 00:38:19,910
从我们运行的 cowtest 文件中加载，

615
00:38:20,090 --> 00:38:22,430
所以这会彻底改变 shell 的任何东西，

616
00:38:22,460 --> 00:38:25,700
不出所料，它会立即崩溃。

617
00:38:26,840 --> 00:38:30,050
所以，我们没有以某种方式释放这些页面，

618
00:38:32,700 --> 00:38:34,080
它们看不到这个。

619
00:38:34,740 --> 00:38:35,580
我有一个简短的问题，

620
00:38:35,700 --> 00:38:38,790
这里的 sepc 指向哪里，

621
00:38:38,790 --> 00:38:41,520
你能从哪个汇编文件中找到那个指令吗？

622
00:38:42,960 --> 00:38:43,830
好。

623
00:38:53,270 --> 00:38:55,570
你说它是 shell ，它是。

624
00:38:55,630 --> 00:38:58,240
上次是因为其他错误，

625
00:38:58,270 --> 00:39:00,070
在那里它是 shell ，

626
00:39:00,100 --> 00:39:01,510
这里，我不知道是什么，

627
00:39:01,510 --> 00:39:02,350
我从来没有，

628
00:39:03,200 --> 00:39:06,680
我没有花时间去追查这件事。

629
00:39:07,500 --> 00:39:11,490
所以这个问题可能有多个答案，

630
00:39:11,490 --> 00:39:13,200
即使我能给你答案，

631
00:39:13,230 --> 00:39:16,680
所以答案是 shell 或者 cowtest ，

632
00:39:17,370 --> 00:39:24,130
对于进程 id 3 ，也可能是 cowtest 。

633
00:39:25,140 --> 00:39:27,270
我只是说我不完全知道这是怎么回事，

634
00:39:27,390 --> 00:39:31,470
查看 asm 文件可能没有帮助，

635
00:39:31,650 --> 00:39:35,190
因为我们认为已经发生的整个问题是，

636
00:39:36,590 --> 00:39:41,300
保存指令的页面被释放并重新使用，

637
00:39:41,420 --> 00:39:47,780
所以，它们不再执行 asm 文件中的指令，

638
00:39:48,260 --> 00:39:50,150
或者执行一些垃圾，

639
00:39:52,370 --> 00:39:54,530
所以我们可以看看地址 1004 ，但是它，

640
00:39:55,970 --> 00:39:57,980
它不会真正告诉我们发生了什么。

641
00:39:58,740 --> 00:40:01,530
我们可能使用调试器找出这一点，

642
00:40:02,400 --> 00:40:07,150
我们可以在 gdb 中打断，然后查看指令，

643
00:40:07,150 --> 00:40:12,100
它实际上是一个 1004 指向的虚拟地址。

644
00:40:13,190 --> 00:40:16,880
更进一步的问题，关于那个[]，

645
00:40:17,240 --> 00:40:22,190
所以我的理解是我们得到了一个非法指令错误，

646
00:40:22,190 --> 00:40:28,180
因为我们改变了指令页指令物理内存，

647
00:40:28,180 --> 00:40:30,880
那些内存被写了别的东西，

648
00:40:30,940 --> 00:40:36,270
有没有可能，比如某些幸运的情况下，

649
00:40:36,270 --> 00:40:38,560
它们正在被重写，

650
00:40:38,680 --> 00:40:39,700
但是当我们再次查看它时，

651
00:40:39,700 --> 00:40:42,670
它正在被重写为有效的指令页，

652
00:40:42,670 --> 00:40:46,270
所以我们开始执行随机指令，

653
00:40:46,270 --> 00:40:48,280
却没有得到非法指令错误，

654
00:40:48,280 --> 00:40:49,210
我们得到一些其他错误。

655
00:40:49,480 --> 00:40:52,450
是的，绝对的。

656
00:40:53,440 --> 00:40:58,420
是的，我是说什么事都有可能发生。

657
00:40:58,630 --> 00:40:59,170
我明白了。

658
00:40:59,320 --> 00:41:01,210
我猜不到，

659
00:41:01,240 --> 00:41:04,570
如果我没有做这个实验，

660
00:41:04,940 --> 00:41:08,540
在这里，我猜不出会出什么问题。

661
00:41:11,720 --> 00:41:16,850
事实上，我认为我在这一点上还看到了其他奇怪的事情发生。

662
00:41:18,540 --> 00:41:21,450
可能是第一页数据有垃圾，

663
00:41:21,450 --> 00:41:22,770
它里面有数据，

664
00:41:22,770 --> 00:41:26,100
并且 shell 会遍历完整的垃圾数据，

665
00:41:26,130 --> 00:41:28,440
比如堆栈，而不是指令。

666
00:41:30,940 --> 00:41:32,710
好的，所以我们不想马上释放页面，

667
00:41:32,710 --> 00:41:36,850
我们只想在页面真的不再使用的时候释放它。

668
00:41:39,730 --> 00:41:45,160
那么有没有人能提出标准，

669
00:41:45,160 --> 00:41:50,230
何时应该或不应该释放每个页面的内存？

670
00:41:51,080 --> 00:41:54,980
我们可以记录有多少次，

671
00:41:54,980 --> 00:41:58,580
就像在 kalloc 中，无论你什么时候，

672
00:41:59,250 --> 00:42:02,310
你应该递增和递减某些类型变量，

673
00:42:02,490 --> 00:42:05,610
并保持所有不同地址的数组。

674
00:42:05,820 --> 00:42:07,260
是的，没错。

675
00:42:07,260 --> 00:42:09,240
所以，考虑这个问题的一种方式是，

676
00:42:09,240 --> 00:42:15,720
我们只想在页面引用为零的情况下，释放该页面，

677
00:42:15,960 --> 00:42:17,970
但是，可能会有很多，

678
00:42:17,970 --> 00:42:21,210
如果一个程序 fork 再 fork ，

679
00:42:21,210 --> 00:42:24,360
我们现在可以有三到四个不同的进程，

680
00:42:24,360 --> 00:42:27,900
都引用写入时复制 fork 到这一页，

681
00:42:28,560 --> 00:42:31,230
所以这个计数，

682
00:42:31,230 --> 00:42:33,600
有多少页表引用一个页面，

683
00:42:33,600 --> 00:42:34,920
因为 fork 继续增长，

684
00:42:35,130 --> 00:42:38,040
当进程退出时，可以下降，

685
00:42:38,040 --> 00:42:43,260
或者调用 exec ，它会清除所有页表条目的引用，它会将所有这些引用从页表条目中清除，

686
00:42:43,320 --> 00:42:47,490
或者如果进程进行写入并导致写入错误，

687
00:42:47,670 --> 00:42:51,660
这也是我们减少一个引用的情况，

688
00:42:52,230 --> 00:42:54,660
减少一个到页面的页表引用。

689
00:42:55,210 --> 00:42:56,530
所以我们需要一个计数，

690
00:42:56,800 --> 00:43:01,930
我们想要通过计算引用页面的页表条目来进行计数。

691
00:43:02,840 --> 00:43:05,600
所以我们需要考虑如何保持这个计数，

692
00:43:05,600 --> 00:43:06,890
什么时候增加它，

693
00:43:07,280 --> 00:43:11,000
在代码中的什么位置递增和递减。

694
00:43:12,870 --> 00:43:15,030
好的，所以它们，

695
00:43:15,940 --> 00:43:18,220
如果，你可能意识到，

696
00:43:18,220 --> 00:43:23,110
有多种方法可以维持这一计数，

697
00:43:23,740 --> 00:43:29,740
我的方法是创建一个名为 refcount 的数组，

698
00:43:29,860 --> 00:43:32,910
给每一页一个计数。

699
00:43:33,640 --> 00:43:36,130
我们需要知道有多少条目在 refcount 中，

700
00:43:36,430 --> 00:43:38,140
在 xv6 中，很简单，

701
00:43:38,380 --> 00:43:43,630
它只使用固定数量的物理内存，

702
00:43:43,660 --> 00:43:46,390
我们只需要对每页物理内存一个计数，

703
00:43:46,600 --> 00:43:51,540
我们知道，根据对 kinit 的观察，

704
00:43:51,810 --> 00:43:57,620
xv6 仅使用 PHYSTOP ，物理内存量，

705
00:43:58,130 --> 00:44:01,190
我们只需要保持每页的计数，而不是每字节，

706
00:44:01,190 --> 00:44:04,220
所以我们要把 PHYSTOP 除以 4096 ，

707
00:44:04,710 --> 00:44:06,330
这就是我们需要的数组元素。

708
00:44:09,150 --> 00:44:11,160
在更正式的操作系统中，

709
00:44:11,160 --> 00:44:12,870
我们不知道有多少内存可用，

710
00:44:13,460 --> 00:44:15,230
除非我们检查硬件，

711
00:44:15,230 --> 00:44:20,570
我们不得不动态分配这个数组。

712
00:44:20,990 --> 00:44:23,890
有什么问题吗，把计数放在哪里？

713
00:44:28,410 --> 00:44:29,370
好的。

714
00:44:29,730 --> 00:44:30,090
事实上。

715
00:44:30,090 --> 00:44:30,720
是。

716
00:44:30,750 --> 00:44:34,710
我在想，你直接使用 4096 是什么原因，

717
00:44:34,710 --> 00:44:36,540
而不是页面大小的宏。

718
00:44:37,850 --> 00:44:40,820
是的，原因是我记得 4096 ，

719
00:44:40,970 --> 00:44:43,610
我不记得页面大小宏的名称了，

720
00:44:43,910 --> 00:44:45,470
不过，如果你愿意的话，我很乐意用。

721
00:44:47,850 --> 00:44:52,530
实际上，如果 xv6 的目的是可移植的，

722
00:44:52,530 --> 00:44:56,100
并且能够在具有不同页面大小的各种不同的机器上运行，

723
00:44:56,160 --> 00:44:57,960
我们必须对此更加小心，

724
00:44:57,960 --> 00:45:02,280
但是有 500 种方式使得 xv6 完全不能移植。

725
00:45:04,390 --> 00:45:08,830
所以，我不担心这件事。

726
00:45:09,250 --> 00:45:12,850
我猜页面大小是由硬件决定的，在哪里。

727
00:45:15,100 --> 00:45:21,670
在硬件中，RISC-V 手册上说，页面是多大。

728
00:45:22,560 --> 00:45:24,060
是的，因为，

729
00:45:24,940 --> 00:45:30,030
是 MMU 接受虚拟地址，

730
00:45:30,030 --> 00:45:32,250
并使用它来索引页表。

731
00:45:32,550 --> 00:45:36,660
哦，对，因为地址转换是在硬件中进行的，

732
00:45:36,660 --> 00:45:39,600
所以硬件必须知道页面大小，好的。

733
00:45:40,260 --> 00:45:41,340
它是可配置的，

734
00:45:41,340 --> 00:45:44,880
但是有几种不同的策略可以告诉硬件使用，

735
00:45:44,880 --> 00:45:48,360
但是我们告诉它使用 4096 字节的页面。

736
00:45:49,670 --> 00:45:50,240
好的。

737
00:45:50,630 --> 00:45:52,370
抱歉，教授，

738
00:45:52,400 --> 00:45:54,470
哪里，我想这是个 C 的问题，

739
00:45:54,470 --> 00:46:00,080
所以我们的全局变量比如 refcount 存储在哪里，

740
00:46:00,690 --> 00:46:05,940
比如它们与特定的处理器绑定吗？

741
00:46:05,970 --> 00:46:07,440
这是内核，

742
00:46:08,200 --> 00:46:13,180
所发生的是可执行文件，

743
00:46:16,420 --> 00:46:20,290
编译器和加载器或链接器产生的，

744
00:46:22,270 --> 00:46:25,060
有这种，

745
00:46:25,120 --> 00:46:28,690
表明有多少数据，

746
00:46:28,690 --> 00:46:31,780
程序中所有全局变量的总大小是多少。

747
00:46:32,760 --> 00:46:35,810
我们看不到这些代码，

748
00:46:35,810 --> 00:46:38,690
但是当 QEMU 加载内核时，

749
00:46:41,710 --> 00:46:45,280
实际上是这样的，

750
00:46:45,280 --> 00:46:46,450
当你编译的时候，

751
00:46:46,600 --> 00:46:51,590
程序调用链接器，计算基于，

752
00:46:51,620 --> 00:46:54,110
查看所有全局变量及其大小，

753
00:46:54,230 --> 00:46:56,690
并在内存中分配一个地址，

754
00:46:57,340 --> 00:46:59,650
是的，分配给每个全局变量。

755
00:47:04,340 --> 00:47:06,080
这就是它在内存中的地方。

756
00:47:08,090 --> 00:47:18,970
我是说，我们只是安排，

757
00:47:18,970 --> 00:47:25,480
所以 xv6 内核使用 10000 字节各种全局变量，

758
00:47:26,090 --> 00:47:29,150
并且在引导过程将其加载到存储器中的任何地方，

759
00:47:29,180 --> 00:47:31,460
比如在地址一百万处，

760
00:47:31,460 --> 00:47:39,110
它就使用这些地址用于全局变量。

761
00:47:39,200 --> 00:47:39,920
我明白了，

762
00:47:39,920 --> 00:47:42,380
这是不是跟这个类似，

763
00:47:42,410 --> 00:47:47,810
就像在磁盘上只有一份程序的指令的副本，

764
00:47:47,810 --> 00:47:52,760
这个程序只有一份全局变量的副本。

765
00:47:55,330 --> 00:48:00,130
好的，一个程序，

766
00:48:00,130 --> 00:48:05,010
好的，我不知道该怎么回答，

767
00:48:05,010 --> 00:48:11,980
我的意思是，当你声明一个全局变量时，比如 int x ，

768
00:48:12,440 --> 00:48:15,590
当你编译时，编译编译器和链接器决定

769
00:48:15,650 --> 00:48:18,080
基于谁知道它是什么或者它是可配置的，

770
00:48:18,080 --> 00:48:20,600
但是它们决定了变量的地址，

771
00:48:20,810 --> 00:48:23,780
它们决定 x 地址定为 1000 ，

772
00:48:24,580 --> 00:48:26,980
然后代码读取或写入 x ，

773
00:48:26,980 --> 00:48:30,760
如果我们有代码 refcount[0] 等于 1 ，

774
00:48:31,990 --> 00:48:37,190
但是编译只是把内存设置在 1000 地址，

775
00:48:37,190 --> 00:48:39,890
或者链接器决定把 refcount 放在哪里，

776
00:48:39,950 --> 00:48:44,900
进行存储，设置存储器地址 1001 。

777
00:48:50,790 --> 00:48:55,310
是的，它不是，

778
00:48:55,820 --> 00:48:58,010
它实际上是类似的事情，

779
00:48:58,010 --> 00:49:00,200
和你运行普通用户程序时发生的。

780
00:49:02,980 --> 00:49:06,670
链接器和编译器决定内存全局变量的位置。

781
00:49:07,400 --> 00:49:11,460
它们就在那里，而且可以工作。

782
00:49:13,050 --> 00:49:15,480
我很抱歉，这不是一个很好的解释。

783
00:49:18,560 --> 00:49:25,160
好的，只需定义此全局计数数组，每个物理页一个，

784
00:49:25,730 --> 00:49:29,470
我们需要在不同的地方修改这些计数，

785
00:49:29,530 --> 00:49:31,900
当然，当我们第一次分配页面时，

786
00:49:31,930 --> 00:49:35,230
我们会说它有一个引用，

787
00:49:35,230 --> 00:49:38,890
因为我们把页面地址给调用 kalloc 的程序，

788
00:49:39,130 --> 00:49:43,390
这时，只有该程序引用了这个页面，

789
00:49:43,390 --> 00:49:56,400
因此，我将此页面的引用计数设置为 1 。

790
00:49:56,400 --> 00:49:58,800
所以，首先我要计算一下页码，

791
00:49:58,800 --> 00:50:06,260
它是页面的地址除以 4096 ，即页码。

792
00:50:08,690 --> 00:50:12,170
然后我将设置

793
00:50:12,260 --> 00:50:15,260
刚分配的页面的引用计数为 1 。

794
00:50:21,920 --> 00:50:23,240
有关于这些代码的问题吗？

795
00:50:27,570 --> 00:50:32,490
因为我知道引用计数会有 bug ，

796
00:50:33,120 --> 00:50:36,120
我在这里做了一些合理性检查，

797
00:50:36,120 --> 00:50:43,540
只是，引用计数应该是 0 ，

798
00:50:43,540 --> 00:50:45,790
如果我们刚刚分配的页面是释放的，

799
00:50:45,940 --> 00:50:48,010
最好它的引用计数为 0 。

800
00:50:54,140 --> 00:50:55,550
对这个代码，有什么问题吗？

801
00:51:00,490 --> 00:51:03,520
好的，通常我们希望增加引用计数

802
00:51:03,520 --> 00:51:05,920
我们增加，

803
00:51:06,720 --> 00:51:11,580
当写入时复制 fork 添加指向现有页的页表条目时，

804
00:51:12,000 --> 00:51:13,110
我们想要，

805
00:51:13,820 --> 00:51:17,030
实际上，我们想要减少引用计数，

806
00:51:17,760 --> 00:51:19,440
事实证明，在很多地方，

807
00:51:19,590 --> 00:51:21,570
例如，当进程退出时，

808
00:51:21,750 --> 00:51:24,090
我们需要递减其所有页的引用计数，

809
00:51:24,090 --> 00:51:25,680
当你调用 exec 时，

810
00:51:26,620 --> 00:51:28,840
它释放所有当前内存，

811
00:51:28,840 --> 00:51:29,830
因为它会取代它，

812
00:51:29,830 --> 00:51:31,480
我们想要减少所有的引用计数，

813
00:51:31,480 --> 00:51:33,760
当发生写入时复制页面错误时，

814
00:51:33,760 --> 00:51:35,110
然后我们复制了一份，

815
00:51:35,350 --> 00:51:38,260
我们想要减少旧页面上的引用计数，

816
00:51:38,410 --> 00:51:42,940
这些位置都是可以同时释放页面的，

817
00:51:42,940 --> 00:51:44,440
因为当前的 xv6 ，

818
00:51:44,800 --> 00:51:48,070
考虑每个页面只有一个引用，

819
00:51:48,070 --> 00:51:50,500
所以在大多数我们想要减少的地方，

820
00:51:50,500 --> 00:51:52,060
并发调用 kfree ，

821
00:51:52,300 --> 00:51:53,800
所以我要做的是

822
00:51:53,860 --> 00:51:57,610
修改 kfree 使其具有稍微不同的语义，

823
00:51:57,610 --> 00:51:59,920
使 kfree 成为，

824
00:52:00,250 --> 00:52:04,180
某种可以减少引用计数的函数，

825
00:52:04,300 --> 00:52:07,840
并且仅当引用计数降至零时才释放页面。

826
00:52:08,890 --> 00:52:12,310
我的意思是，我会修复所有调用 kfree 的地方。

827
00:52:16,830 --> 00:52:20,150
好的，我们需要检查，

828
00:52:21,770 --> 00:52:24,470
在我们用垃圾数据填满页面之前。

829
00:52:25,300 --> 00:52:28,090
所以，这让事情变得有点复杂，

830
00:52:28,090 --> 00:52:31,840
因为即使在 kfree 中已经有一个锁的临界区，

831
00:52:31,960 --> 00:52:32,800
我们也不能使用它，

832
00:52:32,800 --> 00:52:35,830
因为它发生在我们将页面填满垃圾数据之后。

833
00:52:37,680 --> 00:52:41,130
所以，我们需要一个锁，

834
00:52:41,130 --> 00:52:43,480
因为我们可能释放同一页面，

835
00:52:43,480 --> 00:52:46,810
在同一时间从多个不同的内核，

836
00:52:47,260 --> 00:52:52,010
同样，我要找到页码，

837
00:52:52,010 --> 00:52:57,030
通过将物理地址除以 4096 。

838
00:52:58,160 --> 00:53:03,800
我想再一次 panic ，只是一次合理性检查，

839
00:53:04,620 --> 00:53:06,330
如果我们要释放一页的话，

840
00:53:06,330 --> 00:53:08,700
最好有超过零的引用计数。

841
00:53:15,210 --> 00:53:19,830
如果页面有多个引用计数，我们需要返回。

842
00:53:20,820 --> 00:53:25,570
实际上，让我们减少引用计数，

843
00:53:26,470 --> 00:53:29,560
我们想在解锁后返回，

844
00:53:29,560 --> 00:53:31,000
我们必须记住一个变量，

845
00:53:31,000 --> 00:53:33,670
我将记住该页面是否有更多引用，

846
00:53:33,670 --> 00:53:35,350
然后释放锁，然后返回，

847
00:53:35,620 --> 00:53:37,840
所以我将创建一个临时变量，

848
00:53:37,840 --> 00:53:44,130
该变量包含，然后释放，

849
00:53:46,640 --> 00:53:50,240
如果还有引用这个页面的话，

850
00:53:50,240 --> 00:53:52,070
我们就返回，不要释放它。

851
00:53:52,750 --> 00:53:55,690
只有当引用计数降到零时，我们才释放它。

852
00:53:57,360 --> 00:53:58,230
有什么问题吗？

853
00:53:58,620 --> 00:53:59,640
你能不能再解释一下，

854
00:53:59,640 --> 00:54:03,480
为什么要在这个过程中取得 kmem->lock ？

855
00:54:04,220 --> 00:54:06,650
为什么整段都要获取它？

856
00:54:07,160 --> 00:54:10,280
是的，当你在做页码计算的时候。

857
00:54:10,730 --> 00:54:12,530
是这一行，

858
00:54:14,350 --> 00:54:18,010
这一行和下一行是问题的关键，

859
00:54:18,010 --> 00:54:21,130
问题是，在这个页面上，

860
00:54:21,220 --> 00:54:23,830
我们现在可能有多个对它的引用，

861
00:54:23,890 --> 00:54:26,530
如果两个进程有相同的引用，

862
00:54:26,680 --> 00:54:28,960
有指向相同页面的页表条目，

863
00:54:29,200 --> 00:54:32,050
如果它们同时在不同的核心上退出，

864
00:54:32,260 --> 00:54:35,890
它们会同时对相同的页面调用 kfree 。

865
00:54:38,740 --> 00:54:43,180
你可以为引用计数变量创建一个新的锁，

866
00:54:43,180 --> 00:54:44,530
然后使用它吗？

867
00:54:48,610 --> 00:54:49,150
是的。

868
00:54:51,340 --> 00:54:52,330
是的，基本上，

869
00:54:52,330 --> 00:54:54,370
所有操纵这些计数的代码

870
00:54:54,370 --> 00:54:55,420
都需要使用相同的锁，

871
00:54:55,420 --> 00:54:58,450
但我觉得锁是什么并不重要。

872
00:55:00,980 --> 00:55:04,610
好的，这就解决了大部分我们关心的减少的问题，

873
00:55:04,610 --> 00:55:05,630
每一次释放页面，

874
00:55:05,630 --> 00:55:08,900
我们只有在引用计数为零的情况下才释放。

875
00:55:09,020 --> 00:55:12,680
我们也需要增加引用计数，

876
00:55:12,980 --> 00:55:14,900
我们需要在哪里增加引用计数。

877
00:55:22,240 --> 00:55:25,090
好的，因为我知道我们需要做好这件事，

878
00:55:25,090 --> 00:55:29,320
任何人都可以调用的函数。

879
00:55:41,460 --> 00:55:43,620
再一次，如果有什么不正常，我想引起 panic ，

880
00:55:43,620 --> 00:55:45,240
所以如果地址很奇怪，

881
00:55:45,930 --> 00:55:50,750
我当然不想超出数组的末尾。

882
00:55:52,820 --> 00:55:56,210
或者如果我们不想增加页面的引用计数，

883
00:55:56,210 --> 00:55:57,770
引用计数为零，

884
00:55:58,470 --> 00:56:00,270
这也是一个错误，

885
00:56:04,440 --> 00:56:05,490
我只是把这些放在这里，

886
00:56:05,490 --> 00:56:07,740
因为从我的代码经验中知道，

887
00:56:07,740 --> 00:56:10,740
正是那种地方，我会有 bug 。

888
00:56:25,610 --> 00:56:27,710
好的，我应该从哪里调用增加。

889
00:56:30,860 --> 00:56:33,110
你有 uvmcopy ，当你。

890
00:56:35,060 --> 00:56:40,950
我认为 uvmcopy 是唯一另一个引用页面的地方。

891
00:56:46,600 --> 00:56:49,000
好的，我这么做了，

892
00:56:49,000 --> 00:56:51,010
这几乎无关紧要。

893
00:56:52,400 --> 00:56:55,010
我们创造了另一个对 pa 的引用，

894
00:56:55,040 --> 00:56:58,570
所以我想使用 incref(pa) 。

895
00:57:01,850 --> 00:57:06,150
很可能会遇到来自编译器的问题，

896
00:57:06,150 --> 00:57:11,850
如果我们不把它的定义放在 traps.h 中。

897
00:57:12,580 --> 00:57:13,210
好的,

898
00:57:18,450 --> 00:57:19,530
让我们看看。

899
00:57:39,230 --> 00:57:40,490
那太快了，

900
00:57:41,950 --> 00:57:44,800
那是 kfree ref ，

901
00:57:45,970 --> 00:57:47,260
kfree 不高兴。

902
00:57:50,380 --> 00:57:54,010
好的，这是在引导过程的早期，

903
00:57:54,010 --> 00:57:56,680
也许是出了什么问题的一个线索。

904
00:57:57,310 --> 00:58:02,800
如果有人有任何猜测，我很乐意听听，

905
00:58:02,800 --> 00:58:05,830
同时，启动调试器，尝试获取回溯信息。

906
00:58:06,660 --> 00:58:08,250
这是在 kinit 中，

907
00:58:08,250 --> 00:58:13,020
因为你正在尝试将内容放入链表，

908
00:58:13,020 --> 00:58:15,030
但是链表尚未分配。

909
00:58:16,360 --> 00:58:22,780
所以，当你尝试将所有内容加载到链表中时，

910
00:58:23,140 --> 00:58:26,170
在那之前你没有调用 kalloc 。

911
00:58:26,500 --> 00:58:27,790
是的，完全正确，

912
00:58:28,090 --> 00:58:31,410
所以，请看这里的操作，

913
00:58:31,440 --> 00:58:32,940
好的，我得到 panic ，

914
00:58:32,940 --> 00:58:35,100
输入 where ，它在，

915
00:58:36,290 --> 00:58:38,030
这里是 kfree 被调用，并引起 panic ，

916
00:58:38,030 --> 00:58:40,010
它一开始就是从 freerange 调用的，

917
00:58:40,010 --> 00:58:43,040
当我们在初始化空闲列表时，

918
00:58:43,400 --> 00:58:47,300
所以在 freerange 有一些需要修复的东西，

919
00:58:47,330 --> 00:58:50,120
问题是我调用 kfree ，

920
00:58:50,120 --> 00:58:51,620
如你所说，我调用 kfree ，

921
00:58:51,620 --> 00:58:53,300
但是当然，所有的引用计数都是零，

922
00:58:53,300 --> 00:58:55,490
当参考计数为 0 时， kfree 会出现 panic ，

923
00:58:55,820 --> 00:59:03,500
所以我把这个改为。

924
00:59:11,100 --> 00:59:11,610
这个怎么样。

925
00:59:20,300 --> 00:59:23,180
好的，我们现在可以启动了，

926
00:59:24,380 --> 00:59:25,220
干得不错，

927
00:59:25,220 --> 00:59:26,030
让我们看看。

928
00:59:30,160 --> 00:59:32,530
好的，让我们再运行一次 cowtest 。

929
00:59:34,290 --> 00:59:36,420
嗯，我们通过了这个 simple 测试，

930
00:59:36,420 --> 00:59:39,600
我们通过了 simple 测试，这很棒。

931
00:59:41,490 --> 00:59:45,450
我们通过了一次 three 测试，

932
00:59:45,510 --> 00:59:47,550
但是我们没有通过，

933
00:59:48,190 --> 00:59:50,860
我们没有通过第二次 three 测试，

934
00:59:51,700 --> 00:59:57,310
test 测试触发了我添加到 trap 的打印语句，

935
00:59:57,310 --> 01:00:00,100
输出 cow kalloc failed ，

936
01:00:00,280 --> 01:00:03,570
只有在我们内存不足的情况下才会打印出来。

937
01:00:05,030 --> 01:00:06,170
所以我们内存不足了。

938
01:00:09,550 --> 01:00:10,660
为什么我们内存不足了。

939
01:00:17,220 --> 01:00:21,120
所以我们每次分配的时候都会更新引用计数，

940
01:00:21,600 --> 01:00:27,090
但是当我们释放的时候，没有减少计数。

941
01:00:27,450 --> 01:00:29,310
那么我应该在哪里加上。

942
01:00:31,670 --> 01:00:33,260
嗯，按照你目前的方法，

943
01:00:33,260 --> 01:00:38,090
我认为 pa1 的引用计数需要减少，

944
01:00:38,090 --> 01:00:39,620
所以我们需要 kfree 它。

945
01:00:39,980 --> 01:00:41,300
是的，就是这样。

946
01:00:41,330 --> 01:00:47,730
我想可能是有人在 45 分钟前提出了这个问题，

947
01:00:47,910 --> 01:00:48,900
让我们看看，

948
01:00:48,930 --> 01:00:52,700
让我们释放 pa1 ，而不是 pa2 。

949
01:00:53,320 --> 01:00:56,480
好的，现在 kfree 的意思是，

950
01:00:56,480 --> 01:00:58,850
不是释放这个页面，

951
01:00:58,880 --> 01:01:02,330
kfree 的意思是减少这个页面上的引用计数，

952
01:01:02,360 --> 01:01:03,650
如果是零的话，才释放它，

953
01:01:03,860 --> 01:01:06,950
以此类推，在只有一个 fork 的简单情况下，

954
01:01:07,130 --> 01:01:09,500
所以有两个对页面的引用，

955
01:01:09,830 --> 01:01:13,220
我们在复制中得到了写入错误，

956
01:01:13,250 --> 01:01:16,580
现在 kfree 要做的就是将计数减为 1 ，

957
01:01:16,580 --> 01:01:18,950
现在另一个进程可以使用这个页面，

958
01:01:19,130 --> 01:01:20,840
我们并不是要释放它。

959
01:01:23,020 --> 01:01:25,810
好的，希望现在，

960
01:01:27,340 --> 01:01:37,810
我们不会在 cowtest 中内存不足。

961
01:01:41,830 --> 01:01:42,790
嗯，我喜欢它，

962
01:01:42,880 --> 01:01:45,040
好的，我们通过了 three 测试，

963
01:01:45,730 --> 01:01:47,170
没有内存不足。

964
01:01:51,420 --> 01:01:51,930
好的，

965
01:01:54,140 --> 01:01:55,940
遗憾的是，我们还没有完成，

966
01:01:55,940 --> 01:02:02,890
我们在 file 测试中有一个有趣的错误，

967
01:02:02,890 --> 01:02:04,720
那么让我们来看一下 file 测试。

968
01:02:11,820 --> 01:02:13,560
好的，这是 filetest ，

969
01:02:13,890 --> 01:02:16,050
它在测试的注释中说，

970
01:02:16,050 --> 01:02:18,090
它测试 copyout ，

971
01:02:18,090 --> 01:02:22,910
所以，是很好的线索，我们的问题在哪里，

972
01:02:23,300 --> 01:02:26,210
实际上失败的事情是，

973
01:02:26,630 --> 01:02:29,090
我的意思是你必须稍微发挥你的想象力，

974
01:02:29,090 --> 01:02:32,330
但是，错误信息似乎是这个，

975
01:02:32,330 --> 01:02:35,330
同时从两个不同的进程打印。

976
01:02:37,440 --> 01:02:39,990
事实上，这个测试是一个循环，

977
01:02:40,560 --> 01:02:43,830
四次迭代，就是 fork ，

978
01:02:43,830 --> 01:02:47,130
因此它将产生四个并发进程，

979
01:02:47,340 --> 01:02:50,340
这个错误消息将被交错，

980
01:02:50,490 --> 01:02:52,320
所以我们需要知道读取失败的原因，

981
01:02:52,320 --> 01:02:53,880
如果我们想了解 bug 是什么，

982
01:02:53,910 --> 01:02:56,010
我们需要知道读取失败的原因。

983
01:02:56,220 --> 01:02:58,770
第一步可能是找出读取返回了什么，

984
01:02:58,770 --> 01:02:59,910
我们所知道的是，

985
01:03:00,870 --> 01:03:05,210
它返回了除了 sizeof(i) 之外的其他东西，

986
01:03:05,240 --> 01:03:06,830
但是我们不知道它返回了什么，

987
01:03:06,830 --> 01:03:09,830
所以我要捕获返回值，

988
01:03:15,680 --> 01:03:18,830
我要打印返回值。

989
01:03:21,930 --> 01:03:23,730
哦，我有个问题，抱歉，

990
01:03:23,790 --> 01:03:27,660
看起来有三个线程失败了，

991
01:03:27,660 --> 01:03:30,520
但是，其中一个并没有结束，

992
01:03:31,150 --> 01:03:32,830
它还在运行，

993
01:03:33,280 --> 01:03:34,630
为什么它没有失败？

994
01:03:35,490 --> 01:03:37,170
为什么第三个线程没有失败？

995
01:03:38,700 --> 01:03:42,240
第四个，如果你做 cowtest 然后 echo ，

996
01:03:42,760 --> 01:03:45,040
另一个还会继续运行，

997
01:03:45,040 --> 01:03:46,840
你会看到更多的输出。

998
01:03:49,290 --> 01:03:51,240
是的，三个失败了，一个没有。

999
01:03:53,230 --> 01:03:57,640
嗯，让我们先调查一下为什么它们中的任何一个都失败了，

1000
01:03:57,790 --> 01:03:59,680
然后我可以猜一猜，

1001
01:04:00,040 --> 01:04:03,460
虽然不知道为什么其中一个没有失败。

1002
01:04:05,110 --> 01:04:08,500
好的，这里发生的情况是， read 返回的是 -1 。

1003
01:04:09,740 --> 01:04:11,570
那么为什么 read 返回的是 -1 。

1004
01:04:12,870 --> 01:04:14,370
你可能会假设，

1005
01:04:14,370 --> 01:04:17,670
我们将这个 buf 传递给 read ，

1006
01:04:18,060 --> 01:04:20,190
你可能会想象，

1007
01:04:20,340 --> 01:04:22,650
你知道 read 需要做一些事情，

1008
01:04:22,650 --> 01:04:28,560
也就是调用 copyout 将文件数据复制到这个缓冲区中，

1009
01:04:29,120 --> 01:04:30,110
我们传递给 read 的，

1010
01:04:30,110 --> 01:04:31,370
也许它出了什么问题，

1011
01:04:31,370 --> 01:04:33,200
它与写入是复制 fork 的关系。

1012
01:04:33,440 --> 01:04:34,880
那么让我们来看看 read ，

1013
01:04:38,530 --> 01:04:40,150
看看它为什么会失败。

1014
01:04:40,730 --> 01:04:44,440
找出，为什么 read ，

1015
01:04:44,470 --> 01:04:46,450
好的，那么让我们来捕捉，

1016
01:04:46,480 --> 01:04:49,840
read 所有 sys_read 调用 fileread ，

1017
01:04:50,170 --> 01:04:52,000
在获取一组参数之后。

1018
01:04:55,010 --> 01:04:57,110
所以我们修复这个，

1019
01:04:58,480 --> 01:05:01,540
走进一步，来理解什么东西出错了。

1020
01:05:05,310 --> 01:05:09,770
我们希望 cc 会为 -1 。

1021
01:05:18,500 --> 01:05:20,090
嗯，有意思，

1022
01:05:20,390 --> 01:05:24,410
我们没有看到 cc 等于 -1 。

1023
01:05:25,060 --> 01:05:27,010
事实上，失败发生了，

1024
01:05:27,310 --> 01:05:30,010
失败从这里开始发生，

1025
01:05:30,040 --> 01:05:36,010
在我们得到任何相应的 cc 打印语句之前，

1026
01:05:36,010 --> 01:05:37,570
它根本不是 -1 ，

1027
01:05:37,570 --> 01:05:39,790
而是 4 ，这是一个非失败值。

1028
01:05:42,620 --> 01:05:43,520
所以这意味着，

1029
01:05:43,520 --> 01:05:46,040
在调用 fileread 之前的一些事情，

1030
01:05:46,520 --> 01:05:50,780
一定触发了这次返回，

1031
01:05:50,930 --> 01:05:52,460
这里的其中一个函数，

1032
01:05:53,580 --> 01:05:56,070
导致 read 返回 -1 。

1033
01:05:58,690 --> 01:06:00,940
请随意猜猜，在我输入时。

1034
01:06:03,980 --> 01:06:05,690
顺便说一下，这对我来说完全是个意外，

1035
01:06:05,690 --> 01:06:08,050
当我追踪到它的时候。

1036
01:06:08,950 --> 01:06:11,260
哦，我想这个文件是描述符。

1037
01:06:12,010 --> 01:06:14,260
是的，文件描述符，我看到了，

1038
01:06:14,260 --> 01:06:18,430
我所期望的是 fileread 失败是由于某些原因，

1039
01:06:18,430 --> 01:06:23,290
而且 copyout 对写入时复制的页面做不正确的事情，

1040
01:06:24,220 --> 01:06:25,990
但这不是失败的地方。

1041
01:06:26,290 --> 01:06:28,890
好的，如果我们想找出，

1042
01:06:28,890 --> 01:06:32,190
它是 argfd 或者 argint 或者 argaddr 失败，

1043
01:06:32,280 --> 01:06:33,690
让我们从 argfd 开始，

1044
01:06:34,050 --> 01:06:36,180
我要把打印语句放在这里，

1045
01:06:36,180 --> 01:06:40,910
帮助我找出，

1046
01:06:40,910 --> 01:06:43,760
这些失败情况中的哪一个触发了，

1047
01:06:43,850 --> 01:06:45,890
有两个地方返回的是 -1 ，

1048
01:06:46,280 --> 01:06:49,760
这个是 fd 本身出了问题，

1049
01:06:52,580 --> 01:06:56,700
所以我们在 argfd 返回 -1 的地方添加打印语句。

1050
01:07:05,950 --> 01:07:10,000
是的，这是什么意思， fd 。

1051
01:07:10,060 --> 01:07:16,560
好的，我们希望这些 fd 打印输出，发生在错误之前，

1052
01:07:16,710 --> 01:07:18,600
所以我们看到的是 fd 9 ，

1053
01:07:18,600 --> 01:07:22,450
它是 fd 9 ，这会导致错误，

1054
01:07:22,810 --> 01:07:25,120
所以 fd 9 没有通过这三个测试中的一个，

1055
01:07:25,120 --> 01:07:27,040
但我们知道它不小于零，

1056
01:07:27,370 --> 01:07:32,350
我碰巧知道它不大于等于 NOFILE ，即打开的文件数，

1057
01:07:32,350 --> 01:07:36,670
这意味着 ofile 数组 9 ，

1058
01:07:36,670 --> 01:07:38,200
文件描述符 9 必须为 0 ，

1059
01:07:38,200 --> 01:07:41,410
也就是说，在这个进程中，没有文件描述符 9 。

1060
01:07:43,700 --> 01:07:47,500
所以不知道什么原因，写入时复制测试，

1061
01:07:49,680 --> 01:07:55,920
这个代码和写入时复制测试传递了无效文件描述符来读取。

1062
01:07:56,580 --> 01:08:00,560
所以，文件描述符来自 fds ，

1063
01:08:00,620 --> 01:08:03,930
fds 来自对管道的调用。

1064
01:08:06,710 --> 01:08:07,460
怎么会，

1065
01:08:07,460 --> 01:08:08,840
通常 pipe 如果没有失败，

1066
01:08:08,840 --> 01:08:10,280
它会将文件描述符留在数组中，

1067
01:08:10,280 --> 01:08:11,420
那么这怎么会出错呢。

1068
01:08:18,860 --> 01:08:23,270
哦，我们都知道答案一定是什么什么 copyout 。

1069
01:08:25,880 --> 01:08:27,290
那么缺失的部分是什么。

1070
01:08:38,060 --> 01:08:42,100
我是说，我想有一件事能帮我找到这件事，

1071
01:08:42,100 --> 01:08:47,450
因为我意识到首先 fd 不应该是 9 ，

1072
01:08:47,480 --> 01:08:51,110
在每一次迭代中， 9 都是你所期望的值，

1073
01:08:52,470 --> 01:08:54,240
在上一次迭代的基础上增加一些，

1074
01:08:54,240 --> 01:08:56,310
这像是对管道的最高调用。

1075
01:08:56,310 --> 01:08:58,560
是的，它们都会得到 9 ，你说得对。

1076
01:08:58,980 --> 01:09:02,550
有什么东西使内存变得奇怪。

1077
01:09:03,010 --> 01:09:04,660
是的，完全正确。

1078
01:09:04,810 --> 01:09:07,950
所以， fds 管道，

1079
01:09:07,950 --> 01:09:11,400
管道转换文件描述符的方式是它调用 copyout ，

1080
01:09:12,380 --> 01:09:16,880
将分配的文件描述符号复制到调用方的地址空间。

1081
01:09:17,150 --> 01:09:19,700
我们这里用的是写入时复制 fork ，

1082
01:09:19,700 --> 01:09:21,500
所以如果我们不小心，

1083
01:09:21,530 --> 01:09:24,530
至少最初只有一个页面，

1084
01:09:24,530 --> 01:09:26,360
它在所有进程之间共享。

1085
01:09:26,570 --> 01:09:28,640
所以第一个调用管道的进程，

1086
01:09:29,780 --> 01:09:30,980
如果出现问题，

1087
01:09:31,220 --> 01:09:35,840
管道系统调用可能会写入共享页面，

1088
01:09:36,700 --> 01:09:40,900
然后该文件描述符的值将被所有进程看到，

1089
01:09:40,900 --> 01:09:44,170
而不仅仅是实际分配描述符的进程。

1090
01:09:46,660 --> 01:09:50,440
它们看到这个是一种假设风险。

1091
01:09:54,030 --> 01:09:55,260
那么让我们来看看，

1092
01:09:55,440 --> 01:09:56,280
试着想象一下，

1093
01:09:56,340 --> 01:10:00,450
因此，首先让我们看看 sysfile ，

1094
01:10:00,480 --> 01:10:11,460
看看管道是如何复制出分配的文件描述符的，

1095
01:10:12,540 --> 01:10:16,820
事实上，在这里有两个调用 copyout ，

1096
01:10:17,000 --> 01:10:18,950
复制管道数组中的两个元素，

1097
01:10:18,950 --> 01:10:21,380
所以，管道使用 copyout

1098
01:10:21,380 --> 01:10:25,830
将文件描述符复制到用户空间的数组中。

1099
01:10:26,420 --> 01:10:27,680
那么， copyout 做了什么呢。

1100
01:10:31,500 --> 01:10:35,520
嗯，它查找虚拟地址以找到物理地址。

1101
01:10:37,100 --> 01:10:45,620
然后它会写入复制该物理地址，仅此而已。

1102
01:10:46,180 --> 01:10:49,030
因此，它没有做的一件事是

1103
01:10:49,030 --> 01:10:52,090
检查写权限，没有查看 PTE_W 。

1104
01:10:53,590 --> 01:10:54,790
因此，对于这个页面，

1105
01:10:54,790 --> 01:10:58,420
在这个虚拟地址指向的写入时复制的共享页面，

1106
01:10:58,600 --> 01:11:01,840
copyout 根本不知道，它会继续写下去。

1107
01:11:02,580 --> 01:11:06,330
所以我的意思是，当管道调用 copyout 时，

1108
01:11:06,330 --> 01:11:08,460
它会写一个共享页面，

1109
01:11:08,460 --> 01:11:11,610
所有 fork 进程都可以看到这个修改，

1110
01:11:11,910 --> 01:11:13,770
而不仅仅是调用管道的进程。

1111
01:11:15,270 --> 01:11:18,000
对于为什么会发生这个，有什么问题吗？

1112
01:11:25,570 --> 01:11:26,140
好的。

1113
01:11:29,000 --> 01:11:33,080
好的，你们都知道我们需要修改 copyout ，

1114
01:11:33,080 --> 01:11:37,340
由于 copyout 是查找虚拟地址并将其转换为物理地址，

1115
01:11:37,340 --> 01:11:39,110
但是它没有使用 MMU ，

1116
01:11:39,350 --> 01:11:41,690
所以 MMU 没有捕捉到写入错误，

1117
01:11:41,720 --> 01:11:43,730
因为 MMU 没有参与，

1118
01:11:45,290 --> 01:11:47,390
walkaddr 查看页表本身

1119
01:11:47,390 --> 01:11:51,560
而不是让 MMU 为它查看页表。

1120
01:11:54,040 --> 01:11:58,210
好的，那么，我们需要修改 copyout ，

1121
01:11:58,270 --> 01:11:59,740
我们不想调用 walkaddr ，

1122
01:11:59,740 --> 01:12:01,690
walkaddr 只产生一个物理地址，

1123
01:12:01,720 --> 01:12:03,730
我们实际上需要页表条目，

1124
01:12:03,820 --> 01:12:06,040
因为我们想要查看权限位，

1125
01:12:06,070 --> 01:12:09,970
查看它是否是写入时复制受保护的页面，

1126
01:12:10,210 --> 01:12:11,710
所以我们将调用 walk 。

1127
01:12:20,770 --> 01:12:23,650
我们需要检查所有常见的错误，

1128
01:12:24,510 --> 01:12:26,280
所以可能根本就没有映射，

1129
01:12:29,260 --> 01:12:31,330
也许不是有效的映射，

1130
01:12:33,450 --> 01:12:38,190
或者可能是用户代码不允许使用的映射，

1131
01:12:38,430 --> 01:12:41,550
在所有这些情况下，这都是个错误，

1132
01:12:41,550 --> 01:12:43,380
但这一次，我们可以返回一个错误，

1133
01:12:43,560 --> 01:12:46,650
调用 read 返回 -1 ，而不是终止进程，

1134
01:12:46,680 --> 01:12:47,460
那就好了。

1135
01:12:50,690 --> 01:12:53,810
接下来，我们需要知道如何检查它是否是写入时复制页面。

1136
01:12:54,080 --> 01:12:57,680
有没有什么想法可以让我们

1137
01:12:59,340 --> 01:13:01,080
检查我们是否应该复制，

1138
01:13:01,080 --> 01:13:03,270
我们是否应该在这一点上进行复制。

1139
01:13:11,130 --> 01:13:13,320
写入时复制页面

1140
01:13:13,320 --> 01:13:15,360
和普通的非共享页面有什么不同？

1141
01:13:18,170 --> 01:13:20,030
引用的数量会更大吗？

1142
01:13:21,000 --> 01:13:22,200
嗯，这是很好的观点，

1143
01:13:22,200 --> 01:13:27,760
如果引用计数大于 1 ，

1144
01:13:27,760 --> 01:13:31,450
这当然是一个非常好的线索，

1145
01:13:31,450 --> 01:13:33,160
那是一个写入时复制页面。

1146
01:13:33,900 --> 01:13:36,090
但是，如果引用计数为 1 ，

1147
01:13:36,360 --> 01:13:38,700
是否意味着它不是写入时复制页面。

1148
01:13:45,900 --> 01:13:48,930
如果你 fork 了，子进程出现写入时复制错误，

1149
01:13:48,930 --> 01:13:53,100
做了复制，将引用计数减少到 1 ，

1150
01:13:53,520 --> 01:13:55,800
但是该页在父进程中仍然是写保护的。

1151
01:13:59,550 --> 01:14:04,550
在这种情况下，我们也许可以不受影响地进行修改，

1152
01:14:04,580 --> 01:14:08,550
所以我想我们可以检查一下引用数量，

1153
01:14:09,980 --> 01:14:12,920
并且仅被视为写入时复制页面，

1154
01:14:12,920 --> 01:14:14,510
如果引用计数大于零，

1155
01:14:14,690 --> 01:14:19,010
但是我要做的是不同的，甚至更容易的捷径，

1156
01:14:19,850 --> 01:14:22,100
如果页面是写保护的，

1157
01:14:22,310 --> 01:14:25,460
那么页面可以被写保护的唯一方式，

1158
01:14:25,610 --> 01:14:27,800
并且设置了 PTE_U 位，

1159
01:14:28,460 --> 01:14:32,540
在这个版本的 xv6 中，它是写入时复制页面。

1160
01:14:35,170 --> 01:14:38,470
因此，与检查引用计数相比，这为我节省了一点打字时间，

1161
01:14:38,800 --> 01:14:42,790
我们已经在 trap.c 中编写了处理此问题的代码。

1162
01:14:46,180 --> 01:14:49,070
所以我就从这里调用那个代码。

1163
01:14:51,840 --> 01:14:54,900
我们仍然需要处理可能的错误返回，

1164
01:14:54,900 --> 01:15:00,140
如果是个疯狂的地址。

1165
01:15:00,700 --> 01:15:01,600
哦，事实上，我们没有。

1166
01:15:11,880 --> 01:15:12,630
好的。

1167
01:15:15,000 --> 01:15:18,280
好的，所以页面不能写入，

1168
01:15:18,280 --> 01:15:20,080
我们会调用 cowfault ，

1169
01:15:20,230 --> 01:15:23,980
并且 cowfault 会复制并设置页面可写，

1170
01:15:25,210 --> 01:15:30,100
所以我想我们在这一点上就快做完了，

1171
01:15:30,340 --> 01:15:32,950
然而，如果 copyin ，

1172
01:15:32,950 --> 01:15:35,950
如果 cowfault 没有产生一个。

1173
01:15:42,310 --> 01:15:42,910
我们删除这个。

1174
01:15:43,420 --> 01:15:45,820
如果 cowfault 制作了复制，

1175
01:15:45,820 --> 01:15:49,330
它将修改页表条目中的物理地址，

1176
01:15:49,480 --> 01:15:52,690
因此我们必须再次从页表条目中取出物理地址，

1177
01:15:52,690 --> 01:15:53,770
防止它被修改，

1178
01:15:53,980 --> 01:15:55,120
我正要这么做，

1179
01:15:55,120 --> 01:16:00,770
我们这里有页表条目。

1180
01:16:02,420 --> 01:16:06,320
我认为这或多或少已经足够了。

1181
01:16:07,590 --> 01:16:12,630
那么，关于 copyout 的修改，有什么问题吗？

1182
01:16:15,940 --> 01:16:20,800
好的，我要做一个 cowfault 的全局声明。

1183
01:16:37,190 --> 01:16:37,820
漂亮。

1184
01:16:43,870 --> 01:16:46,480
好的，看起来不错。

1185
01:16:46,510 --> 01:16:47,920
有没有人知道我们已经完成了。

1186
01:16:57,820 --> 01:16:58,660
完成或没有，

1187
01:16:58,660 --> 01:17:00,790
我们还必须通过 usertests 。

1188
01:17:02,680 --> 01:17:07,950
哦，好的，让我删掉这些输出语句。

1189
01:17:25,540 --> 01:17:29,590
我认为 execout 测试故意分配了大量内存。

1190
01:17:33,260 --> 01:17:39,130
好的，在我们等待用户测试结果的同时，有任何问题吗？

1191
01:17:44,140 --> 01:17:45,340
哦， usertests 不开心，

1192
01:17:45,340 --> 01:17:48,130
我想这是一块熟悉的破损，

1193
01:17:48,130 --> 01:17:50,050
有人已经提出来了，

1194
01:17:50,050 --> 01:17:56,720
这是 walk 中的 panic ，

1195
01:17:57,020 --> 01:17:58,070
如果用户进程，

1196
01:17:58,070 --> 01:18:01,460
usertest 我认为是故意做的。

1197
01:18:01,610 --> 01:18:04,340
我们看看 usertests 。

1198
01:18:09,540 --> 01:18:11,550
这是 copyout 测试，

1199
01:18:14,090 --> 01:18:15,950
甚至在它的评论中说，

1200
01:18:15,950 --> 01:18:18,380
它将荒谬的指针传递给系统调用。

1201
01:18:18,680 --> 01:18:22,970
好的，那么我们面临的是 copyout ，

1202
01:18:23,560 --> 01:18:25,060
我们传入一个荒谬的指针，

1203
01:18:25,060 --> 01:18:27,610
使用那个荒谬的指针调用 walk ，

1204
01:18:28,060 --> 01:18:30,790
然后 walk panic 了，

1205
01:18:30,790 --> 01:18:32,050
如果你给它一个荒谬的指针。

1206
01:18:32,110 --> 01:18:36,350
所以，就像有人提到的，

1207
01:18:36,680 --> 01:18:41,210
我们不能用荒谬的指针来调用 walk ，

1208
01:18:42,970 --> 01:18:44,530
是什么， MAXVA 还是什么。

1209
01:18:46,440 --> 01:18:46,980
好的。

1210
01:18:47,570 --> 01:18:51,590
当然，我们完全有权返回错误

1211
01:18:51,590 --> 01:18:56,300
如果用户进程传递这个超出的指针。

1212
01:19:00,050 --> 01:19:02,900
好的，我希望现在可以通过。

1213
01:19:05,090 --> 01:19:06,710
我没有发现任何其他问题。

1214
01:19:09,600 --> 01:19:13,150
好了，有什么问题。

1215
01:19:16,490 --> 01:19:19,190
我想我的问题更宽泛，

1216
01:19:19,580 --> 01:19:23,870
当我们用小步走的时候，

1217
01:19:23,960 --> 01:19:29,710
我们在这里得到了随机的其他的 bug ，

1218
01:19:29,770 --> 01:19:32,770
如果我们从头开始做实验，

1219
01:19:32,800 --> 01:19:37,980
那么有那么多奇怪的 bug 不会让人迷惑吗，

1220
01:19:38,720 --> 01:19:41,450
你怎么，

1221
01:19:42,000 --> 01:19:44,850
你怎么知道是不是你写的东西有 bug ，

1222
01:19:44,880 --> 01:19:47,940
或者你没有，而是其余部分的 bug 。

1223
01:19:48,540 --> 01:19:50,310
我想我不能回答你的问题。

1224
01:19:51,980 --> 01:19:54,110
关于 bug 的可悲事实，

1225
01:19:54,110 --> 01:19:58,430
特别是对内核页面表做了一些有趣的事情而导致的错误，

1226
01:19:58,850 --> 01:20:03,700
就是每个 bug 都是不同的。

1227
01:20:04,500 --> 01:20:09,420
什么才是追踪漏洞的制胜策略，

1228
01:20:10,540 --> 01:20:13,180
这完全取决于 bug 的本质。

1229
01:20:15,330 --> 01:20:16,530
通常，

1230
01:20:16,620 --> 01:20:17,400
我不是，

1231
01:20:18,040 --> 01:20:19,480
我有一些，

1232
01:20:19,870 --> 01:20:21,610
我有一些策略，

1233
01:20:21,610 --> 01:20:24,580
有时有用，有时没用，

1234
01:20:25,160 --> 01:20:26,360
比如我坚信，

1235
01:20:26,360 --> 01:20:28,160
我将打印语句放入代码中，

1236
01:20:28,160 --> 01:20:32,270
以便收集信息或验证假设。

1237
01:20:34,720 --> 01:20:37,240
我经常会花时间看看代码，

1238
01:20:37,360 --> 01:20:41,650
只是为了给自己来点头脑风暴，

1239
01:20:41,650 --> 01:20:43,510
试着生成一些东西，

1240
01:20:43,510 --> 01:20:45,850
在这一点上可能出错的东西，

1241
01:20:46,330 --> 01:20:48,700
然后将打印语句放到[] panic 或其他地方，

1242
01:20:48,700 --> 01:20:55,270
试图排除各种猜测问题可能是什么东西。

1243
01:20:55,890 --> 01:20:57,480
另一种可能是，

1244
01:20:57,810 --> 01:21:00,690
你做了一些，你的代码起作用了，

1245
01:21:00,690 --> 01:21:02,580
或者没有显示这个错误之类的，

1246
01:21:02,850 --> 01:21:05,100
你知道半小时前你做了一些改变，

1247
01:21:05,100 --> 01:21:06,180
现在你有了一些 bug ，

1248
01:21:06,360 --> 01:21:07,560
另一种可能性是，

1249
01:21:07,560 --> 01:21:12,230
你可以返回到没有错误的代码版本，

1250
01:21:12,230 --> 01:21:15,050
然后一点一点地添加更改，直到错误出现。

1251
01:21:16,560 --> 01:21:17,580
现在，这些都是，

1252
01:21:17,610 --> 01:21:20,640
我不知道有什么策略总是奏效的，

1253
01:21:20,640 --> 01:21:22,230
或者甚至有超过一小部分的时间在工作。

1254
01:21:25,260 --> 01:21:28,260
但真相是你们在这堂课上学到的东西的一部分，

1255
01:21:28,290 --> 01:21:30,060
在学习操作系统的同时，

1256
01:21:30,630 --> 01:21:33,960
你正在获得编写和调试代码的经验。

1257
01:21:37,860 --> 01:21:39,060
抱歉，没有更多的帮助。

1258
01:21:42,950 --> 01:21:43,850
还有其他问题吗？

1259
01:21:52,650 --> 01:21:57,630
好了，我们快下课了。

1260
01:22:00,580 --> 01:22:01,900
我很乐意多说几句，

1261
01:22:02,790 --> 01:22:06,480
但是这节课的正式部分我们已经讲完了。

1262
01:22:10,930 --> 01:22:14,320
好的，我们星期三见。

1263
01:22:15,390 --> 01:22:17,160
哦，抱歉，我还有另一个问题，

1264
01:22:17,190 --> 01:22:24,340
当我们第一次看到写入错误时，

1265
01:22:24,460 --> 01:22:29,920
之后我们也看到了对于 shell 非法指令的错误，

1266
01:22:30,100 --> 01:22:32,860
然后是初始化过程的一些东西，

1267
01:22:33,510 --> 01:22:34,320
那是什么。

1268
01:22:39,620 --> 01:22:48,480
好的，我没有一个想法。

1269
01:22:48,600 --> 01:22:53,700
初始化进程，我认为不会与任何东西共享页面。

1270
01:22:55,090 --> 01:22:57,460
我只是不知道，很抱歉。

1271
01:22:58,070 --> 01:22:58,520
我们可以。

1272
01:23:01,890 --> 01:23:02,790
我不得不后退一步，

1273
01:23:02,790 --> 01:23:04,050
这发生得很早，

1274
01:23:04,050 --> 01:23:05,280
当我做实验的时候，

1275
01:23:05,310 --> 01:23:07,410
我们只需要复制页表，其他什么都不用。

1276
01:23:07,410 --> 01:23:07,920
是的。

1277
01:23:08,440 --> 01:23:13,300
我想它是，比如 scause f 对于 shell ，

1278
01:23:13,420 --> 01:23:20,650
我想可能是 scause c 对于 init 进程。

1279
01:23:21,810 --> 01:23:23,190
好的，让我看看，

1280
01:23:23,190 --> 01:23:27,360
如果你是对的，让我们来看看，我们可以。

1281
01:23:32,270 --> 01:23:42,250
让我们从头开始重建实验，

1282
01:23:44,100 --> 01:23:45,420
克隆。

1283
01:24:07,740 --> 01:24:10,110
好的，我们刚才讲的这一点，

1284
01:24:11,260 --> 01:24:14,290
我刚刚修改了 uvmcopy 。

1285
01:24:16,700 --> 01:24:21,180
所以我们在这里不能做什么，

1286
01:24:21,180 --> 01:24:24,690
我们没有分配，也没有 memmove 。

1287
01:24:27,420 --> 01:24:29,520
但我们会，

1288
01:24:34,160 --> 01:24:39,340
我们会把 pa 传给 mappages ，

1289
01:24:39,340 --> 01:24:43,180
我想在我第一次跑任何东西的时候。

1290
01:24:43,800 --> 01:24:45,450
我想这就是当时的状态。

1291
01:24:46,050 --> 01:24:48,660
那是在我们做完 flag 之后，所以。

1292
01:24:48,660 --> 01:24:49,020
好的。

1293
01:24:55,490 --> 01:24:57,140
好的，让我们清楚。

1294
01:25:11,790 --> 01:25:12,750
看起来不错。

1295
01:25:35,420 --> 01:25:38,210
好的，我们有一个 c ，

1296
01:25:38,210 --> 01:25:41,450
让我们看看 c 指令页面错误，

1297
01:25:41,450 --> 01:25:44,900
好的，所以 scause 2 ，

1298
01:25:46,390 --> 01:25:50,350
我们认为一个共享的进程 id 2 ，

1299
01:25:50,350 --> 01:25:53,380
你说得对，是进程 id 1 。

1300
01:26:00,740 --> 01:26:03,170
我没有一个想法来解释为什么进程 id 1。

1301
01:26:05,510 --> 01:26:06,770
为什么失控了。

1302
01:26:07,490 --> 01:26:10,070
让我们看看它是做什么的。

1303
01:26:14,340 --> 01:26:15,060
我看看 init 。

1304
01:26:33,520 --> 01:26:34,960
好的，它执行这个 shell 。

1305
01:26:39,580 --> 01:26:42,310
我不知道。

1306
01:26:42,400 --> 01:26:45,220
好的，我有个主意，

1307
01:26:45,310 --> 01:26:48,070
进程 id 2 出现错误并退出。

1308
01:26:48,850 --> 01:26:49,450
所以你之后做了 fork 。

1309
01:26:49,450 --> 01:26:52,450
是的，那就是这个等待 init ，

1310
01:26:52,450 --> 01:26:55,660
它返回了，

1311
01:26:55,810 --> 01:26:58,030
让我们回到循环中，再次调用 fork ，

1312
01:26:58,030 --> 01:26:59,410
所以，在 fork 之后，

1313
01:26:59,560 --> 01:27:03,980
我们现在共享，或者取决于所有这些损坏代码。

1314
01:27:07,460 --> 01:27:08,690
哦，好的，我明白了。

1315
01:27:09,270 --> 01:27:11,220
哦，是的，那是非常令人困惑的。

1316
01:27:11,740 --> 01:27:15,040
哦，是的，这些错误完全是[]，

1317
01:27:15,070 --> 01:27:18,460
因为我们违反了各种直觉，

1318
01:27:18,460 --> 01:27:19,480
关于事情是如何运作的。

1319
01:27:21,120 --> 01:27:21,870
好的。

