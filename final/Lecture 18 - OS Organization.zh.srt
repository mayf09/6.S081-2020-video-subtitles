1
00:00:07,470 --> 00:00:10,890
好的，你们能听到我说话吗？
Alright, can you guys hear me?

2
00:00:13,190 --> 00:00:13,820
是的。
Yes.

3
00:00:14,750 --> 00:00:15,200
谢谢。
Thank you.

4
00:00:15,770 --> 00:00:18,800
好的，今天我主要想说的是微内核，
Alright, today I want to talk about talk mostly about micro kernels,

5
00:00:19,550 --> 00:00:22,820
首先，我们来了解一些背景，
but first a little bit of context

6
00:00:22,820 --> 00:00:25,210
以帮助解释
to sort of help explain

7
00:00:25,210 --> 00:00:28,210
为什么人们一开始会探索微内核，
why people explored micro kernels in the first place,

8
00:00:28,570 --> 00:00:33,370
人们获得微内核，
this people got the micro kernels

9
00:00:33,370 --> 00:00:38,980
试着广泛地思考内核应该做什么，
by trying to think about more broadly about what kernels should actually do,

10
00:00:39,010 --> 00:00:40,720
就像我们在 xv6 中，
like we've you know with xv6,

11
00:00:40,720 --> 00:00:43,660
某种程度上，做 Unix 所做的事情，
is sort of does the things that Unix does

12
00:00:43,660 --> 00:00:48,020
我们采用了这组抽象概念和系统调用，
and we kind of take that set of abstractions and system calls

13
00:00:48,020 --> 00:00:50,840
并保留了内核中的设施，
and keep sort of facilities inside the kernels,

14
00:00:50,840 --> 00:00:54,950
理所当然是我们试图设计的目标，
kind of for granted is the target of what we're trying to design,

15
00:00:54,950 --> 00:00:58,210
但是完全值得怀疑，
but it's totally worth wondering,

16
00:00:58,240 --> 00:01:00,370
天哪，内核首先应该做什么，
gosh, what should a kernel do in the first place,

17
00:01:00,370 --> 00:01:04,880
也许是 xv6 或 Linux 所做的特定类型的事情，
maybe maybe the particular kind of stuff that xv6 or Linux does,

18
00:01:04,910 --> 00:01:07,130
这不是最好的答案，
it's not really the best answer,

19
00:01:07,160 --> 00:01:08,060
或者它是。
or maybe it is.

20
00:01:08,330 --> 00:01:12,260
当然，我们这里的处境有些危险，
And of course we're on somewhat treacherous ground here,

21
00:01:12,260 --> 00:01:14,180
因为现在我们，
because now we're we're,

22
00:01:14,270 --> 00:01:17,990
内核是一种为程序员的开发平台，
what kernels are is kind of a development platform for programmers,

23
00:01:18,170 --> 00:01:18,770
正如我们所知，
as we know,

24
00:01:18,770 --> 00:01:24,890
程序员，不同的人有非常不同的主观偏好，
programmers different people have very different sort of subjective preferences

25
00:01:24,890 --> 00:01:28,100
他们喜欢在什么样的基础设施上编程。
about what kind of infrastructure they like to program on.

26
00:01:28,100 --> 00:01:32,380
所以我们不一定要期待一个最好的答案，
So we can't necessarily expect a single best answer,

27
00:01:33,270 --> 00:01:35,430
但是我们可以期望学到一些东西，
but we can expect to maybe learn something,

28
00:01:35,610 --> 00:01:37,200
或许可以取得一些进展，
and maybe make some progress

29
00:01:37,200 --> 00:01:39,510
通过努力想一想可能的答案。
by trying to think about what answers might be.

30
00:01:40,620 --> 00:01:41,610
所以首先，
So first of all,

31
00:01:41,640 --> 00:01:46,500
让我试着明确传统的方法，
let me try to crystallize what the traditional approaches

32
00:01:46,500 --> 00:01:50,550
我们应该使用什么样的内核接口，
to what kind of kernel interfaces we ought to be using

33
00:01:50,760 --> 00:01:54,960
Linux ， Unix 和 xv6 都是例子，
and Linux and Unix and xv6 are all examples of,

34
00:01:55,400 --> 00:02:00,410
我个人所说的传统设计方法的例子，
of what I personally call a traditional design approach,

35
00:02:00,440 --> 00:02:02,240
但是用另一个词来形容它，
but another word for it,

36
00:02:02,240 --> 00:02:04,550
那是一种概括，
that kind of summarizes,

37
00:02:05,160 --> 00:02:07,740
这种方法最终像是宏大而单一的。
but this approach has ended up like is monolithic.

38
00:02:13,510 --> 00:02:14,290
宏大而单一的。
Monolithic.

39
00:02:14,320 --> 00:02:19,970
这意味着内核是一个单一的大程序，
And what that means is that the kernel is a single big program,

40
00:02:19,970 --> 00:02:21,650
它可以做各种各样的事情，
that does all kinds of things,

41
00:02:21,830 --> 00:02:23,450
都在同一个程序内。
all within the same program.

42
00:02:25,470 --> 00:02:27,840
事实上，这确实反映了
And indeed this really reflects

43
00:02:27,840 --> 00:02:30,990
人们对内核应该做什么的想法，
the way people thought about what kernels ought to be doing

44
00:02:31,050 --> 00:02:35,730
像 Linux 这样的内核的一个特点是，
a real hallmark of kernels like Linux is

45
00:02:35,730 --> 00:02:40,470
它们提供了强大的抽象，
that they have, they provide powerful abstractions,

46
00:02:40,560 --> 00:02:43,620
他们选择像文件系统这样的东西，
you know they choose things like file systems

47
00:02:43,620 --> 00:02:45,990
这是一个复杂的项目，
and which is really a complicated item,

48
00:02:46,480 --> 00:02:48,370
它们提供文件系统，
and they present file systems

49
00:02:48,370 --> 00:02:52,570
文件、目录和文件描述符作为它们的接口，
and files and directories and file descriptors as their interface,

50
00:02:52,570 --> 00:02:58,450
而不是将磁盘硬件作为它们与应用程序的接口，
rather than for example presenting disk hardware as their interface to applications,

51
00:02:58,480 --> 00:03:03,310
所以，使用强大的抽象，
so, and using presenting powerful abstractions

52
00:03:03,310 --> 00:03:05,950
而不是非常低级别的抽象有一些很大的优势，
instead of very low-level abstractions has some big advantages,

53
00:03:06,220 --> 00:03:11,410
宏内核通常有一种很大的抽象，
monolithic kernels often have a sort of big abstractions,

54
00:03:17,150 --> 00:03:19,890
比如，文件系统。
like, file, the file system.

55
00:03:21,180 --> 00:03:22,590
大的抽象的一个优点是
One advantage of big abstract is

56
00:03:22,590 --> 00:03:26,310
它们通常是可移植的文件和目录，
that they're often portable of files and directories,

57
00:03:26,310 --> 00:03:29,940
你可以在所有类型的存储上实现文件和目录，
you can implement files and directories on all kinds of storage

58
00:03:30,810 --> 00:03:33,810
你可以使用文件和目录，
and file you can use files and directories,

59
00:03:33,810 --> 00:03:37,500
而不必担心运行的磁盘的品牌，
[] having to worry about what brand of disk drive is running on

60
00:03:37,500 --> 00:03:39,780
或者它可能是固态硬盘而不是硬盘，
or maybe it's an ssd instead of a hard drive,

61
00:03:39,780 --> 00:03:41,340
或者它可能是一个网络文件系统，
or maybe it's a network file system

62
00:03:41,340 --> 00:03:42,450
所有的接口都是一样的，
and all its the same interface,

63
00:03:42,450 --> 00:03:46,320
因为文件系统接口非常抽象。
because the file system interface is pretty high level pretty abstract.

64
00:03:46,530 --> 00:03:49,000
所以，这样做的一个好处是，
So, an advantage of this is

65
00:03:49,000 --> 00:03:51,880
获得可移植性的方法，
that the way to get portability,

66
00:03:52,520 --> 00:03:56,000
编写应用程序并使其在各种不同的硬件上运行，
write an application and have it run on all kinds of different hardware

67
00:03:56,000 --> 00:03:58,880
而不必修改应用程序。
without having to modify the application.

68
00:04:00,150 --> 00:04:01,560
另一个例子是，
Another example of this is that

69
00:04:01,860 --> 00:04:07,500
Unix Linux 提供了地址空间抽象。
Unix Linux provides an address space abstraction

70
00:04:07,500 --> 00:04:10,140
而不是提供一些东西，
rather than providing something that's likes,

71
00:04:10,230 --> 00:04:12,810
而不是提供对 MMU 硬件的直接访问，
rather than providing direct access to the MMU hardware

72
00:04:13,260 --> 00:04:16,710
对于可移植性有用，
and that's useful for portability

73
00:04:16,710 --> 00:04:18,840
并且对应用程序隐藏了复杂性。
and sort of hide complexity from applications.

74
00:04:20,440 --> 00:04:24,970
所以，这些强大的抽象的另一大优势，
So another big advantage of these powerful abstractions,

75
00:04:24,970 --> 00:04:27,730
它们往往对应用程序隐藏了复杂性。
they tend to hide complexity from applications.

76
00:04:30,690 --> 00:04:36,180
比如 xv6 提供的文件描述符接口，
The, so for example the file descriptor interface that xv6 provides,

77
00:04:36,180 --> 00:04:37,350
它是非常简单的接口，
it's very simple interface,

78
00:04:37,350 --> 00:04:39,990
但你只需要读写文件描述符，
but you just read and write on file descriptors,

79
00:04:39,990 --> 00:04:41,010
再简单不过了，
couldn't get much simpler,

80
00:04:41,100 --> 00:04:43,470
但是在它的背后是非常复杂的代码，
but behind it is very complicated code

81
00:04:43,470 --> 00:04:48,150
对于读写磁盘上的文件系统。
for actually reading and writing a disk, the file system on disk.

82
00:04:50,670 --> 00:04:51,840
这对程序员来说是件好事，
And that's nice for programmers,

83
00:04:51,840 --> 00:04:53,760
但它会让内核变得很大很复杂，
but it makes for a big complex kernel,

84
00:04:54,930 --> 00:04:59,340
这些大的抽象还帮助内核管理和共享资源，
these big abstractions also help the kernel manage and share resources,

85
00:04:59,340 --> 00:05:02,520
我们已经委托给内核的事情，比如内存管理，
we've delegated to the kernel things, like memory management,

86
00:05:02,520 --> 00:05:04,680
内核跟踪哪些内存是空闲的，
the kernel keeps track of what memories free,

87
00:05:04,800 --> 00:05:09,270
类似地，内核跟踪磁盘的哪些部分是空闲的，
we similarly the kernel keeps track of what parts of the disk are free,

88
00:05:09,270 --> 00:05:11,070
当前磁盘的哪些部分在使用。
in what parts of the disk current current use.

89
00:05:11,160 --> 00:05:12,780
所以程序员们不用考虑它，
So programmers don't get to think about it,

90
00:05:13,200 --> 00:05:15,660
再一次，它简化了程序，
and that again, it simplifies programs,

91
00:05:15,660 --> 00:05:18,360
它甚至还有助于增强健壮性和安全性，
it also helps with robustness and security even,

92
00:05:19,140 --> 00:05:22,950
因为如果允许程序决定磁盘的哪些部分是空闲的，
because if programs are allowed to decide what parts of the disk are free or not,

93
00:05:22,980 --> 00:05:26,010
那么也许一个程序可以使用
then maybe one program could use

94
00:05:26,010 --> 00:05:28,470
另一个程序已经在使用的磁盘的一部分。
a part of the disk that's already being used by another program.

95
00:05:30,210 --> 00:05:34,290
所以实际上，内核负责资源管理，
So the fact that the kernel is in charge of resource management,

96
00:05:36,980 --> 00:05:39,230
帮助共享并帮助确保安全，
helps with sharing and helps with security,

97
00:05:39,500 --> 00:05:45,530
但这也是某种程度上导致内核变大。
but again it's a force that sort of causes the kernel to be big.

98
00:05:49,380 --> 00:05:49,980
所以不管怎样，
So anyway,

99
00:05:49,980 --> 00:05:54,900
让内核负责所有这些有趣的抽象，
so having the kernel being charge of all these sort of juicy abstractions,

100
00:05:54,900 --> 00:05:58,160
即使它们只有简单的接口，
that even if they have simple interfaces,

101
00:05:58,190 --> 00:05:59,690
里面有很多复杂的东西，
have a lot of complexity inside,

102
00:05:59,720 --> 00:06:05,000
让内核变成又大又复杂的东西。
have let kernels to be big and complex items.

103
00:06:05,840 --> 00:06:09,350
而这种整体式设计的另一个方面是，
And another aspect of this monolithic design approaches,

104
00:06:09,350 --> 00:06:11,780
因为这都是一个程序，
that because it's all one program,

105
00:06:11,840 --> 00:06:13,490
所有不同的内核子系统，
all the different kernel subsystems,

106
00:06:13,490 --> 00:06:17,210
比如文件系统，内存分配器，调度器以及虚拟内存，
like the file system and the memory allocator and scheduler and virtual memories,

107
00:06:17,210 --> 00:06:19,430
它们都是一个大的程序的一部分，
they're all part of one big integrated program,

108
00:06:19,580 --> 00:06:22,430
这意味着它们可以窥探彼此的数据结构，
it means that they can peer into each others data structures,

109
00:06:22,430 --> 00:06:28,460
所以，这往往会使设施的实施变得更容易，
and so that's just tended to make it much easier to implement facilities,

110
00:06:28,460 --> 00:06:31,040
它在某种程度上是不止一个的一部分，
that are sort of parts of more than one

111
00:06:31,400 --> 00:06:35,510
或者你认为不止一种类型的模块或子系统，
or what you might think of as more than one kind of module or subsystem,

112
00:06:35,510 --> 00:06:38,840
比如，像 exec 这样的系统调用，
so for example a system call like exec,

113
00:06:39,620 --> 00:06:41,930
exec 深入文件系统，
exec has its fingers deeply into file system,

114
00:06:41,930 --> 00:06:44,960
因为它读取磁盘的二进制映像，
because it's reading binary images of the disk

115
00:06:44,960 --> 00:06:46,250
以加载内存，
in order to load the memory,

116
00:06:46,310 --> 00:06:51,590
它还深入到内存分配和虚拟内存分页系统，
it also has its fingers into the memory allocation and virtual memory paging system,

117
00:06:51,650 --> 00:06:54,380
因为它需要设置新进程的地址空间，
because it needs to set up the address space of the new process,

118
00:06:54,440 --> 00:06:55,310
但这真的很容易，
but it's really easy,

119
00:06:55,310 --> 00:06:58,310
在 xv6 或 Linux 中这样做没有问题，
there's no problem with doing that in xv6 or Linux,

120
00:06:58,310 --> 00:07:01,550
因为文件系统都在那里，
because both all the file system is right there,

121
00:07:01,760 --> 00:07:02,960
在同一个内核程序中，
in the same kernel program

122
00:07:02,960 --> 00:07:05,900
虚拟内存系统也是同一程序的一部分，
and the virtual memory system is also right there as part of the same program

123
00:07:07,010 --> 00:07:10,730
如果你以某种方式严格分割，
and if you somehow there was a rigid split

124
00:07:10,730 --> 00:07:12,770
在文件系统和虚拟内存系统之间，
between the file system and the virtual memory system,

125
00:07:12,860 --> 00:07:15,230
要实现像 exec 这样的东西会困难得多，
would be much harder to implement something like exec,

126
00:07:15,230 --> 00:07:18,080
它深入到这两个[]。
that has sort of fingers in both of these [].

127
00:07:18,320 --> 00:07:20,870
但是在宏系统中，只有一个大程序，
But in a monolithic system just one big program,

128
00:07:21,290 --> 00:07:23,060
就容易多了。
it's much easier.

129
00:07:24,090 --> 00:07:28,140
另一件事情让实现软件
Another thing that makes implementing software

130
00:07:28,140 --> 00:07:31,290
在 xv6 或 Linux 这样的宏内核中更简单的是，
inside a monolithic kernel like xv6 or Linux easy is that

131
00:07:31,320 --> 00:07:35,850
所有代码都以完全硬件权限运行，
all the code runs with full hardware privileges,

132
00:07:35,850 --> 00:07:38,910
比如，所有 xv6 都在管理员模式下运行，
all xv6 runs in supervisor mode for example,

133
00:07:39,120 --> 00:07:42,570
这意味着没有限制，没有恼人，
which means there's no limits there's no irritating,

134
00:07:42,870 --> 00:07:45,450
你不能写那段内存，
oh, you can't you know me to write that memory here,

135
00:07:45,450 --> 00:07:46,950
因为你没有足够的权限，
because you don't have enough privilege,

136
00:07:47,160 --> 00:07:50,980
所有内核代码都以某种最大权限运行，
all the kernel code runs with sort of maximum privilege,

137
00:07:52,710 --> 00:07:56,430
像 Linux 这样的操作系统也是如此。
and you know the same is true of operating systems like Linux.

138
00:07:57,770 --> 00:08:02,360
所以这个设计策略，
So, this design strategy,

139
00:08:02,360 --> 00:08:05,030
对于内核开发者来说是非常方便的，
it's very convenient for kernel developers

140
00:08:05,090 --> 00:08:08,810
它使得构建这些大型抽象变得很容易，
and it's made it easy to build these big abstractions

141
00:08:08,810 --> 00:08:12,770
这对应用程序开发人员来说是方便的，
which are convenient for application developers,

142
00:08:12,800 --> 00:08:17,030
然而，这里也有一些批评，
however, there's also a certain amount to criticize

143
00:08:17,030 --> 00:08:20,780
对于传统的宏方法。
with the monolithic, traditional monolithic approach.

144
00:08:23,300 --> 00:08:25,580
这是开始的动力之一，
And this is starting to be part of the motivation

145
00:08:25,580 --> 00:08:32,080
来研究其他架构，比如微内核，
for looking at other architectures, like micro kernels,

146
00:08:32,500 --> 00:08:33,250
所以你可能会问，
so you might ask,

147
00:08:33,250 --> 00:08:37,200
为什么不是宏内核。
why not monolithic kernels.

148
00:08:43,290 --> 00:08:47,640
其中之一就是它们又大又复杂，
So one is just that they're big and complex,

149
00:08:47,850 --> 00:08:52,620
所以任何 Linux 系统都取决于你是如何计算的，
so anything that's Linux is depending on how you count,

150
00:08:52,620 --> 00:08:58,260
Linux 在几十万到几百万行代码之间，
Linux somewhere between many hundreds of thousands and a few million lines of code

151
00:08:58,470 --> 00:09:01,650
人们利用了这个事实，
and people really do take advantage of the fact,

152
00:09:01,650 --> 00:09:04,560
Linux 的一部分可以查看其他部分的数据，
that one part of Linux can sort of look at the data of another

153
00:09:04,560 --> 00:09:06,090
这使得编程变得更容易，
and that makes the programming easier,

154
00:09:06,120 --> 00:09:11,670
但这也使得代码之间存在大量的互连和相互关系，
but it also makes there'd be a lot of interconnections and interrelationships between code

155
00:09:11,670 --> 00:09:13,980
所以，它会是一个挑战，
and so it can be a bit challenging

156
00:09:13,980 --> 00:09:15,870
有时查看 Linux 内核代码，
sometimes to look at the Linux kernel code

157
00:09:15,870 --> 00:09:16,830
找出它的目的是什么，
and figure out what it's up to

158
00:09:17,460 --> 00:09:21,390
任何时候，当你得到大程序，
and anytime you get big programs,

159
00:09:21,390 --> 00:09:24,120
特别是那些复杂结构的程序，
especially ones that are a complex structure,

160
00:09:24,120 --> 00:09:25,140
你会有 bug ，
you get bugs,

161
00:09:26,670 --> 00:09:30,090
操作系统内核也不例外，
and operating system kernels are no exceptions

162
00:09:30,090 --> 00:09:32,430
多年来，它们有各种各样的 bug ，
and over the years, they've had all kinds of bugs,

163
00:09:33,030 --> 00:09:37,320
包括可用于安全目的的漏洞。
including bugs that are exploitable for security.

164
00:09:40,050 --> 00:09:47,640
所以，这是一系列麻烦的关系，
So, so this is sort of trouble set of relationships,

165
00:09:47,670 --> 00:09:49,260
如果你允许内核的大模型，
if you allow a big model of the kernel,

166
00:09:49,440 --> 00:09:50,700
几乎可以肯定的是，
you almost certainly,

167
00:09:50,730 --> 00:09:54,600
无法避免 bug 和可利用的安全问题，
can't avoid bugs and exploitable security problems

168
00:09:54,990 --> 00:09:57,840
这是一个真正的问题。
and that's a real I mean there really is a problem.

169
00:10:00,490 --> 00:10:06,560
人们对宏内核可能并不完全满意的另一个原因是，
Another reason why people are maybe not entirely happy with monolithic kernels is that,

170
00:10:06,710 --> 00:10:12,380
随着时间的推移，它们往往只会增长，具有所有想要的功能，
they tend to just grow with all desirable features over time

171
00:10:12,530 --> 00:10:15,710
所以 Linux 被用来做各种不同的事情，
and so you know Linux is used for all kinds of different things,

172
00:10:15,710 --> 00:10:19,430
从电话听筒到桌面工作站，
from telephone handsets to a desktop workstations

173
00:10:19,430 --> 00:10:23,690
从笔记本电脑，平板电脑到互联网上的服务器，
and laptops to tablets to servers on the Internet,

174
00:10:23,690 --> 00:10:24,650
再到路由器，
to routers

175
00:10:25,790 --> 00:10:27,290
这导致了 Linux ，
and that's caused Linux,

176
00:10:27,290 --> 00:10:29,900
Linux 可以支持所有这些东西，这真是太棒了，
it's fantastic that Linux can support all those things,

177
00:10:29,960 --> 00:10:31,940
但它使它变得非常笼统，
but it has caused it to be very general,

178
00:10:32,000 --> 00:10:34,940
它支持很多不同的东西，
it has support in there for many many different things

179
00:10:34,970 --> 00:10:36,950
任何应用程序，
and any one application

180
00:10:36,950 --> 00:10:38,270
比如我运行 web 服务器，
like me running my web servers,

181
00:10:38,270 --> 00:10:43,730
不需要比如 Linux 非常复杂的声卡支持，
unlikely to need for example Linux is very sophisticated sound card support,

182
00:10:44,030 --> 00:10:45,950
所以这里有大量的东西，
so there's just a huge amount of stuff,

183
00:10:45,950 --> 00:10:50,050
是为了让 Linux 成为通用的，
that's there for to allow Linux to be general purpose,

184
00:10:50,230 --> 00:10:51,820
这很好，
which is good,

185
00:10:52,120 --> 00:10:54,610
但也有一个担心，
but there's a worry,

186
00:10:54,610 --> 00:10:58,540
一般用途往往意味着缓慢，
that general purpose is going to tend to mean slow,

187
00:10:58,990 --> 00:11:01,900
可能对各种不同的东西都有好处，
that you know may be good for all kinds of different things,

188
00:11:01,900 --> 00:11:05,350
但可能对任何特定的东西都不是最优的。
but maybe not optimum for anything in particular.

189
00:11:06,160 --> 00:11:07,900
所以很难，
so it's very hard to,

190
00:11:08,500 --> 00:11:10,750
当你试着做一些非常快的东西，
you know when you're trying to make something really fast,

191
00:11:10,750 --> 00:11:13,960
最好让它只做一两件事，
it's great to have it just only do one or two things,

192
00:11:13,960 --> 00:11:16,630
你可以专注于优化单个代码路径，
you can focus on optimizing a single code path,

193
00:11:17,440 --> 00:11:20,470
但是如果你的软件需要做上千种不同的事情中的一个，
but if your software needs to do any one of a thousand different things,

194
00:11:20,470 --> 00:11:22,750
专注优化要困难得多。
it's much harder to have focused optimization.

195
00:11:25,090 --> 00:11:27,580
这就是， Linux 不一定很慢，
So this is, Linux is not necessarily slow,

196
00:11:27,580 --> 00:11:29,170
但是，你可能会想，
but it's you know you might wonder,

197
00:11:29,170 --> 00:11:31,840
它是否像可能的那样快，
if it's really as fast as it could possibly be

198
00:11:31,840 --> 00:11:33,520
对于任何给定的情况。
for any given situation.

199
00:11:35,210 --> 00:11:36,380
所以如果你仔细想想，
So if you think about it,

200
00:11:36,380 --> 00:11:37,370
你如何考虑，
how do you think,

201
00:11:37,370 --> 00:11:40,970
如果你考虑 Linux 或 xv6 中几乎所有东西，
if you think about almost anything in Linux or xv6,

202
00:11:41,510 --> 00:11:44,420
你可能会想，它是否真的需要做它所做的每一件事，
you know you may wonder whether it really needs to do everything it does,

203
00:11:44,420 --> 00:11:47,600
比如，如果你通过管道写入单个字节，
so, for example if you write a single byte over a pipe

204
00:11:47,660 --> 00:11:49,070
从一个进程到另一个进程，
from one process to another,

205
00:11:49,430 --> 00:11:51,770
但是有很多指令会被执行，
but there's a lot of instructions that get executed,

206
00:11:51,950 --> 00:11:54,740
即使是 xv6 ，它是一个简单的内核，
even xv6 which is a simple kernel, right,

207
00:11:54,740 --> 00:11:58,100
有缓冲，有锁，
there's buffering, you know there's locking,

208
00:11:58,160 --> 00:12:00,170
有睡眠和唤醒，
there's could be a sleep and wakeup

209
00:12:00,320 --> 00:12:01,730
在管道读写时，
during a pipe read and write,

210
00:12:01,730 --> 00:12:02,840
可能有调度器，
there's maybe a scheduler

211
00:12:02,840 --> 00:12:05,450
可能调用上下文切换，
in may called the scheduler context switch,

212
00:12:05,660 --> 00:12:09,300
有很多东西可能不一定需要，
has a lot of stuff that's maybe not necessarily,

213
00:12:09,750 --> 00:12:12,630
需要的绝对最小的，
the absolute minimum that would be required

214
00:12:12,630 --> 00:12:15,360
将一个字节从一个进程移动到另一个进程。
to move a byte from one process to another.

215
00:12:17,940 --> 00:12:21,240
这些大内核的另一个潜在问题是，
Another potential problem with these big kernels is that,

216
00:12:21,330 --> 00:12:23,620
因为它们太大了，
they, because they're so big

217
00:12:23,620 --> 00:12:29,590
而且它们故意去掉一些非常复杂的抽象，
and they sort of intentionally bite off some very sophisticated abstractions,

218
00:12:29,710 --> 00:12:31,390
他们有很多设计决策，
they tend to have a lot of design decisions,

219
00:12:31,390 --> 00:12:32,830
在内核中。
kind of baked into the kernel.

220
00:12:34,700 --> 00:12:37,850
所以，在某些方面你不能，
So, you know in ways that you can't,

221
00:12:37,880 --> 00:12:38,930
即使你不同意他们的观点，
even if you disagree with them,

222
00:12:38,930 --> 00:12:42,770
你也不能，应用程序只能接受它。
you can't really you know [] applications just have to live with it.

223
00:12:43,010 --> 00:12:48,980
所以，相反的，
So, you know as a as opposed to,

224
00:12:48,980 --> 00:12:49,970
在某个幻想世界里，
in some fantasy world,

225
00:12:49,970 --> 00:12:52,880
也许应用程序可以做出更多的决定，
maybe applications could make a lot more of the decisions,

226
00:12:52,880 --> 00:12:55,430
所以有一些例子，
so you know some examples of things where

227
00:12:57,660 --> 00:13:03,930
你可能会对 API 的设计方式感到失望，
you may just you may be bummed out by the way the API designed,

228
00:13:04,020 --> 00:13:06,570
比如，在 Unix 中，
for example in a Unix,

229
00:13:06,570 --> 00:13:08,970
你可以等待自己的子进程，
you can wait for a process your own children,

230
00:13:08,970 --> 00:13:10,560
如果你 fork ，可以等待你的子进程，
if you fork, you can wait for your children,

231
00:13:10,560 --> 00:13:12,210
但你不能等待其他进程，
but you can't wait for some other process

232
00:13:12,210 --> 00:13:15,780
也许你想等待一个孙子进程或一个无关的进程，
and maybe you want to wait for a grandchild or an unrelated process,

233
00:13:15,780 --> 00:13:16,920
但这不是一个选择，
but that's just not an option,

234
00:13:17,040 --> 00:13:18,450
它不是这样工作的，
it's just not the way things work,

235
00:13:18,630 --> 00:13:20,250
即使这对你来说很方便，
even if it would be convenient for you,

236
00:13:21,360 --> 00:13:26,520
也许您想要更改另一个进程地址空间的设置方式，
maybe you want to change the way another processes address space is set up,

237
00:13:26,550 --> 00:13:27,960
也许可以调用和映射
you know maybe call and map on

238
00:13:27,960 --> 00:13:30,840
你控制的另一个进程，
[] of another process that you're controlling,

239
00:13:30,840 --> 00:13:33,110
但是，这也不是一个选择，
but again, that's just not an option,

240
00:13:33,110 --> 00:13:35,540
你可以映射修改自己的地址空间，
you can map change your own address space,

241
00:13:35,540 --> 00:13:38,180
但不能修改其他进程的地址空间，
but not changes other process address space,

242
00:13:38,330 --> 00:13:43,160
可能是数据库，并且磁盘上有 B 树索引，
maybe a database and you have B-tree indexes on the disk

243
00:13:43,550 --> 00:13:47,630
你可能知道很多关于在磁盘上布局 B 树的最快方法，
and you may know a lot about it the fastest way to layout B-tree on a disk,

244
00:13:47,900 --> 00:13:50,300
但是如果你使用文件系统读写文件，
but if you're reading and writing files with the file system,

245
00:13:50,360 --> 00:13:54,050
文件系统不知道你是在写入 B 树，
the file system has no idea that you're actually writing a B-tree

246
00:13:54,050 --> 00:13:58,790
也不知道应该如何在磁盘上布局 B 树以实现最快的访问。
or how a B-tree ought to be laid out on a disk for fastest access.

247
00:13:59,190 --> 00:14:01,230
所以如果你的数据库有点麻烦，
And so if your database you're going to be kind of bummed,

248
00:14:01,230 --> 00:14:04,470
也许你很高兴有这个文件系统供你支配，
you know maybe you're happy that you have this file system at your disposal,

249
00:14:04,560 --> 00:14:06,360
但它并没有真正做你想做的事。
but it doesn't really do what you want to do.

250
00:14:07,340 --> 00:14:12,260
这就是设计决策到大内核中的感觉。
That's the sense in which a design decisions are often baked into big kernels.

251
00:14:13,290 --> 00:14:17,880
最后，还有一种特殊的问题，
And finally, a specific sort of issue that,

252
00:14:20,920 --> 00:14:24,880
所以它可能是在 20 世纪 90 年代出现的，
so it came up in a big way in the 1990s probably,

253
00:14:25,000 --> 00:14:27,130
一种可扩展性的概念，
a notion of extensibility,

254
00:14:29,950 --> 00:14:34,000
让程序能够在运行时修改内核，
that it might be desirable for programs to be able to change the kernel on the fly,

255
00:14:34,030 --> 00:14:35,800
能够下载内核中的新代码，
to be able to download new code in the kernel

256
00:14:35,800 --> 00:14:37,420
或者改变它的运作方式之类的，
or change the way it operates or something,

257
00:14:37,720 --> 00:14:40,840
为了能让数据库
in order to do things like have databases

258
00:14:40,840 --> 00:14:44,470
能够控制磁盘上的数据布局。
able to control the layout of data on the disk.

259
00:14:45,320 --> 00:14:50,330
至少在过去的几十年里，
At least in decades past,

260
00:14:50,390 --> 00:14:54,970
宏内核没有任何特定的功能，
monolithic kernels tended not to, to have any particular features,

261
00:14:54,970 --> 00:14:56,830
来帮助这种扩展能力，
that help with this kind of extensive ability,

262
00:14:56,830 --> 00:14:58,840
你只是困在内核中。
you're just stuck with whatever the kernel did.

263
00:15:01,490 --> 00:15:02,780
好的。
Okay.

264
00:15:03,430 --> 00:15:07,290
所以，这些都是人们考虑的一些问题，
So, these were sort of problems in the back of people's minds,

265
00:15:07,290 --> 00:15:11,080
让他们思考其他的，
that let them to think about other kinds of,

266
00:15:11,290 --> 00:15:14,800
操作系统设计其他体系结构的方式，
other ways of designing other architectures for operating systems

267
00:15:15,040 --> 00:15:18,710
而且有很多想法，
and and there were a number of, a number of ideas,

268
00:15:18,710 --> 00:15:20,570
有些与人们追求的截然不同，
some quite radically different that people pursued,

269
00:15:20,780 --> 00:15:22,400
我们要谈的是其中一个，
we're going to talk about one of them,

270
00:15:22,820 --> 00:15:25,640
今天特别受欢迎的一个，
particularly popular one today

271
00:15:25,880 --> 00:15:27,440
这就是微内核的想法。
and that's the idea of micro kernels.

272
00:15:31,330 --> 00:15:34,120
微内核，很多想法，
Micro kernels, although many of the ideas

273
00:15:34,120 --> 00:15:38,180
或者回到计算机历史的开始，
or go back to the beginning of computer history,

274
00:15:39,020 --> 00:15:43,160
它们变成一种热门的研究课题，
they became a sort of hot research topic,

275
00:15:43,160 --> 00:15:46,100
可能从 20 世纪 80 年代中后期开始。
starting in maybe the mid to late 1980s.

276
00:15:46,550 --> 00:15:49,580
最重要的想法是，
And the big idea,

277
00:15:52,710 --> 00:15:56,280
顺便说一下，微内核这个词
so micro kernel this this word, by the way

278
00:15:56,280 --> 00:15:58,650
指的是一种一般的方法，一个概念，
refers to a sort of general approach, a concept,

279
00:15:58,650 --> 00:16:00,840
它不是任何特定的东西，
it doesn't refer to any specific artifact,

280
00:16:00,840 --> 00:16:05,400
有许多人设计和构建操作系统，
there were many people who designed and built operating systems

281
00:16:05,400 --> 00:16:09,030
根据微内核的一般方案，
that followed the general sort of plan for micro kernels,

282
00:16:09,030 --> 00:16:10,560
但是，这些项目中的每一个，
but you know each of these projects,

283
00:16:10,770 --> 00:16:13,950
最终设计和操作系统都可能有很大的不同。
ended up designing and operating systems may be quite different from the others.

284
00:16:14,070 --> 00:16:18,790
所以关键的想法是微小的内核，
So the key idea was the tiny kernel,

285
00:16:22,540 --> 00:16:29,140
仅支持 IPC 进程间通信，
that supported just IPC or inter process communication,

286
00:16:29,320 --> 00:16:33,970
以及某种线程或任务的概念。
and some sort of notion of a threads or tasks.

287
00:16:35,620 --> 00:16:37,990
所以，你有一个内核，它为你提供
So you have a kernel that provides you

288
00:16:37,990 --> 00:16:40,600
一种类似于抽象的进程的概念，
a notion of sort of process like abstraction

289
00:16:40,600 --> 00:16:42,730
进程之间可以互相通信，
and away for processes to communicate with each other,

290
00:16:42,730 --> 00:16:44,830
通过这种进程间通信，
with this inter process communication

291
00:16:44,890 --> 00:16:46,450
没有其他的了。
and nothing else.

292
00:16:46,480 --> 00:16:48,220
其他你可能想做的事，
And everything else you might want to do,

293
00:16:48,220 --> 00:16:50,230
比如要实现的文件系统，
like a file system you'd implement,

294
00:16:50,320 --> 00:16:53,440
作为进程或任务在用户级代码，
as a process as a task as a user level code,

295
00:16:53,470 --> 00:16:54,790
而不是在内核中。
not in the kernel at all.

296
00:16:55,850 --> 00:16:57,080
所以，这里的图，
So picture for that,

297
00:17:01,100 --> 00:17:05,030
现在我们使用 u 表示微内核，
maybe now we're going to use u for micro kernel,

298
00:17:05,090 --> 00:17:06,530
微内核在下面这里，
and the micro kernel down here

299
00:17:06,530 --> 00:17:08,870
在上面有用户空间进程，
and we got user space processes up here

300
00:17:08,870 --> 00:17:11,990
我们可能会运行所有常见的进程，
and we might have all the kind of usual processes run,

301
00:17:11,990 --> 00:17:16,380
也许要运行 vi ，我最喜欢的文本编辑器，
maybe we're gonna run vi, my favorite text editor,

302
00:17:16,380 --> 00:17:21,320
还有我的编译器，我的窗口系统。
and my my compiler, my windows system.

303
00:17:25,340 --> 00:17:27,470
但这里也像常用进程一样，
But also up here as usual processes,

304
00:17:27,470 --> 00:17:28,910
我们使用文件系统，
we're going to have the file system,

305
00:17:29,650 --> 00:17:32,620
就像用户空间中的服务器进程一样，
just as a server process in user space,

306
00:17:32,620 --> 00:17:35,440
也许我们会有一个磁盘驱动程序，
maybe we're going to have a disk driver,

307
00:17:36,180 --> 00:17:38,070
它们知道如何与我的磁盘硬件通信，
they know how to talk to my disk hardware,

308
00:17:38,310 --> 00:17:40,290
也许我们有一个网络堆栈，
maybe we have a network stack,

309
00:17:40,290 --> 00:17:47,790
它知道如何使用 TCP 与我的网卡交互，
that knows how to talk talk TCP to my network interface card,

310
00:17:48,360 --> 00:17:50,970
也许我们有一个用户级别的进程，
maybe we'll have a user level process,

311
00:17:50,970 --> 00:17:54,690
负责执行花哨的分页技巧，
that's in charge of doing fancy paging tricks,

312
00:17:54,720 --> 00:17:57,120
比如内存映射文件，
like memory mapped files

313
00:17:57,120 --> 00:17:59,910
或者可能实现写入时复制， fork 等东西。
or maybe implements copy-on-write fork or something.

314
00:18:01,560 --> 00:18:05,520
当我的文本编辑器需要读取文件时，
And when my text editor needs to read a file,

315
00:18:05,760 --> 00:18:07,200
它需要与文件系统交互，
it needs to talk the file system,

316
00:18:07,200 --> 00:18:18,390
所以，它通过 IPC 进程间通信发送一条消息，
and so it's gonna send a a message via IPC inter process communication,

317
00:18:19,010 --> 00:18:21,230
到文件系统服务器，
to the file system server,

318
00:18:21,530 --> 00:18:23,090
其中包含所有文件系统代码，
which has all the file system code,

319
00:18:23,090 --> 00:18:24,590
它是关于文件和目录，
it's about files and directories

320
00:18:24,590 --> 00:18:28,040
并且文件系统服务器代码可能需要与磁盘交互，
and file system server code may need to talk to the disk,

321
00:18:28,040 --> 00:18:31,070
所以它可能发送磁盘读取或写入，
so it might send another sort of disk read or write,

322
00:18:31,070 --> 00:18:33,560
另一个 IPC ，
so another IPC to,

323
00:18:33,560 --> 00:18:35,840
磁盘驱动以某种方式与硬件交互，
the disk driver which somehow talks this hardware,

324
00:18:36,350 --> 00:18:40,930
这个驱动程序可能返回一个磁盘块到文件服务器，
this driver may return you know a disk block to the file server

325
00:18:41,260 --> 00:18:42,220
在它完成它的事情之后，
after it does its thing,

326
00:18:42,220 --> 00:18:45,100
也许文件服务器最终再次返回你请求的数据，
maybe the file server finally returns the data you ask for again

327
00:18:45,100 --> 00:18:47,020
通过进程间通信消息，
by inter process communication messages,

328
00:18:47,350 --> 00:18:49,270
回到我的文本编辑器。
back to my text editor.

329
00:18:50,240 --> 00:18:53,870
但是这里需要注意的关键是，
But you know the the critical thing to notice here is that

330
00:18:54,650 --> 00:18:56,600
内核中唯一要做的就是，
the only stuff going down here in the kernel is

331
00:18:56,600 --> 00:19:01,190
支持这些进程、任务或线程，
support for these processes or tasks or threads,

332
00:19:02,130 --> 00:19:03,180
无论它们是什么，
whatever they might be

333
00:19:03,210 --> 00:19:08,400
支持进程间通信消息传递，没有其他的，
and support for the inter process communication message passing and nothing else,

334
00:19:08,400 --> 00:19:09,780
下面没有文件系统，
there's no file system down here,

335
00:19:09,780 --> 00:19:13,380
下面的内核中也没有设备驱动程序，
there's no device drivers necessarily down here in the kernel,

336
00:19:13,380 --> 00:19:15,180
这里没有网络堆栈，
there's no network stack,

337
00:19:15,510 --> 00:19:17,010
所有这些东西都在上面，
all that stuff is up here,

338
00:19:17,010 --> 00:19:20,970
或多或少都是普通的用户级进程。
as more or less ordinary user level processes.

339
00:19:21,790 --> 00:19:26,710
所以，它们会带来一个非常小的内核，
So they lead you to a very small kernel

340
00:19:26,710 --> 00:19:30,250
包含相对较少的代码可以优化，
with a relatively little code optimize,

341
00:19:30,250 --> 00:19:32,200
比如你可以优化 IPC ，
like you can optimize IPC

342
00:19:32,200 --> 00:19:33,460
没有太多其他的事情要做。
and there's not much else going on.

343
00:19:36,590 --> 00:19:39,920
所以这是我们要在剩下的这节课上讨论的图片，
And so this is the kind of picture we're going to talk about for the rest of the lecture

344
00:19:39,920 --> 00:19:42,710
让你们了解这件事的最终的情况。
and just give you a taste of where this ended up.

345
00:19:42,740 --> 00:19:47,300
实际上，今天仍在使用一种微内核，
There are actually still a micro kernels in use today,

346
00:19:47,300 --> 00:19:49,010
事实上， L4 微内核，
and indeed the L4 micro kernel

347
00:19:49,010 --> 00:19:52,730
是今天论文讨论的主题所使用的，
which is the topic of today's paper turns out to be used,

348
00:19:52,970 --> 00:19:56,810
有很多 L4 实例运行，
there's many instances many many instances of L4 running,

349
00:19:56,810 --> 00:19:59,000
因为它被用在很多手机里，
because it's used in a lot of cellphones

350
00:19:59,480 --> 00:20:02,630
在小型控制器上控制手机无线电，
in the little micro controllers that control the cell phone radios

351
00:20:02,900 --> 00:20:06,680
而且它也被用于最近的 iPhone ，
and it's also apparently used in recent iPhones

352
00:20:06,830 --> 00:20:13,580
作为 iPhone 上的专用 enclave 处理器上运行的操作系统，
as the operating system that runs on a special dedicated enclave processor in the iPhone,

353
00:20:13,580 --> 00:20:16,580
用于隐藏秘密的密钥。
that hides the secret cryptographic keys.

354
00:20:17,270 --> 00:20:18,620
所以，有很多嵌入式，
So there's a bunch of embedded

355
00:20:19,100 --> 00:20:21,410
微内核胜出
where these micro kernels have won out

356
00:20:21,410 --> 00:20:24,770
在小型嵌入式专用计算机系统中，
in little embedded specialized computer systems,

357
00:20:24,890 --> 00:20:26,360
不是笔记本，
not not laptops,

358
00:20:26,360 --> 00:20:32,320
而是专用于单一专门任务的计算机，
but a computer dedicated to single specialized tasks

359
00:20:32,350 --> 00:20:34,600
可能不需要 Linux 的复杂性，
where you may not need the complexity of Linux,

360
00:20:34,600 --> 00:20:36,220
但是你确实需要一些操作系统。
but you do need some operating system.

361
00:20:37,680 --> 00:20:38,430
另一件事，
And the other thing,

362
00:20:38,430 --> 00:20:43,200
微内核的另一种最终结果是，
that's the other sort of final result from micro kernels is that,

363
00:20:43,260 --> 00:20:49,530
用户级服务与其他程序通过 IPC 与它们交互，
the idea of user level services with with other programs talking to them with IPC,

364
00:20:49,710 --> 00:20:52,860
也已经进入了很多操作系统，
that also has made its way into a lot of operating systems,

365
00:20:52,860 --> 00:20:53,580
就像 Mac OS ，
like Mac OS,

366
00:20:53,580 --> 00:20:55,350
它正运行着与你交谈，
which running right now to talk to you,

367
00:20:55,560 --> 00:21:00,840
它既是一种普通的宏内核，
you know it's a sort of as well as being a kind of ordinary monolithic kernel,

368
00:21:00,870 --> 00:21:05,220
它还很好地支持用户级服务，
it also has good support for a user level services

369
00:21:05,220 --> 00:21:09,440
以及 Unix 进程之间与服务交互的 IPC ，
and IPC between Unix processes to talk to the service,

370
00:21:09,440 --> 00:21:16,470
所以，那个想法也是一个成功的想法，被广泛采用。
so, that idea also, was a successful idea and widely adopted.

371
00:21:17,550 --> 00:21:20,160
好的，这是基本架构，
Okay, so this is the basic architecture,

372
00:21:20,490 --> 00:21:25,380
我将继续谈论一些方式和原因，
I'm going to go on and talk about some ways and reasons

373
00:21:25,380 --> 00:21:26,550
为什么这个有吸引力，
why this might be attractive,

374
00:21:26,610 --> 00:21:29,520
但首先是高层次的问题，
but first are there any just kind of high-level questions about,

375
00:21:31,730 --> 00:21:33,200
微内核是什么。
what it is I mean by micro kernel.

376
00:21:38,950 --> 00:21:40,330
好的。
Okay.

377
00:21:42,700 --> 00:21:47,830
那么，人们希望的是什么，
So, what is it that people are hoping for,

378
00:21:50,450 --> 00:21:54,600
当他们开始构建微内核的时候。
when they started building micro micro kernels.

379
00:21:54,600 --> 00:21:57,690
所以，一个很大的动机，
So, one big motivation,

380
00:21:57,690 --> 00:21:59,670
尽管你不一定会看到它被写得很多，
although you wouldn't necessarily see it written down much,

381
00:21:59,670 --> 00:22:01,860
这只是一种审美。
it's just a sense of aesthetics, right.

382
00:22:01,890 --> 00:22:03,810
我想很多人都觉得
I think just a lot of people feel

383
00:22:03,810 --> 00:22:10,080
像 Linux 内核这样庞大复杂的单一程序，
that huge complicated a single programs like like Linux kernel

384
00:22:10,200 --> 00:22:11,460
并不是很优雅，
are just not very elegant,

385
00:22:11,640 --> 00:22:13,260
当然，我们可以构建系统，
that surely we can build something

386
00:22:13,260 --> 00:22:18,840
更小，更有针对性的设计，
that's much more much much smaller much more focused design,

387
00:22:18,840 --> 00:22:23,120
而不是一个巨大的有随机不同功能的[袋子]，
isn't such a huge [grab bag] of random different features,

388
00:22:23,780 --> 00:22:27,780
所以我觉得有一种强烈的审美，
so I think there was a strong sort of aesthetic feeling,

389
00:22:28,680 --> 00:22:30,720
我们当然可以做得比大内核更好。
surely we can do better than big kernels.

390
00:22:31,360 --> 00:22:36,220
但是还有其他更具体可以量化的东西，
But others are more specific things that you might be able to quantify

391
00:22:36,220 --> 00:22:45,290
或者更小的内核可能更安全，
or something a kernel that's small might be more secure, right,

392
00:22:45,680 --> 00:22:48,650
代码越少， bug 越少，
a few lines of code you have, probably fewer bugs you have,

393
00:22:49,010 --> 00:22:54,200
更少有人利用其中的 bug 来破坏安全，
less chance of somebody be able to exploit one of those bugs to break security,

394
00:22:54,620 --> 00:22:59,280
然后最极端的是，
and then the extreme of that,

395
00:22:59,930 --> 00:23:04,580
你可以想象操作系统可以证明是对的，
you could imagine operating system that's actually provable provably correct,

396
00:23:06,950 --> 00:23:08,810
有人可以写一份证明，
where somebody can sit down and write a proof,

397
00:23:08,810 --> 00:23:11,090
操作系统没有 bug ，
that the operating system has no bugs

398
00:23:11,090 --> 00:23:13,130
或者做它应该做的事，其他什么也不做。
or does exactly what it's supposed to do and nothing else.

399
00:23:13,910 --> 00:23:16,910
并且确实有一个，
And indeed there is at least one

400
00:23:17,760 --> 00:23:23,100
证明是正确的，证明是安全的操作系统，叫做 seL4 ，
verified, proved correct, proved secure operating system named seL4,

401
00:23:23,100 --> 00:23:27,330
它是 L4 微内核的众多后代之一，
which is one of the many descendants of the L4 micro kernel,

402
00:23:30,000 --> 00:23:31,440
今天的论文，
today's paper,

403
00:23:31,500 --> 00:23:33,330
人们知道，
but you really you know people know

404
00:23:33,330 --> 00:23:36,510
如何验证中小型程序，
how to verify small to medium sized programs,

405
00:23:36,510 --> 00:23:38,250
但他们不知道如何验证巨大的程序，
but they don't know how to verify huge programs

406
00:23:38,250 --> 00:23:40,110
除非微内核很小，
unless the fact that micro kernels are small,

407
00:23:40,320 --> 00:23:43,350
一种关键的因素，能够证明它们是正确的。
sort of critical ingredient and be able to prove their correct.

408
00:23:45,530 --> 00:23:48,320
你喜欢小的另一个原因是，
Another reason why you might like small is that

409
00:23:48,320 --> 00:23:51,560
少量代码通常更容易优化，
small amount of code is often like easier to optimize,

410
00:23:51,560 --> 00:23:56,080
跟大型程序比起来。
than, than a huge program.

411
00:23:57,720 --> 00:24:00,390
另一个小的可能更快原因是，
Another reason why small might result in fast is that

412
00:24:00,510 --> 00:24:04,820
你不必为很多你不用的功能考虑，
you don't have to pay for a lot of features you don't use,

413
00:24:04,850 --> 00:24:06,410
微内核几乎不做任何事情，
you know micro kernel does hardly anything,

414
00:24:06,410 --> 00:24:09,170
那么你不必关心很多你不会使用的功能。
then you're not paying for a lot of features you're not using.

415
00:24:11,220 --> 00:24:14,180
另一个小的原因是，
Another reason for small is that,

416
00:24:14,480 --> 00:24:18,320
小内核可能会产生更少的设计决策，
small kernel probably bakes in far fewer design decisions,

417
00:24:18,320 --> 00:24:21,200
让应用程序编写者做出更少的设计决策，
forces fewer design decisions on application writers

418
00:24:22,580 --> 00:24:26,000
所以，它给他们留下了更多灵活性，
and so it leaves them more maybe leaves them more flexible flexibility

419
00:24:26,000 --> 00:24:27,890
让他们做自己的设计决策。
to make their own design decisions.

420
00:24:30,800 --> 00:24:31,760
顺便说一句，所有这些，
By the way, these are all,

421
00:24:31,760 --> 00:24:36,880
这些不是微内核方法的必然结果，
these are not necessary consequences of the micro kernel approach,

422
00:24:36,970 --> 00:24:40,870
这些都是人们希望通过使用微内核来实现的。
these are things that people hoped for and tried to achieve by using micro kernels.

423
00:24:41,200 --> 00:24:43,360
另一些原因，
And another set of reasons,

424
00:24:43,360 --> 00:24:46,030
微内核看起来很有吸引力与这样一个事实有关，
why micro kernels seemed attractive has to do with the fact that

425
00:24:46,030 --> 00:24:48,070
很多代码都是用户级别的，
a lot of the code was at user level,

426
00:24:49,110 --> 00:24:52,270
很多特性和功能，
that is a lot of features and functions,

427
00:24:52,270 --> 00:24:55,460
我们在内核中使用的，
that we sort of grown used to being inside the kernel

428
00:24:55,460 --> 00:24:57,260
实际上是用户级别的服务，
were actual user level services,

429
00:24:57,440 --> 00:25:00,950
所以他们希望通过打破内核部分，
so they hope that by a sort of breaking the kernel part

430
00:25:00,950 --> 00:25:04,730
运行不同的部分，比如用户级服务，
and running the different parts, like a user level services,

431
00:25:04,730 --> 00:25:08,810
比如文件服务，文件服务服务器，
like a file service, for file service server,

432
00:25:09,050 --> 00:25:14,380
这可能会使代码更加模块化，
that might cause the the code to be more modular,

433
00:25:14,860 --> 00:25:18,220
可能会鼓励操作系统设计人员
might sort of encourage operating system designers

434
00:25:18,220 --> 00:25:23,920
将所有这些功能划分为许多单独的服务，
to split up all these functions into many separate services,

435
00:25:23,920 --> 00:25:25,300
那也许是一件好事。
that might that might be a good thing.

436
00:25:26,330 --> 00:25:31,190
用户级代码也可能更容易修改，
User level code is also possibly easier to modify,

437
00:25:31,190 --> 00:25:35,600
用户级别通常更容易调整，替换或修改，
its user level it's usually easier to tweak it or replace it or modify it,

438
00:25:35,600 --> 00:25:38,060
比起在内核中做同样的事情，
than doing the same stuff in the kernel,

439
00:25:38,060 --> 00:25:40,310
所以也许它更容易定制，
so maybe it's easier to customize,

440
00:25:43,610 --> 00:25:47,390
将操作系统置于用户级别，
putting the operating systems at user level,

441
00:25:47,390 --> 00:25:50,240
这也可能使它们更健壮，
that also might make them more robust,

442
00:25:50,240 --> 00:25:53,270
如果内核出了问题，
you can, you can if the kernel something goes wrong with the kernel,

443
00:25:55,170 --> 00:25:58,020
通常你收到 panic 然后重启，
you know, usually you have to panic and reboot,

444
00:25:58,020 --> 00:26:02,940
因为，你不能再相信内核里的东西了，
because, you know you can't necessarily trust what's in the kernel anymore,

445
00:26:02,940 --> 00:26:03,780
如果它有一些 bug ，
if it's had some bug,

446
00:26:03,780 --> 00:26:07,050
可能会导致它覆盖其数据的随机部分，
that maybe causes it to overwrite a random part of its data,

447
00:26:07,530 --> 00:26:10,140
如果你有一堆用户级别的服务，
whereas if you have a bunch of user level services

448
00:26:10,140 --> 00:26:11,340
它们中的一个发生故障，
and one of them malfunctions

449
00:26:11,340 --> 00:26:15,180
除零操作，或这释放野指针，
and devised by zero or dereferences a wild pointer,

450
00:26:15,300 --> 00:26:17,490
也许只有那台服务器崩溃，
maybe only that one server will crash

451
00:26:17,490 --> 00:26:19,740
让操作系统的其他部分完好无损，
and leaving the rest of the operating system intact,

452
00:26:19,740 --> 00:26:20,970
然后也许你可以重启它，
then maybe you can restart it,

453
00:26:21,270 --> 00:26:22,260
只重启那一台服务器，
just that one server,

454
00:26:22,260 --> 00:26:28,440
所以，也许将操作系统功能移动到用户级进程，
so maybe user level, moving OS functionality to user process

455
00:26:28,440 --> 00:26:30,180
可能会带来更强的健壮性，
might lead to more robustness,

456
00:26:30,300 --> 00:26:31,080
这是令人惊讶的，
this is surprise,

457
00:26:31,680 --> 00:26:33,360
特别是对驱动程序来说，
particularly evident for drivers,

458
00:26:33,570 --> 00:26:39,110
内核中或硬件设备驱动程序中存在大多数 bug ，
there most bugs in the kernel or actually hardware device drivers,

459
00:26:39,230 --> 00:26:41,810
如果我们能设法将设备驱动程序移出内核，
if we can manage to move the device drivers out of the kernel,

460
00:26:41,930 --> 00:26:45,230
那么我们在内核中崩溃的 bug 可能会少得多。
then we might have many fewer bugs crashes in the kernel.

461
00:26:46,840 --> 00:26:47,860
而最后一个好处，
And the final advantage,

462
00:26:47,860 --> 00:26:49,840
人们想的是，
the people were thinking about back then is that,

463
00:26:50,080 --> 00:26:53,680
你可以模拟一个或多个操作系统，
you could emulate one or multiple operating system [personalities]

464
00:26:53,680 --> 00:26:54,940
在一个微内核上，
on top of a micro kernel,

465
00:26:55,180 --> 00:26:58,330
所以，即使微内核几乎不直接为你做任何事情，
so even though micro kernel does does hardly anything for you directly,

466
00:26:58,360 --> 00:27:01,600
你也可以运行 Unix 服务器或其他东西在它上面，
you might be able to run a Unix server or something on top of it,

467
00:27:01,900 --> 00:27:06,110
可能在一台机器上不止一个。
maybe more than one on the same machine.

468
00:27:08,760 --> 00:27:10,920
当然，这是今天的论文所说的，
Of course, that's what today's papers about,

469
00:27:11,430 --> 00:27:15,810
在微内核上运行 Unix 或 Linux 作为服务，
running Unix, running Linux as a service on a micro kernel,

470
00:27:16,320 --> 00:27:20,270
这些都是人们希望的东西，
these are all the set of things that people were hoping

471
00:27:20,270 --> 00:27:22,190
能够获得一些[吸引力]，
to be able to get some [traction]

472
00:27:22,190 --> 00:27:25,970
通过研究微内核设计。
on by looking into micro kernel designs.

473
00:27:27,010 --> 00:27:32,100
当然会有一些难题，你必须想清楚，
Of course, there's some sort of puzzles, you have to think through,

474
00:27:33,020 --> 00:27:34,070
一些挑战。
some challenges.

475
00:27:37,810 --> 00:27:41,920
如果你想设计自己的微内核，一个挑战是，
One challenge, if you want to design your own micro kernel is

476
00:27:42,160 --> 00:27:44,170
找出 API ，
actually figuring out you want the API

477
00:27:44,170 --> 00:27:46,300
你希望微内核系统调用接口
you want the micro kernel system call interface

478
00:27:46,300 --> 00:27:47,950
尽可能的简单，
to be as simple as possible,

479
00:27:48,160 --> 00:27:49,960
因为关键是要让它变得很小，
because the whole point was to keep it small

480
00:27:50,290 --> 00:27:54,700
什么是最小可以系统调用，
and what is the actual smallest set of useful system calls

481
00:27:54,700 --> 00:27:55,660
你可以[使用]的，
you can get [away] with,

482
00:27:56,140 --> 00:27:58,030
它看起来是什么样子的，
you know what does it look like,

483
00:27:59,240 --> 00:28:00,950
这不是特别清楚，
that's not particularly clear,

484
00:28:02,720 --> 00:28:08,370
看看最小的系统调用 API 。
look at the minimum system call API.

485
00:28:12,190 --> 00:28:14,800
你需要最小系统调用 API ，
You need these this minimum system call API,

486
00:28:14,800 --> 00:28:15,850
它越简单越好，
it's great to be simple,

487
00:28:15,880 --> 00:28:20,110
但是你必须构建一些相当复杂的功能，
but you actually have to be able to build some pretty sophisticated features

488
00:28:20,110 --> 00:28:22,210
在你的最小系统调用 API 之外，
out of your minimum system call API,

489
00:28:22,210 --> 00:28:24,520
因为内核做的不够多，
because even the kernel doesn't do much,

490
00:28:24,520 --> 00:28:26,770
最终，你必须能够运行程序，
you know in the end, you've got to be able to run programs,

491
00:28:26,770 --> 00:28:30,430
你可能试着在微内核上运行 Unix ，
you got maybe you're trying to run Unix on top of a micro kernel,

492
00:28:30,430 --> 00:28:32,800
为了能够执行 fork mmap 之类的操作，
to be able do things like fork mmap,

493
00:28:33,130 --> 00:28:37,060
所以作为系统调用接口的一部分，
so as part of the system call interface,

494
00:28:37,090 --> 00:28:40,110
简单低级系统调用接口，
simple low-level system call interface,

495
00:28:40,260 --> 00:28:41,940
它必须足够强大，
it has to be powerful enough

496
00:28:41,940 --> 00:28:47,150
以支持人们需要做的所有事情，
to support all the stuff people need to do,

497
00:28:47,150 --> 00:28:50,900
比如 exec 和 fork ，
like exec and fork

498
00:28:51,290 --> 00:28:53,780
甚至可能是写入时复制 fork
and hack maybe even copy-on-write fork

499
00:28:53,780 --> 00:28:57,320
或磁盘文件的内存映射，
or memory mapping on disk files,

500
00:28:57,320 --> 00:29:00,740
但这些都在一个没有文件系统的内核中，
but all in a kernel that has no idea about files or file system,

501
00:29:01,310 --> 00:29:02,570
需要支持 exec ，
needs to support exec,

502
00:29:02,570 --> 00:29:05,030
但内核对文件一无所知。
but with kernel that knows nothing about files.

503
00:29:06,440 --> 00:29:12,050
我们需要操作系统的其他部分，
We need the rest of the, the operating system,

504
00:29:12,050 --> 00:29:15,640
以某种方式确保微内核可能非常简单，
somehow ensure that micro kernel maybe very simple,

505
00:29:15,640 --> 00:29:21,340
但是现在我们需要开发一些用户级的服务，
but you know now we're requiring the development of some set of user level servers,

506
00:29:21,340 --> 00:29:23,790
实现操作系统的其他部分，
that implement the rest of the operating system,

507
00:29:24,270 --> 00:29:26,790
所以我们至少要做到这一点，
so we need, that has to get done at least

508
00:29:26,790 --> 00:29:29,640
可能需要解决一些设计难题，
and may require some solving design puzzles,

509
00:29:30,870 --> 00:29:35,250
最后，这种安排需要大量通信，
and finally, the you know this arrangement requires a lot of chitchat

510
00:29:35,250 --> 00:29:38,280
通过 IPC 进程间通信，
over inter processor communication over IPC,

511
00:29:38,640 --> 00:29:47,300
所以会有很大的压力让 IPC 非常快，
so there's going to be great pressure to make the you know IPC very fast,

512
00:29:47,300 --> 00:29:52,080
所以，需要知道 IPC 是否能足够快，
so you know wonder whether IPC can be made fast enough,

513
00:29:53,420 --> 00:29:56,390
让微内核保持竞争力。
to keep micro kernels competitive.

514
00:29:57,700 --> 00:30:00,220
好的，一般说来，
Alright, and just in general,

515
00:30:00,220 --> 00:30:02,830
不仅仅是 IPC 的速度，
actually the not just IPC speed,

516
00:30:02,830 --> 00:30:03,850
但总的来说，
but in general,

517
00:30:04,720 --> 00:30:09,160
有很多理由相信宏内核可以获得一定的性能，
a lot of reason to believe that monolithic kernels derived some performance

518
00:30:09,160 --> 00:30:10,900
因为它们是集成的，
out of the fact that they're integrated,

519
00:30:10,900 --> 00:30:15,460
文件系统代码可以与虚拟内存代码和内存分配代码交互，
that the file system code can talk to the virtual memory code and memory allocation code,

520
00:30:15,730 --> 00:30:18,880
它是一个[快乐的]大项目。
it's all sort of one big happy giant program.

521
00:30:19,710 --> 00:30:23,640
如果将所有这些内容拆分到单独的服务中，
And if you require all those things to be split out into separate servers

522
00:30:23,640 --> 00:30:26,550
或者可能拆分到内核和用户级别，
or may be split between the kernel and user level,

523
00:30:26,550 --> 00:30:30,330
通过集成的方式进行优化的机会可能较少，
there may be fewer opportunities for optimization by way of integration,

524
00:30:30,540 --> 00:30:34,230
然后可能会也可能不会损害性能。
then that may or may not end up hurting performance.

525
00:30:37,200 --> 00:30:37,860
好的。
Alright.

526
00:30:39,980 --> 00:30:44,270
所以这些都是期望的优势，
So these are sort of crosscutting hoped for wins

527
00:30:44,270 --> 00:30:46,310
以及所有挑战，
and sort of challenges that all,

528
00:30:46,610 --> 00:30:49,670
很多微内核项目所面对的。
the many micro kernel projects faced.

529
00:30:53,000 --> 00:30:54,110
因为今天的论文，
Because of today's paper,

530
00:30:54,110 --> 00:30:58,220
我要告诉你们一些关于 L4 的事情，
I'm gonna tell you a bunch of about L4 specifically,

531
00:30:58,220 --> 00:31:05,440
它是今天论文作者开发和使用的微内核。
which is the micro kernel the the authors of today's paper developed and used.

532
00:31:07,630 --> 00:31:13,020
L4 当然不是最早的微内核，
L4 is not, it's certainly not the earliest micro kernel ever made,

533
00:31:13,020 --> 00:31:15,840
但它是早期微内核之一，
but it's one of the sort of early micro kernels,

534
00:31:16,050 --> 00:31:19,770
从 20 世纪 80 年代开始的所有工作中，
that came out of all the work in this starting in the 1980s

535
00:31:20,130 --> 00:31:23,790
就工作原理而言，是相当有代表性的。
and it's fairly representative as far as how it works.

536
00:31:25,140 --> 00:31:28,830
一些目标是，
There's been, it's a bit of a moving target was

537
00:31:28,830 --> 00:31:32,550
它发展和演变了很多年，
the subject of [intense] development and evolution for many years

538
00:31:32,550 --> 00:31:34,050
而且它仍然很强劲，
and it's still going strong,

539
00:31:34,620 --> 00:31:35,970
如果查看维基百科上，
if you look at on Wikipedia,

540
00:31:35,970 --> 00:31:39,780
你会发现 L4 有 15 到 20 种不同的变体，
you'll see that there's maybe 15 or 20 different variants of L4,

541
00:31:39,780 --> 00:31:42,030
它们来了又走，有些还在这里，
that have come and gone and some are still here,

542
00:31:42,780 --> 00:31:45,120
我想从 20 世纪 80 年代末开始，
starting I think in the late 1980s

543
00:31:45,750 --> 00:31:48,920
我要向你们解释的是
and I know what I'm gonna try to explain to you is

544
00:31:48,920 --> 00:31:51,080
我对 L4 如何工作的理解，
my understanding of how L4 worked,

545
00:31:51,200 --> 00:31:54,980
在今天的论文发表的时候。
at about the time today's paper came out.

546
00:31:58,890 --> 00:32:04,810
好的，那么从高的层面来说，
Alright, so just at a high level,

547
00:32:04,840 --> 00:32:08,230
L4 当然是微型的，
the L4 was certainly micro,

548
00:32:08,230 --> 00:32:12,460
从某种意义上说，它是一个小内核，
in the sense that it was actually is a small kernel,

549
00:32:12,520 --> 00:32:15,130
它只有 7 个系统调用，
it has only 7 system calls,

550
00:32:15,790 --> 00:32:17,020
有些有点复杂，
some of them a little bit complex,

551
00:32:17,020 --> 00:32:18,880
但它仍然只有 7 个系统调用，
but still it only has 7 system calls,

552
00:32:18,910 --> 00:32:22,960
而今天的 Linux ，我最后一次统计时，有三百多个，
whereas today's Linux, the last time I counted, had in the mid three hundreds

553
00:32:23,830 --> 00:32:26,440
甚至 xv6 是一个非常简单的内核，
and even xv6 which is an extremely simple kernel,

554
00:32:26,440 --> 00:32:28,570
即使 xv6 也有 21 个系统调用，
even xv6 has 21 system calls,

555
00:32:29,230 --> 00:32:34,110
所以 L4 只有 7 个，
so L4 it's only 7,

556
00:32:34,440 --> 00:32:36,150
所以通过这个度量很简单，
so by that metric is simple,

557
00:32:36,150 --> 00:32:37,320
它也不是很大，
it's also not very big,

558
00:32:37,530 --> 00:32:44,790
我认为，当这篇论文写成时，大约有 13000 行代码，
I think, as the time this paper was written at about 13 000 lines of code,

559
00:32:45,600 --> 00:32:46,620
只是没有太多，
just not too much,

560
00:32:46,620 --> 00:32:48,300
xv6 比这更小，
xv6 is smaller than that,

561
00:32:49,890 --> 00:32:52,860
我认为 xv6 内核可能有 6000 到 7000 行代码，
I think xv6 maybe six or 7000 lines of code in the kernel,

562
00:32:53,010 --> 00:32:55,410
但就内核而言， xv6 仍然非常简单，
but still xv6 is very simple as kernels [],

563
00:32:55,980 --> 00:32:57,810
L4 并不比这更复杂，
L4 not much more complex than that,

564
00:32:57,810 --> 00:33:03,540
这是 Linux 的十分之一、二十分之一或三十分之一，
and this is you know a tenth or twentieth or thirtieth as big as as Linux,

565
00:33:03,690 --> 00:33:04,500
是相当小的。
is pretty small.

566
00:33:05,520 --> 00:33:09,090
它只有几个基本的抽象，
It had only a few basic abstractions,

567
00:33:10,950 --> 00:33:18,810
它有任务或地址空间的概念，
it had a notion of what they called tasks or address spaces,

568
00:33:22,170 --> 00:33:25,740
这些或多或少对应于我们在 Unix 中所说的进程，
and these more or less correspond to what we would call a process in Unix,

569
00:33:25,740 --> 00:33:30,210
这是一堆从 0 开始的内存映射，
it's a bunch of memories map starting at 0

570
00:33:30,210 --> 00:33:34,210
你可以在这里执行，
and and you're able to execute in here,

571
00:33:34,510 --> 00:33:36,310
就像在进程中，
just like in the process,

572
00:33:36,310 --> 00:33:39,620
与 xv6 的不同之处是，
when different from xv6 is that

573
00:33:39,680 --> 00:33:43,880
每个任务可以有多个线程，
there can be multiple threads per task,

574
00:33:45,040 --> 00:33:52,450
L4 负责在每个任务中调度多个执行线程。
and L4 was in charge of scheduling multiple threads of execution within each task.

575
00:33:54,260 --> 00:33:56,420
这样的部分原因是
And part of the reason for this is

576
00:33:56,420 --> 00:33:58,310
它有线程非常方便，
just it's very convenient to have threads

577
00:33:58,310 --> 00:34:01,280
将线程作为编程结构化工具，
as a programming structuring program structuring tool

578
00:34:01,460 --> 00:34:02,750
它也是，
and it was also,

579
00:34:03,350 --> 00:34:08,570
我不知道他们是否支持多核机器，
I don't know if they actually supported multi-core multiprocessor machines,

580
00:34:08,600 --> 00:34:09,680
在写这篇论文的时候，
at the time the paper was written,

581
00:34:09,680 --> 00:34:13,940
但是，他们很可能有线程，
but, they may well have and threads,

582
00:34:13,940 --> 00:34:15,230
当然，你需要能够
of course just what you need to be able to

583
00:34:15,230 --> 00:34:18,950
利用多个核心执行同一个程序，
harness multiple cores executing the same program,

584
00:34:19,130 --> 00:34:23,320
所以 L4 内核支持线程。
so there's are threads supported by L4 kernel.

585
00:34:26,650 --> 00:34:29,740
所以， L4 支持任务，
So so, L4 supported tasks,

586
00:34:29,740 --> 00:34:32,680
它知道任务，它知道线程，
it knew about tasks, it knew about threads

587
00:34:32,830 --> 00:34:36,190
它也知道地址空间，
and it also knew about address spaces,

588
00:34:36,190 --> 00:34:39,130
在这个意义上，你可以告诉 L4 ，
in the sense that you could, you could ask tell L4,

589
00:34:39,130 --> 00:34:42,040
这是我们想要的页面映射到地址空间。
look, here's how we want pages mapped into address space.

590
00:34:43,110 --> 00:34:49,980
L4 知道的另一件主要事情是进程间通信，
And the other main thing that L4 knew about is inter process communication,

591
00:34:49,980 --> 00:34:53,220
每个线程都有一个标识符，
so that was every thread has an identifier

592
00:34:53,400 --> 00:34:54,360
一个线程可能会说，
and one thread could say,

593
00:34:54,360 --> 00:34:56,310
我想发送一条消息，
look, I want to send a message,

594
00:34:56,340 --> 00:34:59,190
它只是给另一个线程几个字节，
it just some bytes to another thread,

595
00:34:59,190 --> 00:35:00,840
这是这个标识符，
and here's this identifier,

596
00:35:00,840 --> 00:35:05,540
请给另一个线程发送一条消息。
please, please send a message to that other thread.

597
00:35:07,860 --> 00:35:15,350
所以，这些是任务，线程，地址空间和 IPC ，
So these are really the only task, threads, address spaces and IPC

598
00:35:15,350 --> 00:35:16,760
实际上是唯一的抽象概念，
were really the only abstractions,

599
00:35:16,880 --> 00:35:18,230
系统调用，
the system calls,

600
00:35:19,670 --> 00:35:21,380
我不知道是否能把它们全部列出来，
I don't know if I can be able to list them all,

601
00:35:21,380 --> 00:35:27,450
但是，系统调用是，
but the system calls were,

602
00:35:27,690 --> 00:35:28,920
这里有一个线程，
there was a thread,

603
00:35:29,160 --> 00:35:33,270
线程创建系统调用，
thread create system call,

604
00:35:33,270 --> 00:35:38,670
你给它一个地址空间 id ，创建一个新的线程，
which also you gave it a address space id has to create a new thread

605
00:35:38,670 --> 00:35:41,580
如果地址空间分配已经存在，
and if the address space are tasked in already exist,

606
00:35:41,580 --> 00:35:43,140
它会给你创建一个新的任务，
it would create a new task for you,

607
00:35:43,320 --> 00:35:45,780
将线程和任务创建结合在一起。
sort of combine thread and task creation.

608
00:35:48,030 --> 00:35:52,210
有发送和接收，
There's send and receive,

609
00:35:53,280 --> 00:35:57,210
不同风格的发送和接收 IPC 系统调用。
various flavors of send and receive IPC system calls.

610
00:35:59,580 --> 00:36:05,430
有一种方法将页面映射到你的或其他地址空间，
There's a way to map pages into your or other address space,

611
00:36:05,430 --> 00:36:11,220
所以你可以让 L4 改变你的地址空间的设置方式，
so, you, you could ask the L4 to change the way your address space was set up,

612
00:36:11,220 --> 00:36:13,530
你的页表映射的设置方式，
the way your page table maps were set up,

613
00:36:13,560 --> 00:36:15,510
但是你也可以要求 L4 ，
but you could also ask L4,

614
00:36:15,540 --> 00:36:17,820
如果你有正确的权限，
if you had the right permissions to go

615
00:36:17,820 --> 00:36:21,480
可以更改另一个任务的地址空间的设置方式。
and change the way another task's address space was set up.

616
00:36:21,860 --> 00:36:28,970
因此，这实际上是通过 IPC 完成的，
So, this was actually done through the IPC,

617
00:36:28,970 --> 00:36:30,680
将通过 IPC 接口，
would spent through the IPC interface,

618
00:36:30,680 --> 00:36:33,080
将发送一个特殊的 IPC 消息，
you know would send a special IPC message,

619
00:36:33,230 --> 00:36:35,900
内核知道目标线程，
that the kernel knew about to the target thread,

620
00:36:35,900 --> 00:36:39,590
并且内核将修改目标线程地址空间。
and the kernel would modify the target thread's address space.

621
00:36:41,050 --> 00:36:43,030
这是如果你创建一个新的线程，
And this is if you are creating a new thread,

622
00:36:43,030 --> 00:36:45,580
实际上新创建的线程完全没有内存，
this is actually new threads are created with no memory at all,

623
00:36:46,720 --> 00:36:47,710
所以如果你想创建一个线程，
so if you want to create a thread,

624
00:36:47,710 --> 00:36:49,780
你首先调用线程创建系统调用
you first call the thread create system call

625
00:36:49,780 --> 00:36:52,660
来创建新的线程，任务和地址空间，
to create a new thread and task and address space,

626
00:36:52,720 --> 00:36:54,100
然后你发送它，
and then you send it,

627
00:36:54,370 --> 00:36:56,230
如果你创建一个神奇的 IPC ，
if you make one of these magic IPCs

628
00:36:56,230 --> 00:37:00,070
来发送一些你自己的内存映射，
to send some of your own memory maps of your own memory,

629
00:37:00,070 --> 00:37:02,260
你已经准备好的指令或数据，
that you've prepared with instructions or data

630
00:37:02,800 --> 00:37:04,840
为了将内存映射到新的，
to map that memory into the new,

631
00:37:05,530 --> 00:37:07,540
新的任务地址空间，
and so a new task address space,

632
00:37:07,930 --> 00:37:11,260
然后发送一个特殊的 IPC 到这个新的任务，
and then you send a special start IPC to this new task

633
00:37:11,260 --> 00:37:14,800
通过程序计数器和你想开始执行的堆栈指针，
with the program counter and stack pointer you want it to start executing with,

634
00:37:15,100 --> 00:37:16,060
它将开始执行，
that will start executing

635
00:37:16,060 --> 00:37:19,480
并在要求启动程序计数器处设置内存。
and that memory you've setup at the program counter you ask startup.

636
00:37:21,740 --> 00:37:24,140
有一种方法不通过系统调用，
There's a way not through system calls,

637
00:37:24,320 --> 00:37:25,700
事实上，我不知道它是怎么工作的，
in fact I don't know how it worked,

638
00:37:25,700 --> 00:37:30,700
但是特权任务可以映射设备硬件，
but privileged tasks could map device hardware,

639
00:37:32,980 --> 00:37:36,820
映射设备控制寄存器到它们自己的地址空间。
you know device control registers into their own address spaces.

640
00:37:39,980 --> 00:37:41,990
所以， L4 对设备不是很了解，
So, L4 didn't really know much about devices

641
00:37:41,990 --> 00:37:44,060
比如磁盘或网卡，
like disks or network interface cards,

642
00:37:44,060 --> 00:37:48,830
但是用户级软件可以直接访问，
but user level software could get directly at,

643
00:37:51,160 --> 00:37:53,350
用户级软件可以实现设备驱动，
user level software that implemented device drivers,

644
00:37:53,350 --> 00:37:55,720
用户级软件可以直接访问设备硬件。
that user level could get directly at device hardware.

645
00:37:56,610 --> 00:37:59,580
有一种方法可以，
There was a way to

646
00:38:00,220 --> 00:38:03,430
你可以告诉 L4 打开中断，
you could tell L4 to turn on interrupt,

647
00:38:05,870 --> 00:38:07,370
来自任何设备的任何中断，
any interrupt from any device,

648
00:38:07,520 --> 00:38:09,980
L4 并不知道哪台设备打开。
L4 didn't really know which device just turned,

649
00:38:10,400 --> 00:38:13,520
把中断给 IPC 消息。
given interrupt into an IPC message.

650
00:38:14,070 --> 00:38:20,070
所以设备驱动程序任务不仅读写设备硬件，
So a device driver task not just read write the device hardware,

651
00:38:20,070 --> 00:38:22,620
也会告诉 L4 在设备中断的时候，
but also tell L4 well anytime that device interrupts,

652
00:38:22,680 --> 00:38:24,720
请给我发送一条 IPC 消息，
please send me an IPC message,

653
00:38:25,350 --> 00:38:26,670
通知我中断。
notifying me the interrupt.

654
00:38:27,820 --> 00:38:32,380
最后，一个任务告诉内核
And finally one task tell the kernel

655
00:38:32,410 --> 00:38:37,390
给它另一个任务页面错误的通知，
to give it notifications of another task page faults,

656
00:38:38,470 --> 00:38:41,020
所以，如果这个任务出现页面错误，
so if this task page fault,

657
00:38:41,140 --> 00:38:44,830
L4 会将其转换为 IPC 消息，
L4 would turn that into an IPC message

658
00:38:45,730 --> 00:38:49,120
并将它发送到另一个专用的分页任务，
and send it to another designated pager task,

659
00:38:49,930 --> 00:38:52,990
将页面错误通知发送给指定的页面任务，
send the notification the page fault to a designated pager task,

660
00:38:52,990 --> 00:38:57,250
所以每个任务都有一个关联的分页任务，来处理它的页面错误，
so every task has an associated pager task, that handled its page faults,

661
00:38:57,460 --> 00:39:01,600
这就是你把钩子挂在页面错误上的方式，
and that's the way you know you get hooks into the page faults,

662
00:39:01,600 --> 00:39:05,590
用来实现写入时复制， fork 或懒分配。
in order to implement things like copy-on-write fork or lazy allocation.

663
00:39:09,060 --> 00:39:11,550
内核就是这样，在 L4 中没有其他东西，
And that's it for the kernel, there's nothing else in L4,

664
00:39:11,550 --> 00:39:12,900
没有文件系统，
there's no file system,

665
00:39:13,230 --> 00:39:16,530
L4 本身并不支持 fork exec 之类的功能，
L4 didn't itself had support for things like fork exec,

666
00:39:16,830 --> 00:39:21,510
除了这些非常简单的 IPC 之外，没有任何通信，
didn't have any communication beyond these very simple IPC,

667
00:39:21,990 --> 00:39:22,560
比如没有管道，
like did not pipes,

668
00:39:22,560 --> 00:39:24,060
没有设备驱动程序，
did not device drivers,

669
00:39:24,060 --> 00:39:25,290
没有网络支持，什么都没有，
no networking support nothing,

670
00:39:26,250 --> 00:39:27,750
如果你需要其他东西的话，
everything else if you wanted it,

671
00:39:28,200 --> 00:39:31,890
你需要提供作为用户级别的服务。
you need to supply as a user level services.

672
00:39:37,080 --> 00:39:40,760
好的，那么一件事是，
Okay, so one thing that are,

673
00:39:41,630 --> 00:39:46,400
L4 支持线程切换，
L4 does supply is switching among threads,

674
00:39:46,520 --> 00:39:50,750
L4 执行调度和上下文切换，
L4 would actually do the scheduling and context switches

675
00:39:51,350 --> 00:39:54,710
以便在多个线程中复用单个 CPU ，
in order to multiplex a single CPU among multiple threads

676
00:39:54,710 --> 00:39:57,770
你会发现它做的方式完全不令人惊讶，
and the way it did it you would find completely unsurprising,

677
00:39:58,160 --> 00:40:03,860
L4 为每个线程、每个任务保存了寄存器，
L4 basically had saved registers for every task, for every thread,

678
00:40:04,580 --> 00:40:05,960
当它执行线程时，
when it executed a thread,

679
00:40:05,960 --> 00:40:10,070
执行线程会跳入用户空间，切换页表，
the executing thread would jump into user space, switch page tables,

680
00:40:10,070 --> 00:40:12,860
所以，那个线程将在用户空间中执行一段时间，
so that thread and that thread will execute for a while in user space,

681
00:40:13,070 --> 00:40:15,170
然后可能定时器中断响起，
then maybe the timer interrupt would go off

682
00:40:15,170 --> 00:40:17,270
这是 L4 所知道的一种设备，
and that was actually a device L4 knew about,

683
00:40:17,600 --> 00:40:19,910
定时器中断会在一段时间后触发，
the timer interrupt might go off after a while,

684
00:40:20,280 --> 00:40:21,330
中断 L4 ，
interrupting the L4,

685
00:40:21,330 --> 00:40:26,010
L4 将保存这个任务的用户寄存器到任务中，
L4 would save this task's user registers in a per task,

686
00:40:26,340 --> 00:40:29,280
一个任务线程数组结构，
an array of tasks thread structures,

687
00:40:29,520 --> 00:40:32,900
会将这个线程寄存器保存起来，
would save this threads registers away,

688
00:40:33,320 --> 00:40:35,150
从循环中选择一个新任务运行，
pick a new task to run in a loop,

689
00:40:35,180 --> 00:40:37,460
这与 xv6 中的调度循环非常像，
much like the scheduling loop in xv6,

690
00:40:37,850 --> 00:40:43,820
从先前保存的寄存器恢复这个任务的寄存器，
restore this task's registers out from its previously saved registers,

691
00:40:44,030 --> 00:40:45,230
切换页表，
switch page tables,

692
00:40:45,230 --> 00:40:47,930
然后跳到这个任务，并执行一段时间，
and then jump into this task and execute it for a while,

693
00:40:48,950 --> 00:40:50,300
直到定时器中断停止
until the timer interrupt went off

694
00:40:50,300 --> 00:40:54,620
或直到这个任务 yield ，
or until this task either yielded,

695
00:40:54,800 --> 00:40:58,040
我想这里可能还有一个 yield 系统调用或类似的调用。
I think there's also probably a yield system call or something like it.

696
00:40:59,230 --> 00:41:00,910
一个任务可能会让出 CPU ，
A task can yield a CPU

697
00:41:00,910 --> 00:41:04,120
或者任务可能会等待接收 IPC ，
or a task could wait to receive an IPC,

698
00:41:04,120 --> 00:41:05,020
在这种情况下，
in that case,

699
00:41:06,090 --> 00:41:08,040
我们跳回 L4 ，
L4, we jump back into L4

700
00:41:08,040 --> 00:41:12,540
L4 看到寄存器切换到新任务并运行，
and L4 see this registers switch to a new task and run task,

701
00:41:12,600 --> 00:41:19,170
所以 L4 的线程切换部分是非常熟悉的。
so that thread switching part of L4 is very, be very familiar.

702
00:41:25,350 --> 00:41:27,060
那个。
The.

703
00:41:30,130 --> 00:41:31,630
我之前提到过这件事，
I I mentioned this before,

704
00:41:31,630 --> 00:41:34,390
我想说，因为它出现了，
I just want to because it comes up,

705
00:41:34,970 --> 00:41:37,910
我想写在这里，
I wanna write here,

706
00:41:39,830 --> 00:41:40,910
这个分页的概念，
this notion of a pager,

707
00:41:40,910 --> 00:41:47,390
如果进程出现页面错误，
the, repeat if a process is a page fault,

708
00:41:48,620 --> 00:41:49,760
trap 出现在内核，
traps into the kernel,

709
00:41:49,850 --> 00:41:52,370
并且内核将页面错误转换为 IPC 消息，
and the kernel turns that page fault into an IPC message

710
00:41:52,370 --> 00:41:54,710
发给指定的分页任务，
to a designated pager task

711
00:41:54,860 --> 00:41:56,390
并告诉它地址，
and tells it the address,

712
00:41:57,650 --> 00:41:59,420
告诉这个分页任务，
tells this pager task

713
00:42:00,260 --> 00:42:04,400
哪个线程出了故障，以及它在哪个地址上出了故障。
which thread faulted and the address it faulted on on.

714
00:42:05,050 --> 00:42:06,280
然后分页任务，
And then the pager task,

715
00:42:06,340 --> 00:42:09,310
如果它想实现懒分配，
if it wants to say implement lazy allocation,

716
00:42:09,610 --> 00:42:13,660
也许这个线程写入一些没有分配的内存，
maybe this thread write some memory that was not allocated yet,

717
00:42:13,660 --> 00:42:17,170
我想它要求懒分配，
but I think that it sort of asked to be lazily allocated,

718
00:42:17,410 --> 00:42:21,670
它的分页任务将负责从 L4 分配一些内存，
its pager task would then be in charge of allocating some memory from L4,

719
00:42:22,570 --> 00:42:25,930
发送一个特殊的 IPC ，
sending one of these special IPCs,

720
00:42:26,140 --> 00:42:32,110
导致内存映射到这个任务中，
cause that caused memory to be mapped into this task,

721
00:42:32,110 --> 00:42:36,670
然后发送 IPC 以恢复这个线程的执行。
and then sending an IPC to resume execution inside this thread.

722
00:42:38,320 --> 00:42:40,060
所以就有了分页任务的概念，
So there was this notion of pager task

723
00:42:40,060 --> 00:42:41,710
来实现所有事情，
to implement all this all the stuff,

724
00:42:41,710 --> 00:42:45,040
xv6 或 Linux 在页面错误处理程序中实现的，
that xv6 or Linux implements in page fault handlers,

725
00:42:45,040 --> 00:42:48,040
你可以用这个实现写入时复制 fork ，
like you could implement copy-on-write fork with this,

726
00:42:48,040 --> 00:42:48,790
如果你喜欢的话，
if you liked,

727
00:42:48,790 --> 00:42:50,950
或这内存映射文件，
or memory mapped files,

728
00:42:50,950 --> 00:42:53,500
它们都使用这些分页任务中的一个。
all using one of these pager task.

729
00:42:53,500 --> 00:42:58,850
它们是一种强大的用户级方式，
They were sort of powerful user level way,

730
00:42:59,270 --> 00:43:02,480
使用页面错误驱动的技巧。
play tricks with a driven by page faults.

731
00:43:03,710 --> 00:43:04,910
所以这是一个例子，
And so this is an example,

732
00:43:05,120 --> 00:43:06,170
许多例子中的一个，
one of many examples,

733
00:43:06,170 --> 00:43:11,120
像 L4 这样的微内核可能更灵活，
in which micro kernel like L4 might have been quite a bit more flexible

734
00:43:11,120 --> 00:43:12,170
对于用户程序来说，
for user programs

735
00:43:12,170 --> 00:43:13,280
跟传统内核比起来，
than a conventional kernel,

736
00:43:13,550 --> 00:43:16,490
比如，如果你让 Linux 做一些额外的事情，
like if you think Linux ought to do some extra thing,

737
00:43:16,490 --> 00:43:20,150
比如，可能一些，
like maybe you know some you know,

738
00:43:20,150 --> 00:43:22,400
如果 Linux 没有写入时复制 fork ，
if Linux didn't already have copy-on-write fork

739
00:43:22,400 --> 00:43:24,230
而你想要写入时复制 fork ，
and you wanted to have copy-on-write fork,

740
00:43:24,440 --> 00:43:27,680
如果不修改内核，就无法在 Linux 中实现它，
you really can't implement that in Linux without modifying the kernel,

741
00:43:28,040 --> 00:43:29,930
而且没有办法为 Linux 编写可移植的代码，
and there's no way to write portable code,

742
00:43:30,200 --> 00:43:32,690
可移植的用户级代码，
portable user level code for Linux,

743
00:43:32,690 --> 00:43:34,790
它可以实现写入时复制 fork 之类的东西。
that could implement something like copy-on-write fork.

744
00:43:38,020 --> 00:43:38,770
这并不完全正确，
That's not quite true,

745
00:43:38,770 --> 00:43:39,940
但这是非常困难的，
but it would be very difficult,

746
00:43:39,970 --> 00:43:43,330
而 L4 相对简单，
whereas L4 its relatively straightforward,

747
00:43:43,330 --> 00:43:45,280
L4 已完全为你设置好，
L4 is completely set up for you

748
00:43:45,280 --> 00:43:46,870
以便你能编写用户级代码，
to be able to write user level code,

749
00:43:46,900 --> 00:43:51,340
它获取页面错误用来实现写入时复制 fork ，
that gets the page faults that are required to drive copy-on-write fork,

750
00:43:51,810 --> 00:43:55,170
所有都在用户空间中，而不必扰乱内核。
all in user space, without having to mess with the kernel.

751
00:43:58,030 --> 00:44:03,840
好的，关于 L4 如何工作，有没有什么问题？
Okay, so any questions so far about how L4 works.

752
00:44:05,590 --> 00:44:10,540
哦，抱歉，你能解释一下线程和任务的区别吗？
Oh, sorry, can you just clarify the difference between a thread and a task?

753
00:44:10,540 --> 00:44:15,610
是的，任务对应于，
Yes, a task corresponds to

754
00:44:15,610 --> 00:44:19,290
它就像 xv6 中的进程，
it's like a process in xv6,

755
00:44:19,290 --> 00:44:21,510
它有一些内存和地址空间，
it has a bunch of memory and address space

756
00:44:21,630 --> 00:44:24,660
你可以在其中执行用户代码，
and you can execute user code in it,

757
00:44:24,660 --> 00:44:28,270
如果你在 xv6 中有一个进程，
xv6 if you have a process in xv6,

758
00:44:28,300 --> 00:44:30,640
那么它只能有一个控制线程，
it can only, it can only be one thread of control,

759
00:44:30,850 --> 00:44:35,410
在一个 xv6 中的进程内执行，
on a single you know executing inside a process in xv6,

760
00:44:35,440 --> 00:44:39,490
但是在现代操作系统和 L4 中，
but in modern operating systems and L4,

761
00:44:40,070 --> 00:44:42,350
在单个进程中，在单个地址空间中，
in a single process, in a single address space,

762
00:44:42,350 --> 00:44:44,750
如果你有多个内核，
you could have if you have multiple cores,

763
00:44:45,410 --> 00:44:50,690
你可以让多个内核执行单个任务，
you can have multiple cores executing a single task,

764
00:44:51,440 --> 00:44:57,710
通常每个核心都在任务的地址空间内设置自己的堆栈。
for each, typically always each set up with its own stack inside that task's address space.

765
00:44:58,480 --> 00:44:59,200
所以，如果，
And so if,

766
00:44:59,410 --> 00:44:59,980
这意味着你可以，
that means you can,

767
00:44:59,980 --> 00:45:04,060
比如，编写一个程序可以获得并发速度，
for example write a single program that can get parallel speedup,

768
00:45:04,060 --> 00:45:07,210
通过多核硬件增加性能，
improve performance from multi-core hardware

769
00:45:07,210 --> 00:45:11,800
通过多个线程每个运行在一个核心上，
by running one thread on having multiple threads each running a different core,

770
00:45:12,040 --> 00:45:13,120
从而完成更多工作。
thereby getting more work done.

771
00:45:15,400 --> 00:45:16,690
好的，我明白了，谢谢。
Okay, I see, thank you.

772
00:45:16,930 --> 00:45:17,590
好的。
Yes.

773
00:45:21,950 --> 00:45:25,300
好的，如你所见，
Okay, so as you can see,

774
00:45:25,300 --> 00:45:29,560
这是一个严重依赖 IPC 的设计，
this is a design that relies heavily on IPC,

775
00:45:29,770 --> 00:45:31,720
因为你要与你的文件服务器交互，
because you're going to want to talk to your file server,

776
00:45:31,720 --> 00:45:34,720
文件服务器想要与设备驱动器服务器交互，
a file server is going to want to talk to the device driver server,

777
00:45:34,900 --> 00:45:37,690
你会看到 IPC 信息来回飞来飞去，
you're gonna have IPC messages flying back and forth,

778
00:45:37,720 --> 00:45:41,380
对于每个系统调用，对于每个页面错误，对于每个设备中断，
for every system call, for every page fault, for every device interrupt,

779
00:45:41,470 --> 00:45:43,600
IPC 系统需要速度非常快，
the IPC system just has to be fast,

780
00:45:44,260 --> 00:45:51,940
现在我们开始讨论
however now we're starting to talk about

781
00:45:51,940 --> 00:45:56,050
微内核故事中的一个严重的潜在缺陷。
a serious potential defect in a micro kernel story.

782
00:46:04,720 --> 00:46:10,150
首先让我给你们展示一个简单但是非常慢的设计，
So first let me show you a straightforward but very slow design,

783
00:46:10,880 --> 00:46:15,410
模仿 Unix 管道的 IPC ，
for IPC patterned off of Unix pipes

784
00:46:15,410 --> 00:46:16,190
我之所以提到这一点，
and I'm bringing this up,

785
00:46:16,190 --> 00:46:21,950
是因为一些早期的微内核以这种方式工作，
because some early micro kernels worked in sort of a similar way

786
00:46:21,950 --> 00:46:23,030
与我即将向你们展示的类似，
to what I'm about to show you,

787
00:46:23,090 --> 00:46:24,290
结果证明是很慢的。
which turned out to be slow.

788
00:46:25,430 --> 00:46:32,620
好的，假设你有两个进程，
Okay, so let's suppose you have you know you have two processes,

789
00:46:32,620 --> 00:46:33,760
我们有 P1 ，
we got P1,

790
00:46:34,120 --> 00:46:36,850
P1 想要向 P2 发送消息。
P1 wants to send a message to P2.

791
00:46:39,710 --> 00:46:41,210
那么这应该如何运作，
So how should that actually work,

792
00:46:41,240 --> 00:46:45,530
一种可能是有一个 send 系统调用，
well, one possibility is to have a send system call,

793
00:46:46,320 --> 00:46:48,570
你给 send 系统调用一个 id ，
and you give send system call the id

794
00:46:48,570 --> 00:46:51,460
那个你想要发送消息的线程，
of the thread you want to send a message to

795
00:46:51,460 --> 00:46:56,590
以及指向消息的字节的指针，
and a pointer to the message to the bytes,

796
00:46:56,590 --> 00:46:59,320
可能是你想要发送到那个进程，
may be that you actually want to send to that process,

797
00:46:59,320 --> 00:47:01,900
所以这个系统调用将跳转到内核，
so this system call are going to jump into the kernel,

798
00:47:02,110 --> 00:47:07,150
也许我们可以设计这种仿照管道和 xv6 的方案，
you know maybe we design this patterned after pipes and xv6,

799
00:47:07,420 --> 00:47:11,500
所以你可以想象有一个等待消息的缓冲区，
so you can imagine there being a buffer of messages waiting,

800
00:47:11,590 --> 00:47:13,720
也许 P2 正在做其他的事情，
maybe P2 doing something else right now,

801
00:47:13,930 --> 00:47:16,210
可能它是服务器，正在为别人的请求提供服务，
maybe it's a server, it's serving somebody else's request,

802
00:47:16,210 --> 00:47:18,160
所以它还没有准备好处理你的请求，
so it's not ready to handle your request,

803
00:47:18,640 --> 00:47:23,900
您可以想象，也许内核中有一个等待消息的缓冲区，
you can imagine, maybe a buffer of waiting messages in the kernel,

804
00:47:23,900 --> 00:47:24,890
就像管道缓冲区一样，
like a pipe buffer,

805
00:47:25,130 --> 00:47:26,210
当你调用 send 时，
when you call send,

806
00:47:27,180 --> 00:47:30,150
它会将你的消息附加到这个缓冲区，
it appends your message to this buffer,

807
00:47:30,150 --> 00:47:31,620
等待 P2 接收消息。
waiting for P2 to receive it.

808
00:47:32,070 --> 00:47:34,350
事实上几乎总是，
You know, in fact almost always,

809
00:47:36,060 --> 00:47:39,570
在这些系统中，你很少仅仅想要发送一条信息，
in these systems, you rarely just wanted to send a message,

810
00:47:39,840 --> 00:47:41,910
你几乎总是想得到回应，
you almost always wanted to get a response too,

811
00:47:41,910 --> 00:47:46,050
你需要 RPC ，远程过程调用操作，
you wanted an RPC, remote procedure call operation,

812
00:47:46,050 --> 00:47:49,770
所以， P1 可能会紧跟其后的是接收，
so, in fact P1 would probably follow this immediately by a receive

813
00:47:49,770 --> 00:47:52,140
以尝试获得响应，
to try to get the response back,

814
00:47:52,320 --> 00:47:53,040
但总的来说，
but in general,

815
00:47:53,500 --> 00:47:56,410
让我们暂时设想一下我们正在进行单向 IPC ，
let's just imagine we're doing a one-way IPC for the moment,

816
00:47:56,410 --> 00:48:01,330
所以 send 会将你的消息附加到内核缓冲区中，
so send would append your message to the in kernel buffer,

817
00:48:01,600 --> 00:48:05,770
我们必须将消息字节从用户空间复制到这个缓冲区，
we have to copy the message bytes from user space into this buffer

818
00:48:05,860 --> 00:48:08,830
然后返回，进程一可以做一些其他事情，
and then return and process one can do something else,

819
00:48:08,830 --> 00:48:11,650
比如可能准备接收回复，
like maybe prepared to receive the response,

820
00:48:12,430 --> 00:48:13,240
过了一会儿，
after a while,

821
00:48:13,240 --> 00:48:18,060
P2 想要接收下一条消息，
P2 it's gonna want to receive the next message

822
00:48:18,060 --> 00:48:20,100
只要调用 recv 系统调用，
just gonna make the recv system call,

823
00:48:21,290 --> 00:48:26,180
它将返回发送者的 id ，
and that's gonna return the id of the sender,

824
00:48:26,800 --> 00:48:30,070
并将消息复制到 P2 的内存中，
and copy the message into P2's memory,

825
00:48:30,550 --> 00:48:33,430
把前面的消息从队列里拿出来，
just gonna take the front message off the queue,

826
00:48:33,430 --> 00:48:34,780
复制到 P2 的内存里，
copy into P2's memory,

827
00:48:36,550 --> 00:48:37,420
然后返回。
and then return.

828
00:48:40,800 --> 00:48:42,330
所以。
So.

829
00:48:46,890 --> 00:48:49,380
这个叫做，
This is called,

830
00:48:50,130 --> 00:48:52,290
有一些词来形容这个，
there's some words for this,

831
00:48:52,350 --> 00:48:55,590
你会在今天的论文中看到，
whose [] you'll see saw in today's paper,

832
00:48:55,650 --> 00:48:59,520
这称为异步方案，
this is called an asynchronous scheme,

833
00:49:01,230 --> 00:49:04,320
因为 P1 发送消息而不需要等待任何东西，
because P1 sends a message without having to wait for anything,

834
00:49:04,320 --> 00:49:06,390
它只是追加到队列并返回，
it just appends to queue and returns,

835
00:49:07,170 --> 00:49:09,570
它被称为缓冲系统，
and it's called a buffered system,

836
00:49:12,520 --> 00:49:16,750
因为内核复制这个消息到缓冲区中，
because the kernel copy this message into the buffer

837
00:49:16,750 --> 00:49:18,880
到 send 的内部缓冲区中，
into its internal buffer on the send

838
00:49:18,880 --> 00:49:21,100
然后稍后当接收发生时，
and then later when the receive happens,

839
00:49:21,100 --> 00:49:23,380
它将消息从缓冲区复制到目标，
it copies the message out of the buffer to the target,

840
00:49:23,380 --> 00:49:25,210
所以这是异步缓冲。
so this is asynchronous buffered.

841
00:49:27,040 --> 00:49:29,770
如果你正在进行完整的请求响应对，
If you're doing a full request response pair,

842
00:49:29,920 --> 00:49:31,240
然后 P1 将调用 send ，
then P1 is going to call send,

843
00:49:31,240 --> 00:49:32,230
send 将会返回，
send going to return,

844
00:49:32,260 --> 00:49:33,820
然后 P1 直接，
P1 is then immediately,

845
00:49:33,880 --> 00:49:37,390
让我们假设这两组缓冲区，
let's assume we're going to assume that's really two sets of buffers,

846
00:49:37,390 --> 00:49:38,410
每个方向一组，
one for each direction,

847
00:49:38,860 --> 00:49:41,200
P1 立即调用 recv ，
P1 immediately gonna call recv,

848
00:49:42,880 --> 00:49:48,400
recv 将等待某些内容出现在应答缓冲区中，
recv gonna wait, need to wait for something to appear in the reply buffer,

849
00:49:48,640 --> 00:49:50,500
所以它不得不让出 CPU ，
so it's going to have to yield the CPU,

850
00:49:50,500 --> 00:49:51,280
它会做一些事情，
it's got to do something

851
00:49:51,280 --> 00:49:53,830
在 xv6 中，调用 sleep 并让出 CPU ，
and call sleep in xv6, yield the CPU,

852
00:49:55,030 --> 00:49:56,800
在单个 CPU 系统上，
on a single CPU system,

853
00:49:56,800 --> 00:49:58,480
可能只有在这一点上，
it may be only at this point,

854
00:49:58,690 --> 00:50:01,990
P1 放弃 CPU ， P2 才可以运行。
that P1 gives up the CPU and now P2 can run.

855
00:50:02,630 --> 00:50:06,740
事实上，这个时代的硬件几乎都是单核的，
And indeed the hardware in this era was almost always single core,

856
00:50:07,910 --> 00:50:11,180
当然，这篇论文是在单核硬件上运行的，
certainly this paper is running on single core hardware,

857
00:50:11,180 --> 00:50:12,770
所以 P1 将会，
so P1 is gonna,

858
00:50:13,040 --> 00:50:15,440
P1 执行， P1 不执行，
P1 executing and P1 not executing

859
00:50:15,440 --> 00:50:17,510
直到 P1 最终获得 CPU ，
until P1 finally gets up the CPU

860
00:50:17,510 --> 00:50:20,300
recv 等待这里出现的消息，
and recv waiting for a message to appear here

861
00:50:20,480 --> 00:50:23,780
并且只有到那时， P2 才能被调度，调用 recv ，
and only then will P2 be scheduled maybe to call recv,

862
00:50:24,320 --> 00:50:25,670
recv 复制消息，
recv copy the message

863
00:50:25,700 --> 00:50:28,970
然后 P2 调用它的 send ，
and then P2 make it's called to send,

864
00:50:32,800 --> 00:50:34,120
追加其回复。
to append its reply.

865
00:50:36,110 --> 00:50:38,630
然后 send 系统调用返回到 P2 ，
And then the send system call return to P2

866
00:50:38,630 --> 00:50:41,150
在某一时刻， P2 可能会让出 CPU ，
and at some point, presumably P2 will give up to CPU,

867
00:50:41,180 --> 00:50:42,530
可能是计时器响起，
maybe the timer will go off,

868
00:50:42,830 --> 00:50:45,890
然后 P1 将在内核中恢复执行，
then P1 will resume execution in the kernel,

869
00:50:46,190 --> 00:50:47,780
看到那里有一条消息，
see there's a message there

870
00:50:47,780 --> 00:50:49,370
然后返回到用户空间，
and return back to user space

871
00:50:50,330 --> 00:50:51,530
所以这意味着，
and so that means that,

872
00:50:51,530 --> 00:50:54,080
这个设计是缓慢的设计。
this design is slow design.

873
00:50:54,990 --> 00:50:59,010
为了得到请求和响应，
There's in order to have a request and a response,

874
00:50:59,430 --> 00:51:06,510
需要四个系统调用，两个 send ，两个 recv ，
there's four system calls, two sends, and two recvs,

875
00:51:06,690 --> 00:51:08,920
每一次用户内核穿越，
you know each user kernel crossings,

876
00:51:08,920 --> 00:51:11,080
每一次都相当昂贵，
each one of which is reasonably expensive,

877
00:51:11,380 --> 00:51:13,990
这里需要休眠，
there's a need to sleep,

878
00:51:14,110 --> 00:51:17,770
这个 recv 必须休眠，等待数据出现，
this recv has to sleep, waiting for data to appear,

879
00:51:18,040 --> 00:51:21,100
有一个完整调用调度器循环，
and there's a full call the scheduler loop

880
00:51:21,100 --> 00:51:23,590
以及从 P1 到 P2 的上下文切换，
and a context switch from P1 to P2,

881
00:51:24,100 --> 00:51:25,180
才能实现这个。
in order to make this.

882
00:51:25,180 --> 00:51:29,770
每个内核穿越和上下文切换都可能是昂贵的，
And you know each of these kernel crossings and context switch is potentially expensive,

883
00:51:29,770 --> 00:51:32,800
因为你每次跨越内核用户边界时，
because you know every time you cross the kernel user boundary,

884
00:51:32,800 --> 00:51:34,360
你交换页表，
you switch page tables

885
00:51:34,540 --> 00:51:37,360
那个，
and that is,

886
00:51:37,930 --> 00:51:42,640
它几乎肯定会扰乱 CPU 缓存，
it has a near certainty of disturbing the CPU caches,

887
00:51:42,640 --> 00:51:44,410
比如更改页表，
like changing the page table,

888
00:51:44,500 --> 00:51:49,240
可能会刷新 TLB ，虚拟内存查找缓存，
probably flushes the TLB, the virtual memory lookup cache,

889
00:51:49,240 --> 00:51:50,530
这会让事情变慢。
which is going to slow things down.

890
00:51:52,220 --> 00:51:55,980
所以，这是一种相当慢的方式，
So, this is a pretty slow way to go

891
00:51:56,070 --> 00:51:58,890
涉及大量内核穿越消息，
involves a lot of kernel crossings message,

892
00:51:58,890 --> 00:52:01,050
在用户和内核之间复制消息，
copying of messages between user and kernel,

893
00:52:01,110 --> 00:52:03,810
可能分配缓冲区等等，
maybe allocation of buffers etc,

894
00:52:04,830 --> 00:52:06,060
但事实证明，
but it turns out that,

895
00:52:06,060 --> 00:52:08,520
对于这个[]案例，
for the, for this [] case,

896
00:52:08,520 --> 00:52:11,250
你发送请求，并且希望得到响应，
in which you're sending a request and you want to get a response back,

897
00:52:11,370 --> 00:52:17,610
你可以将其简化为相当简单的设计，
you can strip this down to considerably simpler design

898
00:52:17,970 --> 00:52:20,310
事实上，这就是它前进的方向。
and in fact, this is the way it forward.

899
00:52:21,870 --> 00:52:24,840
这是在一份著名的论文上发表的，
And this was laid out in a famous paper,

900
00:52:25,080 --> 00:52:27,570
称为通过内核设计改进 IPC ，
called improving IPC by kernel design

901
00:52:27,720 --> 00:52:30,450
在今天的论文前几年发表。
published a few years before today's paper.

902
00:52:34,670 --> 00:52:36,890
所以它做了几件不同的事情，
So it does a couple things differently,

903
00:52:36,950 --> 00:52:40,400
首先，它是同步的。
for one thing, it's synchronous.

904
00:52:42,330 --> 00:52:43,320
这就是，
That is,

905
00:52:44,700 --> 00:52:51,300
这里没有丢弃任何东西，
there's none of this, there's no dropping something off

906
00:52:51,300 --> 00:52:52,590
返回并等待，
and returning and waiting,

907
00:52:52,740 --> 00:52:56,190
让另一个进程提取数据，
letting the other guy, letting the other process pick up the data,

908
00:52:56,520 --> 00:52:57,420
它感觉像，
when it feels like,

909
00:52:57,420 --> 00:53:02,730
不是 send 等待 recv 和 recv 等待 send 。
instead send waits for receive and receive waits for send.

910
00:53:02,730 --> 00:53:08,430
所以， P1 想要发送，我调用 send ，
So, one process one and I want to send and I call send,

911
00:53:11,280 --> 00:53:14,520
它不会将我的消息复制到缓冲区，
it doesn't copy my message into a buffer,

912
00:53:14,520 --> 00:53:17,790
P1 现在直接，
it actually P1 will now immediately,

913
00:53:17,790 --> 00:53:21,800
如果 P1 在 L4 内核中发送，
if the P1 send in the L4 kernel,

914
00:53:21,800 --> 00:53:24,290
等待 P2 调用 recv ，
waits for P2 to call recv

915
00:53:24,470 --> 00:53:28,460
并且如果 P2 已经在内核中等待调用 recv ，
and if P2 is already in the kernel waiting in a call to recv,

916
00:53:28,670 --> 00:53:33,910
P2 要么已经在内核中，等待调用 recv ，
well P2 is either already in the kernel, waiting in a call to recv

917
00:53:34,300 --> 00:53:37,270
或者 P1 send 并等待，
or P1 send and wait for it,

918
00:53:37,300 --> 00:53:39,340
等待 P2 的下一个调用 recv ，
wait for P2's next call to recv,

919
00:53:39,370 --> 00:53:42,280
当两者都到达这里时，
when both have arrived here,

920
00:53:42,430 --> 00:53:46,190
当 P1 在内核中，它调用 send ，
when P1 is, in the kernel and it's called a send,

921
00:53:46,190 --> 00:53:47,990
P2 在内核中，调用 recv ，
P2's in the kernel is called to recv,

922
00:53:48,050 --> 00:53:49,670
只有那时才会有事情发生，
only then does anything happen,

923
00:53:49,790 --> 00:53:55,510
这个速度快的原因之一是，
and one reason this is fast is that,

924
00:53:55,810 --> 00:53:57,610
如果 P2 已经在 recv ，
if P2 is already in recv,

925
00:53:57,610 --> 00:54:01,910
然后 P1 ，当它在内核中执行 send 时，
then P1, when it's executing send in the kernel,

926
00:54:01,940 --> 00:54:07,490
可以没有上下文切换或通用调度，
can just without a context switch or a general purpose scheduling,

927
00:54:07,550 --> 00:54:11,880
可以直接跳回 P2 的用户空间，
can just jump back into user space in P2,

928
00:54:11,910 --> 00:54:15,260
就像是从这个 recv 返回，
as if it was returning from this receive, right,

929
00:54:15,260 --> 00:54:17,480
这是一条通过内核的更快的路径，
and that's a much faster path through the kernel,

930
00:54:17,570 --> 00:54:22,850
比起保存寄存器，放弃 CPU ，调用调度器，
than you know saving registers, giving up the CPU calling the scheduler

931
00:54:23,210 --> 00:54:25,160
并找到一个新的进程来运行，
and finding a new process to run,

932
00:54:25,160 --> 00:54:29,750
相反， P1 send 知道有等待的 recv ，
instead P1 send knows that there's a waiting recv,

933
00:54:29,870 --> 00:54:35,300
然后立刻跳到了 P2 ，
and just sort of immediately jumps into P2,

934
00:54:35,930 --> 00:54:37,610
就像它是从 recv 返回一样。
as if it was returning from recv.

935
00:54:39,080 --> 00:54:43,460
他们开发的方案也是无缓冲的，
The scheme that they developed is also unbuffered,

936
00:54:47,540 --> 00:54:48,920
它可以部分做到这一点，
and it could do that partially,

937
00:54:48,920 --> 00:54:50,660
因为它是同步的，
because it's synchronous,

938
00:54:52,220 --> 00:54:55,160
当 send 和 recv 都在内核中，
when both the send and recv are in the kernel,

939
00:54:55,220 --> 00:54:57,650
信息可以，
the message can be,

940
00:54:58,040 --> 00:54:59,870
send 发送一些信息，
you know send sending some message,

941
00:55:00,780 --> 00:55:04,950
内核可以直接将消息从用户空间复制到用户空间，
the kernel can directly copy the message from user space to user space,

942
00:55:04,950 --> 00:55:08,250
而不必首先复制到内核中，然后再从内核中返回，
without having to first copy into the kernel, and then back out of the kernel,

943
00:55:08,430 --> 00:55:13,050
由于双方都在等待对方的系统调用，
because because since both sides wait for the other system call,

944
00:55:13,050 --> 00:55:13,950
发生的事，
what happened,

945
00:55:14,040 --> 00:55:17,880
这意味着它们在等待这两个指针已经知道，
that means that they've waited for both pointers to be known,

946
00:55:17,880 --> 00:55:21,970
recv 指定它希望将消息存放在何处，
recv specifies where it wants the message to be deposited,

947
00:55:22,060 --> 00:55:22,990
所以，在这一点上，
so at this point,

948
00:55:23,260 --> 00:55:26,170
我们知道这两个地址，然后内核可以直接复制，
we know both addresses, then kernel just do the copy directly,

949
00:55:26,200 --> 00:55:27,970
而不是通过内核。
instead of through the kernel.

950
00:55:29,160 --> 00:55:35,510
如果消息非常小，
For and if the message is super small,

951
00:55:35,510 --> 00:55:37,310
可能只有几十个字节，
like maybe only a few dozen bytes,

952
00:55:37,340 --> 00:55:42,200
然后，它可以在没有任何复制的情况下在寄存器中传递，
then it can be passed in registers without any copy at all,

953
00:55:45,270 --> 00:55:46,830
你可以称之为零拷贝。
what you might call zero copy.

954
00:55:49,810 --> 00:55:53,740
请记住，只有当 P2 已经处于 recv 状态时， send 才会继续，
Remember the send only proceeds if the P2 is already in recv

955
00:55:53,740 --> 00:55:56,680
send 直接跳转到 P2 ，
and send basically jumps directly to P2,

956
00:55:56,770 --> 00:55:59,230
这条通过内核的代码路径
well this code path to the kernel

957
00:55:59,530 --> 00:56:03,550
注意不会干扰一堆寄存器，
takes care to not disturb a bunch of registers

958
00:56:03,790 --> 00:56:06,400
这意味着 P1 可以把它的系统调用，
and that means that P1 can put its system call,

959
00:56:06,430 --> 00:56:07,900
如果消息很短，
if the message is short,

960
00:56:07,990 --> 00:56:11,680
它可以把消息放在某些指定的寄存器中，
it can put the message in certain designated registers,

961
00:56:11,680 --> 00:56:16,240
内核保证在 P2 之前保留这些寄存器，
the kernel guarantees to preserve those registers on its way up to P2

962
00:56:16,240 --> 00:56:17,050
这意味着，
and that means that,

963
00:56:18,370 --> 00:56:23,440
当内核作为 send 的结果从 recv 系统调用返回时，
when the kernel returns from the recv system call as a result of send,

964
00:56:23,680 --> 00:56:27,790
这些指定寄存器的内容保存了那个消息，
the contents of those designated registers hold the message

965
00:56:28,120 --> 00:56:31,480
根本不需要从一个内存复制到另一个内存，
and therefore never had to be copied at all from memory to memory,

966
00:56:31,900 --> 00:56:33,160
根本不用移动，
never had to be moved at all,

967
00:56:33,160 --> 00:56:34,690
它们只是在寄存器中，
they're just sitting right in the registers,

968
00:56:34,690 --> 00:56:36,430
在那里它们可以非常快地被访问。
where they can be accessed very quickly.

969
00:56:38,770 --> 00:56:41,470
这当然只适用于小信息，
And this you know of course only works for small messages,

970
00:56:41,980 --> 00:56:49,200
对于非常大的消息， L4 可以在 IPC 消息中携带页面映射，
for very large messages, L4 can carry a page mapping in IPC message,

971
00:56:49,200 --> 00:56:51,150
所以对于巨大的信息来说，
so for huge messages,

972
00:56:53,600 --> 00:56:57,320
比如从文件里读取块之类的结果，
you know like the result of reading a block from a file or something,

973
00:56:59,840 --> 00:57:03,260
你可以只发送将映射到目标地址空间的页面，
you could just send the pages will be mapped into the target address space,

974
00:57:03,260 --> 00:57:05,420
同样不需要任何复制。
again without any copy.

975
00:57:06,390 --> 00:57:08,850
所以它是通过页面映射来完成的，
And so it's done through page mapping,

976
00:57:09,330 --> 00:57:10,770
提供页面，
give away the page

977
00:57:11,540 --> 00:57:17,290
或提供访问权限以共享页面。
or access [], access to this permission to share the page.

978
00:57:18,390 --> 00:57:20,100
所以小消息是快的，
And so small messages are fast,

979
00:57:20,580 --> 00:57:22,380
大消息也是相当快的，
huge messages are pretty fast,

980
00:57:22,380 --> 00:57:24,420
你仍然需要根据目标调整页表，
you still have to adjust the page table to target,

981
00:57:24,420 --> 00:57:26,280
但这比复制要快得多。
but that's much faster than copying.

982
00:57:27,180 --> 00:57:30,150
L4 玩的最后一个把戏是，
And final trick that L4 played was

983
00:57:30,270 --> 00:57:34,920
注意，如果你正在对请求和响应执行 RPC ，
noticing that if you're doing an RPC with the request and response,

984
00:57:35,040 --> 00:57:42,380
是非常程式化的对等的系统调用，
are very stylized peers of system calls

985
00:57:42,380 --> 00:57:44,900
你也可以将系统调用合并起来，
and you may as well combine system calls

986
00:57:44,930 --> 00:57:48,650
合并 send 和 recv 系统调用，以减少内核穿越，
send and recv system calls in order to reduce kernel crossing,

987
00:57:48,650 --> 00:57:51,260
所以，对于 RPC 的特殊情况，
so for the special case of RPC,

988
00:57:51,260 --> 00:57:54,930
这几乎总是人们在做的事情，
which is almost always what people are doing,

989
00:57:55,500 --> 00:57:56,580
当他们使用 IPC 时，
when they're using IPC,

990
00:57:56,580 --> 00:57:58,680
这里有一个 call 系统调用，
there was a call system call,

991
00:58:00,790 --> 00:58:06,470
call 基本上是 send 加 recv 的组合，
and the call was basically combined send plus receive,

992
00:58:08,640 --> 00:58:10,680
但是没有返回到用户空间，
but without the return to user space,

993
00:58:10,680 --> 00:58:13,260
然后重新进入内核空间，
and then re-entry into kernel space,

994
00:58:13,260 --> 00:58:17,090
这是一对系统调用执行的，
that a pair of system calls take,

995
00:58:17,300 --> 00:58:19,100
在服务器端，
on the server side,

996
00:58:19,100 --> 00:58:22,230
只有一个调用，
there was a a single call

997
00:58:22,230 --> 00:58:27,270
可以发送来自一个系统调用的应答，
that would send the reply from one system call

998
00:58:27,270 --> 00:58:33,850
然后等待来自任何人的下一次系统调用的请求消息。
and then wait for the request message from anyone for the next system call.

999
00:58:34,690 --> 00:58:37,660
这是一个回应的发送，
And this is basically a send of one response,

1000
00:58:37,660 --> 00:58:40,420
但是等待接收下一个请求，
but wait to receive the next request,

1001
00:58:40,600 --> 00:58:43,270
这又一次将内核穿越的数量减少了一半，
and this again cut in half the number of kernel crossings

1002
00:58:44,500 --> 00:58:45,880
事实证明，
and it turned out that,

1003
00:58:46,000 --> 00:58:49,900
所有这些优化的总和，
the sum of all of these optimizations,

1004
00:58:49,930 --> 00:58:52,420
现在对于较短的 RPC ，
now for the kind of short RPCs

1005
00:58:52,420 --> 00:58:57,210
它是一个典型的工作负载，
which are you know one typical workload,

1006
00:58:57,360 --> 00:59:02,120
所有这些会导致加速 20 倍。
all this led to a 20x speedup.

1007
00:59:02,990 --> 00:59:04,640
这是他们的论文所说的，
This is what their paper reported,

1008
00:59:04,640 --> 00:59:06,530
比以前的系统快了 20 倍，
20x speedup over there previous system,

1009
00:59:06,530 --> 00:59:10,880
大概有点像我在之前的设计中展示的。
which was presumably a little bit more like what I showed in a previous design.

1010
00:59:12,880 --> 00:59:14,320
所以这是一个令人印象深刻的，
And so this was an impressive,

1011
00:59:15,980 --> 00:59:19,910
这篇论文是在几年前由一些相同的作者发表的，
this paper came out a few years before the by some of the same authors,

1012
00:59:19,910 --> 00:59:21,440
但在人们阅读之前的几年，
but few years before the people were reading,

1013
00:59:21,440 --> 00:59:26,990
这让人们对微内核有了更多的好感。
and this caused people to view micro kernels a little bit more favorably.

1014
00:59:27,780 --> 00:59:30,150
IPC 是可以相当快的。
The IPC could actually be quite fast.

1015
00:59:32,240 --> 00:59:37,450
关于 L4 玩的这些 IPC 技巧，有什么问题吗？
Any questions about these IPC tricks that L4 plays?

1016
00:59:39,340 --> 00:59:40,990
是的，我想我错过了这个，
Yeah, I I think I missed this,

1017
00:59:40,990 --> 00:59:46,720
但是，当进程发送有接收消息时，
but, when is a process sending there are receiving messages,

1018
00:59:46,900 --> 00:59:48,700
它什么时候在使用那个系统调用？
like when is it using that system call?

1019
00:59:50,200 --> 00:59:53,830
好的，实际上，对于 RPC ，对于请求响应，
Okay, actually, so for RPCs, for request response,

1020
00:59:53,860 --> 01:00:01,540
事实上，进程使用这对系统调用，
in fact, in fact, the the processes use this pair of of system calls

1021
01:00:01,570 --> 01:00:03,850
而不是 send 和 recv 。
rather than send and secv.

1022
01:00:04,420 --> 01:00:07,330
所以，是的， call 有两个参数，
So yeah, call you really get two arguments,

1023
01:00:07,330 --> 01:00:11,200
你要发送的消息和放置响应的位置，
message you want to send and a place to put the response

1024
01:00:11,320 --> 01:00:13,270
在内核内部，只是将这两者结合起来，
and inside the kernel just combines these two,

1025
01:00:13,570 --> 01:00:15,370
你可以认为这是一种 hack ，
you could view this is a bit of a hack,

1026
01:00:15,370 --> 01:00:19,510
但由于 IPC 非常频繁，
but because IPC is so frequent,

1027
01:00:20,160 --> 01:00:24,590
它值得使用一些 hack 来让它更快。
it's worth a little bit of hack in order to make it fast.

1028
01:00:25,340 --> 01:00:28,070
在上面的图表里，在方框中，
And in the diagram up there, in the box,

1029
01:00:28,070 --> 01:00:32,390
你让 P2 运行 recv 系统调用，
where you have P2 sending that are running the recv system call,

1030
01:00:32,510 --> 01:00:35,480
是什么促使 P2 。
why, what prompted P2 to.

1031
01:00:37,280 --> 01:00:40,130
好的，在我的 RPC 世界里，
Okay it in in my RPC world,

1032
01:00:40,190 --> 01:00:42,050
我们有客户端，
we got, we have clients,

1033
01:00:43,840 --> 01:00:46,240
它们向服务器发送请求，
and they're sending requests to servers,

1034
01:00:49,940 --> 01:00:51,710
服务器将做一些回应，
and the server is going to do something in reply,

1035
01:00:51,710 --> 01:00:53,690
所以既然 P2 是服务器，
so since P2 is the server,

1036
01:00:53,690 --> 01:00:56,180
我们想象 P2 处于 while 循环中，
we imagine that P2 is sitting in a while loop,

1037
01:00:56,210 --> 01:00:59,930
它将从任何客户端接收下一条消息，
in which, in which it's going to receive the next message from any client,

1038
01:00:59,990 --> 01:01:01,580
做一点工作来处理它，
do a little bit of work to process it,

1039
01:01:01,580 --> 01:01:03,350
在数据库中查找一些数据或其他操作，
you know look up some data in a database or something,

1040
01:01:03,350 --> 01:01:04,460
然后发送回复，
and then send a reply

1041
01:01:04,490 --> 01:01:06,590
返回到循环的顶部并再次等待，
and go back to the top of the loop and wait again,

1042
01:01:06,800 --> 01:01:08,690
所以最接近的情况是，
so to first [approximation],

1043
01:01:08,690 --> 01:01:15,500
我们希望 P2 会把所有的时间都花在等待来自任何人的下一条消息上，
we expect P2 spends all its time waiting for the next message from anyone,

1044
01:01:15,860 --> 01:01:17,090
可以从任何人那里请求。
that can request from anyone.

1045
01:01:19,170 --> 01:01:21,060
这个设计确实，
And this design really,

1046
01:01:23,560 --> 01:01:26,200
它有点依赖于 P2 ，
it does kind of rely on P2 always

1047
01:01:26,380 --> 01:01:27,610
当它在其他时间，
and when it's at rest,

1048
01:01:27,610 --> 01:01:29,020
就是在内核中，
basically sitting in the kernel

1049
01:01:29,050 --> 01:01:33,460
在一个 recv 系统调用上，等待下一个请求，
in a recv system call waiting for the next request,

1050
01:01:33,460 --> 01:01:40,030
所以下一个请求可以直接从该系统调用返回。
so that the next request can directly basically return from that system call.

1051
01:01:40,560 --> 01:01:42,150
这是一条捷径，
And that's the fast path,

1052
01:01:42,210 --> 01:01:44,550
在这个设计中是非常高效的。
that's super efficient in this design.

1053
01:01:48,560 --> 01:01:50,000
抱歉，我只是想跟进一下，
Sorry, just to follow up on that,

1054
01:01:50,540 --> 01:01:51,410
也就是说，
that means that,

1055
01:01:51,800 --> 01:01:55,340
你说它来自 P1 返回 P2 ，
you said that it goes from P1 and returns to P2,

1056
01:01:55,950 --> 01:01:57,210
所以想要回来，
so like to come back,

1057
01:01:57,330 --> 01:02:00,300
你需要回复，所以。
you would need to send a response, so.

1058
01:02:00,870 --> 01:02:05,100
是的，我们希望 P2 会发送一个响应，
That's right, we expect P2 to send a response,

1059
01:02:05,540 --> 01:02:10,250
并且响应的发送反向遵循基本相同的代码路径，
and that sending of the response actually follows basically the same code path in reverse,

1060
01:02:10,250 --> 01:02:12,050
当 P2 发送响应时，
that when P2 sends a response,

1061
01:02:14,240 --> 01:02:17,660
有效地使 P1 返回，
that that effectively causes P1 to return from,

1062
01:02:18,320 --> 01:02:21,020
我是说， P1 实际上是在调用 call 系统调用，
I mean, P1 was actually making this call system call,

1063
01:02:21,230 --> 01:02:25,460
所以， P2 响应的传递导致 call ，
so the delivery of P2's response causes the call,

1064
01:02:25,490 --> 01:02:28,310
返回从这个系统调用回到 P1 。
the return from this from this system call back into P1.

1065
01:02:29,530 --> 01:02:31,660
好的，我明白了，谢谢。
Okay, I see, thank you.

1066
01:02:31,960 --> 01:02:34,150
这与通常的设置略有不同，
This is a little bit different from the usual setup,

1067
01:02:34,150 --> 01:02:37,420
你认为可以跳转到内核和系统调用，
where you think you jump into the kernel and system call

1068
01:02:37,420 --> 01:02:38,530
你执行该系统调用，
and you execute that system call

1069
01:02:38,530 --> 01:02:41,410
它将返回代表 P1 的所有工作，
and it returns sort of all working on behalf of P1

1070
01:02:41,470 --> 01:02:43,480
这是管道读写工作的方式，
which is the way pipe read write work,

1071
01:02:43,600 --> 01:02:46,180
这里，你知道 P1 进入内核，
here, you know P1 is entering the kernel,

1072
01:02:46,750 --> 01:02:48,280
P1 进入内核，返回却是 P2 .
P1 entering the kernel,

1073
01:02:49,130 --> 01:02:51,380
and you know that the return goes to P2,

1074
01:02:53,540 --> 01:02:55,880
有点奇怪，但速度很快。
kind of odd, but very fast.

1075
01:03:02,540 --> 01:03:11,540
好的，所以这是对人们使用微内核的一种很大的贡献，
Okay, so this was a big big sort of contribution to people taking micro kernels,

1076
01:03:13,780 --> 01:03:15,250
人们愿意使用微内核
people's willingness to take micro kernel

1077
01:03:15,250 --> 01:03:20,620
作为宏内核的潜在替代品，
seriously as potential replacement for a monolithic kernels,

1078
01:03:20,620 --> 01:03:24,340
但是，你仍然需要解决这个问题，
however you know that you still have to still leave [] the question,

1079
01:03:24,340 --> 01:03:25,420
即使 RPC 很快，
even if RPC is fast,

1080
01:03:25,420 --> 01:03:27,520
比如你从哪里得到操作系统的其他部分，
like where you get the rest of the operating system,

1081
01:03:28,720 --> 01:03:31,390
内核只有百分之几的所有东西，
like this kernel only has a few percent of all the stuff,

1082
01:03:31,390 --> 01:03:32,890
比如文件系统和网络堆栈，
like file systems and network stacks,

1083
01:03:32,890 --> 01:03:35,290
我们希望使用完整的操作系统。
we expect to be in a full operating system.

1084
01:03:35,700 --> 01:03:36,900
其他的部分，我们该怎么办，
What do we do about the rest

1085
01:03:37,740 --> 01:03:42,660
这个问题通常在大学研究项目的背景下提出，
and this question is usually being asked in the context of some university research project

1086
01:03:42,660 --> 01:03:44,670
他们资源相对有限，
with relatively limited resources,

1087
01:03:46,890 --> 01:03:50,550
我们需要从某个地方获得所有这些用户级别的服务。
we need to get all those user level servers from somewhere.

1088
01:03:51,060 --> 01:03:54,780
实际上，有一些专门的应用程序，
Actually there are specialized applications

1089
01:03:54,780 --> 01:03:56,430
这不是一个太大的问题，
for which that's not too much of a problem,

1090
01:03:56,430 --> 01:04:01,110
如果我们运行的是某种设备，控制器，
if we're running you know some sort of device you know controller,

1091
01:04:01,110 --> 01:04:05,980
或者你的车的点火控制系统，
or maybe the you know ignition control system for your car,

1092
01:04:05,980 --> 01:04:09,430
这只运行了几千行代码，
that is only running a few thousand lines of code anyway,

1093
01:04:09,430 --> 01:04:11,650
可能只需要一个文件系统，
maybe just need a file system,

1094
01:04:12,340 --> 01:04:14,830
然后，我们可以在用户级别使用很少的东西，
then we can get away with very little stuff at user level

1095
01:04:14,830 --> 01:04:18,520
微内核对于这类应用来说完全是有意义的，
and micro kernels totally makes sense for that kind of application,

1096
01:04:18,850 --> 01:04:20,560
但是人们，
but but the people,

1097
01:04:21,140 --> 01:04:23,330
当这些项目真的有目标的时候，
you know when these projects really they had ambitions,

1098
01:04:23,330 --> 01:04:27,320
使用它完全取代现有的操作系统，
that oh gosh going to totally replace existing operating systems,

1099
01:04:27,320 --> 01:04:29,300
他们希望能构建一些东西，
and they hoped that they could build something,

1100
01:04:29,300 --> 01:04:32,330
人们想要在他们的工作站上运行的东西，
that people would want to run on their on their workstations

1101
01:04:32,330 --> 01:04:33,890
在他们的服务器上运行，无处不在，
and run on their servers and everywhere,

1102
01:04:33,890 --> 01:04:36,590
完全替换大的宏内核，
just replace big monolithic kernels altogether,

1103
01:04:37,100 --> 01:04:39,320
但是要做到这一点，你需要一个真正的，
and but for that you know you need a real,

1104
01:04:39,320 --> 01:04:41,660
你需要操作系统所能做的所有东西。
you need all the stuff that an operating system does.

1105
01:04:43,280 --> 01:04:49,640
一种可能性，更多是一种哲学上的可能性，
One possibility, the most maybe sort of philosophically consistent possibility

1106
01:04:49,640 --> 01:04:53,540
就是重新实现你需要的一切，
would be to re-implement everything you need,

1107
01:04:53,540 --> 01:04:56,240
而是以一种微内核的方式，
but in a sort of micro kernel way

1108
01:04:56,240 --> 01:04:59,150
就像大量不同的用户级进程，
as lots and lots of different user level processes,

1109
01:04:59,420 --> 01:05:01,070
但那只是，
but that's just,

1110
01:05:01,830 --> 01:05:04,890
实际上人们，有很多项目都是这么做的，
actually people, there were projects did that,

1111
01:05:04,890 --> 01:05:06,870
但这是一项繁重的工作，
but it's a vast amount of work

1112
01:05:07,710 --> 01:05:11,160
更具体地说，人们真的想运行，
and more specifically, people really want to run,

1113
01:05:11,190 --> 01:05:13,570
为了让我使用笔记本电脑，
you know, in order for me to use a laptop,

1114
01:05:13,600 --> 01:05:15,580
它必须运行 Emacs ，
it just has to run Emacs

1115
01:05:15,970 --> 01:05:18,460
它必须运行我最喜欢的 C 编译器，
and it has to run my favorite C compiler,

1116
01:05:18,520 --> 01:05:21,490
否则我绝对不会切换到你们的操作系统。
otherwise I'm just definitely not going to switch to your operating system.

1117
01:05:22,040 --> 01:05:26,390
这意味着微内核要想获得任何形式的采用，
And what that meant is that micro kernels in order for to gain any kind of adoption,

1118
01:05:26,390 --> 01:05:29,090
它们必须能够支持现有的应用程序，
they had to be able to support existing applications,

1119
01:05:29,330 --> 01:05:31,280
它们必须能够兼容，
they had to be able to be compatible,

1120
01:05:31,400 --> 01:05:39,740
提供完全相同的或者至少在更高级别的 API 上相同的系统调用，
provide identical or at least the system call at the higher level service API level,

1121
01:05:39,740 --> 01:05:41,570
它们必须完全兼容
they had to be totally compatible with

1122
01:05:41,570 --> 01:05:44,390
一些现有的操作系统，比如 Unix Linux ，
some exist operating system, like Unix like Linux,

1123
01:05:44,480 --> 01:05:47,180
为了让任何人都愿意换。
in order for anybody to be willing to switch.

1124
01:05:47,920 --> 01:05:51,280
所以这些项目面临着一个更具体的问题，
So these projects face a more specific problem of

1125
01:05:51,280 --> 01:05:52,480
它们将如何得到，
how they were going to get,

1126
01:05:52,540 --> 01:05:57,940
它们如何实现与现有应用程序的兼容性，
how are they going to attain compatibility with existing applications

1127
01:05:57,940 --> 01:06:00,070
为 Linux 或 Windows 或其他平台编写的应用程序，
written for Linux or maybe Windows or something,

1128
01:06:00,070 --> 01:06:02,830
但是对于这个项目来说，是 Linux ，
but for this project, it was Linux,

1129
01:06:03,970 --> 01:06:08,760
不是编写他们自己的全新的用户级服务器，
and rather than write their own totally new set of user level servers,

1130
01:06:08,760 --> 01:06:12,510
它们模仿 Linux ，他们决定走一条更容易的路，
they mimic Linux, they decided to take a far easier path

1131
01:06:12,540 --> 01:06:13,740
很多项目都是这样做的，
and many projects did this,

1132
01:06:13,740 --> 01:06:22,920
直接在他们的微内核上运行已有的宏内核，
of simply directly running an existing monolithic kernel as on top of their micro kernel,

1133
01:06:23,930 --> 01:06:25,700
而不是重新实现一些新的东西，
instead of re-implementing some new thing

1134
01:06:25,850 --> 01:06:28,700
这正是今天论文的主题。
and says that's exactly what today's paper is about.

1135
01:06:31,340 --> 01:06:38,370
事实上， L4 微内核在底部，
It has, indeed, you know L4 micro kernel down at the bottom,

1136
01:06:42,860 --> 01:06:46,190
但也像一个相当大的服务器，
but also as like a pretty big server,

1137
01:06:46,460 --> 01:06:53,710
它们将完整的 Linux 内核作为用户级进程运行，
they run a pretty full Linux kernel as a user level process,

1138
01:06:54,420 --> 01:06:57,210
这听起来可能有点令人惊讶，
and so, that may sound a little surprising,

1139
01:06:57,210 --> 01:07:00,000
内核不是用户级进程，内核就是内核，
the kernel is not a user level process right, the kernel is the kernel,

1140
01:07:00,930 --> 01:07:02,580
你认为它是在硬件上运行的，
you think of it as running on the hardware,

1141
01:07:02,580 --> 01:07:05,190
但实际上 Linux 内核，
but in fact you know Linux kernel

1142
01:07:05,220 --> 01:07:08,610
如你所见，在 QEMU 中运行 xv6 ，
as you can see from running xv6 in QEMU,

1143
01:07:08,610 --> 01:07:10,530
就是在用户空间中运行的，
which is running in user space after all,

1144
01:07:11,190 --> 01:07:12,870
内核只是一个程序，
a kernel is just a program

1145
01:07:12,900 --> 01:07:14,880
所以，只要稍加修改，
and so with some modifications,

1146
01:07:14,940 --> 01:07:18,900
它就可以在用户级别运行，
it can be made to run at user level,

1147
01:07:19,200 --> 01:07:21,030
所以他们必须修改 Linux ，
and so they had to modify Linux

1148
01:07:21,030 --> 01:07:24,480
他们在 Linux 中使用了很多低级的东西，
and they took a lot of the low-level stuff in Linux,

1149
01:07:24,480 --> 01:07:25,890
比如 Linux 中的代码，
for example of the code in Linux,

1150
01:07:25,890 --> 01:07:28,590
期望能够直接修改页表
that expects to be able to directly modify page tables

1151
01:07:28,590 --> 01:07:31,290
或读写处理器寄存器，
or read and write processor registers,

1152
01:07:31,440 --> 01:07:33,720
他们需要修改一些低级别的东西，
there were some low-level stuff they had to modify,

1153
01:07:34,230 --> 01:07:36,210
Linux 的某些部分必须改变，
some parts of Linux had to change,

1154
01:07:37,820 --> 01:07:41,270
为了将它们转换为进行系统调用，
in order to convert them to basically make system calls

1155
01:07:41,270 --> 01:07:45,740
或者通过 L4 发送 IPC 消息，而不是直接访问硬件，
or send IPC messages through L4 instead of directly get at hardware,

1156
01:07:45,980 --> 01:07:47,060
但在很大程度上，
but for the most part,

1157
01:07:47,210 --> 01:07:50,930
它们可以直接运行几乎所有 Linux ，而不需要修改，
they were able to directly run, without change, almost all of Linux,

1158
01:07:50,930 --> 01:07:53,330
所以这意味着他们得到 Linux 的一部分，
so that means they got as part of Linux,

1159
01:07:53,390 --> 01:07:59,210
文件系统和网络支持以及各种设备驱动程序，
you know file system and network support and all kinds of device drivers,

1160
01:08:00,810 --> 01:08:02,610
Linux 带来的东西，
who knows what that comes with Linux,

1161
01:08:03,380 --> 01:08:06,760
而不必编写他们自己的版本。
without having to write their own version of this.

1162
01:08:08,230 --> 01:08:11,590
事实上，这个设置的方式是，
You know, in fact the way this was set up was,

1163
01:08:11,590 --> 01:08:17,740
Linux 内核作为一个 L4 任务运行，
that Linux, the Linux kernel ran as one L4 task,

1164
01:08:18,610 --> 01:08:23,110
但是每个 Linux 进程作为单独的 L4 任务运行，
but each Linux process ran as a separate L4 task,

1165
01:08:23,110 --> 01:08:25,350
当您登录到这个 Linux 时，
when you log into this Linux

1166
01:08:25,350 --> 01:08:28,650
你让它为你运行一个 shell ，一个终端窗口或其他东西，
and you ask it to run a shell for you, a terminal window or something,

1167
01:08:28,770 --> 01:08:31,740
它将启动一个 L4 任务，
it's going to fire up an L4 task,

1168
01:08:32,260 --> 01:08:35,470
它将在用户级别运行 Linux 程序，
that's going to run that Linux program at user level,

1169
01:08:36,760 --> 01:08:38,410
所以这里 Linux 有一个任务，
so there were one task for Linux

1170
01:08:38,410 --> 01:08:44,670
以及在 Linux 下启动的每个 Linux 进程都有一个任务，
and one task for each Linux process that you fire up under Linux

1171
01:08:44,670 --> 01:08:53,580
Linux 不是直接修改 VI 进程使用的页表，
and Linux instead of directly modifying the page table the VI, VI process uses,

1172
01:08:53,670 --> 01:08:57,840
Linux 将发送写 IPC 给 L4 ，
Linux is going to ask send the write IPC to L4

1173
01:08:57,840 --> 01:09:01,080
以使 L4 修改 VI 的页表。
to cause L4 to change VI's page table.

1174
01:09:05,060 --> 01:09:08,980
关于这里的基本方案，有什么问题吗？
Any questions about that, about the basic scheme?

1175
01:09:14,120 --> 01:09:18,350
另一件事改变的事，
Another thing to, another thing that was changed,

1176
01:09:18,650 --> 01:09:20,030
很多小事都变了，
many small things were changed,

1177
01:09:20,030 --> 01:09:23,660
但是，有一件特别有趣的事情是，
but a specific thing of interest is that,

1178
01:09:23,810 --> 01:09:26,030
当 VI 想要进行系统调用时，
when VI wants to make a system call,

1179
01:09:26,030 --> 01:09:29,190
所以，如果 VI 不知道它在 L4 上运行，
so, if VI doesn't know it's running on L4,

1180
01:09:29,670 --> 01:09:32,430
在这个方案中，
in this scheme,

1181
01:09:32,430 --> 01:09:36,660
实际上所有这些程序认为自己运行在 Linux 上，
it's really all these programs just think of themselves as running on Linux,

1182
01:09:36,690 --> 01:09:38,700
当 VI 想要进行系统调用时，
when VI wants to make a system call,

1183
01:09:38,820 --> 01:09:42,420
L4 不支持的系统调用，
you know L4 does not support,

1184
01:09:42,660 --> 01:09:45,840
它不是在进行 L4 系统调用，而是进行 Linux 系统调用，
its not making L4 system call, it's making Linux system call,

1185
01:09:46,050 --> 01:09:48,270
所以 VI 系统调用，比如 fork ，
so VI system calls like fork,

1186
01:09:48,360 --> 01:09:54,330
这里有一个很小的库，链接到，
there's a little library, basically that was linked into these,

1187
01:09:56,010 --> 01:09:59,580
Linux 进程将返回调用，
Linux processes that would return calls

1188
01:09:59,580 --> 01:10:04,920
比如 fork exec pipe read 或 write 之类的调用，返回到 IPC 消息，
like things like fork or exec or pipe read or write into IPC messages,

1189
01:10:05,070 --> 01:10:09,330
它将发送到 Linux 任务，
that it would send to the Linux task

1190
01:10:09,450 --> 01:10:11,820
并等待 Linux 任务的响应，
and wait for the response the Linux task,

1191
01:10:11,820 --> 01:10:14,310
然后返回，像系统调用返回一样。
then return as if the system call returned.

1192
01:10:15,670 --> 01:10:21,830
所以，这些小库将系统调用返回到 Linux 的 IPC 消息中，
So so these little libraries return system calls into IPC messages to Linux

1193
01:10:22,010 --> 01:10:23,090
这意味着，
and what that meant is that,

1194
01:10:23,210 --> 01:10:27,170
如果 Linux 内核任务没有做任何事情，
if the Linux kernel task isn't doing anything, it isn't doing anything else,

1195
01:10:27,290 --> 01:10:31,700
它在一个 recv 调用上，等待接收下一个系统调用请求 IPC ，
it's sitting in a call recv， waiting for the next system call request IPC

1196
01:10:31,700 --> 01:10:34,340
来自这些进程中的任何一个。
from any one of these processes.

1197
01:10:39,040 --> 01:10:39,820
这导致了，
And that led to it,

1198
01:10:41,330 --> 01:10:43,850
这导致了明显的不同，
that that leads to a significant difference

1199
01:10:43,850 --> 01:10:48,500
这种 Linux 的工作方式与普通 Linux 的工作方式，
between how this Linux works and how ordinary Linux works,

1200
01:10:49,280 --> 01:10:51,080
在普通的 Linux 中，比如 xv6 ，
in ordinary Linux, just like xv6,

1201
01:10:51,080 --> 01:10:56,660
每个用户级进程都有一个对应的内核线程，
there's a basically a kernel thread that corresponds to every user level process

1202
01:10:56,660 --> 01:10:59,170
并且当程序进行系统调用时，
and when program makes a system call,

1203
01:10:59,960 --> 01:11:03,110
内核代表该系统调用运行一个线程，
the kernel runs a thread on behalf of that system call,

1204
01:11:03,470 --> 01:11:07,100
在普通 Linux 中，
and when in ordinary Linux,

1205
01:11:07,100 --> 01:11:10,580
当 Linux 在内核线程之间切换时，
when Linux switches between kernel threads,

1206
01:11:10,610 --> 01:11:14,210
这意味着从一个进程切换到另一个进程，
that basically implies a switch from one process to another,

1207
01:11:14,830 --> 01:11:16,720
所以这是一对一的关系，
so there's kind of one to one correspondence

1208
01:11:16,720 --> 01:11:21,840
Linux 内核运行的内核线程，
between what kernel thread Linux kernels running

1209
01:11:22,170 --> 01:11:24,810
和 Linux 完成后要运行的进程之间，
and what process is gonna run when Linux is done,

1210
01:11:24,900 --> 01:11:26,610
在这里，连接被打断了，
here that connection is broken,

1211
01:11:26,670 --> 01:11:30,060
实际上，这个 Linux 服务器中，
they were indeed in this Linux server,

1212
01:11:30,090 --> 01:11:33,000
一个内核线程对应于。
a kernel thread corresponding to each.

1213
01:11:34,230 --> 01:11:35,910
抱歉，让我再说一遍，
I'm sorry, let me start again,

1214
01:11:35,910 --> 01:11:41,710
Linux 内核服务器在单个 L4 线程中运行，
the Linux kernel server was running in a single L4 thread,

1215
01:11:41,740 --> 01:11:47,500
所以在 Linux 中一次只有一个控制线程在执行，
so there was only a single sort of thread of control executing in Linux at a time,

1216
01:11:48,280 --> 01:11:51,790
然而，就像在 xv6 中一样，
however, just as in xv6,

1217
01:11:52,370 --> 01:11:55,430
这个控制线程切换
this one thread of control would switch

1218
01:11:55,460 --> 01:12:00,920
使用非常类似于 xv6 上下文切换的技术，
using a technique very much like xv6 context switch,

1219
01:12:01,550 --> 01:12:07,190
可以在对应于每个用户进程的内核线程之间切换，
could switch between a kernel thread corresponding to each user process,

1220
01:12:07,220 --> 01:12:10,840
但是这些，
however, which of these,

1221
01:12:10,900 --> 01:12:13,840
这些内核线程纯粹在 Linux 内部实现的，
the these kernel threads were implemented purely within Linux,

1222
01:12:13,840 --> 01:12:15,790
与 L4 级线程无关，
had nothing to do with L4 threads,

1223
01:12:15,820 --> 01:12:17,380
这里只有一个 L4 线程，
there's only one L4 thread here,

1224
01:12:17,980 --> 01:12:22,420
但是哪个用户进程正在运行由 L4 确定，
but which user process was running was determined by L4,

1225
01:12:22,940 --> 01:12:25,160
所以在这个设置中，
so in this setup,

1226
01:12:25,190 --> 01:12:31,400
Linux 可能服务于执行 VI 的内核线程的请求，
Linux might be serving a request from executing the kernel thread for VI,

1227
01:12:31,430 --> 01:12:33,080
服务 VI 系统调用，
serving a VI system call,

1228
01:12:33,380 --> 01:12:37,640
同时， L4 引起 shell 在用户空间中运行，
at the same time that L4 is causing this shell to run in user space,

1229
01:12:38,080 --> 01:12:41,760
这与 xv6 或 linux 中的情况非常不同，
which is very unlike what happens in xv6 or Linux

1230
01:12:41,760 --> 01:12:44,400
在它们之中存在直接关系，
where there's a direct correspondence

1231
01:12:44,400 --> 01:12:50,460
在活动内核线程和相应的用户级线程之间，
between the sort of active kernel thread and the corresponding a user level thread,

1232
01:12:50,460 --> 01:12:51,930
在这里，L4 运行，
here L4 of running whatever

1233
01:12:51,930 --> 01:12:56,790
Linux 内核中的这些线程更加私有，
it feels like and these threads in the Linux kernel are really much more private

1234
01:12:56,790 --> 01:13:01,890
关于 Linux 能够并发执行系统调用，
and are just about Linux being able to concurrently execute system calls

1235
01:13:01,890 --> 01:13:03,390
在不同的执行阶段，
in different stages of execution,

1236
01:13:03,450 --> 01:13:08,020
可能一个进程正在等待磁盘，
where maybe one process is waiting for the disk in its thread,

1237
01:13:08,320 --> 01:13:14,560
Linux 可以运行不同进程内核线程来服务进程系统调用。
Linux can run a different processe's kernel thread to serve that process system call.

1238
01:13:20,480 --> 01:13:27,470
所以，你可能会想，为什么这个设计没有直接使用 L4 线程
So, you might wonder why this design didn't directly use L4 threads

1239
01:13:27,470 --> 01:13:34,570
来实现 Linux 内部的各种不同的内核线程，
to implement the various different kernel threads inside Linux,

1240
01:13:35,110 --> 01:13:39,160
为什么 Linux 实现自己的内部线程，
why did Linux implement its own sort of internal threads package

1241
01:13:39,160 --> 01:13:40,540
而不是使用 L4 线程，
instead of using L4 threads,

1242
01:13:40,720 --> 01:13:42,940
答案是，在那个时候，
and the answer was that in those days,

1243
01:13:43,960 --> 01:13:47,460
a ，他们没有多核硬件，
a, they didn't have access to multi-core hardware,

1244
01:13:47,490 --> 01:13:49,170
他们使用的是单核硬件，
they were using single core hardware,

1245
01:13:49,170 --> 01:13:51,510
所以，这里没有性能优势，
so there were no performance advantage

1246
01:13:51,810 --> 01:13:56,040
在内核中同时执行多个线程，
to be able to execute multiple threads in the kernel at the same time,

1247
01:13:56,040 --> 01:13:57,240
因为只有一个核心，
because there was only one core,

1248
01:13:58,530 --> 01:14:00,240
所以，第二个线程无法执行，
so a second thread couldn't be executing,

1249
01:14:00,450 --> 01:14:02,970
因为硬件的原因，一次只能执行一个线程，
only one thread could execute at a time due to the hardware,

1250
01:14:03,480 --> 01:14:06,360
另一个可能更有说服力的原因是，
and the other may be even more powerful reason is that

1251
01:14:06,360 --> 01:14:09,120
那时候，他们用的这个 Linux 版本，
in those days, the version of Linux they were using,

1252
01:14:09,850 --> 01:14:12,280
没有支持，
did not did not have the support,

1253
01:14:12,430 --> 01:14:16,150
这需要有多个线程，多个核心，
that's required to have multiple threads multiple cores

1254
01:14:16,150 --> 01:14:18,280
同时在内核内执行，
executing inside the kernel at the same time,

1255
01:14:18,490 --> 01:14:21,370
他们使用的是单处理器 Linux ，
they were using a uni-processor Linux,

1256
01:14:21,400 --> 01:14:25,600
足够老的 Linux ，它只有一个核心用于内核，
so old enough Linux, it expected only one core the kernel at a time,

1257
01:14:27,420 --> 01:14:30,840
它没有像 xv6 那样的自旋锁，
it didn't have things like the spin locks the xv6 has,

1258
01:14:30,870 --> 01:14:36,880
这允许在内核内正确执行多个多核，
that would allow it to correctly execute multiple multiple cores inside the kernel,

1259
01:14:36,940 --> 01:14:39,070
所以，不会有性能优势，
so there would have been no performance advantage

1260
01:14:40,090 --> 01:14:43,450
在内核内具有多个活动的 L4 线程，
in having multiple L4 threads active inside the kernel,

1261
01:14:44,290 --> 01:14:47,380
但它需要添加，
but it would have required adding in,

1262
01:14:47,590 --> 01:14:48,790
为了增加性能，
you know for you know performance,

1263
01:14:48,790 --> 01:14:51,670
添加自旋锁和其他内容，
when adding in all the spin locks and other stuff,

1264
01:14:51,670 --> 01:14:53,890
用来支持并发性，
that's required to support concurrency,

1265
01:14:53,980 --> 01:14:55,830
所以他们没有这么做。
so they didn't do it.

1266
01:14:57,570 --> 01:15:00,960
这种安排的一个缺点是，
A drawback of this arrangement is that,

1267
01:15:01,740 --> 01:15:03,810
在普通 Linux 中，在原生 Linux 中，
in ordinary Linux, in native Linux,

1268
01:15:03,810 --> 01:15:05,670
就像你直接在笔记本电脑上运行的，
like you would run directly on your laptop,

1269
01:15:05,730 --> 01:15:09,630
Linux 有很多复杂的调度机制，
Linux has a lot of sophisticated scheduling machinery,

1270
01:15:09,630 --> 01:15:12,990
可以对不同的进程设置优先级，
that can do things like impose priorities on different processes

1271
01:15:12,990 --> 01:15:15,240
或者保证各种公平，
or ensure various kinds of fairness,

1272
01:15:17,080 --> 01:15:19,690
这很好，因为在你的笔记本电脑上，
and that was fine, because in on your laptop,

1273
01:15:19,690 --> 01:15:24,520
因为 Linux 控制着每个核心上运行的进程，
because Linux is in control of what process is running on each core,

1274
01:15:24,550 --> 01:15:26,890
但在这个设置中， Linux 根本不能控制这一点，
but in this setup, Linux is not controlling that at all,

1275
01:15:27,280 --> 01:15:31,380
Linux 无法控制什么进程正在运行，
and Linux is no control over what, what process is running,

1276
01:15:31,500 --> 01:15:35,190
因为执行此调度的是 L4 ，而不是 Linux ，
because it L4 that does this scheduling, not Linux,

1277
01:15:35,370 --> 01:15:37,740
这些进程由 L4 调度，
you know these processes are scheduled by L4,

1278
01:15:37,740 --> 01:15:42,660
所以，他们失去了让 Linux 负责调度的能力。
so they kind of lost the ability to have Linux be in charge of a schedule.

1279
01:15:44,640 --> 01:15:46,110
这有点缺陷，
You know, it's a bit of a defect of this,

1280
01:15:46,110 --> 01:15:53,850
尽管我确信后来的 L4 版本有针对 Linux 或类似系统的某种方式，
although I'm sure later versions of L4 had some way for Linux or something like it

1281
01:15:53,850 --> 01:15:55,260
为了告诉 L4 调度器，
to be able to tell the L4 schedule,

1282
01:15:55,260 --> 01:15:59,490
请给这个进程更高的优先权或者别的什么，
look, please give this process higher priority or whatever,

1283
01:16:00,540 --> 01:16:01,500
所以这有点奇怪。
so it's a bit awkward.

1284
01:16:06,950 --> 01:16:08,630
好的。
Alright.

1285
01:16:11,390 --> 01:16:16,510
所以，他们花了这么多功夫才让这件事开始。
So, so they went to all this work to get this going.

1286
01:16:17,780 --> 01:16:21,260
而且，你应该问问自己，
And, you should ask yourself

1287
01:16:21,260 --> 01:16:27,920
这篇关于微内核的论文带给我们的教训是什么？
you know what is the, what's the takeaway lesson from from this paper about micro kernels.

1288
01:16:29,970 --> 01:16:32,040
有一件事，所以对我们来说，
You know one things, so for us,

1289
01:16:32,040 --> 01:16:34,290
这篇论文有很多有趣的花絮，
you know this paper has a lot of interesting tidbits,

1290
01:16:34,290 --> 01:16:35,490
关于微内核如何工作，
about how micro kernels work,

1291
01:16:35,490 --> 01:16:36,660
关于 Linux 如何工作，
about how Linux works

1292
01:16:36,660 --> 01:16:39,930
以及如何设置如何设计这样的系统，
and how you set up how you can design a system like this,

1293
01:16:39,930 --> 01:16:41,700
这可能很有趣，
which may be interesting,

1294
01:16:42,600 --> 01:16:47,310
但在一个更大的世界里，人们想要吸取一些教训，
but a larger world, people want to want to draw some lessons,

1295
01:16:47,730 --> 01:16:48,810
他们需要的，
they need to be able to,

1296
01:16:49,790 --> 01:16:51,380
我在这篇论文中介绍了一些经验教训，
I present some lessons in this paper,

1297
01:16:51,680 --> 01:16:57,530
论文没有真正回答微内核是不是一个好主意，
the paper is not really answering the question are micro kernel is a good idea,

1298
01:16:57,980 --> 01:16:59,720
这并不是这里真正发生的事情，
that's not really what's going on here,

1299
01:17:00,530 --> 01:17:04,280
这篇论文讨论了，
the paper what the paper is part of argument about

1300
01:17:04,310 --> 01:17:11,510
微内核是否有足够的性能来值得使用，
whether micro kernels have enough performance to, to be worth using

1301
01:17:11,780 --> 01:17:13,280
原因是，
and the reason is that

1302
01:17:13,280 --> 01:17:18,710
在这篇论文发表之前的五年或者十年，
in in maybe five years five or ten years before this paper came out,

1303
01:17:19,550 --> 01:17:21,170
有一个著名的测量结果，
there was a famous set of measurements,

1304
01:17:21,170 --> 01:17:24,500
在之前的一种称为 Mach 的微内核上，
on one of the predecessor micro kernels and earlier micro kernel called Mach,

1305
01:17:24,650 --> 01:17:28,430
基本上在这种配置下运行，
basically running in very much this configuration,

1306
01:17:29,000 --> 01:17:32,230
但这是不同的，内部设计完全不同，
but it's different, you know, totally different design internally,

1307
01:17:32,230 --> 01:17:34,060
但都是一样的架构。
but kind of the same architecture.

1308
01:17:35,020 --> 01:17:39,780
早先这个微内核项目的名字叫 Mach ，
This, the name of this earlier micro kernel project is Mach,

1309
01:17:40,230 --> 01:17:41,880
有对 Mach 的测量，
there was measurements on Mach,

1310
01:17:41,880 --> 01:17:47,220
表示 Mach 比普通 Unix 慢得多，
that showed that Mach was dramatically slower than just ordinary Unix,

1311
01:17:47,700 --> 01:17:49,770
当它在这个配置中运行时，
when it was run in this configuration

1312
01:17:49,770 --> 01:17:52,530
这有很多原因，
and you know there are a lot of reasons for that

1313
01:17:52,530 --> 01:17:54,900
必须使用 IPC 系统，
having to do with the IPC system,

1314
01:17:54,900 --> 01:17:56,970
并不像你希望的那样优化，
not being as optimized as you might hope,

1315
01:17:57,090 --> 01:17:59,730
它们是有更多地切换上下文，
they're being just sort of more context switches

1316
01:17:59,730 --> 01:18:05,510
使用内核穿越和高速缓存未命中等等，
and you know we use our kernel crossings and cache misses and whatever,

1317
01:18:05,510 --> 01:18:08,540
Mach 慢的原因有很多，
there's a whole lot of reasons why Mach was slow,

1318
01:18:08,540 --> 01:18:11,510
但是很多人看到这些基准测试结果，
but many people saw those benchmark results,

1319
01:18:11,510 --> 01:18:14,420
显示 Mach 比原始操作系统慢得多，
showing that Mach was much slower than native operating systems

1320
01:18:14,420 --> 01:18:18,920
并认为微内核是无可救药的低效的，
and decided that micro kernels were just hopeless, hopelessly inefficient,

1321
01:18:19,040 --> 01:18:21,680
不太可能快到可以竞争，
where unlikely ever to be fast enough to be competitive

1322
01:18:21,680 --> 01:18:25,520
我们都应该使用宏内核。
and you know we should just all use monolithic kernels.

1323
01:18:26,320 --> 01:18:31,690
今天的论文就像是对这一论点的回答，
Today's papers like an answer basically to that argument,

1324
01:18:31,690 --> 01:18:34,540
在某种程度上是对这一论点的反驳，
it's sort of the rebuttal to that argument,

1325
01:18:34,570 --> 01:18:36,220
这篇论文的重点是展示
and the point of this paper is to show

1326
01:18:36,220 --> 01:18:38,230
你可以构建这个架构，
that you can build this architecture,

1327
01:18:38,230 --> 01:18:41,500
如果你注意优化性能，
and if you pay attention to optimizing performance,

1328
01:18:41,620 --> 01:18:44,680
你可以得到有竞争力的性能，
you can get a competitive performance

1329
01:18:44,680 --> 01:18:48,580
与直接运行 Unix 的原生操作系统相比，
with native operating systems just directly running Unix,

1330
01:18:49,000 --> 01:18:54,140
所以，你不能简单地根据性能来排除微内核，
and therefore you can't dismiss micro kernels simply on the basis of performance,

1331
01:18:54,380 --> 01:18:56,210
你可能因为其他原因不想要它们，
you may not want them for other reasons,

1332
01:18:56,210 --> 01:19:00,470
但你不能以性能作为拒绝的理由，
but you can't use performance as the reason to reject,

1333
01:19:01,010 --> 01:19:07,330
提出这一论点的很大一部分原因是，
part of, a huge part of the ingredients in making that argument is that,

1334
01:19:07,330 --> 01:19:11,320
他们使用我几分钟前提到的技术使 IPC 变得更快，
they made the IPC much faster with the techniques that I outlined a few minutes ago

1335
01:19:11,500 --> 01:19:17,100
你可以看到这一点，我认为在一个非常简单的基准表 2 中，
and you can see this I think in a, in a very simple benchmark table 2,

1336
01:19:17,100 --> 01:19:18,750
如果你有论文的复制，
if you have a copy of the paper with you,

1337
01:19:18,960 --> 01:19:25,800
表 2 是在硬件上以普通方式运行的原生 Linux 的测量结果，
table 2 as measurements of just native Linux running in the ordinary way on hardware

1338
01:19:26,070 --> 01:19:28,080
在原生 Linux 上，他们展示了
and on native Linux, they show that

1339
01:19:28,080 --> 01:19:30,600
他们的硬件和 Linux 版本，
you know on their hardware and their version of Linux,

1340
01:19:30,780 --> 01:19:37,020
一个个简单的系统调用 getpid 花费了 1.7 微秒，
that a single simple system call getpid took 1.7 microseconds,

1341
01:19:37,900 --> 01:19:40,000
它们还表明，
and they also show that

1342
01:19:40,150 --> 01:19:45,040
在 L4 设置相同的东西，
the sort of equivalent thing in there L4 setup,

1343
01:19:45,160 --> 01:19:48,280
你必须发送 IPC 请求并获得 IPC 响应，
where you have to send an IPC request and get an IPC response

1344
01:19:48,310 --> 01:19:50,710
仅针对 getpid 系统调用，
just for this getpid system call,

1345
01:19:51,040 --> 01:19:58,360
在 L4 Linux 下，这需要 4 微秒的时间，
that that that took four microseconds under L4 Linux,

1346
01:19:58,360 --> 01:19:59,830
这意味着两倍的时间，
which is to say twice as long,

1347
01:19:59,830 --> 01:20:02,710
但是有两倍的工作在进行，
but there's twice as much work going on,

1348
01:20:02,710 --> 01:20:05,710
因为你进行两组用户内核穿越，
because you're doing two sets of user kernel crossings

1349
01:20:05,710 --> 01:20:09,280
不只是一个简单的系统调用，
instead of just a single simple system call,

1350
01:20:09,370 --> 01:20:11,020
也就是说，他们可以声称，
that is they could claim

1351
01:20:11,020 --> 01:20:16,660
他们让这些 IPC 基础系统调用的花费降到了最低，
that they appeared the expense of these IPC base system calls down to basically the minimum,

1352
01:20:16,690 --> 01:20:20,950
这是系统调用原生 Linux 花费的两倍，
that is twice the cost of system call native Linux

1353
01:20:21,010 --> 01:20:24,400
所以，他们的表现几乎和你预期的一样好。
and therefore they were doing roughly as good as you could possibly expect.

1354
01:20:26,400 --> 01:20:30,990
当然，现在他们的系统速度仍然只有原生 Linux 的一半，
Now, of course that's still their systems are still half as fast as native Linux,

1355
01:20:33,220 --> 01:20:34,750
这不是很清楚，
and you know it's not clear

1356
01:20:34,750 --> 01:20:38,620
除非你做一些测量，系统调用是否运行了两次，
unless you did some measurements whether system calls taking twice

1357
01:20:38,620 --> 01:20:42,670
或者简单的系统调用花费两倍的时间是灾难还是不是问题。
or simple system calls taking twice as long as a disaster or not a problem.

1358
01:20:43,150 --> 01:20:44,620
为了表明这一点，
And in order to show that,

1359
01:20:44,650 --> 01:20:47,500
这可能是一场灾难，如果你执行大量系统调用，
you know it might be a disaster, if you do a lot of system calls

1360
01:20:47,500 --> 01:20:51,820
或者可能不成问题，如果你执行的系统调用相对较少，
or might be not a problem, if you do relatively few system calls

1361
01:20:51,820 --> 01:20:54,790
或者每个系统调用有很多工作，
or there's a lot of work per system calls,

1362
01:20:55,200 --> 01:20:57,510
可能系统调用比 getpid 更复杂。
maybe a system calls are more complicated than getpid.

1363
01:20:57,870 --> 01:21:03,540
论文中的答案是 A 图基准测试，
And the answer to that in the paper is the figure A benchmark,

1364
01:21:04,040 --> 01:21:06,470
使用这个名为 AIM 的基准测试，
using this benchmark called AIM,

1365
01:21:06,740 --> 01:21:07,820
这只是一个，
which is just a more,

1366
01:21:08,360 --> 01:21:10,910
它是一个各种不同的系统调用的基准测试，
it's a benchmark that has all kinds of different system calls,

1367
01:21:10,910 --> 01:21:13,070
它读写文件，创建进程，
it reads and writes files and creates processes

1368
01:21:13,070 --> 01:21:16,370
用内核做进程做的所有事情，
does all the things with the kernel that processes do,

1369
01:21:16,820 --> 01:21:19,070
他们在图 A 中显示，
and they basically showed in figure A that

1370
01:21:19,220 --> 01:21:23,450
他们的设置运行的是一个更完整的应用程序，
their setup running a much more full application that does,

1371
01:21:24,420 --> 01:21:26,010
不仅仅是 getpid ，
much more than just getpid,

1372
01:21:26,310 --> 01:21:29,730
运行速度仅比本地 Linux 慢几个百分点，
runs only a few percent slower than native Linux,

1373
01:21:29,940 --> 01:21:32,310
所以，你可以预期，
and therefore, hopefully you could expect

1374
01:21:32,310 --> 01:21:34,620
无论你想在计算机上运行什么，
that whatever it is you wanted to run on a computer,

1375
01:21:34,800 --> 01:21:38,250
在 L4 上运行几乎与 Linux 同样快，
would run almost as fast under L4 as Linux,

1376
01:21:38,250 --> 01:21:40,620
就像在普通操作系统下一样，
as it does under a straight operating system,

1377
01:21:41,040 --> 01:21:42,210
在原生操作系统下，
under native operating system

1378
01:21:42,480 --> 01:21:45,600
所以，它们
and therefore you know they were basically

1379
01:21:45,600 --> 01:21:50,630
基本上和直接运行 Linux 一样快，
to a first approximation as fast as just running straight Linux

1380
01:21:50,630 --> 01:21:53,630
所以，你应该认真对待它们。
and therefore you should take them seriously.

1381
01:21:55,530 --> 01:21:58,140
好的，这是一个令人印象深刻的结果，
Okay, so that was an impressive result by the way,

1382
01:21:58,200 --> 01:22:02,250
这是一个出乎意料的，并且很酷，
this is like someone unexpected and cool,

1383
01:22:02,940 --> 01:22:07,830
快进 20 年后，这一切就结束了，
just fast forwarding twenty years, where this ended up,

1384
01:22:07,830 --> 01:22:08,790
正如我之前提到的，
as I mentioned before,

1385
01:22:08,790 --> 01:22:12,480
人们在很多嵌入式环境中使用 L4 ，
people actually use L4 in a bunch of embedded situations,

1386
01:22:12,480 --> 01:22:14,010
特别是它用得很多，
particularly its used a lot,

1387
01:22:14,160 --> 01:22:18,210
智能手机上运行 L4 的例子很多，
there are many instances of L4 running in in smartphones,

1388
01:22:18,630 --> 01:22:21,510
隐藏在人们的视线之外，但不管怎样，
hidden from view but nevertheless,

1389
01:22:22,160 --> 01:22:24,080
并且所有运行的各种自定义软件，
and all running various kinds of custom software,

1390
01:22:24,080 --> 01:22:30,410
在这种情况下，它们不必与 Unix 兼容，
not not running, they don't have to have compatibility with Unix, in these situations,

1391
01:22:30,740 --> 01:22:33,680
微内核在其他更一般的情况下，
micro kernels in other more general situations

1392
01:22:33,680 --> 01:22:37,340
如工作站或服务器中从未真正流行起来，
like workstations or servers never really caught on,

1393
01:22:37,340 --> 01:22:40,850
这并不是因为这个设计一定有什么问题，
and it's not because there's necessarily anything wrong with that design,

1394
01:22:40,970 --> 01:22:46,010
只是为了取代一些现有的软件，
it's just they would have in order to displace some existing software,

1395
01:22:46,160 --> 01:22:48,980
你的新东西必须是更好的，
your new thing has to be you know like better,

1396
01:22:48,980 --> 01:22:51,080
让人们将会被激励去转换。
so people will be motivated to switch.

1397
01:22:51,520 --> 01:22:55,090
这些微内核是很好的，自然优雅，
And these micro kernels were perfectly good, naturally elegant,

1398
01:22:55,840 --> 01:22:58,600
但是人们很难确切指出
but it was hard to put, for people to put their finger on,

1399
01:22:58,600 --> 01:23:00,190
为什么它要好得多，
why it was so much better,

1400
01:23:00,190 --> 01:23:01,810
他们应该不厌其烦地
that they should go to the trouble

1401
01:23:01,900 --> 01:23:05,830
从 Linux 或他们正在运行的切换过来，
of switching from Linux or whatever they were running fits,

1402
01:23:05,830 --> 01:23:08,230
所以它从来没有真正流行起来，
so it never really caught on,

1403
01:23:08,230 --> 01:23:09,790
不一定是出于很好的原因，
not necessarily for good reasons,

1404
01:23:09,790 --> 01:23:12,910
因为它们看起来要好得多。
but because they were like dramatically better.

1405
01:23:13,590 --> 01:23:14,400
另一方面，
On the other hand,

1406
01:23:14,580 --> 01:23:18,360
来自这个架构的许多想法都产生了持久的影响，
many ideas from this architecture had a lasting impact,

1407
01:23:18,600 --> 01:23:22,320
人们得出，
the the people have to work out

1408
01:23:22,710 --> 01:23:26,550
更多有趣和灵活的方式来使用虚拟内存，
much more interesting and flexible ways of using virtual memory

1409
01:23:26,550 --> 01:23:30,210
为了在微内核上支持操作系统，
in order to support operating systems on their micro kernels

1410
01:23:30,390 --> 01:23:33,060
这些更复杂的接口
and those more sophisticated interfaces

1411
01:23:33,120 --> 01:23:38,550
通过 mmap 等方式进入 Linux 等主流操作系统，
made their way through things like mmap into mainstream operating systems like Linux,

1412
01:23:39,090 --> 01:23:42,870
这种在顶层运行操作系统的想法，
this idea of running an operating system kind of on top,

1413
01:23:43,320 --> 01:23:48,150
作为低级操作系统之上的服务器，
as a as a server on top of a lower level operating system,

1414
01:23:48,270 --> 01:23:52,500
在今天以虚拟机监视器的形式非常流行，
is extremely popular today in the form of virtual machine monitors,

1415
01:23:52,500 --> 01:23:57,120
它们在各地使用各种云托管服务。
which use all over the place and sort of cloud hosting services.

1416
01:23:57,610 --> 01:24:03,710
对可扩展性的需求，你可以修改用户级服务，
The desire for extensibility, you could modify a user level service,

1417
01:24:03,770 --> 01:24:08,270
在 Linux 中发挥作用的方式是可加载的内核模块，
the way that played out in things like Linux was loadable kernel modules

1418
01:24:08,270 --> 01:24:12,830
允许你动态加载修改 Linux 内核的工作方式，
which allow you to load, modify the way the Linux kernel works on the fly,

1419
01:24:13,910 --> 01:24:16,280
当然还有客户端服务器的类型，
and of course the sort of client server,

1420
01:24:16,280 --> 01:24:18,650
对客户端服务器体系结构的良好支持，
good support for this client server architecture,

1421
01:24:19,180 --> 01:24:21,400
也进入了像 MacOS 这样的内核，
also made its way into kernels like MacOS,

1422
01:24:21,400 --> 01:24:24,040
它具有良好的 IPC 和良好的客户端服务器。
which has good IPC and good client server.

1423
01:24:25,700 --> 01:24:27,320
这就是我对这堂课要说的全部内容，
And that's all I have to say for this lecture,

1424
01:24:27,350 --> 01:24:31,700
我很乐意留下来回答问题，谢谢。
I'm happy to stick around for questions, thank you.

1425
01:24:36,690 --> 01:24:37,290
谢谢。
Thank you.

1426
01:24:37,950 --> 01:24:38,400
不用谢。
You're welcome.

1427
01:24:40,150 --> 01:24:41,590
哦，我想问一下，
Oh, I wanted to ask,

1428
01:24:41,590 --> 01:24:47,600
我们现在讨论的论文关于页表，
so the paper we're talking about virtual, about page tables,

1429
01:24:48,100 --> 01:24:50,290
我想是在 4.2 ，
at I think 4.2

1430
01:24:50,470 --> 01:24:52,990
它说的是如何，
and it was saying how,

1431
01:24:54,960 --> 01:24:58,020
我想这和你之前提到的差不多，
I think it was kind of what what you mentioned before,

1432
01:24:58,050 --> 01:25:02,250
你说有一种错误的方式可以做到这一点，
where you said that there is a wrong way to do that,

1433
01:25:02,580 --> 01:25:05,340
我想可能有点类似，
I think might be kind of similar to that,

1434
01:25:05,370 --> 01:25:09,720
但是如果做这件事，
but if you do this, this thing

1435
01:25:09,720 --> 01:25:13,630
你现在在照片里解释的这件事，
that you explain this in your picture now,

1436
01:25:14,280 --> 01:25:20,430
在这种情况下，页表是如何工作的？
would it be, I guess how how would the page tables work in this case?

1437
01:25:20,550 --> 01:25:26,370
好的，你可能指的是 4.3 节，双空间错误。
Well, are you, you may be referring to section 4.3 the dual space mistake.

1438
01:25:26,610 --> 01:25:27,150
哦，是的，抱歉， 4.3 。
Oh yes sorry 4.3.

1439
01:25:28,380 --> 01:25:30,660
是的，这是一个有点复杂的故事，
Yeah, that's a bit of a complicated story,

1440
01:25:30,660 --> 01:25:33,990
但让我们看看，
but the let's see,

1441
01:25:35,710 --> 01:25:38,920
背景的一部分是 Linux 在那些日子里的工作方式，
part of the background is the way that Linux worked in those days,

1442
01:25:38,920 --> 01:25:41,440
事实上，直到最近，都是
and indeed until recently is that

1443
01:25:41,560 --> 01:25:44,380
当你在用户级别运行时，
the when you're running at user level,

1444
01:25:44,860 --> 01:25:46,810
页表实际上有，
the page table, this actually has

1445
01:25:46,810 --> 01:25:49,870
进程页面，用户级页映射，
both the processe's pages, user level pages mapped in

1446
01:25:49,960 --> 01:25:52,600
并且所有内核都映射到这个页表中，
and all of the kernel mapped into that one page table,

1447
01:25:53,300 --> 01:25:54,890
在 x86 上，
on xv6 anyway,

1448
01:25:54,920 --> 01:25:59,600
所以，当你进行系统调用并跳入内核时，
so when you made system call, and jumped into the kernel,

1449
01:26:00,140 --> 01:26:02,510
内核已映射到页表中，
the kernel was already mapped into the page table

1450
01:26:02,750 --> 01:26:05,090
因此不需要页表切换，
and therefore no page table switch was required,

1451
01:26:05,480 --> 01:26:06,620
当你进行系统调用时，
when you make a system call,

1452
01:26:06,620 --> 01:26:08,930
它的成本要低得多，
its that much more expensive and much more cheaper,

1453
01:26:09,290 --> 01:26:10,820
因为没有页表切换，
because there was no page table switch,

1454
01:26:10,820 --> 01:26:12,020
如果你在 xv6 中调用，
if you're call in xv6,

1455
01:26:12,020 --> 01:26:14,120
你知道 trampoline 代码切换页表，
you know the trampoline code switches page tables,

1456
01:26:14,120 --> 01:26:17,060
这是一件昂贵的事情，
which is an expensive thing to do,

1457
01:26:17,060 --> 01:26:22,190
因为它刷新虚拟到物理映射的 TLB 高速缓存。
because it flushs the TLB cache of virtual to physical mappings.

1458
01:26:22,810 --> 01:26:23,890
无论如何，为了提高效率，
Anyway, so for efficiency,

1459
01:26:23,890 --> 01:26:27,760
Linux 在同一页表中映射内核和用户空间，
Linux used to map kernel and user space in the same page table

1460
01:26:28,030 --> 01:26:30,630
具有很快的系统调用，
had fast system calls as a result,

1461
01:26:30,660 --> 01:26:37,210
原因并不是很清楚，
so they for reasons that aren't very clear,

1462
01:26:37,210 --> 01:26:42,360
他们决定执行相同的操作来设置 Unix 服务器中的映射。
decided to do this same thing to setup the mapping in the Unix server.

1463
01:26:43,950 --> 01:26:46,610
好的，他们想要的是，
Well, what they wanted was that

1464
01:26:46,610 --> 01:26:51,180
当 VI ，当一个进程将系统调用发送到这里时，
when VI, when a process send a system call over here,

1465
01:26:51,270 --> 01:26:53,790
他们希望页表处于活动状态，
they wanted to have the page table that was active,

1466
01:26:53,790 --> 01:26:58,430
在 Linux 服务器上处理那个系统调用的时候，
well, in the Linux server while processing that system call,

1467
01:26:58,520 --> 01:27:01,730
包括所有虚拟内存映射，
include all the virtual memory mappings,

1468
01:27:01,730 --> 01:27:04,730
send 系统调用的进程的映射。
mappings for the process that sent the system call.

1469
01:27:06,980 --> 01:27:07,970
这至少使它，
And that at least would make it

1470
01:27:09,030 --> 01:27:13,770
更容易的查找传给系统调用参数的虚拟地址，
simpler to look up virtual addresses past a system call arguments,

1471
01:27:13,770 --> 01:27:15,030
比如发送给 read ，
like pass to read,

1472
01:27:15,720 --> 01:27:18,180
之所以效果不佳，
the reason why this worked out poorly,

1473
01:27:18,180 --> 01:27:19,080
原因有很多，
there are a bunch of reasons,

1474
01:27:19,080 --> 01:27:24,870
一是 L4 对 Linux 的东西一无所知，
one is that, L4 which doesn't know anything about any of Linux stuff,

1475
01:27:25,020 --> 01:27:27,150
L4 只知道有两个进程，
L4 just knows there's two processes

1476
01:27:27,150 --> 01:27:30,270
所以，当你将 IPC 从一个进程发送到另一个进程时，
and so when you send an IPC from one process to another,

1477
01:27:30,270 --> 01:27:32,100
L4 只是切换页表，
L4 just switches page tables,

1478
01:27:32,370 --> 01:27:33,570
它总是只切换页表，
it always just switches page tables,

1479
01:27:33,570 --> 01:27:36,000
这个页表， VI 的页表，
this guy the page table, VI, the page table,

1480
01:27:36,630 --> 01:27:39,090
L4 将页表与 Linux 内核相关联，
L4 associates a page table with Linux kernel,

1481
01:27:39,090 --> 01:27:40,620
只是总是切换页表，
just always switches page tables,

1482
01:27:40,710 --> 01:27:42,330
所以，你甚至不能，
so you couldn't even

1483
01:27:42,330 --> 01:27:46,000
由于 L4 系统调用的实现方式不同，
due the L4 due to the different way system calls are implemented

1484
01:27:46,000 --> 01:27:48,070
并且涉及 L4 的事实是，
and the fact that L4 was involved,

1485
01:27:48,160 --> 01:27:51,670
在系统调用期间没有办法保留页表，
there was no way to preserve the page table during a system call,

1486
01:27:52,230 --> 01:27:53,310
那是不可能的，
that just wasn't possible,

1487
01:27:53,850 --> 01:27:56,640
因为 L4 总是切换页表，
because L4 always switched page tables

1488
01:27:56,940 --> 01:27:58,650
当它在从一个进程切换到另一个进程时，
when it switched from one process to another,

1489
01:27:58,680 --> 01:28:03,000
所以，他们永远不会获得无需切换页表的效率优势，
so they were never going to get the efficiency win of not having to switch page tables,

1490
01:28:03,030 --> 01:28:08,060
当它一旦从用户到内核的切换时。
when that once a crossing from from user to kernel.

1491
01:28:08,860 --> 01:28:12,370
但我认为他们想要方便
But I think they wanted the convenience

1492
01:28:12,370 --> 01:28:16,830
能够直接使用用户提供的虚拟地址，
of being able to directly use user supplied virtual addresses,

1493
01:28:17,630 --> 01:28:21,760
但这意味着映射是活跃的，
but that meant that mappings they needed to be active

1494
01:28:21,790 --> 01:28:26,860
取决于它们代表哪个进程执行系统调用，
depended on which process they were executing a system call on behalf of,

1495
01:28:27,160 --> 01:28:30,010
所以 Linux 不可能有任何一个页表，
so there couldn't be any one page table for Linux,

1496
01:28:31,330 --> 01:28:36,510
LINUX 页表是否使用取决于发送系统调用 RPC 的进程，
page table Linux sort of one is used depends on what process sent system call RPC,

1497
01:28:36,540 --> 01:28:39,630
但是 L4 不知道怎么玩这个游戏，
but L4 did not know how to play that game,

1498
01:28:39,840 --> 01:28:44,520
L4 将单个页表与每个进程与每个任务相关联，
L4 associated a single page table with each process with each task,

1499
01:28:44,760 --> 01:28:47,910
所以它只会切换到那个页表，
and so in order and it would just switch to that page table,

1500
01:28:47,910 --> 01:28:48,840
所以运气不好，
so tough luck,

1501
01:28:48,840 --> 01:28:52,850
Linux 没有任何方法使页表不同，
Linux didn't have any way to cause the page table to differ

1502
01:28:52,850 --> 01:28:55,730
根据 send 系统调用的不同，
depending on who it's sent to the system call,

1503
01:28:56,210 --> 01:28:57,470
为了解决这个问题，
in order to deal with that,

1504
01:28:57,650 --> 01:29:03,170
他们制作了一堆内核的共享内存副本，
apparently they made a bunch of shared memory copies of the kernel,

1505
01:29:03,720 --> 01:29:06,330
每个进程一个，
one for each process

1506
01:29:06,360 --> 01:29:08,700
所以每个内核的共享内存副本，
and so each of these shared memory copies of the kernel,

1507
01:29:09,290 --> 01:29:12,860
将所有内核内存映射到其中，
had exact had all of the kernel memory mapped into it,

1508
01:29:12,860 --> 01:29:15,560
所以它们都是相同的内核数据结构，
so they were all the same kernel data structures,

1509
01:29:15,590 --> 01:29:22,780
但是每个进程都有一个与之相关联的专用内核任务，
but each process had a dedicated kernel task associated with it

1510
01:29:22,780 --> 01:29:26,260
所以，这允许他们对 L4 使用技巧，
and therefore that basically allowed them to trick L4

1511
01:29:26,260 --> 01:29:28,150
并切换到适当的页表，
and to switch into the appropriate page table,

1512
01:29:28,150 --> 01:29:31,090
包括进程加上内核，
that included that process plus the kernel,

1513
01:29:31,420 --> 01:29:34,060
具体取决于哪个进程系统调用请求。
depending on which process system call request.

1514
01:29:34,720 --> 01:29:37,780
我觉得那挺管用的，
And you know I think that kind of worked,

1515
01:29:37,780 --> 01:29:41,230
但是他们说他们工作很慢之类的，
but I don't [] what they said they worked was slow or something,

1516
01:29:41,590 --> 01:29:44,080
因为有很多任务。
because there were a lot of tasks.

1517
01:29:46,810 --> 01:29:48,280
不管怎么说，这是个复杂的故事，
Anyway, it's a complicated story,

1518
01:29:48,280 --> 01:29:50,200
我认为这件事的效果不是很好。
and I think it didn't work out very well for this.

1519
01:29:50,560 --> 01:29:52,360
好的，我明白了，
Okay, okay I see,

1520
01:29:52,360 --> 01:29:57,250
我想这很好地解释了为什么这个东西更难，
I think I think that explains well why this thing is harder to do

1521
01:29:57,250 --> 01:30:00,170
比我们做的 xv6 ，好的。
than, well, what we do xv6, okay.

1522
01:30:00,880 --> 01:30:02,890
是的，这个，因为没有，
Yeah yeah, this, because there's not,

1523
01:30:03,500 --> 01:30:05,750
你有这张图片 xv6 甚至标准的 Linux
you have this picture xv6 or even standard Linux

1524
01:30:05,750 --> 01:30:07,130
都比这个简单得多，
is much simpler than this,

1525
01:30:07,610 --> 01:30:10,430
你只是直接跳到内核中，
you're just jumping directly into the kernel

1526
01:30:10,430 --> 01:30:13,940
并且内核对所有分页硬件有直接控制权，
and the kernel has control over direct control over all the paging hardware,

1527
01:30:14,090 --> 01:30:16,070
当它运行 L4 时就没有了。
which doesn't have when it runs L4.

1528
01:30:17,120 --> 01:30:19,820
好的，我明白了，谢谢。
Right, okay I see, thank you, thank you.

1529
01:30:21,190 --> 01:30:23,590
我们会问，为什么，
We're gonna ask, why,

1530
01:30:23,590 --> 01:30:31,180
看起来有些任务比其他任务更适合放在内核之外，
it seems like some some tasks are more appropriate to be put outside the kernel than others,

1531
01:30:31,270 --> 01:30:34,480
但是这个 L4 使用微内核的方法，
but this L4 like the approach with micro kernels

1532
01:30:34,480 --> 01:30:36,910
似乎总是要么什么都有，要么什么都不是，
always seems to be either everything or nothing,

1533
01:30:36,940 --> 01:30:41,350
比如要么有一个宏内核来做所有的事情，要么什么都不做，
like either you have a monolithic kernel doing everything or nothing,

1534
01:30:41,350 --> 01:30:47,020
比如我觉得分页和其他一些事情在内核中可能非常有效，
just like I feel like paging and some other things could be very efficient inside the kernel,

1535
01:30:47,020 --> 01:30:48,970
然后可能像文件系统，
and then maybe like file systems

1536
01:30:48,970 --> 01:30:51,850
需要交换的东西可能在外部，
that things that need to be swappable could be outside,

1537
01:30:52,420 --> 01:30:56,740
然后，甚至可以拥有一个具有某些功能的内核，
and then even like you can maybe even have a kernel that has some functionality,

1538
01:30:56,740 --> 01:30:59,980
但是你可以选择不使用它，而提供你自己的，
but you can opt to not use it and provide your own,

1539
01:31:00,540 --> 01:31:02,280
有没有什么。
is there any thing.

1540
01:31:02,280 --> 01:31:05,310
你说的绝对是对的，
You say is absolutely well taken

1541
01:31:05,310 --> 01:31:10,440
确实有很多微内核或与微内核相关的项目，
and indeed there were a lot of micro kernel or micro kernel related projects

1542
01:31:11,130 --> 01:31:13,950
它们中的许多制造了各种各样的混合内核，
and many of them built various kinds of hybrids,

1543
01:31:14,190 --> 01:31:16,740
比如有几个不同版本的 Mach ，
like there's actually a couple different versions of Mach

1544
01:31:16,740 --> 01:31:19,810
其中一些是混合内核，
and some of them sort of hybrid kernels,

1545
01:31:19,810 --> 01:31:22,570
有这样一个微内核 IPC ，
which yeah there was this micro kernel that knew about IPC,

1546
01:31:22,570 --> 01:31:27,480
但内核中是一个完整的 Unix ，
but also in the kernel was a complete Unix,

1547
01:31:27,630 --> 01:31:32,440
比如， Mach 2.5 就是在内部使用混合内核，
so for instance Mach 2.5 was this hybrid with it,

1548
01:31:33,480 --> 01:31:36,690
微内核和 Unix 几乎都在同一个内核中。
but micro kernel and Unix all sort of in the same kernel

1549
01:31:36,990 --> 01:31:38,730
你可以进行系统调用，
and you can make system calls either

1550
01:31:38,730 --> 01:31:42,540
而且一些东西使用了微内核的方式，
and some stuff was built in the sort of micro kernel way,

1551
01:31:42,540 --> 01:31:45,900
但是有些东西他们只是用了 Mach 的内核，
but some things they were just used the kernel that was in Mach,

1552
01:31:46,170 --> 01:31:47,880
它在 Mach 内核中，
that was built into the Mach kernel,

1553
01:31:48,000 --> 01:31:49,980
Unix 内核被内置到 Mach 内核中，
the Unix kernel was built into the Mach kernel,

1554
01:31:50,280 --> 01:31:56,160
一种现代 MacOS 构建方式也与所描述的方式类似，
a modern MacOS also built in a way that like the way you describe,

1555
01:31:56,160 --> 01:32:00,930
MacOS 有一个完整的操作系统，
you know MacOS has a complete operating system

1556
01:32:00,930 --> 01:32:02,430
里面有一个文件系统和所有的东西，
with a file system and everything inside it,

1557
01:32:02,430 --> 01:32:07,020
但它也很好地支持 IPC 和类似的线程，
but it also has good support for IPC and sort of like threads,

1558
01:32:07,020 --> 01:32:12,300
所有你想要构建的微内核式服务。
all the stuff you would want to build micro kernel style services.

1559
01:32:13,570 --> 01:32:17,980
谷歌的 Fuchsia 是不是也实现了其中一些想法？
Is Google's Fuchsia, I'm aware of also implements some of these ideas as well.

1560
01:32:18,490 --> 01:32:19,390
我敢打赌是的。
I'll bet yeah.

1561
01:32:22,180 --> 01:32:24,160
所以不管怎样，没有一种方法，
So anyway, there's no one way,

1562
01:32:24,940 --> 01:32:28,000
有些人希望一个纯粹的，
there were people who were sort of hoping that a pure,

1563
01:32:28,670 --> 01:32:32,360
非常纯粹的计划能够奏效，
a very pure scheme could be made to work,

1564
01:32:36,860 --> 01:32:38,510
这不是唯一可能的前进道路。
it's not the only possible way forward.

1565
01:32:41,030 --> 01:32:42,110
好的，谢谢，
Alright, thanks,

1566
01:32:42,140 --> 01:32:43,820
我要去我的下一节课了，
got around my next lecture,

1567
01:32:43,820 --> 01:32:45,050
但是我们会再见的。
but I'll see you guys.

1568
01:32:45,950 --> 01:32:46,400
再见。
See you later.

1569
01:32:48,790 --> 01:32:49,300
谢谢。
Thank you.

1570
01:32:49,940 --> 01:32:50,480
不用谢。
You're welcome.

1571
01:32:52,460 --> 01:32:53,900
哦，我没有，
Oh, I I didn't have a,

1572
01:32:53,960 --> 01:32:55,250
我只想说一句，
I have just a remark,

1573
01:32:55,280 --> 01:32:57,110
我觉得很有意思，
I I think it's fascinating,

1574
01:32:57,110 --> 01:33:00,720
它好像慢了 5% ，
that it it's like 5% slower,

1575
01:33:00,720 --> 01:33:02,490
但它做的工作要多得多，
but it does so much more work,

1576
01:33:02,580 --> 01:33:03,990
是的，它非常有意思。
yeah was fascinated with that.

1577
01:33:06,120 --> 01:33:09,330
你的意思是，即使它做更多的工作也只是稍微慢一点，
You mean that even though it's doing much more work is only slightly slower,

1578
01:33:09,960 --> 01:33:15,210
IPC 的性能真的是[]。
really have a really [] over the IPC performance.

1579
01:33:15,690 --> 01:33:18,480
当然，还有一件事需要记住，
And it's another thing to remember, of course is that,

1580
01:33:19,310 --> 01:33:20,510
如果你开始做，
if you start doing,

1581
01:33:20,540 --> 01:33:24,410
如果你在每个系统调用中做大量的工作，
if you're doing a significant amount of work per system call,

1582
01:33:25,380 --> 01:33:28,590
查找文件和目录什么的，
you know looking at files and directories or something,

1583
01:33:28,650 --> 01:33:30,390
那么系统调用的成本，
then the cost of the system call,

1584
01:33:30,390 --> 01:33:33,780
IPC 本身成本就开始变得不那么重要了。
the IPC itself starts to be less important.

1585
01:33:34,890 --> 01:33:38,100
所以，更快的系统调用加上实际程序的组合
So the combination of faster system calls plus real programs

1586
01:33:38,100 --> 01:33:40,770
可以做一些不同于进行系统调用的事情。
do things other than making system calls.

1587
01:33:41,750 --> 01:33:45,170
但你也会希望交换页表。
But you would also like switch page tables and.

1588
01:33:45,260 --> 01:33:45,740
是的。
Yeah.

1589
01:33:45,890 --> 01:33:46,910
其他系统有的。
The others have.

1590
01:33:47,330 --> 01:33:48,320
是的，尽管论文，
Yeah, although the paper,

1591
01:33:48,320 --> 01:33:49,370
我没有谈到它，
I did not talk about it,

1592
01:33:49,370 --> 01:33:51,350
但是论文有一些巧妙的技巧，
but the paper had some clever tricks

1593
01:33:51,350 --> 01:33:54,980
可以避免切换页表的成本，
for avoiding the cost of switching page tables,

1594
01:33:55,010 --> 01:33:58,940
我不知道你是否还记得，
I don't know if you remember for some of its,

1595
01:33:58,940 --> 01:34:03,320
在第 6 页中，我们讨论的是标记 TLB 为很小的空间，
on page 6, we're talking about supporting tagged TLBs a small spaces,

1596
01:34:03,560 --> 01:34:07,940
他们有一些聪明的想法来避免切换页表，
they have some clever ideas for not switch page tables,

1597
01:34:08,600 --> 01:34:10,820
这是我在读这份论文之前听说过的。
which I had not heard of before I read this paper.

1598
01:34:12,340 --> 01:34:15,430
太酷了，非常感谢，再见。
This is pretty cool, thank you so much, bye.

1599
01:34:16,020 --> 01:34:16,470
再见。
Goodbye.

