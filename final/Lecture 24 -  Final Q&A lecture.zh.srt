1
00:00:06,750 --> 00:00:09,630
下午好，快速试音。

2
00:00:10,510 --> 00:00:11,320
大家能听到我说话吗？

3
00:00:12,270 --> 00:00:12,780
是的。

4
00:00:13,820 --> 00:00:14,570
谢谢。

5
00:00:15,350 --> 00:00:19,370
好的，我想今天到目前为止，

6
00:00:19,370 --> 00:00:23,180
这是本学期的最后一节 6.S081 的课。

7
00:00:23,960 --> 00:00:30,500
我们并没有一个正式的话题，

8
00:00:30,620 --> 00:00:31,820
这是一个问答课程，

9
00:00:32,150 --> 00:00:36,380
所以你可以随便问任何问题，

10
00:00:36,410 --> 00:00:37,430
我想这是最后一次，

11
00:00:37,430 --> 00:00:40,490
至少是你们这学期最后一次上这门课了。

12
00:00:41,260 --> 00:00:43,390
默认情况下，我的计划是

13
00:00:43,390 --> 00:00:49,090
根据电子邮件上的问题复习几个主题，

14
00:00:49,150 --> 00:00:53,100
然后我要稍微讨论一下网络实验的解决方案。

15
00:00:53,850 --> 00:00:58,560
如果可能的话，再花一点时间介绍一下 mmap 实验，

16
00:01:00,110 --> 00:01:01,760
再次谈论这些解决方案。

17
00:01:02,090 --> 00:01:05,660
然后有很多关于后续课程的问题，

18
00:01:05,810 --> 00:01:09,050
事实上，我会先讲到这一点。

19
00:01:10,120 --> 00:01:15,280
但是在深入到这三个主题中的一个之前，

20
00:01:15,280 --> 00:01:23,800
让我提醒你，有一个科目评估正在进行中，

21
00:01:23,800 --> 00:01:27,700
而我们作为 6.S081 的工作人员，

22
00:01:27,700 --> 00:01:31,900
我们感谢你对 6.S081 的反馈。

23
00:01:33,060 --> 00:01:34,440
希望它是积极的，

24
00:01:34,680 --> 00:01:37,410
我们明年有机会再次授课。

25
00:01:39,320 --> 00:01:41,000
也许这也是一个很好的时机，

26
00:01:41,000 --> 00:01:44,570
谢谢你们参加今天的课程，

27
00:01:44,600 --> 00:01:46,730
即使没有非常正式的计划，

28
00:01:46,730 --> 00:01:49,040
我也感谢工作人员，

29
00:01:49,040 --> 00:01:53,330
我很感激你们非常忙碌，

30
00:01:53,330 --> 00:01:57,110
尤其论文不是直接对应实验，

31
00:01:57,110 --> 00:02:00,560
很明显，你们中的许多人都深入论文中，

32
00:02:00,560 --> 00:02:01,940
试图真正理解它们，

33
00:02:01,940 --> 00:02:04,760
在电子邮件上问一些很棒的问题。

34
00:02:04,760 --> 00:02:09,350
所以，我们非常感谢你们的努力。

35
00:02:10,780 --> 00:02:15,470
在我讲每个主题之前，有什么问题吗？

36
00:02:21,540 --> 00:02:25,830
好的，让我从电子邮件中出现最多的问题开始，

37
00:02:25,890 --> 00:02:27,000
接下来是什么。

38
00:02:28,580 --> 00:02:35,900
有很多课程是面向系统的，

39
00:02:36,350 --> 00:02:39,500
我肯定我错过了一些课，

40
00:02:39,590 --> 00:02:41,330
我应该在这里列出的，

41
00:02:41,600 --> 00:02:44,660
它与操作系统直接相关，

42
00:02:44,660 --> 00:02:47,240
当然，如果你学过 6.033 ，

43
00:02:47,270 --> 00:02:48,470
这是一门很棒的课程，

44
00:02:48,470 --> 00:02:52,460
尤其是我们阅读或学习如何阅读论文。

45
00:02:52,950 --> 00:02:59,910
6.828 是我们最初提供的唯一操作系统课程，

46
00:02:59,940 --> 00:03:03,480
今年或者第二年，

47
00:03:03,750 --> 00:03:05,790
今年是提供这两门课的第一年，

48
00:03:06,090 --> 00:03:08,520
所以， 6.S081 是本科生操作系统，

49
00:03:08,520 --> 00:03:14,340
6.828 作为研究生的操作系统课程。

50
00:03:14,870 --> 00:03:17,330
6.828 假设，

51
00:03:17,330 --> 00:03:20,120
你已经选了 6.S081 或本科生操作系统，

52
00:03:20,120 --> 00:03:26,150
在新的项目和构建有趣的操作系统工件，

53
00:03:26,680 --> 00:03:28,810
从文献中阅读更多的论文，

54
00:03:28,960 --> 00:03:31,390
以及更多的现代研究文献。

55
00:03:32,660 --> 00:03:34,430
然后也许你更，

56
00:03:34,430 --> 00:03:38,000
操作系统有很多与硬件的接口，

57
00:03:38,030 --> 00:03:40,820
有更多的系统的硬件方面，

58
00:03:40,820 --> 00:03:42,980
计算机架构课程 6.823 ，

59
00:03:42,980 --> 00:03:45,080
我相信会在即将到来的春天提供，

60
00:03:45,320 --> 00:03:47,000
当然还有 6.111 ，

61
00:03:47,000 --> 00:03:50,990
是构建硬件设备的东西。

62
00:03:51,460 --> 00:03:55,270
在性能方面，在编译器方面，

63
00:03:55,270 --> 00:03:57,820
6.172 6.035 是个好地方，

64
00:03:57,850 --> 00:04:02,020
你们中的一些人同时选修了 6.172 ，

65
00:04:02,050 --> 00:04:05,620
如果你选了编译课程 6.035

66
00:04:05,620 --> 00:04:07,780
或动态编译器课程，

67
00:04:07,780 --> 00:04:10,240
它们两个也都是很棒的课程。

68
00:04:11,580 --> 00:04:13,650
系统是一个宽泛的话题，

69
00:04:13,680 --> 00:04:16,230
所以，这里有网络，

70
00:04:16,230 --> 00:04:18,090
以及一大批课程，

71
00:04:18,090 --> 00:04:20,070
围绕网络的整个课程，

72
00:04:20,130 --> 00:04:23,940
以及围绕数据库的整个课程，

73
00:04:24,240 --> 00:04:27,730
这些都是好的和重要的，

74
00:04:27,790 --> 00:04:31,570
你在 6.S081 中看到的方面

75
00:04:31,570 --> 00:04:35,590
将在这些课程中以更重要的方式出现。

76
00:04:36,510 --> 00:04:40,440
比如，网络是一个很棒的话题 6.829 ，

77
00:04:40,440 --> 00:04:43,050
你会在那里看到更多关于网络的内容，

78
00:04:43,380 --> 00:04:44,970
比起你已经在 6.S081 中看到的，

79
00:04:45,240 --> 00:04:47,790
6.830 ，我们讨论过文件系统，

80
00:04:47,790 --> 00:04:51,150
是另一种重要的存储系统，

81
00:04:51,150 --> 00:04:55,410
可能在一些方面对许多应用程序更重要，数据库，

82
00:04:55,410 --> 00:04:58,140
所以你有 6.830 这个很棒的课程

83
00:04:58,140 --> 00:04:59,700
来学习更多关于数据库的知识。

84
00:05:00,780 --> 00:05:02,370
这些课程，

85
00:05:02,370 --> 00:05:06,180
有时叫做 PDOS 课程，

86
00:05:07,440 --> 00:05:08,970
这里有很多课程，

87
00:05:09,030 --> 00:05:13,110
6.824 分布式系统课程将开设，

88
00:05:13,110 --> 00:05:16,470
在下学期春季学期，

89
00:05:16,470 --> 00:05:23,180
本学期在 6.S081 涉及的教职员工，

90
00:05:23,180 --> 00:05:24,620
将参与 6.824 。

91
00:05:25,330 --> 00:05:29,650
有 6.858 是计算机安全课程，

92
00:05:29,830 --> 00:05:33,040
今年春天我们不会提供，

93
00:05:33,040 --> 00:05:36,220
但是我们希望在下一学年提供。

94
00:05:36,870 --> 00:05:41,100
有 6.826 是计算机系统原理，

95
00:05:41,100 --> 00:05:44,970
有很多人问起验证和系统软件，

96
00:05:44,970 --> 00:05:45,960
这就是你要学的课程，

97
00:05:45,960 --> 00:05:47,730
如果你对那个主题感兴趣。

98
00:05:48,780 --> 00:05:50,940
更广泛地说，

99
00:05:50,940 --> 00:05:54,300
很多人想知道研究要怎么继续，

100
00:05:54,300 --> 00:05:54,990
如果你感兴趣，

101
00:05:54,990 --> 00:05:59,730
几乎所有系统文献的论文都是公开的，

102
00:05:59,730 --> 00:06:01,890
甚至最近的会议，

103
00:06:01,920 --> 00:06:05,400
比如， OSDI 会议在几周前举行，

104
00:06:05,700 --> 00:06:07,950
你可以看着它们，

105
00:06:07,950 --> 00:06:09,840
看看有哪些主题，

106
00:06:09,840 --> 00:06:11,760
看看你觉得有趣的论文，

107
00:06:11,760 --> 00:06:13,050
所有的讨论都发表了，

108
00:06:13,410 --> 00:06:16,950
会议的优势之一，

109
00:06:16,950 --> 00:06:18,390
所有这些会议都是虚拟的，

110
00:06:18,390 --> 00:06:21,600
所以所有的会议都被记录下来了，

111
00:06:21,600 --> 00:06:24,180
你可以查看它们，看看发生了什么。

112
00:06:24,850 --> 00:06:27,100
如果你对这两部分感兴趣，

113
00:06:27,100 --> 00:06:28,390
这里有研究的部分，

114
00:06:28,780 --> 00:06:31,120
当然还有实践中正在进行的事情。

115
00:06:31,120 --> 00:06:32,890
如果你有兴趣

116
00:06:32,920 --> 00:06:34,810
跟踪 Linux 正在发生的事情，

117
00:06:34,810 --> 00:06:37,510
以及它是如何发展的，

118
00:06:37,870 --> 00:06:43,510
lwn.net 发布了常规的页面和非常有趣的文章，

119
00:06:43,510 --> 00:06:48,010
关于围绕 Linux 内核的重大变化或话题。

120
00:06:49,470 --> 00:06:53,910
最后，如果你对做实验感到兴奋，

121
00:06:53,910 --> 00:06:55,500
只需要继续 hack 就行了，

122
00:06:55,620 --> 00:06:58,920
我认为你可以很容易地创造出项目，

123
00:06:58,920 --> 00:07:02,310
要么通过扩展实验，

124
00:07:02,310 --> 00:07:03,870
或者试一试你自己的事情，

125
00:07:04,740 --> 00:07:09,360
这是学习和查看事物运作方式的一种很好的方式。

126
00:07:10,090 --> 00:07:12,310
你在实验里可能对此有很好的感觉，

127
00:07:12,310 --> 00:07:15,340
我们是边做边学的铁杆粉丝，

128
00:07:15,520 --> 00:07:19,990
还有很多你自己可以做的事。

129
00:07:22,930 --> 00:07:29,130
关于 6.S081 之后的下一步，还有什么问题吗？

130
00:07:41,410 --> 00:07:42,010
好的？

131
00:07:43,180 --> 00:07:46,630
好的，我们来谈谈网络实验，

132
00:07:47,360 --> 00:07:51,890
我想昨天就截止了。

133
00:07:56,100 --> 00:07:58,350
有几件事，

134
00:07:58,350 --> 00:08:01,440
我会慢慢开始深入，

135
00:08:01,440 --> 00:08:02,940
我从最高层开始，

136
00:08:03,300 --> 00:08:08,850
让我用普通术语来讨论一下实验。

137
00:08:13,390 --> 00:08:14,710
这里有几件事情，

138
00:08:14,710 --> 00:08:17,800
首先，我想稍微谈谈一些结构性的东西，

139
00:08:19,120 --> 00:08:21,820
这会影响实验的设计，

140
00:08:21,820 --> 00:08:23,650
或者实验的编码。

141
00:08:23,920 --> 00:08:26,500
这里有四种不同方面的东西，

142
00:08:26,500 --> 00:08:28,660
其中一个我想谈谈硬件，

143
00:08:29,140 --> 00:08:31,540
这是实验中的一个，

144
00:08:31,570 --> 00:08:34,360
软件和硬件之间有很多交互，

145
00:08:34,360 --> 00:08:37,090
事实上，硬件在很大程度上决定了

146
00:08:37,090 --> 00:08:39,370
软件的结构。

147
00:08:40,250 --> 00:08:42,470
然后稍微介绍一下软件结构，

148
00:08:43,170 --> 00:08:45,660
回到这个一般性的话题上来，

149
00:08:45,660 --> 00:08:48,480
我们在学期中期的某个地方谈到了，

150
00:08:48,480 --> 00:08:50,520
关于驱动的组织，

151
00:08:50,520 --> 00:08:52,560
相对于操作系统内核的其他部分。

152
00:08:52,890 --> 00:08:55,590
然后更多讨论一下关于硬件结构，

153
00:08:55,590 --> 00:08:59,680
rings ，以及描述符，

154
00:09:02,500 --> 00:09:04,690
是硬件结构的两个主要部分，

155
00:09:04,690 --> 00:09:07,840
驱动程序必须处理的。

156
00:09:08,780 --> 00:09:12,830
然后我会谈到代码，特别是解决方案，

157
00:09:13,220 --> 00:09:17,210
关注一下 mbufs 的作用，

158
00:09:19,780 --> 00:09:22,690
还有通过电子邮件的锁的很多问题，

159
00:09:22,690 --> 00:09:27,700
关于为什么不对接收函数加锁，

160
00:09:27,790 --> 00:09:30,370
为什么在接收处理程序中的循环，

161
00:09:31,140 --> 00:09:36,000
以及命令的标志代表什么，

162
00:09:36,060 --> 00:09:40,710
描述符结构的命令字段。

163
00:09:40,710 --> 00:09:42,120
我们将查看这些问题，

164
00:09:42,120 --> 00:09:44,820
同时查看代码。

165
00:09:47,110 --> 00:09:48,340
在开始之前，

166
00:09:48,340 --> 00:09:49,450
可能是值得的，

167
00:09:49,450 --> 00:09:50,620
在这里提醒我们自己，

168
00:09:50,620 --> 00:09:51,730
挑战是什么，

169
00:09:51,730 --> 00:09:54,040
尽管它们可能还在你的脑海中记忆犹新，

170
00:09:54,070 --> 00:09:55,690
从高级别来看，

171
00:09:55,690 --> 00:09:57,820
一个核心[]挑战，

172
00:09:57,820 --> 00:09:59,680
你必须在实验中解决的。

173
00:10:01,610 --> 00:10:04,130
你可以在任何时候跳进来，

174
00:10:04,130 --> 00:10:06,440
如果我可能错过的和你[挣扎]过的（问题）。

175
00:10:07,030 --> 00:10:09,610
首先，是硬件规格，

176
00:10:10,120 --> 00:10:13,780
这是一份 PDF 文件，

177
00:10:13,780 --> 00:10:15,520
是一份很严肃的文件，

178
00:10:15,970 --> 00:10:20,380
这个网卡 E1000 ，

179
00:10:20,380 --> 00:10:22,420
尽管它是一个非常简单的网卡，

180
00:10:22,420 --> 00:10:25,690
仍然是一个非常复杂的硬件，

181
00:10:25,690 --> 00:10:29,680
它提供了许多不同的功能和编程方式，

182
00:10:29,710 --> 00:10:32,260
你需要掌握，

183
00:10:32,260 --> 00:10:35,770
卡的功能，以及你是如何对它进行编程，

184
00:10:36,040 --> 00:10:41,680
它的内部是困难的，也是一个挑战。

185
00:10:46,520 --> 00:10:50,960
第二，我想你知道主要的挑战是事情的并发性，

186
00:10:52,620 --> 00:10:57,270
有两个部分的并发性使这个实验具有挑战性，

187
00:10:57,390 --> 00:11:00,210
一个就是硬件和软件之间的并发性，

188
00:11:01,060 --> 00:11:03,700
比如网卡在做一些事情，

189
00:11:03,700 --> 00:11:06,670
比如同时发送数据包，接收数据包，

190
00:11:06,670 --> 00:11:08,770
操作系统内核在运行，驱动程序也在运行，

191
00:11:09,100 --> 00:11:13,420
所以在硬件和软件之间必须有一些协调计划，

192
00:11:13,420 --> 00:11:15,790
确保每件事都能顺利解决，

193
00:11:16,860 --> 00:11:22,800
驱动的很大一部分都在处理这种协调问题。

194
00:11:23,860 --> 00:11:28,180
还有软件与软件的协调，

195
00:11:28,540 --> 00:11:30,700
驱动程序多个线程或多个内核线程

196
00:11:31,780 --> 00:11:36,100
可能在驱动程序内部运行的处理程序周围，

197
00:11:36,100 --> 00:11:37,060
我们要确保，

198
00:11:37,060 --> 00:11:41,470
它们不会互相践踏或类似的事情发生，

199
00:11:41,470 --> 00:11:46,430
这在锁主题中会有很多。

200
00:11:47,160 --> 00:11:49,140
即使这个驱动，

201
00:11:49,140 --> 00:11:54,990
就软件并发性而言，想法是非常直接的，

202
00:11:55,020 --> 00:11:58,440
但是尽管如此，你还是需要注意和思考一些事情。

203
00:11:59,260 --> 00:12:04,330
最后，我想可能在你的列表中，

204
00:12:04,330 --> 00:12:07,450
就是调试有点困难，

205
00:12:08,070 --> 00:12:10,740
更具挑战性的纯软件调试，

206
00:12:10,740 --> 00:12:14,490
因为你不能在网卡内部设置断点，

207
00:12:14,550 --> 00:12:17,340
你在对寄存器编程，

208
00:12:17,340 --> 00:12:20,490
然后它会让网卡做好工作，

209
00:12:20,970 --> 00:12:22,710
如果网卡什么也不做，

210
00:12:22,710 --> 00:12:24,990
或者你看不到你的数据包从另一端出来，

211
00:12:24,990 --> 00:12:29,720
在数据包率的记录中，

212
00:12:30,050 --> 00:12:32,750
那你就很挠头了，

213
00:12:32,750 --> 00:12:36,110
并开始思考可能出了什么问题，

214
00:12:36,110 --> 00:12:39,350
或者你可能在硬件规范中漏掉了什么，

215
00:12:40,220 --> 00:12:42,530
你必须来回绕圈，

216
00:12:42,530 --> 00:12:44,630
而且没有一种简单的方法，

217
00:12:44,630 --> 00:12:49,870
你不能单步调试网卡。

218
00:12:52,550 --> 00:12:54,290
就挑战而言，这能理解吗，

219
00:12:54,290 --> 00:12:56,840
这与你自己的经历是一致的，

220
00:12:56,840 --> 00:12:58,670
或者我错过了一些，

221
00:12:59,410 --> 00:13:01,930
错过了你处理的核心挑战。

222
00:13:18,330 --> 00:13:20,490
好的，好的。

223
00:13:21,390 --> 00:13:22,350
让我们来谈谈，

224
00:13:22,350 --> 00:13:24,360
让我们从硬件方面开始，

225
00:13:24,450 --> 00:13:27,870
我想从那里开始的原因是，

226
00:13:27,870 --> 00:13:31,380
因为，很容易记住或忘记这样一个事实，

227
00:13:31,380 --> 00:13:33,000
你是在和硬件打交道，

228
00:13:33,360 --> 00:13:38,820
即使通过某种虚拟化，使用 QEMU 对其进行模拟，

229
00:13:38,820 --> 00:13:42,810
你只是在你的 Athena 或笔记本电脑上运行它，

230
00:13:42,960 --> 00:13:46,410
QEMU 实现的实际是硬件。

231
00:13:46,590 --> 00:13:48,000
所以再次提醒你，

232
00:13:48,240 --> 00:13:50,880
你之前看过这张图片，

233
00:13:50,880 --> 00:13:52,680
你知道思考这件事的方式是，

234
00:13:52,680 --> 00:13:59,100
QEMU 模拟了一个完整的设备和处理器电路板。

235
00:13:59,750 --> 00:14:01,700
还有。

236
00:14:04,220 --> 00:14:07,520
所以，我们都知道，我在之前说过的，

237
00:14:07,520 --> 00:14:13,700
处理器就是整个电路板的一小块，

238
00:14:13,700 --> 00:14:15,440
是在风扇的下面的东西，

239
00:14:15,680 --> 00:14:19,010
但是还有一系列设备，

240
00:14:19,010 --> 00:14:22,310
这些设备都连接到或可以连接到这块板上，

241
00:14:22,640 --> 00:14:26,840
然后与运行在处理器的代码进行交互，

242
00:14:26,840 --> 00:14:29,210
在这里使用这个特殊的实验，

243
00:14:29,210 --> 00:14:30,740
真正有趣的是，

244
00:14:31,280 --> 00:14:32,930
它是以太网插孔，

245
00:14:33,050 --> 00:14:34,970
在那里你可以插入以太网电缆，

246
00:14:34,970 --> 00:14:38,660
然后另一个网卡把它的数据包送过来。

247
00:14:40,440 --> 00:14:44,250
QEMU 并不完全模仿这块板，

248
00:14:44,520 --> 00:14:45,690
所以事情略有不同，

249
00:14:45,690 --> 00:14:47,850
但是，至少在概念上，

250
00:14:47,850 --> 00:14:50,700
这个图片，你应该把它放在你的脑海里，

251
00:14:50,700 --> 00:14:54,210
当有进程写入寄存器时，

252
00:14:54,210 --> 00:14:57,540
设备驱动程序会花费一些东西才能发生，

253
00:14:57,540 --> 00:15:00,000
最终一些数据包从这根电缆里出来，

254
00:15:00,240 --> 00:15:03,370
它连接到以太网接口。

255
00:15:05,840 --> 00:15:08,600
你知道的更多的，

256
00:15:08,690 --> 00:15:16,940
在示意图中更多的，

257
00:15:16,940 --> 00:15:19,430
这里的图片是一样的，

258
00:15:19,430 --> 00:15:21,440
我们在这里看到的是处理器，

259
00:15:21,920 --> 00:15:24,230
电路板上面有四个核心，

260
00:15:24,440 --> 00:15:26,960
它有 L1 和 L2 缓存，

261
00:15:26,960 --> 00:15:29,420
然后有一个到内存的连接，

262
00:15:29,570 --> 00:15:32,690
这是一个内存， RAM 随机存取寄存器，

263
00:15:32,690 --> 00:15:34,250
正如我们稍后将看到的，

264
00:15:34,250 --> 00:15:36,110
它是一个重要的角色。

265
00:15:36,520 --> 00:15:39,370
这里[交叉]连接到，

266
00:15:39,730 --> 00:15:43,000
在这里连接到千兆以太网控制器，

267
00:15:44,350 --> 00:15:47,550
有点混乱，

268
00:15:47,550 --> 00:15:51,870
思考这个级别的细节是怎么回事。

269
00:15:51,930 --> 00:15:53,160
所以对于课程的剩余部分来说，

270
00:15:53,160 --> 00:15:56,040
这里的图片稍微简单一点，

271
00:15:58,240 --> 00:16:01,450
图片在你的脑海里，

272
00:16:01,780 --> 00:16:06,340
你可能是在做实验的时候开发的，如下所示。

273
00:16:07,780 --> 00:16:14,290
基本上有四个处理器或者核心，

274
00:16:15,470 --> 00:16:16,880
这里是 RISC-V ，

275
00:16:19,120 --> 00:16:22,450
然后这里是 RISC-V 核心，

276
00:16:22,450 --> 00:16:26,020
并执行你编写的指令，

277
00:16:26,170 --> 00:16:27,580
你可以想想看，

278
00:16:27,580 --> 00:16:29,560
它们都连接到总线上，

279
00:16:29,560 --> 00:16:31,840
然后有一个小的简化，

280
00:16:31,840 --> 00:16:34,360
这会让你更容易解释事情。

281
00:16:34,780 --> 00:16:37,870
在总线上，那里有随机存取存储器，

282
00:16:40,030 --> 00:16:43,960
其中有内核使用的所有数据存储，

283
00:16:43,960 --> 00:16:45,670
内核本身的存储，

284
00:16:45,670 --> 00:16:48,610
我们在学期开始的时候看到很多细节。

285
00:16:49,000 --> 00:16:50,860
然后对于这个实验，

286
00:16:50,860 --> 00:16:52,960
有趣的是，在总线上，

287
00:16:53,570 --> 00:16:59,360
是网卡 E1000 。

288
00:17:01,910 --> 00:17:06,680
RAM 通常连接到 RISC-V 处理器上，

289
00:17:06,680 --> 00:17:08,150
更多地是通过一些专用总线，

290
00:17:08,330 --> 00:17:13,250
而网络设备则是较慢类型的总线上，

291
00:17:13,460 --> 00:17:15,530
尤其是实验中的总线，

292
00:17:15,530 --> 00:17:19,010
这里有一条 PCIe 总线，

293
00:17:19,010 --> 00:17:24,090
连接处理器部分和网络部分。

294
00:17:27,260 --> 00:17:29,870
为了让网络做点事情，

295
00:17:29,990 --> 00:17:33,710
网卡内部有控制器，

296
00:17:33,710 --> 00:17:35,960
这些控制器有寄存器，

297
00:17:37,690 --> 00:17:38,890
而且你可以，

298
00:17:39,460 --> 00:17:42,250
这些寄存器的一个很酷的方面是，

299
00:17:42,250 --> 00:17:46,180
它们被称为内存映射 IO 寄存器，

300
00:17:46,390 --> 00:17:47,890
所以你可以写入它们，

301
00:17:47,890 --> 00:17:52,870
使用 *0x 或者别的什么值，

302
00:17:52,870 --> 00:17:55,180
对于在物理内存空间中，

303
00:17:55,330 --> 00:17:57,310
那个寄存器的值是多少，

304
00:17:57,760 --> 00:18:01,290
比如我们可能有头和尾寄存器。

305
00:18:02,260 --> 00:18:05,740
你知道我们可以，驱动程序可以写入它们，

306
00:18:05,740 --> 00:18:08,410
通过执行加载或存储指令，

307
00:18:08,710 --> 00:18:13,450
到对应物理地址空间这个地址，

308
00:18:13,570 --> 00:18:15,220
到寄存器的位置。

309
00:18:15,770 --> 00:18:18,620
硬件将确保当我们加载或存储时，

310
00:18:18,710 --> 00:18:21,950
那个存储要么去，

311
00:18:22,660 --> 00:18:25,900
如果它是控制寄存器，则转到控制寄存器，

312
00:18:25,900 --> 00:18:29,470
如果是在 RAM 中的地址，则会进入 RAM 中。

313
00:18:31,270 --> 00:18:35,050
所以，你可以对网卡编程，

314
00:18:35,050 --> 00:18:38,590
通过加载、读取和写入这些控制寄存器，

315
00:18:38,590 --> 00:18:42,310
正如你看到的，这些控制寄存器中的位具有特殊意义。

316
00:18:43,570 --> 00:18:46,490
现在，对于这个网卡，

317
00:18:46,490 --> 00:18:49,790
网卡需要通过网络发送数据包，

318
00:18:49,940 --> 00:18:52,070
而且它需要从某个地方获取数据包。

319
00:18:53,010 --> 00:18:55,770
所以，数据包实际上是在，

320
00:18:55,800 --> 00:18:58,320
就像我们稍后会看到的那样，

321
00:18:58,320 --> 00:18:59,820
分配在内存中的某个地方，

322
00:19:01,930 --> 00:19:04,840
我们所做的就是，

323
00:19:05,110 --> 00:19:06,910
实际上，除了这些数据包之外，

324
00:19:06,910 --> 00:19:09,910
还有两个环形结构也在内存中。

325
00:19:14,420 --> 00:19:20,710
而且，我们可以编程，

326
00:19:20,800 --> 00:19:22,960
我们可以告诉网卡，

327
00:19:22,960 --> 00:19:25,540
网卡也知道这些环形结构在哪里，

328
00:19:26,230 --> 00:19:28,900
它有 tx 环的地址，

329
00:19:28,900 --> 00:19:32,400
它有 rx 环的地址，

330
00:19:32,850 --> 00:19:37,530
硬件网卡会查看这些地址

331
00:19:37,530 --> 00:19:39,720
来查看需要发送哪些数据包，

332
00:19:39,840 --> 00:19:43,710
所以，在这里，我们可能有一个需要传输的数据包队列，

333
00:19:43,710 --> 00:19:45,690
或者一个需要接收的数据包队列。

334
00:19:48,910 --> 00:19:55,610
还有，你知道 E1000 ， DMA ，

335
00:19:55,610 --> 00:20:01,130
比如它们会在第一个数据包发送时工作，

336
00:20:01,130 --> 00:20:06,290
DMA 是那些与数据包关联的分组数据，

337
00:20:06,440 --> 00:20:09,260
直接从 RAM 到网络，

338
00:20:09,980 --> 00:20:12,350
在完全不涉及处理器的情况下，

339
00:20:13,400 --> 00:20:15,110
这就是所谓的 DMA ，即直接存储器存取。

340
00:20:19,130 --> 00:20:19,910
好的？

341
00:20:21,890 --> 00:20:25,220
这个概述图片能理解吗，

342
00:20:25,250 --> 00:20:32,120
对于 RISC-V RAM 和 E1000 的组织来说。

343
00:20:33,070 --> 00:20:34,330
对此有什么问题吗？

344
00:20:41,500 --> 00:20:45,490
所以，在谈论硬件、软件并发性时，

345
00:20:45,550 --> 00:20:49,690
显然，你知道 E1000 和处理器

346
00:20:49,690 --> 00:20:56,560
同时操纵这些发送和接收队列或环。

347
00:20:57,030 --> 00:20:58,650
所以，这里有某种协议，

348
00:20:58,860 --> 00:21:01,170
给出和获取协议，

349
00:21:01,230 --> 00:21:02,910
在某些情况下，

350
00:21:03,030 --> 00:21:08,790
环的部分是由网卡拥有和操作的，

351
00:21:08,790 --> 00:21:12,840
有些部分可能在软件或操作系统内核的控制下。

352
00:21:13,500 --> 00:21:15,750
稍后，你会看到这是如何安排的，

353
00:21:15,960 --> 00:21:17,910
但是我们需要小心，

354
00:21:17,910 --> 00:21:23,220
网卡不会[绊倒]操作系统，

355
00:21:23,220 --> 00:21:24,090
反之亦然。

356
00:21:28,540 --> 00:21:29,350
一个简单的问题，

357
00:21:29,380 --> 00:21:35,140
RAM 中是否有单独的发送环和接收环，

358
00:21:35,140 --> 00:21:40,270
然后，也在 E1000 驱动程序中。

359
00:21:40,570 --> 00:21:41,710
是的，有一种方法，

360
00:21:41,710 --> 00:21:43,330
好的，有两件事发生，

361
00:21:43,330 --> 00:21:44,920
我们稍后看一下代码，

362
00:21:45,100 --> 00:21:51,190
传输环和接收环驻留在 RAM 中，

363
00:21:51,740 --> 00:21:58,730
E1000 和 RISC-V 都可以操作存储在 RAM 中的环，

364
00:22:01,140 --> 00:22:04,950
这些就是你在硬件文档中看到的环。

365
00:22:05,520 --> 00:22:06,720
它是这种情况，

366
00:22:06,720 --> 00:22:12,780
xv6 也有一个驱动程序维护 mbuf 环，

367
00:22:13,110 --> 00:22:16,770
与发送环和 rx 环分开，

368
00:22:16,830 --> 00:22:18,840
比如有类似 tx mbuf 的东西。

369
00:22:21,460 --> 00:22:23,500
这是数据结构，

370
00:22:23,500 --> 00:22:25,420
只有操作系统才了解的，

371
00:22:25,840 --> 00:22:28,150
网卡并不知道这个，

372
00:22:28,150 --> 00:22:33,760
网卡只知道 tx 环和 rx 环，

373
00:22:33,850 --> 00:22:37,600
因为这些是编程到寄存器中的值，

374
00:22:37,720 --> 00:22:39,490
比如，这里你可以找到，

375
00:22:39,490 --> 00:22:41,470
这里你可以找到传送环的地址，

376
00:22:41,530 --> 00:22:43,270
这里你可以找到接收环的地址。

377
00:22:44,520 --> 00:22:45,450
好的，理解了。

378
00:22:45,660 --> 00:22:46,260
这个可以理解吗?

379
00:22:49,840 --> 00:22:52,000
好的，这就是硬件图片，

380
00:22:52,120 --> 00:22:55,750
一个更简明的版本。

381
00:22:55,930 --> 00:22:58,180
让我们稍微谈谈软件结构，

382
00:22:59,520 --> 00:23:02,760
在这个实验有一个很大的令人困惑的地方。

383
00:23:05,870 --> 00:23:07,010
所以，软件结构。

384
00:23:12,050 --> 00:23:14,990
所以，让我们画出

385
00:23:14,990 --> 00:23:17,330
我们最关心的事情，驱动程序，

386
00:23:17,360 --> 00:23:21,970
这是我们的驱动程序， E1000 驱动程序。

387
00:23:26,150 --> 00:23:28,790
它只有两个函数，

388
00:23:29,000 --> 00:23:37,600
它有一个 transmit 函数和一个 recv 函数。

389
00:23:40,810 --> 00:23:44,530
并且 recv 函数响应中断，

390
00:23:46,300 --> 00:23:47,560
所以中断发生了，

391
00:23:48,550 --> 00:23:53,860
然后 xv6 将使用通常的中断机制，

392
00:23:53,860 --> 00:23:55,150
一个 trap 发生，

393
00:23:55,540 --> 00:23:58,540
trap 查看网卡有没有中断，

394
00:23:58,540 --> 00:23:59,470
如果出现中断，

395
00:23:59,470 --> 00:24:01,240
网卡将调用 recv 函数。

396
00:24:02,600 --> 00:24:03,860
正如你们所记得的，

397
00:24:03,860 --> 00:24:07,490
我们曾经有一节关于设备驱动程序的课程，

398
00:24:07,580 --> 00:24:11,270
将设备驱动程序分成两部分通常是有帮助的，

399
00:24:11,760 --> 00:24:16,530
下半部分运行在中断处理程序的上下文中，

400
00:24:18,160 --> 00:24:20,320
通常命名为上半部分，

401
00:24:22,880 --> 00:24:29,360
它通常运行在内核进程或用户级进程的上下文中，

402
00:24:29,360 --> 00:24:32,750
比如，如果你想一下位于上面的东西，

403
00:24:32,930 --> 00:24:36,110
这里是网络栈代码，

404
00:24:36,110 --> 00:24:40,910
实现 IP UDP 等，位于这里。

405
00:24:41,430 --> 00:24:42,930
然后你知道，

406
00:24:43,500 --> 00:24:46,110
我们通常的线，

407
00:24:47,160 --> 00:24:50,220
内核空间在下面，用户空间在上面，

408
00:24:50,220 --> 00:24:53,250
这是操作系统的世界角度，

409
00:24:53,250 --> 00:24:56,820
用户空间不是特别大或特别重要，

410
00:24:57,090 --> 00:25:02,580
比如用户级程序的 nettest ，

411
00:25:03,090 --> 00:25:06,360
运行在用户空间并进行系统调用，

412
00:25:06,780 --> 00:25:10,650
系统调用进入网络栈，

413
00:25:11,010 --> 00:25:19,120
比如，使用文件描述符调用 write 系统调用，

414
00:25:19,420 --> 00:25:22,630
内核知道，如果你写入那个文件描述符，

415
00:25:22,630 --> 00:25:25,360
那么写入会发送到网络栈，

416
00:25:25,540 --> 00:25:27,520
网络栈建立数据包，

417
00:25:27,700 --> 00:25:29,260
然后它调用 transmit 。

418
00:25:30,830 --> 00:25:35,090
然后 transmit 操作发送队列，

419
00:25:35,090 --> 00:25:36,530
或 tx 队列或环，

420
00:25:36,710 --> 00:25:39,980
它会从网络中收到数据包，

421
00:25:40,010 --> 00:25:42,590
在某种程度上，响应可能会返回，

422
00:25:42,590 --> 00:25:44,120
那会引起中断，

423
00:25:44,270 --> 00:25:45,890
然后 recv 函数将运行

424
00:25:45,890 --> 00:25:50,090
并检查接收环。

425
00:25:50,760 --> 00:25:53,010
所以有几样东西，

426
00:25:53,560 --> 00:25:57,460
我想指出的是在并发性方面。

427
00:25:58,060 --> 00:26:00,670
所以，首先，中断处理器，

428
00:26:00,670 --> 00:26:03,520
可以运行在任何时间，

429
00:26:03,520 --> 00:26:05,380
可能是用户空间，

430
00:26:05,380 --> 00:26:06,490
如果出现中断，

431
00:26:06,520 --> 00:26:09,190
中断机制将导致

432
00:26:09,190 --> 00:26:12,790
当前用户程序切换到内核模式，

433
00:26:12,790 --> 00:26:15,220
你知道 trap 的功能代码，

434
00:26:15,220 --> 00:26:16,330
我们之前已经看到过，

435
00:26:16,330 --> 00:26:17,770
它将会全部收到。

436
00:26:17,770 --> 00:26:20,230
我们可能正处于某个用户进程中，

437
00:26:20,230 --> 00:26:21,640
我们得到一个中断，

438
00:26:21,640 --> 00:26:23,080
突然我们就进入了 recv 函数。

439
00:26:23,900 --> 00:26:24,890
即使在内核中，

440
00:26:24,890 --> 00:26:26,630
如果我们没有持有锁，

441
00:26:26,630 --> 00:26:28,070
锁会关闭中断，

442
00:26:28,070 --> 00:26:29,330
但我们没有持有锁，

443
00:26:29,330 --> 00:26:30,620
我们可能会被中断，

444
00:26:30,620 --> 00:26:36,770
内核会将程序计数器改变为中断处理程序，

445
00:26:36,770 --> 00:26:38,750
并运行 recv 函数。

446
00:26:39,560 --> 00:26:42,530
所以这段代码是运行在下半部分的东西，

447
00:26:42,530 --> 00:26:45,200
基本上任何时候都可以立刻运行。

448
00:26:45,950 --> 00:26:48,560
在上半部分的代码，

449
00:26:48,650 --> 00:26:53,300
它在用户级进程或内核线程运行，

450
00:26:53,300 --> 00:26:57,510
调用上半部分（的线程）。

451
00:26:58,080 --> 00:26:59,760
很容易的情况可能是，

452
00:27:00,060 --> 00:27:02,160
事实上，即使在 nettest 中，

453
00:27:02,160 --> 00:27:07,170
我们可能会对很多进程进行 nettest ，

454
00:27:07,470 --> 00:27:10,200
我们有很多实例，其中一个测试，

455
00:27:10,230 --> 00:27:12,210
我们有很多 nettest 运行的实例，

456
00:27:14,700 --> 00:27:17,190
并且它们都跳到网络栈中，

457
00:27:17,190 --> 00:27:20,370
它们都调用 transmit 。

458
00:27:20,820 --> 00:27:21,900
所以情况就是这样，

459
00:27:21,900 --> 00:27:24,240
所以我们从并发性的角度来看待这个问题，

460
00:27:24,420 --> 00:27:28,020
多个发送者可以位于上下文中，

461
00:27:28,020 --> 00:27:29,280
它可以位于上半部分，

462
00:27:29,310 --> 00:27:30,510
所以很明显，

463
00:27:30,510 --> 00:27:34,260
我们需要一些锁方案或准则，

464
00:27:34,260 --> 00:27:38,640
至少确保不同的发送者不会被对方绊倒。

465
00:27:40,380 --> 00:27:41,910
然后在下半部分，

466
00:27:42,480 --> 00:27:44,970
只有一个中断处理程序，

467
00:27:45,060 --> 00:27:48,360
永远不会有多个接收器同时运行，

468
00:27:48,570 --> 00:27:52,710
多个接收器并行同时运行在不同的核心上，

469
00:27:52,710 --> 00:27:57,000
当中断发生时的中断处理程序，

470
00:27:57,270 --> 00:27:59,130
进程会发出告警，

471
00:27:59,560 --> 00:28:02,260
如果将来发生中断，

472
00:28:02,260 --> 00:28:06,610
它们会被阻塞，直到当前中断被处理为止，

473
00:28:06,820 --> 00:28:11,670
所以事实上，当 recv 函数运行时，

474
00:28:11,910 --> 00:28:15,450
只有一个中断处理程序在运行。

475
00:28:15,450 --> 00:28:18,030
在调用 recv 时。

476
00:28:18,760 --> 00:28:24,360
所以，在 recv 本身中并不存在真正的并发，

477
00:28:24,360 --> 00:28:31,200
当然 transmit 线程可以与中断处理程序并发运行，

478
00:28:31,200 --> 00:28:34,110
比如，我们可能有一个核心运行中断处理程序，

479
00:28:34,320 --> 00:28:37,950
可能有另一个核心运行 transmit 。

480
00:28:39,860 --> 00:28:43,530
对于这个，有什么问题吗？

481
00:28:45,870 --> 00:28:50,540
它是一件很重要的需要理解的事情。

482
00:28:51,310 --> 00:28:53,350
这是一点复习，但也很重要。

483
00:29:00,400 --> 00:29:01,000
好的，那么。

484
00:29:01,030 --> 00:29:03,700
我想，我有一个一般性的问题，

485
00:29:03,790 --> 00:29:05,020
我们怎么知道，

486
00:29:05,740 --> 00:29:09,760
什么应该被归类为下半部分和上半部分？

487
00:29:10,430 --> 00:29:13,250
是的，我认为考虑这件事的方式是，

488
00:29:13,250 --> 00:29:15,410
在中断处理程序的上下文中运行的任何东西，

489
00:29:15,440 --> 00:29:16,280
都是下半部分，

490
00:29:17,330 --> 00:29:19,370
在这种情况下，就是接收。

491
00:29:20,700 --> 00:29:26,410
而在常规进程或内核线程的上下文中运行的任何东西，

492
00:29:26,440 --> 00:29:27,880
就是上半部分。

493
00:29:32,200 --> 00:29:37,720
好的，如果你再仔细看一下这张图片，

494
00:29:38,080 --> 00:29:38,860
从哪里，

495
00:29:39,010 --> 00:29:41,770
让我在这里做一个高级别的声明，

496
00:29:41,920 --> 00:29:45,280
很多人问为什么没有对接收加锁，

497
00:29:46,320 --> 00:29:49,620
以及哪里需要加锁。

498
00:29:49,950 --> 00:29:53,070
所以第一眼看上去，

499
00:29:53,680 --> 00:29:56,200
它可能不需要加锁，

500
00:29:56,200 --> 00:29:59,710
因为只有一个正在运行的接收实例，

501
00:29:59,740 --> 00:30:02,620
没有同时运行多个接收实例，

502
00:30:02,770 --> 00:30:03,940
所以这些接收，

503
00:30:03,970 --> 00:30:05,170
因为只有一个接收，

504
00:30:05,200 --> 00:30:07,450
所以它不与任何其他接收共享数据结构，

505
00:30:07,450 --> 00:30:08,860
因为只有一个。

506
00:30:09,380 --> 00:30:10,850
现在，当然可以是这种情况，

507
00:30:10,850 --> 00:30:13,640
接收者和发送者共享数据结构，

508
00:30:13,670 --> 00:30:16,340
但是我们随后会看到，不是这种情况，

509
00:30:16,860 --> 00:30:20,730
驱动程序的发送部分完全独立于

510
00:30:20,730 --> 00:30:24,900
驱动程序的接收部分，接收数据包。

511
00:30:25,380 --> 00:30:29,400
所以，接收并不需要真正加锁，

512
00:30:29,430 --> 00:30:32,700
它并不与任何其他并发活动共享数据结构。

513
00:30:34,400 --> 00:30:37,910
奇怪的是，你们中的一些人发现，

514
00:30:37,910 --> 00:30:41,380
如果你使用了锁，会引发 panic 。

515
00:30:42,100 --> 00:30:44,470
所以让我简单地说一下，

516
00:30:44,470 --> 00:30:47,830
因为 panic 发生的原因是，

517
00:30:47,830 --> 00:30:48,790
有一点是因为，

518
00:30:48,790 --> 00:30:54,610
在 xv6 内核中的软件结构

519
00:30:56,740 --> 00:30:58,750
比你想象的要稍微复杂一些，

520
00:30:58,960 --> 00:31:00,760
原因是，

521
00:31:00,760 --> 00:31:04,630
接收中断处理程序做了相当多的工作，

522
00:31:05,140 --> 00:31:06,790
或者可以做相当多的工作，

523
00:31:07,090 --> 00:31:08,470
所以让我稍微谈谈这件事。

524
00:31:09,430 --> 00:31:12,700
在特定的情况下，它做了相当多的工作，

525
00:31:12,700 --> 00:31:16,550
比如， ARP 请求，

526
00:31:20,180 --> 00:31:23,690
ARP 是 Robert 之前谈到的数据包类型之一，

527
00:31:23,990 --> 00:31:26,720
但发生的事情就是中断进来，

528
00:31:27,570 --> 00:31:35,700
ARP 请求用来使用 IP 地址发现以太网地址，

529
00:31:35,700 --> 00:31:39,620
它会调用 eth1000_recv ，

530
00:31:43,400 --> 00:31:46,700
它会调用 net_rx ，

531
00:31:46,700 --> 00:31:51,500
这样就会调用前面图片上的网络栈，

532
00:31:51,500 --> 00:31:55,280
让接收可以调用进入这里的代码，

533
00:31:56,460 --> 00:31:59,190
net receive 调用，

534
00:32:03,540 --> 00:32:10,680
糟糕， net receive 调用 net_rx_arp ，

535
00:32:12,690 --> 00:32:16,560
而且它查看，这里有一个 ARP 数据包，

536
00:32:16,560 --> 00:32:24,000
并且发回 xv6 的以太网地址，

537
00:32:24,210 --> 00:32:27,270
然后它做的是发送数据包，

538
00:32:27,270 --> 00:32:36,860
它会调用 e1000_transmit ，

539
00:32:36,860 --> 00:32:40,280
我们知道，这需要获取一把锁，

540
00:32:42,070 --> 00:32:45,550
你使用 eth1000_lock 来完成它。

541
00:32:50,860 --> 00:32:53,020
这里必须加锁的原因是，

542
00:32:53,020 --> 00:32:54,910
因为可能有多个发送者，

543
00:32:54,910 --> 00:32:59,350
发送者不应该被对方[绊倒]。

544
00:33:00,440 --> 00:33:02,270
所以这是一张图，

545
00:33:02,270 --> 00:33:04,520
所以我们就前一张图片而言，

546
00:33:04,520 --> 00:33:05,840
我们在这里看到的是，

547
00:33:06,590 --> 00:33:12,770
下半部分可能最终会调用上半部分中的代码，

548
00:33:12,950 --> 00:33:16,010
然后从上半部分回到驱动程序。

549
00:33:17,400 --> 00:33:20,940
你在这里遇到了麻烦，

550
00:33:20,940 --> 00:33:25,170
因为不是百分之百清楚，

551
00:33:25,170 --> 00:33:29,610
你不需要在接收部分加锁，

552
00:33:29,730 --> 00:33:32,070
所以你们中很多人遇到了这种特殊的 bug ，

553
00:33:32,070 --> 00:33:43,700
你在接收中获取了 eth1000_lock 。

554
00:33:45,460 --> 00:33:46,750
这一切都很正常，

555
00:33:46,750 --> 00:33:48,400
只是偶尔你会得到 panic ，

556
00:33:49,670 --> 00:33:51,110
为什么你会得到 panic ，

557
00:33:52,140 --> 00:33:54,060
希望这张图片能让你看得很清楚。

558
00:33:59,400 --> 00:34:01,590
我是说，这不是同一把锁吗，

559
00:34:01,590 --> 00:34:05,280
因为 e1000_transmit 将尝试获取 e1000_lock 。

560
00:34:05,610 --> 00:34:07,020
是的，没错，

561
00:34:07,380 --> 00:34:10,890
所以在这一点上， eth1000 拥有这把锁，

562
00:34:10,890 --> 00:34:14,280
调用 net_rx ，调用 net_rx_arp ，e1000_transmit ，

563
00:34:14,280 --> 00:34:15,420
然后再次调用获取，

564
00:34:15,780 --> 00:34:17,760
你们可能还记得以前的实验，

565
00:34:17,940 --> 00:34:21,240
如果叫它调用获取已经持有的，

566
00:34:21,610 --> 00:34:23,440
这会是个死锁，

567
00:34:23,440 --> 00:34:25,600
所以 xv6 内核出现了 panic 。

568
00:34:28,240 --> 00:34:32,620
问题，假设我们的锁实现略有不同，

569
00:34:32,620 --> 00:34:34,630
比如那些函数没有发生，

570
00:34:35,480 --> 00:34:37,220
比如，它将，

571
00:34:37,400 --> 00:34:40,010
假设，如果我想获得已经持有的锁，

572
00:34:40,010 --> 00:34:40,820
而且什么都没有发生。

573
00:34:41,060 --> 00:34:45,110
是的，这就是所谓的递归锁，

574
00:34:47,660 --> 00:34:50,750
或者另一种名称是可重入锁。

575
00:34:51,580 --> 00:34:54,460
所以如果你有一个递归锁，可重入锁，

576
00:34:54,460 --> 00:34:56,530
然后你可以自由地做这件事，

577
00:34:56,530 --> 00:34:57,520
它不会有问题。

578
00:34:58,170 --> 00:35:01,890
我想你们中的一位在电子邮件中提到，

579
00:35:01,890 --> 00:35:05,970
实现递归锁才能真正解决这个问题。

580
00:35:06,660 --> 00:35:11,100
所以他们在 eth1000_recv 函数中获取锁，

581
00:35:11,370 --> 00:35:14,010
在 panic 之后，

582
00:35:14,010 --> 00:35:16,770
修复在 xv6 中的获取和释放，

583
00:35:16,770 --> 00:35:18,720
通过支持递归锁。

584
00:35:20,760 --> 00:35:21,810
这也是一个解决方案。

585
00:35:23,240 --> 00:35:25,820
一个简单的解决方案，

586
00:35:25,880 --> 00:35:31,970
我们计划的和工作人员的解决方案是，

587
00:35:31,970 --> 00:35:35,120
根本不需要在接收中获取锁，

588
00:35:35,120 --> 00:35:37,100
因为这是没有必要的。

589
00:35:39,910 --> 00:35:41,110
对不起，你能再说一遍吗，

590
00:35:41,110 --> 00:35:45,070
为什么在接收中不能有两个线程？

591
00:35:46,550 --> 00:35:49,310
在接收中只有一个线程，即运行中断处理程序，

592
00:35:49,930 --> 00:35:53,200
在任何内核上，一次只有一个接收函数在运行，

593
00:35:54,110 --> 00:36:00,770
它会调用操作系统的上半部分，

594
00:36:01,160 --> 00:36:04,280
然后调用回到下半部分，

595
00:36:05,180 --> 00:36:07,940
抱歉，不在下半部分，调用回到 e1000_transmit ，

596
00:36:07,940 --> 00:36:09,980
而 transmit 肯定需要获取锁，

597
00:36:10,430 --> 00:36:16,840
所以，即使 eth1000_recv 在持有锁的同时调用 e1000_transmit ，

598
00:36:16,900 --> 00:36:20,650
e1000_transmit 尝试获取中断处理程序已经持有的相同的锁，

599
00:36:21,600 --> 00:36:25,080
如果你在接收处理程序中持有锁。

600
00:36:26,830 --> 00:36:30,270
我明白了，所以是这样的，

601
00:36:30,270 --> 00:36:33,060
比如一次中断会发生，

602
00:36:33,060 --> 00:36:36,270
然后，当它还在运行时，

603
00:36:36,390 --> 00:36:39,510
另一个中断可能也会发生。

604
00:36:39,510 --> 00:36:42,870
不，不是，那张图片，也许可以回到这张图片上，

605
00:36:43,170 --> 00:36:46,370
所以中断发生了，它调用接收函数，

606
00:36:46,760 --> 00:36:48,500
这里只有一个接收函数运行，

607
00:36:48,620 --> 00:36:53,390
接收函数调用 rx net receive ，

608
00:36:53,390 --> 00:36:55,220
它调用 net_rx_arp ，

609
00:36:55,430 --> 00:36:58,040
那个 arp 函数调用 transmit ，

610
00:36:58,740 --> 00:37:02,460
如果你在发送和接收中使用相同的锁，

611
00:37:02,580 --> 00:37:03,870
你会陷入死锁。

612
00:37:08,100 --> 00:37:09,600
好的，我明白了，谢谢。

613
00:37:13,660 --> 00:37:14,710
有点像是，好的，

614
00:37:15,540 --> 00:37:17,430
所以基本上有两种解决方案，

615
00:37:17,460 --> 00:37:19,440
一种是使用递归锁，

616
00:37:20,370 --> 00:37:24,560
另一种解决方案是不在接收中使用锁，

617
00:37:25,790 --> 00:37:27,740
或者使用两把锁。

618
00:37:31,040 --> 00:37:33,260
这三个都是完全合理的解决方案。

619
00:37:37,000 --> 00:37:38,050
对于这个，有什么问题吗？

620
00:37:39,070 --> 00:37:42,610
会不会有理由在接收周围加锁呢？

621
00:37:42,910 --> 00:37:44,770
不，在这种情况下，

622
00:37:44,770 --> 00:37:46,360
根本没有理由加锁。

623
00:37:49,540 --> 00:37:52,570
我们能想出这样一种情况，

624
00:37:52,570 --> 00:37:54,490
如果你想要一个接收锁，

625
00:37:54,490 --> 00:37:57,970
比如你有两块网卡之类的。

626
00:37:58,550 --> 00:38:03,620
是的，如果你还记得 UART 代码，

627
00:38:03,980 --> 00:38:10,760
好的，你可能想要锁的一个常见原因是，

628
00:38:10,760 --> 00:38:15,020
因为下半部分和上半部分共享了数据结构。

629
00:38:17,200 --> 00:38:21,850
所以，比如，接收和发送可能操作相同的共享数据结构，

630
00:38:22,090 --> 00:38:24,100
在这一点上，你需要一把锁，

631
00:38:24,160 --> 00:38:26,560
比如，你记得在控制台驱动程序中，

632
00:38:27,060 --> 00:38:28,320
它们共享一个队列，

633
00:38:29,100 --> 00:38:32,970
所以接收处理程序需要获得队列，

634
00:38:33,120 --> 00:38:35,550
需要获取锁才能访问那个队列。

635
00:38:39,480 --> 00:38:40,680
这回答了你的问题吗？

636
00:38:42,500 --> 00:38:43,580
是的，谢谢。

637
00:38:44,720 --> 00:38:47,510
这就引出了我想提出的第二点。

638
00:38:48,230 --> 00:38:52,700
让我画一幅新图，

639
00:38:52,700 --> 00:38:53,930
因为它有点拥挤。

640
00:38:54,350 --> 00:38:57,740
我们再次考虑下半部分和上半部分。

641
00:39:00,670 --> 00:39:01,450
所以，这是下半部分，

642
00:39:01,450 --> 00:39:04,390
有点抽象，但是它可能会有帮助。

643
00:39:07,110 --> 00:39:11,610
在多数驱动程序软件中，

644
00:39:11,640 --> 00:39:16,560
下半部分基本上不会真正进入上半部分。

645
00:39:17,360 --> 00:39:20,870
所以，如果你返回并查看控制台代码，

646
00:39:21,080 --> 00:39:24,500
这个序列不可能在那里发生，

647
00:39:24,530 --> 00:39:25,880
而没有发生的原因是，

648
00:39:25,880 --> 00:39:28,310
因为下半部分通常做的工作很少，

649
00:39:28,550 --> 00:39:30,890
它唯一能做的就是抓到包，

650
00:39:31,100 --> 00:39:32,330
把包放在队列里。

651
00:39:34,000 --> 00:39:35,560
然后，在后来的某个时候，

652
00:39:35,680 --> 00:39:40,980
在上半部分有一个单独的线程，

653
00:39:40,980 --> 00:39:43,590
它查看那个队列，然后从队列中抓取数据包，

654
00:39:43,590 --> 00:39:45,570
然后继续做任何需要做的事。

655
00:39:46,400 --> 00:39:51,650
现在，在这一简单性并减少的代码里，

656
00:39:51,860 --> 00:39:54,620
这不是这些特殊的驱动程序遵循的结构，

657
00:39:54,830 --> 00:39:58,800
这个驱动可能偶尔会调用，

658
00:39:58,800 --> 00:40:02,840
有时驱动遵循这个结构，

659
00:40:02,840 --> 00:40:05,690
但偶尔，它可以进入上半部分

660
00:40:05,780 --> 00:40:07,970
然后回到下半部分。

661
00:40:15,210 --> 00:40:16,140
对此有什么问题吗？

662
00:40:23,120 --> 00:40:27,500
好的，我想这是某种程度上的软件并发性，

663
00:40:27,500 --> 00:40:28,970
稍后我们会回到更多的话题，

664
00:40:28,970 --> 00:40:30,920
如果我们更详细地看一下代码，

665
00:40:31,440 --> 00:40:33,570
稍微谈一下关于环的事。

666
00:40:37,540 --> 00:40:39,640
所以基本上就像你想的那样，

667
00:40:39,640 --> 00:40:42,670
这里有环，

668
00:40:42,880 --> 00:40:47,260
有两个环，一个用于接收，一个用于发送，

669
00:40:47,260 --> 00:40:51,790
tx tx 都在 RAM 里。

670
00:40:52,510 --> 00:40:58,600
它们是由运行在 RISC-V 核心上的代码操作的，

671
00:40:58,600 --> 00:41:01,030
以及网卡本身。

672
00:41:01,710 --> 00:41:03,060
所以有某种协议，

673
00:41:03,060 --> 00:41:07,380
在网卡和 RISC-V 之间，

674
00:41:07,410 --> 00:41:09,780
关于谁可以查看什么，

675
00:41:10,020 --> 00:41:15,270
所以，这是硬件设备中非常常见的组织方式，

676
00:41:15,270 --> 00:41:16,680
通常的做法是，

677
00:41:16,680 --> 00:41:18,690
在某种程度上，看看传输队列，

678
00:41:18,690 --> 00:41:21,930
有一些固定大小的结构描述符的队列，

679
00:41:21,960 --> 00:41:23,790
我们马上就会看到，

680
00:41:24,060 --> 00:41:25,230
这些是描述符。

681
00:41:29,360 --> 00:41:33,320
组织或协调，

682
00:41:33,320 --> 00:41:39,260
发生在驱动程序和网卡之间的是，

683
00:41:39,260 --> 00:41:46,140
消费者与生产者的协调。

684
00:41:47,430 --> 00:41:49,350
可以用一种方式来考虑，

685
00:41:49,350 --> 00:41:52,470
如果这是传输队列，

686
00:41:52,470 --> 00:41:54,450
也许这里有个头指针，

687
00:41:56,520 --> 00:41:57,840
这里有一个尾指针，

688
00:42:00,440 --> 00:42:04,400
尾指针是由软件控制的，

689
00:42:05,580 --> 00:42:07,590
所以软件会查看尾指针，

690
00:42:07,590 --> 00:42:10,650
它想发送另一个数据包，

691
00:42:10,650 --> 00:42:14,910
把它放在在环里尾指针加 1 的位置，

692
00:42:14,910 --> 00:42:17,400
然后把尾指针向那个方向移动。

693
00:42:19,240 --> 00:42:22,330
而头指针通常由硬件控制。

694
00:42:24,750 --> 00:42:27,030
所以尾由软件控制，头由硬件控制，

695
00:42:27,030 --> 00:42:29,820
基本上，硬件查看头指针，

696
00:42:29,820 --> 00:42:31,980
这里第一个数据包是要发送的，

697
00:42:32,040 --> 00:42:34,530
在描述符里有一些信息，

698
00:42:34,680 --> 00:42:38,310
或者描述符有网卡要查看的足够多的信息，

699
00:42:38,310 --> 00:42:43,770
比如，这是我要移动到电缆的字节。

700
00:42:44,950 --> 00:42:48,670
一旦完成，它就会将头指针朝那个方向移动，

701
00:42:48,790 --> 00:42:52,630
一旦它使用传输队列中的一个数据包。

702
00:42:53,630 --> 00:42:55,160
考虑这个问题的一种方式是，

703
00:42:55,430 --> 00:43:01,400
所以在这里和尾之间的所有描述符，

704
00:43:02,540 --> 00:43:05,240
所以填入的所有东西，

705
00:43:05,720 --> 00:43:08,930
比如尾指针移动到了这里。

706
00:43:12,540 --> 00:43:13,290
所以数据包，

707
00:43:13,290 --> 00:43:16,200
作为填充的所有描述符条目，

708
00:43:16,260 --> 00:43:17,880
你考虑它们的方法是，

709
00:43:18,640 --> 00:43:21,190
它们属于网卡硬件。

710
00:43:21,810 --> 00:43:25,230
网卡允许读取它们，用它们做事情，

711
00:43:25,350 --> 00:43:29,580
但是软件不允许对它们做任何事情，

712
00:43:29,760 --> 00:43:33,780
如果软件在这些描述符上[乱涂乱画]，

713
00:43:34,080 --> 00:43:38,880
它们在某种程度上是由网卡拥有的，

714
00:43:39,000 --> 00:43:42,240
这将改变网卡看到的数据，

715
00:43:42,240 --> 00:43:43,800
这将是非常不想看到的。

716
00:43:44,460 --> 00:43:47,550
所以，协议基本上是，

717
00:43:47,550 --> 00:43:50,880
就像软件将尾指针向上移动了一个，

718
00:43:51,060 --> 00:43:56,100
然后你刚刚移动的点会到网络传输队列中，

719
00:43:56,130 --> 00:43:57,450
现在归硬件所有，

720
00:43:57,780 --> 00:43:58,950
它会在，

721
00:43:58,950 --> 00:44:03,090
它将归硬件所有，直到它必须被发送出去，

722
00:44:03,210 --> 00:44:07,140
直到头指针移动过那个特定的结构。

723
00:44:09,890 --> 00:44:10,760
这能理解吗？

724
00:44:18,950 --> 00:44:21,380
很好，对于传输来说，也是一样的故事，

725
00:44:21,410 --> 00:44:24,230
有一个头指针，

726
00:44:24,880 --> 00:44:30,740
它是由硬件控制的，

727
00:44:30,770 --> 00:44:32,150
这里有一个尾指针，

728
00:44:32,150 --> 00:44:35,800
它是由软件控制的，

729
00:44:37,340 --> 00:44:39,710
在两者之间的数据包

730
00:44:40,840 --> 00:44:47,920
是硬件已接收到的数据包，

731
00:44:47,920 --> 00:44:53,110
通过期待尾指针，

732
00:44:53,110 --> 00:44:55,180
软件可以查看是否真的有新的数据包，

733
00:44:55,180 --> 00:44:57,850
它已经准备好可以使用了，

734
00:44:57,850 --> 00:44:59,440
如果它已准备好可以使用，

735
00:44:59,440 --> 00:45:02,950
硬件将通过在状态字段中声明 DD 位来表示。

736
00:45:03,440 --> 00:45:05,210
因此当设置 DD 位时，

737
00:45:05,270 --> 00:45:06,740
硬件和软件都是好的，

738
00:45:06,770 --> 00:45:09,200
这些数据包，硬件已经完成了，

739
00:45:09,530 --> 00:45:13,220
所以可以把它拿出来，把尾指针向上移动一个。

740
00:45:14,920 --> 00:45:21,700
所以，在驱动程序和硬件之间存在某种的收发，

741
00:45:21,730 --> 00:45:24,880
为了协调它们不会被对方[绊倒]。

742
00:45:27,340 --> 00:45:31,840
关于环，有什么问题吗？

743
00:45:36,200 --> 00:45:36,920
这是不是，

744
00:45:36,980 --> 00:45:41,810
这是不是一种普遍的实现方式，

745
00:45:41,810 --> 00:45:45,680
比如用户或具有共享内存的两个东西之间的通信？

746
00:45:46,270 --> 00:45:49,090
是的，这当然是在软件中，

747
00:45:49,090 --> 00:45:51,880
但是很多硬件设备也使用这种技巧，

748
00:45:52,510 --> 00:46:00,250
在硬件和软件之间进行生产者和消费者风格的协调。

749
00:46:05,350 --> 00:46:06,820
所以，是的，它是非常常见的结构。

750
00:46:08,430 --> 00:46:11,250
也许你可以问一两个问题，

751
00:46:11,460 --> 00:46:14,280
比如为什么是队列，为什么是环。

752
00:46:14,910 --> 00:46:16,410
好的，这里有一个环，

753
00:46:16,410 --> 00:46:20,250
因为队列环绕使其大小固定，

754
00:46:21,590 --> 00:46:25,730
但是为什么不让队列一个条目，

755
00:46:27,900 --> 00:46:29,190
就像 UART 一样，

756
00:46:29,550 --> 00:46:32,550
你还记得 UART 驱动程序和控制器

757
00:46:32,550 --> 00:46:35,670
只有一个寄存器发送一个字节，

758
00:46:35,670 --> 00:46:37,230
另一个寄存器接收一个字节。

759
00:46:38,880 --> 00:46:42,450
那么，为什么要选择这个复杂的方案，

760
00:46:42,450 --> 00:46:44,250
你可以只使用一个寄存器，

761
00:46:44,250 --> 00:46:47,040
然后你可以告诉硬件，

762
00:46:47,040 --> 00:46:48,690
这个寄存器现在已经准备好了，发送它，

763
00:46:49,390 --> 00:46:52,500
然后你就等这件事完成。

764
00:46:55,300 --> 00:46:59,950
为了允许在有数据包突发时使用。

765
00:47:00,480 --> 00:47:02,530
是的，就是这样，

766
00:47:02,860 --> 00:47:07,750
网卡或电缆的网络接口性能非常高，

767
00:47:07,750 --> 00:47:10,630
性能非常高，每秒千兆。

768
00:47:11,310 --> 00:47:14,910
所以，这对核心来说可能很困难，

769
00:47:14,910 --> 00:47:16,260
处理器跟上它，

770
00:47:16,290 --> 00:47:18,660
所以你想给它一大堆数据包，

771
00:47:18,660 --> 00:47:21,030
网络或网卡[块]，

772
00:47:21,030 --> 00:47:22,740
把它们高速发送出去。

773
00:47:23,280 --> 00:47:26,880
类似地，在接收中，你可能会收到突发的数据包进来，

774
00:47:27,270 --> 00:47:29,370
你想把它们放在队列里，

775
00:47:29,370 --> 00:47:33,710
然后操作系统开始处理队列。

776
00:47:35,090 --> 00:47:36,830
所以这是一种常见的，

777
00:47:39,270 --> 00:47:45,010
这就是原因，这些队列通常用于处理突发。

778
00:47:48,910 --> 00:47:51,700
如果队列满了怎么办，比如接收。

779
00:47:58,950 --> 00:48:02,610
我想文件提到了，

780
00:48:02,610 --> 00:48:05,790
它做了某种形式的丢弃尾的方案。

781
00:48:06,810 --> 00:48:10,290
是的，基本上数据包会被丢弃。

782
00:48:11,170 --> 00:48:13,420
所以，任何未来传入的数据包，

783
00:48:13,420 --> 00:48:17,230
如果队列已满，环里没有地方了，

784
00:48:17,230 --> 00:48:19,390
网卡不能对它们执行任何操作，

785
00:48:19,390 --> 00:48:23,830
所以它唯一能做的就是删除数据包，

786
00:48:23,860 --> 00:48:26,930
或者没有添加到环中，因此消失。

787
00:48:27,890 --> 00:48:30,560
所以，有时这是丢包的一个原因，

788
00:48:31,170 --> 00:48:33,660
并且操作系统过载，

789
00:48:33,690 --> 00:48:36,330
数据包跟不上，环被填满了，

790
00:48:36,540 --> 00:48:38,670
然后数据包会被丢弃。

791
00:48:41,110 --> 00:48:42,130
更高级的软件，

792
00:48:42,130 --> 00:48:46,840
比如 TCP 连接可能会重新传输这些数据包，

793
00:48:47,110 --> 00:48:49,660
但这是数据包可能被丢弃的原因之一。

794
00:48:52,730 --> 00:48:56,030
所以即使硬件运行得很好，

795
00:48:56,150 --> 00:48:57,830
由于这些突发，

796
00:48:57,830 --> 00:48:59,870
一些数据包可能会被删除。

797
00:49:01,240 --> 00:49:02,920
所以，你有一个非常大的突发。

798
00:49:07,010 --> 00:49:10,010
头指针和尾指针，

799
00:49:10,010 --> 00:49:12,560
它们都是队列的软件抽象吧？

800
00:49:13,160 --> 00:49:15,740
好的，这些是，

801
00:49:15,740 --> 00:49:18,320
这些是控制寄存器，

802
00:49:18,320 --> 00:49:22,370
所以有一个用于头指针的控制寄存器，

803
00:49:22,370 --> 00:49:25,970
有一个用于尾指针的控制寄存器，

804
00:49:26,060 --> 00:49:28,010
硬件和软件之间没有真正的区分，

805
00:49:28,010 --> 00:49:30,110
基本上驱动知道尾指针，

806
00:49:30,110 --> 00:49:35,490
并且硬件知道尾指针和头指针，

807
00:49:35,520 --> 00:49:37,050
并使用基本的控制寄存器。

808
00:49:37,720 --> 00:49:38,410
好的，好的。

809
00:49:39,070 --> 00:49:40,300
我们稍后会看代码，

810
00:49:40,300 --> 00:49:41,260
它是如何出现的，

811
00:49:42,810 --> 00:49:44,280
确保如果你回到，

812
00:49:44,610 --> 00:49:48,420
让我们看看这张图片还在这里，

813
00:49:48,840 --> 00:49:51,210
这是我们之前看过的那张图片，

814
00:49:51,540 --> 00:49:54,660
这是一个控制寄存器，持有头指针，

815
00:49:54,780 --> 00:49:57,060
这是持有尾指针的控制寄存器，

816
00:49:57,060 --> 00:50:00,480
当然还有一个是接收的，一个是发送的。

817
00:50:04,300 --> 00:50:04,930
好的?

818
00:50:08,810 --> 00:50:10,280
我们回到这里。

819
00:50:11,290 --> 00:50:14,140
好的，我们来谈谈描述符。

820
00:50:15,250 --> 00:50:18,310
所以描述符由硬件定义的，

821
00:50:18,730 --> 00:50:20,140
所以硬件表示，

822
00:50:20,140 --> 00:50:22,240
这是描述符应该是什么样子，

823
00:50:22,240 --> 00:50:25,660
而你的驱动，这些是可以填入的位，

824
00:50:25,660 --> 00:50:28,930
如果你填入那个位，告诉我。

825
00:50:29,270 --> 00:50:34,350
所以这里有两个描述符很重要，

826
00:50:34,380 --> 00:50:40,160
这是接收描述符 rx ，

827
00:50:40,160 --> 00:50:42,680
这是 tx 描述符。

828
00:50:43,380 --> 00:50:45,960
所以让我们稍微看一下。

829
00:50:46,600 --> 00:50:48,370
是的，它是，

830
00:50:48,820 --> 00:50:52,990
可能最重要的部分是这个地址，

831
00:50:53,530 --> 00:50:56,560
这就是软件填写的地址，

832
00:50:56,560 --> 00:51:00,370
说明硬件应该将数据包转存到哪里，

833
00:51:00,490 --> 00:51:04,690
在 RAM 的什么地方，

834
00:51:04,930 --> 00:51:09,100
网卡应该把接收到的数据放到 RAM 的什么地方，

835
00:51:09,220 --> 00:51:12,460
所以，它是接收缓冲区的地址。

836
00:51:17,080 --> 00:51:20,500
然后可能最重要的部分是

837
00:51:20,560 --> 00:51:23,470
是你已经看到的 status 字段。

838
00:51:24,020 --> 00:51:28,370
所以当驱动还在继续查看尾指针的时候，

839
00:51:28,430 --> 00:51:31,460
看到收到了一个新的数据包，

840
00:51:31,670 --> 00:51:34,490
它判断是否接收到新数据包的方式是，

841
00:51:34,670 --> 00:51:39,450
是 DD 位，是由硬件设置的。

842
00:51:40,540 --> 00:51:47,290
阴影区域是数据包描述符的字段，

843
00:51:47,920 --> 00:51:50,890
接收描述符是硬件填入的，

844
00:51:51,010 --> 00:51:53,620
白色的未加阴影的是

845
00:51:53,620 --> 00:51:56,860
由软件填入的加阴影的字段，

846
00:51:57,100 --> 00:51:59,470
我们在这里看到了明显区别，

847
00:51:59,680 --> 00:52:01,240
一些归软件所有，

848
00:52:01,270 --> 00:52:05,690
一些归硬件所有。

849
00:52:08,760 --> 00:52:13,290
好的，还有一个类似的描述符，

850
00:52:13,290 --> 00:52:14,760
非常简单的描述符，

851
00:52:15,150 --> 00:52:18,060
是传输的硬件描述符，

852
00:52:18,300 --> 00:52:19,920
它有一个地址，

853
00:52:19,980 --> 00:52:21,210
这个地址当然是

854
00:52:21,210 --> 00:52:25,590
需要发送的数据在内存中的地址。

855
00:52:26,000 --> 00:52:28,460
然后它有一个 command 字段，

856
00:52:29,160 --> 00:52:32,610
这是软件告诉驱动，告诉网卡，

857
00:52:32,670 --> 00:52:34,740
这是你应该对数据包执行的操作，

858
00:52:34,740 --> 00:52:37,470
或者这是你应该知道的关于这个数据包的信息。

859
00:52:38,290 --> 00:52:39,760
所以有一件事，

860
00:52:40,000 --> 00:52:42,370
我想我们填入两个东西，

861
00:52:42,370 --> 00:52:46,330
EOP 表示数据包的末尾，

862
00:52:46,630 --> 00:52:48,160
这告诉驱动程序，

863
00:52:48,310 --> 00:52:51,550
这是数据包的最后一个描述符，

864
00:52:51,550 --> 00:52:56,080
现在，你可以发送这些描述符里的数据。

865
00:52:56,900 --> 00:53:06,220
我想我们设置了响应请求命令位，

866
00:53:06,490 --> 00:53:09,850
或者 RS ，

867
00:53:09,880 --> 00:53:11,530
就是告诉网卡，

868
00:53:11,560 --> 00:53:14,530
当你完成传输这个东西，

869
00:53:14,680 --> 00:53:20,600
设置它实际传输的位。

870
00:53:21,430 --> 00:53:23,650
我们稍后会看到它是如何显示的。

871
00:53:25,570 --> 00:53:26,350
有什么问题吗？

872
00:53:32,230 --> 00:53:34,090
所以有一件事要记住，

873
00:53:34,360 --> 00:53:35,350
对于这些结构，

874
00:53:35,380 --> 00:53:36,610
这些都是由硬件定义的，

875
00:53:36,640 --> 00:53:39,970
软件不能控制它们的结构，

876
00:53:39,970 --> 00:53:43,780
这是由硬件和网卡定义的。

877
00:53:44,860 --> 00:53:47,050
好的，让我们看一小段代码，

878
00:53:47,470 --> 00:53:50,590
看看解决方案是什么样子，

879
00:53:50,590 --> 00:53:52,450
我们将看几个问题，

880
00:53:52,450 --> 00:53:54,580
我们还没有看过的 mbuf ，

881
00:53:55,060 --> 00:53:59,020
传输过程中的问题和接收过程中的问题。

882
00:54:00,600 --> 00:54:03,090
你们大概都很熟悉这一点，

883
00:54:03,090 --> 00:54:05,250
考虑到你刚刚完成实验。

884
00:54:08,880 --> 00:54:09,900
好的，那么这里，

885
00:54:09,900 --> 00:54:14,010
查看顶部，这是传送环。

886
00:54:15,040 --> 00:54:18,580
是的，这就是描述符环，

887
00:54:18,580 --> 00:54:22,000
我们在最后几张幻灯片中画到了。

888
00:54:22,670 --> 00:54:23,540
这里有一个单独的，

889
00:54:23,600 --> 00:54:24,830
我们简要地谈过这个，

890
00:54:24,830 --> 00:54:28,280
这里有一个独立的 mbuf 环，

891
00:54:28,520 --> 00:54:34,190
但在这个环完全是软件或驱动程序抽象，

892
00:54:34,550 --> 00:54:42,090
这个结构是硬件定义的，

893
00:54:42,090 --> 00:54:42,870
如果你看一下。

894
00:54:43,480 --> 00:54:43,960
哎呀。

895
00:55:02,990 --> 00:55:04,760
查看定义，

896
00:55:04,760 --> 00:55:06,740
这里是 tx_desc 结构体，

897
00:55:06,860 --> 00:55:10,310
这对应于 C 版本的结构体，

898
00:55:10,310 --> 00:55:11,750
由硬件定义的，

899
00:55:11,780 --> 00:55:14,090
64 位地址，

900
00:55:14,090 --> 00:55:17,480
length 字段， cso 字节， cmd 字节，

901
00:55:17,480 --> 00:55:21,740
status 字节， css 字节，然后是 special 的两字节。

902
00:55:22,590 --> 00:55:25,320
还有一个类似的环，是由硬件定义的，

903
00:55:25,840 --> 00:55:28,390
或类似的接收描述符，是由硬件定义的，

904
00:55:28,390 --> 00:55:32,560
并且那些已经看到的描述符与这些硬件结构相对应。

905
00:55:34,970 --> 00:55:36,230
好的，让我们来看一下传输，

906
00:55:37,780 --> 00:55:41,650
这是一种用于传输的解决方案，

907
00:55:42,390 --> 00:55:44,370
获取一把锁，

908
00:55:44,400 --> 00:55:46,680
我们之前说的需要锁的原因是，

909
00:55:46,680 --> 00:55:49,110
因为有多个函数或多个内核线程

910
00:55:49,110 --> 00:55:51,900
可能会同时调用 transmit 。

911
00:55:53,460 --> 00:55:55,110
然后它查看尾指针，

912
00:55:55,320 --> 00:55:57,660
查看是否有，

913
00:55:58,300 --> 00:56:01,120
在房间里发送新的数据包，

914
00:56:01,120 --> 00:56:03,880
因为网卡落后了，

915
00:56:03,880 --> 00:56:07,390
所有的描述符都在使用中。

916
00:56:08,170 --> 00:56:09,280
所以它检查的方式，

917
00:56:09,730 --> 00:56:13,390
描述符是否在使用，

918
00:56:13,390 --> 00:56:19,040
通过检查是否未设置 DD 位。

919
00:56:20,120 --> 00:56:22,850
如果它设置了，

920
00:56:25,410 --> 00:56:29,760
如果没有设置，则它立即返回，

921
00:56:29,760 --> 00:56:31,170
根本不发送数据包，

922
00:56:31,350 --> 00:56:33,660
在任何其他情况下，则继续下去，

923
00:56:33,660 --> 00:56:35,550
会发送 mbuf 。

924
00:56:39,760 --> 00:56:43,600
所以，如果 tx_mbufs 中仍有 mbuf ，

925
00:56:43,600 --> 00:56:45,820
意味着这是[以前]的 mbuf ，

926
00:56:45,850 --> 00:56:47,260
释放那个 mbuf ，

927
00:56:47,260 --> 00:56:50,800
因为我们要把 mbuf 插入到这个描述符中，

928
00:56:51,100 --> 00:56:52,120
我们只需要记住，

929
00:56:52,120 --> 00:56:54,490
我们插入哪个描述符，

930
00:56:54,610 --> 00:56:56,080
我们做到这一点的方法是

931
00:56:56,080 --> 00:56:58,420
将其保存在 tx_mbuf 中。

932
00:56:59,820 --> 00:57:01,230
然后我们填入描述符，

933
00:57:01,500 --> 00:57:04,530
所以我们要填入的第一样东西是头指针，

934
00:57:04,530 --> 00:57:05,820
然后我们填入，

935
00:57:05,850 --> 00:57:11,970
我们把地址放入 mbuf 中第一个头指针的开始，

936
00:57:13,470 --> 00:57:17,020
然后，放入 length ， status 设置为 0 ，

937
00:57:17,110 --> 00:57:18,730
设置 cmd 字段，

938
00:57:18,730 --> 00:57:23,200
通过设置 RS 和 EOP 位。

939
00:57:23,760 --> 00:57:28,340
然后，你会同步，

940
00:57:28,340 --> 00:57:30,860
以确保实际上没有重新排序，

941
00:57:30,890 --> 00:57:35,300
所有这些指令都是在下一条指令之前执行。

942
00:57:36,140 --> 00:57:37,310
下一条指令所做的，

943
00:57:37,310 --> 00:57:38,930
它更新尾指针，

944
00:57:39,080 --> 00:57:41,330
所以，[]更新尾指针，

945
00:57:41,330 --> 00:57:45,470
尾指针是网卡中的一个控制寄存器，

946
00:57:45,890 --> 00:57:48,200
所以当我们更新尾部指针时，

947
00:57:48,290 --> 00:57:51,170
网卡知道发生了变化，

948
00:57:51,470 --> 00:57:56,180
它将读取那个描述符的数据，

949
00:57:56,420 --> 00:58:00,200
它将读取我们刚刚填入的这些字段，

950
00:58:00,350 --> 00:58:02,450
所以我们要绝对确保，

951
00:58:02,880 --> 00:58:06,750
所有这些写入，所有的存储都在内存中实现，

952
00:58:06,780 --> 00:58:09,630
在网卡读取它们之前，

953
00:58:09,630 --> 00:58:11,520
这就是为什么那里有 __sync_synchronize 的原因，

954
00:58:13,760 --> 00:58:14,900
然后我们释放锁，

955
00:58:14,900 --> 00:58:17,240
这就是我们传输数据包所要做的全部工作。

956
00:58:20,790 --> 00:58:24,800
你能再解释一下 __sync_synchronize 吗，比如。

957
00:58:25,270 --> 00:58:30,160
是的，它是关于技术上的内存排序，

958
00:58:30,160 --> 00:58:32,140
编译器可以自由地重新排序指令，

959
00:58:32,660 --> 00:58:38,720
写入可能位于 L1 缓存或 L2 缓存中，

960
00:58:39,080 --> 00:58:42,380
基本上 synchronize 是内存屏障，

961
00:58:42,680 --> 00:58:45,260
告诉硬件和编译器，

962
00:58:45,350 --> 00:58:48,680
请不要通过屏障移动任何指令，

963
00:58:49,630 --> 00:58:51,670
并确保所有数据，

964
00:58:51,670 --> 00:58:54,640
在这个屏障之前的所有保存，

965
00:58:54,730 --> 00:58:57,100
都是在内存中实现的。

966
00:58:58,700 --> 00:58:59,990
这很重要的原因是，

967
00:58:59,990 --> 00:59:04,340
因为，回到我们刚才的图片，

968
00:59:05,380 --> 00:59:10,060
一直回到这里。

969
00:59:10,710 --> 00:59:14,970
确保运行驱动的 RISC-V 核心

970
00:59:15,000 --> 00:59:17,160
将值放在这里，

971
00:59:17,160 --> 00:59:20,670
但这些值在 L1 缓存和 L2 缓存中，

972
00:59:21,030 --> 00:59:24,000
以及内存刷新，并确保它们出现在 RAM 中，

973
00:59:24,120 --> 00:59:26,940
这一点很重要，因为只要我们更新尾指针，

974
00:59:26,940 --> 00:59:29,670
e1000 将在 RAM 中查找这些描述符，

975
00:59:30,970 --> 00:59:34,000
我们必须确保所有的字段都设置好了，

976
00:59:34,800 --> 00:59:37,080
否则，它将读取过时的值。

977
00:59:40,360 --> 00:59:41,140
这能理解吗？

978
00:59:43,410 --> 00:59:43,980
好的，谢谢。

979
00:59:46,320 --> 00:59:48,300
为什么 mbuf 会存在，

980
01:00:00,660 --> 01:00:02,730
为什么会有这种分离的结构，

981
01:00:02,760 --> 01:00:07,850
为什么会有这两种对应的结构？

982
01:00:09,590 --> 01:00:11,000
我想部分原因是，

983
01:00:11,000 --> 01:00:13,590
这一切都很好，

984
01:00:13,590 --> 01:00:18,510
如果驱动需要告诉硬件东西在哪里，

985
01:00:18,510 --> 01:00:19,260
但归根结底，

986
01:00:19,260 --> 01:00:20,820
我们确实需要保存数据包，

987
01:00:20,820 --> 01:00:22,800
以便以某种方式将其传递到网络栈。

988
01:00:24,020 --> 01:00:24,860
是的，就是这样，

989
01:00:24,920 --> 01:00:27,350
所以，考虑这个问题的一种方式是，

990
01:00:27,350 --> 01:00:30,110
mbuf 完全是操作系统抽象，

991
01:00:30,110 --> 01:00:32,750
与网卡一点关系都没有，

992
01:00:33,140 --> 01:00:33,740
它之所以在那里，

993
01:00:33,740 --> 01:00:39,590
因为，如果在某个时候，可能会收到一个数据包，

994
01:00:39,590 --> 01:00:41,450
我们把它送到网络栈，

995
01:00:41,450 --> 01:00:43,610
放到网络栈中的某个队列中，

996
01:00:43,700 --> 01:00:45,890
这样当稍后用户进程调用 read 时，

997
01:00:45,920 --> 01:00:47,150
你可以读它，

998
01:00:48,000 --> 01:00:50,550
同时，我们需要一些结构

999
01:00:50,550 --> 01:00:53,040
来保存我们收到的数据，

1000
01:00:53,040 --> 01:00:54,990
这就是这些 mbuf 结构。

1001
01:01:01,310 --> 01:01:03,800
抱歉，你能不能谈谈，

1002
01:01:04,700 --> 01:01:09,990
比如，你如何在代码中使用链表结构，

1003
01:01:09,990 --> 01:01:13,690
因为我试着去理解它并追踪它，

1004
01:01:14,290 --> 01:01:19,490
它似乎有一些 push tail 或 push head ，

1005
01:01:19,550 --> 01:01:23,680
但我在我的代码里从来没有调用它，

1006
01:01:24,220 --> 01:01:28,000
哦，它可能在 net.c 文件中。

1007
01:01:30,200 --> 01:01:33,110
我们给你们的网络 C 文件吗？

1008
01:01:33,770 --> 01:01:34,610
是的。

1009
01:01:39,650 --> 01:01:40,940
你想的是什么？

1010
01:01:42,800 --> 01:01:49,940
如果你查找，比如 pull pop ，我想是 pop 。

1011
01:01:54,210 --> 01:01:57,030
是的，这是唯一的地方，

1012
01:01:57,030 --> 01:02:03,540
看起来使用了 mbuf 的链表结构，

1013
01:02:04,290 --> 01:02:08,700
如果你不调用这个函数或 push tail ，

1014
01:02:09,000 --> 01:02:17,610
你只是将 mbuf 视为一个由多少个字符组成的数组，

1015
01:02:17,670 --> 01:02:20,570
那么，为什么 mbuf 会在那里。

1016
01:02:21,370 --> 01:02:27,710
因为在这里，当你收到 UDP 数据包时，

1017
01:02:28,130 --> 01:02:30,440
因此 UDP 数据包从网卡传入，

1018
01:02:30,470 --> 01:02:31,850
它进入网络栈，

1019
01:02:32,450 --> 01:02:34,430
然后是 UDP 数据包，

1020
01:02:34,460 --> 01:02:38,060
UDP 的 mbuf 持有 UDP 数据包，

1021
01:02:38,450 --> 01:02:40,250
在这个队列中，

1022
01:02:42,090 --> 01:02:44,220
在接收者的插槽上。

1023
01:02:47,460 --> 01:02:50,370
这就是为什么你有 mbuf 队列的原因。

1024
01:02:54,420 --> 01:02:56,100
原因是栈在队列中，

1025
01:02:56,100 --> 01:02:57,300
是因为你知道，

1026
01:02:57,300 --> 01:03:00,690
用户进程要从这个套接字读取，

1027
01:03:01,140 --> 01:03:02,670
也可能在做别的事，

1028
01:03:02,700 --> 01:03:05,310
在随后的某个时刻，它调用 read 系统调用，

1029
01:03:05,310 --> 01:03:09,630
然后 read 系统调用将从那个套接字中移动 mbuf 。

1030
01:03:11,780 --> 01:03:20,250
所以，每个套接字可以具有用于接收的 mbuf 列表。

1031
01:03:22,070 --> 01:03:23,390
我明白了，谢谢。

1032
01:03:25,840 --> 01:03:27,580
好的，让我们回到驱动上。

1033
01:03:28,190 --> 01:03:30,230
所以那是传输。

1034
01:03:32,480 --> 01:03:33,980
然后我们接收，

1035
01:03:34,010 --> 01:03:37,340
几乎是一样的，没有太大差别，

1036
01:03:37,760 --> 01:03:42,620
基本上从网卡读取尾指针。

1037
01:03:43,220 --> 01:03:45,470
你可以看到那里有一个数据包，

1038
01:03:45,560 --> 01:03:51,110
如果有数据包，则 DD 字段会被设置，

1039
01:03:51,770 --> 01:03:53,630
如果 DD 字段没有设置，

1040
01:03:53,660 --> 01:03:56,360
然后我们知道没有数据包，我们就结束了，

1041
01:03:57,200 --> 01:03:59,750
如果设置了，我们就去读它，

1042
01:04:02,220 --> 01:04:03,660
读取长度，

1043
01:04:03,660 --> 01:04:08,710
当我们调用 net_rx 时，当我们调用和net_rx时，

1044
01:04:08,710 --> 01:04:11,230
向上调用更高级别的栈。

1045
01:04:11,930 --> 01:04:14,270
当我们完成时，

1046
01:04:14,270 --> 01:04:18,780
我们会释放那个条目，

1047
01:04:18,870 --> 01:04:20,880
以便驱动程序可以使用它

1048
01:04:20,880 --> 01:04:22,470
来接收更多数据包。

1049
01:04:23,340 --> 01:04:25,980
真正的关键的操作是，

1050
01:04:25,980 --> 01:04:28,710
我们撞上尾指针告诉驱动程序，

1051
01:04:29,100 --> 01:04:31,560
我们已经用完了，你可以再次使用，

1052
01:04:31,590 --> 01:04:33,060
这里的那个位置。

1053
01:04:35,900 --> 01:04:37,910
所以也许最有趣的问题是

1054
01:04:37,940 --> 01:04:40,430
你们问的很多问题，

1055
01:04:40,460 --> 01:04:41,810
为什么这里有一个 while ，

1056
01:04:45,530 --> 01:04:46,730
为什么这是一个循环，

1057
01:04:47,690 --> 01:04:48,830
不是你获得中断，

1058
01:04:48,830 --> 01:04:50,690
你抓到一个数据包，然后你就完成了，

1059
01:04:50,930 --> 01:04:54,370
很多人首先忘记了 while 循环，

1060
01:04:54,370 --> 01:04:56,470
注意，在某个时刻，

1061
01:04:56,470 --> 01:04:58,750
在 nettest 中，你不能接收到数据包。

1062
01:05:02,840 --> 01:05:06,230
是因为你希望传输尽可能多的包，

1063
01:05:06,230 --> 01:05:08,900
仅使用一个中断，

1064
01:05:08,900 --> 01:05:13,010
这样你就可以在摊销中断的成本。

1065
01:05:13,780 --> 01:05:15,850
是的，这绝对是其中的一部分，

1066
01:05:15,850 --> 01:05:17,320
你获得，

1067
01:05:17,470 --> 01:05:20,890
我们先来谈谈，根本原因是写入，

1068
01:05:21,730 --> 01:05:24,700
如果一些突发包进来了，

1069
01:05:25,330 --> 01:05:28,570
网卡将产生中断，

1070
01:05:28,930 --> 01:05:30,220
但是有更多的包进来了，

1071
01:05:30,310 --> 01:05:33,130
所以它会把它们放在空闲描述符中，

1072
01:05:33,130 --> 01:05:34,390
可以使用的，

1073
01:05:35,060 --> 01:05:37,190
无法生成更多中断，

1074
01:05:37,190 --> 01:05:38,750
因为已经生成中断，

1075
01:05:39,140 --> 01:05:42,620
在某种程度上，不管是什么进程，

1076
01:05:42,620 --> 01:05:47,300
或者核心在一段关闭中断的代码中，

1077
01:05:47,300 --> 01:05:48,650
因为它在做一些原子性的事情，

1078
01:05:49,010 --> 01:05:49,700
在它的最后，

1079
01:05:49,700 --> 01:05:51,110
有一个锁的释放，

1080
01:05:51,110 --> 01:05:52,400
它打开了中断，

1081
01:05:52,550 --> 01:05:53,420
那个时间点，

1082
01:05:53,420 --> 01:05:57,800
然后接收中断处理程序继续运行，

1083
01:05:58,160 --> 01:05:59,720
但是在一段时间内，

1084
01:05:59,720 --> 01:06:02,510
当第一个包传入到接收处理程序运行之前，

1085
01:06:02,510 --> 01:06:06,290
可能还有一大堆其他的包进来了。

1086
01:06:07,430 --> 01:06:10,310
所以我们不在 while 循环中运行，

1087
01:06:10,340 --> 01:06:13,100
会留下这些数据包，

1088
01:06:13,100 --> 01:06:15,650
会抓到第一个，也会抓到另一个，

1089
01:06:15,650 --> 01:06:18,380
后面的放在队列里，

1090
01:06:18,380 --> 01:06:19,670
它们就在那个环里。

1091
01:06:20,680 --> 01:06:22,780
现在，如果随后的中断进来，

1092
01:06:22,780 --> 01:06:23,920
我们会抓取下一个，

1093
01:06:24,340 --> 01:06:26,110
但就像测试一样，

1094
01:06:26,140 --> 01:06:29,110
他们所做的，他们会运行 UDP 数据包，

1095
01:06:29,110 --> 01:06:30,700
他们会发送一大堆，

1096
01:06:30,700 --> 01:06:34,600
比如，一个测试是并行发送 10 个 ping 请求，

1097
01:06:34,810 --> 01:06:38,200
有 10 个回复也是并行的。

1098
01:06:38,640 --> 01:06:41,940
第一个接收到的产生中断，

1099
01:06:42,030 --> 01:06:43,980
其他九个进入队列，

1100
01:06:44,480 --> 01:06:48,230
更高级的软件到达第一个，

1101
01:06:48,830 --> 01:06:51,380
然后完成并返回，

1102
01:06:51,650 --> 01:06:53,450
在这一点上，什么都不会发生，

1103
01:06:53,450 --> 01:06:56,210
因为接收者正在等待更多的接收数据包，

1104
01:06:56,360 --> 01:06:57,350
它们碰巧在那里，

1105
01:06:57,350 --> 01:06:58,250
它们在环中，

1106
01:06:58,430 --> 01:07:02,120
除了接收不是在 while 循环中做的，

1107
01:07:02,120 --> 01:07:03,140
所以没有去取出它们。

1108
01:07:05,850 --> 01:07:06,570
这能理解吗？

1109
01:07:13,160 --> 01:07:15,710
所以，比如，如果测试程序会发送，

1110
01:07:15,710 --> 01:07:18,320
一个请求等待响应，

1111
01:07:18,320 --> 01:07:20,420
一个请求等待响应，

1112
01:07:20,600 --> 01:07:24,050
你永远不会注意到，需要一个 while 循环。

1113
01:07:24,550 --> 01:07:27,910
因为会有突发的回复回来，

1114
01:07:28,030 --> 01:07:30,970
而这只会一起产生一个中断。

1115
01:07:35,020 --> 01:07:36,820
对于这个，有什么问题吗？

1116
01:07:36,820 --> 01:07:37,990
我有个问题，

1117
01:07:37,990 --> 01:07:42,160
比如，除了 while(1) ，

1118
01:07:42,700 --> 01:07:45,580
我们有一个遍历整个队列的 for 循环，

1119
01:07:45,580 --> 01:07:49,060
出于同样的原因，这也是错误的。

1120
01:07:49,420 --> 01:07:53,260
不，我们跳过所有未设置 DD 的列表。

1121
01:07:54,670 --> 01:07:57,370
好的，我们应该只看数据包，

1122
01:07:57,370 --> 01:08:00,220
我们应该只看尾指针。

1123
01:08:02,170 --> 01:08:05,380
但是原则上，你可以跳过整个队列，

1124
01:08:05,380 --> 01:08:07,120
我想查看 DD 数据包，

1125
01:08:07,120 --> 01:08:09,490
让它们看到 DD 位已设置，

1126
01:08:09,520 --> 01:08:11,920
这可能行得通，我还没试过。

1127
01:08:14,060 --> 01:08:18,050
好的，但是是不是设备可以

1128
01:08:18,320 --> 01:08:23,270
在我们读到旧数据之后，在接收器里放更多的 mbuf ？

1129
01:08:25,000 --> 01:08:25,930
是的，对。

1130
01:08:29,070 --> 01:08:29,610
好的。

1131
01:08:32,080 --> 01:08:32,890
我们必须。

1132
01:08:42,200 --> 01:08:43,010
这是非常危险的，

1133
01:08:43,010 --> 01:08:45,110
这个提议是查看，

1134
01:08:45,110 --> 01:08:47,150
查着 DD 设置，

1135
01:08:47,150 --> 01:08:49,490
因为我们应该这么做，

1136
01:08:49,490 --> 01:08:54,260
我们不应该查看由驱动程序或硬件控制的 buf ，

1137
01:08:54,500 --> 01:08:58,180
只需查看软件可用的缓冲区，

1138
01:08:58,240 --> 01:09:00,760
是由 DD 位表示的，

1139
01:09:00,760 --> 01:09:02,470
通过查看尾指针。

1140
01:09:04,080 --> 01:09:08,430
基本上，尾部和头部之间的任何东西都归硬件所有。

1141
01:09:13,220 --> 01:09:17,060
回到 mbuf ，就像我们需要 mbuf 的原因，

1142
01:09:17,450 --> 01:09:23,990
为什么我们需要缓冲区中的其他信息，比如[]数组，

1143
01:09:24,580 --> 01:09:26,230
我想它叫做[后备存储]。

1144
01:09:28,760 --> 01:09:30,830
它在 net.h 中。

1145
01:09:40,490 --> 01:09:42,830
所以我们需要 buf 字段，

1146
01:09:42,830 --> 01:09:44,300
因为它包含了数据。

1147
01:09:46,800 --> 01:09:49,410
我认为头部包含指向数据的指针。

1148
01:09:49,590 --> 01:09:50,400
好的，好的，

1149
01:09:50,400 --> 01:09:53,190
但是 buf 是实际分配的空间，

1150
01:09:53,190 --> 01:09:54,510
这个数据包，

1151
01:09:54,750 --> 01:09:57,240
然后头部使用指针进入 buf ，

1152
01:09:57,420 --> 01:09:59,100
是数据包的开头。

1153
01:10:01,450 --> 01:10:02,230
好的，好的。

1154
01:10:04,160 --> 01:10:05,630
这是 mbuf ，这是，

1155
01:10:05,630 --> 01:10:08,990
好的， mbuf 的更多上下文是

1156
01:10:08,990 --> 01:10:11,270
你在许多网络栈中看到的结构，

1157
01:10:11,270 --> 01:10:12,920
所以你看一下 Linux 内核，

1158
01:10:12,920 --> 01:10:14,420
你会看到类似这样的结构，

1159
01:10:14,420 --> 01:10:17,420
它通常被称为 mbufs ，所以我们必须。

1160
01:10:19,060 --> 01:10:22,030
我们可以把这个结构简化很多，

1161
01:10:22,270 --> 01:10:24,490
或许接下来我们应该，

1162
01:10:24,550 --> 01:10:26,620
但这是一种标准方法，

1163
01:10:26,620 --> 01:10:30,430
数据包在操作系统内核中的表示。

1164
01:10:39,430 --> 01:10:41,110
好的，关于这个，还有什么问题吗？

1165
01:10:50,760 --> 01:10:51,900
所以我现在有一个选择，

1166
01:10:51,930 --> 01:10:55,590
关于网络驱动程序，我可以说几件事，

1167
01:10:55,860 --> 01:10:59,340
但是那样我就没有时间谈论 mmap 了。

1168
01:10:59,880 --> 01:11:03,780
我也可以稍微谈一下 mmap ，然后到此为止，

1169
01:11:04,500 --> 01:11:06,600
而不是讨论网络驱动程序。

1170
01:11:09,640 --> 01:11:11,200
有什么偏好吗？

1171
01:11:24,740 --> 01:11:25,700
没有偏好。

1172
01:11:31,350 --> 01:11:33,270
让我简单介绍一下 mmap ，

1173
01:11:33,270 --> 01:11:35,940
因为有几次出现了一个问题，

1174
01:11:36,330 --> 01:11:40,080
这可能是值得解决的问题，

1175
01:11:40,920 --> 01:11:45,090
这几乎更多的是关于 mmap 为什么存在的问题，

1176
01:11:45,420 --> 01:11:48,540
然后，是如何实现它。

1177
01:11:49,680 --> 01:11:53,010
所以没有听起来不同的反对意见，

1178
01:11:53,040 --> 01:11:55,770
让我更多地谈谈 mmap 。

1179
01:11:56,750 --> 01:11:58,100
所以，这是最后的机会，

1180
01:11:58,100 --> 01:12:00,980
询问有关网络驱动程序的问题，在下课之前。

1181
01:12:06,660 --> 01:12:12,990
好的，我们来谈谈 mbufs ，哦， mmap 。

1182
01:12:28,610 --> 01:12:33,840
好的，这个问题与文件系统 API 有关，

1183
01:12:33,990 --> 01:12:38,220
文件系统具有相当广泛的 API ，

1184
01:12:38,820 --> 01:12:42,660
支持目录，符号链接，硬链接等，

1185
01:12:42,660 --> 01:12:46,980
但是它的主要部分是文件 API ，

1186
01:12:46,980 --> 01:12:50,520
文件 API ，你现在已经很熟悉了，

1187
01:12:52,110 --> 01:12:56,860
打开文件，有一些权限，

1188
01:12:56,890 --> 01:12:58,720
一旦你打开了文件，

1189
01:12:58,960 --> 01:13:01,450
你可以从文件中读取，

1190
01:13:04,600 --> 01:13:07,870
读到缓冲区中，创建一些数据。

1191
01:13:08,830 --> 01:13:12,550
你写入到文件，

1192
01:13:15,040 --> 01:13:17,920
不管是文件描述符和 buf 还是 len ，

1193
01:13:18,310 --> 01:13:19,390
假设我们，

1194
01:13:20,080 --> 01:13:23,590
然后我们可以关闭文件描述符。

1195
01:13:25,070 --> 01:13:26,900
现在假设我们想要编写一个应用程序，

1196
01:13:27,140 --> 01:13:29,240
你可以想一想，

1197
01:13:30,050 --> 01:13:34,940
可能只是一个文件，有普通的字节数组，

1198
01:13:34,940 --> 01:13:37,610
但是这个应用程序可能有

1199
01:13:37,610 --> 01:13:39,710
它是一个结构数组保存在其中。

1200
01:13:39,890 --> 01:13:43,320
所以，假设应用程序想要更新结构，

1201
01:13:43,320 --> 01:13:44,880
我们必须操作文件，

1202
01:13:46,170 --> 01:13:50,200
这是一个文件，分成结构体，

1203
01:13:50,200 --> 01:13:52,780
从 0 到文件长度，

1204
01:13:52,780 --> 01:13:56,470
我们可能在中间，

1205
01:13:56,830 --> 01:13:59,200
让我们有一个 16 字节的结构，或别的什么，

1206
01:13:59,200 --> 01:14:01,540
我们想要更新其中的一个，

1207
01:14:01,840 --> 01:14:03,490
或者可能想要更新第一个。

1208
01:14:05,680 --> 01:14:07,240
所以，我们可以做到这一点，

1209
01:14:07,240 --> 01:14:09,340
我们读，我们打开文件，

1210
01:14:09,340 --> 01:14:12,670
我们读开始的 16 个字节，

1211
01:14:13,800 --> 01:14:15,720
对应于这个，

1212
01:14:16,420 --> 01:14:20,680
假设更新第一个字段结构，

1213
01:14:20,710 --> 01:14:23,170
那个结构的第一个字节，改为 1 。

1214
01:14:23,880 --> 01:14:28,080
然后我们调用 write ，将其写回，

1215
01:14:28,110 --> 01:14:29,130
然后我们关闭文件。

1216
01:14:29,800 --> 01:14:31,480
那么，如果写入发生在那里，

1217
01:14:31,480 --> 01:14:32,530
它实际写入的位置是哪里。

1218
01:14:41,090 --> 01:14:44,360
所以我们把内存改为 1 ，

1219
01:14:44,360 --> 01:14:47,540
这个会不会先变成 1 ，

1220
01:14:52,140 --> 01:14:53,160
如果我们调用 write 。

1221
01:15:08,510 --> 01:15:11,540
请记住，文件描述符没有设置与它关联。

1222
01:15:13,320 --> 01:15:17,040
然后读取将偏移量向前推，

1223
01:15:17,040 --> 01:15:19,110
在这个例子中，我们读取 16 个字节，

1224
01:15:19,110 --> 01:15:22,020
偏移量从 0 上升到 16 。

1225
01:15:22,960 --> 01:15:24,310
那么 write 在哪里写呢，

1226
01:15:27,190 --> 01:15:32,470
正如你注意到的，在 write 系统调用中没有偏移量参数，

1227
01:15:32,500 --> 01:15:33,610
那么它写在哪里。

1228
01:15:37,070 --> 01:15:37,940
长度？

1229
01:15:39,180 --> 01:15:41,010
是的，我们将写入 len 字节，

1230
01:15:41,010 --> 01:15:42,420
在文件中的哪个偏移量，

1231
01:15:44,080 --> 01:15:46,360
假设 len 对应 16 。

1232
01:15:46,920 --> 01:15:47,520
是的。

1233
01:15:47,940 --> 01:15:51,420
那么这个字节会变成 1 。

1234
01:15:54,090 --> 01:15:58,470
而不是我们实际想要修改的东西。

1235
01:15:59,970 --> 01:16:00,690
这能理解吗？

1236
01:16:02,540 --> 01:16:04,340
所以你写这个应用的方式，

1237
01:16:04,340 --> 01:16:06,050
有一次系统调用，

1238
01:16:06,050 --> 01:16:07,790
我们并没有太多谈论，

1239
01:16:07,910 --> 01:16:12,290
但是每一种 Unix 操作系统都被称为 lseek 。

1240
01:16:14,220 --> 01:16:18,210
lseek 允许你将偏移量更改为某个位置。

1241
01:16:18,850 --> 01:16:20,620
所以在这个案例中，

1242
01:16:20,620 --> 01:16:23,200
我们想要的效果是，

1243
01:16:23,200 --> 01:16:25,600
我们要写这个结构，而不是那个。

1244
01:16:26,140 --> 01:16:28,960
那么我们就会说 lseek 0 ，

1245
01:16:28,990 --> 01:16:34,250
将偏移量重置为 0 ，

1246
01:16:34,280 --> 01:16:37,580
然后这个写操作是偏移量 0 。

1247
01:16:38,380 --> 01:16:42,850
然后这个 write 写入前 16 个字节。

1248
01:16:44,170 --> 01:16:44,920
这能理解吗？

1249
01:16:51,700 --> 01:16:53,290
所以这有点不方便，

1250
01:16:53,290 --> 01:16:54,340
如果你仔细想想，

1251
01:16:54,520 --> 01:16:55,930
你看这个接口，

1252
01:16:55,930 --> 01:16:58,000
有相当多的东西在运行，

1253
01:16:58,000 --> 01:16:59,890
你需要打开，需要读取，

1254
01:16:59,890 --> 01:17:01,570
你需要查找，然后可以写入。

1255
01:17:02,310 --> 01:17:05,010
所以， mmap 流行的原因之一，

1256
01:17:06,600 --> 01:17:10,860
是你可以避免这些复杂的情况。

1257
01:17:11,460 --> 01:17:13,740
因为如果我们用 mmap 写这个，

1258
01:17:13,740 --> 01:17:15,840
我们做的打开 fd ，

1259
01:17:16,110 --> 01:17:17,850
我们像以前一样打开文件，

1260
01:17:20,980 --> 01:17:24,370
然后我们只需要调用 mmap ，

1261
01:17:26,240 --> 01:17:27,830
不管我们的结构是什么，

1262
01:17:27,860 --> 01:17:33,100
比如我们的结构体 h ，等等，

1263
01:17:33,130 --> 01:17:42,440
文件的长度，读、写权限，

1264
01:17:43,530 --> 01:17:50,920
映射共享，文件描述符为 0 。

1265
01:17:52,160 --> 01:17:56,450
然后，我们就在 mmap 中了，

1266
01:17:56,450 --> 01:18:01,070
文件 f 在 h 位置在内存中。

1267
01:18:01,580 --> 01:18:04,040
现在，我们可以说 h ，

1268
01:18:04,040 --> 01:18:08,300
不管第一个字节是 0 还是 1 ，就像我们之前做的那样。

1269
01:18:08,980 --> 01:18:11,710
然后，在某个时刻，我们可以调用 munmap ，

1270
01:18:16,440 --> 01:18:21,500
munmap h ，

1271
01:18:21,500 --> 01:18:23,840
如果我们思考这个问题，我们在内存中查找。

1272
01:18:24,400 --> 01:18:26,920
我们是从文件的角度来看这件事，

1273
01:18:27,310 --> 01:18:28,570
这能解决的问题，

1274
01:18:28,570 --> 01:18:32,410
代码说做的，你获得一个指向 h 的指针，

1275
01:18:32,770 --> 01:18:35,560
你可以更新这个东西为 1 ，

1276
01:18:35,920 --> 01:18:37,390
然后就完成了。

1277
01:18:38,360 --> 01:18:40,790
所以，如果我们需要操作

1278
01:18:40,820 --> 01:18:44,660
文件结构，位于文件中的数据结构，

1279
01:18:44,960 --> 01:18:47,570
这 个mmap 接口要方便得多。

1280
01:18:48,060 --> 01:18:50,100
然后之前的接口，

1281
01:18:50,340 --> 01:18:51,930
我们必须读取，

1282
01:18:51,930 --> 01:18:55,800
我们操纵内存，我们找回，

1283
01:18:55,800 --> 01:18:57,180
然后我们写下信息。

1284
01:18:57,740 --> 01:18:59,360
在这个案例中，

1285
01:18:59,360 --> 01:19:03,410
我们可以将文件看作是字节数组，

1286
01:19:03,410 --> 01:19:05,120
我们可以随意书写，

1287
01:19:05,630 --> 01:19:07,790
而不必[导航]来跳来跳去，

1288
01:19:11,950 --> 01:19:16,060
人们看到 mmap 接口的优势了吗。

1289
01:19:23,960 --> 01:19:25,040
对此有什么问题吗？

1290
01:19:28,170 --> 01:19:32,310
有没有大型存储系统都使用这种方式，

1291
01:19:32,310 --> 01:19:34,050
比如数据库，

1292
01:19:34,050 --> 01:19:36,300
它们是经常使用还是不经常使用。

1293
01:19:36,630 --> 01:19:37,740
它们经常用这个。

1294
01:19:38,600 --> 01:19:40,850
我认为很多应用程序都使用 mmap ，

1295
01:19:40,880 --> 01:19:44,660
因为对于像数据库这样的东西来说要方便得多，

1296
01:19:47,270 --> 01:19:49,790
这个接口非常好，

1297
01:19:49,790 --> 01:19:51,560
如果你需要从标准输入读取，

1298
01:19:51,680 --> 01:19:53,570
有一个字节流进入，

1299
01:19:53,600 --> 01:19:57,770
你读取，并产生一些其他的输出流。

1300
01:19:58,910 --> 01:20:01,640
那个接口非常适合，

1301
01:20:02,000 --> 01:20:03,500
你不必更新偏移量，

1302
01:20:03,500 --> 01:20:05,510
你读取，立即更新偏移量，

1303
01:20:05,510 --> 01:20:07,760
你再次读取，等等。

1304
01:20:07,940 --> 01:20:11,600
所以它对于面向流的输入来说很好。

1305
01:20:12,190 --> 01:20:13,450
嗯，这真的很不错，

1306
01:20:13,450 --> 01:20:16,960
如果文件有数据结构，

1307
01:20:16,960 --> 01:20:21,600
并且更新文件的部分，

1308
01:20:21,600 --> 01:20:23,850
任意的位置。

1309
01:20:32,220 --> 01:20:37,080
好的，让我想想，

1310
01:20:37,110 --> 01:20:42,660
我的时间快用完了。

1311
01:20:43,270 --> 01:20:46,200
所以让我停在这里，

1312
01:20:46,200 --> 01:20:48,750
希望这个关于 mmap 的小道消息，

1313
01:20:48,750 --> 01:20:51,150
知道这一点很有用，

1314
01:20:51,540 --> 01:20:56,650
告诉你为什么这是一个很受欢迎的方案。

1315
01:21:00,080 --> 01:21:01,010
让我们看看,

1316
01:21:01,040 --> 01:21:06,560
我想，我们这节课快结束了，

1317
01:21:06,590 --> 01:21:16,000
也是 6.S081 的结束，

1318
01:21:16,030 --> 01:21:21,790
所以，如果你没有填写反馈调查，

1319
01:21:21,790 --> 01:21:24,640
请这样做，

1320
01:21:24,670 --> 01:21:28,300
如果你能填一下科目评估，我们会很感激的。

1321
01:21:29,180 --> 01:21:34,080
我再一次感谢你们的关注，

1322
01:21:34,110 --> 01:21:36,330
这又是一个奇怪的学期，

1323
01:21:36,330 --> 01:21:38,400
我希望我能见到你们所有人。

1324
01:21:39,620 --> 01:21:43,880
无论是上课还是课前或课后都可以和你面谈，

1325
01:21:44,240 --> 01:21:48,650
不幸的是，正如它所发生的，

1326
01:21:48,680 --> 01:21:52,940
但我希望你能从 6.S081 学到很多，

1327
01:21:52,940 --> 01:21:56,120
当然还有工作人员，感谢你们的努力，

1328
01:21:56,210 --> 01:21:59,060
这学期你们都表现得很棒。

1329
01:21:59,860 --> 01:22:01,800
到此为止，谢谢。

1330
01:22:03,150 --> 01:22:05,160
如果你有任何问题，请不要离开。

1331
01:22:06,550 --> 01:22:08,500
但我相信，你们中的一些人有最后期限。

1332
01:22:10,100 --> 01:22:12,680
老实说，我也代表助教，

1333
01:22:12,680 --> 01:22:15,320
我们真的很享受这些时间，

1334
01:22:15,320 --> 01:22:18,110
跟你们在上班时间以及做检查，

1335
01:22:18,110 --> 01:22:20,210
这是我们做检查的第一学期，

1336
01:22:20,210 --> 01:22:23,600
然后 David 和我都觉得这是一个非常愉快的过程，

1337
01:22:23,600 --> 01:22:25,370
希望我们能够

1338
01:22:25,700 --> 01:22:28,610
帮你们摆脱困境，并进行一些愉快的交谈，

1339
01:22:28,610 --> 01:22:30,530
所以，感谢你们让这学期过得很棒，

1340
01:22:30,530 --> 01:22:32,540
和我们一起在线上，

1341
01:22:32,540 --> 01:22:35,350
解决所有的远程学习问题，

1342
01:22:35,350 --> 01:22:37,750
我们遇到并解决，

1343
01:22:38,020 --> 01:22:39,970
完成这一课程的乐趣。

1344
01:22:46,360 --> 01:22:47,320
还有什么问题吗？

1345
01:22:49,170 --> 01:22:50,670
再说一次，你可以随便提问。

1346
01:23:00,530 --> 01:23:03,260
哦，我有个问题，

1347
01:23:03,800 --> 01:23:06,700
所以，哦，是的，

1348
01:23:06,700 --> 01:23:07,810
非常感谢你的课程，

1349
01:23:07,810 --> 01:23:11,500
我真的很喜欢这门课，这是最好的一学期，

1350
01:23:11,620 --> 01:23:16,210
我想问一下中断，接收的中断，

1351
01:23:16,270 --> 01:23:23,160
硬件如何知道软件何时完成，

1352
01:23:24,130 --> 01:23:27,970
处理上一个中断，而不是发出另一个中断。

1353
01:23:28,800 --> 01:23:32,220
因为有多个步骤，

1354
01:23:32,880 --> 01:23:43,030
一是你看到 e1000 的下半部分，

1355
01:23:43,420 --> 01:23:45,010
我们重新启用中断，

1356
01:23:45,400 --> 01:23:46,420
或者我们告诉网卡，

1357
01:23:46,420 --> 01:23:48,070
我们已经准备好接收更多中断。

1358
01:23:49,170 --> 01:23:52,320
这就是我们告诉网卡产生中断，

1359
01:23:52,770 --> 01:23:55,410
当然，在这一点上，中断并没有打开，

1360
01:23:55,410 --> 01:23:57,720
我们只需告诉网卡，你可以再次生成中断，

1361
01:23:58,280 --> 01:24:00,710
中断被打开，

1362
01:24:00,710 --> 01:24:04,310
正如这些函数，中断启用，

1363
01:24:04,730 --> 01:24:07,280
在这一点上，如果你打开中断启用，

1364
01:24:07,280 --> 01:24:12,620
如果设置了此字段，再加上启用中断，

1365
01:24:12,650 --> 01:24:14,330
中断可能会再次发生。

1366
01:24:15,680 --> 01:24:18,680
好的，我忘了这个寄存器，非常感谢。

1367
01:24:18,680 --> 01:24:22,670
是的，就像一条指令，很容易漏掉。

1368
01:24:25,960 --> 01:24:26,770
还有其他问题吗？

1369
01:24:30,500 --> 01:24:31,490
谢谢大家。

1370
01:24:32,580 --> 01:24:33,480
谢谢你，好的。

1371
01:24:36,520 --> 01:24:37,420
谢谢。

1372
01:24:38,770 --> 01:24:39,850
谢谢。

1373
01:24:40,910 --> 01:24:41,840
非常感谢。

