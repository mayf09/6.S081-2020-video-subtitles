1
00:00:06,750 --> 00:00:09,630
下午好，快速试音。
Good afternoon, quick sound check.

2
00:00:10,510 --> 00:00:11,320
大家能听到我说话吗？
Can people hear me?

3
00:00:12,270 --> 00:00:12,780
是的。
Yes.

4
00:00:13,820 --> 00:00:14,570
谢谢。
Thanks.

5
00:00:15,350 --> 00:00:19,370
好的，我想今天到目前为止，
Okay, so I guess today you know so far,

6
00:00:19,370 --> 00:00:23,180
这是本学期的最后一节 6.S081 的课。
it's the last lecture of 6.S081 this semester.

7
00:00:23,960 --> 00:00:30,500
我们并没有一个正式的话题，
And, we don't really have a formal topic,

8
00:00:30,620 --> 00:00:31,820
这是一个问答课程，
there's a Q&A lecture,

9
00:00:32,150 --> 00:00:36,380
所以你可以随便问任何问题，
so feel free to ask questions about anything,

10
00:00:36,410 --> 00:00:37,430
我想这是最后一次，
this is I guess last,

11
00:00:37,430 --> 00:00:40,490
至少是你们这学期最后一次上这门课了。
your last chance at least this semester for this class.

12
00:00:41,260 --> 00:00:43,390
默认情况下，我的计划是
By default, my plan was

13
00:00:43,390 --> 00:00:49,090
根据电子邮件上的问题复习几个主题，
to go over a couple topics based on the questions over email,

14
00:00:49,150 --> 00:00:53,100
然后我要稍微讨论一下网络实验的解决方案。
then I was going to talk a little bit about network lab, the solutions.

15
00:00:53,850 --> 00:00:58,560
如果可能的话，再花一点时间介绍一下 mmap 实验，
If possible, also a little bit of time about the mmap lab,

16
00:01:00,110 --> 00:01:01,760
再次谈论这些解决方案。
again talking about those solutions.

17
00:01:02,090 --> 00:01:05,660
然后有很多关于后续课程的问题，
And then there were a lot of questions about the following classes

18
00:01:05,810 --> 00:01:09,050
事实上，我会先讲到这一点。
and in fact I think I'll cover that first.

19
00:01:10,120 --> 00:01:15,280
但是在深入到这三个主题中的一个之前，
But before diving in any of these three topics,

20
00:01:15,280 --> 00:01:23,800
让我提醒你，有一个科目评估正在进行中，
let me remind you there's a subject evaluation outgoing ongoing,

21
00:01:23,800 --> 00:01:27,700
而我们作为 6.S081 的工作人员，
and we as staff of 6.S081,

22
00:01:27,700 --> 00:01:31,900
我们感谢你对 6.S081 的反馈。
we appreciate you give your feedback on 6.S081.

23
00:01:33,060 --> 00:01:34,440
希望它是积极的，
And hopefully it's positive,

24
00:01:34,680 --> 00:01:37,410
我们明年有机会再次授课。
you know we get a chance to teach again next year.

25
00:01:39,320 --> 00:01:41,000
也许这也是一个很好的时机，
And maybe this is also a good time

26
00:01:41,000 --> 00:01:44,570
谢谢你们参加今天的课程，
to you know actually thank you for attending today's lecture,

27
00:01:44,600 --> 00:01:46,730
即使没有非常正式的计划，
even though there's not a sort of very formal program,

28
00:01:46,730 --> 00:01:49,040
我也感谢工作人员，
I also appreciate the fact that with the staff

29
00:01:49,040 --> 00:01:53,330
我很感激你们非常忙碌，
and generally appreciate the fact that you know you're being very engaged,

30
00:01:53,330 --> 00:01:57,110
尤其论文不是直接对应实验，
and in particular the paper that not directly to the labs,

31
00:01:57,110 --> 00:02:00,560
很明显，你们中的许多人都深入论文中，
you know it's clear that many of you dove into the papers

32
00:02:00,560 --> 00:02:01,940
试图真正理解它们，
and try to really understand them,

33
00:02:01,940 --> 00:02:04,760
在电子邮件上问一些很棒的问题。
and ask great great question of over email.

34
00:02:04,760 --> 00:02:09,350
所以，我们非常感谢你们的努力。
So, we very much appreciate the engagement.

35
00:02:10,780 --> 00:02:15,470
在我讲每个主题之前，有什么问题吗？
Any questions, before I go with each set of topics?

36
00:02:21,540 --> 00:02:25,830
好的，让我从电子邮件中出现最多的问题开始，
Okay, let me start with the question that probably came up most in email,

37
00:02:25,890 --> 00:02:27,000
接下来是什么。
what next.

38
00:02:28,580 --> 00:02:35,900
有很多课程是面向系统的，
There's a quite a number of classes that systems oriented focused,

39
00:02:36,350 --> 00:02:39,500
我肯定我错过了一些课，
and I'm sure I missed a number of classes,

40
00:02:39,590 --> 00:02:41,330
我应该在这里列出的，
that I should have listed here,

41
00:02:41,600 --> 00:02:44,660
它与操作系统直接相关，
you know immediately straightly related to operating systems,

42
00:02:44,660 --> 00:02:47,240
当然，如果你学过 6.033 ，
you know clearly you know if you have taken 6.033 yet,

43
00:02:47,270 --> 00:02:48,470
这是一门很棒的课程，
it's a great class to take,

44
00:02:48,470 --> 00:02:52,460
尤其是我们阅读或学习如何阅读论文。
particularly we read or learn how to read papers.

45
00:02:52,950 --> 00:02:59,910
6.828 是我们最初提供的唯一操作系统课程，
6.828 which the originally only OS class we offered,

46
00:02:59,940 --> 00:03:03,480
今年或者第二年，
this year or second year we're,

47
00:03:03,750 --> 00:03:05,790
今年是提供这两门课的第一年，
this year first year of offering both,

48
00:03:06,090 --> 00:03:08,520
所以， 6.S081 是本科生操作系统，
so 6.S081 is undergrad OS

49
00:03:08,520 --> 00:03:14,340
6.828 作为研究生的操作系统课程。
and 6.828 as the grad level OS class.

50
00:03:14,870 --> 00:03:17,330
6.828 假设，
And you know basically 6.828 issues

51
00:03:17,330 --> 00:03:20,120
你已经选了 6.S081 或本科生操作系统，
you've taken 6.S081 or undergrad OS

52
00:03:20,120 --> 00:03:26,150
在新的项目和构建有趣的操作系统工件，
and you know goes off in new projects and building interesting OS artifacts,

53
00:03:26,680 --> 00:03:28,810
从文献中阅读更多的论文，
and reading more papers from the literature

54
00:03:28,960 --> 00:03:31,390
以及更多的现代研究文献。
and more of the modern research literature.

55
00:03:32,660 --> 00:03:34,430
然后也许你更，
Then maybe you are more you know,

56
00:03:34,430 --> 00:03:38,000
操作系统有很多与硬件的接口，
the OS sort of you know there's a lot of interfacing with the hardware,

57
00:03:38,030 --> 00:03:40,820
有更多的系统的硬件方面，
would have been more of the hardware side of systems,

58
00:03:40,820 --> 00:03:42,980
计算机架构课程 6.823 ，
you know the computer architecture class 6.823,

59
00:03:42,980 --> 00:03:45,080
我相信会在即将到来的春天提供，
which I believe is offered to the coming Spring

60
00:03:45,320 --> 00:03:47,000
当然还有 6.111 ，
and of course there's 6.111,

61
00:03:47,000 --> 00:03:50,990
是构建硬件设备的东西。
you know sort of the building something hardware devices.

62
00:03:51,460 --> 00:03:55,270
在性能方面，在编译器方面，
On the sort of performance sides, in the compiler sides,

63
00:03:55,270 --> 00:03:57,820
6.172 6.035 是个好地方，
6.172, 6.035 for a good places,

64
00:03:57,850 --> 00:04:02,020
你们中的一些人同时选修了 6.172 ，
a number of you are taking 6.172 in parallel with 6.S081,

65
00:04:02,050 --> 00:04:05,620
如果你选了编译课程 6.035
so but if you have taken for example the compiled class 6.035

66
00:04:05,620 --> 00:04:07,780
或动态编译器课程，
or dynamic compiler class,

67
00:04:07,780 --> 00:04:10,240
它们两个也都是很棒的课程。
both of them are also great classes.

68
00:04:11,580 --> 00:04:13,650
系统是一个宽泛的话题，
System is a broad topic,

69
00:04:13,680 --> 00:04:16,230
所以，这里有网络，
so like there's networking

70
00:04:16,230 --> 00:04:18,090
以及一大批课程，
and there's a whole branch of classes

71
00:04:18,090 --> 00:04:20,070
围绕网络的整个课程，
whole [] of classes around networking,

72
00:04:20,130 --> 00:04:23,940
以及围绕数据库的整个课程，
and a whole stream of class around databases,

73
00:04:24,240 --> 00:04:27,730
这些都是好的和重要的，
which are all good and important,

74
00:04:27,790 --> 00:04:31,570
你在 6.S081 中看到的方面
and aspects that you've seen in 6.S081

75
00:04:31,570 --> 00:04:35,590
将在这些课程中以更重要的方式出现。
will show up in much more prominent ways in those classes.

76
00:04:36,510 --> 00:04:40,440
比如，网络是一个很棒的话题 6.829 ，
For example, networking clears a great topic of 6.829,

77
00:04:40,440 --> 00:04:43,050
你会在那里看到更多关于网络的内容，
and so you'll see a lot more about networking there,

78
00:04:43,380 --> 00:04:44,970
比起你已经在 6.S081 中看到的，
than you've seen in 6.S081,

79
00:04:45,240 --> 00:04:47,790
6.830 ，我们讨论过文件系统，
6.830 you know we talked about file systems,

80
00:04:47,790 --> 00:04:51,150
是另一种重要的存储系统，
you know clearly another important classes of storage systems,

81
00:04:51,150 --> 00:04:55,410
可能在一些方面对许多应用程序更重要，数据库，
and probably in some ways more important for many applications, databases,

82
00:04:55,410 --> 00:04:58,140
所以你有 6.830 这个很棒的课程
and so you get 6.830 a great topic class

83
00:04:58,140 --> 00:04:59,700
来学习更多关于数据库的知识。
to learn a lot more about databases.

84
00:05:00,780 --> 00:05:02,370
这些课程，
In terms of like classes,

85
00:05:02,370 --> 00:05:06,180
有时叫做 PDOS 课程，
that are sort of you know sometimes called whatever the PDOS classes,

86
00:05:07,440 --> 00:05:08,970
这里有很多课程，
there's a number of them,

87
00:05:09,030 --> 00:05:13,110
6.824 分布式系统课程将开设，
6.824 distributed systems class will be offering that,

88
00:05:13,110 --> 00:05:16,470
在下学期春季学期，
coming semester Spring semester,

89
00:05:16,470 --> 00:05:23,180
本学期在 6.S081 涉及的教职员工，
and section of the number of the staff involved this semester in 6.S081

90
00:05:23,180 --> 00:05:24,620
将参与 6.824 。
will be involved in 6.824.

91
00:05:25,330 --> 00:05:29,650
有 6.858 是计算机安全课程，
There's 6.858 which is a computer security class,

92
00:05:29,830 --> 00:05:33,040
今年春天我们不会提供，
we won't be offering in that coming this Spring,

93
00:05:33,040 --> 00:05:36,220
但是我们希望在下一学年提供。
but we hope to offer it the next academic year.

94
00:05:36,870 --> 00:05:41,100
有 6.826 是计算机系统原理，
And there's 6.826 which are principles of computer system,

95
00:05:41,100 --> 00:05:44,970
有很多人问起验证和系统软件，
so a number of people ask about verification and system software,

96
00:05:44,970 --> 00:05:45,960
这就是你要学的课程，
this is the class you take,

97
00:05:45,960 --> 00:05:47,730
如果你对那个主题感兴趣。
if you are interested in that topic.

98
00:05:48,780 --> 00:05:50,940
更广泛地说，
More broadly speaking,

99
00:05:50,940 --> 00:05:54,300
很多人想知道研究要怎么继续，
a lot of people wondering what is actually going on in research,

100
00:05:54,300 --> 00:05:54,990
如果你感兴趣，
if you're interested,

101
00:05:54,990 --> 00:05:59,730
几乎所有系统文献的论文都是公开的，
you know almost all the papers in the systems literature are publicly available,

102
00:05:59,730 --> 00:06:01,890
甚至最近的会议，
even the ones of the recent conferences,

103
00:06:01,920 --> 00:06:05,400
比如， OSDI 会议在几周前举行，
for example the OSDI conference happened a couple weeks ago,

104
00:06:05,700 --> 00:06:07,950
你可以看着它们，
and you can just look at them

105
00:06:07,950 --> 00:06:09,840
看看有哪些主题，
and see what kind of topics are covered

106
00:06:09,840 --> 00:06:11,760
看看你觉得有趣的论文，
and read the papers that you find it interesting,

107
00:06:11,760 --> 00:06:13,050
所有的讨论都发表了，
all the talks are published,

108
00:06:13,410 --> 00:06:16,950
会议的优势之一，
one of advantages of, you know, conference,

109
00:06:16,950 --> 00:06:18,390
所有这些会议都是虚拟的，
that all these conference are virtual,

110
00:06:18,390 --> 00:06:21,600
所以所有的会议都被记录下来了，
and so all the conferences are recorded,

111
00:06:21,600 --> 00:06:24,180
你可以查看它们，看看发生了什么。
and you can just watch them and see what's going on.

112
00:06:24,850 --> 00:06:27,100
如果你对这两部分感兴趣，
If you interested in the sort of two parts,

113
00:06:27,100 --> 00:06:28,390
这里有研究的部分，
there's the research part,

114
00:06:28,780 --> 00:06:31,120
当然还有实践中正在进行的事情。
then of course there's what's going on in practice.

115
00:06:31,120 --> 00:06:32,890
如果你有兴趣
And you know if you're interested in

116
00:06:32,920 --> 00:06:34,810
跟踪 Linux 正在发生的事情，
keeping track of what's happening with Linux

117
00:06:34,810 --> 00:06:37,510
以及它是如何发展的，
and how that's how it's evolving,

118
00:06:37,870 --> 00:06:43,510
lwn.net 发布了常规的页面和非常有趣的文章，
lwn.net actually publish a very regular page and a very interesting articles

119
00:06:43,510 --> 00:06:48,010
关于围绕 Linux 内核的重大变化或话题。
about like big changes or topics that are around the Linux kernel.

120
00:06:49,470 --> 00:06:53,910
最后，如果你对做实验感到兴奋，
Finally you know, if you're just excited about like doing the labs,

121
00:06:53,910 --> 00:06:55,500
只需要继续 hack 就行了，
you know just keep keep hacking,

122
00:06:55,620 --> 00:06:58,920
我认为你可以很容易地创造出项目，
I think you can easily to cook up projects

123
00:06:58,920 --> 00:07:02,310
要么通过扩展实验，
are either by doing extension of labs

124
00:07:02,310 --> 00:07:03,870
或者试一试你自己的事情，
or just trying things out on your own,

125
00:07:04,740 --> 00:07:09,360
这是学习和查看事物运作方式的一种很好的方式。
it's a great way to really learn and appreciate how things work.

126
00:07:10,090 --> 00:07:12,310
你在实验里可能对此有很好的感觉，
You probably got a good sense of that during the labs,

127
00:07:12,310 --> 00:07:15,340
我们是边做边学的铁杆粉丝，
we're sort of big fans of learning by doing

128
00:07:15,520 --> 00:07:19,990
还有很多你自己可以做的事。
and a lot that you can do on your own.

129
00:07:22,930 --> 00:07:29,130
关于 6.S081 之后的下一步，还有什么问题吗？
Any questions about what next after 6.S081?

130
00:07:41,410 --> 00:07:42,010
好的？
Okay?

131
00:07:43,180 --> 00:07:46,630
好的，我们来谈谈网络实验，
Well, let's talk about the net lab,

132
00:07:47,360 --> 00:07:51,890
我想昨天就截止了。
it was due I guess yesterday.

133
00:07:56,100 --> 00:07:58,350
有几件事，
And so as a couple things,

134
00:07:58,350 --> 00:08:01,440
我会慢慢开始深入，
maybe I'll start dive in slowly,

135
00:08:01,440 --> 00:08:02,940
我从最高层开始，
I start a little bit at the top,

136
00:08:03,300 --> 00:08:08,850
让我用普通术语来讨论一下实验。
and let me talk a little bit in generic terms about the lab.

137
00:08:13,390 --> 00:08:14,710
这里有几件事情，
There's a couple things right,

138
00:08:14,710 --> 00:08:17,800
首先，我想稍微谈谈一些结构性的东西，
first, I want to talk a little bit about just sort of structural things,

139
00:08:19,120 --> 00:08:21,820
这会影响实验的设计，
that sort of influence the design of the lab

140
00:08:21,820 --> 00:08:23,650
或者实验的编码。
or you know the coding of the lab.

141
00:08:23,920 --> 00:08:26,500
这里有四种不同方面的东西，
And there are four different things in aspects,

142
00:08:26,500 --> 00:08:28,660
其中一个我想谈谈硬件，
one of these I just want to talk a little bit about hardware,

143
00:08:29,140 --> 00:08:31,540
这是实验中的一个，
you know, this is one of the labs where we,

144
00:08:31,570 --> 00:08:34,360
软件和硬件之间有很多交互，
there's a lot of interaction between software and hardware,

145
00:08:34,360 --> 00:08:37,090
事实上，硬件在很大程度上决定了
in fact the hardware determines for a great part

146
00:08:37,090 --> 00:08:39,370
软件的结构。
like how the the structure of software.

147
00:08:40,250 --> 00:08:42,470
然后稍微介绍一下软件结构，
Then a little bit about software structure,

148
00:08:43,170 --> 00:08:45,660
回到这个一般性的话题上来，
and just sort of back to this general topic,

149
00:08:45,660 --> 00:08:48,480
我们在学期中期的某个地方谈到了，
that we covered in a sort of somewhere in the middle of the term

150
00:08:48,480 --> 00:08:50,520
关于驱动的组织，
about you know the organization of drivers

151
00:08:50,520 --> 00:08:52,560
相对于操作系统内核的其他部分。
relative to the rest of the operating system kernel.

152
00:08:52,890 --> 00:08:55,590
然后更多讨论一下关于硬件结构，
Then talk a little bit more specific about hardware structures,

153
00:08:55,590 --> 00:08:59,680
rings ，以及描述符，
you know the rings, and you know the descriptors,

154
00:09:02,500 --> 00:09:04,690
是硬件结构的两个主要部分，
are the two primary sort of hardware structures,

155
00:09:04,690 --> 00:09:07,840
驱动程序必须处理的。
that the driver deals with or it must deal with.

156
00:09:08,780 --> 00:09:12,830
然后我会谈到代码，特别是解决方案，
And then I'll talk to talk about the code and particularly the solutions,

157
00:09:13,220 --> 00:09:17,210
关注一下 mbufs 的作用，
and focusing on a little bit about the role of mbufs,

158
00:09:19,780 --> 00:09:22,690
还有通过电子邮件的锁的很多问题，
you know locking a lot of questions over email,

159
00:09:22,690 --> 00:09:27,700
关于为什么不对接收函数加锁，
about why not to lock in receive lock, receive in the receive function,

160
00:09:27,790 --> 00:09:30,370
为什么在接收处理程序中的循环，
why the loop in the receive handler,

161
00:09:31,140 --> 00:09:36,000
以及命令的标志代表什么，
and you know what exactly you know the flags meaning the command,

162
00:09:36,060 --> 00:09:40,710
描述符结构的命令字段。
command field of the structure of the descriptor.

163
00:09:40,710 --> 00:09:42,120
我们将查看这些问题，
and so we'll get to those issues

164
00:09:42,120 --> 00:09:44,820
同时查看代码。
as we as we look at the top as we look at the code.

165
00:09:47,110 --> 00:09:48,340
在开始之前，
Just before drive in,

166
00:09:48,340 --> 00:09:49,450
可能是值得的，
it may be worthwhile,

167
00:09:49,450 --> 00:09:50,620
在这里提醒我们自己，
so reminding ourselves here,

168
00:09:50,620 --> 00:09:51,730
挑战是什么，
what the challenges are,

169
00:09:51,730 --> 00:09:54,040
尽管它们可能还在你的脑海中记忆犹新，
although they're probably fresh in your head,

170
00:09:54,070 --> 00:09:55,690
从高级别来看，
like from a high level

171
00:09:55,690 --> 00:09:57,820
一个核心[]挑战，
and one of the sort of core [] challenges,

172
00:09:57,820 --> 00:09:59,680
你必须在实验中解决的。
that you have to deal with in this lab.

173
00:10:01,610 --> 00:10:04,130
你可以在任何时候跳进来，
If you'll jump in to any ones,

174
00:10:04,130 --> 00:10:06,440
如果我可能错过的和你[挣扎]过的（问题）。
that I might have missed and you struggled with.

175
00:10:07,030 --> 00:10:09,610
首先，是硬件规格，
So, first of all you know there's the hardware specification,

176
00:10:10,120 --> 00:10:13,780
这是一份 PDF 文件，
you know it's a PDF,

177
00:10:13,780 --> 00:10:15,520
是一份很严肃的文件，
is a pretty serious document,

178
00:10:15,970 --> 00:10:20,380
这个网卡 E1000 ，
and this network card E1000,

179
00:10:20,380 --> 00:10:22,420
尽管它是一个非常简单的网卡，
even though it's a reasonable simple network card,

180
00:10:22,420 --> 00:10:25,690
仍然是一个非常复杂的硬件，
is still a very sophisticated piece of hardware,

181
00:10:25,690 --> 00:10:29,680
它提供了许多不同的功能和编程方式，
that offers a lot of different features and ways you can program,

182
00:10:29,710 --> 00:10:32,260
你需要掌握，
and you're just getting on top of actually

183
00:10:32,260 --> 00:10:35,770
卡的功能，以及你是如何对它进行编程，
what you know the card does and how do you program it,

184
00:10:36,040 --> 00:10:41,680
它的内部是困难的，也是一个挑战。
you know just internalizing all that is difficult and poses a challenge.

185
00:10:46,520 --> 00:10:50,960
第二，我想你知道主要的挑战是事情的并发性，
Second, I think you know major challenges, the concurrency side of things,

186
00:10:52,620 --> 00:10:57,270
有两个部分的并发性使这个实验具有挑战性，
and there's sort of two parts the concurrency that makes this lab challenging,

187
00:10:57,390 --> 00:11:00,210
一个就是硬件和软件之间的并发性，
one is just the concurrency between the hardware and software,

188
00:11:01,060 --> 00:11:03,700
比如网卡在做一些事情，
like the network card is just doing things,

189
00:11:03,700 --> 00:11:06,670
比如同时发送数据包，接收数据包，
like sending package, receiving packets at the same time,

190
00:11:06,670 --> 00:11:08,770
操作系统内核在运行，驱动程序也在运行，
you know the OS kernel is running and the driver is running,

191
00:11:09,100 --> 00:11:13,420
所以在硬件和软件之间必须有一些协调计划，
and so there has to be some coordination plan between the hardware and software,

192
00:11:13,420 --> 00:11:15,790
确保每件事都能顺利解决，
you know to actually make sure that everything works out,

193
00:11:16,860 --> 00:11:22,800
驱动的很大一部分都在处理这种协调问题。
and a large part of the driver is you know dealing with that coordination.

194
00:11:23,860 --> 00:11:28,180
还有软件与软件的协调，
There's also the software software coordination,

195
00:11:28,540 --> 00:11:30,700
驱动程序多个线程或多个内核线程
the driver multiple threads,

196
00:11:30,700 --> 00:11:31,780
or multiple kernel threads

197
00:11:31,780 --> 00:11:36,100
可能在驱动程序内部运行的处理程序周围，
might be ending around handler run inside of the driver,

198
00:11:36,100 --> 00:11:37,060
我们要确保，
and we've got to make sure that,

199
00:11:37,060 --> 00:11:41,470
它们不会互相践踏或类似的事情发生，
they don't step on each other's toes, nothing else happens,

200
00:11:41,470 --> 00:11:46,430
这在锁主题中会有很多。
and this comes a lot to like you know locking topic.

201
00:11:47,160 --> 00:11:49,140
即使这个驱动，
Even the, even this driver,

202
00:11:49,140 --> 00:11:54,990
就软件并发性而言，想法是非常直接的，
thinks a reasonable straightforward, in terms of the concurrency for software concurrency,

203
00:11:55,020 --> 00:11:58,440
但是尽管如此，你还是需要注意和思考一些事情。
but nevertheless you know something that requires attention and a little bit of thinking.

204
00:11:59,260 --> 00:12:04,330
最后，我想可能在你的列表中，
And finally I guess that was probably on the top of your list or many of your list,

205
00:12:04,330 --> 00:12:07,450
就是调试有点困难，
just debugging this is a little bit hard,

206
00:12:08,070 --> 00:12:10,740
更具挑战性的纯软件调试，
a little bit something more challenging of pure software debugging,

207
00:12:10,740 --> 00:12:14,490
因为你不能在网卡内部设置断点，
because you can't set breakpoints inside of the network card,

208
00:12:14,550 --> 00:12:17,340
你在对寄存器编程，
you know you're in program the registers,

209
00:12:17,340 --> 00:12:20,490
然后它会让网卡做好工作，
and then this would give the card a kick and say like please do your work,

210
00:12:20,970 --> 00:12:22,710
如果网卡什么也不做，
and then if the card doesn't do anything

211
00:12:22,710 --> 00:12:24,990
或者你看不到你的数据包从另一端出来，
or you don't see your packet coming out on the other side,

212
00:12:24,990 --> 00:12:29,720
在数据包率的记录中，
you know in the log of the packet rates,

213
00:12:30,050 --> 00:12:32,750
那你就很挠头了，
then you basically have to scratch your head

214
00:12:32,750 --> 00:12:36,110
并开始思考可能出了什么问题，
and start thinking about what you might have gone wrong

215
00:12:36,110 --> 00:12:39,350
或者你可能在硬件规范中漏掉了什么，
or what you might have missed in the hardware specification,

216
00:12:40,220 --> 00:12:42,530
你必须来回绕圈，
and you have to circle back and forth,

217
00:12:42,530 --> 00:12:44,630
而且没有一种简单的方法，
and there's no sort of easy way,

218
00:12:44,630 --> 00:12:49,870
你不能单步调试网卡。
you just cannot single step you know through the network card.

219
00:12:52,550 --> 00:12:54,290
就挑战而言，这能理解吗，
Does that make sense in terms of challenges,

220
00:12:54,290 --> 00:12:56,840
这与你自己的经历是一致的，
you know there's that line up with your own experience

221
00:12:56,840 --> 00:12:58,670
或者我错过了一些，
or I missing some of the,

222
00:12:59,410 --> 00:13:01,930
错过了你处理的核心挑战。
missing one of the core challenges that you dealt with.

223
00:13:18,330 --> 00:13:20,490
好的，好的。
Okay, well, yeah.

224
00:13:21,390 --> 00:13:22,350
让我们来谈谈，
Let's talk to the,

225
00:13:22,350 --> 00:13:24,360
让我们从硬件方面开始，
let's start with the hardware side of things,

226
00:13:24,450 --> 00:13:27,870
我想从那里开始的原因是，
and the reason I want to start there,

227
00:13:27,870 --> 00:13:31,380
因为，很容易记住或忘记这样一个事实，
because you know, it's so easy to keep or lose track of the fact,

228
00:13:31,380 --> 00:13:33,000
你是在和硬件打交道，
that you're actually dealing with hardware here,

229
00:13:33,360 --> 00:13:38,820
即使通过某种虚拟化，使用 QEMU 对其进行模拟，
you know even through you know sort of virtualized where it is emulated by QEMU,

230
00:13:38,820 --> 00:13:42,810
你只是在你的 Athena 或笔记本电脑上运行它，
and you're just running it on your, on Athena or your laptop,

231
00:13:42,960 --> 00:13:46,410
QEMU 实现的实际是硬件。
the actual thing that's implemented by QEMU is hardware.

232
00:13:46,590 --> 00:13:48,000
所以再次提醒你，
So it's usually gonna remind you again,

233
00:13:48,240 --> 00:13:50,880
你之前看过这张图片，
you've seen this picture before,

234
00:13:50,880 --> 00:13:52,680
你知道思考这件事的方式是，
you know the way to think about it is that,

235
00:13:52,680 --> 00:13:59,100
QEMU 模拟了一个完整的设备和处理器电路板。
you know QEMU emulate a complete board of devices and processor.

236
00:13:59,750 --> 00:14:01,700
还有。
And.

237
00:14:04,220 --> 00:14:07,520
所以，我们都知道，我在之前说过的，
And so we all know, I'm talk a little bit before about,

238
00:14:07,520 --> 00:14:13,700
处理器就是整个电路板的一小块，
the processor actually these are like almost like a small piece of the whole board,

239
00:14:13,700 --> 00:14:15,440
是在风扇的下面的东西，
you know the thing that sits under the fan here,

240
00:14:15,680 --> 00:14:19,010
但是还有一系列设备，
but then there's a range of devices,

241
00:14:19,010 --> 00:14:22,310
这些设备都连接到或可以连接到这块板上，
you know that are connected or can be connected to this board,

242
00:14:22,640 --> 00:14:26,840
然后与运行在处理器的代码进行交互，
and then interact you know with the code running on the processor,

243
00:14:26,840 --> 00:14:29,210
在这里使用这个特殊的实验，
you know here use this particular lab,

244
00:14:29,210 --> 00:14:30,740
真正有趣的是，
what is really interesting sort of,

245
00:14:31,280 --> 00:14:32,930
它是以太网插孔，
it is actually Ethernet jack,

246
00:14:33,050 --> 00:14:34,970
在那里你可以插入以太网电缆，
where you can plug Ethernet cable,

247
00:14:34,970 --> 00:14:38,660
然后另一个网卡把它的数据包送过来。
and then the other is actually the thing that the network card you know sends its package over.

248
00:14:40,440 --> 00:14:44,250
QEMU 并不完全模仿这块板，
You know, QEMU doesn't emulate exactly this board,

249
00:14:44,520 --> 00:14:45,690
所以事情略有不同，
so things like are slightly differently,

250
00:14:45,690 --> 00:14:47,850
但是，至少在概念上，
but again you know at least conceptually,

251
00:14:47,850 --> 00:14:50,700
这个图片，你应该把它放在你的脑海里，
this is like the picture, you should have in your in your head, right,

252
00:14:50,700 --> 00:14:54,210
当有进程写入寄存器时，
and so when there's a process writing registers,

253
00:14:54,210 --> 00:14:57,540
设备驱动程序会花费一些东西才能发生，
you know of the device driver that costs some stuff to happen,

254
00:14:57,540 --> 00:15:00,000
最终一些数据包从这根电缆里出来，
that actually in the end some packages comes out of this cable,

255
00:15:00,240 --> 00:15:03,370
它连接到以太网接口。
that's connected to Ethernet connector.

256
00:15:05,840 --> 00:15:08,600
你知道的更多的，
You know in a slightly more,

257
00:15:08,690 --> 00:15:16,940
在示意图中更多的，
you know in a slightly more in a schematic diagram,

258
00:15:16,940 --> 00:15:19,430
这里的图片是一样的，
you know this is the same picture basically in here,

259
00:15:19,430 --> 00:15:21,440
我们在这里看到的是处理器，
you know we're seeing here is our processor,

260
00:15:21,920 --> 00:15:24,230
电路板上面有四个核心，
board that has four cores on it,

261
00:15:24,440 --> 00:15:26,960
它有 L1 和 L2 缓存，
it has l1 and l2 cache,

262
00:15:26,960 --> 00:15:29,420
然后有一个到内存的连接，
and then there's like a link you know go to memory,

263
00:15:29,570 --> 00:15:32,690
这是一个内存， RAM 随机存取寄存器，
so here's a memory, and the RAM random access memory,

264
00:15:32,690 --> 00:15:34,250
正如我们稍后将看到的，
and as we'll see in a second,

265
00:15:34,250 --> 00:15:36,110
它是一个重要的角色。
you know that play is actually big role.

266
00:15:36,520 --> 00:15:39,370
这里[交叉]连接到，
And here like intersection to link you know to the,

267
00:15:39,730 --> 00:15:43,000
在这里连接到千兆以太网控制器，
for here actually it's linked to the gigabit Ethernet controller,

268
00:15:44,350 --> 00:15:47,550
有点混乱，
you know, just a little bit messy,

269
00:15:47,550 --> 00:15:51,870
思考这个级别的细节是怎么回事。
you know sort of think about the this level of detail what exactly is going on.

270
00:15:51,930 --> 00:15:53,160
所以对于课程的剩余部分来说，
And so for the rest of lecture,

271
00:15:53,160 --> 00:15:56,040
这里的图片稍微简单一点，
here a little bit more simpler picture,

272
00:15:58,240 --> 00:16:01,450
图片在你的脑海里，
and the picture guys really you should you're in your head

273
00:16:01,780 --> 00:16:06,340
你可能是在做实验的时候开发的，如下所示。
and you probably developed while doing lab is as follows.

274
00:16:07,780 --> 00:16:14,290
基本上有四个处理器或者核心，
Basically have are basically four processors or cores,

275
00:16:15,470 --> 00:16:16,880
这里是 RISC-V ，
here's are RISC-V,

276
00:16:19,120 --> 00:16:22,450
然后这里是 RISC-V 核心，
and then there's RISC-V of cores

277
00:16:22,450 --> 00:16:26,020
并执行你编写的指令，
and execute instructions you know you're writing,

278
00:16:26,170 --> 00:16:27,580
你可以想想看，
and you can just think about them,

279
00:16:27,580 --> 00:16:29,560
它们都连接到总线上，
they're sort of all connected to your bus,

280
00:16:29,560 --> 00:16:31,840
然后有一个小的简化，
and then there's a little bit of simplification,

281
00:16:31,840 --> 00:16:34,360
这会让你更容易解释事情。
but like it makes it easier to explain things.

282
00:16:34,780 --> 00:16:37,870
在总线上，那里有随机存取存储器，
And so on the bus, you know there's the random access memory,

283
00:16:40,030 --> 00:16:43,960
其中有内核使用的所有数据存储，
where all the data you know the kernel actually uses store,

284
00:16:43,960 --> 00:16:45,670
内核本身的存储，
the kernel [] that itself stores,

285
00:16:45,670 --> 00:16:48,610
我们在学期开始的时候看到很多细节。
you know look at there's a great amount of detail in the beginning of the semester.

286
00:16:49,000 --> 00:16:50,860
然后对于这个实验，
And then this you know for this particular lab,

287
00:16:50,860 --> 00:16:52,960
有趣的是，在总线上，
the thing that's interesting is that on the bus,

288
00:16:53,570 --> 00:16:59,360
是网卡 E1000 。
is actually the network card you know E1000, that E1000.

289
00:17:01,910 --> 00:17:06,680
RAM 通常连接到 RISC-V 处理器上，
And you know the RAM is generally more connected to the RISC-V processor

290
00:17:06,680 --> 00:17:08,150
更多地是通过一些专用总线，
directly with some private bus,

291
00:17:08,330 --> 00:17:13,250
而网络设备则是较慢类型的总线上，
and network devices tend to be on a slower type of bus,

292
00:17:13,460 --> 00:17:15,530
尤其是实验中的总线，
in particular bus that in the lab,

293
00:17:15,530 --> 00:17:19,010
这里有一条 PCIe 总线，
you know there's a PCIe PCIe bus,

294
00:17:19,010 --> 00:17:24,090
连接处理器部分和网络部分。
that actually connects the processor part you know with the network part.

295
00:17:27,260 --> 00:17:29,870
为了让网络做点事情，
You know to get the network to do something,

296
00:17:29,990 --> 00:17:33,710
网卡内部有控制器，
the network card has controller inside of it,

297
00:17:33,710 --> 00:17:35,960
这些控制器有寄存器，
and you know these controller has registers,

298
00:17:37,690 --> 00:17:38,890
而且你可以，
and you can,

299
00:17:39,460 --> 00:17:42,250
这些寄存器的一个很酷的方面是，
one of the cool aspects of you know these registers,

300
00:17:42,250 --> 00:17:46,180
它们被称为内存映射 IO 寄存器，
they are called memory mapped IO registers,

301
00:17:46,390 --> 00:17:47,890
所以你可以写入它们，
and so you could just write them

302
00:17:47,890 --> 00:17:52,870
使用 *0x 或者别的什么值，
with whatever a star you know, 0x and whatever the value is

303
00:17:52,870 --> 00:17:55,180
对于在物理内存空间中，
you know for in the physical memory space,

304
00:17:55,330 --> 00:17:57,310
那个寄存器的值是多少，
what the value is for that particular register,

305
00:17:57,760 --> 00:18:01,290
比如我们可能有头和尾寄存器。
you know, like we might have our head, our tail registers.

306
00:18:02,260 --> 00:18:05,740
你知道我们可以，驱动程序可以写入它们，
And you know we can, the driver can write those

307
00:18:05,740 --> 00:18:08,410
通过执行加载或存储指令，
by executing load or store instruction

308
00:18:08,710 --> 00:18:13,450
到对应物理地址空间这个地址，
you know to the address you know of corresponds you know in the physical address space

309
00:18:13,570 --> 00:18:15,220
到寄存器的位置。
to the location of that register.

310
00:18:15,770 --> 00:18:18,620
硬件将确保当我们加载或存储时，
And the hardware will ensure when we do load or store,

311
00:18:18,710 --> 00:18:21,950
那个存储要么去，
you know that that store will either go you know go to the,

312
00:18:22,660 --> 00:18:25,900
如果它是控制寄存器，则转到控制寄存器，
if it is one of the control register, will go to the control registers,

313
00:18:25,900 --> 00:18:29,470
如果是在 RAM 中的地址，则会进入 RAM 中。
if the go one address is in RAM, will go to the RAM.

314
00:18:31,270 --> 00:18:35,050
所以，你可以对网卡编程，
So you can just manipulate the program network card

315
00:18:35,050 --> 00:18:38,590
通过加载、读取和写入这些控制寄存器，
by loading, reading and writing these control registers,

316
00:18:38,590 --> 00:18:42,310
正如你看到的，这些控制寄存器中的位具有特殊意义。
and basically bits in these control registers have special meaning as you have seen.

317
00:18:43,570 --> 00:18:46,490
现在，对于这个网卡，
Now, for this particular card

318
00:18:46,490 --> 00:18:49,790
网卡需要通过网络发送数据包，
you know network needs to send packets across the network,

319
00:18:49,940 --> 00:18:52,070
而且它需要从某个地方获取数据包。
and you know it needs to get the packet somewhere.

320
00:18:53,010 --> 00:18:55,770
所以，数据包实际上是在，
And so, the packets actually live,

321
00:18:55,800 --> 00:18:58,320
就像我们稍后会看到的那样，
you know are allocated as we'll see in a second

322
00:18:58,320 --> 00:18:59,820
分配在内存中的某个地方，
you know just live somewhere in memory,

323
00:19:01,930 --> 00:19:04,840
我们所做的就是，
and and what we do is,

324
00:19:05,110 --> 00:19:06,910
实际上，除了这些数据包之外，
in fact, in addition to these packets,

325
00:19:06,910 --> 00:19:09,910
还有两个环形结构也在内存中。
you know there's sort of two ring structures that also live in memory.

326
00:19:14,420 --> 00:19:20,710
而且，我们可以编程，
And, and we can you know program,

327
00:19:20,800 --> 00:19:22,960
我们可以告诉网卡，
and we can tell the card,

328
00:19:22,960 --> 00:19:25,540
网卡也知道这些环形结构在哪里，
you know the card also knows where these ring structures are,

329
00:19:26,230 --> 00:19:28,900
它有 tx 环的地址，
you know it has address where to you know tx ring is,

330
00:19:28,900 --> 00:19:32,400
它有 rx 环的地址，
you know it has an address where to rx ring is,

331
00:19:32,850 --> 00:19:37,530
硬件网卡会查看这些地址
and you know the hardware card looks at those addresses

332
00:19:37,530 --> 00:19:39,720
来查看需要发送哪些数据包，
to actually see which packets need to be sent,

333
00:19:39,840 --> 00:19:43,710
所以，在这里，我们可能有一个需要传输的数据包队列，
so here we might have a queue of packets that need to be transmitted

334
00:19:43,710 --> 00:19:45,690
或者一个需要接收的数据包队列。
or a queue packets that need to be received.

335
00:19:48,910 --> 00:19:55,610
还有，你知道 E1000 ， DMA ，
And, you know the E1000 you know DMAs,

336
00:19:55,610 --> 00:20:01,130
比如它们会在第一个数据包发送时工作，
you know for example like you know they're going to work on the first packet to sent,

337
00:20:01,130 --> 00:20:06,290
DMA 是那些与数据包关联的分组数据，
it will DMA basically you know those packets data associated with the the packets,

338
00:20:06,440 --> 00:20:09,260
直接从 RAM 到网络，
you know straight from RAM to the network,

339
00:20:09,980 --> 00:20:12,350
在完全不涉及处理器的情况下，
without actually having the processor involved at all,

340
00:20:13,400 --> 00:20:15,110
这就是所谓的 DMA ，即直接存储器存取。
what is called DMA, direct memory access.

341
00:20:19,130 --> 00:20:19,910
好的？
Okay?

342
00:20:21,890 --> 00:20:25,220
这个概述图片能理解吗，
Does this makes sense in terms of a more abstract picture

343
00:20:25,250 --> 00:20:32,120
对于 RISC-V RAM 和 E1000 的组织来说。
for the organization of the RISC-V RAM and E1000.

344
00:20:33,070 --> 00:20:34,330
对此有什么问题吗？
Any questions about this?

345
00:20:41,500 --> 00:20:45,490
所以，在谈论硬件、软件并发性时，
So, one thing in talking about hardware, software concurrency,

346
00:20:45,550 --> 00:20:49,690
显然，你知道 E1000 和处理器
clearly you know the E1000 and you know the processor

347
00:20:49,690 --> 00:20:56,560
同时操纵这些发送和接收队列或环。
are both manipulating these transmission and reception queues or rings.

348
00:20:57,030 --> 00:20:58,650
所以，这里有某种协议，
And so, there has to be some protocol

349
00:20:58,860 --> 00:21:01,170
给出和获取协议，
sort of given taken give and take protocol,

350
00:21:01,230 --> 00:21:02,910
在某些情况下，
where you know at some point,

351
00:21:03,030 --> 00:21:08,790
环的部分是由网卡拥有和操作的，
particular parts of the ring are operated, are owned or operated by the network card,

352
00:21:08,790 --> 00:21:12,840
有些部分可能在软件或操作系统内核的控制下。
and there are parts that are maybe under control of the software or the OS kernel.

353
00:21:13,500 --> 00:21:15,750
稍后，你会看到这是如何安排的，
And you'll see in a second how that is arranged,

354
00:21:15,960 --> 00:21:17,910
但是我们需要小心，
but you know we got a little bit careful,

355
00:21:17,910 --> 00:21:23,220
网卡不会[绊倒]操作系统，
again, that the card doesn't trip over or trip over the operating system

356
00:21:23,220 --> 00:21:24,090
反之亦然。
or the other way around.

357
00:21:28,540 --> 00:21:29,350
一个简单的问题，
A quick question,

358
00:21:29,380 --> 00:21:35,140
RAM 中是否有单独的发送环和接收环，
so is there a separate transmit ring and and receive ring in the RAM

359
00:21:35,140 --> 00:21:40,270
然后，也在 E1000 驱动程序中。
and then, also in the E1000 or E1000 driver.

360
00:21:40,570 --> 00:21:41,710
是的，有一种方法，
Yeah, well, the one way,

361
00:21:41,710 --> 00:21:43,330
好的，有两件事发生，
okay, so there's two things going on,

362
00:21:43,330 --> 00:21:44,920
我们稍后看一下代码，
and we look at the code in a second,

363
00:21:45,100 --> 00:21:51,190
传输环和接收环驻留在 RAM 中，
the the the transmission ring and receive ring basically lived in RAM,

364
00:21:51,740 --> 00:21:58,730
E1000 和 RISC-V 都可以操作存储在 RAM 中的环，
and both the E1000 and the RISC-V manipulates the ring that actually stored in RAM,

365
00:22:01,140 --> 00:22:04,950
这些就是你在硬件文档中看到的环。
and those are the rings that you saw in the hardware documentation.

366
00:22:05,520 --> 00:22:06,720
它是这种情况，
It happens to be the case,

367
00:22:06,720 --> 00:22:12,780
xv6 也有一个驱动程序维护 mbuf 环，
that xv6 also has a driver maintains a sort of a ring of mbufs,

368
00:22:13,110 --> 00:22:16,770
与发送环和 rx 环分开，
separately of the transmit ring and rx ring,

369
00:22:16,830 --> 00:22:18,840
比如有类似 tx mbuf 的东西。
like there's something like tx mbufs.

370
00:22:21,460 --> 00:22:23,500
这是数据结构，
And that's you know that is the data structure

371
00:22:23,500 --> 00:22:25,420
只有操作系统才了解的，
only the operating system really knows about,

372
00:22:25,840 --> 00:22:28,150
网卡并不知道这个，
the network card doesn't really know about it,

373
00:22:28,150 --> 00:22:33,760
网卡只知道 tx 环和 rx 环，
and network card only knows about the the tx ring and rx ring,

374
00:22:33,850 --> 00:22:37,600
因为这些是编程到寄存器中的值，
because those are the values that were programmed into the registers,

375
00:22:37,720 --> 00:22:39,490
比如，这里你可以找到，
saying like here's where you can find,

376
00:22:39,490 --> 00:22:41,470
这里你可以找到传送环的地址，
here's the address where you can find the transmit ring,

377
00:22:41,530 --> 00:22:43,270
这里你可以找到接收环的地址。
here's the address where you can find the receive ring.

378
00:22:44,520 --> 00:22:45,450
好的，理解了。
Okay, that makes sense.

379
00:22:45,660 --> 00:22:46,260
这个可以理解吗?
That makes sense?

380
00:22:49,840 --> 00:22:52,000
好的，这就是硬件图片，
Okay, so that's sort of the hardware picture,

381
00:22:52,120 --> 00:22:55,750
一个更简明的版本。
in a more schematic version.

382
00:22:55,930 --> 00:22:58,180
让我们稍微谈谈软件结构，
Let's talk a little bit about the software structure,

383
00:22:59,520 --> 00:23:02,760
在这个实验有一个很大的令人困惑的地方。
there's a big confusing actually in this in this lab.

384
00:23:05,870 --> 00:23:07,010
所以，软件结构。
So,software structure.

385
00:23:12,050 --> 00:23:14,990
所以，让我们画出
So, let's just draw you know the thing,

386
00:23:14,990 --> 00:23:17,330
我们最关心的事情，驱动程序，
that we most care about of course you know the driver,

387
00:23:17,360 --> 00:23:21,970
这是我们的驱动程序， E1000 驱动程序。
so here's our driver, the e1000 driver.

388
00:23:26,150 --> 00:23:28,790
它只有两个函数，
And it basically has only two functions,

389
00:23:29,000 --> 00:23:37,600
它有一个 transmit 函数和一个 recv 函数。
it has a transmit function and it has a receive function.

390
00:23:40,810 --> 00:23:44,530
并且 recv 函数响应中断，
And the receive function runs in response to interrupts,

391
00:23:46,300 --> 00:23:47,560
所以中断发生了，
so an interrupt happens,

392
00:23:48,550 --> 00:23:53,860
然后 xv6 将使用通常的中断机制，
then you know xv6 you will use the usual interrupt mechanism,

393
00:23:53,860 --> 00:23:55,150
一个 trap 发生，
you know a trap happen,

394
00:23:55,540 --> 00:23:58,540
trap 查看网卡有没有中断，
trap look you know to see if there's an interrupt from the network card,

395
00:23:58,540 --> 00:23:59,470
如果出现中断，
if there's an interrupt,

396
00:23:59,470 --> 00:24:01,240
网卡将调用 recv 函数。
the network card will call the receive function.

397
00:24:02,600 --> 00:24:03,860
正如你们所记得的，
And as you remember,

398
00:24:03,860 --> 00:24:07,490
我们曾经有一节关于设备驱动程序的课程，
we used to have one of the previous lectures about device drivers,

399
00:24:07,580 --> 00:24:11,270
将设备驱动程序分成两部分通常是有帮助的，
you know it's often helpful to think of the device drivers were split in two parts,

400
00:24:11,760 --> 00:24:16,530
下半部分运行在中断处理程序的上下文中，
you know the bottom half which runs in the context of of interrupt handler,

401
00:24:18,160 --> 00:24:20,320
通常命名为上半部分，
typically [name] for those in the top half,

402
00:24:22,880 --> 00:24:29,360
它通常运行在内核进程或用户级进程的上下文中，
which generally runs in the context of you know kernel process or like a user level process,

403
00:24:29,360 --> 00:24:32,750
比如，如果你想一下位于上面的东西，
so for example if you think about things that sit on top of here,

404
00:24:32,930 --> 00:24:36,110
这里是网络栈代码，
there's the network stack code,

405
00:24:36,110 --> 00:24:40,910
实现 IP UDP 等，位于这里。
that actually implements you know IP UDP and etc, sit above this.

406
00:24:41,430 --> 00:24:42,930
然后你知道，
And then you know there is,

407
00:24:43,500 --> 00:24:46,110
我们通常的线，
you know, our usual you know sort of line,

408
00:24:47,160 --> 00:24:50,220
内核空间在下面，用户空间在上面，
you know kernel space below, user space up,

409
00:24:50,220 --> 00:24:53,250
这是操作系统的世界角度，
and you know this is [] OS view of the world,

410
00:24:53,250 --> 00:24:56,820
用户空间不是特别大或特别重要，
where user space not particularly that big or important,

411
00:24:57,090 --> 00:25:02,580
比如用户级程序的 nettest ，
and you know for example are whatever nettest in the user level program

412
00:25:03,090 --> 00:25:06,360
运行在用户空间并进行系统调用，
runs in user space and it makes system calls,

413
00:25:06,780 --> 00:25:10,650
系统调用进入网络栈，
system calls go to the network stack,

414
00:25:11,010 --> 00:25:19,120
比如，使用文件描述符调用 write 系统调用，
for example like if you knew calls the write system call with a file descriptor,

415
00:25:19,420 --> 00:25:22,630
内核知道，如果你写入那个文件描述符，
the kernel knows you know for that file descriptor, if you do write,

416
00:25:22,630 --> 00:25:25,360
那么写入会发送到网络栈，
then you know the write should go to the network stack,

417
00:25:25,540 --> 00:25:27,520
网络栈建立数据包，
the network stack builds up the packets,

418
00:25:27,700 --> 00:25:29,260
然后它调用 transmit 。
and then it calls transmit.

419
00:25:30,830 --> 00:25:35,090
然后 transmit 操作发送队列，
And then transmit whatever manipulates the transmission queue,

420
00:25:35,090 --> 00:25:36,530
或 tx 队列或环，
that the tx queue or ring,

421
00:25:36,710 --> 00:25:39,980
它会从网络中收到数据包，
and you know that actually gets packets you know of network,

422
00:25:40,010 --> 00:25:42,590
在某种程度上，响应可能会返回，
at some point a response might go back come back,

423
00:25:42,590 --> 00:25:44,120
那会引起中断，
you know that will generate an interrupt,

424
00:25:44,270 --> 00:25:45,890
然后 recv 函数将运行
and then the recv function will run

425
00:25:45,890 --> 00:25:50,090
并检查接收环。
and inspect you know the receive ring, right.

426
00:25:50,760 --> 00:25:53,010
所以有几样东西，
So there's a couple things that you know wanna,

427
00:25:53,560 --> 00:25:57,460
我想指出的是在并发性方面。
I want to point out you know in terms of concurrency.

428
00:25:58,060 --> 00:26:00,670
所以，首先，中断处理器，
And so, first of all, like the interrupt handler,

429
00:26:00,670 --> 00:26:03,520
可以运行在任何时间，
basically can run at any instant in time, right,

430
00:26:03,520 --> 00:26:05,380
可能是用户空间，
you know you might be user space,

431
00:26:05,380 --> 00:26:06,490
如果出现中断，
and if interrupt comes in

432
00:26:06,520 --> 00:26:09,190
中断机制将导致
you know the interrupt mechanism will cause

433
00:26:09,190 --> 00:26:12,790
当前用户程序切换到内核模式，
you know the current user program to switch to the kernel mode,

434
00:26:12,790 --> 00:26:15,220
你知道 trap 的功能代码，
you know the trap functionality of code,

435
00:26:15,220 --> 00:26:16,330
我们之前已经看到过，
we've seen before it runs,

436
00:26:16,330 --> 00:26:17,770
它将会全部收到。
and it will all received.

437
00:26:17,770 --> 00:26:20,230
我们可能正处于某个用户进程中，
So we might be in the middle of some user process,

438
00:26:20,230 --> 00:26:21,640
我们得到一个中断，
in boom, we get an interrupt

439
00:26:21,640 --> 00:26:23,080
突然我们就进入了 recv 函数。
and suddenly we're in the recv function.

440
00:26:23,900 --> 00:26:24,890
即使在内核中，
And even in the kernel,

441
00:26:24,890 --> 00:26:26,630
如果我们没有持有锁，
like if we're not holding locks,

442
00:26:26,630 --> 00:26:28,070
锁会关闭中断，
you know locks turn interrupts off,

443
00:26:28,070 --> 00:26:29,330
但我们没有持有锁，
but we're not holding locks,

444
00:26:29,330 --> 00:26:30,620
我们可能会被中断，
we could get an interrupt,

445
00:26:30,620 --> 00:26:36,770
内核会将程序计数器改变为中断处理程序，
and the kernel may change the program counter basically to the interrupt handler

446
00:26:36,770 --> 00:26:38,750
并运行 recv 函数。
and run the recv function.

447
00:26:39,560 --> 00:26:42,530
所以这段代码是运行在下半部分的东西，
So this code sort of runs you know the things that in the bottom half,

448
00:26:42,530 --> 00:26:45,200
基本上任何时候都可以立刻运行。
you know can basically run instantly almost anytime.

449
00:26:45,950 --> 00:26:48,560
在上半部分的代码，
In the code, in the top half,

450
00:26:48,650 --> 00:26:53,300
它在用户级进程或内核线程运行，
it really operates on behalf of a user level processes or kernel threads,

451
00:26:53,300 --> 00:26:57,510
调用上半部分（的线程）。
that actually make calls into the top half.

452
00:26:58,080 --> 00:26:59,760
很容易的情况可能是，
You know easily could have been the case,

453
00:27:00,060 --> 00:27:02,160
事实上，即使在 nettest 中，
in fact this is the case even in nettest,

454
00:27:02,160 --> 00:27:07,170
我们可能会对很多进程进行 nettest ，
we might actually have nettest for a whole bunch of processes,

455
00:27:07,470 --> 00:27:10,200
我们有很多实例，其中一个测试，
that we have actually many instances, one of the tests,

456
00:27:10,230 --> 00:27:12,210
我们有很多 nettest 运行的实例，
we have many instances of nettest running,

457
00:27:14,700 --> 00:27:17,190
并且它们都跳到网络栈中，
and they all jump into the network stack,

458
00:27:17,190 --> 00:27:20,370
它们都调用 transmit 。
and they all you know then called transmit, right.

459
00:27:20,820 --> 00:27:21,900
所以情况就是这样，
So that is the case,

460
00:27:21,900 --> 00:27:24,240
所以我们从并发性的角度来看待这个问题，
so we're looking at this from the perspective concurrency,

461
00:27:24,420 --> 00:27:28,020
多个发送者可以位于上下文中，
multiple senders can be actually in the context,

462
00:27:28,020 --> 00:27:29,280
它可以位于上半部分，
it can be in the top half,

463
00:27:29,310 --> 00:27:30,510
所以很明显，
and so it's pretty clear,

464
00:27:30,510 --> 00:27:34,260
我们需要一些锁方案或准则，
you know we need some locking scheme or discipline

465
00:27:34,260 --> 00:27:38,640
至少确保不同的发送者不会被对方绊倒。
to at least make sure that different senders don't trip over each other.

466
00:27:40,380 --> 00:27:41,910
然后在下半部分，
Then on the bottom half,

467
00:27:42,480 --> 00:27:44,970
只有一个中断处理程序，
there's only one interrupt handler, correct,

468
00:27:45,060 --> 00:27:48,360
永远不会有多个接收器同时运行，
there's never in the case that the receive is going to be called by multiple,

469
00:27:48,570 --> 00:27:52,710
多个接收器并行同时运行在不同的核心上，
there's multiple receivers running at the same time in parallel on different cores,

470
00:27:52,710 --> 00:27:57,000
当中断发生时的中断处理程序，
you know the the interrupt handler when an interrupt happens,

471
00:27:57,270 --> 00:27:59,130
进程会发出告警，
the process is alert it,

472
00:27:59,560 --> 00:28:02,260
如果将来发生中断，
and if future interrupts happen,

473
00:28:02,260 --> 00:28:06,610
它们会被阻塞，直到当前中断被处理为止，
they're actually blocked until the current interrupt actually dealt with,

474
00:28:06,820 --> 00:28:11,670
所以事实上，当 recv 函数运行时，
and so in fact, when the recv function runs,

475
00:28:11,910 --> 00:28:15,450
只有一个中断处理程序在运行。
there's actually only one interrupt handler running,

476
00:28:15,450 --> 00:28:18,030
在调用 recv 时。
at the time that calls for recv.

477
00:28:18,760 --> 00:28:24,360
所以，在 recv 本身中并不存在真正的并发，
And so there's no real immediately concurrency in recv itself,

478
00:28:24,360 --> 00:28:31,200
当然 transmit 线程可以与中断处理程序并发运行，
although of course the transmit you know threads can run concurrently with the interrupt handler,

479
00:28:31,200 --> 00:28:34,110
比如，我们可能有一个核心运行中断处理程序，
for example, we might have one core running an interrupt handler,

480
00:28:34,320 --> 00:28:37,950
可能有另一个核心运行 transmit 。
may have another core actually is about to transmit.

481
00:28:39,860 --> 00:28:43,530
对于这个，有什么问题吗？
This, any questions about this?

482
00:28:45,870 --> 00:28:50,540
它是一件很重要的需要理解的事情。
It's sort of important to have, to understand.

483
00:28:51,310 --> 00:28:53,350
这是一点复习，但也很重要。
It's a bit of review but it's important too.

484
00:29:00,400 --> 00:29:01,000
好的，那么。
Okay, so.

485
00:29:01,030 --> 00:29:03,700
我想，我有一个一般性的问题，
I guess, I have a general question,

486
00:29:03,790 --> 00:29:05,020
我们怎么知道，
how do we know,

487
00:29:05,740 --> 00:29:09,760
什么应该被归类为下半部分和上半部分？
what is supposed to be classified as a bottom half and the top half?

488
00:29:10,430 --> 00:29:13,250
是的，我认为考虑这件事的方式是，
So, yeah, I think the way to think about it is that,

489
00:29:13,250 --> 00:29:15,410
在中断处理程序的上下文中运行的任何东西，
anything that runs in the context of an interrupt handler,

490
00:29:15,440 --> 00:29:16,280
都是下半部分，
that's the bottom half,

491
00:29:17,330 --> 00:29:19,370
在这种情况下，就是接收。
and in this case is basically just receive.

492
00:29:20,700 --> 00:29:26,410
而在常规进程或内核线程的上下文中运行的任何东西，
And anything that runs in the context of regular process or thread kernel thread,

493
00:29:26,440 --> 00:29:27,880
就是上半部分。
you know that's the top half.

494
00:29:32,200 --> 00:29:37,720
好的，如果你再仔细看一下这张图片，
Okay, so if you look at this picture a little bit more,

495
00:29:38,080 --> 00:29:38,860
从哪里，
since where,

496
00:29:39,010 --> 00:29:41,770
让我在这里做一个高级别的声明，
actually let me have a high level statement here,

497
00:29:41,920 --> 00:29:45,280
很多人问为什么没有对接收加锁，
a lot of people ask you know why no locking receive,

498
00:29:46,320 --> 00:29:49,620
以及哪里需要加锁。
and where is lock needed.

499
00:29:49,950 --> 00:29:53,070
所以第一眼看上去，
And so the first glance,

500
00:29:53,680 --> 00:29:56,200
它可能不需要加锁，
it might not be necessary to lock if necessary, correct,

501
00:29:56,200 --> 00:29:59,710
因为只有一个正在运行的接收实例，
because there's only one instance of receive running,

502
00:29:59,740 --> 00:30:02,620
没有同时运行多个接收实例，
so there's not multiple instances of receive running at the same time,

503
00:30:02,770 --> 00:30:03,940
所以这些接收，
and so these receives,

504
00:30:03,970 --> 00:30:05,170
因为只有一个接收，
since there's only one receive,

505
00:30:05,200 --> 00:30:07,450
所以它不与任何其他接收共享数据结构，
it doesn't share data structures with any other receive,

506
00:30:07,450 --> 00:30:08,860
因为只有一个。
because there's only one of them, right.

507
00:30:09,380 --> 00:30:10,850
现在，当然可以是这种情况，
Now, of course it could be the case,

508
00:30:10,850 --> 00:30:13,640
接收者和发送者共享数据结构，
that the receiver and the transmitter shared data structures,

509
00:30:13,670 --> 00:30:16,340
但是我们随后会看到，不是这种情况，
but as we see in a second that actually is not the case,

510
00:30:16,860 --> 00:30:20,730
驱动程序的发送部分完全独立于
basically the transmission part of the driver is completely separate from

511
00:30:20,730 --> 00:30:24,900
驱动程序的接收部分，接收数据包。
the reception part of the driver, receiving packets.

512
00:30:25,380 --> 00:30:29,400
所以，接收并不需要真正加锁，
And so as a result, receive doesn't really, doesn't need actually locks,

513
00:30:29,430 --> 00:30:32,700
它并不与任何其他并发活动共享数据结构。
you know it's really not sharing data structures with any other concurrent activity.

514
00:30:34,400 --> 00:30:37,910
奇怪的是，你们中的一些人发现，
Weird part is that you know some of you found out,

515
00:30:37,910 --> 00:30:41,380
如果你使用了锁，会引发 panic 。
if you do use a lock, you actually get a panic.

516
00:30:42,100 --> 00:30:44,470
所以让我简单地说一下，
And so let me say a little bit about that,

517
00:30:44,470 --> 00:30:47,830
因为 panic 发生的原因是，
because the reason that panic happens is,

518
00:30:47,830 --> 00:30:48,790
有一点是因为，
a little bit because there's,

519
00:30:48,790 --> 00:30:54,610
在 xv6 内核中的软件结构
this the software structure actually in in xv6 kernel slightly,

520
00:30:56,740 --> 00:30:58,750
比你想象的要稍微复杂一些，
slightly more complicated than you might think,

521
00:30:58,960 --> 00:31:00,760
原因是，
and the reason is that

522
00:31:00,760 --> 00:31:04,630
接收中断处理程序做了相当多的工作，
basically the receive interrupt handler just quite a bit of work,

523
00:31:05,140 --> 00:31:06,790
或者可以做相当多的工作，
or can do quite a bit of work,

524
00:31:07,090 --> 00:31:08,470
所以让我稍微谈谈这件事。
so let me talk a little bit about it.

525
00:31:09,430 --> 00:31:12,700
在特定的情况下，它做了相当多的工作，
In the particular case that actually does quite a bit of work,

526
00:31:12,700 --> 00:31:16,550
比如， ARP 请求，
for example ARP requests,

527
00:31:20,180 --> 00:31:23,690
ARP 是 Robert 之前谈到的数据包类型之一，
ARP is one of those packet types that Robert talked about a little while ago,

528
00:31:23,990 --> 00:31:26,720
但发生的事情就是中断进来，
but basically what happens like an interrupt comes in,

529
00:31:27,570 --> 00:31:35,700
ARP 请求用来使用 IP 地址发现以太网地址，
so an ARP request for discovery the ethernet addresses where an IP address you know comes in,

530
00:31:35,700 --> 00:31:39,620
它会调用 eth1000_recv ，
you know that will call you know eth1000_recv,

531
00:31:43,400 --> 00:31:46,700
它会调用 net_rx ，
and you know that will call whatever net_rx,

532
00:31:46,700 --> 00:31:51,500
这样就会调用前面图片上的网络栈，
so that will go call into the network stack on the previous pictures,

533
00:31:51,500 --> 00:31:55,280
让接收可以调用进入这里的代码，
so that receives calls into this code over here,

534
00:31:56,460 --> 00:31:59,190
net receive 调用，
net receive you know calls,

535
00:32:03,540 --> 00:32:10,680
糟糕， net receive 调用 net_rx_arp ，
oops,net receive calls net_rx_arp,

536
00:32:12,690 --> 00:32:16,560
而且它查看，这里有一个 ARP 数据包，
and it and you know it looks you know there's an ARP packet,

537
00:32:16,560 --> 00:32:24,000
并且发回 xv6 的以太网地址，
and basically sends back the ethernet address for this particular for xv6,

538
00:32:24,210 --> 00:32:27,270
然后它做的是发送数据包，
and then the way it does that of course you know to send the packet,

539
00:32:27,270 --> 00:32:36,860
它会调用 e1000_transmit ，
it will call you know, e1000_transmit right,

540
00:32:36,860 --> 00:32:40,280
我们知道，这需要获取一把锁，
and you know we know that will actually need to acquire a lock,

541
00:32:42,070 --> 00:32:45,550
你使用 eth1000_lock 来完成它。
well, you did that you know whatever there's eth1000_lock.

542
00:32:50,860 --> 00:32:53,020
这里必须加锁的原因是，
The reason that actually has to go on a lock is,

543
00:32:53,020 --> 00:32:54,910
因为可能有多个发送者，
because there might be multiple senders

544
00:32:54,910 --> 00:32:59,350
发送者不应该被对方[绊倒]。
and you know the senders should not trip over over, trip over each other.

545
00:33:00,440 --> 00:33:02,270
所以这是一张图，
So that's sort of the picture,

546
00:33:02,270 --> 00:33:04,520
所以我们就前一张图片而言，
so what we're basically in terms of this previous picture,

547
00:33:04,520 --> 00:33:05,840
我们在这里看到的是，
what we're seeing here is that,

548
00:33:06,590 --> 00:33:12,770
下半部分可能最终会调用上半部分中的代码，
the bottom half may end up call the code in the top half,

549
00:33:12,950 --> 00:33:16,010
然后从上半部分回到驱动程序。
and come back into the driver through the top half.

550
00:33:17,400 --> 00:33:20,940
你在这里遇到了麻烦，
And a number of you know you run into trouble with that,

551
00:33:20,940 --> 00:33:25,170
因为不是百分之百清楚，
because you know the you know it's not 100% clear,

552
00:33:25,170 --> 00:33:29,610
你不需要在接收部分加锁，
that you didn't need a locks in the receiving part,

553
00:33:29,730 --> 00:33:32,070
所以你们中很多人遇到了这种特殊的 bug ，
and so quite a number of you run into this particular bug,

554
00:33:32,070 --> 00:33:43,700
你在接收中获取了 eth1000_lock 。
where you're actually required the you know eth1000_lock in receive.

555
00:33:45,460 --> 00:33:46,750
这一切都很正常，
And that worked all fine correctly,

556
00:33:46,750 --> 00:33:48,400
只是偶尔你会得到 panic ，
except once in a while you get a panic,

557
00:33:49,670 --> 00:33:51,110
为什么你会得到 panic ，
why do you get the panic,

558
00:33:52,140 --> 00:33:54,060
希望这张图片能让你看得很清楚。
hopefully with this picture, that's pretty clear about.

559
00:33:59,400 --> 00:34:01,590
我是说，这不是同一把锁吗，
I mean, isn't it going to be the same lock,

560
00:34:01,590 --> 00:34:05,280
因为 e1000_transmit 将尝试获取 e1000_lock 。
because that the e1000_transmit is going to try to acquire eth1000_lock.

561
00:34:05,610 --> 00:34:07,020
是的，没错，
Yeah exactly, correct,

562
00:34:07,380 --> 00:34:10,890
所以在这一点上， eth1000 拥有这把锁，
so eth1000 here at this point now owns the lock, holds it,

563
00:34:10,890 --> 00:34:14,280
调用 net_rx ，调用 net_rx_arp ，e1000_transmit ，
calls net_rx, calls net_rx_arp, e1000_transmit,

564
00:34:14,280 --> 00:34:15,420
然后再次调用获取，
then calls acquire again,

565
00:34:15,780 --> 00:34:17,760
你们可能还记得以前的实验，
and as you might remember from previous labs,

566
00:34:17,940 --> 00:34:21,240
如果叫它调用获取已经持有的，
if require it's called it's already held,

567
00:34:21,610 --> 00:34:23,440
这会是个死锁，
that's a deadlock right,

568
00:34:23,440 --> 00:34:25,600
所以 xv6 内核出现了 panic 。
and so xv6 kernel panics.

569
00:34:28,240 --> 00:34:32,620
问题，假设我们的锁实现略有不同，
Question, let's let's assume we had a slightly different implementation of locks,

570
00:34:32,620 --> 00:34:34,630
比如那些函数没有发生，
such as those functions are not occur,

571
00:34:35,480 --> 00:34:37,220
比如，它将，
like it would such,

572
00:34:37,400 --> 00:34:40,010
假设，如果我想获得已经持有的锁，
let's assume like if I wanted to acquire a lock already held,

573
00:34:40,010 --> 00:34:40,820
而且什么都没有发生。
nothing happened.

574
00:34:41,060 --> 00:34:45,110
是的，这就是所谓的递归锁，
Yeah so, these are these are called recursive locks,

575
00:34:47,660 --> 00:34:50,750
或者另一种名称是可重入锁。
or reentrant locks is another way the name for them.

576
00:34:51,580 --> 00:34:54,460
所以如果你有一个递归锁，可重入锁，
And so if you have a recursive locks, reentrant locks,

577
00:34:54,460 --> 00:34:56,530
然后你可以自由地做这件事，
then you know you could freely do this

578
00:34:56,530 --> 00:34:57,520
它不会有问题。
and it would be no problem.

579
00:34:58,170 --> 00:35:01,890
我想你们中的一位在电子邮件中提到，
And I think one of you over email mentioned to me,

580
00:35:01,890 --> 00:35:05,970
实现递归锁才能真正解决这个问题。
that actually the implemented recursive locks to actually deal with this particular problem.

581
00:35:06,660 --> 00:35:11,100
所以他们在 eth1000_recv 函数中获取锁，
And so they did required to lock in the eth1000_recv function,

582
00:35:11,370 --> 00:35:14,010
在 panic 之后，
and you know after the panic,

583
00:35:14,010 --> 00:35:16,770
修复在 xv6 中的获取和释放，
basically fixed acquire release in the xv6

584
00:35:16,770 --> 00:35:18,720
通过支持递归锁。
[direction] support recursive locks.

585
00:35:20,760 --> 00:35:21,810
这也是一个解决方案。
And that would be a solution.

586
00:35:23,240 --> 00:35:25,820
一个简单的解决方案，
The simple solution, it's a fine solution,

587
00:35:25,880 --> 00:35:31,970
我们计划的和工作人员的解决方案是，
the solution that we intended and the staff solution as is

588
00:35:31,970 --> 00:35:35,120
根本不需要在接收中获取锁，
basically just doesn't require locks in receive at all,

589
00:35:35,120 --> 00:35:37,100
因为这是没有必要的。
because it actually turned out not to be necessary.

590
00:35:39,910 --> 00:35:41,110
对不起，你能再说一遍吗，
Sorry, can you say again,

591
00:35:41,110 --> 00:35:45,070
为什么在接收中不能有两个线程？
why there couldn't be two threads in receive?

592
00:35:46,550 --> 00:35:49,310
在接收中只有一个线程，即运行中断处理程序，
There's only one thread in receive, the interrupt handler runs,

593
00:35:49,930 --> 00:35:53,200
在任何内核上，一次只有一个接收函数在运行，
there's only one receive function ever running at the time on any core,

594
00:35:54,110 --> 00:36:00,770
它会调用操作系统的上半部分，
that actually calls into the top half of the, the top half of the operating system

595
00:36:01,160 --> 00:36:04,280
然后调用回到下半部分，
and that calles back out into the bottom half,

596
00:36:05,180 --> 00:36:07,940
抱歉，不在下半部分，调用回到 e1000_transmit ，
sorry,not in the bottom, that calls back into e1000_transmit

597
00:36:07,940 --> 00:36:09,980
而 transmit 肯定需要获取锁，
and transmit definitely needs to acquire a lock,

598
00:36:10,430 --> 00:36:16,840
所以，即使 eth1000_recv 在持有锁的同时调用 e1000_transmit ，
so even receive, eth1000_recv, while holding the lock calls e1000_transmit,

599
00:36:16,900 --> 00:36:20,650
e1000_transmit 尝试获取中断处理程序已经持有的相同的锁，
which tries to acquire the same lock that the interrupt handler already holds,

600
00:36:21,600 --> 00:36:25,080
如果你在接收处理程序中持有锁。
if you have, if you locked in receive handler.

601
00:36:26,830 --> 00:36:30,270
我明白了，所以是这样的，
I see, so so it is the case,

602
00:36:30,270 --> 00:36:33,060
比如一次中断会发生，
like one interrupt can go off

603
00:36:33,060 --> 00:36:36,270
然后，当它还在运行时，
and then while it's still running,

604
00:36:36,390 --> 00:36:39,510
另一个中断可能也会发生。
another interrupt could go off as well, is.

605
00:36:39,510 --> 00:36:42,870
不，不是，那张图片，也许可以回到这张图片上，
No, no, the picture, maybe go back to this picture,

606
00:36:43,170 --> 00:36:46,370
所以中断发生了，它调用接收函数，
so interrupt happens, that calls the receive function,

607
00:36:46,760 --> 00:36:48,500
这里只有一个接收函数运行，
there's only one receive function running,

608
00:36:48,620 --> 00:36:53,390
接收函数调用 rx net receive ，
that receive function calls you know rx net receive,

609
00:36:53,390 --> 00:36:55,220
它调用 net_rx_arp ，
that calls rx net_rx_arp,

610
00:36:55,430 --> 00:36:58,040
那个 arp 函数调用 transmit ，
and that arp function calls transmit,

611
00:36:58,740 --> 00:37:02,460
如果你在发送和接收中使用相同的锁，
and if you were using the same lock in transmit and receive,

612
00:37:02,580 --> 00:37:03,870
你会陷入死锁。
you know you would get a deadlock.

613
00:37:08,100 --> 00:37:09,600
好的，我明白了，谢谢。
Okay I see, thank you.

614
00:37:13,660 --> 00:37:14,710
有点像是，好的，
That's sort of, yeah, okay,

615
00:37:15,540 --> 00:37:17,430
所以基本上有两种解决方案，
and so basically the two solutions to this,

616
00:37:17,460 --> 00:37:19,440
一种是使用递归锁，
one is to use recursive locks,

617
00:37:20,370 --> 00:37:24,560
另一种解决方案是不在接收中使用锁，
other solution was no locks in receive,

618
00:37:25,790 --> 00:37:27,740
或者使用两把锁。
or you know have two locks.

619
00:37:31,040 --> 00:37:33,260
这三个都是完全合理的解决方案。
All three of them are totally reasonable solutions.

620
00:37:37,000 --> 00:37:38,050
对于这个，有什么问题吗？
Any questions about this?

621
00:37:39,070 --> 00:37:42,610
会不会有理由在接收周围加锁呢？
Would there be a reason to have a lock around receive at all?

622
00:37:42,910 --> 00:37:44,770
不，在这种情况下，
No, in this particular case,

623
00:37:44,770 --> 00:37:46,360
根本没有理由加锁。
there's no reason to have a lock at all.

624
00:37:49,540 --> 00:37:52,570
我们能想出这样一种情况，
What would be, could we think of a situation

625
00:37:52,570 --> 00:37:54,490
如果你想要一个接收锁，
where you would want a receive lock,

626
00:37:54,490 --> 00:37:57,970
比如你有两块网卡之类的。
would be like if you had two network cards or something.

627
00:37:58,550 --> 00:38:03,620
是的，如果你还记得 UART 代码，
Yeah, or if you like if you remember in the UART code,

628
00:38:03,980 --> 00:38:10,760
好的，你可能想要锁的一个常见原因是，
okay, so may a common reason why you might want to have a locking shared is,

629
00:38:10,760 --> 00:38:15,020
因为下半部分和上半部分共享了数据结构。
because the bottom half and the top half shared data structures.

630
00:38:17,200 --> 00:38:21,850
所以，比如，接收和发送可能操作相同的共享数据结构，
So, for example the receive and transmit might manipulate the same shared data structures,

631
00:38:22,090 --> 00:38:24,100
在这一点上，你需要一把锁，
at that point you need you need a lock,

632
00:38:24,160 --> 00:38:26,560
比如，你记得在控制台驱动程序中，
and so for example you remember from your console driver,

633
00:38:27,060 --> 00:38:28,320
它们共享一个队列，
they shared a queue,

634
00:38:29,100 --> 00:38:32,970
所以接收处理程序需要获得队列，
and so receive handler needed to get queue,

635
00:38:33,120 --> 00:38:35,550
需要获取锁才能访问那个队列。
need to get the lock to actually get access to that queue.

636
00:38:39,480 --> 00:38:40,680
这回答了你的问题吗？
Does that answer your question?

637
00:38:42,500 --> 00:38:43,580
是的，谢谢。
Yeah, thanks.

638
00:38:44,720 --> 00:38:47,510
这就引出了我想提出的第二点。
And so this brings me up with a second sort of point I wanted to make.

639
00:38:48,230 --> 00:38:52,700
让我画一幅新图，
That the let me actually draw a new picture,

640
00:38:52,700 --> 00:38:53,930
因为它有点拥挤。
because it gets a little crowded.

641
00:38:54,350 --> 00:38:57,740
我们再次考虑下半部分和上半部分。
We think about this bottom half again, and the top half.

642
00:39:00,670 --> 00:39:01,450
所以，这是下半部分，
So here's the bottom,

643
00:39:01,450 --> 00:39:04,390
有点抽象，但是它可能会有帮助。
a little bit abstract, but you know it may be helpful.

644
00:39:07,110 --> 00:39:11,610
在多数驱动程序软件中，
In much typically in much software, driver software,

645
00:39:11,640 --> 00:39:16,560
下半部分基本上不会真正进入上半部分。
the bottom half basically doesn't really call into the top half at all.

646
00:39:17,360 --> 00:39:20,870
所以，如果你返回并查看控制台代码，
So, for example if you go back and you look at the console code,

647
00:39:21,080 --> 00:39:24,500
这个序列不可能在那里发生，
this sequence of the sequence cannot happen there,

648
00:39:24,530 --> 00:39:25,880
而没有发生的原因是，
and the reason doesn't happen is,

649
00:39:25,880 --> 00:39:28,310
因为下半部分通常做的工作很少，
because the bottom half typically does very little work,

650
00:39:28,550 --> 00:39:30,890
它唯一能做的就是抓到包，
the only thing it does maybe you grab the packet,

651
00:39:31,100 --> 00:39:32,330
把包放在队列里。
stick the packet in the queue.

652
00:39:34,000 --> 00:39:35,560
然后，在后来的某个时候，
And then, at some point later,

653
00:39:35,680 --> 00:39:40,980
在上半部分有一个单独的线程，
you know the the top half, you know there's a separate thread in the top half,

654
00:39:40,980 --> 00:39:43,590
它查看那个队列，然后从队列中抓取数据包，
that basically looks at that queue and then grabs packets out of the queue,

655
00:39:43,590 --> 00:39:45,570
然后继续做任何需要做的事。
and then keeps on doing whatever needs to be done.

656
00:39:46,400 --> 00:39:51,650
现在，在这一简单性并减少的代码里，
Now, for simplicity a in this simplicity and reduce the amount of code,

657
00:39:51,860 --> 00:39:54,620
这不是这些特殊的驱动程序遵循的结构，
that is not the structure that these particular driver follows,

658
00:39:54,830 --> 00:39:58,800
这个驱动可能偶尔会调用，
this driver once in a while may actually call up in,

659
00:39:58,800 --> 00:40:02,840
有时驱动遵循这个结构，
call up actually sometimes this structure is followed by the driver,

660
00:40:02,840 --> 00:40:05,690
但偶尔，它可以进入上半部分
but once in awhile, it can actually go into the top half

661
00:40:05,780 --> 00:40:07,970
然后回到下半部分。
and come back out into the bottom half.

662
00:40:15,210 --> 00:40:16,140
对此有什么问题吗？
Any questions about this?

663
00:40:23,120 --> 00:40:27,500
好的，我想这是某种程度上的软件并发性，
Okay, so that's sort of I guess software concurrency

664
00:40:27,500 --> 00:40:28,970
稍后我们会回到更多的话题，
and we'll come back to a little more later,

665
00:40:28,970 --> 00:40:30,920
如果我们更详细地看一下代码，
if we look at the code in a bit more detail,

666
00:40:31,440 --> 00:40:33,570
稍微谈一下关于环的事。
talk a little bit about the rings.

667
00:40:37,540 --> 00:40:39,640
所以基本上就像你想的那样，
And so basically the way you think about it,

668
00:40:39,640 --> 00:40:42,670
这里有环，
you know there ring,

669
00:40:42,880 --> 00:40:47,260
有两个环，一个用于接收，一个用于发送，
there's two rings and one for receiving and one for sending,

670
00:40:47,260 --> 00:40:51,790
tx tx 都在 RAM 里。
you know tx rx both lives in RAM.

671
00:40:52,510 --> 00:40:58,600
它们是由运行在 RISC-V 核心上的代码操作的，
And you know they're manipulated by code running on the RISC-V cores

672
00:40:58,600 --> 00:41:01,030
以及网卡本身。
and by you know the network card itself.

673
00:41:01,710 --> 00:41:03,060
所以有某种协议，
So there has to be some protocol

674
00:41:03,060 --> 00:41:07,380
在网卡和 RISC-V 之间，
between the network card and the RISC-V of course,

675
00:41:07,410 --> 00:41:09,780
关于谁可以查看什么，
about who gets to look at what,

676
00:41:10,020 --> 00:41:15,270
所以，这是硬件设备中非常常见的组织方式，
and so the way this is a very common organization in hardware devices,

677
00:41:15,270 --> 00:41:16,680
通常的做法是，
the way that typically is done,

678
00:41:16,680 --> 00:41:18,690
在某种程度上，看看传输队列，
there's sort of, look at the transmit queue,

679
00:41:18,690 --> 00:41:21,930
有一些固定大小的结构描述符的队列，
there's basically a queue of some fixed size structures descriptors,

680
00:41:21,960 --> 00:41:23,790
我们马上就会看到，
as we'll looking in a second,

681
00:41:24,060 --> 00:41:25,230
这些是描述符。
these are the descriptors.

682
00:41:29,360 --> 00:41:33,320
组织或协调，
And the organization or the coordination that is actually

683
00:41:33,320 --> 00:41:39,260
发生在驱动程序和网卡之间的是，
that's happening between the driver and network card is

684
00:41:39,260 --> 00:41:46,140
消费者与生产者的协调。
the consumer producer coordination.

685
00:41:47,430 --> 00:41:49,350
可以用一种方式来考虑，
Basically, one way to think about it,

686
00:41:49,350 --> 00:41:52,470
如果这是传输队列，
you know there is if this is the transmit queue,

687
00:41:52,470 --> 00:41:54,450
也许这里有个头指针，
you know there's maybe there's a head pointer,

688
00:41:56,520 --> 00:41:57,840
这里有一个尾指针，
there's a tail pointer,

689
00:42:00,440 --> 00:42:04,400
尾指针是由软件控制的，
and you know this the tail pointer is controlled by the software,

690
00:42:05,580 --> 00:42:07,590
所以软件会查看尾指针，
and so the software looks at the tail pointer,

691
00:42:07,590 --> 00:42:10,650
它想发送另一个数据包，
and it wants to send, send another packet,

692
00:42:10,650 --> 00:42:14,910
把它放在在环里尾指针加 1 的位置，
sticks it you know in a the ring at the location of tail plus one,

693
00:42:14,910 --> 00:42:17,400
然后把尾指针向那个方向移动。
and then moves up tail pointer in that direction.

694
00:42:19,240 --> 00:42:22,330
而头指针通常由硬件控制。
And the head pointer is usually controlled by the hardware.

695
00:42:24,750 --> 00:42:27,030
所以尾由软件控制，头由硬件控制，
So tail by software, head by hardware

696
00:42:27,030 --> 00:42:29,820
基本上，硬件查看头指针，
and basically the you know the hardware basically looks at the head,

697
00:42:29,820 --> 00:42:31,980
这里第一个数据包是要发送的，
and this is the first packet that is going to be sent,

698
00:42:32,040 --> 00:42:34,530
在描述符里有一些信息，
you know there's a little bit of information in the descriptor,

699
00:42:34,680 --> 00:42:38,310
或者描述符有网卡要查看的足够多的信息，
or enough information that descriptor for the network card to look at,

700
00:42:38,310 --> 00:42:43,770
比如，这是我要移动到电缆的字节。
and say like oh this is the bytes that I need to move on to the move on to the cable.

701
00:42:44,950 --> 00:42:48,670
一旦完成，它就会将头指针朝那个方向移动，
And once it's done, it moves the head pointer in that direction,

702
00:42:48,790 --> 00:42:52,630
一旦它使用传输队列中的一个数据包。
once it's consumed you know one of the packets out of the transmission queue.

703
00:42:53,630 --> 00:42:55,160
考虑这个问题的一种方式是，
And one way to think about it is that,

704
00:42:55,430 --> 00:43:01,400
所以在这里和尾之间的所有描述符，
all the descriptors between here, between the tail,

705
00:43:02,540 --> 00:43:05,240
所以填入的所有东西，
and so all the things that are actually being filled in,

706
00:43:05,720 --> 00:43:08,930
比如尾指针移动到了这里。
like the tail moved up maybe to here.

707
00:43:12,540 --> 00:43:13,290
所以数据包，
You know all the packets,

708
00:43:13,290 --> 00:43:16,200
作为填充的所有描述符条目，
that are all the descriptor entries that are actually filled in,

709
00:43:16,260 --> 00:43:17,880
你考虑它们的方法是，
the way you think about them is,

710
00:43:18,640 --> 00:43:21,190
它们属于网卡硬件。
they are owned by the hardware owned by the network card.

711
00:43:21,810 --> 00:43:25,230
网卡允许读取它们，用它们做事情，
The network card is allowed to read them, do things with them,

712
00:43:25,350 --> 00:43:29,580
但是软件不允许对它们做任何事情，
but the software and the software is not allowed to do anything with that,

713
00:43:29,760 --> 00:43:33,780
如果软件在这些描述符上[乱涂乱画]，
like if the software would be scribbling over these descriptors,

714
00:43:34,080 --> 00:43:38,880
它们在某种程度上是由网卡拥有的，
while they really sort of owned by the hardware by network card,

715
00:43:39,000 --> 00:43:42,240
这将改变网卡看到的数据，
that would change the data that the network card sees,

716
00:43:42,240 --> 00:43:43,800
这将是非常不想看到的。
and that would be pretty undesirable.

717
00:43:44,460 --> 00:43:47,550
所以，协议基本上是，
And so, the protocol basically is

718
00:43:47,550 --> 00:43:50,880
就像软件将尾指针向上移动了一个，
that like once you know the software moves the tail pointer one up,

719
00:43:51,060 --> 00:43:56,100
然后你刚刚移动的点会到网络传输队列中，
then you know that point you have just moved into the network queue in the transmission queue

720
00:43:56,130 --> 00:43:57,450
现在归硬件所有，
is now owned by the hardware,

721
00:43:57,780 --> 00:43:58,950
它会在，
and it will stick in,

722
00:43:58,950 --> 00:44:03,090
它将归硬件所有，直到它必须被发送出去，
you know it will be owned by the hardware until it has to be sent,

723
00:44:03,210 --> 00:44:07,140
直到头指针移动过那个特定的结构。
and basically until the head pointer moves past you know that particular structure.

724
00:44:09,890 --> 00:44:10,760
这能理解吗？
Does that make sense?

725
00:44:18,950 --> 00:44:21,380
很好，对于传输来说，也是一样的故事，
Good, for transmission, basically it's the same story,

726
00:44:21,410 --> 00:44:24,230
有一个头指针，
you know there's a there's a head pointer,

727
00:44:24,880 --> 00:44:30,740
它是由硬件控制的，
that basically that's controlled by the hardware,

728
00:44:30,770 --> 00:44:32,150
这里有一个尾指针，
and there's a tail pointer,

729
00:44:32,150 --> 00:44:35,800
它是由软件控制的，
that is controlled by, there is the software pointer,

730
00:44:37,340 --> 00:44:39,710
在两者之间的数据包
and basically the packets in between

731
00:44:40,840 --> 00:44:47,920
是硬件已接收到的数据包，
are are packets are actually have been received by the hardware,

732
00:44:47,920 --> 00:44:53,110
通过期待尾指针，
and and you know by expecting the tail pointer,

733
00:44:53,110 --> 00:44:55,180
软件可以查看是否真的有新的数据包，
and the software can see if there's actually a new packet,

734
00:44:55,180 --> 00:44:57,850
它已经准备好可以使用了，
you know that is ready to be consumed,

735
00:44:57,850 --> 00:44:59,440
如果它已准备好可以使用，
and if that ready to be consumed,

736
00:44:59,440 --> 00:45:02,950
硬件将通过在状态字段中声明 DD 位来表示。
the hardware will indicate that by saying that DD bit in the status field.

737
00:45:03,440 --> 00:45:05,210
因此当设置 DD 位时，
And so when the DD bit is set,

738
00:45:05,270 --> 00:45:06,740
硬件和软件都是好的，
hardware software are good,

739
00:45:06,770 --> 00:45:09,200
这些数据包，硬件已经完成了，
you know these packets, you know the hardware is done with it,

740
00:45:09,530 --> 00:45:13,220
所以可以把它拿出来，把尾指针向上移动一个。
and so it can take it out and move the tail pointer one up.

741
00:45:14,920 --> 00:45:21,700
所以，在驱动程序和硬件之间存在某种的收发，
And so there's sort of this give and take between driver and our hardware

742
00:45:21,730 --> 00:45:24,880
为了协调它们不会被对方[绊倒]。
to actually coordinate they don't trip over each other.

743
00:45:27,340 --> 00:45:31,840
关于环，有什么问题吗？
Any questions about the rings?

744
00:45:36,200 --> 00:45:36,920
这是不是，
Is this like,

745
00:45:36,980 --> 00:45:41,810
这是不是一种普遍的实现方式，
is this a universal way to kind of implement,

746
00:45:41,810 --> 00:45:45,680
比如用户或具有共享内存的两个东西之间的通信？
like user or any kind of communication between two things that have shared memory?

747
00:45:46,270 --> 00:45:49,090
是的，这当然是在软件中，
Yeah, it's a pretty certainly also in software, you see this,

748
00:45:49,090 --> 00:45:51,880
但是很多硬件设备也使用这种技巧，
but many hardware devices play this sort of trick,

749
00:45:52,510 --> 00:46:00,250
在硬件和软件之间进行生产者和消费者风格的协调。
where going to producer consumer style coordination between the hardware and software.

750
00:46:05,350 --> 00:46:06,820
所以，是的，它是非常常见的结构。
So yeah, it's a very common structure.

751
00:46:08,430 --> 00:46:11,250
也许你可以问一两个问题，
Maybe one or two questions, you can ask about it,

752
00:46:11,460 --> 00:46:14,280
比如为什么是队列，为什么是环。
like why is there actually even a queue, why is there a ring.

753
00:46:14,910 --> 00:46:16,410
好的，这里有一个环，
Okay, the reason there's a ring correct,

754
00:46:16,410 --> 00:46:20,250
因为队列环绕使其大小固定，
because the queue wraps around, queue wraps around to make it fix size,

755
00:46:21,590 --> 00:46:25,730
但是为什么不让队列一个条目，
but you know, why, why not, you know have queue one entry, one entry,

756
00:46:27,900 --> 00:46:29,190
就像 UART 一样，
like it's almost like the UART,

757
00:46:29,550 --> 00:46:32,550
你还记得 UART 驱动程序和控制器
you remember the UART driver and controller

758
00:46:32,550 --> 00:46:35,670
只有一个寄存器发送一个字节，
is basically only one register to send a byte

759
00:46:35,670 --> 00:46:37,230
另一个寄存器接收一个字节。
and there's another register receive a byte.

760
00:46:38,880 --> 00:46:42,450
那么，为什么要选择这个复杂的方案，
And so why have, why go for this complicated scheme,

761
00:46:42,450 --> 00:46:44,250
你可以只使用一个寄存器，
you could have yourself a single register,

762
00:46:44,250 --> 00:46:47,040
然后你可以告诉硬件，
and then you can basically say you know hardware,

763
00:46:47,040 --> 00:46:48,690
这个寄存器现在已经准备好了，发送它，
this register is now ready, send it,

764
00:46:49,390 --> 00:46:52,500
然后你就等这件事完成。
and then you just wait until the it's done.

765
00:46:55,300 --> 00:46:59,950
为了允许在有数据包突发时使用。
To allow for when there are bursts of packets.

766
00:47:00,480 --> 00:47:02,530
是的，就是这样，
Yeah, yeah exactly,

767
00:47:02,860 --> 00:47:07,750
网卡或电缆的网络接口性能非常高，
you know the network interface where the network card or cable is pretty high performance,

768
00:47:07,750 --> 00:47:10,630
性能非常高，每秒千兆。
in fact very high performance, gigabits per second.

769
00:47:11,310 --> 00:47:14,910
所以，这对核心来说可能很困难，
And so, it can be hard for the core,

770
00:47:14,910 --> 00:47:16,260
处理器跟上它，
the processors actually keep up with it,

771
00:47:16,290 --> 00:47:18,660
所以你想给它一大堆数据包，
so you would like to give it a whole bunch of packets,

772
00:47:18,660 --> 00:47:21,030
网络或网卡[块]，
you know the networks or network card chunk along

773
00:47:21,030 --> 00:47:22,740
把它们高速发送出去。
and all send them out at high speed.

774
00:47:23,280 --> 00:47:26,880
类似地，在接收中，你可能会收到突发的数据包进来，
And similarly you know in reception you might get a burst of packets coming in

775
00:47:27,270 --> 00:47:29,370
你想把它们放在队列里，
and you want to place them in the queue

776
00:47:29,370 --> 00:47:33,710
然后操作系统开始处理队列。
and then the operating system can start processing the queue, right.

777
00:47:35,090 --> 00:47:36,830
所以这是一种常见的，
And so this is a common,

778
00:47:39,270 --> 00:47:45,010
这就是原因，这些队列通常用于处理突发。
this is the reason, that these queues are common to handle bursts.

779
00:47:48,910 --> 00:47:51,700
如果队列满了怎么办，比如接收。
What happens if the queue is full, like reception.

780
00:47:58,950 --> 00:48:02,610
我想文件提到了，
I think the the document mentioned that,

781
00:48:02,610 --> 00:48:05,790
它做了某种形式的丢弃尾的方案。
it does some form of drop tail scheme.

782
00:48:06,810 --> 00:48:10,290
是的，基本上数据包会被丢弃。
Yeah, there, yeah, basically the packets get dropped.

783
00:48:11,170 --> 00:48:13,420
所以，任何未来传入的数据包，
So any future incoming packets,

784
00:48:13,420 --> 00:48:17,230
如果队列已满，环里没有地方了，
if the queue is full, the packets or there's no room anymore in the ring,

785
00:48:17,230 --> 00:48:19,390
网卡不能对它们执行任何操作，
the network card can't do anything with that, correct,

786
00:48:19,390 --> 00:48:23,830
所以它唯一能做的就是删除数据包，
and so the only option it actually has to basically delete the packet

787
00:48:23,860 --> 00:48:26,930
或者没有添加到环中，因此消失。
or not added to the ring and therefore disappears.

788
00:48:27,890 --> 00:48:30,560
所以，有时这是丢包的一个原因，
So, one reason you know packet loss, sometimes is that,

789
00:48:31,170 --> 00:48:33,660
并且操作系统过载，
and operating system is overloaded,

790
00:48:33,690 --> 00:48:36,330
数据包跟不上，环被填满了，
you know with packet can't keep up and the ring fills

791
00:48:36,540 --> 00:48:38,670
然后数据包会被丢弃。
and then you know the packets get dropped.

792
00:48:41,110 --> 00:48:42,130
更高级的软件，
You know higher level software,

793
00:48:42,130 --> 00:48:46,840
比如 TCP 连接可能会重新传输这些数据包，
of course maybe like TCP connection might re-transmit those packets,

794
00:48:47,110 --> 00:48:49,660
但这是数据包可能被丢弃的原因之一。
but this is one reason why packets can get dropped.

795
00:48:52,730 --> 00:48:56,030
所以即使硬件运行得很好，
So even if the hardware sort of works all perfectly fine,

796
00:48:56,150 --> 00:48:57,830
由于这些突发，
you know because of these bursts

797
00:48:57,830 --> 00:48:59,870
一些数据包可能会被删除。
you know it can happen that some packets might get dropped.

798
00:49:01,240 --> 00:49:02,920
所以，你有一个非常大的突发。
So you had a really really big burst.

799
00:49:07,010 --> 00:49:10,010
头指针和尾指针，
The head and tail pointers,

800
00:49:10,010 --> 00:49:12,560
它们都是队列的软件抽象吧？
they're all software abstractions, right, of the queue?

801
00:49:13,160 --> 00:49:15,740
好的，这些是，
Okay, so these are actually turns out that

802
00:49:15,740 --> 00:49:18,320
这些是控制寄存器，
those are these control registers, right,

803
00:49:18,320 --> 00:49:22,370
所以有一个用于头指针的控制寄存器，
so there's a control register for the hardware, the header pointer is,

804
00:49:22,370 --> 00:49:25,970
有一个用于尾指针的控制寄存器，
a control register for the basically the tail pointers,

805
00:49:26,060 --> 00:49:28,010
硬件和软件之间没有真正的区分，
there's no real distinction between hardware software,

806
00:49:28,010 --> 00:49:30,110
基本上驱动知道尾指针，
basically the driver knows about the tail pointer,

807
00:49:30,110 --> 00:49:35,490
并且硬件知道尾指针和头指针，
and it knows about the hardware knows about the tail pointer and header pointer

808
00:49:35,520 --> 00:49:37,050
并使用基本的控制寄存器。
and use a basic control registers.

809
00:49:37,720 --> 00:49:38,410
好的，好的。
Okay yeah.

810
00:49:39,070 --> 00:49:40,300
我们稍后会看代码，
We will see the code in seconds,

811
00:49:40,300 --> 00:49:41,260
它是如何出现的，
how did that shows up,

812
00:49:42,810 --> 00:49:44,280
确保如果你回到，
make sure if you go back to our,

813
00:49:44,610 --> 00:49:48,420
让我们看看这张图片还在这里，
maybe let's see this picture still here,

814
00:49:48,840 --> 00:49:51,210
这是我们之前看过的那张图片，
here's that earlier picture we looked at,

815
00:49:51,540 --> 00:49:54,660
这是一个控制寄存器，持有头指针，
and you know here's control register that holds the head,

816
00:49:54,780 --> 00:49:57,060
这是持有尾指针的控制寄存器，
here's control register that holds the tail,

817
00:49:57,060 --> 00:50:00,480
当然还有一个是接收的，一个是发送的。
and of course there's one for both reception and one for sending.

818
00:50:04,300 --> 00:50:04,930
好的?
Okay?

819
00:50:08,810 --> 00:50:10,280
我们回到这里。
Let's go back here.

820
00:50:11,290 --> 00:50:14,140
好的，我们来谈谈描述符。
Okay, so let's talk a little bit about the descriptors.

821
00:50:15,250 --> 00:50:18,310
所以描述符由硬件定义的，
And so the descriptors are defined by the hardware

822
00:50:18,730 --> 00:50:20,140
所以硬件表示，
and so the hardware says

823
00:50:20,140 --> 00:50:22,240
这是描述符应该是什么样子，
like here's how the descriptors should look like,

824
00:50:22,240 --> 00:50:25,660
而你的驱动，这些是可以填入的位，
and your driver you know these are the bits you can fill in,

825
00:50:25,660 --> 00:50:28,930
如果你填入那个位，告诉我。
and if you fill in that bit that tells me to follow, right.

826
00:50:29,270 --> 00:50:34,350
所以这里有两个描述符很重要，
And so here's the two descriptors are important,

827
00:50:34,380 --> 00:50:40,160
这是接收描述符 rx ，
you know, here's the receive descriptor rx,

828
00:50:40,160 --> 00:50:42,680
这是 tx 描述符。
and here's a tx, one of the tx descriptors.

829
00:50:43,380 --> 00:50:45,960
所以让我们稍微看一下。
And so let's look a little bit.

830
00:50:46,600 --> 00:50:48,370
是的，它是，
Yeah, it's a little bit,

831
00:50:48,820 --> 00:50:52,990
可能最重要的部分是这个地址，
probably the most important part is this address,

832
00:50:53,530 --> 00:50:56,560
这就是软件填写的地址，
and that is the address that the software filled in

833
00:50:56,560 --> 00:51:00,370
说明硬件应该将数据包转存到哪里，
to say where they should where the hardware to dump the packet,

834
00:51:00,490 --> 00:51:04,690
在 RAM 的什么地方，
where in RAM to the driver,

835
00:51:04,930 --> 00:51:09,100
网卡应该把接收到的数据放到 RAM 的什么地方，
where should the network card put the data that is received into RAM,

836
00:51:09,220 --> 00:51:12,460
所以，它是接收缓冲区的地址。
so it's the address of the reception buffer, if you will.

837
00:51:17,080 --> 00:51:20,500
然后可能最重要的部分是
And then you know probably the most important part in

838
00:51:20,560 --> 00:51:23,470
是你已经看到的 status 字段。
is the status field as you've seen.

839
00:51:24,020 --> 00:51:28,370
所以当驱动还在继续查看尾指针的时候，
So when the driver basically still continues to look sort of at the tail

840
00:51:28,430 --> 00:51:31,460
看到收到了一个新的数据包，
and sees that there's a new packet has been received

841
00:51:31,670 --> 00:51:34,490
它判断是否接收到新数据包的方式是，
and the way it tells whether a new packet received is,

842
00:51:34,670 --> 00:51:39,450
是 DD 位，是由硬件设置的。
is that the DD bit, correct, is set by the hardware.

843
00:51:40,540 --> 00:51:47,290
阴影区域是数据包描述符的字段，
And you know the shaded areas are the fields of the packet descriptor of the,

844
00:51:47,920 --> 00:51:50,890
接收描述符是硬件填入的，
receive descriptor actually the hardware fills in,

845
00:51:51,010 --> 00:51:53,620
白色的未加阴影的是
and the white you know the non shaded ones

846
00:51:53,620 --> 00:51:56,860
由软件填入的加阴影的字段，
are the fields that actually shaded in are filled in by the software,

847
00:51:57,100 --> 00:51:59,470
我们在这里看到了明显区别，
again here we see this clear distinction about,

848
00:51:59,680 --> 00:52:01,240
一些归软件所有，
somethings are owned by software,

849
00:52:01,270 --> 00:52:05,690
一些归硬件所有。
somethings are owned by by the hardware.

850
00:52:08,760 --> 00:52:13,290
好的，还有一个类似的描述符，
Okay, and there's a similar you know descriptor,

851
00:52:13,290 --> 00:52:14,760
非常简单的描述符，
very simple descriptor that looks,

852
00:52:15,150 --> 00:52:18,060
是传输的硬件描述符，
that's a hardware descriptor for the transmission,

853
00:52:18,300 --> 00:52:19,920
它有一个地址，
it has an address,

854
00:52:19,980 --> 00:52:21,210
这个地址当然是
the address of course is

855
00:52:21,210 --> 00:52:25,590
需要发送的数据在内存中的地址。
the address where the data is in memory that needs to be sent.

856
00:52:26,000 --> 00:52:28,460
然后它有一个 command 字段，
And then it has a bunch of, has a command field,

857
00:52:29,160 --> 00:52:32,610
这是软件告诉驱动，告诉网卡，
and here's how the software tells the driver tells the network card,

858
00:52:32,670 --> 00:52:34,740
这是你应该对数据包执行的操作，
this is what you should do with this particular packet

859
00:52:34,740 --> 00:52:37,470
或者这是你应该知道的关于这个数据包的信息。
or you know this is what you should know about this particular packet.

860
00:52:38,290 --> 00:52:39,760
所以有一件事，
And so one thing,

861
00:52:40,000 --> 00:52:42,370
我想我们填入两个东西，
yeah we I think we [fill] in two packet, two things,

862
00:52:42,370 --> 00:52:46,330
EOP 表示数据包的末尾，
we call the EOP says you know the end of packet,

863
00:52:46,630 --> 00:52:48,160
这告诉驱动程序，
and that basically tells the driver,

864
00:52:48,310 --> 00:52:51,550
这是数据包的最后一个描述符，
this is the last descriptor of a particular packet,

865
00:52:51,550 --> 00:52:56,080
现在，你可以发送这些描述符里的数据。
and now can you know send off you know whatever data that's in these descriptors.

866
00:52:56,900 --> 00:53:06,220
我想我们设置了响应请求命令位，
And I think we set the response you know requested command bit

867
00:53:06,490 --> 00:53:09,850
或者 RS ，
or RS I think it is,

868
00:53:09,880 --> 00:53:11,530
就是告诉网卡，
basically tells network card,

869
00:53:11,560 --> 00:53:14,530
当你完成传输这个东西，
when you're done transmitting this thing,

870
00:53:14,680 --> 00:53:20,600
设置它实际传输的位。
you know set the, set the bit that it actually has been transmitted.

871
00:53:21,430 --> 00:53:23,650
我们稍后会看到它是如何显示的。
We'll see in a second how how that shows up.

872
00:53:25,570 --> 00:53:26,350
有什么问题吗？
Any questions?

873
00:53:32,230 --> 00:53:34,090
所以有一件事要记住，
So one one thing to keep in mind,

874
00:53:34,360 --> 00:53:35,350
对于这些结构，
you know with these structures,

875
00:53:35,380 --> 00:53:36,610
这些都是由硬件定义的，
these are defined by the hardware,

876
00:53:36,640 --> 00:53:39,970
软件不能控制它们的结构，
like hardware, software has no control over their structure,

877
00:53:39,970 --> 00:53:43,780
这是由硬件和网卡定义的。
you know there's just literally defined by the hardware, by the network card.

878
00:53:44,860 --> 00:53:47,050
好的，让我们看一小段代码，
Okay, let's look at a little bit of code

879
00:53:47,470 --> 00:53:50,590
看看解决方案是什么样子，
and see what the solution looks like,

880
00:53:50,590 --> 00:53:52,450
我们将看几个问题，
and we'll look at a couple of issues

881
00:53:52,450 --> 00:53:54,580
我们还没有看过的 mbuf ，
that we haven't looked at yet, you know the mbufs,

882
00:53:55,060 --> 00:53:59,020
传输过程中的问题和接收过程中的问题。
issues if during transmission and issues during receiving.

883
00:54:00,600 --> 00:54:03,090
你们大概都很熟悉这一点，
And this would be presumably all well familiar with to you,

884
00:54:03,090 --> 00:54:05,250
考虑到你刚刚完成实验。
given the fact that you just finished the lab.

885
00:54:08,880 --> 00:54:09,900
好的，那么这里，
Okay, so here,

886
00:54:09,900 --> 00:54:14,010
查看顶部，这是传送环。
just to go to the top, here's the transmit ring.

887
00:54:15,040 --> 00:54:18,580
是的，这就是描述符环，
Yeah, and that's basically the ring of descriptors,

888
00:54:18,580 --> 00:54:22,000
我们在最后几张幻灯片中画到了。
you know we drew off in the last couple of slides.

889
00:54:22,670 --> 00:54:23,540
这里有一个单独的，
There's a separate,

890
00:54:23,600 --> 00:54:24,830
我们简要地谈过这个，
we talked briefly about this,

891
00:54:24,830 --> 00:54:28,280
这里有一个独立的 mbuf 环，
there's a separate basically ring of mbufs,

892
00:54:28,520 --> 00:54:34,190
但在这个环完全是软件或驱动程序抽象，
but in that ring is completely you know a software or driver only abstraction,

893
00:54:34,550 --> 00:54:42,090
这个结构是硬件定义的，
hardware, this is defined by this structure is defined by the hardware, right,

894
00:54:42,090 --> 00:54:42,870
如果你看一下。
and if you look at.

895
00:54:43,480 --> 00:54:43,960
哎呀。
Oops.

896
00:55:02,990 --> 00:55:04,760
查看定义，
You know look at the definitions,

897
00:55:04,760 --> 00:55:06,740
这里是 tx_desc 结构体，
but here's struct tx_desc,

898
00:55:06,860 --> 00:55:10,310
这对应于 C 版本的结构体，
that corresponds to the C version of exactly the structure

899
00:55:10,310 --> 00:55:11,750
由硬件定义的，
that actually was defined by the hardware,

900
00:55:11,780 --> 00:55:14,090
64 位地址，
you know 64 bit address,

901
00:55:14,090 --> 00:55:17,480
length 字段， cso 字节， cmd 字节，
you know the length field, the cso, byte the cmd byte,

902
00:55:17,480 --> 00:55:21,740
status 字节， css 字节，然后是 special 的两字节。
the status byte, the css byte, and then two word for special.

903
00:55:22,590 --> 00:55:25,320
还有一个类似的环，是由硬件定义的，
And there's a similar ring that is literally defined by the hardware,

904
00:55:25,840 --> 00:55:28,390
或类似的接收描述符，是由硬件定义的，
or similar descriptors received descriptor as defined by hardware,

905
00:55:28,390 --> 00:55:32,560
并且那些已经看到的描述符与这些硬件结构相对应。
and those we just have see descriptors corresponding to these hardware structures.

906
00:55:34,970 --> 00:55:36,230
好的，让我们来看一下传输，
Alright, let's look at transmit,

907
00:55:37,780 --> 00:55:41,650
这是一种用于传输的解决方案，
so here's the sort of staff solution for transmit,

908
00:55:42,390 --> 00:55:44,370
获取一把锁，
you know acquires a lock,

909
00:55:44,400 --> 00:55:46,680
我们之前说的需要锁的原因是，
and the reason we said before that needed lock is,

910
00:55:46,680 --> 00:55:49,110
因为有多个函数或多个内核线程
because multiple functions or multiple threads, kernel threads

911
00:55:49,110 --> 00:55:51,900
可能会同时调用 transmit 。
might call transmit at the same time.

912
00:55:53,460 --> 00:55:55,110
然后它查看尾指针，
And then it looks at the tail,

913
00:55:55,320 --> 00:55:57,660
查看是否有，
you know to see if there's any,

914
00:55:58,300 --> 00:56:01,120
在房间里发送新的数据包，
in the room to actually sent a new packet,

915
00:56:01,120 --> 00:56:03,880
因为网卡落后了，
because you know the network card got behind,

916
00:56:03,880 --> 00:56:07,390
所有的描述符都在使用中。
and all the descriptors actually are be in used.

917
00:56:08,170 --> 00:56:09,280
所以它检查的方式，
And so the way it checks,

918
00:56:09,730 --> 00:56:13,390
描述符是否在使用，
where you're actually the descriptor in the in use,

919
00:56:13,390 --> 00:56:19,040
通过检查是否未设置 DD 位。
by checking whether the DD bit is not set.

920
00:56:20,120 --> 00:56:22,850
如果它设置了，
And if it is set then,

921
00:56:25,410 --> 00:56:29,760
如果没有设置，则它立即返回，
if it's not set, then it returns immediately,

922
00:56:29,760 --> 00:56:31,170
根本不发送数据包，
not sending the packet at all,

923
00:56:31,350 --> 00:56:33,660
在任何其他情况下，则继续下去，
and in any other case, gonna it keeps on,

924
00:56:33,660 --> 00:56:35,550
会发送 mbuf 。
going and actually will send the mbuf.

925
00:56:39,760 --> 00:56:43,600
所以，如果 tx_mbufs 中仍有 mbuf ，
So if there's still an mbuf in this position in the tx_mbufs,

926
00:56:43,600 --> 00:56:45,820
意味着这是[以前]的 mbuf ，
and means this is an mbuf for a while back,

927
00:56:45,850 --> 00:56:47,260
释放那个 mbuf ，
you know free that mbuf,

928
00:56:47,260 --> 00:56:50,800
因为我们要把 mbuf 插入到这个描述符中，
because we're going to actually stick in a new mbuf into this descriptor,

929
00:56:51,100 --> 00:56:52,120
我们只需要记住，
we just need to remember,

930
00:56:52,120 --> 00:56:54,490
我们插入哪个描述符，
which you know mbuf we stuck in that descriptor,

931
00:56:54,610 --> 00:56:56,080
我们做到这一点的方法是
and so the way we do that is

932
00:56:56,080 --> 00:56:58,420
将其保存在 tx_mbuf 中。
by keeping that in the tx_mbufs.

933
00:56:59,820 --> 00:57:01,230
然后我们填入描述符，
And then we fill in the descriptor,

934
00:57:01,500 --> 00:57:04,530
所以我们要填入的第一样东西是头指针，
and so the first thing we'll filling is the head

935
00:57:04,530 --> 00:57:05,820
然后我们填入，
and we fill in,

936
00:57:05,850 --> 00:57:11,970
我们把地址放入 mbuf 中第一个头指针的开始，
we put in the address the start of the first header in the mbuf,

937
00:57:13,470 --> 00:57:17,020
然后，放入 length ， status 设置为 0 ，
then, put the length, set the status 0,

938
00:57:17,110 --> 00:57:18,730
设置 cmd 字段，
put the command field in place

939
00:57:18,730 --> 00:57:23,200
通过设置 RS 和 EOP 位。
by setting both RS and the EOP bit as we discuss the second.

940
00:57:23,760 --> 00:57:28,340
然后，你会同步，
And, and then basically you'll be synchronized

941
00:57:28,340 --> 00:57:30,860
以确保实际上没有重新排序，
to make actually sure there's no reordering of,

942
00:57:30,890 --> 00:57:35,300
所有这些指令都是在下一条指令之前执行。
you know that all these instructions are performed before the next instruction.

943
00:57:36,140 --> 00:57:37,310
下一条指令所做的，
And what the next instruction does,

944
00:57:37,310 --> 00:57:38,930
它更新尾指针，
it actually updates the tail pointer,

945
00:57:39,080 --> 00:57:41,330
所以，[]更新尾指针，
and so the [] updates the tail pointer,

946
00:57:41,330 --> 00:57:45,470
尾指针是网卡中的一个控制寄存器，
and the tail pointer correct is a control register in the network card,

947
00:57:45,890 --> 00:57:48,200
所以当我们更新尾部指针时，
and so basically when we update the tail pointer,

948
00:57:48,290 --> 00:57:51,170
网卡知道发生了变化，
the network card knows aha something changed,

949
00:57:51,470 --> 00:57:56,180
它将读取那个描述符的数据，
and it's going to read you know the data at that descriptor,

950
00:57:56,420 --> 00:58:00,200
它将读取我们刚刚填入的这些字段，
and it's going to basically read these fields, we've just filled in,

951
00:58:00,350 --> 00:58:02,450
所以我们要绝对确保，
so we're gonna basically make absolutely sure that,

952
00:58:02,880 --> 00:58:06,750
所有这些写入，所有的存储都在内存中实现，
all these writes, all the stores are materialized in memory,

953
00:58:06,780 --> 00:58:09,630
在网卡读取它们之前，
before the network card actually reads them,

954
00:58:09,630 --> 00:58:11,520
这就是为什么那里有 __sync_synchronize 的原因，
and so this is why the __sync_synchronize there,

955
00:58:13,760 --> 00:58:14,900
然后我们释放锁，
and then we release about a lock,

956
00:58:14,900 --> 00:58:17,240
这就是我们传输数据包所要做的全部工作。
and that's basically all we have to do to transmit a packet.

957
00:58:20,790 --> 00:58:24,800
你能再解释一下 __sync_synchronize 吗，比如。
Can you explain the __sync_synchronize again, like what.

958
00:58:25,270 --> 00:58:30,160
是的，它是关于技术上的内存排序，
Yeah, it's mostly memory ordering technicality, correct,

959
00:58:30,160 --> 00:58:32,140
编译器可以自由地重新排序指令，
compilers are free to reorder instructions,

960
00:58:32,660 --> 00:58:38,720
写入可能位于 L1 缓存或 L2 缓存中，
the writes might actually sit in the L1 cache or the L2 cache,

961
00:58:39,080 --> 00:58:42,380
基本上 synchronize 是内存屏障，
and sync basically the synchronize sort of memory fence,

962
00:58:42,680 --> 00:58:45,260
告诉硬件和编译器，
that tells the hardware and compiler,

963
00:58:45,350 --> 00:58:48,680
请不要通过屏障移动任何指令，
please don't move any instructions across this barrier,

964
00:58:49,630 --> 00:58:51,670
并确保所有数据，
and make sure that all the data,

965
00:58:51,670 --> 00:58:54,640
在这个屏障之前的所有保存，
that you know all the stores before this barrier

966
00:58:54,730 --> 00:58:57,100
都是在内存中实现的。
are actually actually materialized in RAM.

967
00:58:58,700 --> 00:58:59,990
这很重要的原因是，
And the reason that is important is,

968
00:58:59,990 --> 00:59:04,340
因为，回到我们刚才的图片，
because the, go back to our picture for a little while ago,

969
00:59:05,380 --> 00:59:10,060
一直回到这里。
all the way back here.

970
00:59:10,710 --> 00:59:14,970
确保运行驱动的 RISC-V 核心
Make sure both you know the RISC-V cores that run the driver code

971
00:59:15,000 --> 00:59:17,160
将值放在这里，
basically put values here in round right,

972
00:59:17,160 --> 00:59:20,670
但这些值在 L1 缓存和 L2 缓存中，
but you know those values are [] the L1 cache and L2 cache

973
00:59:21,030 --> 00:59:24,000
以及内存刷新，并确保它们出现在 RAM 中，
and the memory flush and ensures that they actually show up in the RAM,

974
00:59:24,120 --> 00:59:26,940
这一点很重要，因为只要我们更新尾指针，
this is important because as soon as we update the tail pointer,

975
00:59:26,940 --> 00:59:29,670
e1000 将在 RAM 中查找这些描述符，
the e1000 is going to look into RAM for these descriptors,

976
00:59:30,970 --> 00:59:34,000
我们必须确保所有的字段都设置好了，
and we've got to make sure that all the fields are indeed set,

977
00:59:34,800 --> 00:59:37,080
否则，它将读取过时的值。
otherwise, it would read stale values.

978
00:59:40,360 --> 00:59:41,140
这能理解吗？
Does that make sense?

979
00:59:43,410 --> 00:59:43,980
好的，谢谢。
Yep,thank you.

980
00:59:46,320 --> 00:59:48,300
为什么 mbuf 会存在，
Why do mbuf exist,

981
01:00:00,660 --> 01:00:02,730
为什么会有这种分离的结构，
why have these sort of separate structure of,

982
01:00:02,760 --> 01:00:07,850
为什么会有这两种对应的结构？
why have these two sort of corresponding structures?

983
01:00:09,590 --> 01:00:11,000
我想部分原因是，
So I guess part of it is,

984
01:00:11,000 --> 01:00:13,590
这一切都很好，
it's all nice and well

985
01:00:13,590 --> 01:00:18,510
如果驱动需要告诉硬件东西在哪里，
if the driver needs to talk to the hardware about where things are,

986
01:00:18,510 --> 01:00:19,260
但归根结底，
but at the end of the day,

987
01:00:19,260 --> 01:00:20,820
我们确实需要保存数据包，
we do need to store the packet

988
01:00:20,820 --> 01:00:22,800
以便以某种方式将其传递到网络栈。
to hand off to the network stack somehow.

989
01:00:24,020 --> 01:00:24,860
是的，就是这样，
Yeah, exactly,

990
01:00:24,920 --> 01:00:27,350
所以，考虑这个问题的一种方式是，
you know, so you know so one way to think about it is

991
01:00:27,350 --> 01:00:30,110
mbuf 完全是操作系统抽象，
that the you know the mbufs completely an OS abstraction,

992
01:00:30,110 --> 01:00:32,750
与网卡一点关系都没有，
nothing to do with really the network card at all,

993
01:00:33,140 --> 01:00:33,740
它之所以在那里，
and it's there,

994
01:00:33,740 --> 01:00:39,590
因为，如果在某个时候，可能会收到一个数据包，
because like you know if at some point, you know maybe receive a packet,

995
01:00:39,590 --> 01:00:41,450
我们把它送到网络栈，
you know we hand it off to the network stack,

996
01:00:41,450 --> 01:00:43,610
放到网络栈中的某个队列中，
in the network stack now sticks at some queue,

997
01:00:43,700 --> 01:00:45,890
这样当稍后用户进程调用 read 时，
so that when later a user process calls read,

998
01:00:45,920 --> 01:00:47,150
你可以读它，
you actually can read it,

999
01:00:48,000 --> 01:00:50,550
同时，我们需要一些结构
in the meantime, we need to have some structure,

1000
01:00:50,550 --> 01:00:53,040
来保存我们收到的数据，
that holds that data that we actually received

1001
01:00:53,040 --> 01:00:54,990
这就是这些 mbuf 结构。
and that's exactly what those mbuf structures are.

1002
01:01:01,310 --> 01:01:03,800
抱歉，你能不能谈谈，
Sorry, can you talk about the,

1003
01:01:04,700 --> 01:01:09,990
比如，你如何在代码中使用链表结构，
like how, how do you use the link list structure in your code,

1004
01:01:09,990 --> 01:01:13,690
因为我试着去理解它并追踪它，
because I was trying to to understand it and track it down

1005
01:01:14,290 --> 01:01:19,490
它似乎有一些 push tail 或 push head ，
and it seems like there's some push tail or push head,

1006
01:01:19,550 --> 01:01:23,680
但我在我的代码里从来没有调用它，
but I don't ever call it in my code,

1007
01:01:24,220 --> 01:01:28,000
哦，它可能在 net.c 文件中。
oh, it might be it might be in the net.c file.

1008
01:01:30,200 --> 01:01:33,110
我们给你们的网络 C 文件吗？
The networks C files file, we gave you to, correct?

1009
01:01:33,770 --> 01:01:34,610
是的。
Yeah.

1010
01:01:39,650 --> 01:01:40,940
你想的是什么？
And where you're thinking?

1011
01:01:42,800 --> 01:01:49,940
如果你查找，比如 pull pop ，我想是 pop 。
If you look for something like pull pop, I think pop.

1012
01:01:54,210 --> 01:01:57,030
是的，这是唯一的地方，
Yeah, so this is this is the only place

1013
01:01:57,030 --> 01:02:03,540
看起来使用了 mbuf 的链表结构，
where it looks like it does things with the linked list structure of mbuf,

1014
01:02:04,290 --> 01:02:08,700
如果你不调用这个函数或 push tail ，
and if you don't ever call this function or the push tail,

1015
01:02:09,000 --> 01:02:17,610
你只是将 mbuf 视为一个由多少个字符组成的数组，
you basically just treat the mbuf as an array of like how many characters,

1016
01:02:17,670 --> 01:02:20,570
那么，为什么 mbuf 会在那里。
so, so why is mbuf there.

1017
01:02:21,370 --> 01:02:27,710
因为在这里，当你收到 UDP 数据包时，
Because here, when you receive a UDP packet,

1018
01:02:28,130 --> 01:02:30,440
因此 UDP 数据包从网卡传入，
so the UDP packet comes in from the network card,

1019
01:02:30,470 --> 01:02:31,850
它进入网络栈，
it goes to the network stack,

1020
01:02:32,450 --> 01:02:34,430
然后是 UDP 数据包，
then the UDP packet,

1021
01:02:34,460 --> 01:02:38,060
UDP 的 mbuf 持有 UDP 数据包，
the mbuf for the UDP that holds that UDP packet

1022
01:02:38,450 --> 01:02:40,250
在这个队列中，
is actually stuck in a queue right here,

1023
01:02:42,090 --> 01:02:44,220
在接收者的插槽上。
on the socket for the receiver.

1024
01:02:47,460 --> 01:02:50,370
这就是为什么你有 mbuf 队列的原因。
And so this is the reason that you can have queues within mbufs.

1025
01:02:54,420 --> 01:02:56,100
原因是栈在队列中，
And the reason is stack in the queue there correct,

1026
01:02:56,100 --> 01:02:57,300
是因为你知道，
is because you know who knows,

1027
01:02:57,300 --> 01:03:00,690
用户进程要从这个套接字读取，
you know the user process that's going to read you know from this particular socket,

1028
01:03:01,140 --> 01:03:02,670
也可能在做别的事，
you know might be doing something else,

1029
01:03:02,700 --> 01:03:05,310
在随后的某个时刻，它调用 read 系统调用，
and at some point later, it's going to call the read system call,

1030
01:03:05,310 --> 01:03:09,630
然后 read 系统调用将从那个套接字中移动 mbuf 。
then the read system call is going to move you know that mbuf from that socket.

1031
01:03:11,780 --> 01:03:20,250
所以，每个套接字可以具有用于接收的 mbuf 列表。
And so, the point with each socket can have a list of mbufs for reception.

1032
01:03:22,070 --> 01:03:23,390
我明白了，谢谢。
I see, thank you.

1033
01:03:25,840 --> 01:03:27,580
好的，让我们回到驱动上。
Okay, let's go back to the driver.

1034
01:03:28,190 --> 01:03:30,230
所以那是传输。
So that was transmit.

1035
01:03:32,480 --> 01:03:33,980
然后我们接收，
So then we receive,

1036
01:03:34,010 --> 01:03:37,340
几乎是一样的，没有太大差别，
you know almost similar, not that much difference,

1037
01:03:37,760 --> 01:03:42,620
基本上从网卡读取尾指针。
basically you know read the tail pointer from the network card.

1038
01:03:43,220 --> 01:03:45,470
你可以看到那里有一个数据包，
You see there actually a packet,

1039
01:03:45,560 --> 01:03:51,110
如果有数据包，则 DD 字段会被设置，
and if there's a packet, then the DD field would be set,

1040
01:03:51,770 --> 01:03:53,630
如果 DD 字段没有设置，
if the DD field is not set,

1041
01:03:53,660 --> 01:03:56,360
然后我们知道没有数据包，我们就结束了，
then we know there's no packet and so we're done,

1042
01:03:57,200 --> 01:03:59,750
如果设置了，我们就去读它，
if it is set, we're going to read it,

1043
01:04:02,220 --> 01:04:03,660
读取长度，
and read the length,

1044
01:04:03,660 --> 01:04:08,710
当我们调用 net_rx 时，当我们调用和net_rx时，
you know, and when we when we call and net_rx,

1045
01:04:08,710 --> 01:04:11,230
向上调用更高级别的栈。
you know do up call into the higher level stack.

1046
01:04:11,930 --> 01:04:14,270
当我们完成时，
And when we're done,

1047
01:04:14,270 --> 01:04:18,780
我们会释放那个条目，
you know we're basically free up you know that entry,

1048
01:04:18,870 --> 01:04:20,880
以便驱动程序可以使用它
so that the driver can use it

1049
01:04:20,880 --> 01:04:22,470
来接收更多数据包。
to actually receive more packets in it.

1050
01:04:23,340 --> 01:04:25,980
真正的关键的操作是，
And the real crucial operation there is, correct,

1051
01:04:25,980 --> 01:04:28,710
我们撞上尾指针告诉驱动程序，
we bump up basically the tail to tell the driver,

1052
01:04:29,100 --> 01:04:31,560
我们已经用完了，你可以再次使用，
okay, you know we're done with it, you can use it again,

1053
01:04:31,590 --> 01:04:33,060
这里的那个位置。
you know here's again that slot.

1054
01:04:35,900 --> 01:04:37,910
所以也许最有趣的问题是
So maybe the most interesting question is

1055
01:04:37,940 --> 01:04:40,430
你们问的很多问题，
and number of questions have you asked,

1056
01:04:40,460 --> 01:04:41,810
为什么这里有一个 while ，
why is the while there,

1057
01:04:45,530 --> 01:04:46,730
为什么这是一个循环，
why is this in a loop,

1058
01:04:47,690 --> 01:04:48,830
不是你获得中断，
don't you get an interrupt,

1059
01:04:48,830 --> 01:04:50,690
你抓到一个数据包，然后你就完成了，
then you know you grab one packet then you've done,

1060
01:04:50,930 --> 01:04:54,370
很多人首先忘记了 while 循环，
a number of people that actually forgot while loop first,

1061
01:04:54,370 --> 01:04:56,470
注意，在某个时刻，
you know notice that basically at some point

1062
01:04:56,470 --> 01:04:58,750
在 nettest 中，你不能接收到数据包。
you don't receive packets anymore, during nettest.

1063
01:05:02,840 --> 01:05:06,230
是因为你希望传输尽可能多的包，
Is it because you would like to transmit as many packets

1064
01:05:06,230 --> 01:05:08,900
仅使用一个中断，
that are ready as possible with only one interrupt,

1065
01:05:08,900 --> 01:05:13,010
这样你就可以在摊销中断的成本。
so that you can kind of amortize the cost of the interrupt.

1066
01:05:13,780 --> 01:05:15,850
是的，这绝对是其中的一部分，
Yeah, this, this is absolutely part of it,

1067
01:05:15,850 --> 01:05:17,320
你获得，
you know you get to the,

1068
01:05:17,470 --> 01:05:20,890
我们先来谈谈，根本原因是写入，
let's first talk about you know the root cause is write,

1069
01:05:21,730 --> 01:05:24,700
如果一些突发包进来了，
if a number of burst package comes in,

1070
01:05:25,330 --> 01:05:28,570
网卡将产生中断，
and the network card will generate the interrupt,

1071
01:05:28,930 --> 01:05:30,220
但是有更多的包进来了，
but more packets are coming in,

1072
01:05:30,310 --> 01:05:33,130
所以它会把它们放在空闲描述符中，
and so it will just put them in the free descriptors right

1073
01:05:33,130 --> 01:05:34,390
可以使用的，
that actually can use,

1074
01:05:35,060 --> 01:05:37,190
无法生成更多中断，
can't generate more interrupts,

1075
01:05:37,190 --> 01:05:38,750
因为已经生成中断，
because already generated interrupt,

1076
01:05:39,140 --> 01:05:42,620
在某种程度上，不管是什么进程，
and at some point you know the whatever the process

1077
01:05:42,620 --> 01:05:47,300
或者核心在一段关闭中断的代码中，
or you know, maybe we were the core was just in a section of code that turned off interrupts,

1078
01:05:47,300 --> 01:05:48,650
因为它在做一些原子性的事情，
because it was doing something atomic,

1079
01:05:49,010 --> 01:05:49,700
在它的最后，
at the end of it,

1080
01:05:49,700 --> 01:05:51,110
有一个锁的释放，
you know there's a release from lock,

1081
01:05:51,110 --> 01:05:52,400
它打开了中断，
that actually turns interruption on,

1082
01:05:52,550 --> 01:05:53,420
那个时间点，
that point of time,

1083
01:05:53,420 --> 01:05:57,800
然后接收中断处理程序继续运行，
then basically the receive handlers, the interrupt handler going to run,

1084
01:05:58,160 --> 01:05:59,720
但是在一段时间内，
but between a period,

1085
01:05:59,720 --> 01:06:02,510
当第一个包传入到接收处理程序运行之前，
when the first packet comes in and before you receive handler runs,

1086
01:06:02,510 --> 01:06:06,290
可能还有一大堆其他的包进来了。
there's a whole bunch of other packets might have could have could have come in.

1087
01:06:07,430 --> 01:06:10,310
所以我们不在 while 循环中运行，
And so we don't run in the while loop,

1088
01:06:10,340 --> 01:06:13,100
会留下这些数据包，
will leave those packets,

1089
01:06:13,100 --> 01:06:15,650
会抓到第一个，也会抓到另一个，
will grab the first one and will grab the other

1090
01:06:15,650 --> 01:06:18,380
后面的放在队列里，
and the later ones you stick there in the queue, right,

1091
01:06:18,380 --> 01:06:19,670
它们就在那个环里。
they're just sitting there in that ring.

1092
01:06:20,680 --> 01:06:22,780
现在，如果随后的中断进来，
Now, if subsequent interrupt would come in,

1093
01:06:22,780 --> 01:06:23,920
我们会抓取下一个，
we'll grab the next one,

1094
01:06:24,340 --> 01:06:26,110
但就像测试一样，
but like the tests,

1095
01:06:26,140 --> 01:06:29,110
他们所做的，他们会运行 UDP 数据包，
you know what they do they run their UDP packets,

1096
01:06:29,110 --> 01:06:30,700
他们会发送一大堆，
you know, so they send off a whole bunch,

1097
01:06:30,700 --> 01:06:34,600
比如，一个测试是并行发送 10 个 ping 请求，
like one of the test since like ten ping request in parallel,

1098
01:06:34,810 --> 01:06:38,200
有 10 个回复也是并行的。
you know the ten responses coming parallel back, you know correct.

1099
01:06:38,640 --> 01:06:41,940
第一个接收到的产生中断，
The first one receives generates an interrupt,

1100
01:06:42,030 --> 01:06:43,980
其他九个进入队列，
the other nine go into the queue,

1101
01:06:44,480 --> 01:06:48,230
更高级的软件到达第一个，
the higher level software, you know reached the first one,

1102
01:06:48,830 --> 01:06:51,380
然后完成并返回，
and then returns like it's done,

1103
01:06:51,650 --> 01:06:53,450
在这一点上，什么都不会发生，
and at that point, nothing happens anymore,

1104
01:06:53,450 --> 01:06:56,210
因为接收者正在等待更多的接收数据包，
because the receiver is waiting for more receive packets,

1105
01:06:56,360 --> 01:06:57,350
它们碰巧在那里，
they happen to be there,

1106
01:06:57,350 --> 01:06:58,250
它们在环中，
they're sitting in the ring,

1107
01:06:58,430 --> 01:07:02,120
除了接收不是在 while 循环中做的，
except you know the receive didn't do them in a while loop

1108
01:07:02,120 --> 01:07:03,140
所以没有去取出它们。
and so didn't pick them up.

1109
01:07:05,850 --> 01:07:06,570
这能理解吗？
Does that make sense?

1110
01:07:13,160 --> 01:07:15,710
所以，比如，如果测试程序会发送，
So, for example if the test programs would have sent,

1111
01:07:15,710 --> 01:07:18,320
一个请求等待响应，
one request waited for a response,

1112
01:07:18,320 --> 01:07:20,420
一个请求等待响应，
one request waited for a response,

1113
01:07:20,600 --> 01:07:24,050
你永远不会注意到，需要一个 while 循环。
then you would never notice that, you needed to a while loop.

1114
01:07:24,550 --> 01:07:27,910
因为会有突发的回复回来，
And it's because like there's a burst of responses might come back,

1115
01:07:28,030 --> 01:07:30,970
而这只会一起产生一个中断。
and that only generate together one interrupt.

1116
01:07:35,020 --> 01:07:36,820
对于这个，有什么问题吗？
Any questions about that, about this?

1117
01:07:36,820 --> 01:07:37,990
我有个问题，
I have a question,

1118
01:07:37,990 --> 01:07:42,160
比如，除了 while(1) ，
so for example if instead of a while one,

1119
01:07:42,700 --> 01:07:45,580
我们有一个遍历整个队列的 for 循环，
we would have a for loop that just goes through the whole queue,

1120
01:07:45,580 --> 01:07:49,060
出于同样的原因，这也是错误的。
that would also be wrong for the same reason.

1121
01:07:49,420 --> 01:07:53,260
不，我们跳过所有未设置 DD 的列表。
No, we skip all the ones that have the DD not set.

1122
01:07:54,670 --> 01:07:57,370
好的，我们应该只看数据包，
Okay, we should only we should only look at packets

1123
01:07:57,370 --> 01:08:00,220
我们应该只看尾指针。
and actually we should only look at the tail pointer.

1124
01:08:02,170 --> 01:08:05,380
但是原则上，你可以跳过整个队列，
But you know in principle, you could just skip the whole queue

1125
01:08:05,380 --> 01:08:07,120
我想查看 DD 数据包，
and I guess look at the DD packets,

1126
01:08:07,120 --> 01:08:09,490
让它们看到 DD 位已设置，
you know let them see the DD bit is set,

1127
01:08:09,520 --> 01:08:11,920
这可能行得通，我还没试过。
and that might work, I don't know I haven't tried that.

1128
01:08:14,060 --> 01:08:18,050
好的，但是是不是设备可以
Okay, but isn't the device able to

1129
01:08:18,320 --> 01:08:23,270
在我们读到旧数据之后，在接收器里放更多的 mbuf ？
put more mbufs in the receive after we read stale?

1130
01:08:25,000 --> 01:08:25,930
是的，对。
Yeah yeah.

1131
01:08:29,070 --> 01:08:29,610
好的。
Okay.

1132
01:08:32,080 --> 01:08:32,890
我们必须。
And we have to.

1133
01:08:42,200 --> 01:08:43,010
这是非常危险的，
It's very dangerous,

1134
01:08:43,010 --> 01:08:45,110
这个提议是查看，
like this proposal of like sort of looking around,

1135
01:08:45,110 --> 01:08:47,150
查着 DD 设置，
and you know seeing DD set,

1136
01:08:47,150 --> 01:08:49,490
因为我们应该这么做，
because you know really we should do,

1137
01:08:49,490 --> 01:08:54,260
我们不应该查看由驱动程序或硬件控制的 buf ，
we should not look at buf that really are controlled by the driver or by the hardware,

1138
01:08:54,500 --> 01:08:58,180
只需查看软件可用的缓冲区，
and only look at buffers are actually available to the software

1139
01:08:58,240 --> 01:09:00,760
是由 DD 位表示的，
and which is indicated by the DD bit,

1140
01:09:00,760 --> 01:09:02,470
通过查看尾指针。
and basically by looking at the tail pointer.

1141
01:09:04,080 --> 01:09:08,430
基本上，尾部和头部之间的任何东西都归硬件所有。
Basically, anything owned between the tail and the head is owned by the hardware.

1142
01:09:13,220 --> 01:09:17,060
回到 mbuf ，就像我们需要 mbuf 的原因，
Going back to the mbuf, like the reason we need the mbuf,

1143
01:09:17,450 --> 01:09:23,990
为什么我们需要缓冲区中的其他信息，比如[]数组，
why do we need the other information in the buffer like the [] array,

1144
01:09:24,580 --> 01:09:26,230
我想它叫做[后备存储]。
I think it's called the backing store.

1145
01:09:28,760 --> 01:09:30,830
它在 net.h 中。
It gets in net.h.

1146
01:09:40,490 --> 01:09:42,830
所以我们需要 buf 字段，
So we need we need the buf field, correct,

1147
01:09:42,830 --> 01:09:44,300
因为它包含了数据。
because it actually contains the data.

1148
01:09:46,800 --> 01:09:49,410
我认为头部包含指向数据的指针。
I thought the head contains a pointer to the data.

1149
01:09:49,590 --> 01:09:50,400
好的，好的，
Yeah yeah okay,

1150
01:09:50,400 --> 01:09:53,190
但是 buf 是实际分配的空间，
but the buf actually is the actual allocates space,

1151
01:09:53,190 --> 01:09:54,510
这个数据包，
you know the whole packets, right,

1152
01:09:54,750 --> 01:09:57,240
然后头部使用指针进入 buf ，
and then head get pointers into buf,

1153
01:09:57,420 --> 01:09:59,100
是数据包的开头。
basically the start of the packet.

1154
01:10:01,450 --> 01:10:02,230
好的，好的。
Okay, okay.

1155
01:10:04,160 --> 01:10:05,630
这是 mbuf ，这是，
And this is mbuf, this is,

1156
01:10:05,630 --> 01:10:08,990
好的， mbuf 的更多上下文是
okay so a little bit more context to mbuf is

1157
01:10:08,990 --> 01:10:11,270
你在许多网络栈中看到的结构，
a structure that you see in a lot of network stacks,

1158
01:10:11,270 --> 01:10:12,920
所以你看一下 Linux 内核，
so you look in the Linux kernel,

1159
01:10:12,920 --> 01:10:14,420
你会看到类似这样的结构，
you'll see structure similar like this,

1160
01:10:14,420 --> 01:10:17,420
它通常被称为 mbufs ，所以我们必须。
and it's typically called mbufs, and so we have to.

1161
01:10:19,060 --> 01:10:22,030
我们可以把这个结构简化很多，
We could have simplified this structure quite a bit, if we wanted to

1162
01:10:22,270 --> 01:10:24,490
或许接下来我们应该，
and maybe subsequent here is we should,

1163
01:10:24,550 --> 01:10:26,620
但这是一种标准方法，
but this is sort of the standard way

1164
01:10:26,620 --> 01:10:30,430
数据包在操作系统内核中的表示。
in which packets are represented in operating system kernels.

1165
01:10:39,430 --> 01:10:41,110
好的，关于这个，还有什么问题吗？
Okay, any further questions about this?

1166
01:10:50,760 --> 01:10:51,900
所以我现在有一个选择，
So I have a choice now,

1167
01:10:51,930 --> 01:10:55,590
关于网络驱动程序，我可以说几件事，
a couple of things I could say about the network driver,

1168
01:10:55,860 --> 01:10:59,340
但是那样我就没有时间谈论 mmap 了。
but then I won't have any time to talk about mmap.

1169
01:10:59,880 --> 01:11:03,780
我也可以稍微谈一下 mmap ，然后到此为止，
I could also talk a little bit about mmap and then and stop here,

1170
01:11:04,500 --> 01:11:06,600
而不是讨论网络驱动程序。
in terms of talking to the network driver.

1171
01:11:09,640 --> 01:11:11,200
有什么偏好吗？
Any preferences?

1172
01:11:24,740 --> 01:11:25,700
没有偏好。
No preferences.

1173
01:11:31,350 --> 01:11:33,270
让我简单介绍一下 mmap ，
Let me talk a little bit about mmap,

1174
01:11:33,270 --> 01:11:35,940
因为有几次出现了一个问题，
because there was a question that came up a couple times,

1175
01:11:36,330 --> 01:11:40,080
这可能是值得解决的问题，
and that might be worth addressing,

1176
01:11:40,920 --> 01:11:45,090
这几乎更多的是关于 mmap 为什么存在的问题，
it's almost more a question about you know why mmap exists,

1177
01:11:45,420 --> 01:11:48,540
然后，是如何实现它。
then, you know actually how to implement it.

1178
01:11:49,680 --> 01:11:53,010
所以没有听起来不同的反对意见，
So there's no real objections which sounds different,

1179
01:11:53,040 --> 01:11:55,770
让我更多地谈谈 mmap 。
let me talk a little bit more about mmap.

1180
01:11:56,750 --> 01:11:58,100
所以，这是最后的机会，
So this is your last chance

1181
01:11:58,100 --> 01:12:00,980
询问有关网络驱动程序的问题，在下课之前。
to ask any questions about the network driver until the end of class.

1182
01:12:06,660 --> 01:12:12,990
好的，我们来谈谈 mbufs ，哦， mmap 。
Okay, let's talk about the mbufs, oh, mmap.

1183
01:12:28,610 --> 01:12:33,840
好的，这个问题与文件系统 API 有关，
Okay, so the, the question really relates to sort of the file system API,

1184
01:12:33,990 --> 01:12:38,220
文件系统具有相当广泛的 API ，
and so the file system has a reasonable broad API,

1185
01:12:38,820 --> 01:12:42,660
支持目录，符号链接，硬链接等，
supporting directories, symbolic links, hard links, etc etc,

1186
01:12:42,660 --> 01:12:46,980
但是它的主要部分是文件 API ，
but presumably the main the main part of it is the the file API, correct,

1187
01:12:46,980 --> 01:12:50,520
文件 API ，你现在已经很熟悉了，
the file API, you're well familiar to you now,

1188
01:12:52,110 --> 01:12:56,860
打开文件，有一些权限，
open the file, you know with some permissions,

1189
01:12:56,890 --> 01:12:58,720
一旦你打开了文件，
and once you have opened the file,

1190
01:12:58,960 --> 01:13:01,450
你可以从文件中读取，
you know you can read from the file,

1191
01:13:04,600 --> 01:13:07,870
读到缓冲区中，创建一些数据。
into a buffer, create some data.

1192
01:13:08,830 --> 01:13:12,550
你写入到文件，
And you can write you know to the file,

1193
01:13:15,040 --> 01:13:17,920
不管是文件描述符和 buf 还是 len ，
whatever file descriptor and buf, you know len,

1194
01:13:18,310 --> 01:13:19,390
假设我们，
so let's say we,

1195
01:13:20,080 --> 01:13:23,590
然后我们可以关闭文件描述符。
and then we can close the file descriptor.

1196
01:13:25,070 --> 01:13:26,900
现在假设我们想要编写一个应用程序，
Now let's say we want to write an application

1197
01:13:27,140 --> 01:13:29,240
你可以想一想，
and you can think about the,

1198
01:13:30,050 --> 01:13:34,940
可能只是一个文件，有普通的字节数组，
you know may be just a file as, you know files normally a array of bytes,

1199
01:13:34,940 --> 01:13:37,610
但是这个应用程序可能有
but like maybe this application has sort of

1200
01:13:37,610 --> 01:13:39,710
它是一个结构数组保存在其中。
it's an array of struct that are stored in it.

1201
01:13:39,890 --> 01:13:43,320
所以，假设应用程序想要更新结构，
So, and let's say the application wants to update the struct,

1202
01:13:43,320 --> 01:13:44,880
我们必须操作文件，
so you know we have to file,

1203
01:13:46,170 --> 01:13:50,200
这是一个文件，分成结构体，
here's a file and so divided in you know structs,

1204
01:13:50,200 --> 01:13:52,780
从 0 到文件长度，
you know whatever zero to use the file length,

1205
01:13:52,780 --> 01:13:56,470
我们可能在中间，
and you know we maybe like in the middle,

1206
01:13:56,830 --> 01:13:59,200
让我们有一个 16 字节的结构，或别的什么，
let's have structure 16 bytes or something

1207
01:13:59,200 --> 01:14:01,540
我们想要更新其中的一个，
and you know we want to update one of these

1208
01:14:01,840 --> 01:14:03,490
或者可能想要更新第一个。
or maybe want to update the first one.

1209
01:14:05,680 --> 01:14:07,240
所以，我们可以做到这一点，
And so in a way we could do that correctly,

1210
01:14:07,240 --> 01:14:09,340
我们读，我们打开文件，
we read and we open the file,

1211
01:14:09,340 --> 01:14:12,670
我们读开始的 16 个字节，
we read you know the first you know whatever 16 bytes,

1212
01:14:13,800 --> 01:14:15,720
对应于这个，
that correspond to this you know we,

1213
01:14:16,420 --> 01:14:20,680
假设更新第一个字段结构，
let's say updates you know the first field struct,

1214
01:14:20,710 --> 01:14:23,170
那个结构的第一个字节，改为 1 。
the first byte of that struct, you know to be 1.

1215
01:14:23,880 --> 01:14:28,080
然后我们调用 write ，将其写回，
And then we call write, to basically write it back

1216
01:14:28,110 --> 01:14:29,130
然后我们关闭文件。
and then we close the file.

1217
01:14:29,800 --> 01:14:31,480
那么，如果写入发生在那里，
So if when is write happens where,

1218
01:14:31,480 --> 01:14:32,530
它实际写入的位置是哪里。
where does it actually write.

1219
01:14:41,090 --> 01:14:44,360
所以我们把内存改为 1 ，
So we've set this memory above the 1,

1220
01:14:44,360 --> 01:14:47,540
这个会不会先变成 1 ，
you know will this first by change to 1,

1221
01:14:52,140 --> 01:14:53,160
如果我们调用 write 。
if we call write.

1222
01:15:08,510 --> 01:15:11,540
请记住，文件描述符没有设置与它关联。
So, remember the file descriptor has not set associated with it correct.

1223
01:15:13,320 --> 01:15:17,040
然后读取将偏移量向前推，
And reads read pushes that offset you know forward,

1224
01:15:17,040 --> 01:15:19,110
在这个例子中，我们读取 16 个字节，
in this case, we've read 16 bytes,

1225
01:15:19,110 --> 01:15:22,020
偏移量从 0 上升到 16 。
you know the offset goes from up 0 to 16.

1226
01:15:22,960 --> 01:15:24,310
那么 write 在哪里写呢，
And so where does write write,

1227
01:15:27,190 --> 01:15:32,470
正如你注意到的，在 write 系统调用中没有偏移量参数，
as you notice, there's no offset argument in the write system call,

1228
01:15:32,500 --> 01:15:33,610
那么它写在哪里。
so where does it write.

1229
01:15:37,070 --> 01:15:37,940
长度？
Len?

1230
01:15:39,180 --> 01:15:41,010
是的，我们将写入 len 字节，
Yeah you we'll write len bytes,

1231
01:15:41,010 --> 01:15:42,420
在文件中的哪个偏移量，
which offset in the file,

1232
01:15:44,080 --> 01:15:46,360
假设 len 对应 16 。
presumably len exactly at 16 right.

1233
01:15:46,920 --> 01:15:47,520
是的。
Yes.

1234
01:15:47,940 --> 01:15:51,420
那么这个字节会变成 1 。
Write here, so which, this byte will change to 1, correct.

1235
01:15:54,090 --> 01:15:58,470
而不是我们实际想要修改的东西。
Not the actual thing that we are actually trying to modify.

1236
01:15:59,970 --> 01:16:00,690
这能理解吗？
Does that make sense?

1237
01:16:02,540 --> 01:16:04,340
所以你写这个应用的方式，
So the way you've written this application,

1238
01:16:04,340 --> 01:16:06,050
有一次系统调用，
it turns out there was one a system call,

1239
01:16:06,050 --> 01:16:07,790
我们并没有太多谈论，
that we didn't really talk much about at all,

1240
01:16:07,910 --> 01:16:12,290
但是每一种 Unix 操作系统都被称为 lseek 。
but every operating system, Unix operating system is called system called lseek.

1241
01:16:14,220 --> 01:16:18,210
lseek 允许你将偏移量更改为某个位置。
And lseek allows you basically to change the offset to some position.

1242
01:16:18,850 --> 01:16:20,620
所以在这个案例中，
And so in this particular case,

1243
01:16:20,620 --> 01:16:23,200
我们想要的效果是，
we want to do have the effect

1244
01:16:23,200 --> 01:16:25,600
我们要写这个结构，而不是那个。
that we're going to write this struct not that one.

1245
01:16:26,140 --> 01:16:28,960
那么我们就会说 lseek 0 ，
Then we would have said like you know lseek 0,

1246
01:16:28,990 --> 01:16:34,250
将偏移量重置为 0 ，
basically resetting the offset to actually 0,

1247
01:16:34,280 --> 01:16:37,580
然后这个写操作是偏移量 0 。
so then this write would actually sort here now offset 0.

1248
01:16:38,380 --> 01:16:42,850
然后这个 write 写入前 16 个字节。
And then this write actually you would write actually at the first 16 bytes.

1249
01:16:44,170 --> 01:16:44,920
这能理解吗？
Does that make sense?

1250
01:16:51,700 --> 01:16:53,290
所以这有点不方便，
So this is slightly inconvenient, correctly,

1251
01:16:53,290 --> 01:16:54,340
如果你仔细想想，
if you think about this,

1252
01:16:54,520 --> 01:16:55,930
你看这个接口，
you look at this interface,

1253
01:16:55,930 --> 01:16:58,000
有相当多的东西在运行，
there's actually quite a bit of stuff going on,

1254
01:16:58,000 --> 01:16:59,890
你需要打开，需要读取，
you know you gotta open, you gotta read it,

1255
01:16:59,890 --> 01:17:01,570
你需要查找，然后可以写入。
you know you can seek it and then you can write it.

1256
01:17:02,310 --> 01:17:05,010
所以， mmap 流行的原因之一，
And so, one reason that mmap is popular,

1257
01:17:06,600 --> 01:17:10,860
是你可以避免这些复杂的情况。
is you can sort of avoid you know these these complications.

1258
01:17:11,460 --> 01:17:13,740
因为如果我们用 mmap 写这个，
Because if we write this using mmap,

1259
01:17:13,740 --> 01:17:15,840
我们做的打开 fd ，
you know, we do fd is open

1260
01:17:16,110 --> 01:17:17,850
我们像以前一样打开文件，
and we open the file as before,

1261
01:17:20,980 --> 01:17:24,370
然后我们只需要调用 mmap ，
and then you know we just call mmap,

1262
01:17:26,240 --> 01:17:27,830
不管我们的结构是什么，
it's going to be whatever our struct,

1263
01:17:27,860 --> 01:17:33,100
比如我们的结构体 h ，等等，
let's say our struct h, you know, blah, blah blah,

1264
01:17:33,130 --> 01:17:42,440
文件的长度，读、写权限，
you know whatever some len for the file, read, write permissions,

1265
01:17:43,530 --> 01:17:50,920
映射共享，文件描述符为 0 。
you know map shared, and file descriptor 0.

1266
01:17:52,160 --> 01:17:56,450
然后，我们就在 mmap 中了，
And then, so now basically with this correct we're in mmapping,

1267
01:17:56,450 --> 01:18:01,070
文件 f 在 h 位置在内存中。
you know the file f at the location h, you know in memory.

1268
01:18:01,580 --> 01:18:04,040
现在，我们可以说 h ，
Now, we can just say h

1269
01:18:04,040 --> 01:18:08,300
不管第一个字节是 0 还是 1 ，就像我们之前做的那样。
whatever first byte is zero or one that we did before.

1270
01:18:08,980 --> 01:18:11,710
然后，在某个时刻，我们可以调用 munmap ，
And then you know at some point you know we can munmap,

1271
01:18:16,440 --> 01:18:21,500
munmap h ，
you know the munmap h, right,

1272
01:18:21,500 --> 01:18:23,840
如果我们思考这个问题，我们在内存中查找。
and so if we think about this, we look in memory.

1273
01:18:24,400 --> 01:18:26,920
我们是从文件的角度来看这件事，
We're looking at this from the perspective of the file,

1274
01:18:27,310 --> 01:18:28,570
这能解决的问题，
you know what this does, correct,

1275
01:18:28,570 --> 01:18:32,410
代码说做的，你获得一个指向 h 的指针，
code literally did is basically you've got a pointer to this h,

1276
01:18:32,770 --> 01:18:35,560
你可以更新这个东西为 1 ，
and you can just update here, you know that thing to 1

1277
01:18:35,920 --> 01:18:37,390
然后就完成了。
and be done with it, right.

1278
01:18:38,360 --> 01:18:40,790
所以，如果我们需要操作
And so if we sort of need to manipulate

1279
01:18:40,820 --> 01:18:44,660
文件结构，位于文件中的数据结构，
you know file structure, data structure that sits inside of a file,

1280
01:18:44,960 --> 01:18:47,570
这 个mmap 接口要方便得多。
this mmap interface is much more convenient.

1281
01:18:48,060 --> 01:18:50,100
然后之前的接口，
Then you know this previous interface,

1282
01:18:50,340 --> 01:18:51,930
我们必须读取，
we're you know we have to read,

1283
01:18:51,930 --> 01:18:55,800
我们操纵内存，我们找回，
you know we manipulated the memory you know we you know we seek back,

1284
01:18:55,800 --> 01:18:57,180
然后我们写下信息。
and then we actually write the information.

1285
01:18:57,740 --> 01:18:59,360
在这个案例中，
And in this particular case,

1286
01:18:59,360 --> 01:19:03,410
我们可以将文件看作是字节数组，
we really can think about the file as being an array of bytes,

1287
01:19:03,410 --> 01:19:05,120
我们可以随意书写，
you know that we can write willy nilly,

1288
01:19:05,630 --> 01:19:07,790
而不必[导航]来跳来跳去，
without actually having to navigate to jump around,

1289
01:19:11,950 --> 01:19:16,060
人们看到 mmap 接口的优势了吗。
do people see what the advantage of the mmap interfaces.

1290
01:19:23,960 --> 01:19:25,040
对此有什么问题吗？
Any questions about this?

1291
01:19:28,170 --> 01:19:32,310
有没有大型存储系统都使用这种方式，
Any big storage systems use this,

1292
01:19:32,310 --> 01:19:34,050
比如数据库，
like I don't know like databases,

1293
01:19:34,050 --> 01:19:36,300
它们是经常使用还是不经常使用。
do they use this a lot or not really.

1294
01:19:36,630 --> 01:19:37,740
它们经常用这个。
They use this a lot.

1295
01:19:38,600 --> 01:19:40,850
我认为很多应用程序都使用 mmap ，
I think a lot of applications use mmap,

1296
01:19:40,880 --> 01:19:44,660
因为对于像数据库这样的东西来说要方便得多，
because for these kinds of things like a database is much more convenient,

1297
01:19:47,270 --> 01:19:49,790
这个接口非常好，
then this interface, this interface is great, correct,

1298
01:19:49,790 --> 01:19:51,560
如果你需要从标准输入读取，
if you need to read from standard input,

1299
01:19:51,680 --> 01:19:53,570
有一个字节流进入，
and there's a stream of bytes coming in,

1300
01:19:53,600 --> 01:19:57,770
你读取，并产生一些其他的输出流。
you read you read you read and you produce some output some other stream.

1301
01:19:58,910 --> 01:20:01,640
那个接口非常适合，
That interface that interface is very suitable for here,

1302
01:20:02,000 --> 01:20:03,500
你不必更新偏移量，
you don't have to update offset,

1303
01:20:03,500 --> 01:20:05,510
你读取，立即更新偏移量，
you know you read, get offset immediately update,

1304
01:20:05,510 --> 01:20:07,760
你再次读取，等等。
you read again, you read a bit further etc etc.

1305
01:20:07,940 --> 01:20:11,600
所以它对于面向流的输入来说很好。
So it's really good for stream oriented input.

1306
01:20:12,190 --> 01:20:13,450
嗯，这真的很不错，
Well, this is really good,

1307
01:20:13,450 --> 01:20:16,960
如果文件有数据结构，
you know if the file has data structure,

1308
01:20:16,960 --> 01:20:21,600
并且更新文件的部分，
and use one of sort of update basic pieces of the file,

1309
01:20:21,600 --> 01:20:23,850
任意的位置。
and you know arbitrary locations.

1310
01:20:32,220 --> 01:20:37,080
好的，让我想想，
Okay, let's see,

1311
01:20:37,110 --> 01:20:42,660
我的时间快用完了。
I'm going to start on about to run out of time.

1312
01:20:43,270 --> 01:20:46,200
所以让我停在这里，
So let me so stop here,

1313
01:20:46,200 --> 01:20:48,750
希望这个关于 mmap 的小道消息，
hopefully this one tidbit about mmap,

1314
01:20:48,750 --> 01:20:51,150
知道这一点很有用，
you know it's useful to know,

1315
01:20:51,540 --> 01:20:56,650
告诉你为什么这是一个很受欢迎的方案。
and tells you why you know that sort of is a popular scheme.

1316
01:21:00,080 --> 01:21:01,010
让我们看看,
Let's see,

1317
01:21:01,040 --> 01:21:06,560
我想，我们这节课快结束了，
so I I think that actually you know we were basically we come to the end of this lecture

1318
01:21:06,590 --> 01:21:16,000
也是 6.S081 的结束，
and I guess the end of the end of six the six 6.S081,

1319
01:21:16,030 --> 01:21:21,790
所以，如果你没有填写反馈调查，
and so again you know if you have not filled out the feedback survey,

1320
01:21:21,790 --> 01:21:24,640
请这样做，
you know please do so,

1321
01:21:24,670 --> 01:21:28,300
如果你能填一下科目评估，我们会很感激的。
you know we appreciate if you fill out the subject evaluation.

1322
01:21:29,180 --> 01:21:34,080
我再一次感谢你们的关注，
And and again I wanna thank you for your attention,

1323
01:21:34,110 --> 01:21:36,330
这又是一个奇怪的学期，
again it is a strange semester,

1324
01:21:36,330 --> 01:21:38,400
我希望我能见到你们所有人。
I wish I could have met you all in person.

1325
01:21:39,620 --> 01:21:43,880
无论是上课还是课前或课后都可以和你面谈，
Talk to you in person either class or before class or after class,

1326
01:21:44,240 --> 01:21:48,650
不幸的是，正如它所发生的，
and unfortunately, as it happened,

1327
01:21:48,680 --> 01:21:52,940
但我希望你能从 6.S081 学到很多，
but I hope you got quite a bit of 6.S081

1328
01:21:52,940 --> 01:21:56,120
当然还有工作人员，感谢你们的努力，
and certainly with the staff and thank you for the engagement,

1329
01:21:56,210 --> 01:21:59,060
这学期你们都表现得很棒。
you guys have been wonderful this semester.

1330
01:21:59,860 --> 01:22:01,800
到此为止，谢谢。
So with that, thank you.

1331
01:22:03,150 --> 01:22:05,160
如果你有任何问题，请不要离开。
If you have any questions, please hang around.

1332
01:22:06,550 --> 01:22:08,500
但我相信，你们中的一些人有最后期限。
But I'm sure some of you have deadlines.

1333
01:22:10,100 --> 01:22:12,680
老实说，我也代表助教，
Honestly on behalf of the TAs as well,

1334
01:22:12,680 --> 01:22:15,320
我们真的很享受这些时间，
we've really enjoyed all the time

1335
01:22:15,320 --> 01:22:18,110
跟你们在上班时间以及做检查，
we spent with you guys in office hours and doing check offs,

1336
01:22:18,110 --> 01:22:20,210
这是我们做检查的第一学期，
and this is the first semester, we've done check offs,

1337
01:22:20,210 --> 01:22:23,600
然后 David 和我都觉得这是一个非常愉快的过程，
and then David and I both found it a really enjoyable process,

1338
01:22:23,600 --> 01:22:25,370
希望我们能够
and you know hopefully we were able to

1339
01:22:25,700 --> 01:22:28,610
帮你们摆脱困境，并进行一些愉快的交谈，
help you guys out and have some good conversations as well,

1340
01:22:28,610 --> 01:22:30,530
所以，感谢你们让这学期过得很棒，
so thanks for making it a great semester

1341
01:22:30,530 --> 01:22:32,540
和我们一起在线上，
and adjusting on the fly with us

1342
01:22:32,540 --> 01:22:35,350
解决所有的远程学习问题，
with all of the remote learning problems,

1343
01:22:35,350 --> 01:22:37,750
我们遇到并解决，
we've run into and had to deal with

1344
01:22:38,020 --> 01:22:39,970
完成这一课程的乐趣。
an absolute pleasure achieving this course.

1345
01:22:46,360 --> 01:22:47,320
还有什么问题吗？
Any further questions?

1346
01:22:49,170 --> 01:22:50,670
再说一次，你可以随便提问。
Again, feel free to hang around.

1347
01:23:00,530 --> 01:23:03,260
哦，我有个问题，
Oh, I had a question,

1348
01:23:03,800 --> 01:23:06,700
所以，哦，是的，
so, it's it's oh yeah,

1349
01:23:06,700 --> 01:23:07,810
非常感谢你的课程，
thank you so much for the class,

1350
01:23:07,810 --> 01:23:11,500
我真的很喜欢这门课，这是最好的一学期，
I really like class, the best class semester,

1351
01:23:11,620 --> 01:23:16,210
我想问一下中断，接收的中断，
I wanted to ask about the interrupts, the received interrupts,

1352
01:23:16,270 --> 01:23:23,160
硬件如何知道软件何时完成，
how does the how does the hardware knows when when the software has finished,

1353
01:23:24,130 --> 01:23:27,970
处理上一个中断，而不是发出另一个中断。
handling the previous interrupt, not issue another one.

1354
01:23:28,800 --> 01:23:32,220
因为有多个步骤，
Because the there's multiple steps,

1355
01:23:32,880 --> 01:23:43,030
一是你看到 e1000 的下半部分，
one is you know you're looking e1000 at the bottom,

1356
01:23:43,420 --> 01:23:45,010
我们重新启用中断，
we re-enable interrupts

1357
01:23:45,400 --> 01:23:46,420
或者我们告诉网卡，
or we tell the card,

1358
01:23:46,420 --> 01:23:48,070
我们已经准备好接收更多中断。
we're ready to receive further interrupts.

1359
01:23:49,170 --> 01:23:52,320
这就是我们告诉网卡产生中断，
So that's why we tell the card to generate interrupts,

1360
01:23:52,770 --> 01:23:55,410
当然，在这一点上，中断并没有打开，
of course at this point interrupts actually not really turned on,

1361
01:23:55,410 --> 01:23:57,720
我们只需告诉网卡，你可以再次生成中断，
and we just tells the card you can generate interrupts again,

1362
01:23:58,280 --> 01:24:00,710
中断被打开，
the interrupts get turned on, correct,

1363
01:24:00,710 --> 01:24:04,310
正如这些函数，中断启用，
like you know by you know these functions, you know interrupt enable

1364
01:24:04,730 --> 01:24:07,280
在这一点上，如果你打开中断启用，
and at that point, if you turn on interrupt enable,

1365
01:24:07,280 --> 01:24:12,620
如果设置了此字段，再加上启用中断，
if this field set, plus you know the point where you turn on interrupt enable

1366
01:24:12,650 --> 01:24:14,330
中断可能会再次发生。
and actually interrupt might happen again.

1367
01:24:15,680 --> 01:24:18,680
好的，我忘了这个寄存器，非常感谢。
Right, I forgot about this register, thank you so much.

1368
01:24:18,680 --> 01:24:22,670
是的，就像一条指令，很容易漏掉。
Yeah, it's just like one instruction, easy to miss.

1369
01:24:25,960 --> 01:24:26,770
还有其他问题吗？
Any other questions?

1370
01:24:30,500 --> 01:24:31,490
谢谢大家。
Thank you all.

1371
01:24:32,580 --> 01:24:33,480
谢谢你，好的。
Thank you, okay.

1372
01:24:36,520 --> 01:24:37,420
谢谢。
Thank you.

1373
01:24:38,770 --> 01:24:39,850
谢谢。
Thank you.

1374
01:24:40,910 --> 01:24:41,840
非常感谢。
Thank you so much.

