1
00:00:06,750 --> 00:00:09,630
Good afternoon, quick sound check.

2
00:00:10,510 --> 00:00:11,320
Can people hear me?

3
00:00:12,270 --> 00:00:12,780
Yes.

4
00:00:13,820 --> 00:00:14,570
Thanks.

5
00:00:15,350 --> 00:00:19,370
Okay, so I guess today you know so far,

6
00:00:19,370 --> 00:00:23,180
it's the last lecture of 6.S081 this semester.

7
00:00:23,960 --> 00:00:30,500
And, we don't really have a formal topic,

8
00:00:30,620 --> 00:00:31,820
there's a Q&A lecture,

9
00:00:32,150 --> 00:00:36,380
so feel free to ask questions about anything,

10
00:00:36,410 --> 00:00:37,430
this is I guess last,

11
00:00:37,430 --> 00:00:40,490
your last chance at least this semester for this class.

12
00:00:41,260 --> 00:00:43,390
By default, my plan was

13
00:00:43,390 --> 00:00:49,090
to go over a couple topics based on the questions over email,

14
00:00:49,150 --> 00:00:53,100
then I was going to talk a little bit about network lab, the solutions.

15
00:00:53,850 --> 00:00:58,560
If possible, also a little bit of time about the mmap lab,

16
00:01:00,110 --> 00:01:01,760
again talking about those solutions.

17
00:01:02,090 --> 00:01:05,660
And then there were a lot of questions about the following classes

18
00:01:05,810 --> 00:01:09,050
and in fact I think I'll cover that first.

19
00:01:10,120 --> 00:01:15,280
But before diving in any of these three topics,

20
00:01:15,280 --> 00:01:23,800
let me remind you there's a subject evaluation outgoing ongoing,

21
00:01:23,800 --> 00:01:27,700
and we as staff of 6.S081,

22
00:01:27,700 --> 00:01:31,900
we appreciate you give your feedback on 6.S081.

23
00:01:33,060 --> 00:01:34,440
And hopefully it's positive,

24
00:01:34,680 --> 00:01:37,410
you know we get a chance to teach again next year.

25
00:01:39,320 --> 00:01:41,000
And maybe this is also a good time

26
00:01:41,000 --> 00:01:44,570
to you know actually thank you for attending today's lecture,

27
00:01:44,600 --> 00:01:46,730
even though there's not a sort of very formal program,

28
00:01:46,730 --> 00:01:49,040
I also appreciate the fact that with the staff

29
00:01:49,040 --> 00:01:53,330
and generally appreciate the fact that you know you're being very engaged,

30
00:01:53,330 --> 00:01:57,110
and in particular the paper that not directly to the labs,

31
00:01:57,110 --> 00:02:00,560
you know it's clear that many of you dove into the papers

32
00:02:00,560 --> 00:02:01,940
and try to really understand them,

33
00:02:01,940 --> 00:02:04,760
and ask great great question of over email.

34
00:02:04,760 --> 00:02:09,350
So, we very much appreciate the engagement.

35
00:02:10,780 --> 00:02:15,470
Any questions, before I go with each set of topics?

36
00:02:21,540 --> 00:02:25,830
Okay, let me start with the question that probably came up most in email,

37
00:02:25,890 --> 00:02:27,000
what next.

38
00:02:28,580 --> 00:02:35,900
There's a quite a number of classes that systems oriented focused,

39
00:02:36,350 --> 00:02:39,500
and I'm sure I missed a number of classes,

40
00:02:39,590 --> 00:02:41,330
that I should have listed here,

41
00:02:41,600 --> 00:02:44,660
you know immediately straightly related to operating systems,

42
00:02:44,660 --> 00:02:47,240
you know clearly you know if you have taken 6.033 yet,

43
00:02:47,270 --> 00:02:48,470
it's a great class to take,

44
00:02:48,470 --> 00:02:52,460
particularly we read or learn how to read papers.

45
00:02:52,950 --> 00:02:59,910
6.828 which the originally only OS class we offered,

46
00:02:59,940 --> 00:03:03,480
this year or second year we're,

47
00:03:03,750 --> 00:03:05,790
this year first year of offering both,

48
00:03:06,090 --> 00:03:08,520
so 6.S081 is undergrad OS

49
00:03:08,520 --> 00:03:14,340
and 6.828 as the grad level OS class.

50
00:03:14,870 --> 00:03:17,330
And you know basically 6.828 issues

51
00:03:17,330 --> 00:03:20,120
you've taken 6.S081 or undergrad OS

52
00:03:20,120 --> 00:03:26,150
and you know goes off in new projects and building interesting OS artifacts,

53
00:03:26,680 --> 00:03:28,810
and reading more papers from the literature

54
00:03:28,960 --> 00:03:31,390
and more of the modern research literature.

55
00:03:32,660 --> 00:03:34,430
Then maybe you are more you know,

56
00:03:34,430 --> 00:03:38,000
the OS sort of you know there's a lot of interfacing with the hardware,

57
00:03:38,030 --> 00:03:40,820
would have been more of the hardware side of systems,

58
00:03:40,820 --> 00:03:42,980
you know the computer architecture class 6.823,

59
00:03:42,980 --> 00:03:45,080
which I believe is offered to the coming Spring

60
00:03:45,320 --> 00:03:47,000
and of course there's 6.111,

61
00:03:47,000 --> 00:03:50,990
you know sort of the building something hardware devices.

62
00:03:51,460 --> 00:03:55,270
On the sort of performance sides, in the compiler sides,

63
00:03:55,270 --> 00:03:57,820
6.172, 6.035 for a good places,

64
00:03:57,850 --> 00:04:02,020
a number of you are taking 6.172 in parallel with 6.S081,

65
00:04:02,050 --> 00:04:05,620
so but if you have taken for example the compiled class 6.035

66
00:04:05,620 --> 00:04:07,780
or dynamic compiler class,

67
00:04:07,780 --> 00:04:10,240
both of them are also great classes.

68
00:04:11,580 --> 00:04:13,650
System is a broad topic,

69
00:04:13,680 --> 00:04:16,230
so like there's networking

70
00:04:16,230 --> 00:04:18,090
and there's a whole branch of classes

71
00:04:18,090 --> 00:04:20,070
whole [] of classes around networking,

72
00:04:20,130 --> 00:04:23,940
and a whole stream of class around databases,

73
00:04:24,240 --> 00:04:27,730
which are all good and important,

74
00:04:27,790 --> 00:04:31,570
and aspects that you've seen in 6.S081

75
00:04:31,570 --> 00:04:35,590
will show up in much more prominent ways in those classes.

76
00:04:36,510 --> 00:04:40,440
For example, networking clears a great topic of 6.829,

77
00:04:40,440 --> 00:04:43,050
and so you'll see a lot more about networking there,

78
00:04:43,380 --> 00:04:44,970
than you've seen in 6.S081,

79
00:04:45,240 --> 00:04:47,790
6.830 you know we talked about file systems,

80
00:04:47,790 --> 00:04:51,150
you know clearly another important classes of storage systems,

81
00:04:51,150 --> 00:04:55,410
and probably in some ways more important for many applications, databases,

82
00:04:55,410 --> 00:04:58,140
and so you get 6.830 a great topic class

83
00:04:58,140 --> 00:04:59,700
to learn a lot more about databases.

84
00:05:00,780 --> 00:05:02,370
In terms of like classes,

85
00:05:02,370 --> 00:05:06,180
that are sort of you know sometimes called whatever the PDOS classes,

86
00:05:07,440 --> 00:05:08,970
there's a number of them,

87
00:05:09,030 --> 00:05:13,110
6.824 distributed systems class will be offering that,

88
00:05:13,110 --> 00:05:16,470
coming semester Spring semester,

89
00:05:16,470 --> 00:05:23,180
and section of the number of the staff involved this semester in 6.S081

90
00:05:23,180 --> 00:05:24,620
will be involved in 6.824.

91
00:05:25,330 --> 00:05:29,650
There's 6.858 which is a computer security class,

92
00:05:29,830 --> 00:05:33,040
we won't be offering in that coming this Spring,

93
00:05:33,040 --> 00:05:36,220
but we hope to offer it the next academic year.

94
00:05:36,870 --> 00:05:41,100
And there's 6.826 which are principles of computer system,

95
00:05:41,100 --> 00:05:44,970
so a number of people ask about verification and system software,

96
00:05:44,970 --> 00:05:45,960
this is the class you take,

97
00:05:45,960 --> 00:05:47,730
if you are interested in that topic.

98
00:05:48,780 --> 00:05:50,940
More broadly speaking,

99
00:05:50,940 --> 00:05:54,300
a lot of people wondering what is actually going on in research,

100
00:05:54,300 --> 00:05:54,990
if you're interested,

101
00:05:54,990 --> 00:05:59,730
you know almost all the papers in the systems literature are publicly available,

102
00:05:59,730 --> 00:06:01,890
even the ones of the recent conferences,

103
00:06:01,920 --> 00:06:05,400
for example the OSDI conference happened a couple weeks ago,

104
00:06:05,700 --> 00:06:07,950
and you can just look at them

105
00:06:07,950 --> 00:06:09,840
and see what kind of topics are covered

106
00:06:09,840 --> 00:06:11,760
and read the papers that you find it interesting,

107
00:06:11,760 --> 00:06:13,050
all the talks are published,

108
00:06:13,410 --> 00:06:16,950
one of advantages of, you know, conference,

109
00:06:16,950 --> 00:06:18,390
that all these conference are virtual,

110
00:06:18,390 --> 00:06:21,600
and so all the conferences are recorded,

111
00:06:21,600 --> 00:06:24,180
and you can just watch them and see what's going on.

112
00:06:24,850 --> 00:06:27,100
If you interested in the sort of two parts,

113
00:06:27,100 --> 00:06:28,390
there's the research part,

114
00:06:28,780 --> 00:06:31,120
then of course there's what's going on in practice.

115
00:06:31,120 --> 00:06:32,890
And you know if you're interested in

116
00:06:32,920 --> 00:06:34,810
keeping track of what's happening with Linux

117
00:06:34,810 --> 00:06:37,510
and how that's how it's evolving,

118
00:06:37,870 --> 00:06:43,510
lwn.net actually publish a very regular page and a very interesting articles

119
00:06:43,510 --> 00:06:48,010
about like big changes or topics that are around the Linux kernel.

120
00:06:49,470 --> 00:06:53,910
Finally you know, if you're just excited about like doing the labs,

121
00:06:53,910 --> 00:06:55,500
you know just keep keep hacking,

122
00:06:55,620 --> 00:06:58,920
I think you can easily to cook up projects

123
00:06:58,920 --> 00:07:02,310
are either by doing extension of labs

124
00:07:02,310 --> 00:07:03,870
or just trying things out on your own,

125
00:07:04,740 --> 00:07:09,360
it's a great way to really learn and appreciate how things work.

126
00:07:10,090 --> 00:07:12,310
You probably got a good sense of that during the labs,

127
00:07:12,310 --> 00:07:15,340
we're sort of big fans of learning by doing

128
00:07:15,520 --> 00:07:19,990
and a lot that you can do on your own.

129
00:07:22,930 --> 00:07:29,130
Any questions about what next after 6.S081?

130
00:07:41,410 --> 00:07:42,010
Okay?

131
00:07:43,180 --> 00:07:46,630
Well, let's talk about the net lab,

132
00:07:47,360 --> 00:07:51,890
it was due I guess yesterday.

133
00:07:56,100 --> 00:07:58,350
And so as a couple things,

134
00:07:58,350 --> 00:08:01,440
maybe I'll start dive in slowly,

135
00:08:01,440 --> 00:08:02,940
I start a little bit at the top,

136
00:08:03,300 --> 00:08:08,850
and let me talk a little bit in generic terms about the lab.

137
00:08:13,390 --> 00:08:14,710
There's a couple things right,

138
00:08:14,710 --> 00:08:17,800
first, I want to talk a little bit about just sort of structural things,

139
00:08:19,120 --> 00:08:21,820
that sort of influence the design of the lab

140
00:08:21,820 --> 00:08:23,650
or you know the coding of the lab.

141
00:08:23,920 --> 00:08:26,500
And there are four different things in aspects,

142
00:08:26,500 --> 00:08:28,660
one of these I just want to talk a little bit about hardware,

143
00:08:29,140 --> 00:08:31,540
you know, this is one of the labs where we,

144
00:08:31,570 --> 00:08:34,360
there's a lot of interaction between software and hardware,

145
00:08:34,360 --> 00:08:37,090
in fact the hardware determines for a great part

146
00:08:37,090 --> 00:08:39,370
like how the the structure of software.

147
00:08:40,250 --> 00:08:42,470
Then a little bit about software structure,

148
00:08:43,170 --> 00:08:45,660
and just sort of back to this general topic,

149
00:08:45,660 --> 00:08:48,480
that we covered in a sort of somewhere in the middle of the term

150
00:08:48,480 --> 00:08:50,520
about you know the organization of drivers

151
00:08:50,520 --> 00:08:52,560
relative to the rest of the operating system kernel.

152
00:08:52,890 --> 00:08:55,590
Then talk a little bit more specific about hardware structures,

153
00:08:55,590 --> 00:08:59,680
you know the rings, and you know the descriptors,

154
00:09:02,500 --> 00:09:04,690
are the two primary sort of hardware structures,

155
00:09:04,690 --> 00:09:07,840
that the driver deals with or it must deal with.

156
00:09:08,780 --> 00:09:12,830
And then I'll talk to talk about the code and particularly the solutions,

157
00:09:13,220 --> 00:09:17,210
and focusing on a little bit about the role of mbufs,

158
00:09:19,780 --> 00:09:22,690
you know locking a lot of questions over email,

159
00:09:22,690 --> 00:09:27,700
about why not to lock in receive lock, receive in the receive function,

160
00:09:27,790 --> 00:09:30,370
why the loop in the receive handler,

161
00:09:31,140 --> 00:09:36,000
and you know what exactly you know the flags meaning the command,

162
00:09:36,060 --> 00:09:40,710
command field of the structure of the descriptor.

163
00:09:40,710 --> 00:09:42,120
and so we'll get to those issues

164
00:09:42,120 --> 00:09:44,820
as we as we look at the top as we look at the code.

165
00:09:47,110 --> 00:09:48,340
Just before drive in,

166
00:09:48,340 --> 00:09:49,450
it may be worthwhile,

167
00:09:49,450 --> 00:09:50,620
so reminding ourselves here,

168
00:09:50,620 --> 00:09:51,730
what the challenges are,

169
00:09:51,730 --> 00:09:54,040
although they're probably fresh in your head,

170
00:09:54,070 --> 00:09:55,690
like from a high level

171
00:09:55,690 --> 00:09:57,820
and one of the sort of core [] challenges,

172
00:09:57,820 --> 00:09:59,680
that you have to deal with in this lab.

173
00:10:01,610 --> 00:10:04,130
If you'll jump in to any ones,

174
00:10:04,130 --> 00:10:06,440
that I might have missed and you struggled with.

175
00:10:07,030 --> 00:10:09,610
So, first of all you know there's the hardware specification,

176
00:10:10,120 --> 00:10:13,780
you know it's a PDF,

177
00:10:13,780 --> 00:10:15,520
is a pretty serious document,

178
00:10:15,970 --> 00:10:20,380
and this network card E1000,

179
00:10:20,380 --> 00:10:22,420
even though it's a reasonable simple network card,

180
00:10:22,420 --> 00:10:25,690
is still a very sophisticated piece of hardware,

181
00:10:25,690 --> 00:10:29,680
that offers a lot of different features and ways you can program,

182
00:10:29,710 --> 00:10:32,260
and you're just getting on top of actually

183
00:10:32,260 --> 00:10:35,770
what you know the card does and how do you program it,

184
00:10:36,040 --> 00:10:41,680
you know just internalizing all that is difficult and poses a challenge.

185
00:10:46,520 --> 00:10:50,960
Second, I think you know major challenges, the concurrency side of things,

186
00:10:52,620 --> 00:10:57,270
and there's sort of two parts the concurrency that makes this lab challenging,

187
00:10:57,390 --> 00:11:00,210
one is just the concurrency between the hardware and software,

188
00:11:01,060 --> 00:11:03,700
like the network card is just doing things,

189
00:11:03,700 --> 00:11:06,670
like sending package, receiving packets at the same time,

190
00:11:06,670 --> 00:11:08,770
you know the OS kernel is running and the driver is running,

191
00:11:09,100 --> 00:11:13,420
and so there has to be some coordination plan between the hardware and software,

192
00:11:13,420 --> 00:11:15,790
you know to actually make sure that everything works out,

193
00:11:16,860 --> 00:11:22,800
and a large part of the driver is you know dealing with that coordination.

194
00:11:23,860 --> 00:11:28,180
There's also the software software coordination,

195
00:11:28,540 --> 00:11:31,780
the driver multiple threads, or multiple kernel threads

196
00:11:31,780 --> 00:11:36,100
might be ending around handler run inside of the driver,

197
00:11:36,100 --> 00:11:37,060
and we've got to make sure that,

198
00:11:37,060 --> 00:11:41,470
they don't step on each other's toes, nothing else happens,

199
00:11:41,470 --> 00:11:46,430
and this comes a lot to like you know locking topic.

200
00:11:47,160 --> 00:11:49,140
Even the, even this driver,

201
00:11:49,140 --> 00:11:54,990
thinks a reasonable straightforward, in terms of the concurrency for software concurrency,

202
00:11:55,020 --> 00:11:58,440
but nevertheless you know something that requires attention and a little bit of thinking.

203
00:11:59,260 --> 00:12:04,330
And finally I guess that was probably on the top of your list or many of your list,

204
00:12:04,330 --> 00:12:07,450
just debugging this is a little bit hard,

205
00:12:08,070 --> 00:12:10,740
a little bit something more challenging of pure software debugging,

206
00:12:10,740 --> 00:12:14,490
because you can't set breakpoints inside of the network card,

207
00:12:14,550 --> 00:12:17,340
you know you're in program the registers,

208
00:12:17,340 --> 00:12:20,490
and then this would give the card a kick and say like please do your work,

209
00:12:20,970 --> 00:12:22,710
and then if the card doesn't do anything

210
00:12:22,710 --> 00:12:24,990
or you don't see your packet coming out on the other side,

211
00:12:24,990 --> 00:12:29,720
you know in the log of the packet rates,

212
00:12:30,050 --> 00:12:32,750
then you basically have to scratch your head

213
00:12:32,750 --> 00:12:36,110
and start thinking about what you might have gone wrong

214
00:12:36,110 --> 00:12:39,350
or what you might have missed in the hardware specification,

215
00:12:40,220 --> 00:12:42,530
and you have to circle back and forth,

216
00:12:42,530 --> 00:12:44,630
and there's no sort of easy way,

217
00:12:44,630 --> 00:12:49,870
you just cannot single step you know through the network card.

218
00:12:52,550 --> 00:12:54,290
Does that make sense in terms of challenges,

219
00:12:54,290 --> 00:12:56,840
you know there's that line up with your own experience

220
00:12:56,840 --> 00:12:58,670
or I missing some of the,

221
00:12:59,410 --> 00:13:01,930
missing one of the core challenges that you dealt with.

222
00:13:18,330 --> 00:13:20,490
Okay, well, yeah.

223
00:13:21,390 --> 00:13:22,350
Let's talk to the,

224
00:13:22,350 --> 00:13:24,360
let's start with the hardware side of things,

225
00:13:24,450 --> 00:13:27,870
and the reason I want to start there,

226
00:13:27,870 --> 00:13:31,380
because you know, it's so easy to keep or lose track of the fact,

227
00:13:31,380 --> 00:13:33,000
that you're actually dealing with hardware here,

228
00:13:33,360 --> 00:13:38,820
you know even through you know sort of virtualized where it is emulated by QEMU,

229
00:13:38,820 --> 00:13:42,810
and you're just running it on your, on Athena or your laptop,

230
00:13:42,960 --> 00:13:46,410
the actual thing that's implemented by QEMU is hardware.

231
00:13:46,590 --> 00:13:48,000
So it's usually gonna remind you again,

232
00:13:48,240 --> 00:13:50,880
you've seen this picture before,

233
00:13:50,880 --> 00:13:52,680
you know the way to think about it is that,

234
00:13:52,680 --> 00:13:59,100
you know QEMU emulate a complete board of devices and processor.

235
00:13:59,750 --> 00:14:01,700
And.

236
00:14:04,220 --> 00:14:07,520
And so we all know, I'm talk a little bit before about,

237
00:14:07,520 --> 00:14:13,700
the processor actually these are like almost like a small piece of the whole board,

238
00:14:13,700 --> 00:14:15,440
you know the thing that sits under the fan here,

239
00:14:15,680 --> 00:14:19,010
but then there's a range of devices,

240
00:14:19,010 --> 00:14:22,310
you know that are connected or can be connected to this board,

241
00:14:22,640 --> 00:14:26,840
and then interact you know with the code running on the processor,

242
00:14:26,840 --> 00:14:29,210
you know here use this particular lab,

243
00:14:29,210 --> 00:14:30,740
what is really interesting sort of,

244
00:14:31,280 --> 00:14:32,930
it is actually Ethernet jack,

245
00:14:33,050 --> 00:14:34,970
where you can plug Ethernet cable,

246
00:14:34,970 --> 00:14:38,660
and then the other is actually the thing that the network card you know sends its package over.

247
00:14:40,440 --> 00:14:44,250
You know, QEMU doesn't emulate exactly this board,

248
00:14:44,520 --> 00:14:45,690
so things like are slightly differently,

249
00:14:45,690 --> 00:14:47,850
but again you know at least conceptually,

250
00:14:47,850 --> 00:14:50,700
this is like the picture, you should have in your in your head, right,

251
00:14:50,700 --> 00:14:54,210
and so when there's a process writing registers,

252
00:14:54,210 --> 00:14:57,540
you know of the device driver that costs some stuff to happen,

253
00:14:57,540 --> 00:15:00,000
that actually in the end some packages comes out of this cable,

254
00:15:00,240 --> 00:15:03,370
that's connected to Ethernet connector.

255
00:15:05,840 --> 00:15:08,600
You know in a slightly more,

256
00:15:08,690 --> 00:15:16,940
you know in a slightly more in a schematic diagram,

257
00:15:16,940 --> 00:15:19,430
you know this is the same picture basically in here,

258
00:15:19,430 --> 00:15:21,440
you know we're seeing here is our processor,

259
00:15:21,920 --> 00:15:24,230
board that has four cores on it,

260
00:15:24,440 --> 00:15:26,960
it has l1 and l2 cache,

261
00:15:26,960 --> 00:15:29,420
and then there's like a link you know go to memory,

262
00:15:29,570 --> 00:15:32,690
so here's a memory, and the RAM random access memory,

263
00:15:32,690 --> 00:15:34,250
and as we'll see in a second,

264
00:15:34,250 --> 00:15:36,110
you know that play is actually big role.

265
00:15:36,520 --> 00:15:39,370
And here like intersection to link you know to the,

266
00:15:39,730 --> 00:15:43,000
for here actually it's linked to the gigabit Ethernet controller,

267
00:15:44,350 --> 00:15:47,550
you know, just a little bit messy,

268
00:15:47,550 --> 00:15:51,870
you know sort of think about the this level of detail what exactly is going on.

269
00:15:51,930 --> 00:15:53,160
And so for the rest of lecture,

270
00:15:53,160 --> 00:15:56,040
here a little bit more simpler picture,

271
00:15:58,240 --> 00:16:01,450
and the picture guys really you should you're in your head

272
00:16:01,780 --> 00:16:06,340
and you probably developed while doing lab is as follows.

273
00:16:07,780 --> 00:16:14,290
Basically have are basically four processors or cores,

274
00:16:15,470 --> 00:16:16,880
here's are RISC-V,

275
00:16:19,120 --> 00:16:22,450
and then there's RISC-V of cores

276
00:16:22,450 --> 00:16:26,020
and execute instructions you know you're writing,

277
00:16:26,170 --> 00:16:27,580
and you can just think about them,

278
00:16:27,580 --> 00:16:29,560
they're sort of all connected to your bus,

279
00:16:29,560 --> 00:16:31,840
and then there's a little bit of simplification,

280
00:16:31,840 --> 00:16:34,360
but like it makes it easier to explain things.

281
00:16:34,780 --> 00:16:37,870
And so on the bus, you know there's the random access memory,

282
00:16:40,030 --> 00:16:43,960
where all the data you know the kernel actually uses store,

283
00:16:43,960 --> 00:16:45,670
the kernel [] that itself stores,

284
00:16:45,670 --> 00:16:48,610
you know look at there's a great amount of detail in the beginning of the semester.

285
00:16:49,000 --> 00:16:50,860
And then this you know for this particular lab,

286
00:16:50,860 --> 00:16:52,960
the thing that's interesting is that on the bus,

287
00:16:53,570 --> 00:16:59,360
is actually the network card you know E1000, that E1000.

288
00:17:01,910 --> 00:17:06,680
And you know the RAM is generally more connected to the RISC-V processor

289
00:17:06,680 --> 00:17:08,150
directly with some private bus,

290
00:17:08,330 --> 00:17:13,250
and network devices tend to be on a slower type of bus,

291
00:17:13,460 --> 00:17:15,530
in particular bus that in the lab,

292
00:17:15,530 --> 00:17:19,010
you know there's a PCIe PCIe bus,

293
00:17:19,010 --> 00:17:24,090
that actually connects the processor part you know with the network part.

294
00:17:27,260 --> 00:17:29,870
You know to get the network to do something,

295
00:17:29,990 --> 00:17:33,710
the network card has controller inside of it,

296
00:17:33,710 --> 00:17:35,960
and you know these controller has registers,

297
00:17:37,690 --> 00:17:38,890
and you can,

298
00:17:39,460 --> 00:17:42,250
one of the cool aspects of you know these registers,

299
00:17:42,250 --> 00:17:46,180
they are called memory mapped IO registers,

300
00:17:46,390 --> 00:17:47,890
and so you could just write them

301
00:17:47,890 --> 00:17:52,870
with whatever a star you know, 0x and whatever the value is

302
00:17:52,870 --> 00:17:55,180
you know for in the physical memory space,

303
00:17:55,330 --> 00:17:57,310
what the value is for that particular register,

304
00:17:57,760 --> 00:18:01,290
you know, like we might have our head, our tail registers.

305
00:18:02,260 --> 00:18:05,740
And you know we can, the driver can write those

306
00:18:05,740 --> 00:18:08,410
by executing load or store instruction

307
00:18:08,710 --> 00:18:13,450
you know to the address you know of corresponds you know in the physical address space

308
00:18:13,570 --> 00:18:15,220
to the location of that register.

309
00:18:15,770 --> 00:18:18,620
And the hardware will ensure when we do load or store,

310
00:18:18,710 --> 00:18:21,950
you know that that store will either go you know go to the,

311
00:18:22,660 --> 00:18:25,900
if it is one of the control register, will go to the control registers,

312
00:18:25,900 --> 00:18:29,470
if the go one address is in RAM, will go to the RAM.

313
00:18:31,270 --> 00:18:35,050
So you can just manipulate the program network card

314
00:18:35,050 --> 00:18:38,590
by loading, reading and writing these control registers,

315
00:18:38,590 --> 00:18:42,310
and basically bits in these control registers have special meaning as you have seen.

316
00:18:43,570 --> 00:18:46,490
Now, for this particular card

317
00:18:46,490 --> 00:18:49,790
you know network needs to send packets across the network,

318
00:18:49,940 --> 00:18:52,070
and you know it needs to get the packet somewhere.

319
00:18:53,010 --> 00:18:55,770
And so, the packets actually live,

320
00:18:55,800 --> 00:18:58,320
you know are allocated as we'll see in a second

321
00:18:58,320 --> 00:18:59,820
you know just live somewhere in memory,

322
00:19:01,930 --> 00:19:04,840
and and what we do is,

323
00:19:05,110 --> 00:19:06,910
in fact, in addition to these packets,

324
00:19:06,910 --> 00:19:09,910
you know there's sort of two ring structures that also live in memory.

325
00:19:14,420 --> 00:19:20,710
And, and we can you know program,

326
00:19:20,800 --> 00:19:22,960
and we can tell the card,

327
00:19:22,960 --> 00:19:25,540
you know the card also knows where these ring structures are,

328
00:19:26,230 --> 00:19:28,900
you know it has address where to you know tx ring is,

329
00:19:28,900 --> 00:19:32,400
you know it has an address where to rx ring is,

330
00:19:32,850 --> 00:19:37,530
and you know the hardware card looks at those addresses

331
00:19:37,530 --> 00:19:39,720
to actually see which packets need to be sent,

332
00:19:39,840 --> 00:19:43,710
so here we might have a queue of packets that need to be transmitted

333
00:19:43,710 --> 00:19:45,690
or a queue packets that need to be received.

334
00:19:48,910 --> 00:19:55,610
And, you know the E1000 you know DMAs,

335
00:19:55,610 --> 00:20:01,130
you know for example like you know they're going to work on the first packet to sent,

336
00:20:01,130 --> 00:20:06,290
it will DMA basically you know those packets data associated with the the packets,

337
00:20:06,440 --> 00:20:09,260
you know straight from RAM to the network,

338
00:20:09,980 --> 00:20:12,350
without actually having the processor involved at all,

339
00:20:13,400 --> 00:20:15,110
what is called DMA, direct memory access.

340
00:20:19,130 --> 00:20:19,910
Okay?

341
00:20:21,890 --> 00:20:25,220
Does this makes sense in terms of a more abstract picture

342
00:20:25,250 --> 00:20:32,120
for the organization of the RISC-V RAM and E1000.

343
00:20:33,070 --> 00:20:34,330
Any questions about this?

344
00:20:41,500 --> 00:20:45,490
So, one thing in talking about hardware, software concurrency,

345
00:20:45,550 --> 00:20:49,690
clearly you know the E1000 and you know the processor

346
00:20:49,690 --> 00:20:56,560
are both manipulating these transmission and reception queues or rings.

347
00:20:57,030 --> 00:20:58,650
And so, there has to be some protocol

348
00:20:58,860 --> 00:21:01,170
sort of given taken give and take protocol,

349
00:21:01,230 --> 00:21:02,910
where you know at some point,

350
00:21:03,030 --> 00:21:08,790
particular parts of the ring are operated, are owned or operated by the network card,

351
00:21:08,790 --> 00:21:12,840
and there are parts that are maybe under control of the software or the OS kernel.

352
00:21:13,500 --> 00:21:15,750
And you'll see in a second how that is arranged,

353
00:21:15,960 --> 00:21:17,910
but you know we got a little bit careful,

354
00:21:17,910 --> 00:21:23,220
again, that the card doesn't trip over or trip over the operating system

355
00:21:23,220 --> 00:21:24,090
or the other way around.

356
00:21:28,540 --> 00:21:29,350
A quick question,

357
00:21:29,380 --> 00:21:35,140
so is there a separate transmit ring and and receive ring in the RAM

358
00:21:35,140 --> 00:21:40,270
and then, also in the E1000 or E1000 driver.

359
00:21:40,570 --> 00:21:41,710
Yeah, well, the one way,

360
00:21:41,710 --> 00:21:43,330
okay, so there's two things going on,

361
00:21:43,330 --> 00:21:44,920
and we look at the code in a second,

362
00:21:45,100 --> 00:21:51,190
the the the transmission ring and receive ring basically lived in RAM,

363
00:21:51,740 --> 00:21:58,730
and both the E1000 and the RISC-V manipulates the ring that actually stored in RAM,

364
00:22:01,140 --> 00:22:04,950
and those are the rings that you saw in the hardware documentation.

365
00:22:05,520 --> 00:22:06,720
It happens to be the case,

366
00:22:06,720 --> 00:22:12,780
that xv6 also has a driver maintains a sort of a ring of mbufs,

367
00:22:13,110 --> 00:22:16,770
separately of the transmit ring and rx ring,

368
00:22:16,830 --> 00:22:18,840
like there's something like tx mbufs.

369
00:22:21,460 --> 00:22:23,500
And that's you know that is the data structure

370
00:22:23,500 --> 00:22:25,420
only the operating system really knows about,

371
00:22:25,840 --> 00:22:28,150
the network card doesn't really know about it,

372
00:22:28,150 --> 00:22:33,760
and network card only knows about the the tx ring and rx ring,

373
00:22:33,850 --> 00:22:37,600
because those are the values that were programmed into the registers,

374
00:22:37,720 --> 00:22:39,490
saying like here's where you can find,

375
00:22:39,490 --> 00:22:41,470
here's the address where you can find the transmit ring,

376
00:22:41,530 --> 00:22:43,270
here's the address where you can find the receive ring.

377
00:22:44,520 --> 00:22:45,450
Okay, that makes sense.

378
00:22:45,660 --> 00:22:46,260
That makes sense?

379
00:22:49,840 --> 00:22:52,000
Okay, so that's sort of the hardware picture,

380
00:22:52,120 --> 00:22:55,750
in a more schematic version.

381
00:22:55,930 --> 00:22:58,180
Let's talk a little bit about the software structure,

382
00:22:59,520 --> 00:23:02,760
there's a big confusing actually in this in this lab.

383
00:23:05,870 --> 00:23:07,010
So software structure.

384
00:23:12,050 --> 00:23:14,990
So, let's just draw you know the thing,

385
00:23:14,990 --> 00:23:17,330
that we most care about of course you know the driver,

386
00:23:17,360 --> 00:23:21,970
so here's our driver, the e1000 driver.

387
00:23:26,150 --> 00:23:28,790
And it basically has only two functions,

388
00:23:29,000 --> 00:23:37,600
it has a transmit function and it has a receive function.

389
00:23:40,810 --> 00:23:44,530
And the receive function runs in response to interrupts,

390
00:23:46,300 --> 00:23:47,560
so an interrupt happens,

391
00:23:48,550 --> 00:23:53,860
then you know xv6 you will use the usual interrupt mechanism,

392
00:23:53,860 --> 00:23:55,150
you know a trap happen,

393
00:23:55,540 --> 00:23:58,540
trap look you know to see if there's an interrupt from the network card,

394
00:23:58,540 --> 00:23:59,470
if there's an interrupt,

395
00:23:59,470 --> 00:24:01,240
the network card will call the receive function.

396
00:24:02,600 --> 00:24:03,860
And as you remember,

397
00:24:03,860 --> 00:24:07,490
we used to have one of the previous lectures about device drivers,

398
00:24:07,580 --> 00:24:11,270
you know it's often helpful to think of the device drivers were split in two parts,

399
00:24:11,760 --> 00:24:16,530
you know the bottom half which runs in the context of of interrupt handler,

400
00:24:18,160 --> 00:24:20,320
typically [name] for those in the top half,

401
00:24:22,880 --> 00:24:29,360
which generally runs in the context of you know kernel process or like a user level process,

402
00:24:29,360 --> 00:24:32,750
so for example if you think about things that sit on top of here,

403
00:24:32,930 --> 00:24:36,110
there's the network stack code,

404
00:24:36,110 --> 00:24:40,910
that actually implements you know IP UDP and etc, sit above this.

405
00:24:41,430 --> 00:24:42,930
And then you know there is,

406
00:24:43,500 --> 00:24:46,110
you know, our usual you know sort of line,

407
00:24:47,160 --> 00:24:50,220
you know kernel space below, user space up,

408
00:24:50,220 --> 00:24:53,250
and you know this is [] OS view of the world,

409
00:24:53,250 --> 00:24:56,820
where user space not particularly that big or important,

410
00:24:57,090 --> 00:25:02,580
and you know for example are whatever nettest in the user level program

411
00:25:03,090 --> 00:25:06,360
runs in user space and it makes system calls,

412
00:25:06,780 --> 00:25:10,650
system calls go to the network stack,

413
00:25:11,010 --> 00:25:19,120
for example like if you knew calls the write system call with a file descriptor,

414
00:25:19,420 --> 00:25:22,630
the kernel knows you know for that file descriptor, if you do write,

415
00:25:22,630 --> 00:25:25,360
then you know the write should go to the network stack,

416
00:25:25,540 --> 00:25:27,520
the network stack builds up the packets,

417
00:25:27,700 --> 00:25:29,260
and then it calls transmit.

418
00:25:30,830 --> 00:25:35,090
And then transmit whatever manipulates the transmission queue,

419
00:25:35,090 --> 00:25:36,530
that the tx queue or ring,

420
00:25:36,710 --> 00:25:39,980
and you know that actually gets packets you know of network,

421
00:25:40,010 --> 00:25:42,590
at some point a response might go back come back,

422
00:25:42,590 --> 00:25:44,120
you know that will generate an interrupt,

423
00:25:44,270 --> 00:25:45,890
and then the recv function will run

424
00:25:45,890 --> 00:25:50,090
and inspect you know the receive ring, right.

425
00:25:50,760 --> 00:25:53,010
So there's a couple things that you know wanna,

426
00:25:53,560 --> 00:25:57,460
I want to point out you know in terms of concurrency.

427
00:25:58,060 --> 00:26:00,670
And so, first of all, like the interrupt handler,

428
00:26:00,670 --> 00:26:03,520
basically can run at any instant in time, right,

429
00:26:03,520 --> 00:26:05,380
you know you might be user space,

430
00:26:05,380 --> 00:26:06,490
and if interrupt comes in

431
00:26:06,520 --> 00:26:09,190
you know the interrupt mechanism will cause

432
00:26:09,190 --> 00:26:12,790
you know the current user program to switch to the kernel mode,

433
00:26:12,790 --> 00:26:15,220
you know the trap functionality of code,

434
00:26:15,220 --> 00:26:16,330
we've seen before it runs,

435
00:26:16,330 --> 00:26:17,770
and it will all received.

436
00:26:17,770 --> 00:26:20,230
So we might be in the middle of some user process,

437
00:26:20,230 --> 00:26:21,640
in boom, we get an interrupt

438
00:26:21,640 --> 00:26:23,080
and suddenly we're in the recv function.

439
00:26:23,900 --> 00:26:24,890
And even in the kernel,

440
00:26:24,890 --> 00:26:26,630
like if we're not holding locks,

441
00:26:26,630 --> 00:26:28,070
you know locks turn interrupts off,

442
00:26:28,070 --> 00:26:29,330
but we're not holding locks,

443
00:26:29,330 --> 00:26:30,620
we could get an interrupt,

444
00:26:30,620 --> 00:26:36,770
and the kernel may change the program counter basically to the interrupt handler

445
00:26:36,770 --> 00:26:38,750
and run the recv function.

446
00:26:39,560 --> 00:26:42,530
So this code sort of runs you know the things that in the bottom half,

447
00:26:42,530 --> 00:26:45,200
you know can basically run instantly almost anytime.

448
00:26:45,950 --> 00:26:48,560
In the code, in the top half,

449
00:26:48,650 --> 00:26:53,300
it really operates on behalf of a user level processes or kernel threads,

450
00:26:53,300 --> 00:26:57,510
that actually make calls into the top half.

451
00:26:58,080 --> 00:26:59,760
You know easily could have been the case,

452
00:27:00,060 --> 00:27:02,160
in fact this is the case even in nettest,

453
00:27:02,160 --> 00:27:07,170
we might actually have nettest for a whole bunch of processes,

454
00:27:07,470 --> 00:27:10,200
that we have actually many instances, one of the tests,

455
00:27:10,230 --> 00:27:12,210
we have many instances of nettest running,

456
00:27:14,700 --> 00:27:17,190
and they all jump into the network stack,

457
00:27:17,190 --> 00:27:20,370
and they all you know then called transmit, right.

458
00:27:20,820 --> 00:27:21,900
So that is the case,

459
00:27:21,900 --> 00:27:24,240
so we're looking at this from the perspective concurrency,

460
00:27:24,420 --> 00:27:28,020
multiple senders can be actually in the context,

461
00:27:28,020 --> 00:27:29,280
it can be in the top half,

462
00:27:29,310 --> 00:27:30,510
and so it's pretty clear,

463
00:27:30,510 --> 00:27:34,260
you know we need some locking scheme or discipline

464
00:27:34,260 --> 00:27:38,640
to at least make sure that different senders don't trip over each other.

465
00:27:40,380 --> 00:27:41,910
Then on the bottom half,

466
00:27:42,480 --> 00:27:44,970
there's only one interrupt handler, correct,

467
00:27:45,060 --> 00:27:48,360
there's never in the case that the receive is going to be called by multiple,

468
00:27:48,570 --> 00:27:52,710
there's multiple receivers running at the same time in parallel on different cores,

469
00:27:52,710 --> 00:27:57,000
you know the the interrupt handler when an interrupt happens,

470
00:27:57,270 --> 00:27:59,130
the process is alert it,

471
00:27:59,560 --> 00:28:02,260
and if future interrupts happen,

472
00:28:02,260 --> 00:28:06,610
they're actually blocked until the current interrupt actually dealt with,

473
00:28:06,820 --> 00:28:11,670
and so in fact, when the recv function runs,

474
00:28:11,910 --> 00:28:15,450
there's actually only one interrupt handler running,

475
00:28:15,450 --> 00:28:18,030
at the time that calls for recv.

476
00:28:18,760 --> 00:28:24,360
And so there's no real immediately concurrency in recv itself,

477
00:28:24,360 --> 00:28:31,200
although of course the transmit you know threads can run concurrently with the interrupt handler,

478
00:28:31,200 --> 00:28:34,110
for example, we might have one core running an interrupt handler,

479
00:28:34,320 --> 00:28:37,950
may have another core actually is about to transmit.

480
00:28:39,860 --> 00:28:43,530
This, any questions about this?

481
00:28:45,870 --> 00:28:50,540
It's sort of important to have, to understand.

482
00:28:51,310 --> 00:28:53,350
It's a bit of review but it's important too.

483
00:29:00,400 --> 00:29:01,000
Okay, so.

484
00:29:01,030 --> 00:29:03,700
I guess, I have a general question,

485
00:29:03,790 --> 00:29:05,020
how do we know,

486
00:29:05,740 --> 00:29:09,760
what is supposed to be classified as a bottom half and the top half?

487
00:29:10,430 --> 00:29:13,250
So, yeah, I think the way to think about it is that,

488
00:29:13,250 --> 00:29:15,410
anything that runs in the context of an interrupt handler,

489
00:29:15,440 --> 00:29:16,280
that's the bottom half,

490
00:29:17,330 --> 00:29:19,370
and in this case is basically just receive.

491
00:29:20,700 --> 00:29:26,410
And anything that runs in the context of regular process or thread kernel thread,

492
00:29:26,440 --> 00:29:27,880
you know that's the top half.

493
00:29:32,200 --> 00:29:37,720
Okay, so if you look at this picture a little bit more,

494
00:29:38,080 --> 00:29:38,860
since where,

495
00:29:39,010 --> 00:29:41,770
actually let me have a high level statement here,

496
00:29:41,920 --> 00:29:45,280
a lot of people ask you know why no locking receive,

497
00:29:46,320 --> 00:29:49,620
and where is lock needed.

498
00:29:49,950 --> 00:29:53,070
And so the first glance,

499
00:29:53,680 --> 00:29:56,200
it might not be necessary to lock if necessary, correct,

500
00:29:56,200 --> 00:29:59,710
because there's only one instance of receive running,

501
00:29:59,740 --> 00:30:02,620
so there's not multiple instances of receive running at the same time,

502
00:30:02,770 --> 00:30:03,940
and so these receives,

503
00:30:03,970 --> 00:30:05,170
since there's only one receive,

504
00:30:05,200 --> 00:30:07,450
it doesn't share data structures with any other receive,

505
00:30:07,450 --> 00:30:08,860
because there's only one of them, right.

506
00:30:09,380 --> 00:30:10,850
Now, of course it could be the case,

507
00:30:10,850 --> 00:30:13,640
that the receiver and the transmitter shared data structures,

508
00:30:13,670 --> 00:30:16,340
but as we see in a second that actually is not the case,

509
00:30:16,860 --> 00:30:20,730
basically the transmission part of the driver is completely separate from

510
00:30:20,730 --> 00:30:24,900
the reception part of the driver, receiving packets.

511
00:30:25,380 --> 00:30:29,400
And so as a result, receive doesn't really, doesn't need actually locks,

512
00:30:29,430 --> 00:30:32,700
you know it's really not sharing data structures with any other concurrent activity.

513
00:30:34,400 --> 00:30:37,910
Weird part is that you know some of you found out,

514
00:30:37,910 --> 00:30:41,380
if you do use a lock, you actually get a panic.

515
00:30:42,100 --> 00:30:44,470
And so let me say a little bit about that,

516
00:30:44,470 --> 00:30:47,830
because the reason that panic happens is,

517
00:30:47,830 --> 00:30:48,790
a little bit because there's,

518
00:30:48,790 --> 00:30:54,610
this the software structure actually in in xv6 kernel slightly,

519
00:30:56,740 --> 00:30:58,750
slightly more complicated than you might think,

520
00:30:58,960 --> 00:31:00,760
and the reason is that

521
00:31:00,760 --> 00:31:04,630
basically the receive interrupt handler just quite a bit of work,

522
00:31:05,140 --> 00:31:06,790
or can do quite a bit of work,

523
00:31:07,090 --> 00:31:08,470
so let me talk a little bit about it.

524
00:31:09,430 --> 00:31:12,700
In the particular case that actually does quite a bit of work,

525
00:31:12,700 --> 00:31:16,550
for example ARP requests,

526
00:31:20,180 --> 00:31:23,690
ARP is one of those packet types that Robert talked about a little while ago,

527
00:31:23,990 --> 00:31:26,720
but basically what happens like an interrupt comes in,

528
00:31:27,570 --> 00:31:35,700
so an ARP request for discovery the ethernet addresses where an IP address you know comes in,

529
00:31:35,700 --> 00:31:39,620
you know that will call you know eth1000_recv,

530
00:31:43,400 --> 00:31:46,700
and you know that will call whatever net_rx,

531
00:31:46,700 --> 00:31:51,500
so that will go call into the network stack on the previous pictures,

532
00:31:51,500 --> 00:31:55,280
so that receives calls into this code over here,

533
00:31:56,460 --> 00:31:59,190
net receive you know calls,

534
00:32:03,540 --> 00:32:10,680
oops net receive calls net_rx_arp,

535
00:32:12,690 --> 00:32:16,560
and it and you know it looks you know there's an ARP packet,

536
00:32:16,560 --> 00:32:24,000
and basically sends back the ethernet address for this particular for xv6,

537
00:32:24,210 --> 00:32:27,270
and then the way it does that of course you know to send the packet,

538
00:32:27,270 --> 00:32:36,860
it will call you know, e1000_transmit right,

539
00:32:36,860 --> 00:32:40,280
and you know we know that will actually need to acquire a lock,

540
00:32:42,070 --> 00:32:45,550
well, you did that you know whatever there's eth1000_lock.

541
00:32:50,860 --> 00:32:53,020
The reason that actually has to go on a lock is,

542
00:32:53,020 --> 00:32:54,910
because there might be multiple senders

543
00:32:54,910 --> 00:32:59,350
and you know the senders should not trip over over, trip over each other.

544
00:33:00,440 --> 00:33:02,270
So that's sort of the picture,

545
00:33:02,270 --> 00:33:04,520
so what we're basically in terms of this previous picture,

546
00:33:04,520 --> 00:33:05,840
what we're seeing here is that,

547
00:33:06,590 --> 00:33:12,770
the bottom half may end up call the code in the top half,

548
00:33:12,950 --> 00:33:16,010
and come back into the driver through the top half.

549
00:33:17,400 --> 00:33:20,940
And a number of you know you run into trouble with that,

550
00:33:20,940 --> 00:33:25,170
because you know the you know it's not 100% clear,

551
00:33:25,170 --> 00:33:29,610
that you didn't need a locks in the receiving part,

552
00:33:29,730 --> 00:33:32,070
and so quite a number of you run into this particular bug,

553
00:33:32,070 --> 00:33:43,700
where you're actually required the you know eth1000_lock in receive.

554
00:33:45,460 --> 00:33:46,750
And that worked all fine correctly,

555
00:33:46,750 --> 00:33:48,400
except once in a while you get a panic,

556
00:33:49,670 --> 00:33:51,110
why do you get the panic,

557
00:33:52,140 --> 00:33:54,060
hopefully with this picture, that's pretty clear about.

558
00:33:59,400 --> 00:34:01,590
I mean, isn't it going to be the same lock,

559
00:34:01,590 --> 00:34:05,280
because that the e1000_transmit is going to try to acquire eth1000_lock.

560
00:34:05,610 --> 00:34:07,020
Yeah exactly, correct,

561
00:34:07,380 --> 00:34:10,890
so eth1000 here at this point now owns the lock, holds it,

562
00:34:10,890 --> 00:34:14,280
calls net_rx, calls net_rx_arp, e1000_transmit,

563
00:34:14,280 --> 00:34:15,420
then calls acquire again,

564
00:34:15,780 --> 00:34:17,760
and as you might remember from previous labs,

565
00:34:17,940 --> 00:34:21,240
if require it's called it's already held,

566
00:34:21,610 --> 00:34:23,440
that's a deadlock right,

567
00:34:23,440 --> 00:34:25,600
and so xv6 kernel panics.

568
00:34:28,240 --> 00:34:32,620
Question, let's let's assume we had a slightly different implementation of locks,

569
00:34:32,620 --> 00:34:34,630
such as those functions are not occur,

570
00:34:35,480 --> 00:34:37,220
like it would such,

571
00:34:37,400 --> 00:34:40,010
let's assume like if I wanted to acquire a lock already held,

572
00:34:40,010 --> 00:34:40,820
nothing happened.

573
00:34:41,060 --> 00:34:45,110
Yeah so, these are these are called recursive locks,

574
00:34:47,660 --> 00:34:50,750
or reentrant locks is another way the name for them.

575
00:34:51,580 --> 00:34:54,460
And so if you have a recursive locks, reentrant locks,

576
00:34:54,460 --> 00:34:56,530
then you know you could freely do this

577
00:34:56,530 --> 00:34:57,520
and it would be no problem.

578
00:34:58,170 --> 00:35:01,890
And I think one of you over email mentioned to me,

579
00:35:01,890 --> 00:35:05,970
that actually the implemented recursive locks to actually deal with this particular problem.

580
00:35:06,660 --> 00:35:11,100
And so they did required to lock in the eth1000_recv function,

581
00:35:11,370 --> 00:35:14,010
and you know after the panic,

582
00:35:14,010 --> 00:35:16,770
basically fixed acquire release in the xv6

583
00:35:16,770 --> 00:35:18,720
[direction] support recursive locks.

584
00:35:20,760 --> 00:35:21,810
And that would be a solution.

585
00:35:23,240 --> 00:35:25,820
The simple solution, it's a fine solution,

586
00:35:25,880 --> 00:35:31,970
the solution that we intended and the staff solution as is

587
00:35:31,970 --> 00:35:35,120
basically just doesn't require locks in receive at all,

588
00:35:35,120 --> 00:35:37,100
because it actually turned out not to be necessary.

589
00:35:39,910 --> 00:35:41,110
Sorry, can you say again,

590
00:35:41,110 --> 00:35:45,070
why there couldn't be two threads in receive?

591
00:35:46,550 --> 00:35:49,310
There's only one thread in receive, the interrupt handler runs,

592
00:35:49,930 --> 00:35:53,200
there's only one receive function ever running at the time on any core,

593
00:35:54,110 --> 00:36:00,770
that actually calls into the top half of the, the top half of the operating system

594
00:36:01,160 --> 00:36:04,280
and that calles back out into the bottom half,

595
00:36:05,180 --> 00:36:07,940
sorry not in the bottom, that calls back into e1000_transmit

596
00:36:07,940 --> 00:36:09,980
and transmit definitely needs to acquire a lock,

597
00:36:10,430 --> 00:36:16,840
so even receive, eth1000_recv, while holding the lock calls e1000_transmit,

598
00:36:16,900 --> 00:36:20,650
which tries to acquire the same lock that the interrupt handler already holds,

599
00:36:21,600 --> 00:36:25,080
if you have, if you locked in receive handler.

600
00:36:26,830 --> 00:36:30,270
I see, so so it is the case,

601
00:36:30,270 --> 00:36:33,060
like one interrupt can go off

602
00:36:33,060 --> 00:36:36,270
and then while it's still running,

603
00:36:36,390 --> 00:36:39,510
another interrupt could go off as well, is.

604
00:36:39,510 --> 00:36:42,870
No, no, the picture, maybe go back to this picture,

605
00:36:43,170 --> 00:36:46,370
so interrupt happens, that calls the receive function,

606
00:36:46,760 --> 00:36:48,500
there's only one receive function running,

607
00:36:48,620 --> 00:36:53,390
that receive function calls you know rx net receive,

608
00:36:53,390 --> 00:36:55,220
that calls rx net_rx_arp,

609
00:36:55,430 --> 00:36:58,040
and that arp function calls transmit,

610
00:36:58,740 --> 00:37:02,460
and if you were using the same lock in transmit and receive,

611
00:37:02,580 --> 00:37:03,870
you know you would get a deadlock.

612
00:37:08,100 --> 00:37:09,600
Okay I see, thank you.

613
00:37:13,660 --> 00:37:14,710
That's sort of, yeah, okay,

614
00:37:15,540 --> 00:37:17,430
and so basically the two solutions to this,

615
00:37:17,460 --> 00:37:19,440
one is to use recursive locks,

616
00:37:20,370 --> 00:37:24,560
other solution was no locks in receive,

617
00:37:25,790 --> 00:37:27,740
or you know have two locks.

618
00:37:31,040 --> 00:37:33,260
All three of them are totally reasonable solutions.

619
00:37:37,000 --> 00:37:38,050
Any questions about this?

620
00:37:39,070 --> 00:37:42,610
Would there be a reason to have a lock around receive at all?

621
00:37:42,910 --> 00:37:44,770
No, in this particular case,

622
00:37:44,770 --> 00:37:46,360
there's no reason to have a lock at all.

623
00:37:49,540 --> 00:37:52,570
What would be, could we think of a situation

624
00:37:52,570 --> 00:37:54,490
where you would want a receive lock,

625
00:37:54,490 --> 00:37:57,970
would be like if you had two network cards or something.

626
00:37:58,550 --> 00:38:03,620
Yeah, or if you like if you remember in the UART code,

627
00:38:03,980 --> 00:38:10,760
okay, so may a common reason why you might want to have a locking shared is,

628
00:38:10,760 --> 00:38:15,020
because the bottom half and the top half shared data structures.

629
00:38:17,200 --> 00:38:21,850
So, for example the receive and transmit might manipulate the same shared data structures,

630
00:38:22,090 --> 00:38:24,100
at that point you need you need a lock,

631
00:38:24,160 --> 00:38:26,560
and so for example you remember from your console driver,

632
00:38:27,060 --> 00:38:28,320
they shared a queue,

633
00:38:29,100 --> 00:38:32,970
and so receive handler needed to get queue,

634
00:38:33,120 --> 00:38:35,550
need to get the lock to actually get access to that queue.

635
00:38:39,480 --> 00:38:40,680
Does that answer your question?

636
00:38:42,500 --> 00:38:43,580
Yeah, thanks.

637
00:38:44,720 --> 00:38:47,510
And so this brings me up with a second sort of point I wanted to make.

638
00:38:48,230 --> 00:38:52,700
That the let me actually draw a new picture,

639
00:38:52,700 --> 00:38:53,930
because it gets a little crowded.

640
00:38:54,350 --> 00:38:57,740
We think about this bottom half again, and the top half.

641
00:39:00,670 --> 00:39:01,450
So here's the bottom,

642
00:39:01,450 --> 00:39:04,390
a little bit abstract, but you know it may be helpful.

643
00:39:07,110 --> 00:39:11,610
In much typically in much software, driver software,

644
00:39:11,640 --> 00:39:16,560
the bottom half basically doesn't really call into the top half at all.

645
00:39:17,360 --> 00:39:20,870
So, for example if you go back and you look at the console code,

646
00:39:21,080 --> 00:39:24,500
this sequence of the sequence cannot happen there,

647
00:39:24,530 --> 00:39:25,880
and the reason doesn't happen is,

648
00:39:25,880 --> 00:39:28,310
because the bottom half typically does very little work,

649
00:39:28,550 --> 00:39:30,890
the only thing it does maybe you grab the packet,

650
00:39:31,100 --> 00:39:32,330
stick the packet in the queue.

651
00:39:34,000 --> 00:39:35,560
And then, at some point later,

652
00:39:35,680 --> 00:39:40,980
you know the the top half, you know there's a separate thread in the top half,

653
00:39:40,980 --> 00:39:43,590
that basically looks at that queue and then grabs packets out of the queue,

654
00:39:43,590 --> 00:39:45,570
and then keeps on doing whatever needs to be done.

655
00:39:46,400 --> 00:39:51,650
Now, for simplicity a in this simplicity and reduce the amount of code,

656
00:39:51,860 --> 00:39:54,620
that is not the structure that these particular driver follows,

657
00:39:54,830 --> 00:39:58,800
this driver once in a while may actually call up in,

658
00:39:58,800 --> 00:40:02,840
call up actually sometimes this structure is followed by the driver,

659
00:40:02,840 --> 00:40:05,690
but once in awhile, it can actually go into the top half

660
00:40:05,780 --> 00:40:07,970
and come back out into the bottom half.

661
00:40:15,210 --> 00:40:16,140
Any questions about this?

662
00:40:23,120 --> 00:40:27,500
Okay, so that's sort of I guess software concurrency

663
00:40:27,500 --> 00:40:28,970
and we'll come back to a little more later,

664
00:40:28,970 --> 00:40:30,920
if we look at the code in a bit more detail,

665
00:40:31,440 --> 00:40:33,570
talk a little bit about the rings.

666
00:40:37,540 --> 00:40:39,640
And so basically the way you think about it,

667
00:40:39,640 --> 00:40:42,670
you know there ring,

668
00:40:42,880 --> 00:40:47,260
there's two rings and one for receiving and one for sending,

669
00:40:47,260 --> 00:40:51,790
you know tx rx both lives in RAM.

670
00:40:52,510 --> 00:40:58,600
And you know they're manipulated by code running on the RISC-V cores

671
00:40:58,600 --> 00:41:01,030
and by you know the network card itself.

672
00:41:01,710 --> 00:41:03,060
So there has to be some protocol

673
00:41:03,060 --> 00:41:07,380
between the network card and the RISC-V of course,

674
00:41:07,410 --> 00:41:09,780
about who gets to look at what,

675
00:41:10,020 --> 00:41:15,270
and so the way this is a very common organization in hardware devices,

676
00:41:15,270 --> 00:41:16,680
the way that typically is done,

677
00:41:16,680 --> 00:41:18,690
there's sort of, look at the transmit queue,

678
00:41:18,690 --> 00:41:21,930
there's basically a queue of some fixed size structures descriptors,

679
00:41:21,960 --> 00:41:23,790
as we'll looking in a second,

680
00:41:24,060 --> 00:41:25,230
these are the descriptors.

681
00:41:29,360 --> 00:41:33,320
And the organization or the coordination that is actually

682
00:41:33,320 --> 00:41:39,260
that's happening between the driver and network card is

683
00:41:39,260 --> 00:41:46,140
the consumer producer coordination.

684
00:41:47,430 --> 00:41:49,350
Basically, one way to think about it,

685
00:41:49,350 --> 00:41:52,470
you know there is if this is the transmit queue,

686
00:41:52,470 --> 00:41:54,450
you know there's maybe there's a head pointer,

687
00:41:56,520 --> 00:41:57,840
there's a tail pointer,

688
00:42:00,440 --> 00:42:04,400
and you know this the tail pointer is controlled by the software,

689
00:42:05,580 --> 00:42:07,590
and so the software looks at the tail pointer,

690
00:42:07,590 --> 00:42:10,650
and it wants to send, send another packet,

691
00:42:10,650 --> 00:42:14,910
sticks it you know in a the ring at the location of tail plus one,

692
00:42:14,910 --> 00:42:17,400
and then moves up tail pointer in that direction.

693
00:42:19,240 --> 00:42:22,330
And the head pointer is usually controlled by the hardware.

694
00:42:24,750 --> 00:42:27,030
So tail by software, head by hardware

695
00:42:27,030 --> 00:42:29,820
and basically the you know the hardware basically looks at the head,

696
00:42:29,820 --> 00:42:31,980
and this is the first packet that is going to be sent,

697
00:42:32,040 --> 00:42:34,530
you know there's a little bit of information in the descriptor,

698
00:42:34,680 --> 00:42:38,310
or enough information that descriptor for the network card to look at,

699
00:42:38,310 --> 00:42:43,770
and say like oh this is the bytes that I need to move on to the move on to the cable.

700
00:42:44,950 --> 00:42:48,670
And once it's done, it moves the head pointer in that direction,

701
00:42:48,790 --> 00:42:52,630
once it's consumed you know one of the packets out of the transmission queue.

702
00:42:53,630 --> 00:42:55,160
And one way to think about it is that,

703
00:42:55,430 --> 00:43:01,400
all the descriptors between here, between the tail,

704
00:43:02,540 --> 00:43:05,240
and so all the things that are actually being filled in,

705
00:43:05,720 --> 00:43:08,930
like the tail moved up maybe to here.

706
00:43:12,540 --> 00:43:13,290
You know all the packets,

707
00:43:13,290 --> 00:43:16,200
that are all the descriptor entries that are actually filled in,

708
00:43:16,260 --> 00:43:17,880
the way you think about them is,

709
00:43:18,640 --> 00:43:21,190
they are owned by the hardware owned by the network card.

710
00:43:21,810 --> 00:43:25,230
The network card is allowed to read them, do things with them,

711
00:43:25,350 --> 00:43:29,580
but the software and the software is not allowed to do anything with that,

712
00:43:29,760 --> 00:43:33,780
like if the software would be scribbling over these descriptors,

713
00:43:34,080 --> 00:43:38,880
while they really sort of owned by the hardware by network card,

714
00:43:39,000 --> 00:43:42,240
that would change the data that the network card sees,

715
00:43:42,240 --> 00:43:43,800
and that would be pretty undesirable.

716
00:43:44,460 --> 00:43:47,550
And so, the protocol basically is

717
00:43:47,550 --> 00:43:50,880
that like once you know the software moves the tail pointer one up,

718
00:43:51,060 --> 00:43:56,100
then you know that point you have just moved into the network queue in the transmission queue

719
00:43:56,130 --> 00:43:57,450
is now owned by the hardware,

720
00:43:57,780 --> 00:43:58,950
and it will stick in,

721
00:43:58,950 --> 00:44:03,090
you know it will be owned by the hardware until it has to be sent,

722
00:44:03,210 --> 00:44:07,140
and basically until the head pointer moves past you know that particular structure.

723
00:44:09,890 --> 00:44:10,760
Does that make sense?

724
00:44:18,950 --> 00:44:21,380
Good, for transmission, basically it's the same story,

725
00:44:21,410 --> 00:44:24,230
you know there's a there's a head pointer,

726
00:44:24,880 --> 00:44:30,740
that basically that's controlled by the hardware,

727
00:44:30,770 --> 00:44:32,150
and there's a tail pointer,

728
00:44:32,150 --> 00:44:35,800
that is controlled by, there is the software pointer,

729
00:44:37,340 --> 00:44:39,710
and basically the packets in between

730
00:44:40,840 --> 00:44:47,920
are are packets are actually have been received by the hardware,

731
00:44:47,920 --> 00:44:53,110
and and you know by expecting the tail pointer,

732
00:44:53,110 --> 00:44:55,180
and the software can see if there's actually a new packet,

733
00:44:55,180 --> 00:44:57,850
you know that is ready to be consumed,

734
00:44:57,850 --> 00:44:59,440
and if that ready to be consumed,

735
00:44:59,440 --> 00:45:02,950
the hardware will indicate that by saying that DD bit in the status field.

736
00:45:03,440 --> 00:45:05,210
And so when the DD bit is set,

737
00:45:05,270 --> 00:45:06,740
hardware software are good,

738
00:45:06,770 --> 00:45:09,200
you know these packets, you know the hardware is done with it,

739
00:45:09,530 --> 00:45:13,220
and so it can take it out and move the tail pointer one up.

740
00:45:14,920 --> 00:45:21,700
And so there's sort of this give and take between driver and our hardware

741
00:45:21,730 --> 00:45:24,880
to actually coordinate they don't trip over each other.

742
00:45:27,340 --> 00:45:31,840
Any questions about the rings?

743
00:45:36,200 --> 00:45:36,920
Is this like,

744
00:45:36,980 --> 00:45:41,810
is this a universal way to kind of implement,

745
00:45:41,810 --> 00:45:45,680
like user or any kind of communication between two things that have shared memory?

746
00:45:46,270 --> 00:45:49,090
Yeah, it's a pretty certainly also in software, you see this,

747
00:45:49,090 --> 00:45:51,880
but many hardware devices play this sort of trick,

748
00:45:52,510 --> 00:46:00,250
where going to producer consumer style coordination between the hardware and software.

749
00:46:05,350 --> 00:46:06,820
So yeah, it's a very common structure.

750
00:46:08,430 --> 00:46:11,250
Maybe one or two questions, you can ask about it,

751
00:46:11,460 --> 00:46:14,280
like why is there actually even a queue, why is there a ring.

752
00:46:14,910 --> 00:46:16,410
Okay, the reason there's a ring correct,

753
00:46:16,410 --> 00:46:20,250
because the queue wraps around, queue wraps around to make it fix size,

754
00:46:21,590 --> 00:46:25,730
but you know, why, why not, you know have queue one entry, one entry,

755
00:46:27,900 --> 00:46:29,190
like it's almost like the UART,

756
00:46:29,550 --> 00:46:32,550
you remember the UART driver and controller

757
00:46:32,550 --> 00:46:35,670
is basically only one register to send a byte

758
00:46:35,670 --> 00:46:37,230
and there's another register receive a byte.

759
00:46:38,880 --> 00:46:42,450
And so why have, why go for this complicated scheme,

760
00:46:42,450 --> 00:46:44,250
you could have yourself a single register,

761
00:46:44,250 --> 00:46:47,040
and then you can basically say you know hardware,

762
00:46:47,040 --> 00:46:48,690
this register is now ready, send it,

763
00:46:49,390 --> 00:46:52,500
and then you just wait until the it's done.

764
00:46:55,300 --> 00:46:59,950
To allow for when there are bursts of packets.

765
00:47:00,480 --> 00:47:02,530
Yeah, yeah exactly,

766
00:47:02,860 --> 00:47:07,750
you know the network interface where the network card or cable is pretty high performance,

767
00:47:07,750 --> 00:47:10,630
in fact very high performance, gigabits per second.

768
00:47:11,310 --> 00:47:14,910
And so, it can be hard for the core,

769
00:47:14,910 --> 00:47:16,260
the processors actually keep up with it,

770
00:47:16,290 --> 00:47:18,660
so you would like to give it a whole bunch of packets,

771
00:47:18,660 --> 00:47:21,030
you know the networks or network card chunk along

772
00:47:21,030 --> 00:47:22,740
and all send them out at high speed.

773
00:47:23,280 --> 00:47:26,880
And similarly you know in reception you might get a burst of packets coming in

774
00:47:27,270 --> 00:47:29,370
and you want to place them in the queue

775
00:47:29,370 --> 00:47:33,710
and then the operating system can start processing the queue, right.

776
00:47:35,090 --> 00:47:36,830
And so this is a common,

777
00:47:39,270 --> 00:47:45,010
this is the reason, that these queues are common to handle bursts.

778
00:47:48,910 --> 00:47:51,700
What happens if the queue is full, like reception.

779
00:47:58,950 --> 00:48:02,610
I think the the document mentioned that,

780
00:48:02,610 --> 00:48:05,790
it does some form of drop tail scheme.

781
00:48:06,810 --> 00:48:10,290
Yeah, there, yeah, basically the packets get dropped.

782
00:48:11,170 --> 00:48:13,420
So any future incoming packets,

783
00:48:13,420 --> 00:48:17,230
if the queue is full, the packets or there's no room anymore in the ring,

784
00:48:17,230 --> 00:48:19,390
the network card can't do anything with that, correct,

785
00:48:19,390 --> 00:48:23,830
and so the only option it actually has to basically delete the packet

786
00:48:23,860 --> 00:48:26,930
or not added to the ring and therefore disappears.

787
00:48:27,890 --> 00:48:30,560
So, one reason you know packet loss, sometimes is that,

788
00:48:31,170 --> 00:48:33,660
and operating system is overloaded,

789
00:48:33,690 --> 00:48:36,330
you know with packet can't keep up and the ring fills

790
00:48:36,540 --> 00:48:38,670
and then you know the packets get dropped.

791
00:48:41,110 --> 00:48:42,130
You know higher level software,

792
00:48:42,130 --> 00:48:46,840
of course maybe like TCP connection might re-transmit those packets,

793
00:48:47,110 --> 00:48:49,660
but this is one reason why packets can get dropped.

794
00:48:52,730 --> 00:48:56,030
So even if the hardware sort of works all perfectly fine,

795
00:48:56,150 --> 00:48:57,830
you know because of these bursts

796
00:48:57,830 --> 00:48:59,870
you know it can happen that some packets might get dropped.

797
00:49:01,240 --> 00:49:02,920
So you had a really really big burst.

798
00:49:07,010 --> 00:49:10,010
The head and tail pointers,

799
00:49:10,010 --> 00:49:12,560
they're all software abstractions, right, of the queue?

800
00:49:13,160 --> 00:49:15,740
Okay, so these are actually turns out that

801
00:49:15,740 --> 00:49:18,320
those are these control registers, right,

802
00:49:18,320 --> 00:49:22,370
so there's a control register for the hardware, the header pointer is,

803
00:49:22,370 --> 00:49:25,970
a control register for the basically the tail pointers,

804
00:49:26,060 --> 00:49:28,010
there's no real distinction between hardware software,

805
00:49:28,010 --> 00:49:30,110
basically the driver knows about the tail pointer,

806
00:49:30,110 --> 00:49:35,490
and it knows about the hardware knows about the tail pointer and header pointer

807
00:49:35,520 --> 00:49:37,050
and use a basic control registers.

808
00:49:37,720 --> 00:49:38,410
Okay yeah.

809
00:49:39,070 --> 00:49:40,300
We will see the code in seconds,

810
00:49:40,300 --> 00:49:41,260
how did that shows up,

811
00:49:42,810 --> 00:49:44,280
make sure if you go back to our,

812
00:49:44,610 --> 00:49:48,420
maybe let's see this picture still here,

813
00:49:48,840 --> 00:49:51,210
here's that earlier picture we looked at,

814
00:49:51,540 --> 00:49:54,660
and you know here's control register that holds the head,

815
00:49:54,780 --> 00:49:57,060
here's control register that holds the tail,

816
00:49:57,060 --> 00:50:00,480
and of course there's one for both reception and one for sending.

817
00:50:04,300 --> 00:50:04,930
Okay?

818
00:50:08,810 --> 00:50:10,280
Let's go back here.

819
00:50:11,290 --> 00:50:14,140
Okay, so let's talk a little bit about the descriptors.

820
00:50:15,250 --> 00:50:18,310
And so the descriptors are defined by the hardware

821
00:50:18,730 --> 00:50:20,140
and so the hardware says

822
00:50:20,140 --> 00:50:22,240
like here's how the descriptors should look like,

823
00:50:22,240 --> 00:50:25,660
and your driver you know these are the bits you can fill in,

824
00:50:25,660 --> 00:50:28,930
and if you fill in that bit that tells me to follow, right.

825
00:50:29,270 --> 00:50:34,350
And so here's the two descriptors are important,

826
00:50:34,380 --> 00:50:40,160
you know, here's the receive descriptor rx,

827
00:50:40,160 --> 00:50:42,680
and here's a tx, one of the tx descriptors.

828
00:50:43,380 --> 00:50:45,960
And so let's look a little bit.

829
00:50:46,600 --> 00:50:48,370
Yeah, it's a little bit,

830
00:50:48,820 --> 00:50:52,990
probably the most important part is this address,

831
00:50:53,530 --> 00:50:56,560
and that is the address that the software filled in

832
00:50:56,560 --> 00:51:00,370
to say where they should where the hardware to dump the packet,

833
00:51:00,490 --> 00:51:04,690
where in RAM to the driver,

834
00:51:04,930 --> 00:51:09,100
where should the network card put the data that is received into RAM,

835
00:51:09,220 --> 00:51:12,460
so it's the address of the reception buffer, if you will.

836
00:51:17,080 --> 00:51:20,500
And then you know probably the most important part in

837
00:51:20,560 --> 00:51:23,470
is the status field as you've seen.

838
00:51:24,020 --> 00:51:28,370
So when the driver basically still continues to look sort of at the tail

839
00:51:28,430 --> 00:51:31,460
and sees that there's a new packet has been received

840
00:51:31,670 --> 00:51:34,490
and the way it tells whether a new packet received is,

841
00:51:34,670 --> 00:51:39,450
is that the DD bit, correct, is set by the hardware.

842
00:51:40,540 --> 00:51:47,290
And you know the shaded areas are the fields of the packet descriptor of the,

843
00:51:47,920 --> 00:51:50,890
receive descriptor actually the hardware fills in,

844
00:51:51,010 --> 00:51:53,620
and the white you know the non shaded ones

845
00:51:53,620 --> 00:51:56,860
are the fields that actually shaded in are filled in by the software,

846
00:51:57,100 --> 00:51:59,470
again here we see this clear distinction about,

847
00:51:59,680 --> 00:52:01,240
somethings are owned by software,

848
00:52:01,270 --> 00:52:05,690
somethings are owned by by the hardware.

849
00:52:08,760 --> 00:52:13,290
Okay, and there's a similar you know descriptor,

850
00:52:13,290 --> 00:52:14,760
very simple descriptor that looks,

851
00:52:15,150 --> 00:52:18,060
that's a hardware descriptor for the transmission,

852
00:52:18,300 --> 00:52:19,920
it has an address,

853
00:52:19,980 --> 00:52:21,210
the address of course is

854
00:52:21,210 --> 00:52:25,590
the address where the data is in memory that needs to be sent.

855
00:52:26,000 --> 00:52:28,460
And then it has a bunch of, has a command field,

856
00:52:29,160 --> 00:52:32,610
and here's how the software tells the driver tells the network card,

857
00:52:32,670 --> 00:52:34,740
this is what you should do with this particular packet

858
00:52:34,740 --> 00:52:37,470
or you know this is what you should know about this particular packet.

859
00:52:38,290 --> 00:52:39,760
And so one thing,

860
00:52:40,000 --> 00:52:42,370
yeah we I think we [fill] in two packet, two things,

861
00:52:42,370 --> 00:52:46,330
we call the EOP says you know the end of packet,

862
00:52:46,630 --> 00:52:48,160
and that basically tells the driver,

863
00:52:48,310 --> 00:52:51,550
this is the last descriptor of a particular packet,

864
00:52:51,550 --> 00:52:56,080
and now can you know send off you know whatever data that's in these descriptors.

865
00:52:56,900 --> 00:53:06,220
And I think we set the response you know requested command bit

866
00:53:06,490 --> 00:53:09,850
or RS I think it is,

867
00:53:09,880 --> 00:53:11,530
basically tells network card,

868
00:53:11,560 --> 00:53:14,530
when you're done transmitting this thing,

869
00:53:14,680 --> 00:53:20,600
you know set the, set the bit that it actually has been transmitted.

870
00:53:21,430 --> 00:53:23,650
We'll see in a second how how that shows up.

871
00:53:25,570 --> 00:53:26,350
Any questions?

872
00:53:32,230 --> 00:53:34,090
So one one thing to keep in mind,

873
00:53:34,360 --> 00:53:35,350
you know with these structures,

874
00:53:35,380 --> 00:53:36,610
these are defined by the hardware,

875
00:53:36,640 --> 00:53:39,970
like hardware, software has no control over their structure,

876
00:53:39,970 --> 00:53:43,780
you know there's just literally defined by the hardware, by the network card.

877
00:53:44,860 --> 00:53:47,050
Okay, let's look at a little bit of code

878
00:53:47,470 --> 00:53:50,590
and see what the solution looks like,

879
00:53:50,590 --> 00:53:52,450
and we'll look at a couple of issues

880
00:53:52,450 --> 00:53:54,580
that we haven't looked at yet, you know the mbufs,

881
00:53:55,060 --> 00:53:59,020
issues if during transmission and issues during receiving.

882
00:54:00,600 --> 00:54:03,090
And this would be presumably all well familiar with to you,

883
00:54:03,090 --> 00:54:05,250
given the fact that you just finished the lab.

884
00:54:08,880 --> 00:54:09,900
Okay, so here,

885
00:54:09,900 --> 00:54:14,010
just to go to the top, here's the transmit ring.

886
00:54:15,040 --> 00:54:18,580
Yeah, and that's basically the ring of descriptors,

887
00:54:18,580 --> 00:54:22,000
you know we drew off in the last couple of slides.

888
00:54:22,670 --> 00:54:23,540
There's a separate,

889
00:54:23,600 --> 00:54:24,830
we talked briefly about this,

890
00:54:24,830 --> 00:54:28,280
there's a separate basically ring of mbufs,

891
00:54:28,520 --> 00:54:34,190
but in that ring is completely you know a software or driver only abstraction,

892
00:54:34,550 --> 00:54:42,090
hardware, this is defined by this structure is defined by the hardware, right,

893
00:54:42,090 --> 00:54:42,870
and if you look at.

894
00:54:43,480 --> 00:54:43,960
Oops.

895
00:55:02,990 --> 00:55:04,760
You know look at the definitions,

896
00:55:04,760 --> 00:55:06,740
but here's struct tx_desc,

897
00:55:06,860 --> 00:55:10,310
that corresponds to the C version of exactly the structure

898
00:55:10,310 --> 00:55:11,750
that actually was defined by the hardware,

899
00:55:11,780 --> 00:55:14,090
you know 64 bit address,

900
00:55:14,090 --> 00:55:17,480
you know the length field, the cso, byte the cmd byte,

901
00:55:17,480 --> 00:55:21,740
the status byte, the css byte, and then two word for special.

902
00:55:22,590 --> 00:55:25,320
And there's a similar ring that is literally defined by the hardware,

903
00:55:25,840 --> 00:55:28,390
or similar descriptors received descriptor as defined by hardware,

904
00:55:28,390 --> 00:55:32,560
and those we just have see descriptors corresponding to these hardware structures.

905
00:55:34,970 --> 00:55:36,230
Alright, let's look at transmit,

906
00:55:37,780 --> 00:55:41,650
so here's the sort of staff solution for transmit,

907
00:55:42,390 --> 00:55:44,370
you know acquires a lock,

908
00:55:44,400 --> 00:55:46,680
and the reason we said before that needed lock is,

909
00:55:46,680 --> 00:55:49,110
because multiple functions or multiple threads, kernel threads

910
00:55:49,110 --> 00:55:51,900
might call transmit at the same time.

911
00:55:53,460 --> 00:55:55,110
And then it looks at the tail,

912
00:55:55,320 --> 00:55:57,660
you know to see if there's any,

913
00:55:58,300 --> 00:56:01,120
in the room to actually sent a new packet,

914
00:56:01,120 --> 00:56:03,880
because you know the network card got behind,

915
00:56:03,880 --> 00:56:07,390
and all the descriptors actually are be in used.

916
00:56:08,170 --> 00:56:09,280
And so the way it checks,

917
00:56:09,730 --> 00:56:13,390
where you're actually the descriptor in the in use,

918
00:56:13,390 --> 00:56:19,040
by checking whether the DD bit is not set.

919
00:56:20,120 --> 00:56:22,850
And if it is set then,

920
00:56:25,410 --> 00:56:29,760
if it's not set, then it returns immediately,

921
00:56:29,760 --> 00:56:31,170
not sending the packet at all,

922
00:56:31,350 --> 00:56:33,660
and in any other case, gonna it keeps on,

923
00:56:33,660 --> 00:56:35,550
going and actually will send the mbuf.

924
00:56:39,760 --> 00:56:43,600
So if there's still an mbuf in this position in the tx_mbufs,

925
00:56:43,600 --> 00:56:45,820
and means this is an mbuf for a while back,

926
00:56:45,850 --> 00:56:47,260
you know free that mbuf,

927
00:56:47,260 --> 00:56:50,800
because we're going to actually stick in a new mbuf into this descriptor,

928
00:56:51,100 --> 00:56:52,120
we just need to remember,

929
00:56:52,120 --> 00:56:54,490
which you know mbuf we stuck in that descriptor,

930
00:56:54,610 --> 00:56:56,080
and so the way we do that is

931
00:56:56,080 --> 00:56:58,420
by keeping that in the tx_mbufs.

932
00:56:59,820 --> 00:57:01,230
And then we fill in the descriptor,

933
00:57:01,500 --> 00:57:04,530
and so the first thing we'll filling is the head

934
00:57:04,530 --> 00:57:05,820
and we fill in,

935
00:57:05,850 --> 00:57:11,970
we put in the address the start of the first header in the mbuf,

936
00:57:13,470 --> 00:57:17,020
then, put the length, set the status 0,

937
00:57:17,110 --> 00:57:18,730
put the command field in place

938
00:57:18,730 --> 00:57:23,200
by setting both RS and the EOP bit as we discuss the second.

939
00:57:23,760 --> 00:57:28,340
And, and then basically you'll be synchronized

940
00:57:28,340 --> 00:57:30,860
to make actually sure there's no reordering of,

941
00:57:30,890 --> 00:57:35,300
you know that all these instructions are performed before the next instruction.

942
00:57:36,140 --> 00:57:37,310
And what the next instruction does,

943
00:57:37,310 --> 00:57:38,930
it actually updates the tail pointer,

944
00:57:39,080 --> 00:57:41,330
and so the [] updates the tail pointer,

945
00:57:41,330 --> 00:57:45,470
and the tail pointer correct is a control register in the network card,

946
00:57:45,890 --> 00:57:48,200
and so basically when we update the tail pointer,

947
00:57:48,290 --> 00:57:51,170
the network card knows aha something changed,

948
00:57:51,470 --> 00:57:56,180
and it's going to read you know the data at that descriptor,

949
00:57:56,420 --> 00:58:00,200
and it's going to basically read these fields, we've just filled in,

950
00:58:00,350 --> 00:58:02,450
so we're gonna basically make absolutely sure that,

951
00:58:02,880 --> 00:58:06,750
all these writes, all the stores are materialized in memory,

952
00:58:06,780 --> 00:58:09,630
before the network card actually reads them,

953
00:58:09,630 --> 00:58:11,520
and so this is why the __sync_synchronize there,

954
00:58:13,760 --> 00:58:14,900
and then we release about a lock,

955
00:58:14,900 --> 00:58:17,240
and that's basically all we have to do to transmit a packet.

956
00:58:20,790 --> 00:58:24,800
Can you explain the __sync_synchronize again, like what.

957
00:58:25,270 --> 00:58:30,160
Yeah, it's mostly memory ordering technicality, correct,

958
00:58:30,160 --> 00:58:32,140
compilers are free to reorder instructions,

959
00:58:32,660 --> 00:58:38,720
the writes might actually sit in the L1 cache or the L2 cache,

960
00:58:39,080 --> 00:58:42,380
and sync basically the synchronize sort of memory fence,

961
00:58:42,680 --> 00:58:45,260
that tells the hardware and compiler,

962
00:58:45,350 --> 00:58:48,680
please don't move any instructions across this barrier,

963
00:58:49,630 --> 00:58:51,670
and make sure that all the data,

964
00:58:51,670 --> 00:58:54,640
that you know all the stores before this barrier

965
00:58:54,730 --> 00:58:57,100
are actually actually materialized in RAM.

966
00:58:58,700 --> 00:58:59,990
And the reason that is important is,

967
00:58:59,990 --> 00:59:04,340
because the, go back to our picture for a little while ago,

968
00:59:05,380 --> 00:59:10,060
all the way back here.

969
00:59:10,710 --> 00:59:14,970
Make sure both you know the RISC-V cores that run the driver code

970
00:59:15,000 --> 00:59:17,160
basically put values here in round right,

971
00:59:17,160 --> 00:59:20,670
but you know those values are [] the L1 cache and L2 cache

972
00:59:21,030 --> 00:59:24,000
and the memory flush and ensures that they actually show up in the RAM,

973
00:59:24,120 --> 00:59:26,940
this is important because as soon as we update the tail pointer,

974
00:59:26,940 --> 00:59:29,670
the e1000 is going to look into RAM for these descriptors,

975
00:59:30,970 --> 00:59:34,000
and we've got to make sure that all the fields are indeed set,

976
00:59:34,800 --> 00:59:37,080
otherwise, it would read stale values.

977
00:59:40,360 --> 00:59:41,140
Does that make sense?

978
00:59:43,410 --> 00:59:43,980
Yep thank you.

979
00:59:46,320 --> 00:59:48,300
Why do mbuf exist,

980
01:00:00,660 --> 01:00:02,730
why have these sort of separate structure of,

981
01:00:02,760 --> 01:00:07,850
why have these two sort of corresponding structures?

982
01:00:09,590 --> 01:00:11,000
So I guess part of it is,

983
01:00:11,000 --> 01:00:13,590
it's all nice and well

984
01:00:13,590 --> 01:00:18,510
if the driver needs to talk to the hardware about where things are,

985
01:00:18,510 --> 01:00:19,260
but at the end of the day,

986
01:00:19,260 --> 01:00:20,820
we do need to store the packet

987
01:00:20,820 --> 01:00:22,800
to hand off to the network stack somehow.

988
01:00:24,020 --> 01:00:24,860
Yeah, exactly,

989
01:00:24,920 --> 01:00:27,350
you know, so you know so one way to think about it is

990
01:00:27,350 --> 01:00:30,110
that the you know the mbufs completely an OS abstraction,

991
01:00:30,110 --> 01:00:32,750
nothing to do with really the network card at all,

992
01:00:33,140 --> 01:00:33,740
and it's there,

993
01:00:33,740 --> 01:00:39,590
because like you know if at some point, you know maybe receive a packet,

994
01:00:39,590 --> 01:00:41,450
you know we hand it off to the network stack,

995
01:00:41,450 --> 01:00:43,610
in the network stack now sticks at some queue,

996
01:00:43,700 --> 01:00:45,890
so that when later a user process calls read,

997
01:00:45,920 --> 01:00:47,150
you actually can read it,

998
01:00:48,000 --> 01:00:50,550
in the meantime, we need to have some structure,

999
01:00:50,550 --> 01:00:53,040
that holds that data that we actually received

1000
01:00:53,040 --> 01:00:54,990
and that's exactly what those mbuf structures are.

1001
01:01:01,310 --> 01:01:03,800
Sorry, can you talk about the,

1002
01:01:04,700 --> 01:01:09,990
like how, how do you use the link list structure in your code,

1003
01:01:09,990 --> 01:01:13,690
because I was trying to to understand it and track it down

1004
01:01:14,290 --> 01:01:19,490
and it seems like there's some push tail or push head,

1005
01:01:19,550 --> 01:01:23,680
but I don't ever call it in my code,

1006
01:01:24,220 --> 01:01:28,000
oh, it might be it might be in the net.c file.

1007
01:01:30,200 --> 01:01:33,110
The networks C files file, we gave you to, correct?

1008
01:01:33,770 --> 01:01:34,610
Yeah.

1009
01:01:39,650 --> 01:01:40,940
And where you're thinking?

1010
01:01:42,800 --> 01:01:49,940
If you look for something like pull pop, I think pop.

1011
01:01:54,210 --> 01:01:57,030
Yeah, so this is this is the only place

1012
01:01:57,030 --> 01:02:03,540
where it looks like it does things with the linked list structure of mbuf,

1013
01:02:04,290 --> 01:02:08,700
and if you don't ever call this function or the push tail,

1014
01:02:09,000 --> 01:02:17,610
you basically just treat the mbuf as an array of like how many characters,

1015
01:02:17,670 --> 01:02:20,570
so, so why is mbuf there.

1016
01:02:21,370 --> 01:02:27,710
Because here, when you receive a UDP packet,

1017
01:02:28,130 --> 01:02:30,440
so the UDP packet comes in from the network card,

1018
01:02:30,470 --> 01:02:31,850
it goes to the network stack,

1019
01:02:32,450 --> 01:02:34,430
then the UDP packet,

1020
01:02:34,460 --> 01:02:38,060
the mbuf for the UDP that holds that UDP packet

1021
01:02:38,450 --> 01:02:40,250
is actually stuck in a queue right here,

1022
01:02:42,090 --> 01:02:44,220
on the socket for the receiver.

1023
01:02:47,460 --> 01:02:50,370
And so this is the reason that you can have queues within mbufs.

1024
01:02:54,420 --> 01:02:56,100
And the reason is stack in the queue there correct,

1025
01:02:56,100 --> 01:02:57,300
is because you know who knows,

1026
01:02:57,300 --> 01:03:00,690
you know the user process that's going to read you know from this particular socket,

1027
01:03:01,140 --> 01:03:02,670
you know might be doing something else,

1028
01:03:02,700 --> 01:03:05,310
and at some point later, it's going to call the read system call,

1029
01:03:05,310 --> 01:03:09,630
then the read system call is going to move you know that mbuf from that socket.

1030
01:03:11,780 --> 01:03:20,250
And so, the point with each socket can have a list of mbufs for reception.

1031
01:03:22,070 --> 01:03:23,390
I see, thank you.

1032
01:03:25,840 --> 01:03:27,580
Okay, let's go back to the driver.

1033
01:03:28,190 --> 01:03:30,230
So that was transmit.

1034
01:03:32,480 --> 01:03:33,980
So then we receive,

1035
01:03:34,010 --> 01:03:37,340
you know almost similar, not that much difference,

1036
01:03:37,760 --> 01:03:42,620
basically you know read the tail pointer from the network card.

1037
01:03:43,220 --> 01:03:45,470
You see there actually a packet,

1038
01:03:45,560 --> 01:03:51,110
and if there's a packet, then the DD field would be set,

1039
01:03:51,770 --> 01:03:53,630
if the DD field is not set,

1040
01:03:53,660 --> 01:03:56,360
then we know there's no packet and so we're done,

1041
01:03:57,200 --> 01:03:59,750
if it is set, we're going to read it,

1042
01:04:02,220 --> 01:04:03,660
and read the length,

1043
01:04:03,660 --> 01:04:08,710
you know, and when we when we call and net_rx,

1044
01:04:08,710 --> 01:04:11,230
you know do up call into the higher level stack.

1045
01:04:11,930 --> 01:04:14,270
And when we're done,

1046
01:04:14,270 --> 01:04:18,780
you know we're basically free up you know that entry,

1047
01:04:18,870 --> 01:04:20,880
so that the driver can use it

1048
01:04:20,880 --> 01:04:22,470
to actually receive more packets in it.

1049
01:04:23,340 --> 01:04:25,980
And the real crucial operation there is, correct,

1050
01:04:25,980 --> 01:04:28,710
we bump up basically the tail to tell the driver,

1051
01:04:29,100 --> 01:04:31,560
okay, you know we're done with it, you can use it again,

1052
01:04:31,590 --> 01:04:33,060
you know here's again that slot.

1053
01:04:35,900 --> 01:04:37,910
So maybe the most interesting question is

1054
01:04:37,940 --> 01:04:40,430
and number of questions have you asked,

1055
01:04:40,460 --> 01:04:41,810
why is the while there,

1056
01:04:45,530 --> 01:04:46,730
why is this in a loop,

1057
01:04:47,690 --> 01:04:48,830
don't you get an interrupt,

1058
01:04:48,830 --> 01:04:50,690
then you know you grab one packet then you've done,

1059
01:04:50,930 --> 01:04:54,370
a number of people that actually forgot while loop first,

1060
01:04:54,370 --> 01:04:56,470
you know notice that basically at some point

1061
01:04:56,470 --> 01:04:58,750
you don't receive packets anymore, during nettest.

1062
01:05:02,840 --> 01:05:06,230
Is it because you would like to transmit as many packets

1063
01:05:06,230 --> 01:05:08,900
that are ready as possible with only one interrupt,

1064
01:05:08,900 --> 01:05:13,010
so that you can kind of amortize the cost of the interrupt.

1065
01:05:13,780 --> 01:05:15,850
Yeah, this, this is absolutely part of it,

1066
01:05:15,850 --> 01:05:17,320
you know you get to the,

1067
01:05:17,470 --> 01:05:20,890
let's first talk about you know the root cause is write,

1068
01:05:21,730 --> 01:05:24,700
if a number of burst package comes in,

1069
01:05:25,330 --> 01:05:28,570
and the network card will generate the interrupt,

1070
01:05:28,930 --> 01:05:30,220
but more packets are coming in,

1071
01:05:30,310 --> 01:05:33,130
and so it will just put them in the free descriptors right

1072
01:05:33,130 --> 01:05:34,390
that actually can use,

1073
01:05:35,060 --> 01:05:37,190
can't generate more interrupts,

1074
01:05:37,190 --> 01:05:38,750
because already generated interrupt,

1075
01:05:39,140 --> 01:05:42,620
and at some point you know the whatever the process

1076
01:05:42,620 --> 01:05:47,300
or you know, maybe we were the core was just in a section of code that turned off interrupts,

1077
01:05:47,300 --> 01:05:48,650
because it was doing something atomic,

1078
01:05:49,010 --> 01:05:49,700
at the end of it,

1079
01:05:49,700 --> 01:05:51,110
you know there's a release from lock,

1080
01:05:51,110 --> 01:05:52,400
that actually turns interruption on,

1081
01:05:52,550 --> 01:05:53,420
that point of time,

1082
01:05:53,420 --> 01:05:57,800
then basically the receive handlers, the interrupt handler going to run,

1083
01:05:58,160 --> 01:05:59,720
but between a period,

1084
01:05:59,720 --> 01:06:02,510
when the first packet comes in and before you receive handler runs,

1085
01:06:02,510 --> 01:06:06,290
there's a whole bunch of other packets might have could have could have come in.

1086
01:06:07,430 --> 01:06:10,310
And so we don't run in the while loop,

1087
01:06:10,340 --> 01:06:13,100
will leave those packets,

1088
01:06:13,100 --> 01:06:15,650
will grab the first one and will grab the other

1089
01:06:15,650 --> 01:06:18,380
and the later ones you stick there in the queue, right,

1090
01:06:18,380 --> 01:06:19,670
they're just sitting there in that ring.

1091
01:06:20,680 --> 01:06:22,780
Now, if subsequent interrupt would come in,

1092
01:06:22,780 --> 01:06:23,920
we'll grab the next one,

1093
01:06:24,340 --> 01:06:26,110
but like the tests,

1094
01:06:26,140 --> 01:06:29,110
you know what they do they run their UDP packets,

1095
01:06:29,110 --> 01:06:30,700
you know, so they send off a whole bunch,

1096
01:06:30,700 --> 01:06:34,600
like one of the test since like ten ping request in parallel,

1097
01:06:34,810 --> 01:06:38,200
you know the ten responses coming parallel back, you know correct.

1098
01:06:38,640 --> 01:06:41,940
The first one receives generates an interrupt,

1099
01:06:42,030 --> 01:06:43,980
the other nine go into the queue,

1100
01:06:44,480 --> 01:06:48,230
the higher level software, you know reached the first one,

1101
01:06:48,830 --> 01:06:51,380
and then returns like it's done,

1102
01:06:51,650 --> 01:06:53,450
and at that point, nothing happens anymore,

1103
01:06:53,450 --> 01:06:56,210
because the receiver is waiting for more receive packets,

1104
01:06:56,360 --> 01:06:57,350
they happen to be there,

1105
01:06:57,350 --> 01:06:58,250
they're sitting in the ring,

1106
01:06:58,430 --> 01:07:02,120
except you know the receive didn't do them in a while loop

1107
01:07:02,120 --> 01:07:03,140
and so didn't pick them up.

1108
01:07:05,850 --> 01:07:06,570
Does that make sense?

1109
01:07:13,160 --> 01:07:15,710
So, for example if the test programs would have sent,

1110
01:07:15,710 --> 01:07:18,320
one request waited for a response,

1111
01:07:18,320 --> 01:07:20,420
one request waited for a response,

1112
01:07:20,600 --> 01:07:24,050
then you would never notice that, you needed to a while loop.

1113
01:07:24,550 --> 01:07:27,910
And it's because like there's a burst of responses might come back,

1114
01:07:28,030 --> 01:07:30,970
and that only generate together one interrupt.

1115
01:07:35,020 --> 01:07:36,820
Any questions about that, about this?

1116
01:07:36,820 --> 01:07:37,990
I have a question,

1117
01:07:37,990 --> 01:07:42,160
so for example if instead of a while one,

1118
01:07:42,700 --> 01:07:45,580
we would have a for loop that just goes through the whole queue,

1119
01:07:45,580 --> 01:07:49,060
that would also be wrong for the same reason.

1120
01:07:49,420 --> 01:07:53,260
No, we skip all the ones that have the DD not set.

1121
01:07:54,670 --> 01:07:57,370
Okay, we should only we should only look at packets

1122
01:07:57,370 --> 01:08:00,220
and actually we should only look at the tail pointer.

1123
01:08:02,170 --> 01:08:05,380
But you know in principle, you could just skip the whole queue

1124
01:08:05,380 --> 01:08:07,120
and I guess look at the DD packets,

1125
01:08:07,120 --> 01:08:09,490
you know let them see the DD bit is set,

1126
01:08:09,520 --> 01:08:11,920
and that might work, I don't know I haven't tried that.

1127
01:08:14,060 --> 01:08:18,050
Okay, but isn't the device able to

1128
01:08:18,320 --> 01:08:23,270
put more mbufs in the receive after we read stale?

1129
01:08:25,000 --> 01:08:25,930
Yeah yeah.

1130
01:08:29,070 --> 01:08:29,610
Okay.

1131
01:08:32,080 --> 01:08:32,890
And we have to.

1132
01:08:42,200 --> 01:08:43,010
It's very dangerous,

1133
01:08:43,010 --> 01:08:45,110
like this proposal of like sort of looking around,

1134
01:08:45,110 --> 01:08:47,150
and you know seeing DD set,

1135
01:08:47,150 --> 01:08:49,490
because you know really we should do,

1136
01:08:49,490 --> 01:08:54,260
we should not look at buf that really are controlled by the driver or by the hardware,

1137
01:08:54,500 --> 01:08:58,180
and only look at buffers are actually available to the software

1138
01:08:58,240 --> 01:09:00,760
and which is indicated by the DD bit,

1139
01:09:00,760 --> 01:09:02,470
and basically by looking at the tail pointer.

1140
01:09:04,080 --> 01:09:08,430
Basically, anything owned between the tail and the head is owned by the hardware.

1141
01:09:13,220 --> 01:09:17,060
Going back to the mbuf, like the reason we need the mbuf,

1142
01:09:17,450 --> 01:09:23,990
why do we need the other information in the buffer like the [] array,

1143
01:09:24,580 --> 01:09:26,230
I think it's called the backing store.

1144
01:09:28,760 --> 01:09:30,830
It gets in net.h.

1145
01:09:40,490 --> 01:09:42,830
So we need we need the buf field, correct,

1146
01:09:42,830 --> 01:09:44,300
because it actually contains the data.

1147
01:09:46,800 --> 01:09:49,410
I thought the head contains a pointer to the data.

1148
01:09:49,590 --> 01:09:50,400
Yeah yeah okay,

1149
01:09:50,400 --> 01:09:53,190
but the buf actually is the actual allocates space,

1150
01:09:53,190 --> 01:09:54,510
you know the whole packets, right,

1151
01:09:54,750 --> 01:09:57,240
and then head get pointers into buf,

1152
01:09:57,420 --> 01:09:59,100
basically the start of the packet.

1153
01:10:01,450 --> 01:10:02,230
Okay, okay.

1154
01:10:04,160 --> 01:10:05,630
And this is mbuf, this is,

1155
01:10:05,630 --> 01:10:08,990
okay so a little bit more context to mbuf is

1156
01:10:08,990 --> 01:10:11,270
a structure that you see in a lot of network stacks,

1157
01:10:11,270 --> 01:10:12,920
so you look in the Linux kernel,

1158
01:10:12,920 --> 01:10:14,420
you'll see structure similar like this,

1159
01:10:14,420 --> 01:10:17,420
and it's typically called mbufs, and so we have to.

1160
01:10:19,060 --> 01:10:22,030
We could have simplified this structure quite a bit, if we wanted to

1161
01:10:22,270 --> 01:10:24,490
and maybe subsequent here is we should,

1162
01:10:24,550 --> 01:10:26,620
but this is sort of the standard way

1163
01:10:26,620 --> 01:10:30,430
in which packets are represented in operating system kernels.

1164
01:10:39,430 --> 01:10:41,110
Okay, any further questions about this?

1165
01:10:50,760 --> 01:10:51,900
So I have a choice now,

1166
01:10:51,930 --> 01:10:55,590
a couple of things I could say about the network driver,

1167
01:10:55,860 --> 01:10:59,340
but then I won't have any time to talk about mmap.

1168
01:10:59,880 --> 01:11:03,780
I could also talk a little bit about mmap and then and stop here,

1169
01:11:04,500 --> 01:11:06,600
in terms of talking to the network driver.

1170
01:11:09,640 --> 01:11:11,200
Any preferences?

1171
01:11:24,740 --> 01:11:25,700
No preferences.

1172
01:11:31,350 --> 01:11:33,270
Let me talk a little bit about mmap,

1173
01:11:33,270 --> 01:11:35,940
because there was a question that came up a couple times,

1174
01:11:36,330 --> 01:11:40,080
and that might be worth addressing,

1175
01:11:40,920 --> 01:11:45,090
it's almost more a question about you know why mmap exists,

1176
01:11:45,420 --> 01:11:48,540
then, you know actually how to implement it.

1177
01:11:49,680 --> 01:11:53,010
So there's no real objections which sounds different,

1178
01:11:53,040 --> 01:11:55,770
let me talk a little bit more about mmap.

1179
01:11:56,750 --> 01:11:58,100
So this is your last chance

1180
01:11:58,100 --> 01:12:00,980
to ask any questions about the network driver until the end of class.

1181
01:12:06,660 --> 01:12:12,990
Okay, let's talk about the mbufs, oh, mmap.

1182
01:12:28,610 --> 01:12:33,840
Okay, so the, the question really relates to sort of the file system API,

1183
01:12:33,990 --> 01:12:38,220
and so the file system has a reasonable broad API,

1184
01:12:38,820 --> 01:12:42,660
supporting directories, symbolic links, hard links, etc etc,

1185
01:12:42,660 --> 01:12:46,980
but presumably the main the main part of it is the the file API, correct,

1186
01:12:46,980 --> 01:12:50,520
the file API, you're well familiar to you now,

1187
01:12:52,110 --> 01:12:56,860
open the file, you know with some permissions,

1188
01:12:56,890 --> 01:12:58,720
and once you have opened the file,

1189
01:12:58,960 --> 01:13:01,450
you know you can read from the file,

1190
01:13:04,600 --> 01:13:07,870
into a buffer, create some data.

1191
01:13:08,830 --> 01:13:12,550
And you can write you know to the file,

1192
01:13:15,040 --> 01:13:17,920
whatever file descriptor and buf, you know len,

1193
01:13:18,310 --> 01:13:19,390
so let's say we,

1194
01:13:20,080 --> 01:13:23,590
and then we can close the file descriptor.

1195
01:13:25,070 --> 01:13:26,900
Now let's say we want to write an application

1196
01:13:27,140 --> 01:13:29,240
and you can think about the,

1197
01:13:30,050 --> 01:13:34,940
you know may be just a file as, you know files normally a array of bytes,

1198
01:13:34,940 --> 01:13:37,610
but like maybe this application has sort of

1199
01:13:37,610 --> 01:13:39,710
it's an array of struct that are stored in it.

1200
01:13:39,890 --> 01:13:43,320
So, and let's say the application wants to update the struct,

1201
01:13:43,320 --> 01:13:44,880
so you know we have to file,

1202
01:13:46,170 --> 01:13:50,200
here's a file and so divided in you know structs,

1203
01:13:50,200 --> 01:13:52,780
you know whatever zero to use the file length,

1204
01:13:52,780 --> 01:13:56,470
and you know we maybe like in the middle,

1205
01:13:56,830 --> 01:13:59,200
let's have structure 16 bytes or something

1206
01:13:59,200 --> 01:14:01,540
and you know we want to update one of these

1207
01:14:01,840 --> 01:14:03,490
or maybe want to update the first one.

1208
01:14:05,680 --> 01:14:07,240
And so in a way we could do that correctly,

1209
01:14:07,240 --> 01:14:09,340
we read and we open the file,

1210
01:14:09,340 --> 01:14:12,670
we read you know the first you know whatever 16 bytes,

1211
01:14:13,800 --> 01:14:15,720
that correspond to this you know we,

1212
01:14:16,420 --> 01:14:20,680
let's say updates you know the first field struct,

1213
01:14:20,710 --> 01:14:23,170
the first byte of that struct, you know to be 1.

1214
01:14:23,880 --> 01:14:28,080
And then we call write, to basically write it back

1215
01:14:28,110 --> 01:14:29,130
and then we close the file.

1216
01:14:29,800 --> 01:14:31,480
So if when is write happens where,

1217
01:14:31,480 --> 01:14:32,530
where does it actually write.

1218
01:14:41,090 --> 01:14:44,360
So we've set this memory above the 1,

1219
01:14:44,360 --> 01:14:47,540
you know will this first by change to 1,

1220
01:14:52,140 --> 01:14:53,160
if we call write.

1221
01:15:08,510 --> 01:15:11,540
So, remember the file descriptor has not set associated with it correct.

1222
01:15:13,320 --> 01:15:17,040
And reads read pushes that offset you know forward,

1223
01:15:17,040 --> 01:15:19,110
in this case, we've read 16 bytes,

1224
01:15:19,110 --> 01:15:22,020
you know the offset goes from up 0 to 16.

1225
01:15:22,960 --> 01:15:24,310
And so where does write write,

1226
01:15:27,190 --> 01:15:32,470
as you notice, there's no offset argument in the write system call,

1227
01:15:32,500 --> 01:15:33,610
so where does it write.

1228
01:15:37,070 --> 01:15:37,940
Len?

1229
01:15:39,180 --> 01:15:41,010
Yeah you we'll write len bytes,

1230
01:15:41,010 --> 01:15:42,420
which offset in the file,

1231
01:15:44,080 --> 01:15:46,360
presumably len exactly at 16 right.

1232
01:15:46,920 --> 01:15:47,520
Yes.

1233
01:15:47,940 --> 01:15:51,420
Write here, so which, this byte will change to 1, correct.

1234
01:15:54,090 --> 01:15:58,470
Not the actual thing that we are actually trying to modify.

1235
01:15:59,970 --> 01:16:00,690
Does that make sense?

1236
01:16:02,540 --> 01:16:04,340
So the way you've written this application,

1237
01:16:04,340 --> 01:16:06,050
it turns out there was one a system call,

1238
01:16:06,050 --> 01:16:07,790
that we didn't really talk much about at all,

1239
01:16:07,910 --> 01:16:12,290
but every operating system, Unix operating system is called system called lseek.

1240
01:16:14,220 --> 01:16:18,210
And lseek allows you basically to change the offset to some position.

1241
01:16:18,850 --> 01:16:20,620
And so in this particular case,

1242
01:16:20,620 --> 01:16:23,200
we want to do have the effect

1243
01:16:23,200 --> 01:16:25,600
that we're going to write this struct not that one.

1244
01:16:26,140 --> 01:16:28,960
Then we would have said like you know lseek 0,

1245
01:16:28,990 --> 01:16:34,250
basically resetting the offset to actually 0,

1246
01:16:34,280 --> 01:16:37,580
so then this write would actually sort here now offset 0.

1247
01:16:38,380 --> 01:16:42,850
And then this write actually you would write actually at the first 16 bytes.

1248
01:16:44,170 --> 01:16:44,920
Does that make sense?

1249
01:16:51,700 --> 01:16:53,290
So this is slightly inconvenient, correctly,

1250
01:16:53,290 --> 01:16:54,340
if you think about this,

1251
01:16:54,520 --> 01:16:55,930
you look at this interface,

1252
01:16:55,930 --> 01:16:58,000
there's actually quite a bit of stuff going on,

1253
01:16:58,000 --> 01:16:59,890
you know you gotta open, you gotta read it,

1254
01:16:59,890 --> 01:17:01,570
you know you can seek it and then you can write it.

1255
01:17:02,310 --> 01:17:05,010
And so, one reason that mmap is popular,

1256
01:17:06,600 --> 01:17:10,860
is you can sort of avoid you know these these complications.

1257
01:17:11,460 --> 01:17:13,740
Because if we write this using mmap,

1258
01:17:13,740 --> 01:17:15,840
you know, we do fd is open

1259
01:17:16,110 --> 01:17:17,850
and we open the file as before,

1260
01:17:20,980 --> 01:17:24,370
and then you know we just call mmap,

1261
01:17:26,240 --> 01:17:27,830
it's going to be whatever our struct,

1262
01:17:27,860 --> 01:17:33,100
let's say our struct h, you know, blah, blah blah,

1263
01:17:33,130 --> 01:17:42,440
you know whatever some len for the file, read, write permissions,

1264
01:17:43,530 --> 01:17:50,920
you know map shared, and file descriptor 0.

1265
01:17:52,160 --> 01:17:56,450
And then, so now basically with this correct we're in mmapping,

1266
01:17:56,450 --> 01:18:01,070
you know the file f at the location h, you know in memory.

1267
01:18:01,580 --> 01:18:04,040
Now, we can just say h

1268
01:18:04,040 --> 01:18:08,300
whatever first byte is zero or one that we did before.

1269
01:18:08,980 --> 01:18:11,710
And then you know at some point you know we can munmap,

1270
01:18:16,440 --> 01:18:21,500
you know the munmap h, right,

1271
01:18:21,500 --> 01:18:23,840
and so if we think about this, we look in memory.

1272
01:18:24,400 --> 01:18:26,920
We're looking at this from the perspective of the file,

1273
01:18:27,310 --> 01:18:28,570
you know what this does, correct,

1274
01:18:28,570 --> 01:18:32,410
code literally did is basically you've got a pointer to this h,

1275
01:18:32,770 --> 01:18:35,560
and you can just update here, you know that thing to 1

1276
01:18:35,920 --> 01:18:37,390
and be done with it, right.

1277
01:18:38,360 --> 01:18:40,790
And so if we sort of need to manipulate

1278
01:18:40,820 --> 01:18:44,660
you know file structure, data structure that sits inside of a file,

1279
01:18:44,960 --> 01:18:47,570
this mmap interface is much more convenient.

1280
01:18:48,060 --> 01:18:50,100
Then you know this previous interface,

1281
01:18:50,340 --> 01:18:51,930
we're you know we have to read,

1282
01:18:51,930 --> 01:18:55,800
you know we manipulated the memory you know we you know we seek back,

1283
01:18:55,800 --> 01:18:57,180
and then we actually write the information.

1284
01:18:57,740 --> 01:18:59,360
And in this particular case,

1285
01:18:59,360 --> 01:19:03,410
we really can think about the file as being an array of bytes,

1286
01:19:03,410 --> 01:19:05,120
you know that we can write willy nilly,

1287
01:19:05,630 --> 01:19:07,790
without actually having to navigate to jump around,

1288
01:19:11,950 --> 01:19:16,060
do people see what the advantage of the mmap interfaces.

1289
01:19:23,960 --> 01:19:25,040
Any questions about this?

1290
01:19:28,170 --> 01:19:32,310
Any big storage systems use this,

1291
01:19:32,310 --> 01:19:34,050
like I don't know like databases,

1292
01:19:34,050 --> 01:19:36,300
do they use this a lot or not really.

1293
01:19:36,630 --> 01:19:37,740
They use this a lot.

1294
01:19:38,600 --> 01:19:40,850
I think a lot of applications use mmap,

1295
01:19:40,880 --> 01:19:44,660
because for these kinds of things like a database is much more convenient,

1296
01:19:47,270 --> 01:19:49,790
then this interface, this interface is great, correct,

1297
01:19:49,790 --> 01:19:51,560
if you need to read from standard input,

1298
01:19:51,680 --> 01:19:53,570
and there's a stream of bytes coming in,

1299
01:19:53,600 --> 01:19:57,770
you read you read you read and you produce some output some other stream.

1300
01:19:58,910 --> 01:20:01,640
That interface that interface is very suitable for here,

1301
01:20:02,000 --> 01:20:03,500
you don't have to update offset,

1302
01:20:03,500 --> 01:20:05,510
you know you read, get offset immediately update,

1303
01:20:05,510 --> 01:20:07,760
you read again, you read a bit further etc etc.

1304
01:20:07,940 --> 01:20:11,600
So it's really good for stream oriented input.

1305
01:20:12,190 --> 01:20:13,450
Well, this is really good,

1306
01:20:13,450 --> 01:20:16,960
you know if the file has data structure,

1307
01:20:16,960 --> 01:20:21,600
and use one of sort of update basic pieces of the file,

1308
01:20:21,600 --> 01:20:23,850
and you know arbitrary locations.

1309
01:20:32,220 --> 01:20:37,080
Okay, let's see,

1310
01:20:37,110 --> 01:20:42,660
I'm going to start on about to run out of time.

1311
01:20:43,270 --> 01:20:46,200
So let me so stop here,

1312
01:20:46,200 --> 01:20:48,750
hopefully this one tidbit about mmap,

1313
01:20:48,750 --> 01:20:51,150
you know it's useful to know,

1314
01:20:51,540 --> 01:20:56,650
and tells you why you know that sort of is a popular scheme.

1315
01:21:00,080 --> 01:21:01,010
Let's see,

1316
01:21:01,040 --> 01:21:06,560
so I I think that actually you know we were basically we come to the end of this lecture

1317
01:21:06,590 --> 01:21:16,000
and I guess the end of the end of six the six 6.S081,

1318
01:21:16,030 --> 01:21:21,790
and so again you know if you have not filled out the feedback survey,

1319
01:21:21,790 --> 01:21:24,640
you know please do so,

1320
01:21:24,670 --> 01:21:28,300
you know we appreciate if you fill out the subject evaluation.

1321
01:21:29,180 --> 01:21:34,080
And and again I wanna thank you for your attention,

1322
01:21:34,110 --> 01:21:36,330
again it is a strange semester,

1323
01:21:36,330 --> 01:21:38,400
I wish I could have met you all in person.

1324
01:21:39,620 --> 01:21:43,880
Talk to you in person either class or before class or after class,

1325
01:21:44,240 --> 01:21:48,650
and unfortunately, as it happened,

1326
01:21:48,680 --> 01:21:52,940
but I hope you got quite a bit of 6.S081

1327
01:21:52,940 --> 01:21:56,120
and certainly with the staff and thank you for the engagement,

1328
01:21:56,210 --> 01:21:59,060
you guys have been wonderful this semester.

1329
01:21:59,860 --> 01:22:01,800
So with that, thank you.

1330
01:22:03,150 --> 01:22:05,160
If you have any questions, please hang around.

1331
01:22:06,550 --> 01:22:08,500
But I'm sure some of you have deadlines.

1332
01:22:10,100 --> 01:22:12,680
Honestly on behalf of the TAs as well,

1333
01:22:12,680 --> 01:22:15,320
we've really enjoyed all the time

1334
01:22:15,320 --> 01:22:18,110
we spent with you guys in office hours and doing check offs,

1335
01:22:18,110 --> 01:22:20,210
and this is the first semester, we've done check offs,

1336
01:22:20,210 --> 01:22:23,600
and then David and I both found it a really enjoyable process,

1337
01:22:23,600 --> 01:22:25,370
and you know hopefully we were able to

1338
01:22:25,700 --> 01:22:28,610
help you guys out and have some good conversations as well,

1339
01:22:28,610 --> 01:22:30,530
so thanks for making it a great semester

1340
01:22:30,530 --> 01:22:32,540
and adjusting on the fly with us

1341
01:22:32,540 --> 01:22:35,350
with all of the remote learning problems,

1342
01:22:35,350 --> 01:22:37,750
we've run into and had to deal with

1343
01:22:38,020 --> 01:22:39,970
an absolute pleasure achieving this course.

1344
01:22:46,360 --> 01:22:47,320
Any further questions?

1345
01:22:49,170 --> 01:22:50,670
Again, feel free to hang around.

1346
01:23:00,530 --> 01:23:03,260
Oh, I had a question,

1347
01:23:03,800 --> 01:23:06,700
so, it's it's oh yeah,

1348
01:23:06,700 --> 01:23:07,810
thank you so much for the class,

1349
01:23:07,810 --> 01:23:11,500
I really like class, the best class semester,

1350
01:23:11,620 --> 01:23:16,210
I wanted to ask about the interrupts, the received interrupts,

1351
01:23:16,270 --> 01:23:23,160
how does the how does the hardware knows when when the software has finished,

1352
01:23:24,130 --> 01:23:27,970
handling the previous interrupt, not issue another one.

1353
01:23:28,800 --> 01:23:32,220
Because the there's multiple steps,

1354
01:23:32,880 --> 01:23:43,030
one is you know you're looking e1000 at the bottom,

1355
01:23:43,420 --> 01:23:45,010
we re-enable interrupts

1356
01:23:45,400 --> 01:23:46,420
or we tell the card,

1357
01:23:46,420 --> 01:23:48,070
we're ready to receive further interrupts.

1358
01:23:49,170 --> 01:23:52,320
So that's why we tell the card to generate interrupts,

1359
01:23:52,770 --> 01:23:55,410
of course at this point interrupts actually not really turned on,

1360
01:23:55,410 --> 01:23:57,720
and we just tells the card you can generate interrupts again,

1361
01:23:58,280 --> 01:24:00,710
the interrupts get turned on, correct,

1362
01:24:00,710 --> 01:24:04,310
like you know by you know these functions, you know interrupt enable

1363
01:24:04,730 --> 01:24:07,280
and at that point, if you turn on interrupt enable,

1364
01:24:07,280 --> 01:24:12,620
if this field set, plus you know the point where you turn on interrupt enable

1365
01:24:12,650 --> 01:24:14,330
and actually interrupt might happen again.

1366
01:24:15,680 --> 01:24:18,680
Right, I forgot about this register, thank you so much.

1367
01:24:18,680 --> 01:24:22,670
Yeah, it's just like one instruction, easy to miss.

1368
01:24:25,960 --> 01:24:26,770
Any other questions?

1369
01:24:30,500 --> 01:24:31,490
Thank you all.

1370
01:24:32,580 --> 01:24:33,480
Thank you, okay.

1371
01:24:36,520 --> 01:24:37,420
Thank you.

1372
01:24:38,770 --> 01:24:39,850
Thank you.

1373
01:24:40,910 --> 01:24:41,840
Thank you so much.

