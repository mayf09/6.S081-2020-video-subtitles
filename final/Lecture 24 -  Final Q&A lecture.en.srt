1
00:00:06,750 --> 00:00:09,630
Good, good afternoon, quick sound check.

2
00:00:10,510 --> 00:00:11,320
Can people hear me?

3
00:00:12,270 --> 00:00:12,780
Yes.

4
00:00:13,820 --> 00:00:14,570
Thanks.

5
00:00:15,350 --> 00:00:23,180
Okay, so I guess today you know so far it's the last lecture of 6.S081 this semester.

6
00:00:23,960 --> 00:00:30,500
And, we don't really have a formal topic,

7
00:00:30,620 --> 00:00:31,820
there's a Q&A lecture,

8
00:00:32,150 --> 00:00:36,380
so feel free to ask questions about anything,

9
00:00:36,410 --> 00:00:40,490
this is I guess last, your last chance at least this semester for this class.

10
00:00:41,260 --> 00:00:49,090
My default, my plan was to go over a couple topics based on the questions over email,

11
00:00:49,150 --> 00:00:53,100
then I was going to talk a little bit about network lab, the solutions.

12
00:00:53,850 --> 00:00:58,560
If possible, also a little bit of time about the mmap lab,

13
00:01:00,110 --> 00:01:01,760
again talking about those solutions.

14
00:01:02,090 --> 00:01:05,660
And then there were a lot of questions about the following classes

15
00:01:05,810 --> 00:01:09,050
and in fact I think I'll cover that first.

16
00:01:10,120 --> 00:01:15,280
But before diving in any of these three topics,

17
00:01:15,280 --> 00:01:20,390
let me remind you there's a subject evaluation,

18
00:01:22,090 --> 00:01:23,800
outgoing ongoing,

19
00:01:23,800 --> 00:01:27,700
and we, as staff of 6.081,

20
00:01:27,700 --> 00:01:31,900
we appreciate you give your feedback on 6.081.

21
00:01:33,060 --> 00:01:37,410
And hopefully it's positive, you know we get a chance to teach again next year.

22
00:01:39,320 --> 00:01:44,570
And maybe this is also a good time to you know actually thank you for attending today's lecture

23
00:01:44,600 --> 00:01:46,730
even though there's not a sort of very formal program,

24
00:01:46,730 --> 00:01:49,040
they also appreciate the fact that with the staff

25
00:01:49,040 --> 00:01:53,330
and generally appreciate the fact that you know you're being very engaged

26
00:01:53,330 --> 00:01:57,110
and in particular the paper then up directly to the labs,

27
00:01:57,110 --> 00:02:01,940
you know it's clear that many of you dove into the papers and try to really understand them

28
00:02:01,940 --> 00:02:04,760
and ask great great question of over email.

29
00:02:04,760 --> 00:02:09,350
So, we very much appreciate the engagement.

30
00:02:10,780 --> 00:02:15,470
Any questions before I go with each set of topics.

31
00:02:21,540 --> 00:02:27,000
Okay, let me start with the question that probably came up most in email, what next.

32
00:02:28,580 --> 00:02:35,900
There's a quite a number of classes that systems oriented focused,

33
00:02:36,350 --> 00:02:41,330
and I'm sure I missed a number of classes, that I should have listed here,

34
00:02:41,600 --> 00:02:44,660
you know immediately straightly related to operating systems,

35
00:02:44,660 --> 00:02:47,240
you know clearly you know if you haven't taken 6.033 yet,

36
00:02:47,270 --> 00:02:52,460
it's a great class to take particularly we read or learn how to read papers.

37
00:02:52,950 --> 00:02:59,910
6.828 which the originally only OS class we offered,

38
00:02:59,940 --> 00:03:05,790
this year or second year were, this year first year of offering both,

39
00:03:06,090 --> 00:03:08,520
so 6.S081 is undergrad OS

40
00:03:08,520 --> 00:03:14,340
and 6.828 as the grad level OS class.

41
00:03:14,870 --> 00:03:20,120
And you know basically 6.828 issues you've taken 6.S081 or undergrad OS

42
00:03:20,120 --> 00:03:26,150
and you know goes off in new projects and building interesting OS artifacts,

43
00:03:26,680 --> 00:03:28,810
and reading more papers from the literature

44
00:03:28,960 --> 00:03:31,390
and more of the modern research literature.

45
00:03:32,660 --> 00:03:34,430
Then maybe you are more you know,

46
00:03:34,430 --> 00:03:38,000
the OS sort of you know there's a lot of interfacing with the hardware,

47
00:03:38,030 --> 00:03:40,820
would have been more of the hardware side of systems,

48
00:03:40,820 --> 00:03:42,980
you know the computer architecture class 6.823,

49
00:03:42,980 --> 00:03:45,080
which I believe is offered to the coming Spring

50
00:03:45,320 --> 00:03:50,990
and of course there's 6.111 you know sort of the building something hardware devices.

51
00:03:51,460 --> 00:03:55,270
On the sort of performance sides, in the compiler sides,

52
00:03:55,270 --> 00:03:57,820
6.172, 6.035 for a good places,

53
00:03:57,850 --> 00:04:02,020
a number of you are taking 6.172 in parallel with 6.S081,

54
00:04:02,050 --> 00:04:07,780
so but if you have taken for example the compiled class 6.035 or dynamic compiler class,

55
00:04:07,780 --> 00:04:10,240
both of them are also great classes.

56
00:04:11,580 --> 00:04:13,650
System is a broad topic,

57
00:04:13,680 --> 00:04:18,090
so like there's networking and there's a whole branch of classes

58
00:04:18,090 --> 00:04:20,070
whole stream of classes around networking,

59
00:04:20,130 --> 00:04:23,940
with a whole stream of class around databases,

60
00:04:24,240 --> 00:04:27,730
which are all good and important,

61
00:04:27,790 --> 00:04:35,590
and aspects that you've seen 6.S081 will show up in much more prominent ways in those classes.

62
00:04:36,510 --> 00:04:40,440
For example, networking clears a great topic of 6.829

63
00:04:40,440 --> 00:04:43,050
and so you'll see a lot more about networking there,

64
00:04:43,380 --> 00:04:44,970
you've seen in 6.S081,

65
00:04:45,240 --> 00:04:47,790
6.830 you know we talked about file systems,

66
00:04:47,790 --> 00:04:51,150
you know clearly another important classes of storage systems

67
00:04:51,150 --> 00:04:55,410
and probably in some ways more important for many applications, databases,

68
00:04:55,410 --> 00:04:59,700
and so you get 6.830 a great topic class to learn a lot more about databases.

69
00:05:00,780 --> 00:05:06,180
In terms of like classes that are sort of you know sometimes called whatever the PDOS classes,

70
00:05:07,440 --> 00:05:08,970
there's a number of them,

71
00:05:09,030 --> 00:05:16,470
6.824 distributed systems class will be offering that, coming semester Spring semester

72
00:05:16,470 --> 00:05:24,620
and Section of the number of the staff involved this semester in 6.S081 will be involved in 6.824.

73
00:05:25,330 --> 00:05:29,650
There's 6.858 which is a computer security class,

74
00:05:29,830 --> 00:05:33,040
we won't be offering in that coming this Spring,

75
00:05:33,040 --> 00:05:36,220
but we hope to offer it the next academic year.

76
00:05:36,870 --> 00:05:41,100
And there's 6.826 which are principles of computer system,

77
00:05:41,100 --> 00:05:44,970
so a number of people ask about verification and system software,

78
00:05:44,970 --> 00:05:47,730
this is the class you take, if you are interested in that topic.

79
00:05:48,780 --> 00:05:54,300
A more broadly speaking, a lot of people wondering what is actually going on in research,

80
00:05:54,300 --> 00:05:59,730
if you're interested, you know almost all the papers in the systems literature are publicly available,

81
00:05:59,730 --> 00:06:01,890
even the ones of the recent conferences,

82
00:06:01,920 --> 00:06:05,400
for example the OSDI conference happened a couple weeks ago,

83
00:06:05,700 --> 00:06:07,950
and you can just look at them

84
00:06:07,950 --> 00:06:09,840
and see what kind of topics are covered

85
00:06:09,840 --> 00:06:11,760
and read the papers that you find it interesting

86
00:06:11,760 --> 00:06:13,050
all the talks are published,

87
00:06:13,410 --> 00:06:18,390
one of advantages of, you know, conference that all these companies are virtual

88
00:06:18,390 --> 00:06:21,600
and so all the conferences are recorded

89
00:06:21,600 --> 00:06:24,180
and you can just watch them and see what's going on.

90
00:06:24,850 --> 00:06:27,100
If you interested in the sort of two parts,

91
00:06:27,100 --> 00:06:31,120
there's the research part, then of course there's what's going on in practice.

92
00:06:31,120 --> 00:06:37,510
And you know if you're interested in keeping track of what's happening with Linux and how that's how it's evolving,

93
00:06:37,870 --> 00:06:43,510
lwn.net actually publish a very regular page and a very interesting articles

94
00:06:43,510 --> 00:06:48,010
about like big changes or topics that are around the Linux kernel.

95
00:06:49,470 --> 00:06:53,910
Finally you know, if you're just excited about like doing the labs,

96
00:06:53,910 --> 00:06:55,500
you know just keep keep hacking,

97
00:06:55,620 --> 00:07:02,310
I think you can easily to cook up projects are either by doing extension of labs

98
00:07:02,310 --> 00:07:03,870
or just trying things out on your own,

99
00:07:04,740 --> 00:07:09,360
it's a great way to really learn and appreciate how things work.

100
00:07:10,090 --> 00:07:12,310
You probably got a good sense of that during the labs,

101
00:07:12,310 --> 00:07:15,340
we're sort of big fans of learning by doing

102
00:07:15,520 --> 00:07:19,990
and a lot that you can do on your own.

103
00:07:22,930 --> 00:07:29,130
Any questions about what next after 6.S081?

104
00:07:41,410 --> 00:07:42,010
Okay.

105
00:07:43,180 --> 00:07:46,630
Well, let's talk about the net lab,

106
00:07:47,360 --> 00:07:51,890
it was due I guess yesterday.

107
00:07:56,100 --> 00:08:01,440
And so as a couple things maybe I'll start dive in slowly,

108
00:08:01,440 --> 00:08:02,940
I start a little bit at the top

109
00:08:03,300 --> 00:08:08,850
and let me talk a little bit in generic terms about the lab.

110
00:08:13,390 --> 00:08:14,710
There's a couple things right,

111
00:08:14,710 --> 00:08:17,800
first I want to talk a little bit about just sort of structural things,

112
00:08:19,120 --> 00:08:23,650
that sort of influence the design of the lab or you know the coding of the lab.

113
00:08:23,920 --> 00:08:26,500
And there are four different things in aspects,

114
00:08:26,500 --> 00:08:28,660
one of these I just want to talk a little bit about hardware,

115
00:08:29,140 --> 00:08:31,540
you know, this is one of the labs where we,

116
00:08:31,570 --> 00:08:34,360
there's a lot of interaction between software and hardware,

117
00:08:34,360 --> 00:08:39,370
in fact the hardware determines for a great part like how the the structure of this offer.

118
00:08:40,250 --> 00:08:42,470
Then a little bit about software structure,

119
00:08:43,170 --> 00:08:45,660
and just sort of back to this general topic

120
00:08:45,660 --> 00:08:50,520
that we covered in a sort of somewhere in the middle of the term about you know the organization of drivers

121
00:08:50,520 --> 00:08:52,560
relative to the rest of the operating system kernel.

122
00:08:52,890 --> 00:08:55,590
Then talk a little bit more specific about hardware structures,

123
00:08:55,590 --> 00:08:59,680
you know the rings, and you know the descriptors,

124
00:09:02,500 --> 00:09:07,840
are the two primary sort of hardware structures that the driver deals with or it must deal with.

125
00:09:08,780 --> 00:09:12,830
And then I'll talk to talk about the code and particularly the solutions,

126
00:09:13,220 --> 00:09:17,210
and focusing on a little bit about the role of mbufs,

127
00:09:19,780 --> 00:09:22,690
you know locking a lot of questions over email,

128
00:09:22,690 --> 00:09:27,700
about why not to lock in receive lock, receive in the receive function,

129
00:09:27,790 --> 00:09:30,370
why the loop in the receive handler,

130
00:09:31,140 --> 00:09:36,000
and you know what exactly you know the flags meaning the command,

131
00:09:36,060 --> 00:09:40,710
command field of the structure of the descriptor,

132
00:09:40,710 --> 00:09:44,820
and so we'll get to those issues as we as we look at the top as we look at the code.

133
00:09:47,110 --> 00:09:49,450
Just before drive in it, may be worthwhile,

134
00:09:49,450 --> 00:09:54,040
so reminding ourselves here, what the challenges are although they're probably fresh in your head

135
00:09:54,070 --> 00:09:59,680
like from a high level and one of the sort of core talent challenges that you have to deal with in this lab.

136
00:10:01,610 --> 00:10:06,440
If you'll jump in to and any ones that I might have missed and you struggled with.

137
00:10:07,030 --> 00:10:09,610
So, first of all you know there's the hardware specification,

138
00:10:10,120 --> 00:10:15,520
you know it's a PDF, is a pretty serious document,

139
00:10:15,970 --> 00:10:22,420
and this network part E1000 even though it's a reasonable simple network card,

140
00:10:22,420 --> 00:10:25,690
is still a very sophisticated piece of hardware,

141
00:10:25,690 --> 00:10:29,680
that offers a lot of different features and ways you can program

142
00:10:29,710 --> 00:10:35,770
and you're just getting on top of actually what you know the card does and how do you program it,

143
00:10:36,040 --> 00:10:41,680
you know just internalizing all that is difficult and poses a challenge.

144
00:10:46,520 --> 00:10:50,960
Second, I think you know major challenges, the concurrency side of things,

145
00:10:52,620 --> 00:10:57,270
and there's sort of two parts the concurrency that makes this lab challenging,

146
00:10:57,390 --> 00:11:00,210
one is just the concurrency between the hardware and software,

147
00:11:01,060 --> 00:11:06,670
like the network card is just doing things, like sending package, receiving packets at the same time,

148
00:11:06,670 --> 00:11:08,770
you know the OS kernel is running and the driver is running

149
00:11:09,100 --> 00:11:13,420
and so there has to be some coordination plan between the hardware and software,

150
00:11:13,420 --> 00:11:15,790
you know to actually make sure that everything works out.

151
00:11:16,860 --> 00:11:22,800
And a large part of the driver is you know dealing with that coordination.

152
00:11:23,860 --> 00:11:28,180
There's also the software software convert coordination,

153
00:11:28,540 --> 00:11:36,100
the driver multiple threads, where multiple kernel threads might be ending around handler run inside of the driver

154
00:11:36,100 --> 00:11:41,470
and we've got to make sure that they don't step on each other's toes, nothing else happens

155
00:11:41,470 --> 00:11:46,430
and this comes a lot to like you know locking topic.

156
00:11:47,160 --> 00:11:49,140
Even the, even this driver,

157
00:11:49,140 --> 00:11:54,990
thinks a reasonable straightforward, in terms of the concurrency for software concurrency,

158
00:11:55,020 --> 00:11:58,440
but nevertheless you know something that requires attention and a little bit of thinking.

159
00:11:59,260 --> 00:12:04,330
And finally I guess I was probably on the top of your list or many of your list,

160
00:12:04,330 --> 00:12:07,450
just debugging this is a little bit hard,

161
00:12:08,070 --> 00:12:10,740
a little bit something more challenging of pure software debugging,

162
00:12:10,740 --> 00:12:14,490
because you can't set breakpoints inside of the network card,

163
00:12:14,550 --> 00:12:17,340
you know you're in program the registers

164
00:12:17,340 --> 00:12:20,490
and then this would give the card a kick and say like please do your work

165
00:12:20,970 --> 00:12:24,990
and then if the card doesn't do anything or you don't see your packet coming out on the other side,

166
00:12:24,990 --> 00:12:29,720
you know in the log of the packet rates,

167
00:12:30,050 --> 00:12:32,750
then you basically have to scratch your head

168
00:12:32,750 --> 00:12:39,350
and start thinking about what you might have gone wrong or what you might have missed in the hardware specification,

169
00:12:40,220 --> 00:12:42,530
and you have to circle back and forth

170
00:12:42,530 --> 00:12:44,630
and there's no sort of easy way,

171
00:12:44,630 --> 00:12:49,870
you just cannot single step you know through the network card.

172
00:12:52,550 --> 00:12:54,290
Does that make sense in terms of challenges

173
00:12:54,290 --> 00:12:56,840
you know there's that line up with your own experience

174
00:12:56,840 --> 00:13:01,930
or I missing some of the, missing one of the core challenges that you dealt with.

175
00:13:18,330 --> 00:13:20,490
Okay, well, yeah.

176
00:13:21,390 --> 00:13:24,360
Let's talk to the, let's start with the hardware side of things,

177
00:13:24,450 --> 00:13:27,870
and the reason I want to start there,

178
00:13:27,870 --> 00:13:33,000
because you know, it's so easy to keep or lose track of the fact that you're actually dealing with hardware here,

179
00:13:33,360 --> 00:13:38,820
you know even through you know sort of virtualized where it is emulated by QEMU

180
00:13:38,820 --> 00:13:42,810
and you're just running it on your, on Athena or your laptop,

181
00:13:42,960 --> 00:13:46,410
the actual thing that's implemented by QEMU is hardware.

182
00:13:46,590 --> 00:13:48,000
So it's usually gonna remind you again,

183
00:13:48,240 --> 00:13:50,880
you've seen this picture before,

184
00:13:50,880 --> 00:13:52,680
you know the way to think about it is that

185
00:13:52,680 --> 00:13:59,100
you know QEMU emulate a complete board of devices and processor.

186
00:13:59,750 --> 00:14:01,700
And um.

187
00:14:04,220 --> 00:14:07,520
And so we all know I'll talk a little bit before about,

188
00:14:07,520 --> 00:14:13,700
the processor actually these are like almost like a small piece of the whole board,

189
00:14:13,700 --> 00:14:15,440
you know the thing that sits on the fan here,

190
00:14:15,680 --> 00:14:22,310
but then there's a range of devices, you know that are connected or can be connected to this board

191
00:14:22,640 --> 00:14:26,840
and then interact you know we use the code running on the processor,

192
00:14:26,840 --> 00:14:29,210
you know here use this particular lab,

193
00:14:29,210 --> 00:14:32,930
what is really interesting sort of, it is actually Ethernet jack

194
00:14:33,050 --> 00:14:34,970
where you can block Ethernet cable

195
00:14:34,970 --> 00:14:38,660
and then the other is actually the thing that the network card you know sends its package over.

196
00:14:40,440 --> 00:14:44,250
You know, QEMU doesn't emulate exactly this board,

197
00:14:44,520 --> 00:14:45,690
so things like are slightly differently,

198
00:14:45,690 --> 00:14:50,700
but again you know at least conceptually, this is like the picture, you should have in your in your head right

199
00:14:50,700 --> 00:14:54,210
and so when there's a process writing registers,

200
00:14:54,210 --> 00:14:57,540
you know of the device driver that costs some stuff to happen

201
00:14:57,540 --> 00:15:00,000
that actually ends some packages comes out of this cable

202
00:15:00,240 --> 00:15:03,370
that's connected to Ethernet connector.

203
00:15:05,840 --> 00:15:16,940
You know in a slightly more you know in a slightly more in a schematic diagram,

204
00:15:16,940 --> 00:15:19,430
you know this is the same picture basically in here,

205
00:15:19,430 --> 00:15:21,440
you know we're seeing here is our processor,

206
00:15:21,920 --> 00:15:24,230
board that has four cores on it,

207
00:15:24,440 --> 00:15:26,960
it has l1 and l2 cache,

208
00:15:26,960 --> 00:15:29,420
and then there's like a link you know go to memory,

209
00:15:29,570 --> 00:15:32,690
so here's a memory, and when I RAM random access memory

210
00:15:32,690 --> 00:15:36,110
and as we'll see in a second, you know that play is actually big role.

211
00:15:36,520 --> 00:15:43,000
And here like intersection to link you know to the, for here actually it's linked to the gigabit Ethernet controller.

212
00:15:44,350 --> 00:15:51,870
You know, just a little bit messy you sort of think about the this level of detail what exactly is going on.

213
00:15:51,930 --> 00:15:56,040
And so for the rest of lecture here a little bit more simpler picture,

214
00:15:58,240 --> 00:16:01,450
and the picture guys really you're you're in your head

215
00:16:01,780 --> 00:16:06,340
and you probably developed while doing lab is as follows.

216
00:16:07,780 --> 00:16:14,290
Basically have are basically four processors, or cores,

217
00:16:15,470 --> 00:16:16,880
here's are RISC-V,

218
00:16:19,120 --> 00:16:26,020
and then there's RISC-V of cores and execute instructions, you're you're writing,

219
00:16:26,170 --> 00:16:29,560
and you can just think about them, they're sort of all connected to your bus

220
00:16:29,560 --> 00:16:31,840
and then there's a little bit of a simplification,

221
00:16:31,840 --> 00:16:34,360
but like it makes it easier to explain things.

222
00:16:34,780 --> 00:16:37,870
And so on the bus, you know there's the random access memory,

223
00:16:40,030 --> 00:16:45,670
where all the data you know the kernel actually uses historic, the kernel [] that itself stores,

224
00:16:45,670 --> 00:16:48,610
you know look at there's a great amount of detail in the beginning of the semester.

225
00:16:49,000 --> 00:16:50,860
And then this you know for this particular lab,

226
00:16:50,860 --> 00:16:59,360
the thing that's interesting is that on the bus, is actually the network card, you know E1000 what E1000.

227
00:17:01,910 --> 00:17:08,150
And you know the RAM is generally more connected to the RISC-V processor directly with some private bus

228
00:17:08,330 --> 00:17:13,250
and network devices tend to be on a slower type of bus,

229
00:17:13,460 --> 00:17:15,530
in particular bus that in the lab,

230
00:17:15,530 --> 00:17:24,090
you know there's a PCIa PCIe bus that actually connects the processor part, you know with the network part.

231
00:17:27,260 --> 00:17:29,870
You know to get the network to do something,

232
00:17:29,990 --> 00:17:33,710
the network card has controller inside of it

233
00:17:33,710 --> 00:17:35,960
and you know these controller has registers.

234
00:17:37,690 --> 00:17:46,180
And you can, one of the cool aspects of you know these registers, they are called memory mapped IO registers

235
00:17:46,390 --> 00:17:52,870
and so you could just write them with whatever a star you know, 0x and whatever the value is

236
00:17:52,870 --> 00:17:57,310
you know or in the physical memory space what the value is for that particular register.

237
00:17:57,760 --> 00:18:01,290
you know, like we might have our head, our tail registers.

238
00:18:02,260 --> 00:18:10,210
And you know we can, the driver can write those by executing load or store instruction, you know to the address,

239
00:18:10,210 --> 00:18:15,220
you know, of corresponds you know in the physical address space to the location of that register.

240
00:18:15,770 --> 00:18:18,620
And the hardware will ensure when we do load or store,

241
00:18:18,710 --> 00:18:21,950
you know that that store will either go you know go to the,

242
00:18:22,660 --> 00:18:25,900
if it is one of the control register, will go to the control registers,

243
00:18:25,900 --> 00:18:29,470
if the go once address is in RAM will go to the RAM.

244
00:18:31,270 --> 00:18:38,590
So you can just manipulate the program network card by loading, reading and writing these control registers

245
00:18:38,590 --> 00:18:42,310
and basically bits in these control registers have special meaning as you have seen.

246
00:18:43,570 --> 00:18:49,790
Um, now, for this particular card you know network needs to send packets across the network,

247
00:18:49,940 --> 00:18:52,070
and you know it needs to get the packet somewhere.

248
00:18:53,010 --> 00:18:59,820
And so, the packets actually live, you know are allocated as we'll see in a second you know just live somewhere in memory,

249
00:19:01,930 --> 00:19:06,910
and and what we do is, in fact, in addition to these packets,

250
00:19:06,910 --> 00:19:09,910
you know there's sort of two ring structures that also live in memory.

251
00:19:14,420 --> 00:19:20,710
And, and we can you know program,

252
00:19:20,800 --> 00:19:25,540
and we can tell the card, you know the card also knows where these ring structures are,

253
00:19:26,230 --> 00:19:28,900
you know it has address where to you know tx ring is

254
00:19:28,900 --> 00:19:32,400
you know it has an address where to rx ring is

255
00:19:32,850 --> 00:19:39,720
and you know the hardware card looks at those addresses to actually see which packets need to be sent,

256
00:19:39,840 --> 00:19:43,710
so here we might have a queue of packets that need to be transmitted

257
00:19:43,710 --> 00:19:45,690
or a queue packets that need to be received.

258
00:19:48,910 --> 00:19:55,610
And, you know, the E1000 you know DMAs

259
00:19:55,610 --> 00:20:01,130
you know, for example like you know they're going to work on the first factor to sent,

260
00:20:01,130 --> 00:20:06,290
will DMA basically you know those packets data associated with the the packets,

261
00:20:06,440 --> 00:20:09,260
you know straight from RAM to the network,

262
00:20:09,980 --> 00:20:12,350
without actually having the processor involved at all,

263
00:20:13,400 --> 00:20:15,110
what is called DMA, direct memory access.

264
00:20:19,130 --> 00:20:19,910
Okay.

265
00:20:21,890 --> 00:20:32,120
This makes sense in terms of a more abstract picture a for the organization of the RISC-V RAM and E1000.

266
00:20:33,070 --> 00:20:34,330
Any questions about this?

267
00:20:41,500 --> 00:20:45,490
So, one thing in talking about hardware, software concurrency,

268
00:20:45,550 --> 00:20:49,690
clearly you know the E1000 and you know the processor

269
00:20:49,690 --> 00:20:56,560
or both manipulating these transmission and reception queues or rings.

270
00:20:57,030 --> 00:21:01,170
And so, there has to be some protocol sort of give and take in a given take protocol,

271
00:21:01,230 --> 00:21:08,790
where you know at some point, particular parts of the ring are operated through are owned or operated by the network card,

272
00:21:08,790 --> 00:21:12,840
and there are parts that are maybe under control of the software or the OS kernel.

273
00:21:13,500 --> 00:21:15,750
And you'll see in the second half that is arranged,

274
00:21:15,960 --> 00:21:18,270
but you know we got a little bit careful again,

275
00:21:18,270 --> 00:21:24,090
that the concurrent doesn't trip over or trip over the operating system or the other way around.

276
00:21:28,540 --> 00:21:35,140
A quick question, so is there a separate transmit ring and and receive ring in the RAM

277
00:21:35,140 --> 00:21:40,270
and then, also in the E1000 or E1000 driver.

278
00:21:40,570 --> 00:21:41,710
Yeah, well the one way,

279
00:21:41,710 --> 00:21:43,330
okay so there's two things going on

280
00:21:43,330 --> 00:21:44,920
and we look at the code in a second,

281
00:21:45,100 --> 00:21:51,190
the the the transmission ring and receiving basically lived in RAM.

282
00:21:51,740 --> 00:21:58,730
And both the E1000 and the RISC-V manipulates the ring that actually stored in RAM.

283
00:22:01,140 --> 00:22:04,950
And those are the rings that you saw in the hardware documentation.

284
00:22:05,520 --> 00:22:12,780
It happens to be the case that xv6 also has a driver maintains a sort of a ring of mbufs,

285
00:22:13,110 --> 00:22:16,770
separately of the transmit ring and rx ring,

286
00:22:16,830 --> 00:22:18,840
like there's something like tx mbufs.

287
00:22:21,460 --> 00:22:25,420
And that's you know that is the data structure only the operating system really knows about,

288
00:22:25,840 --> 00:22:28,150
the network card doesn't really know about it

289
00:22:28,150 --> 00:22:33,760
and network card only knows about the the tx ring and rx ring,

290
00:22:33,850 --> 00:22:37,600
because those are the values that were programmed into the registers,

291
00:22:37,720 --> 00:22:41,470
saying like here's where you can find here's the address where you can find the transmit ring,

292
00:22:41,530 --> 00:22:43,270
here's the address where you can find the receive ring.

293
00:22:44,520 --> 00:22:45,450
Yeah, that makes sense.

294
00:22:45,660 --> 00:22:46,260
That makes sense?

295
00:22:49,840 --> 00:22:55,750
Okay, so that's sort of the hardware picture, in a more schematic version,

296
00:22:55,930 --> 00:22:58,180
let's talk a little bit about the software structure.

297
00:22:59,520 --> 00:23:02,760
There's a big confusing actually in this in this lab.

298
00:23:05,870 --> 00:23:07,010
So software structure.

299
00:23:12,050 --> 00:23:17,330
So, let's just draw you know the thing that we most care about, of course you know the driver,

300
00:23:17,360 --> 00:23:21,970
so here's our driver, the e1000 driver.

301
00:23:26,150 --> 00:23:28,790
And it basically has only two functions,

302
00:23:29,000 --> 00:23:37,600
as a transmit function, and it has a receive function.

303
00:23:40,810 --> 00:23:44,530
And the receive function runs in response to interrupts.

304
00:23:46,300 --> 00:23:53,860
So an interrupt happens, then you know xv6, you will use the usual interrupt mechanism,

305
00:23:53,860 --> 00:23:58,540
you know a trap happen, trap look you know to see if there's an interrupt from the network card,

306
00:23:58,540 --> 00:24:01,240
if there's an interruption, the network card will call the receive function.

307
00:24:02,600 --> 00:24:07,490
And as you remember we used to have one of the previous lectures about device drivers,

308
00:24:07,580 --> 00:24:11,270
you know it's often helpful to think of the device drivers were split in two parts.

309
00:24:11,760 --> 00:24:16,530
You know the bottom half which runs in the context of of interrupt handler,

310
00:24:18,160 --> 00:24:20,320
typically name for those in the top half,

311
00:24:22,880 --> 00:24:29,360
which generally runs in the context of you know kernel process or like a user level process,

312
00:24:29,360 --> 00:24:32,750
so for example if you think about things that sit on top of here,

313
00:24:32,930 --> 00:24:40,910
there's the network stack code that actually implements you know IP UDP and etc, sit above this.

314
00:24:41,430 --> 00:24:46,110
And then you know there is, you know, our usual you know sort of line,

315
00:24:47,160 --> 00:24:50,220
you know kernel space blow, user space up

316
00:24:50,220 --> 00:24:53,250
and you know this is very OS view of the world

317
00:24:53,250 --> 00:24:56,820
where user space not particularly that big or important

318
00:24:57,090 --> 00:25:02,580
and, you know example are t whatever net test in the user level program

319
00:25:03,090 --> 00:25:06,360
runs user space and it makes system calls,

320
00:25:06,780 --> 00:25:10,650
system calls go to the network stack,

321
00:25:11,010 --> 00:25:19,120
for example like if you knew calls the write system call, with a file descriptor,

322
00:25:19,420 --> 00:25:22,630
the kernel knows you know for that file descriptor, if you do write,

323
00:25:22,630 --> 00:25:25,360
then you know the write should go to the network stack,

324
00:25:25,540 --> 00:25:27,520
the network stack builds up the packets

325
00:25:27,700 --> 00:25:29,260
and then it calls transmit.

326
00:25:30,830 --> 00:25:36,530
And then transmits whatever manipulates the transmission queue that the tx queue or ring

327
00:25:36,710 --> 00:25:39,980
and you know that actually gets packets, you know often network,

328
00:25:40,010 --> 00:25:42,590
at some point a response might go back come back,

329
00:25:42,590 --> 00:25:44,120
you know that will generate an interrupt

330
00:25:44,270 --> 00:25:50,090
and then the receive function will run and inspect you know the receive ring, right.

331
00:25:50,760 --> 00:25:53,010
So there's a couple things that you know wanna,

332
00:25:53,560 --> 00:25:57,460
I want to point out you know in terms of concurrency.

333
00:25:58,060 --> 00:26:00,670
And so, first of all, like the interrupt handler,

334
00:26:00,670 --> 00:26:03,520
basically can run at any instant in time right,

335
00:26:03,520 --> 00:26:05,380
you know you might be user space,

336
00:26:05,380 --> 00:26:12,790
and if interrupt comes in you know the interrupt mechanism will cost you know the current user program to switch to the kernel mode,

337
00:26:12,790 --> 00:26:16,330
you know the trap functionality of code, we've seen before it runs

338
00:26:16,330 --> 00:26:17,770
and it will all received.

339
00:26:17,770 --> 00:26:20,230
So we might be in the middle of some user process,

340
00:26:20,230 --> 00:26:23,080
in boom, we get an interrupt and suddenly we're in the receive function.

341
00:26:23,900 --> 00:26:26,630
And even in the kernel like if we're not holding locks,

342
00:26:26,630 --> 00:26:28,070
you know locks turn interrupts off,

343
00:26:28,070 --> 00:26:30,620
but we're not holding locks, we could get an interrupt

344
00:26:30,620 --> 00:26:36,770
and the kernel may change the program counter basically to the interrupt handler

345
00:26:36,770 --> 00:26:38,750
and run the receive function.

346
00:26:39,560 --> 00:26:42,530
So this code sort of runs you know the things that in the bottom half,

347
00:26:42,530 --> 00:26:45,200
you know can basically run instantly almost anytime.

348
00:26:45,950 --> 00:26:53,300
In the code, in the top half, it really operates on behalf of a user level processes or kernel threads

349
00:26:53,300 --> 00:26:57,510
that actually make calls into the top half.

350
00:26:58,080 --> 00:26:59,760
You know easily could have been the case,

351
00:27:00,060 --> 00:27:02,160
in fact this is the case even in net test,

352
00:27:02,160 --> 00:27:07,170
we might actually have net test for a whole bunch of processes,

353
00:27:07,470 --> 00:27:10,200
that we have actually many instances one of the tests.

354
00:27:10,230 --> 00:27:12,210
We have many instances of net test running,

355
00:27:14,700 --> 00:27:17,190
and they all jump into the network stack,

356
00:27:17,190 --> 00:27:20,370
and they all you know then called transmit, right.

357
00:27:20,820 --> 00:27:21,900
So that is the case,

358
00:27:21,900 --> 00:27:24,240
so we're looking at this from the perspective concurrency,

359
00:27:24,420 --> 00:27:29,280
multiple senders can be actually in the context, it can be in the top half

360
00:27:29,310 --> 00:27:34,260
and so it's pretty clear, you know we need some locking scheme or discipline

361
00:27:34,260 --> 00:27:38,640
to at least make sure that different senders don't trip over each other.

362
00:27:40,380 --> 00:27:41,910
Then on the bottom half,

363
00:27:42,480 --> 00:27:44,970
there's only one interrupt handler correct,

364
00:27:45,060 --> 00:27:50,880
there's never, in the case that the receive is going to be called by multiple, there's multiple receivers running at the same time

365
00:27:51,270 --> 00:27:57,000
in parallel on different cores, you know the the interrupt handler when an interrupt happens,

366
00:27:57,270 --> 00:27:59,130
the process is alert it.

367
00:27:59,560 --> 00:28:06,610
And if future interrupts happen, they're actually blocked until the current interrupt actually dealt with

368
00:28:06,820 --> 00:28:11,670
and so in fact, when the receive function runs,

369
00:28:11,910 --> 00:28:18,030
there's actually only one interrupt handler running, at the time that calls for receive.

370
00:28:18,760 --> 00:28:24,360
And so there's no real immediately concurrency in receive itself,

371
00:28:24,360 --> 00:28:31,200
although of course the transmit you know threads can run concurrently with the interrupt handler,

372
00:28:31,200 --> 00:28:34,110
for example we might have one core running an interrupt handler,

373
00:28:34,320 --> 00:28:37,950
may have another core actually is about to transmit.

374
00:28:39,860 --> 00:28:43,530
This, any questions about this?

375
00:28:45,870 --> 00:28:50,540
It's sort of important to have, to understand.

376
00:28:51,310 --> 00:28:53,350
It's a bit of review but it's important too.

377
00:29:00,400 --> 00:29:01,000
Okay, so.

378
00:29:01,030 --> 00:29:03,700
I guess I have a general question,

379
00:29:03,790 --> 00:29:09,760
how do we know, what is supposed to be classified as a bottom half and the top half.

380
00:29:10,430 --> 00:29:13,250
So, yeah I think the way to think about it is that

381
00:29:13,250 --> 00:29:16,280
anything that runs in the context of an interrupt handler, that's the bottom half.

382
00:29:17,330 --> 00:29:19,370
And in this case is basically just receive.

383
00:29:20,700 --> 00:29:27,880
And anything that runs in the context of regular process, or thread kernel thread, you know that's the top half.

384
00:29:32,200 --> 00:29:37,720
Okay, so if you look at this picture a little bit more,

385
00:29:38,080 --> 00:29:41,770
since we're, actually let me have a high level statement here,

386
00:29:41,920 --> 00:29:49,620
a lot of people ask you know why no locking receive, and where is lock needed.

387
00:29:49,950 --> 00:29:53,070
And so the first glance,

388
00:29:53,680 --> 00:29:56,200
it might not be necessary to lock if necessary correct,

389
00:29:56,200 --> 00:29:59,710
because there's only one instance of receive running,

390
00:29:59,740 --> 00:30:02,620
so there's not multiple instances of receive running at the same time

391
00:30:02,770 --> 00:30:07,450
and so these receives, since there's only one receive, it doesn't share data structures with any other receive,

392
00:30:07,450 --> 00:30:08,860
because there's only one of them, right.

393
00:30:09,380 --> 00:30:13,640
Now, of course it could be the case that the receive and the transmitter shared data structures,

394
00:30:13,670 --> 00:30:16,340
but as we see in a second that actually is not the case,

395
00:30:16,860 --> 00:30:24,900
basically the transmission part of the driver is completely separate from the reception part of the driver, receiving packets.

396
00:30:25,380 --> 00:30:29,400
And so as a result, receive doesn't really, doesn't need actually locks,

397
00:30:29,430 --> 00:30:32,700
you know it's really not sharing data structures with any other concurrent activity.

398
00:30:34,400 --> 00:30:37,910
A weird part is that you know some of you found out

399
00:30:37,910 --> 00:30:41,380
if you do use a lock, you actually get a panic.

400
00:30:42,100 --> 00:30:44,470
And so let me say a little bit about that,

401
00:30:44,470 --> 00:30:48,580
because the reason that panic happens is a little bit because,

402
00:30:48,580 --> 00:30:58,750
there's a this the software structure actually in in xv6 kernel slightly, slightly more complicated than you might think

403
00:30:58,960 --> 00:31:04,630
and the reason is that basically the receive interrupt handler just quite a bit of work,

404
00:31:05,140 --> 00:31:06,790
or can do quite a bit of work,

405
00:31:07,090 --> 00:31:08,470
so let me talk a little bit about it.

406
00:31:09,430 --> 00:31:12,700
In the particular case that actually does quite a bit of work,

407
00:31:12,700 --> 00:31:16,550
for example ARP requests,

408
00:31:20,180 --> 00:31:23,690
ARP is one of those packet types that Robert talked about a little while ago,

409
00:31:23,990 --> 00:31:26,720
but basically what happens like an interrupt comes in,

410
00:31:27,570 --> 00:31:31,560
so an ARP request for discovery,

411
00:31:31,560 --> 00:31:35,700
but the ethernet addresses were an IP address you know comes in,

412
00:31:35,700 --> 00:31:39,620
you know that will call you know eth1000_recv,

413
00:31:43,400 --> 00:31:46,700
and you know it'll call whatever net_rx,

414
00:31:46,700 --> 00:31:51,500
so that will go call into the network stack on the previous pictures,

415
00:31:51,500 --> 00:31:55,280
of that receives calls into this code over here,

416
00:31:56,460 --> 00:32:10,680
net receive you know calls oops net receive calls net_rx_arp.

417
00:32:12,690 --> 00:32:16,560
And it and you know it looks you know there's an ARP packet

418
00:32:16,560 --> 00:32:24,000
and basically sends back the ethernet address [] for this particular for xv6

419
00:32:24,210 --> 00:32:27,270
and then the way it does that of course you know to send the packet,

420
00:32:27,270 --> 00:32:36,860
it will call you know, e1000_transmit right.

421
00:32:36,860 --> 00:32:40,280
And you know we know that will actually need to acquire a lock,

422
00:32:42,070 --> 00:32:45,550
well, you did that you know whenever there's eth1000_lock.

423
00:32:50,860 --> 00:32:53,020
The reason that actually has to go on a lock is

424
00:32:53,020 --> 00:32:59,350
because there might be multiple senders and you know the senders should not trip over over, trip over each other.

425
00:33:00,440 --> 00:33:02,270
So that's sort of the picture,

426
00:33:02,270 --> 00:33:04,520
so what we're basically in terms of this previous picture,

427
00:33:04,520 --> 00:33:05,840
what we're seeing here is that,

428
00:33:06,590 --> 00:33:12,770
the bottom half may end up call the code in the top half

429
00:33:12,950 --> 00:33:16,010
and come back into the driver through the top half.

430
00:33:17,400 --> 00:33:20,940
And a number of, you know you run into trouble with that,

431
00:33:20,940 --> 00:33:29,610
because you know the you know it's not 100% clear that you didn't need a locks in the receiving part

432
00:33:29,730 --> 00:33:32,070
and so quite a number of you run into this particular bug,

433
00:33:32,070 --> 00:33:43,700
where you're actually required the you know eth1000_lock in receive.

434
00:33:45,460 --> 00:33:48,400
And that worked all fine correctly, except once in a while you get a panic.

435
00:33:49,670 --> 00:33:51,110
Why do you get the panic.

436
00:33:52,140 --> 00:33:54,060
Hopefully with this picture, that's pretty clear, but.

437
00:33:59,400 --> 00:34:01,590
I mean, isn't it going to be the same lock,

438
00:34:01,590 --> 00:34:05,280
because that the e1000_transmit is going to try to acquire down the stack.

439
00:34:05,610 --> 00:34:07,020
Yeah exactly, correct,

440
00:34:07,380 --> 00:34:10,110
so eth1000 here at this point now owns the lock,

441
00:34:10,320 --> 00:34:15,420
holds it calls net_rx, calls net_rx_arp, e1000_transmit, then calls acquire again

442
00:34:15,780 --> 00:34:17,760
and as you might remember from previous labs,

443
00:34:17,940 --> 00:34:21,240
if require it's called it's already held,

444
00:34:21,610 --> 00:34:23,440
that's a deadlock right,

445
00:34:23,440 --> 00:34:25,600
and so xv6 kernel panics.

446
00:34:28,240 --> 00:34:32,620
Question, let's let's assume we had a slightly different implementation of locks,

447
00:34:32,620 --> 00:34:34,630
such as those [fanatics] and other care,

448
00:34:35,480 --> 00:34:40,820
like it would such, let's assume like if I wanted to acquire a lot already held nothing happened.

449
00:34:41,060 --> 00:34:45,110
Yeah so, these are these are called recursive locks,

450
00:34:47,660 --> 00:34:50,750
or reentrant locks is another way the name for them.

451
00:34:51,580 --> 00:34:54,460
And so if you have a recursive locks, reentrant locks,

452
00:34:54,460 --> 00:34:57,520
then you know you could freely do this and it would be no problem.

453
00:34:58,170 --> 00:35:04,170
And I think one of you over email mentioned to me that actually the implemented recursive locks

454
00:35:04,230 --> 00:35:05,970
to actually deal with this particular problem.

455
00:35:06,660 --> 00:35:11,100
And so they did required to lock in the eth1000_recv function,

456
00:35:11,370 --> 00:35:18,720
and you know after the panic, basically fixed acquire release in the xv6 direction support recursive locks.

457
00:35:20,760 --> 00:35:21,810
And that would be a solution.

458
00:35:23,240 --> 00:35:25,820
A simple solution, it's a fine solution,

459
00:35:25,880 --> 00:35:31,970
a solution that we intended and the staff solution as is

460
00:35:31,970 --> 00:35:35,120
basically just doesn't require locks in receive at all,

461
00:35:35,120 --> 00:35:37,100
because it actually turned out not to be necessary.

462
00:35:39,910 --> 00:35:45,070
Sorry, can you say again, why there couldn't be two threads in receive.

463
00:35:46,550 --> 00:35:49,310
There's only one thread in receive, the interrupt handler runs.

464
00:35:49,930 --> 00:35:53,200
There's only one receive function ever running at the time on any core.

465
00:35:54,110 --> 00:36:00,770
That actually calls into the top half of the, the top half of the operating system

466
00:36:01,160 --> 00:36:04,280
and that calles back out into the bottom half,

467
00:36:05,180 --> 00:36:07,940
sorry not in the bottom, that calls back into e1000_transmit

468
00:36:07,940 --> 00:36:09,980
and transmit definitely needs to acquire a lock,

469
00:36:10,430 --> 00:36:15,010
so even receive, eth1000_recv, while holding the lock

470
00:36:15,100 --> 00:36:20,650
calls e1000_transmit which tries to acquire the same lock that the interrupt handler already holds,

471
00:36:21,600 --> 00:36:25,080
if you have, if you locked in receive handler.

472
00:36:26,830 --> 00:36:30,270
I see, so so it is the case,

473
00:36:30,270 --> 00:36:33,060
like one interrupt can go off

474
00:36:33,060 --> 00:36:39,510
and then while it's still running another interrupt could go off as well, is.

475
00:36:39,510 --> 00:36:42,870
No, no the picture, maybe go back to this picture,

476
00:36:43,170 --> 00:36:46,370
so interrupt happens, that calls the receive function,

477
00:36:46,760 --> 00:36:48,500
there's only one receive function running,

478
00:36:48,620 --> 00:36:53,390
that receive function calls you know rx net receive,

479
00:36:53,390 --> 00:36:55,220
that calls rx net receive arp

480
00:36:55,430 --> 00:36:58,040
and that arp function calls transmit,

481
00:36:58,740 --> 00:37:02,460
and if you were using the same lock in transmit and receive,

482
00:37:02,580 --> 00:37:03,870
you know you would get a deadlock.

483
00:37:08,100 --> 00:37:09,600
Okay I see, thank you.

484
00:37:13,660 --> 00:37:14,710
That's sort of, yeah, okay,

485
00:37:15,540 --> 00:37:17,430
and so basically the two solutions to this,

486
00:37:17,460 --> 00:37:19,440
one is to use recursive locks,

487
00:37:20,370 --> 00:37:24,560
other solution was no walks in receive,

488
00:37:25,790 --> 00:37:27,740
or you know, have two locks.

489
00:37:31,040 --> 00:37:33,260
All three of them are totally reasonable solutions.

490
00:37:37,000 --> 00:37:38,050
Any questions about this?

491
00:37:39,070 --> 00:37:42,610
Would there be a reason to have a lock around receive at all.

492
00:37:42,910 --> 00:37:46,360
No, in this particular case, there's no reason to have a lock at all.

493
00:37:49,540 --> 00:37:54,490
What would be, could we think of a situation where you would want a receive lock,

494
00:37:54,490 --> 00:37:57,970
would be like if you had two network cards or something.

495
00:37:58,550 --> 00:38:03,620
Yeah, or if you like if you remember in the UART code,

496
00:38:03,980 --> 00:38:10,760
okay, so may a common reason why you might want to have a locking shared is

497
00:38:10,760 --> 00:38:15,020
because the bottom half, in the top half a shared data structures.

498
00:38:17,200 --> 00:38:21,850
So, for example the receive and transmit might manipulate the same shared data structures,

499
00:38:22,090 --> 00:38:24,100
at that point you need you need a lock,

500
00:38:24,160 --> 00:38:26,560
and so for example you remember from your console driver,

501
00:38:27,060 --> 00:38:28,320
they shared a queue,

502
00:38:29,100 --> 00:38:32,970
and so receive handler needed to get queue,

503
00:38:33,120 --> 00:38:35,550
need to lock to actually get access to that queue.

504
00:38:39,480 --> 00:38:40,680
Does that answer your question?

505
00:38:42,500 --> 00:38:43,580
Yeah, thanks.

506
00:38:44,720 --> 00:38:47,510
And so this brings me up with a second sort of point I wanted to make.

507
00:38:48,230 --> 00:38:53,930
That the let me actually draw a new picture, because it gets a little crowded.

508
00:38:54,350 --> 00:38:57,740
We think about this bottom half again, ane the top half.

509
00:39:00,670 --> 00:39:04,390
So here's the bottom little bit abstract, but you know it may be helpful.

510
00:39:07,110 --> 00:39:11,610
In much typically in much software, driver software,

511
00:39:11,640 --> 00:39:16,560
the bottom half basically doesn't really call into the top half at all.

512
00:39:17,360 --> 00:39:20,870
So, for example if you go back and you look at the console code,

513
00:39:21,080 --> 00:39:24,500
this sequence of secrets cannot happen there

514
00:39:24,530 --> 00:39:28,310
and the reason doesn't happen is because the bottom half typically does very little work,

515
00:39:28,550 --> 00:39:32,330
the only thing it does maybe you grab the packet, stick the packet in the queue.

516
00:39:34,000 --> 00:39:35,560
And then, at some point later,

517
00:39:35,680 --> 00:39:40,980
you know the the top half, you know there's a separate thread in the top half

518
00:39:40,980 --> 00:39:43,590
that basically looks at that queue and then grabs packets out of the queue,

519
00:39:43,590 --> 00:39:45,570
and then keeps on doing whatever needs to be done.

520
00:39:46,400 --> 00:39:51,650
Now, for simplicity a in this simplicity and reduce the amount of code,

521
00:39:51,860 --> 00:39:54,620
that is not the structure that these particular driver follows,

522
00:39:54,830 --> 00:39:58,800
this driver once in a while may actually call up in,

523
00:39:58,800 --> 00:40:02,840
call up actually sometimes this structure is followed by the driver,

524
00:40:02,840 --> 00:40:05,690
but once in awhile, it can actually go into the top half

525
00:40:05,780 --> 00:40:07,970
and come back out into the bottom half.

526
00:40:15,210 --> 00:40:16,140
Any questions about this?

527
00:40:23,120 --> 00:40:27,500
Okay, so that's sort of I guess software concurrency

528
00:40:27,500 --> 00:40:28,970
and we'll come back to a little more later,

529
00:40:28,970 --> 00:40:30,920
if we look at the code in a bit more detail.

530
00:40:31,440 --> 00:40:33,570
Talk a little bit about the rings.

531
00:40:37,540 --> 00:40:39,640
And so basically the way you think about it,

532
00:40:39,640 --> 00:40:42,670
you know there ring,

533
00:40:42,880 --> 00:40:47,260
there's two rings and one for receiving and one for sending,

534
00:40:47,260 --> 00:40:51,790
you know tx rx both lives in RAM.

535
00:40:52,510 --> 00:40:58,600
And you know they're manipulated by code running on the RISC-V cores

536
00:40:58,600 --> 00:41:01,030
and by you know the network card itself.

537
00:41:01,710 --> 00:41:04,170
So there has to be some protocol between the network card

538
00:41:04,170 --> 00:41:07,380
and the RISC-V of course,

539
00:41:07,410 --> 00:41:09,780
about who gets to look at what,

540
00:41:10,020 --> 00:41:15,270
and so the way this is a very common organization in hardware devices,

541
00:41:15,270 --> 00:41:16,680
the way that typically is done,

542
00:41:16,680 --> 00:41:18,690
there's sort of, look at the transmit queue,

543
00:41:18,690 --> 00:41:21,930
there's basically a queue of some fixed size structures descriptors,

544
00:41:21,960 --> 00:41:23,790
as we'll looking in a second,

545
00:41:24,060 --> 00:41:25,230
these are the descriptors.

546
00:41:29,360 --> 00:41:39,260
And the organization or the coordination that is actually a that's happening between the driver and network card is

547
00:41:39,260 --> 00:41:46,140
the consumer producer coordination.

548
00:41:47,430 --> 00:41:49,350
Basically, one way to think about it,

549
00:41:49,350 --> 00:41:52,470
you know there is a if this is the transmit queue,

550
00:41:52,470 --> 00:41:54,450
you know there's maybe there's a head pointer,

551
00:41:56,520 --> 00:41:57,840
there's a tail pointer,

552
00:42:00,440 --> 00:42:04,400
and you know this the tail pointer is controlled by the software.

553
00:42:05,580 --> 00:42:07,590
And so the software looks at the tail pointer,

554
00:42:07,590 --> 00:42:10,650
and if once in a minute, send another packet,

555
00:42:10,650 --> 00:42:14,910
sticks it, you know in a the ring at the location of tail plus one

556
00:42:14,910 --> 00:42:17,400
and then moves up tail pointing in that direction.

557
00:42:19,240 --> 00:42:22,330
And the head pointer is usually controlled by the hardware.

558
00:42:24,750 --> 00:42:27,030
So tail by software, head by hardware

559
00:42:27,030 --> 00:42:29,820
and basically the you know the hardware basically looks at the head

560
00:42:29,820 --> 00:42:31,980
and this is the first packet that is going to be sent,

561
00:42:32,040 --> 00:42:34,530
you know there's a little bit of information in the descriptor

562
00:42:34,680 --> 00:42:38,310
or enough information that descriptor for the network card to look at

563
00:42:38,310 --> 00:42:43,770
and say like oh this is the bytes that I need to move on to the move on to the cable.

564
00:42:44,950 --> 00:42:48,670
And once it's done, it moves the head pointer in that direction,

565
00:42:48,790 --> 00:42:52,630
once it's consumed, you know one of the packets out of the transmission queue.

566
00:42:53,630 --> 00:43:01,400
And one way to think about it is that all the descriptors between here, between the tail,

567
00:43:02,540 --> 00:43:05,240
and so all the things that are actually being filled in,

568
00:43:05,720 --> 00:43:08,930
like details moved up maybe to here.

569
00:43:12,540 --> 00:43:16,200
You know all the packets that are all the descriptor entries that are actually filled in,

570
00:43:16,260 --> 00:43:21,190
the way you think about them is, they are owned by the hardware owned by the network card.

571
00:43:21,810 --> 00:43:25,230
The network card is allowed to read them, do things with them,

572
00:43:25,350 --> 00:43:29,580
but the software and the software is not allowed to do anything with that,

573
00:43:29,760 --> 00:43:33,780
like if the software would be scribbling over these descriptors,

574
00:43:34,080 --> 00:43:38,880
while they really sort of owned by the hardware disk by network card,

575
00:43:39,000 --> 00:43:42,240
that would change the data that the network card sees

576
00:43:42,240 --> 00:43:43,800
and that would be pretty undesirable.

577
00:43:44,460 --> 00:43:47,970
And so, the protocol basically is that

578
00:43:47,970 --> 00:43:50,880
like once you know the software moves the tail pointer one up,

579
00:43:51,060 --> 00:43:56,100
then you know that point you have just moved into the network queue in the transmission queue

580
00:43:56,130 --> 00:43:57,450
is now owned by the hardware

581
00:43:57,780 --> 00:44:03,090
and it will stick in you know it will be owned by the hardware until it has to be sent

582
00:44:03,210 --> 00:44:07,140
and basically until the head pointer moves past you know that particular structure.

583
00:44:09,890 --> 00:44:10,760
Does that make sense?

584
00:44:18,950 --> 00:44:21,380
Good, for transmission, basically it's the same story,

585
00:44:21,410 --> 00:44:30,740
you know there's a there's a head pointer that basically that's controlled by the hardware

586
00:44:30,770 --> 00:44:35,800
and there's a tail pointer that is controlled by, there is the software pointer,

587
00:44:37,340 --> 00:44:47,920
and basically the packets in between are are packets are actually have been received by the hardware

588
00:44:47,920 --> 00:44:53,110
and and you know by expecting the tail pointer

589
00:44:53,110 --> 00:44:57,850
and the software can see if there's actually a new packet, you know that is ready to be consumed

590
00:44:57,850 --> 00:45:02,950
and if it's ready to be consumed, the hardware will indicate that by saying that DD bit in the status field.

591
00:45:03,440 --> 00:45:06,740
And so when the DD bit is set, hardware software are good,

592
00:45:06,770 --> 00:45:09,200
you know these packets, you know the hardware is done with it,

593
00:45:09,530 --> 00:45:13,220
and so it can take it out and move the tail pointer one up.

594
00:45:14,920 --> 00:45:21,700
And so there's sort of this give and take between driver and our hardware

595
00:45:21,730 --> 00:45:24,880
to actually coordinate they don't trip over each other.

596
00:45:27,340 --> 00:45:31,840
Any questions about the rings?

597
00:45:36,200 --> 00:45:41,810
Is this like, is this a universal way to kind of implement

598
00:45:41,810 --> 00:45:45,680
like user or any kind of communication between two things that have shared memory.

599
00:45:46,270 --> 00:45:49,090
Yeah it's a pretty certainly also in software, you see this,

600
00:45:49,090 --> 00:45:51,880
but many hardware devices played sort of trick,

601
00:45:52,510 --> 00:46:00,250
we're going to producer consumer style coordination between the hardware and software.

602
00:46:05,350 --> 00:46:06,820
So yeah, they're very common structure.

603
00:46:08,430 --> 00:46:11,250
Maybe one or two questions, you can ask about it,

604
00:46:11,460 --> 00:46:14,280
like why is there actually even a queue, why is there a ring.

605
00:46:14,910 --> 00:46:16,410
Okay, the reason there's a ring correct,

606
00:46:16,410 --> 00:46:20,250
because the queue wraps around, queue wraps around to make it fix size,

607
00:46:21,590 --> 00:46:25,730
but you know, why, why not, you know have queue one entry, one entry,

608
00:46:27,900 --> 00:46:29,190
like it's almost like the UART,

609
00:46:29,550 --> 00:46:35,670
you remember the UART driver and controller is basically only one register to send a byte

610
00:46:35,670 --> 00:46:37,230
and there's another register receive a byte.

611
00:46:38,880 --> 00:46:42,450
And so why have, why go for this complicated scheme,

612
00:46:42,450 --> 00:46:44,250
you could have yourself a single register

613
00:46:44,250 --> 00:46:48,690
and then you can basically say you know hardware, this register is now ready, send it,

614
00:46:49,390 --> 00:46:52,500
and then you just wait until the it's done.

615
00:46:55,300 --> 00:46:59,950
To allow for when there are bursts of packets.

616
00:47:00,480 --> 00:47:02,530
Yeah, yeah exactly,

617
00:47:02,860 --> 00:47:07,750
you know the network interface where the network card or cable is pretty high performance,

618
00:47:07,750 --> 00:47:10,630
in fact very high performance, gigabits per second.

619
00:47:11,310 --> 00:47:16,260
And so, it can be hard for the core, the processors actually keep up with it,

620
00:47:16,290 --> 00:47:18,660
so you would like to give it a whole bunch of packets,

621
00:47:18,660 --> 00:47:21,030
you know the networks or network card chunk along

622
00:47:21,030 --> 00:47:22,740
and I'll send them out at high speed.

623
00:47:23,280 --> 00:47:26,880
And similarly you know in reception you might get a burst of packets coming in

624
00:47:27,270 --> 00:47:29,370
and you want to place them in the queue

625
00:47:29,370 --> 00:47:33,710
and then the operating system can start processing the queue, right.

626
00:47:35,090 --> 00:47:36,830
And so this is a common,

627
00:47:39,270 --> 00:47:45,010
this is the reason that these queues are common to handle bursts.

628
00:47:48,910 --> 00:47:51,700
What happens if the queue is full, like reception.

629
00:47:58,950 --> 00:48:05,790
I think the the document mentioned that it does some form of drop tail scheme.

630
00:48:06,810 --> 00:48:10,290
Yeah, there yeah basically the packets get dropped.

631
00:48:11,170 --> 00:48:14,110
So any future incoming packets, if the queue is full,

632
00:48:14,110 --> 00:48:17,230
the packets or there's no room anymore in the ring,

633
00:48:17,230 --> 00:48:19,390
the network card can't do anything with that correct,

634
00:48:19,390 --> 00:48:23,830
and so the only option it actually has to basically delete the packet

635
00:48:23,860 --> 00:48:26,930
or not added to the ring and therefore disappears.

636
00:48:27,890 --> 00:48:30,560
So, one reason to have packet loss, sometimes is that,

637
00:48:31,170 --> 00:48:33,660
and operating system is overloaded,

638
00:48:33,690 --> 00:48:36,330
you know with packet can't keep up and the ring fills

639
00:48:36,540 --> 00:48:38,670
and then you know the packets get dropped.

640
00:48:41,110 --> 00:48:46,840
You know higher level software, of course maybe like TCP connection might re-transmit those packets,

641
00:48:47,110 --> 00:48:49,660
but this is one reason why packets can get dropped.

642
00:48:52,730 --> 00:48:56,030
So even if the hardware sort of works all perfectly fine,

643
00:48:56,150 --> 00:48:59,870
you know because of these bursts you know it can happen that [] section might get dropped.

644
00:49:01,240 --> 00:49:02,920
So you had a really really big burst.

645
00:49:07,010 --> 00:49:12,560
The head and tail pointers, they're all software abstractions, right, of the queue.

646
00:49:13,160 --> 00:49:18,320
Okay, so these are actually turns out that those are these control registers right,

647
00:49:18,320 --> 00:49:22,370
so there's a control register for the hardware the header pointer is,

648
00:49:22,370 --> 00:49:25,970
a control register for the basically the tail pointers,

649
00:49:26,060 --> 00:49:28,010
there's no real distinction between hardware software,

650
00:49:28,010 --> 00:49:30,110
basically the driver knows about the tail pointer,

651
00:49:30,110 --> 00:49:35,490
and it knows about the hardware knows about the tail pointer and header pointer

652
00:49:35,520 --> 00:49:37,050
and use a basic control registers.

653
00:49:37,720 --> 00:49:38,410
Okay yeah.

654
00:49:39,070 --> 00:49:41,260
It will soon the code in seconds, how did the shows up,

655
00:49:42,810 --> 00:49:44,280
make sure you go back to our,

656
00:49:44,610 --> 00:49:48,420
maybe let's see this picture still here,

657
00:49:48,840 --> 00:49:51,210
here's that earlier picture we looked at

658
00:49:51,540 --> 00:49:54,660
and you know here's control register that holds the head,

659
00:49:54,780 --> 00:49:57,060
here control register that holds the tail

660
00:49:57,060 --> 00:50:00,480
and of course there's one for both reception and one for sending.

661
00:50:04,300 --> 00:50:04,930
Okay?

662
00:50:08,810 --> 00:50:10,280
Let's go back here.

663
00:50:11,290 --> 00:50:14,140
Okay, so let's talk a little bit about the descriptors.

664
00:50:15,250 --> 00:50:18,310
And so the descriptors are defined by the hardware

665
00:50:18,730 --> 00:50:22,240
and so the hardware says like here's how the scriptures should look like,

666
00:50:22,240 --> 00:50:25,660
and you driver you know these are the bits, you can fill in

667
00:50:25,660 --> 00:50:28,930
and if you fill in that bit that tells me to follow, right.

668
00:50:29,270 --> 00:50:34,350
And so here's the two descriptors are important,

669
00:50:34,380 --> 00:50:40,160
you know, here's the receive descriptor rx

670
00:50:40,160 --> 00:50:42,680
and here's a tx, one of the tx descriptors.

671
00:50:43,380 --> 00:50:45,960
And so let's look a little bit.

672
00:50:46,600 --> 00:50:48,370
Yeah it's a little bit,

673
00:50:48,820 --> 00:50:52,990
probably the most important part is this address,

674
00:50:53,530 --> 00:50:56,560
and that is the address that the software filled in

675
00:50:56,560 --> 00:51:00,370
to say where they should where the hardware to dump the packet,

676
00:51:00,490 --> 00:51:09,100
where in RAM to the driver, where should the network card put the data that is received into RAM,

677
00:51:09,220 --> 00:51:12,460
so it's the address of the reception buffer, if you will.

678
00:51:17,080 --> 00:51:20,500
And then you know probably the most important part in

679
00:51:20,560 --> 00:51:23,470
is the status field as you've seen.

680
00:51:24,020 --> 00:51:28,370
So when the driver basically still continues to look sort of at the tail

681
00:51:28,430 --> 00:51:31,460
and sees that there's a new packet has been received

682
00:51:31,670 --> 00:51:34,490
and the way it tells whether a new packet received is

683
00:51:34,670 --> 00:51:36,650
is that the DD bit correct,

684
00:51:36,680 --> 00:51:39,450
is set by the hardware.

685
00:51:40,540 --> 00:51:47,290
And you know the shaded areas are the fields of the packet descriptor of the,

686
00:51:47,920 --> 00:51:50,890
receive descriptor actually the hardware fills in

687
00:51:51,010 --> 00:51:56,860
and the white you know the non shaded ones are the fields that actually shaded in are filled in by the software,

688
00:51:57,100 --> 00:52:01,240
again here we see this clear distinction about somethings are owned by software,

689
00:52:01,270 --> 00:52:05,690
somethings are owned by by the hardware.

690
00:52:08,760 --> 00:52:14,760
Okay, and there's a similar you know descriptor, very simple descriptor that looks,

691
00:52:15,150 --> 00:52:18,060
that's a hardware descriptor for the transmission,

692
00:52:18,300 --> 00:52:25,590
it has an address, the address of course is the address where the data is in memory, that needs to be sent.

693
00:52:26,000 --> 00:52:28,460
And then it has a budget has a command field.

694
00:52:29,160 --> 00:52:32,610
And here's how the software tells the driver tells the network card,

695
00:52:32,670 --> 00:52:34,740
this is what you should do with this particular packet

696
00:52:34,740 --> 00:52:37,470
or you know this is what you should know about this particular packet.

697
00:52:38,290 --> 00:52:42,910
And so one thing, yeah we I think we feeling two path, two things we filled

698
00:52:42,940 --> 00:52:46,330
a EOP says you know the end of packet

699
00:52:46,630 --> 00:52:51,550
and that basically tells the driver, this is the last descriptor of a particular packet

700
00:52:51,550 --> 00:52:56,080
and now can you know send off you know whatever data that's in these descriptors.

701
00:52:56,900 --> 00:53:06,220
And I think we set the response you know requested command bit

702
00:53:06,490 --> 00:53:09,850
or RS I think it is,

703
00:53:09,880 --> 00:53:12,670
basically tells network card when you're done,

704
00:53:12,910 --> 00:53:20,600
transmitting this thing you know set the, set the bit that it actually has been transmitted.

705
00:53:21,430 --> 00:53:23,650
We'll see you second how how to change up.

706
00:53:25,570 --> 00:53:26,350
Any questions?

707
00:53:32,230 --> 00:53:35,350
So one one thing to keep in mind, you know with these structures,

708
00:53:35,380 --> 00:53:39,970
these are defined by the hardware, like hardware, software has no control over their structure,

709
00:53:39,970 --> 00:53:43,780
you know there's just literally defined by the hardware, by the network card.

710
00:53:44,860 --> 00:53:47,050
Okay, let's look at a little bit of code

711
00:53:47,470 --> 00:53:50,590
and see what the solution looks like

712
00:53:50,590 --> 00:53:54,580
and we'll look at a couple of issues that we haven't looked at yet, you know the mbufs.

713
00:53:55,060 --> 00:53:59,020
issues if during transmission and issues during receiving.

714
00:54:00,600 --> 00:54:03,090
And this would be presumably all well familiar with to you,

715
00:54:03,090 --> 00:54:05,250
given the fact that you just finished the lab.

716
00:54:08,880 --> 00:54:14,010
Okay, so here, just to go to the top, here's the transmit ring.

717
00:54:15,040 --> 00:54:18,580
Yeah, and that's basically the ring of descriptors,

718
00:54:18,580 --> 00:54:22,000
you know we drew off in the last couple of slides.

719
00:54:22,670 --> 00:54:24,830
There's a separate, we talked briefly about this,

720
00:54:24,830 --> 00:54:28,280
there's a separate basically ring of mbufs,

721
00:54:28,520 --> 00:54:37,160
but in that ring is completely you know a software or driver only abstraction hardware,

722
00:54:37,310 --> 00:54:42,090
this is defined by this structure is defined by the hardware, right,

723
00:54:42,090 --> 00:54:42,870
and if you look at.

724
00:54:43,480 --> 00:54:43,960
Oops.

725
00:55:02,990 --> 00:55:04,760
You know look at the definitions,

726
00:55:04,760 --> 00:55:06,740
but here's struct tx_desc,

727
00:55:06,860 --> 00:55:11,750
that corresponds to the C version of exactly the structure that actually was defined by the hardware,

728
00:55:11,780 --> 00:55:14,090
you know 64 bit address,

729
00:55:14,090 --> 00:55:21,740
you know the length field, the cso, byte the cmd byte, the status byte, the css byte, and then to word for special.

730
00:55:22,590 --> 00:55:25,320
And there's a similar ring that is literally defined by the hardware,

731
00:55:25,840 --> 00:55:28,390
or similar descriptors received descriptor as defined by hardware

732
00:55:28,390 --> 00:55:32,560
and those regions have see decorations corresponding to these hardware structures.

733
00:55:34,970 --> 00:55:36,230
Alright, let's look at transmit.

734
00:55:37,780 --> 00:55:41,650
So here's the sort of staff solution for transmit,

735
00:55:42,390 --> 00:55:44,370
you know acquires a lock

736
00:55:44,400 --> 00:55:46,680
and the reason we said before that needed lock is

737
00:55:46,680 --> 00:55:51,900
because multiple functions or multiple threads, kernel threats might call transmit at the same time.

738
00:55:53,460 --> 00:55:55,110
And then it looks at the tail,

739
00:55:55,320 --> 00:56:01,120
you know to see if there's any, in the room to actually sent a new packet,

740
00:56:01,120 --> 00:56:03,880
because you know the network card got behind

741
00:56:03,880 --> 00:56:07,390
and all the descriptors actually are be in used.

742
00:56:08,170 --> 00:56:13,390
And so the way it checks, where you're actually the descriptor region here's,

743
00:56:13,390 --> 00:56:19,040
by checking whether the DD bit is not set.

744
00:56:20,120 --> 00:56:22,850
And if it is then,

745
00:56:25,410 --> 00:56:31,170
if it's not set then it returns immediately, not sending the packet at all,

746
00:56:31,350 --> 00:56:33,660
and in any other case, gonna it keeps on,

747
00:56:33,660 --> 00:56:35,550
going and actually will send the mbuf.

748
00:56:39,760 --> 00:56:43,600
So if there's still an mbuf in this position in the tx_mbufs,

749
00:56:43,600 --> 00:56:47,260
and in, this is an mbuf for a while back you know free that mbuf,

750
00:56:47,260 --> 00:56:50,800
because we're going to actually stick in an mbuf into this descriptor,

751
00:56:51,100 --> 00:56:54,490
we just need to remember which you know mbuf we stop in that descriptor

752
00:56:54,610 --> 00:56:58,420
and so the way we do that is by keeping that in the tx_mbufs.

753
00:56:59,820 --> 00:57:01,230
And then we fill in the descriptor,

754
00:57:01,500 --> 00:57:04,530
and so the first thing we'll filling is the head

755
00:57:04,530 --> 00:57:11,970
and we fill in, we put in the address the start of the first header in the mbuf,

756
00:57:13,470 --> 00:57:14,640
then, put the length,

757
00:57:15,220 --> 00:57:17,020
step state is zero,

758
00:57:17,110 --> 00:57:23,200
put the command field in place by sending both RS and the EOP bit as we discuss the second.

759
00:57:23,760 --> 00:57:30,860
And, and then basically you'll be synchronized to make actually sure there's no reordering of,

760
00:57:30,890 --> 00:57:35,300
you know that all these instructions are performed before the next instruction.

761
00:57:36,140 --> 00:57:38,930
And what the next instruction does it actually updates the tail pointer

762
00:57:39,080 --> 00:57:41,330
and so the [adoptive] updates the tail pointer

763
00:57:41,330 --> 00:57:45,470
and the tail point correct is a control register in the network card,

764
00:57:45,890 --> 00:57:48,200
and so basically when we update the tail pointer,

765
00:57:48,290 --> 00:57:51,170
the network card knows aha something changed

766
00:57:51,470 --> 00:57:56,180
and it's going to read you know the data at that descriptor

767
00:57:56,420 --> 00:58:00,200
and it's going to basically read these fields, we've just filled in,

768
00:58:00,350 --> 00:58:06,750
so we're gonna basically make absolutely sure that, all these writes, all the stores are materialized in memory,

769
00:58:06,780 --> 00:58:09,630
before the network card actually reads them

770
00:58:09,630 --> 00:58:11,520
and so this is why the __sync_synchronize there.

771
00:58:13,760 --> 00:58:14,900
And then we release about a lock

772
00:58:14,900 --> 00:58:17,240
and that's basically all we have to do to transmit a packet.

773
00:58:20,790 --> 00:58:24,800
Can you explain the __sync_synchronize again, like what.

774
00:58:25,270 --> 00:58:30,160
Yeah, it's mostly memory ordering technicality correct,

775
00:58:30,160 --> 00:58:32,140
compilers are free to reorder instructions,

776
00:58:32,660 --> 00:58:38,720
the writes might actually sit in the L1 cache or the L2 cache

777
00:58:39,080 --> 00:58:42,380
and sync basically the synchronize sort of memory fence

778
00:58:42,680 --> 00:58:48,680
that tells the hardware and compiler, please don't move any instructions across this barrier,

779
00:58:49,630 --> 00:58:57,100
and make sure that all the data that you know all the stores before this barrier are actually actually materialized in RAM.

780
00:58:58,700 --> 00:58:59,990
And the reason that is important is,

781
00:58:59,990 --> 00:59:04,340
because the, go back to our picture for a little while ago,

782
00:59:05,380 --> 00:59:10,060
all the way back here.

783
00:59:10,710 --> 00:59:17,160
Make sure both you know the RISC-V cores that run the driver code basically put values here in round right,

784
00:59:17,160 --> 00:59:18,840
but you know those values are reversing,

785
00:59:18,840 --> 00:59:24,000
the L1 cache and L2 cache and the memory flush and ensures that they actually show up in the RAM,

786
00:59:24,120 --> 00:59:26,940
this is important because as soon as we update the tail pointer,

787
00:59:26,940 --> 00:59:29,670
the e1000 is going to look into RAM for these descriptors.

788
00:59:30,970 --> 00:59:34,000
And we've got to make sure that all the fields are indeed set,

789
00:59:34,800 --> 00:59:37,080
otherwise, it would read stale values.

790
00:59:40,360 --> 00:59:41,140
Does that make sense?

791
00:59:43,410 --> 00:59:43,980
Yep thank you.

792
00:59:46,320 --> 00:59:48,300
Why do mbuf exist,

793
01:00:00,660 --> 01:00:07,850
why have these sort of separate structure of, why have these two sort of corresponding structures.

794
01:00:09,590 --> 01:00:18,510
So I guess part of it is it's all nice and well if the driver needs to talk to the hardware about where things are,

795
01:00:18,510 --> 01:00:22,800
but at the end of the day, we do need to store the packet to hand off to the network stack somehow.

796
01:00:24,020 --> 01:00:24,860
Yeah exactly,

797
01:00:24,920 --> 01:00:30,110
you know, so you know so one way to think about it is that the you know the mbufs completely less abstraction,

798
01:00:30,110 --> 01:00:32,750
nothing to do with really the network card at all

799
01:00:33,140 --> 01:00:39,590
and it's there because like you know if at some point, you know maybe receive a packet,

800
01:00:39,590 --> 01:00:41,450
you know we headed off to the network stack,

801
01:00:41,450 --> 01:00:43,610
in the network stack now sticks at some queue,

802
01:00:43,700 --> 01:00:45,890
so that when later a user process calls read,

803
01:00:45,920 --> 01:00:47,150
you actually can read it.

804
01:00:48,000 --> 01:00:53,040
In, the meantime we need to have some structure, that holds that data that we actually received

805
01:00:53,040 --> 01:00:54,990
and that's exactly what those mbuf structures are.

806
01:01:01,310 --> 01:01:03,800
Sorry, can you talk about the,

807
01:01:04,700 --> 01:01:09,990
like how, how do you use the link list structure in your code,

808
01:01:09,990 --> 01:01:13,690
because I was trying to to understand it and track it down

809
01:01:14,290 --> 01:01:19,490
and it seems like there's some push tail or push head,

810
01:01:19,550 --> 01:01:23,680
but I don't ever call it in my code,

811
01:01:24,220 --> 01:01:28,000
oh, it might be it might be the net.c file.

812
01:01:30,200 --> 01:01:33,110
Well the networks c files file, we gave you to [].

813
01:01:33,770 --> 01:01:34,610
Yeah.

814
01:01:39,650 --> 01:01:40,940
And where you're thinking.

815
01:01:42,800 --> 01:01:49,940
If you look for something like pull pop, I think pop.

816
01:01:54,210 --> 01:02:03,540
Yeah, so this is this is the only place where it looks like it does things with the linked list structure of mbuf

817
01:02:04,290 --> 01:02:08,700
and if you don't ever call this function or the push tail,

818
01:02:09,000 --> 01:02:17,610
you basically just treat the mbuf as an array of like how many characters,

819
01:02:17,670 --> 01:02:20,570
so, so why is mbuf there.

820
01:02:21,370 --> 01:02:27,710
Because here, when you receive a UDP packet,

821
01:02:28,130 --> 01:02:30,440
so the UDP packet comes in from the network card,

822
01:02:30,470 --> 01:02:31,850
it goes to the network stack,

823
01:02:32,450 --> 01:02:38,060
then the UDP packet, the mbuf for the UDP that holds that UDP packet

824
01:02:38,450 --> 01:02:40,250
is actually stuck in a queue right here,

825
01:02:42,090 --> 01:02:44,220
on the socket for the receiver.

826
01:02:47,460 --> 01:02:50,370
And so this is the reason that you can have queues within mbufs.

827
01:02:54,420 --> 01:02:56,100
And the reason is stack in the queue there correct,

828
01:02:56,100 --> 01:03:00,690
is because you know who knows, you know the user process that's going to read you know from this particular socket,

829
01:03:01,140 --> 01:03:02,670
you know might be doing something else

830
01:03:02,700 --> 01:03:05,310
and at some point later it's going to call the read system call,

831
01:03:05,310 --> 01:03:09,630
then the read system call is going to remove you know that mbuf from that socket.

832
01:03:11,780 --> 01:03:20,250
And so, the point with each socket can have a list of mbufs for reception.

833
01:03:22,070 --> 01:03:23,390
I see, thank you.

834
01:03:25,840 --> 01:03:27,580
Okay, let's go back to the driver.

835
01:03:28,190 --> 01:03:30,230
So that was transmit.

836
01:03:32,480 --> 01:03:37,340
So then we receive, you know almost similar, not that much difference,

837
01:03:37,760 --> 01:03:42,620
basically you know read the tail pointer from the network card.

838
01:03:43,220 --> 01:03:45,470
You see there actually a packet,

839
01:03:45,560 --> 01:03:51,110
and if there's a packet, then the DD field would be set,

840
01:03:51,770 --> 01:03:53,630
if the DD field is not set,

841
01:03:53,660 --> 01:03:56,360
then we know there's no packet and so we're done,

842
01:03:57,200 --> 01:03:59,750
if it is set, we're going to read it,

843
01:04:02,220 --> 01:04:04,410
and read the length, you know.

844
01:04:04,960 --> 01:04:08,710
And when we when we call and net_rx,

845
01:04:08,710 --> 01:04:11,230
you know do up call into the higher level stack.

846
01:04:11,930 --> 01:04:18,780
And when we're done, you know we're basically free up you know that entry.

847
01:04:18,870 --> 01:04:22,470
So that the driver can use it to actually receive more packets in it.

848
01:04:23,340 --> 01:04:25,980
And the real [crucial] operation area is correct,

849
01:04:25,980 --> 01:04:28,710
we bump up basically the tail to tell the driver,

850
01:04:29,100 --> 01:04:31,560
hey you know we're done with it, you can use it again,

851
01:04:31,590 --> 01:04:33,060
you know here's again that slot.

852
01:04:35,900 --> 01:04:40,430
So maybe the most interesting question is and number of questions have you asked

853
01:04:40,460 --> 01:04:46,730
why is the while there, why is this in a loop.

854
01:04:47,690 --> 01:04:50,690
Don't you get an interrupt then you know you grab one packet then you've done,

855
01:04:50,930 --> 01:04:53,770
a number of people that actually forgot while loop,

856
01:04:53,770 --> 01:04:58,750
but first you know notice that basically at some point you don't receive packets anymore, during that test.

857
01:05:02,840 --> 01:05:08,900
Is it because you would like to transmit as many packets that are ready as possible with only one interrupt,

858
01:05:08,900 --> 01:05:13,010
so that you can kind of amortize the cost of the interrupt.

859
01:05:13,780 --> 01:05:15,850
Yeah, this, this is absolutely part of it,

860
01:05:15,850 --> 01:05:20,890
you know you get to the let's first talk about you know the root cause you guys write,

861
01:05:21,730 --> 01:05:24,700
a number of burst package comes in,

862
01:05:25,330 --> 01:05:28,570
and the network card will generate the interrupt,

863
01:05:28,930 --> 01:05:30,220
but more packets are coming in

864
01:05:30,310 --> 01:05:34,390
and so it will just put them in the three descriptors right that actually can use,

865
01:05:35,060 --> 01:05:38,750
can't generate more interrupts, because already generated interrupt

866
01:05:39,140 --> 01:05:42,620
and at some point you know the whatever the process

867
01:05:42,620 --> 01:05:47,300
or you know, maybe we were the core was just in a section of code that turned off interrupts,

868
01:05:47,300 --> 01:05:48,650
because it was doing something atomic,

869
01:05:49,010 --> 01:05:52,400
at the end of it, you know there's a release from lock that actually turns interruption off,

870
01:05:52,550 --> 01:05:54,260
that point of time, then basically do it.

871
01:05:54,680 --> 01:05:57,800
Receive handlers, the interrupt handler going to run,

872
01:05:58,160 --> 01:06:02,510
but between a period when the first packet comes in and before you receive handler runs

873
01:06:02,510 --> 01:06:06,290
there's a whole bunch of other packets might have could have could have come in.

874
01:06:07,430 --> 01:06:13,100
And so we don't run in the while loop, will leave those packets,

875
01:06:13,100 --> 01:06:15,650
will grab the first one and will grab the other

876
01:06:15,650 --> 01:06:18,380
and the later ones you stick there in the queue right,

877
01:06:18,380 --> 01:06:19,670
they're just sitting there in that ring.

878
01:06:20,680 --> 01:06:22,780
Now, if subsequent interrupt would come in,

879
01:06:22,780 --> 01:06:23,920
we'll grab the next one,

880
01:06:24,340 --> 01:06:29,110
but like the tests, you know what they do they run their UDP packets,

881
01:06:29,110 --> 01:06:34,600
you know, so they send off a whole bunch like one of the test since like ten ping request in parallel,

882
01:06:34,810 --> 01:06:38,200
you know the ten responses coming parallel back, you know correct.

883
01:06:38,640 --> 01:06:41,940
The first one receives generates an interrupt,

884
01:06:42,030 --> 01:06:43,980
the other nine go into the queue,

885
01:06:44,480 --> 01:06:48,230
the higher level software, you know reached the first one,

886
01:06:48,830 --> 01:06:51,380
and then returns like it's done

887
01:06:51,650 --> 01:06:53,450
and at that point, nothing happens anymore,

888
01:06:53,450 --> 01:06:56,210
because the receiver is waiting for more receive packets,

889
01:06:56,360 --> 01:06:58,250
they happen to be there, they're sitting in the ring,

890
01:06:58,430 --> 01:07:02,120
except you know, you received didn't do them in a while loop

891
01:07:02,120 --> 01:07:03,140
and so didn't pick them up.

892
01:07:05,850 --> 01:07:06,570
Does that make sense?

893
01:07:13,160 --> 01:07:15,710
So, for example if the test programs would have sent,

894
01:07:15,710 --> 01:07:20,420
one request waited for a response, one request waited for a response,

895
01:07:20,600 --> 01:07:24,050
then you would never notice that, you needed to a while loop.

896
01:07:24,550 --> 01:07:27,910
And it's because like there's a burst of responses might come back,

897
01:07:28,030 --> 01:07:30,970
and that only generate together one interrupt.

898
01:07:35,020 --> 01:07:36,820
Any questions about that, about this?

899
01:07:36,820 --> 01:07:37,990
I have a question,

900
01:07:37,990 --> 01:07:42,160
so for example if instead of a while one,

901
01:07:42,700 --> 01:07:45,580
we would have a for loop that just goes through the whole queue,

902
01:07:45,580 --> 01:07:49,060
that would also be wrong for the same reason.

903
01:07:49,420 --> 01:07:53,260
No, we skip all the ones that have the DD not set.

904
01:07:54,670 --> 01:07:57,370
Okay, we should only we should only look at packets

905
01:07:57,370 --> 01:08:00,220
and actually we should only look at the tail point.

906
01:08:02,170 --> 01:08:05,380
But you know in principle, you could just skip the whole queue

907
01:08:05,380 --> 01:08:07,120
and I guess look at the DD packets,

908
01:08:07,120 --> 01:08:09,490
you know let them see the DD bit is set

909
01:08:09,520 --> 01:08:11,920
and that might work I don't know I haven't tried that.

910
01:08:14,060 --> 01:08:23,270
Okay, but isn't the device able to put more mbufs in the receive after we read stale.

911
01:08:25,000 --> 01:08:25,930
Yeah yeah.

912
01:08:29,070 --> 01:08:29,610
Okay.

913
01:08:32,080 --> 01:08:32,890
And we have to.

914
01:08:42,200 --> 01:08:45,110
It's very dangerous, like this proposal of like sort of looping around,

915
01:08:45,110 --> 01:08:47,150
and you know seeing DD set,

916
01:08:47,150 --> 01:08:49,490
because you know really we should do,

917
01:08:49,490 --> 01:08:54,260
we should not look at buf that really are controlled by the driver or by the hardware

918
01:08:54,500 --> 01:08:58,180
and only look at buffers are actually available to watch this buffer

919
01:08:58,240 --> 01:09:00,760
and which is indicated by the DD bit

920
01:09:00,760 --> 01:09:02,470
and basically by looking at the tail pointer.

921
01:09:04,080 --> 01:09:08,430
Basically, anything owned between the tail and the head is owned by the hardware.

922
01:09:13,220 --> 01:09:17,060
Going back to the mbuf, like the reason we need the mbuf,

923
01:09:17,450 --> 01:09:23,990
why do we need the other information in the buffer like the [] array.

924
01:09:24,580 --> 01:09:26,230
I think it's called the backing store.

925
01:09:28,760 --> 01:09:30,830
It gets in net.h.

926
01:09:40,490 --> 01:09:42,830
So we need we need the buf field, correct,

927
01:09:42,830 --> 01:09:44,300
because it actually contains the data.

928
01:09:46,800 --> 01:09:49,410
I thought the head contains a pointer to the data.

929
01:09:49,590 --> 01:09:50,400
Yeah yeah okay,

930
01:09:50,400 --> 01:09:53,190
but the buf actually is the actual allocates space,

931
01:09:53,190 --> 01:09:54,510
you know the whole packets right,

932
01:09:54,750 --> 01:09:57,240
and then head get points into buf,

933
01:09:57,420 --> 01:09:59,100
basically the start of the packet.

934
01:10:01,450 --> 01:10:02,230
Okay, okay.

935
01:10:04,160 --> 01:10:05,630
And this is mbuf, this is,

936
01:10:05,630 --> 01:10:11,270
okay so a little bit more context to mbuf is a structure that you see in a lot of network stacks,

937
01:10:11,270 --> 01:10:14,420
so you look in the Linux kernel, you'll see structure similar like this

938
01:10:14,420 --> 01:10:17,420
and it's typically called mbufs, and so we have to.

939
01:10:19,060 --> 01:10:22,030
We could have simplified this structure quite a bit, if we wanted to

940
01:10:22,270 --> 01:10:24,490
and maybe subsequent here is we should,

941
01:10:24,550 --> 01:10:30,430
but this is sort of the standard way in which packets are represented in operating system kernels.

942
01:10:39,430 --> 01:10:41,110
Okay, any further questions about this?

943
01:10:50,760 --> 01:10:51,900
So I have a choice now,

944
01:10:51,930 --> 01:10:55,590
a couple of things I could say about the network driver,

945
01:10:55,860 --> 01:10:59,340
but then I won't have any time to talk about mmap.

946
01:10:59,880 --> 01:11:03,780
I could also talk a little bit about mmap and then and stop here,

947
01:11:04,500 --> 01:11:06,600
in terms of talking to the network driver.

948
01:11:09,640 --> 01:11:11,200
Any preferences?

949
01:11:24,740 --> 01:11:25,700
No preferences.

950
01:11:31,350 --> 01:11:33,270
Let me talk a little bit about mmap,

951
01:11:33,270 --> 01:11:35,940
because there was a question that came up a couple times

952
01:11:36,330 --> 01:11:39,390
and that might be worth addressing,

953
01:11:39,480 --> 01:11:45,090
it's almost more a question about you know why mmap exists,

954
01:11:45,420 --> 01:11:48,540
then, you know actually how to implement it.

955
01:11:49,680 --> 01:11:53,010
So there's no real objections which sounds different,

956
01:11:53,040 --> 01:11:55,770
let me talk a little bit more about mmap.

957
01:11:56,750 --> 01:12:00,980
So this is your last chance to ask any questions about the network driver until the end of class.

958
01:12:06,660 --> 01:12:12,990
Okay, let's talk about the mbufs, oh, mmap.

959
01:12:28,610 --> 01:12:33,840
Okay, so the, the question really relates to show the file system API,

960
01:12:33,990 --> 01:12:38,220
and so the file system has a reasonable broad API,

961
01:12:38,820 --> 01:12:42,660
supporting directories, symbolic links, hard links, etc etc,

962
01:12:42,660 --> 01:12:46,980
but presumably the main the main part of it is the the file API, correct,

963
01:12:46,980 --> 01:12:50,520
the file API, you're well familiar to you now,

964
01:12:52,110 --> 01:12:56,860
open the file, you know with some permissions,

965
01:12:56,890 --> 01:12:58,720
and once you have opened the file,

966
01:12:58,960 --> 01:13:07,870
you know you can read from the file, into a buffer, with some data.

967
01:13:08,830 --> 01:13:12,550
And you can write you know through the file,

968
01:13:15,040 --> 01:13:17,920
whatever file descriptor and buf, you know len,

969
01:13:18,310 --> 01:13:23,590
so let's say we, and then we can close the file descriptor.

970
01:13:25,070 --> 01:13:26,900
Now let's say we want to write an application

971
01:13:27,140 --> 01:13:34,940
and you can think about the, you know may be just a file as, you know files normally a array of bytes,

972
01:13:34,940 --> 01:13:39,710
but like maybe this application has sort of it's an array of struct that are stored in it.

973
01:13:39,890 --> 01:13:43,320
So, and let's say the application wants to update the struct,

974
01:13:43,320 --> 01:13:44,880
so you know we have to file,

975
01:13:46,170 --> 01:13:50,200
here's a file and so divided in you know structs,

976
01:13:50,200 --> 01:13:52,780
you know whatever zero to use the file length

977
01:13:52,780 --> 01:13:56,470
and you know we maybe like in the middle,

978
01:13:56,830 --> 01:13:58,720
let's have structure sixty bytes

979
01:13:58,720 --> 01:14:01,540
or something and you know we want to update one of these

980
01:14:01,840 --> 01:14:03,490
or maybe want to update the first one.

981
01:14:05,680 --> 01:14:07,240
And so in a way we could do that correctly,

982
01:14:07,240 --> 01:14:12,670
we read and we open the file, we read, you know the first you know whatever sixteen bytes,

983
01:14:13,800 --> 01:14:15,720
respond to this you know we,

984
01:14:16,420 --> 01:14:20,680
let's say updates you know the first field struct,

985
01:14:20,710 --> 01:14:23,170
the first byte of that struct, you know to be one.

986
01:14:23,880 --> 01:14:28,080
And then we call write, to basically write it back

987
01:14:28,110 --> 01:14:29,130
and then we close the file.

988
01:14:29,800 --> 01:14:32,530
So if when is write happens where, where does it actually write.

989
01:14:41,090 --> 01:14:44,360
So we've set this memory above the one,

990
01:14:44,360 --> 01:14:47,540
you know will this first by change to one,

991
01:14:52,140 --> 01:14:53,160
if we call write.

992
01:15:08,510 --> 01:15:11,540
So, remember the file descriptor has not set associated with it correct.

993
01:15:13,320 --> 01:15:17,040
And reads read pushes that offset you know forward,

994
01:15:17,040 --> 01:15:19,110
in this case, we've read sixteen bytes,

995
01:15:19,110 --> 01:15:22,020
you know the offset goes from up zero to sixteen.

996
01:15:22,960 --> 01:15:24,310
And so where does write write,

997
01:15:27,190 --> 01:15:32,470
as you notice there's no offset argument in the write system call,

998
01:15:32,500 --> 01:15:33,610
so where does it write.

999
01:15:37,070 --> 01:15:37,940
Len?

1000
01:15:39,180 --> 01:15:42,420
Yeah you will write len bytes which offset in the file,

1001
01:15:44,080 --> 01:15:46,360
presumably len exactly at sixteen right.

1002
01:15:46,920 --> 01:15:51,420
That's write here, so which, this byte will change to one correct.

1003
01:15:54,090 --> 01:15:58,470
Not the actual thing that we are actually trying to modify.

1004
01:15:59,970 --> 01:16:00,690
Does that make sense?

1005
01:16:02,540 --> 01:16:04,340
So the way you've written this application,

1006
01:16:04,340 --> 01:16:07,790
it turns out there was once a system call that we didn't really talk much about at all,

1007
01:16:07,910 --> 01:16:12,290
but every operating system, unix operating system is called system called lseek.

1008
01:16:14,220 --> 01:16:18,210
And lseek allows you basically to change the offset to some position.

1009
01:16:18,850 --> 01:16:20,620
And so in this particular case,

1010
01:16:20,620 --> 01:16:25,600
we want to do have the effect that we're going to write this struct not that one.

1011
01:16:26,140 --> 01:16:34,250
Then we would have said like you know, so you know zero basically resetting the offset to actually zero,

1012
01:16:34,280 --> 01:16:37,580
so then this write would actually sort your now offset zero.

1013
01:16:38,380 --> 01:16:42,850
And then this write actually you would write actually at the first sixteen bytes.

1014
01:16:44,170 --> 01:16:44,920
Does that make sense?

1015
01:16:51,700 --> 01:16:53,290
So this is slightly inconvenient correctly,

1016
01:16:53,290 --> 01:16:54,340
if you think about this,

1017
01:16:54,520 --> 01:16:58,000
you look at this interface, there's actually quite a bit of stuff going on,

1018
01:16:58,000 --> 01:16:59,890
you know you gotta open, you gotta read it,

1019
01:16:59,890 --> 01:17:01,570
you know you can seek it and then you can write it.

1020
01:17:02,310 --> 01:17:05,010
And so, one reason that mmap is popular.

1021
01:17:06,600 --> 01:17:10,860
If you can sort of avoid you know these these complications.

1022
01:17:11,460 --> 01:17:13,740
Because if we write this using mmap,

1023
01:17:13,740 --> 01:17:17,850
you know, we do fd is open and we open the file as before.

1024
01:17:20,980 --> 01:17:24,370
And then you know we just call mmap.

1025
01:17:26,240 --> 01:17:27,830
It's going to be whatever our struct,

1026
01:17:27,860 --> 01:17:33,100
let's say our struct h, you know, blah, blah blah,

1027
01:17:33,130 --> 01:17:42,440
you know whatever some link for the file, read, write permissions,

1028
01:17:43,530 --> 01:17:50,920
you know map shared, and file descriptor zero.

1029
01:17:52,160 --> 01:17:56,450
And then, so now basically with this dot correct we're in mmapping,

1030
01:17:56,450 --> 01:18:01,070
you know the file f at the location h, you know in memory.

1031
01:18:01,580 --> 01:18:08,300
Now, we can just say h whatever first byte is zero or one that we did before.

1032
01:18:08,980 --> 01:18:11,710
And then you know at some point you know we can munmap,

1033
01:18:16,440 --> 01:18:21,500
you know the munmap h right,

1034
01:18:21,500 --> 01:18:23,840
and so if we think about this, we look in memory.

1035
01:18:24,400 --> 01:18:26,920
We're looking at this from the perspective of the file,

1036
01:18:27,310 --> 01:18:28,570
you know what this does correct,

1037
01:18:28,570 --> 01:18:32,410
code literally did is basically you've got a pointer to this h

1038
01:18:32,770 --> 01:18:35,560
and you can just update here, you know that thing to one

1039
01:18:35,920 --> 01:18:37,390
and be done with it right.

1040
01:18:38,360 --> 01:18:44,660
And so if we sort of need to manipulate you know file structure, data structure that sits inside of a file,

1041
01:18:44,960 --> 01:18:47,570
this mmap interface is much more convenient.

1042
01:18:48,060 --> 01:18:51,930
Then you know this previous interface, we're you know we have to read,

1043
01:18:51,930 --> 01:18:55,800
you know we manipulated the memory you know we you know we seek back

1044
01:18:55,800 --> 01:18:57,180
and then we actually write the information.

1045
01:18:57,740 --> 01:18:59,360
And in this particular case,

1046
01:18:59,360 --> 01:19:03,410
we really can think about the file as being an array of bytes,

1047
01:19:03,410 --> 01:19:07,790
you know that we can write willy nilly, without actually having to navigate to jump around,

1048
01:19:11,950 --> 01:19:16,060
do people see what the advantage of the mmap interfaces.

1049
01:19:23,960 --> 01:19:25,040
Any questions about this?

1050
01:19:28,170 --> 01:19:32,310
Many big storage systems use this,

1051
01:19:32,310 --> 01:19:36,300
like I don't know like databases do they use this a lot or not really.

1052
01:19:36,630 --> 01:19:37,740
They use this a lot.

1053
01:19:38,600 --> 01:19:40,850
I think a lot of applications use mmap,

1054
01:19:40,880 --> 01:19:44,660
because for these kinds of things like a database is much more convenient,

1055
01:19:47,270 --> 01:19:49,790
then this interface, this interface is great correct,

1056
01:19:49,790 --> 01:19:51,560
if you need to read from standard input,

1057
01:19:51,680 --> 01:19:53,570
and there's a stream of bytes coming in,

1058
01:19:53,600 --> 01:19:57,770
you read you read you read and you produce some output some other stream.

1059
01:19:58,910 --> 01:20:01,640
That interface that interface is very suitable for here,

1060
01:20:02,000 --> 01:20:03,500
you don't have to update offset,

1061
01:20:03,500 --> 01:20:05,510
you know you read, get offset immediately update,

1062
01:20:05,510 --> 01:20:07,760
you read again, you read a bit further etc etc.

1063
01:20:07,940 --> 01:20:11,600
So it's really good for stream oriented input.

1064
01:20:12,190 --> 01:20:13,450
Well, this is really good,

1065
01:20:13,450 --> 01:20:21,600
you know if the file has data structure, and use one of sort of update basic pieces of the file,

1066
01:20:21,600 --> 01:20:23,850
and you know arbitrary locations.

1067
01:20:32,220 --> 01:20:42,660
Okay, let's see, I'm going to start on about to run out of time.

1068
01:20:43,270 --> 01:20:46,200
So let me so stop here,

1069
01:20:46,200 --> 01:20:48,750
hopefully this one tidbit about mmap,

1070
01:20:48,750 --> 01:20:51,150
you know it's useful to know,

1071
01:20:51,540 --> 01:20:56,650
and tells you why you know that sort of is a popular scheme.

1072
01:21:00,080 --> 01:21:01,010
Let's see,

1073
01:21:01,040 --> 01:21:06,560
so I I think that actually you know we were basically we come to the end of this lecture

1074
01:21:06,590 --> 01:21:16,000
and I guess the end of the end of six the six 6.S081

1075
01:21:16,030 --> 01:21:21,790
and so again you know if you have not filled out the feedback survey,

1076
01:21:21,790 --> 01:21:24,640
you know please do so,

1077
01:21:24,670 --> 01:21:28,300
you know we appreciate if you fill out the subject evaluation.

1078
01:21:29,180 --> 01:21:34,080
And and again I wanna thank you for your attention,

1079
01:21:34,110 --> 01:21:36,330
again it is a strange semester,

1080
01:21:36,330 --> 01:21:38,400
I wish I could have met you all in person.

1081
01:21:39,620 --> 01:21:43,880
Talk to you in person either class or before class or after class,

1082
01:21:44,240 --> 01:21:48,650
and unfortunately, as it happened,

1083
01:21:48,680 --> 01:21:52,940
but I hope you got quite a bit of 6.S081

1084
01:21:52,940 --> 01:21:56,120
and certainly with the staff and thank you for the engagement,

1085
01:21:56,210 --> 01:21:59,060
you guys have been wonderful this semester.

1086
01:21:59,860 --> 01:22:01,800
So with that, thank you.

1087
01:22:03,150 --> 01:22:05,160
If you have any questions, please hang around.

1088
01:22:06,550 --> 01:22:08,500
But I'm sure some of you have deadlines.

1089
01:22:10,100 --> 01:22:12,680
Honestly on behalf of the TAs as well,

1090
01:22:12,680 --> 01:22:18,110
we've really enjoyed all the time we spent with you guys in office hours and doing check offs,

1091
01:22:18,110 --> 01:22:20,210
and this is the first semester, we've done check offs

1092
01:22:20,210 --> 01:22:23,600
and then David and I both found it a really enjoyable process

1093
01:22:23,600 --> 01:22:28,220
and you know hopefully we were able to help you guys out and have some good conversations,

1094
01:22:28,220 --> 01:22:30,530
as well so thanks for making it a great semester

1095
01:22:30,530 --> 01:22:35,350
and adjusting on the fly with us with all of the remote learning problems,

1096
01:22:35,350 --> 01:22:39,970
we've run into and had to deal with an absolute pleasure achieving this course.

1097
01:22:46,360 --> 01:22:47,320
Any further questions?

1098
01:22:49,170 --> 01:22:50,670
Again, feel free to hang around.

1099
01:23:00,530 --> 01:23:03,260
Oh, I had a question,

1100
01:23:03,800 --> 01:23:11,500
so, it's it's oh yeah, thank you so much for the class, I really like class, the best class semester,

1101
01:23:11,620 --> 01:23:16,210
I wanted to ask about the interrupts, the received interrupts,

1102
01:23:16,270 --> 01:23:23,160
how does the how does the hardware knows when when the software has finished,

1103
01:23:24,130 --> 01:23:27,970
handling the previous interrupt, not issue another one.

1104
01:23:28,800 --> 01:23:32,220
Because the there's multiple steps,

1105
01:23:32,880 --> 01:23:43,030
one is you know you're looking e1000 at the bottom,

1106
01:23:43,420 --> 01:23:48,070
we re-enable interrupts or we tell the card, we're ready to receive further interrupts.

1107
01:23:49,170 --> 01:23:52,320
So that's why we tell the card to generate interrupts,

1108
01:23:52,770 --> 01:23:55,410
of course at this point interrupts actually not really turned on,

1109
01:23:55,410 --> 01:23:57,720
and we just tells the card you can generate interrupts again.

1110
01:23:58,280 --> 01:24:00,710
The interrupts get turned on correct,

1111
01:24:00,710 --> 01:24:04,310
like you know by you know these functions, you know interrupt enable

1112
01:24:04,730 --> 01:24:07,280
and at that point, if you turn on interrupt enable,

1113
01:24:07,280 --> 01:24:12,620
if this field set, plus you know the point where you turn on interrupt enable

1114
01:24:12,650 --> 01:24:14,330
and actually interrupt might happen again.

1115
01:24:15,680 --> 01:24:18,680
Right, I forgot about this register, thank you so much.

1116
01:24:18,680 --> 01:24:22,670
Yeah, it's just like one instruction, easy to miss.

1117
01:24:25,960 --> 01:24:26,770
Any other questions?

1118
01:24:30,500 --> 01:24:31,490
Thank you all.

1119
01:24:32,580 --> 01:24:33,480
Thank you, okay.

1120
01:24:36,520 --> 01:24:37,420
Thank you.

1121
01:24:38,770 --> 01:24:39,850
Thank you.

1122
01:24:40,910 --> 01:24:41,840
Thank you so much.

