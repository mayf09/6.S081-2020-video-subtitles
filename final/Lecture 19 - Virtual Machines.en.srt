1
00:00:02,580 --> 00:00:06,430
Alright, I'd like to get started.

2
00:00:09,560 --> 00:00:11,450
Today I will talk about virtual machines.

3
00:00:12,090 --> 00:00:16,290
And I'm gonna lecture is really going to be divided into three pieces,

4
00:00:16,290 --> 00:00:20,790
one is going to start with what's called trap and emulate virtualization,

5
00:00:20,790 --> 00:00:25,830
which is basically an overview of how you could build your own virtual machine scheme

6
00:00:26,370 --> 00:00:29,700
RISC-V in QEMU,

7
00:00:30,000 --> 00:00:31,410
then I'm gonna talk a bit about

8
00:00:31,560 --> 00:00:36,120
recent hardware support and microprocessors for virtualization,

9
00:00:36,870 --> 00:00:39,090
and then about today's paper Dune

10
00:00:39,090 --> 00:00:42,600
which uses this modern hardware support.

11
00:00:43,330 --> 00:00:47,140
Alright, so first, what is a virtual machine,

12
00:00:47,770 --> 00:00:51,160
it's really you can think of it as a simulation of a computer,

13
00:00:51,160 --> 00:00:54,850
that's accurate enough to run an operating system,

14
00:00:55,180 --> 00:01:00,980
so QEMU is a, a example of

15
00:01:00,980 --> 00:01:03,740
you could consider to be an example of a virtual machine,

16
00:01:04,130 --> 00:01:07,580
the way I'm going to talk about it is that,

17
00:01:10,880 --> 00:01:14,000
down at the lowest level sitting on top of the hardware,

18
00:01:14,450 --> 00:01:19,520
we're gonna imagine a virtual machine monitor or VMM,

19
00:01:20,000 --> 00:01:24,740
and this more or less takes the place of the standard operating system kernel,

20
00:01:26,700 --> 00:01:28,890
and the virtual machine monitor's job is

21
00:01:28,890 --> 00:01:34,670
to simulate a bunch of computers for guest operating systems,

22
00:01:34,760 --> 00:01:42,260
so said, appear in in you know what used to be user space in our usual diagrams,

23
00:01:42,260 --> 00:01:44,240
but has now guest space.

24
00:01:44,540 --> 00:01:49,260
So this is we call this guest space

25
00:01:49,260 --> 00:01:52,020
and down here host space.

26
00:01:52,830 --> 00:01:57,480
We're gonna have a bunch of, one or more guest operating systems kernels,

27
00:01:57,480 --> 00:02:05,990
so we might have a Linux kernel as one guest,

28
00:02:07,340 --> 00:02:09,590
and this Linux kernel is gonna

29
00:02:09,950 --> 00:02:12,620
you know it's just it thinks of itself as an ordinary kernel,

30
00:02:12,620 --> 00:02:14,060
and it runs a bunch of processes,

31
00:02:14,060 --> 00:02:17,120
maybe VI and a C compiler.

32
00:02:17,750 --> 00:02:20,540
Then we might have other guest,

33
00:02:21,900 --> 00:02:25,380
I have other guest two guest virtual machines running here,

34
00:02:25,380 --> 00:02:27,600
there might be maybe another Linux

35
00:02:27,600 --> 00:02:30,870
or maybe even some other operating system like Windows,

36
00:02:32,670 --> 00:02:34,230
all running on the same machine,

37
00:02:34,830 --> 00:02:38,830
and there would be windows processes running

38
00:02:38,830 --> 00:02:42,880
within as within this guest operating system.

39
00:02:43,060 --> 00:02:49,180
So the host, the host world where the virtual machine monitor runs,

40
00:02:49,180 --> 00:02:53,800
and guest world where these ordinary operating systems run,

41
00:02:53,860 --> 00:02:58,870
and furthermore, we're going to talk about a lot about in

42
00:02:58,870 --> 00:03:09,810
within the guest world, a guest supervisor mode which is mode that kernels running,

43
00:03:09,810 --> 00:03:13,170
the guest kernels running at guest user mode.

44
00:03:16,680 --> 00:03:22,920
And again, the the kind of classical goal of virtual machine monitor is

45
00:03:22,950 --> 00:03:25,020
to provide an emulation of a machine,

46
00:03:25,020 --> 00:03:25,650
that's so good,

47
00:03:25,650 --> 00:03:29,370
that you can just boot ordinary Linux, ordinary Windows unmodified

48
00:03:29,820 --> 00:03:32,550
and have it run inside this virtual machine,

49
00:03:32,550 --> 00:03:36,060
never suspecting that anything funny is going on.

50
00:03:36,820 --> 00:03:40,300
So, for example, the virtual machine monitor has to be in a position

51
00:03:40,300 --> 00:03:43,750
to emulate the difference between supervisor mode and user mode in a way

52
00:03:43,750 --> 00:03:48,340
that is just completely convincing simulation of how the actual hardware does it,

53
00:03:49,000 --> 00:03:49,840
even though that's,

54
00:03:50,540 --> 00:03:52,520
you can't really be exactly what's going on,

55
00:03:53,210 --> 00:03:56,270
so that's why we talk about guest supervisor mode and guest user mode,

56
00:03:56,510 --> 00:03:59,060
VMM's emulation of those two modes.

57
00:03:59,960 --> 00:04:04,640
So so why would you want to use a virtual machine,

58
00:04:05,330 --> 00:04:06,740
it turns out there's a lot of reasons

59
00:04:06,740 --> 00:04:12,350
to run lots of a distinct guest operating systems on a single computer,

60
00:04:13,010 --> 00:04:16,010
sometimes maybe you're running a big company

61
00:04:16,010 --> 00:04:18,650
and you, you need to have lots and lots of servers,

62
00:04:18,650 --> 00:04:22,040
maybe you know name servers and security servers, who knows what

63
00:04:22,190 --> 00:04:25,010
and each one of them doesn't use many resources,

64
00:04:25,040 --> 00:04:28,850
so it's sort of a waste of time to have to buy a physical machine for it,

65
00:04:29,090 --> 00:04:31,340
but you want to run, you know you want to

66
00:04:31,340 --> 00:04:34,880
run lots of these low intensity servers on a single piece of hardware,

67
00:04:34,880 --> 00:04:37,940
you can save money by using a virtual machine.

68
00:04:39,190 --> 00:04:45,460
It turns out virtual machines are also very, very widely used in cloud computing

69
00:04:45,550 --> 00:04:48,550
where it's an outfit like Amazon Amazon AWS,

70
00:04:48,850 --> 00:04:52,540
they don't want to rent out physical machines to people,

71
00:04:52,540 --> 00:04:55,300
because that turns out to be a difficult to manage,

72
00:04:55,300 --> 00:04:59,380
what they want to do is rent their customers, their cloud customers

73
00:04:59,470 --> 00:05:06,850
just a machine that Amazon can on the fly you know decide what hardware run it on

74
00:05:06,850 --> 00:05:08,890
whether to run a bigger or smaller machine,

75
00:05:08,890 --> 00:05:10,270
Amazon can decide,

76
00:05:11,920 --> 00:05:15,070
you know, it's a it's current customers,

77
00:05:15,070 --> 00:05:18,040
maybe there's two customers on this piece of hardware right here,

78
00:05:18,040 --> 00:05:19,510
but they're not using the computer very much,

79
00:05:19,510 --> 00:05:23,110
maybe it can pack a third or fourth customer onto that same piece of hardware

80
00:05:23,230 --> 00:05:26,170
without spending extra money, but get more revenue.

81
00:05:26,500 --> 00:05:32,020
So this virtual machines allow kind of extra level of flexibility

82
00:05:32,920 --> 00:05:35,830
and you know it's kind of trick that's being used is

83
00:05:35,830 --> 00:05:40,810
that we're kind of shifting up the existing operating system kernels and user space

84
00:05:40,810 --> 00:05:46,090
and adding a new layer underneath to provide this flexibility.

85
00:05:47,220 --> 00:05:50,880
It turns out there's there's other reasons why people use virtual machines,

86
00:05:50,880 --> 00:05:52,350
one is certainly kernel development,

87
00:05:52,350 --> 00:05:54,690
which is why we all use QEMU,

88
00:05:55,260 --> 00:05:59,160
the ability to run xv6 in a kind of virtual environment,

89
00:05:59,160 --> 00:06:01,190
rather than a real computer,

90
00:06:01,190 --> 00:06:04,700
makes this course much more convenient for all of us,

91
00:06:04,880 --> 00:06:06,920
it also makes it a little bit easier to debug,

92
00:06:06,920 --> 00:06:09,050
because we can turns out that

93
00:06:09,260 --> 00:06:13,400
once you're running xv6 and this virtual machine environment,

94
00:06:13,400 --> 00:06:16,550
QEMU provides us easier to provide GDB access,

95
00:06:17,690 --> 00:06:19,940
than it would be on a physical computer.

96
00:06:21,140 --> 00:06:24,410
And the final reason that people use virtual machines is that,

97
00:06:24,440 --> 00:06:26,480
there's a bunch of tricks that can be played

98
00:06:26,840 --> 00:06:30,920
using this extra layer of indirection provided by the virtual machine monitor,

99
00:06:30,920 --> 00:06:37,790
for example, you can checkpoint an entire running operating system and user processes,

100
00:06:37,790 --> 00:06:39,560
you can take a checkpoint of it,

101
00:06:40,010 --> 00:06:42,170
stash it away somewhere maybe on disk,

102
00:06:42,170 --> 00:06:44,120
and then later restore that checkpoint,

103
00:06:44,300 --> 00:06:48,870
sort of exactly the state of that operating system and its processes

104
00:06:48,900 --> 00:06:50,310
as it was at the time of the checkpoint,

105
00:06:50,310 --> 00:06:52,980
it's useful for reliability for debugging

106
00:06:53,100 --> 00:06:56,340
for maybe cloning the image of a virtual machine,

107
00:06:56,340 --> 00:06:58,350
so you can run it multiple times.

108
00:06:58,620 --> 00:07:00,180
Another game you can play is

109
00:07:00,180 --> 00:07:06,060
you can might migrate a guest an entire guest to another computer,

110
00:07:06,150 --> 00:07:09,000
if you have a guest operating system running on a physical computer

111
00:07:09,150 --> 00:07:11,970
and you need to shut down or replace that physical computer,

112
00:07:12,120 --> 00:07:16,890
you can actually turns out move the running virtual machine image

113
00:07:16,890 --> 00:07:19,740
without disturbing it to another physical computer,

114
00:07:19,740 --> 00:07:21,390
so that you can shut down the first one.

115
00:07:22,330 --> 00:07:26,020
There's just examples of why people really like virtual machines

116
00:07:26,020 --> 00:07:29,170
and people really do virtual machines are very, very widely used,

117
00:07:29,500 --> 00:07:31,540
and they also have a long history,

118
00:07:31,540 --> 00:07:34,060
this ideas first came up in the 1960s,

119
00:07:34,060 --> 00:07:36,520
and they've been developed over time

120
00:07:36,640 --> 00:07:41,190
until they're, they're quite pervasive easy to use.

121
00:07:42,690 --> 00:07:46,890
For this course, the reason why we're looking into them is

122
00:07:46,890 --> 00:07:51,240
that virtual machine monitors provide sort of different view

123
00:07:51,240 --> 00:07:53,220
on what an operating system can be,

124
00:07:53,640 --> 00:07:56,640
instead of the process abstraction we're all used to,

125
00:07:56,640 --> 00:07:58,560
you know we have some analogous structures here,

126
00:07:58,560 --> 00:08:02,130
but a sort of providing a different kind of container,

127
00:08:02,130 --> 00:08:06,030
it's not a process, it's a sort of simulated machine,

128
00:08:06,690 --> 00:08:10,920
allows us to kind of think about all the stuff we've been talking about,

129
00:08:11,490 --> 00:08:16,470
memory allocation, scheduling protection, from a different point of view,

130
00:08:17,790 --> 00:08:18,870
maybe give us some ideas,

131
00:08:18,870 --> 00:08:21,750
which we can take back to traditional operating system kernels,

132
00:08:22,050 --> 00:08:24,570
and indeed much of the action

133
00:08:24,900 --> 00:08:28,770
sort of development design, development research action

134
00:08:28,800 --> 00:08:32,880
has shifted from conventional kernels

135
00:08:33,600 --> 00:08:36,930
down into the virtual machine monitors themselves,

136
00:08:36,930 --> 00:08:38,760
as they've gotten more and more prevalent,

137
00:08:38,760 --> 00:08:42,330
so in some sense kind of the topic of operating systems

138
00:08:42,330 --> 00:08:45,660
is drifting downwards a bit by one layer.

139
00:08:48,090 --> 00:08:52,260
Okay, for the first part of this lecture I want to talk about

140
00:08:52,440 --> 00:08:59,520
a bit about how we could implement our own virtual machine,

141
00:08:59,550 --> 00:09:03,570
and I'm gonna use RISC-V as that sort of,

142
00:09:04,280 --> 00:09:08,720
assume that we're trying to emulate RISC-V hardware,

143
00:09:08,720 --> 00:09:12,650
so we can run operating systems designed for RISC-V xv6.

144
00:09:14,420 --> 00:09:18,800
And just to repeat the specific goals,

145
00:09:19,610 --> 00:09:24,020
what we'd like we're for kind of classical virtual machines,

146
00:09:24,200 --> 00:09:25,280
what we'd like to build is

147
00:09:25,280 --> 00:09:30,800
something in which the guest software is just completely not aware,

148
00:09:30,980 --> 00:09:32,990
that it's running inside a virtual machine,

149
00:09:33,230 --> 00:09:35,210
we want to build something

150
00:09:35,570 --> 00:09:38,600
that makes it impossible for the guest software to distinguish

151
00:09:38,780 --> 00:09:42,710
to decide whether is this am I running on a real machine or a virtual machine, right,

152
00:09:42,710 --> 00:09:44,660
we want the emulation to be that good.

153
00:09:45,090 --> 00:09:47,400
And the reason for that is that we don't want,

154
00:09:47,910 --> 00:09:49,800
we want to be able to,

155
00:09:49,830 --> 00:09:52,080
we'd like to be able to run anything in our virtual machine,

156
00:09:52,170 --> 00:09:55,200
any operating system even maybe an operating system we haven't heard of,

157
00:09:55,440 --> 00:09:57,330
and that means that you know,

158
00:09:57,330 --> 00:10:00,510
whatever funny stuff the operating system does

159
00:10:00,510 --> 00:10:01,800
and the way it uses hardware,

160
00:10:02,010 --> 00:10:08,620
the virtual machine has to provide that an emulation of exactly the hardware,

161
00:10:08,620 --> 00:10:11,230
so that any tricks that work on the real hardware

162
00:10:11,230 --> 00:10:12,850
are also going to work on the virtual machine.

163
00:10:14,620 --> 00:10:20,290
Sort of similar goal that we'd like is,

164
00:10:20,350 --> 00:10:21,670
we want there to be no way,

165
00:10:21,670 --> 00:10:26,020
not only no way for a guest to decide if it's running on virtual machine,

166
00:10:26,050 --> 00:10:29,530
but no way for guests to be able to escape from the virtual machine,

167
00:10:29,560 --> 00:10:32,530
a lot of the reason why people use virtual machines is

168
00:10:32,530 --> 00:10:37,120
to provide strict confinement for untrusted software,

169
00:10:37,240 --> 00:10:40,240
even untrusted operating systems running inside the virtual machine,

170
00:10:40,420 --> 00:10:43,750
for example if you're Amazon and you're selling cloud servers,

171
00:10:44,110 --> 00:10:47,770
your customers often who provide the operating system

172
00:10:47,800 --> 00:10:50,290
that runs on the virtual machine as well as the applications

173
00:10:50,530 --> 00:10:53,620
and gosh for all you know your customers are not running ordinary Linux,

174
00:10:53,680 --> 00:10:55,960
they're running a special hacked version of Linux,

175
00:10:55,990 --> 00:11:00,880
whose intended to try to break out of its virtual machine

176
00:11:00,880 --> 00:11:05,590
and break into Amazon's either the virtual machines of Amazon's or other customer's

177
00:11:05,590 --> 00:11:10,690
or into the virtual machine monitor that Amazon uses to enforce isolation.

178
00:11:10,960 --> 00:11:13,130
So, it's quite important

179
00:11:13,370 --> 00:11:16,520
that guest and not be able to break out of their virtual machines,

180
00:11:16,520 --> 00:11:18,290
they be able to use the memory,

181
00:11:18,650 --> 00:11:21,590
that they're allowed to use by the virtual machine monitor, for example,

182
00:11:21,770 --> 00:11:23,630
but not other memory,

183
00:11:24,350 --> 00:11:26,360
similarly that they shouldn't be able to reach out

184
00:11:26,600 --> 00:11:31,760
without permission and use things like storage devices or network interface cards,

185
00:11:32,120 --> 00:11:34,010
so you're gonna have very strict isolation.

186
00:11:34,250 --> 00:11:36,800
And in many ways

187
00:11:36,830 --> 00:11:42,650
virtual machines provides stricter isolation than ordinary Unix processes,

188
00:11:42,860 --> 00:11:44,990
ordinary Unix processes can often interact,

189
00:11:44,990 --> 00:11:46,400
they can kill each other

190
00:11:46,400 --> 00:11:50,540
or they can read or write the same files or communicate over pipes,

191
00:11:50,600 --> 00:11:56,090
but, in a sort of ordinary virtual machines, none of that's possible,

192
00:11:56,510 --> 00:12:00,650
the different virtual machines running on the same computer

193
00:12:01,580 --> 00:12:05,420
completely isolated from each other by the virtual machine monitors.

194
00:12:05,420 --> 00:12:06,950
So people like them for security,

195
00:12:07,160 --> 00:12:09,740
it's a way of being able to run untrusted software

196
00:12:10,790 --> 00:12:13,040
without having to worry if it's buggy or malicious.

197
00:12:14,480 --> 00:12:16,730
You know in practice,

198
00:12:17,590 --> 00:12:24,610
I've pitched the goal as being sort of completely faithful emulation of a physical machine,

199
00:12:24,610 --> 00:12:30,340
in fact, it turns out that for performance reasons, this is often blurred

200
00:12:30,340 --> 00:12:32,170
and you'll find for example that

201
00:12:32,770 --> 00:12:37,810
Linux and the most common virtual machine monitors have co-evolved a little bit,

202
00:12:37,810 --> 00:12:39,580
so that in real life,

203
00:12:39,640 --> 00:12:42,850
Linux may actually be aware that it's running on a virtual machine monitor

204
00:12:42,850 --> 00:12:46,060
and with the virtual machine monitors permission for efficiency,

205
00:12:46,870 --> 00:12:51,100
Linux sometimes knowingly talks down to the virtual machine monitors

206
00:12:51,100 --> 00:12:53,920
to do things like get high-speed access to devices,

207
00:12:54,160 --> 00:12:56,290
but that's a carefully controlled exception

208
00:12:56,530 --> 00:13:01,940
and the general strategy is completely faithful simulation.

209
00:13:05,870 --> 00:13:09,410
Okay, so how could we build our own virtual machine monitor.

210
00:13:11,760 --> 00:13:15,120
Well, one possibility would be to do it entirely in software,

211
00:13:15,150 --> 00:13:19,200
you can imagine writing something like QEMU,

212
00:13:19,350 --> 00:13:23,070
that interpreted the machine instructions,

213
00:13:23,070 --> 00:13:27,150
that is you could write a program that would open up the xv6

214
00:13:27,210 --> 00:13:30,870
to read the file that has the xv6 instructions in it

215
00:13:30,990 --> 00:13:33,000
and your program could look at these instructions,

216
00:13:33,000 --> 00:13:36,390
say oh that's a load instruction or a move instruction

217
00:13:36,390 --> 00:13:41,250
and your program could you know sort of simulate RISC-V state,

218
00:13:41,250 --> 00:13:45,060
may have 32 registers implemented in software,

219
00:13:45,770 --> 00:13:48,650
and as your software sort of reads each instruction and picks it apart,

220
00:13:48,650 --> 00:13:50,090
it figures out what kind of instruction is,

221
00:13:50,090 --> 00:13:56,810
it would apply the effects of that instruction to the 32 registers and control registers,

222
00:13:56,810 --> 00:13:58,730
that it was simulating all in software.

223
00:13:59,710 --> 00:14:01,210
And people do this

224
00:14:01,660 --> 00:14:05,590
and it's conceptually straightforward to make it work,

225
00:14:05,590 --> 00:14:09,020
although it maybe a lot of work to get all the details right,

226
00:14:09,500 --> 00:14:21,530
the reason why sort of pure software interpretive virtual machines aren't widely used

227
00:14:21,530 --> 00:14:22,520
is that they're slow,

228
00:14:23,380 --> 00:14:24,670
if you play this game,

229
00:14:24,760 --> 00:14:27,340
your virtual machine is going to run guest software

230
00:14:27,340 --> 00:14:32,110
at a small fraction of the speed of the hardware that you're using,

231
00:14:32,110 --> 00:14:35,260
because for every your virtual machine monitor software has to

232
00:14:35,260 --> 00:14:37,540
look at every instruction as it's executed up here,

233
00:14:37,720 --> 00:14:41,110
your machine monitor is going to maybe run dozens of instructions

234
00:14:41,380 --> 00:14:44,680
in the process of interpreting each one of the guest instructions

235
00:14:44,680 --> 00:14:48,740
and so it's going to be orders of magnitude slower than a real computer

236
00:14:48,740 --> 00:14:51,050
and for something like cloud computing,

237
00:14:51,790 --> 00:14:53,770
it really would not be a practical.

238
00:14:53,860 --> 00:14:58,730
So people don't use the software interpretation

239
00:14:59,090 --> 00:15:01,610
to build virtual machines for production systems,

240
00:15:02,000 --> 00:15:09,810
instead, sort of core of,

241
00:15:10,080 --> 00:15:15,840
one of the main widely used strategies is

242
00:15:15,900 --> 00:15:21,030
to run the actually run the guest instructions on the real CPU.

243
00:15:24,000 --> 00:15:29,340
So if you were going to run xv6 in your virtual machine monitor,

244
00:15:29,430 --> 00:15:33,840
you would actually load xv6 its instructions the kernel,

245
00:15:33,870 --> 00:15:37,880
the beginning, you know entire xv6 instructions in a memory

246
00:15:37,880 --> 00:15:43,970
and then jump to the first instruction in xv6, right.

247
00:15:45,410 --> 00:15:49,430
In order to have your computer actually run the instructions in xv6

248
00:15:49,430 --> 00:15:51,200
and of course this requires that your computer

249
00:15:51,200 --> 00:15:55,520
has the same microprocessor in it that xv6 is expecting,

250
00:15:55,520 --> 00:15:58,490
but that's easy to arrange.

251
00:15:59,570 --> 00:16:02,770
Now, it turns out you can't literally do this,

252
00:16:02,800 --> 00:16:05,470
point at which you run into trouble is

253
00:16:05,470 --> 00:16:12,470
when your guest operating system first executed a privileged instruction, right.

254
00:16:12,500 --> 00:16:17,760
If, and you know that's really the difference between the kernel and ordinary user code is

255
00:16:17,760 --> 00:16:20,280
that kernels which is what we're trying to run here

256
00:16:20,280 --> 00:16:22,950
in our virtual machine kernels use privileged instructions,

257
00:16:23,250 --> 00:16:26,220
guest your guest kernel might for example

258
00:16:26,280 --> 00:16:31,110
try to load a new page table into the satp register RISC-V.

259
00:16:32,670 --> 00:16:34,500
So that's starting to present a puzzle,

260
00:16:35,540 --> 00:16:39,440
if we're executing our guest kernel as an ordinary user process

261
00:16:39,440 --> 00:16:45,410
and Linux for example boy loading satp an illegal instruction in user mode,

262
00:16:45,470 --> 00:16:47,210
then so our programs going to crash,

263
00:16:47,750 --> 00:16:49,040
if we are so foolish as

264
00:16:49,040 --> 00:16:54,740
to load our guest kernel into and run it in supervisor mode,

265
00:16:55,880 --> 00:17:00,440
somehow then our guest kernel will now be able to modify the real page table

266
00:17:00,440 --> 00:17:03,620
and would be able to escape from its virtual machine,

267
00:17:03,980 --> 00:17:11,020
because it controls the contents of PTEs read and write any memory.

268
00:17:11,050 --> 00:17:14,980
So we can't use a strategy that's as simple as

269
00:17:14,980 --> 00:17:17,770
just running the guest kernel directly,

270
00:17:18,610 --> 00:17:20,680
instead we're going to start playing some tricks.

271
00:17:21,340 --> 00:17:28,240
The first step is to run the guest kernel in user mode,

272
00:17:32,240 --> 00:17:39,900
so, this is sort of the fundamental strategy here,

273
00:17:39,960 --> 00:17:42,030
what we're run the guest kernel in user mode,

274
00:17:42,770 --> 00:17:46,340
you know in RISC-V user mode

275
00:17:46,460 --> 00:17:48,350
and so what that means,

276
00:17:48,880 --> 00:17:52,510
you know we're writing, we're writing our own virtual machine monitor

277
00:17:52,930 --> 00:17:55,180
and when we tell it look please boot xv6,

278
00:17:55,300 --> 00:17:59,890
it's going to load xv6's kernel instructions into memory somewhere,

279
00:18:02,120 --> 00:18:03,980
maybe set up a page table appropriately,

280
00:18:03,980 --> 00:18:07,100
that makes it look to xv6 like

281
00:18:07,130 --> 00:18:11,240
its memory starts at 0 and goes up to whatever high memory is,

282
00:18:11,360 --> 00:18:15,170
and then the virtual machine monitor,

283
00:18:15,170 --> 00:18:20,830
we use a trap sret instruction as [evolved] come across on xv6

284
00:18:20,950 --> 00:18:31,180
to jump into the first instruction of the guest OS in user mode,

285
00:18:31,600 --> 00:18:33,790
so the guest operating system will execute along

286
00:18:33,790 --> 00:18:35,710
and many instructions will work fine,

287
00:18:35,710 --> 00:18:39,100
if the guest operating systems just adding two registers together,

288
00:18:39,640 --> 00:18:42,100
reading loading or storing from memory that'll just work

289
00:18:42,370 --> 00:18:46,180
and as soon as the guest operating system uses privilege instruction,

290
00:18:46,210 --> 00:18:48,790
what's gonna happen is it's going to trap,

291
00:18:48,850 --> 00:18:50,710
the RISC-V hardware cause it,

292
00:18:50,890 --> 00:18:53,410
since it's running in user mode, not supervisor mode,

293
00:18:53,560 --> 00:18:56,740
will cause it to trap back into the our virtual machine monitor

294
00:18:56,740 --> 00:18:58,030
and will get control,

295
00:18:58,450 --> 00:19:03,730
so if the guest operating system, for example tries to change satp, the page table pointer,

296
00:19:03,910 --> 00:19:07,990
boom, the RISC-V CPU will trap into our virtual machine monitor

297
00:19:07,990 --> 00:19:09,970
and our software will get control back.

298
00:19:10,890 --> 00:19:12,720
And our software we're able to look and see

299
00:19:12,720 --> 00:19:17,130
what instruction caused the trap and do something appropriate,

300
00:19:17,850 --> 00:19:19,260
but the cool thing here is that,

301
00:19:19,260 --> 00:19:24,340
the guest operating system didn't actually get to set the page table pointer.

302
00:19:24,460 --> 00:19:28,900
But how does how does the VMM intercept this,

303
00:19:28,900 --> 00:19:31,480
like it has to set the trap handler, right,

304
00:19:31,510 --> 00:19:35,020
isn't that something only a privileged process can do,

305
00:19:35,680 --> 00:19:39,100
VMM is a user program on the host OS right.

306
00:19:39,100 --> 00:19:40,720
Okay, what I'm assuming,

307
00:19:41,940 --> 00:19:46,170
what I'm assuming is that the virtual machine monitor runs in supervisor mode,

308
00:19:46,170 --> 00:19:48,150
so in this simple picture,

309
00:19:48,420 --> 00:19:53,310
the virtual machine monitor is the kernel that boots on this piece of hardware,

310
00:19:53,700 --> 00:19:57,720
so instead of booting Linux or whatever you would boot this virtual machine monitor,

311
00:19:57,840 --> 00:19:59,280
it boots in supervisor mode,

312
00:19:59,280 --> 00:20:01,080
it has complete control over the hardware,

313
00:20:01,500 --> 00:20:06,120
so we can set up you know stvec and all this other stuff, however it likes.

314
00:20:06,540 --> 00:20:07,350
That makes sense.

315
00:20:07,710 --> 00:20:11,910
You know, and actually some virtual machine monitors work exactly that way,

316
00:20:11,910 --> 00:20:13,230
you just boot them on the hardware

317
00:20:13,230 --> 00:20:17,160
and its just the virtual machine monitor only that's running in supervisor mode.

318
00:20:17,940 --> 00:20:21,210
In fact, there's also many many virtual machines schemes out there,

319
00:20:21,210 --> 00:20:24,270
in fact, boot Linux,

320
00:20:25,940 --> 00:20:28,010
and then once Linux is up and running,

321
00:20:28,250 --> 00:20:32,300
you load, load the virtual

322
00:20:32,330 --> 00:20:36,830
actually Linux, actually Linux comes with a virtual machine monitor,

323
00:20:36,830 --> 00:20:38,660
or you load the virtual machine monitor

324
00:20:38,660 --> 00:20:42,830
as what's called loadable kernel module into Linux

325
00:20:43,100 --> 00:20:46,370
and it runs in the kernel in supervisor mode.

326
00:20:47,040 --> 00:20:49,800
And that's the way actually today's paper says,

327
00:20:49,860 --> 00:20:54,220
boot Linux, then run this little loadable kernel module,

328
00:20:54,430 --> 00:20:57,460
but the main point is the virtual machine monitor software

329
00:20:57,460 --> 00:21:01,120
and the software rewriting that we trust runs in supervisor mode,

330
00:21:01,620 --> 00:21:04,770
now we're going to run the guest in user mode,

331
00:21:05,540 --> 00:21:09,530
but arrange for it to look like it's running in supervisor mode as far as it's concerned.

332
00:21:12,540 --> 00:21:16,170
Okay, so the good news is that

333
00:21:16,170 --> 00:21:22,950
on RISC-V, everything dangerous traps,

334
00:21:22,950 --> 00:21:26,650
if you try to do it in user mode,

335
00:21:26,740 --> 00:21:30,490
that is all the sort of privilege things that supervisor mode can do

336
00:21:30,580 --> 00:21:34,870
with with the exception of stuff having to do with the page table or PTE

337
00:21:34,870 --> 00:21:35,950
which we'll talk about in a bit,

338
00:21:35,950 --> 00:21:42,050
but basically every every supervisor only instruction causes a trap,

339
00:21:42,050 --> 00:21:44,600
if you try to execute in user mode.

340
00:21:45,140 --> 00:21:46,850
So that means that every time they gotta stop running system,

341
00:21:46,850 --> 00:21:51,230
does anything like reads scause or reads writes stvec or does any of those things,

342
00:21:51,230 --> 00:21:56,420
that xv6 for example does to configure with the privileged part of RISC-V hardware

343
00:21:56,480 --> 00:21:58,790
will cause a trap into the virtual machine monitor

344
00:21:59,990 --> 00:22:01,130
and we'll get control.

345
00:22:01,950 --> 00:22:05,000
And then, the game is going to be

346
00:22:05,000 --> 00:22:11,210
the virtual machine monitor is going to maintain virtual state,

347
00:22:11,450 --> 00:22:25,450
a whole table of virtual state information for for the guest,

348
00:22:25,480 --> 00:22:27,880
so the virtual machine monitor will have,

349
00:22:27,880 --> 00:22:36,760
for example and virtual stvec register just implemented, that's a variable in software

350
00:22:36,760 --> 00:22:42,000
and a virtual sepc register

351
00:22:42,000 --> 00:22:44,520
and all these for all these protected registers,

352
00:22:44,520 --> 00:22:46,440
there's a whole array of them down here,

353
00:22:46,590 --> 00:22:48,480
implemented by the virtual machine monitor

354
00:22:48,630 --> 00:22:51,930
and when the guest operating system for example runs the instruction,

355
00:22:51,930 --> 00:22:53,970
that reads one of these registers,

356
00:22:54,090 --> 00:22:57,270
boom it'll take a trap, because it's illegal in user space,

357
00:22:57,450 --> 00:22:59,970
the virtual machine monitor will inspect the instruction

358
00:23:00,030 --> 00:23:04,290
and say aha, that's an instruction that's reading the sepc register,

359
00:23:04,680 --> 00:23:08,640
and so the virtual machine monitor will then emulate that instruction,

360
00:23:08,700 --> 00:23:13,770
it will read the sepc virtual sepc value out of this array,

361
00:23:14,640 --> 00:23:18,090
it'll copy that into the hardware,

362
00:23:18,510 --> 00:23:22,890
well, what really happened here is that the,

363
00:23:26,750 --> 00:23:32,820
um, I forget the name of the,

364
00:23:34,400 --> 00:23:36,590
there's some instruction whose name I forget,

365
00:23:36,590 --> 00:23:38,900
which is basically ssread,

366
00:23:39,380 --> 00:23:40,850
although that's not its name

367
00:23:40,850 --> 00:23:42,800
and you give it the name of an ordinary register

368
00:23:42,800 --> 00:23:45,650
and the name of a privilege register like sepc

369
00:23:46,070 --> 00:23:50,540
and so what the virtual, trap the virtual machine monitor will read that instruction,

370
00:23:51,040 --> 00:23:52,750
will see, oh, it's an ssread,

371
00:23:52,960 --> 00:24:00,190
virtual machine monitor will copy the virtual copy of sepc into a0 in the trapframe,

372
00:24:00,640 --> 00:24:02,560
after all when entering the VMM,

373
00:24:02,560 --> 00:24:05,570
that's gonna have created a trapframe,

374
00:24:05,570 --> 00:24:07,880
copies of all the guests registers,

375
00:24:07,880 --> 00:24:10,880
that will copy this sepc into a0 in the trapframe,

376
00:24:11,060 --> 00:24:14,300
then return from the trap using sret,

377
00:24:17,000 --> 00:24:20,960
you know, after copying the trapframe registers, the real registers

378
00:24:20,960 --> 00:24:25,750
and return from this trap to the instruction after the ssread

379
00:24:25,750 --> 00:24:26,950
and continue reading there

380
00:24:26,950 --> 00:24:33,170
with now as a0 set to the virtual sepc.

381
00:24:33,950 --> 00:24:37,100
Now the guest operating system will proceed,

382
00:24:37,580 --> 00:24:41,030
you know [] not realizing that something funny happened here,

383
00:24:41,990 --> 00:24:46,490
but it will have gotten a copy of the virtual sepc

384
00:24:46,490 --> 00:24:48,440
that the VMM was keeping on its behalf.

385
00:24:50,500 --> 00:24:53,470
So any questions about this, about this strategy?

386
00:24:58,400 --> 00:25:02,930
How does the VMM differentiate between different guests?

387
00:25:04,880 --> 00:25:08,750
It, it, it's basically the same way,

388
00:25:08,750 --> 00:25:13,130
it would keep one of these tables of virtual state per guest

389
00:25:13,520 --> 00:25:16,640
and it just knows just like xv6 knows which process is running

390
00:25:16,640 --> 00:25:19,490
as a variable, maybe a per core variable saying,

391
00:25:19,610 --> 00:25:21,290
here's the process I'm currently running,

392
00:25:22,260 --> 00:25:26,210
similarly, a VMM would have a per core variable

393
00:25:26,210 --> 00:25:31,490
that indicated which virtual machine it will be multiple of these state structures,

394
00:25:31,520 --> 00:25:33,980
VMM would know which virtual machine was executing

395
00:25:33,980 --> 00:25:37,580
and would look in the appropriate virtual machine state structure,

396
00:25:38,040 --> 00:25:42,960
to find st, sepc or whatever it is looking for.

397
00:25:43,480 --> 00:25:49,630
Can it run multiple, can it assign multiple cores to one of the guests?

398
00:25:49,810 --> 00:25:53,290
Yes, sophisticated virtual machine monitors can do that, yes.

399
00:25:56,870 --> 00:25:58,370
So if you, sorry, go ahead.

400
00:25:58,820 --> 00:26:01,820
Oh, sorry so the guest operating system,

401
00:26:02,150 --> 00:26:05,030
it will have like some registers,

402
00:26:05,390 --> 00:26:10,070
in the actual hardware will be the registers that the guest OS uses,

403
00:26:10,250 --> 00:26:15,830
so why do we not use the actual sepc, but use a virtual one?

404
00:26:23,810 --> 00:26:27,560
The reason is that the virtual machine monitor needs to use these registers,

405
00:26:27,560 --> 00:26:29,780
needs to use the real registers,

406
00:26:30,260 --> 00:26:32,270
so for example think about scause,

407
00:26:33,280 --> 00:26:35,920
when a trap occurs, what happens on,

408
00:26:35,950 --> 00:26:40,180
when you know when the guest operating system tries to do anything privilege,

409
00:26:40,180 --> 00:26:41,110
the trap will occur

410
00:26:41,140 --> 00:26:46,810
and the hardware sets the real hardware scause register to the cause of the trap,

411
00:26:47,510 --> 00:26:52,190
which is illegal instruction or unprivileged instruction whatever it is,

412
00:26:52,250 --> 00:26:57,130
but if the guest operating system,

413
00:26:57,340 --> 00:26:58,870
you know supposing the guest operating system

414
00:26:58,870 --> 00:27:03,100
has just taken a system call from a guest user process,

415
00:27:03,190 --> 00:27:06,850
the guest operating system needs to see an scause,

416
00:27:06,940 --> 00:27:12,760
that's whatever the right scause value is for system call, right,

417
00:27:12,790 --> 00:27:14,350
even though maybe the last thing that

418
00:27:14,350 --> 00:27:18,940
you know, so the the guest operating system is going to read scause,

419
00:27:21,280 --> 00:27:23,080
you know in the trap handler

420
00:27:23,080 --> 00:27:23,950
and what it thinks is

421
00:27:23,950 --> 00:27:28,990
the trap handler handling a system call from one of its guest processes,

422
00:27:29,050 --> 00:27:32,230
the scause, that the guest operating system needs to see

423
00:27:32,260 --> 00:27:34,840
is the value that says that means system call,

424
00:27:35,340 --> 00:27:37,290
but the scause is going to be,

425
00:27:37,290 --> 00:27:40,440
the real scause register is the scause,

426
00:27:40,440 --> 00:27:42,960
that means illegal instruction or unprivileged,

427
00:27:42,990 --> 00:27:46,500
or you know instructions violating the privilege rules,

428
00:27:46,620 --> 00:27:52,990
so, there are actually some times when you could,

429
00:27:53,680 --> 00:28:02,180
well, anyway, in general the VMM, the VMM is the one that needs to see the real,

430
00:28:02,210 --> 00:28:05,150
VMM needs to see different values in the real registers,

431
00:28:05,150 --> 00:28:10,010
then the operating system should see it in its version of the registers.

432
00:28:11,950 --> 00:28:12,730
Does that make sense?

433
00:28:12,730 --> 00:28:13,720
Thank you, yeah.

434
00:28:17,270 --> 00:28:19,970
Okay, so this is called,

435
00:28:19,970 --> 00:28:24,230
the name for this style of a virtual machine implementation

436
00:28:24,230 --> 00:28:26,000
in which the guest runs at user level

437
00:28:26,330 --> 00:28:29,990
and therefore traps whenever tries to do anything privileged

438
00:28:29,990 --> 00:28:32,570
and the VMM can emulate the privileged instruction

439
00:28:32,750 --> 00:28:35,660
and the name for that is TRAP-AND-EMULATEE.

440
00:28:38,290 --> 00:28:40,360
And, it's nice,

441
00:28:40,360 --> 00:28:43,270
because you can, you can build this for yourself,

442
00:28:43,270 --> 00:28:46,270
actually you can build this for yourselves entirely in software,

443
00:28:46,540 --> 00:28:53,230
and you could modify xv6 for example to be a virtual machine monitor on RISC-V,

444
00:28:53,860 --> 00:28:56,800
run over virtual machines, perhaps regular xv6,

445
00:28:57,820 --> 00:29:03,490
just by writing software or software does have to run in supervisor mode.

446
00:29:07,330 --> 00:29:10,630
The state here, all the registers that begin with s,

447
00:29:10,630 --> 00:29:17,260
all those supervisor control registers have to be part of this virtual state,

448
00:29:17,470 --> 00:29:21,040
there's also some other things that are not directly accessible,

449
00:29:22,020 --> 00:29:25,770
from those s registers that nevertheless need to be down in this state,

450
00:29:25,800 --> 00:29:27,090
one of them is the mode,

451
00:29:27,120 --> 00:29:28,920
the virtual machine monitor needs to know

452
00:29:28,920 --> 00:29:35,280
whether the virtual machines running in a guest user mode or guest operating system,

453
00:29:35,280 --> 00:29:41,370
because for example if if user code executes the privileged instruction

454
00:29:41,370 --> 00:29:42,960
like trying to read scause,

455
00:29:42,990 --> 00:29:45,090
sure that'll cause a trap into the VMM too,

456
00:29:45,180 --> 00:29:49,950
but in that case, the VMM should not just emulate the instruction in return,

457
00:29:50,130 --> 00:29:52,350
because that's not a legal instruction in user mode,

458
00:29:52,350 --> 00:29:53,880
so the VMM has to track

459
00:29:55,260 --> 00:29:59,220
whether the guest is in guest supervisor mode or guest user mode

460
00:29:59,220 --> 00:30:03,090
and so there's going to be a mode slot down here as well

461
00:30:03,180 --> 00:30:04,230
and the VMM will know,

462
00:30:04,230 --> 00:30:10,120
because when the guest operating system jumps into a user space,

463
00:30:10,120 --> 00:30:12,310
it'll execute the sret instruction,

464
00:30:12,310 --> 00:30:13,930
sret is a privilege instruction,

465
00:30:13,930 --> 00:30:15,670
so the VMM will actually get control there

466
00:30:15,670 --> 00:30:18,520
and will see, oh the guest is running an sret instruction,

467
00:30:18,910 --> 00:30:23,140
among other things I'm gonna change the virtual mode from supervisor to user.

468
00:30:25,490 --> 00:30:32,290
And another hidden piece of state is the hart number, that is the core number,

469
00:30:34,250 --> 00:30:37,490
you can't get that directly even with the privileged instruction,

470
00:30:37,910 --> 00:30:43,850
but the VMM manager needs to keep track of which hart it's emulating right now.

471
00:30:46,240 --> 00:30:54,450
Okay, the RISC-V it turns out different CPUs are different levels of difficulty,

472
00:30:55,770 --> 00:31:00,750
how hard it is to write a trap-and-emulate virtual machine on the RISC-V,

473
00:31:00,750 --> 00:31:03,060
particularly well suited to it,

474
00:31:03,060 --> 00:31:05,190
because the designers had that in mind

475
00:31:05,190 --> 00:31:07,020
when they were designing the instruction set

476
00:31:07,350 --> 00:31:12,000
and so they knew what the requirements of a trap-and-emulate virtual machine were,

477
00:31:12,180 --> 00:31:15,930
and for example, they've been quite diligent in making sure that

478
00:31:15,930 --> 00:31:20,250
every single privilege thing that supervisor code can do will cause a trap,

479
00:31:20,250 --> 00:31:21,660
if you try to do it in user mode,

480
00:31:21,690 --> 00:31:22,830
which is what you need,

481
00:31:23,040 --> 00:31:28,640
in order to make sure the virtual machine monitor sees a trap for every privileged instructions.

482
00:31:32,820 --> 00:31:34,140
I have a quick question,

483
00:31:34,170 --> 00:31:38,130
so does anything actually run in the guest OS itself

484
00:31:38,280 --> 00:31:40,860
or does it always trap into the virtual machine monitor?

485
00:31:41,400 --> 00:31:44,220
All ordinary instructions,

486
00:31:44,670 --> 00:31:47,460
like if you just have an add instruction,

487
00:31:47,460 --> 00:31:51,750
that you know adds, I don't know how to write this RISC-V assembly,

488
00:31:51,750 --> 00:31:54,450
but let's just say you add a0 to a1

489
00:31:54,450 --> 00:31:56,310
and you want to put the result in a2,

490
00:31:56,550 --> 00:32:01,170
that instruction just executes directly on the hardware at full hardware speed.

491
00:32:01,870 --> 00:32:05,980
If you make a function call, just an ordinary function call,

492
00:32:07,970 --> 00:32:09,200
up here in the guest world,

493
00:32:09,410 --> 00:32:14,050
that just executes without anything special, just a ordinary,

494
00:32:14,080 --> 00:32:17,530
you know all the instructions that are legal in user code,

495
00:32:18,240 --> 00:32:22,440
[] these instructions just execute directly at full speed

496
00:32:22,650 --> 00:32:24,960
when the guest operating system executes them.

497
00:32:25,890 --> 00:32:31,920
Okay, so is there a [semblance] of like user mode and kernel mode in the guest OS.

498
00:32:32,920 --> 00:32:34,600
Yes, the guest operating system is,

499
00:32:36,230 --> 00:32:40,010
well, the guest operating system is unchanged,

500
00:32:40,560 --> 00:32:44,400
so what we're running up here is exactly the Linux kernel,

501
00:32:44,400 --> 00:32:46,440
are exactly the xv6 kernel

502
00:32:46,560 --> 00:32:49,350
and of course xv6 all you know it knows the,

503
00:32:49,350 --> 00:32:54,140
xv6 kernel knows it's running in supervisor mode, right,

504
00:32:54,140 --> 00:32:56,750
just just is of course it's not here,

505
00:32:56,750 --> 00:32:58,550
but as far as the code is concerned,

506
00:32:58,640 --> 00:33:00,530
it's just definitely running in supervisor mode,

507
00:33:00,530 --> 00:33:03,920
it just does all kinds of privilege things and expects them to work,

508
00:33:04,400 --> 00:33:08,180
and then it knows when it executes sret to get into user space

509
00:33:08,180 --> 00:33:11,030
and knows aha, I'm gonna enter user space now.

510
00:33:13,000 --> 00:33:16,840
And you know the VMM sort of makes everything look like

511
00:33:16,960 --> 00:33:18,220
that's indeed what's happening,

512
00:33:19,870 --> 00:33:23,080
even though it's actually in in in in the real machine,

513
00:33:23,080 --> 00:33:26,170
it's in user mode, in both places,

514
00:33:26,410 --> 00:33:28,630
but this looks just like supervisor mode,

515
00:33:28,630 --> 00:33:29,710
this looks just like user mode.

516
00:33:35,100 --> 00:33:36,780
Okay.

517
00:33:38,550 --> 00:33:41,490
Okay, so when the, so for example when the guest

518
00:33:41,490 --> 00:33:44,130
when we execute sret to enter user space,

519
00:33:44,280 --> 00:33:51,690
the sret privileged luckily traps into the virtual machine monitor,

520
00:33:52,290 --> 00:33:55,500
virtual machine monitor changes the virtual mode to user,

521
00:33:55,980 --> 00:33:57,960
even though of course the real mode is still supervisor,

522
00:33:57,960 --> 00:33:59,250
because we're still going to be down here,

523
00:33:59,340 --> 00:34:01,350
change the virtual mode to the user,

524
00:34:03,810 --> 00:34:07,440
it just before it returns from the trap,

525
00:34:07,470 --> 00:34:14,700
the virtual machine monitor sets the real sepc to the virtual sepc,

526
00:34:14,760 --> 00:34:20,880
because in order that when the virtual machine monitor returns using its own sret,

527
00:34:21,030 --> 00:34:24,810
that the the program counter value,

528
00:34:24,810 --> 00:34:27,210
it returns to as a program value is

529
00:34:27,210 --> 00:34:30,810
the program counter that the guest operating system wanted to return to.

530
00:34:31,670 --> 00:34:33,770
So here's a case where very briefly

531
00:34:33,830 --> 00:34:37,880
the real sepc was set equal to the virtual sepc,

532
00:34:40,180 --> 00:34:41,920
and I'll talk about this in a bit,

533
00:34:41,920 --> 00:34:45,130
a virtual machine monitor also is going to be switching page tables,

534
00:34:45,130 --> 00:34:48,700
when it goes back into, into the virtual machine,

535
00:34:49,810 --> 00:34:52,540
when the guest user code wants to make it,

536
00:34:52,540 --> 00:34:56,290
then the guest user code for ordinary instructions execute machine,

537
00:34:56,410 --> 00:34:58,030
execute them directly at full speed,

538
00:34:58,570 --> 00:35:04,060
when the guest code wants to make a system call,

539
00:35:04,330 --> 00:35:06,430
executes the ecall instruction,

540
00:35:07,040 --> 00:35:08,750
that causes a trap,

541
00:35:08,780 --> 00:35:11,960
that trap goes to the virtual machine monitor in this scheme,

542
00:35:12,050 --> 00:35:13,730
the virtual machine monitor says aha,

543
00:35:13,730 --> 00:35:18,140
where in it [] the virtual mode, its virtual mode is user space,

544
00:35:18,560 --> 00:35:20,720
it looks at the instruction,

545
00:35:20,720 --> 00:35:23,240
the trap that faulted its ecall,

546
00:35:24,230 --> 00:35:25,940
and then the virtual machine monitor,

547
00:35:26,030 --> 00:35:30,500
sort of does all the virtual changes makes all the changes in the virtual state required

548
00:35:30,500 --> 00:35:34,910
to simulate a system call trap into the guest operating system,

549
00:35:35,030 --> 00:35:40,430
so it's going to set the virtual sepc to be whatever program counter,

550
00:35:40,760 --> 00:35:46,320
was the ecall instruction was that going to change the virtual mode back to supervisor,

551
00:35:46,470 --> 00:35:49,800
it's gonna set the virtual scause to be system call,

552
00:35:50,970 --> 00:35:56,580
it's gonna set the real epc to be equal to the virtual stvec,

553
00:35:57,020 --> 00:35:58,190
and then call sret,

554
00:35:58,460 --> 00:36:03,470
so that all jump into the guest operating systems trap handler,

555
00:36:03,920 --> 00:36:07,560
which is what or trampoline page or whatever it is

556
00:36:07,590 --> 00:36:10,440
which is what the virtual stvec was pointing to.

557
00:36:16,790 --> 00:36:17,420
Okay.

558
00:36:19,260 --> 00:36:23,730
We have two remaining pieces of business which are quite important,

559
00:36:23,730 --> 00:36:26,910
one is, what about page tables,

560
00:36:27,440 --> 00:36:30,800
and the other is, what about devices.

561
00:36:32,440 --> 00:36:39,960
So the page table sort of there's two pieces to that,

562
00:36:39,990 --> 00:36:41,550
one is that at various points,

563
00:36:41,550 --> 00:36:45,150
the guest operating system is going to modify the satp register

564
00:36:46,440 --> 00:36:49,530
and of course you know that they'll turn into a trap at the virtual machine monitor

565
00:36:49,530 --> 00:36:52,440
and the virtual machine monitor gets a chance to do something,

566
00:36:52,950 --> 00:36:55,740
but what we don't want the virtual machine monitor to do is

567
00:36:55,740 --> 00:36:58,890
simply let the guest set the real satp,

568
00:36:59,600 --> 00:37:03,800
and then execute after having changed the real satp,

569
00:37:03,800 --> 00:37:05,990
because that would let the guest get at any memory,

570
00:37:05,990 --> 00:37:09,950
not just the memory that the virtual machine monitor has allocated to it,

571
00:37:10,280 --> 00:37:14,300
so we cannot let the guest operating system simply set the satp,

572
00:37:15,520 --> 00:37:17,320
but we do need to do something to the satp,

573
00:37:17,320 --> 00:37:21,550
because we need to provide the illusion to the guest operating system,

574
00:37:21,550 --> 00:37:24,430
that yes, indeed, the page tables can change

575
00:37:24,430 --> 00:37:25,510
and more than an illusion,

576
00:37:25,510 --> 00:37:31,060
when the guest software runs load and store instructions or fetches instructions to execute,

577
00:37:31,240 --> 00:37:33,040
we need those to come from the right place,

578
00:37:33,040 --> 00:37:38,620
from the place that the guest operating system pointed its page table entries too,

579
00:37:39,940 --> 00:37:43,630
so what actually happens when the guest sets the satp,

580
00:37:47,560 --> 00:37:50,200
is, we you know we we can't,

581
00:37:50,200 --> 00:37:53,140
we can't directly use the guest operating systems page table,

582
00:37:53,170 --> 00:37:58,300
but the virtual machine monitor cooks up a new page table,

583
00:37:58,480 --> 00:38:04,960
that simulates the guest operating systems desired page table,

584
00:38:05,200 --> 00:38:11,230
so, the, so now the page translation situation is a little bit different,

585
00:38:11,770 --> 00:38:13,120
we have the guest,

586
00:38:14,380 --> 00:38:17,770
with the guest was trying to set the page table too,

587
00:38:17,770 --> 00:38:19,690
so this is the guest page table,

588
00:38:19,690 --> 00:38:21,550
of course is the kernel guest kernel,

589
00:38:22,270 --> 00:38:32,180
and that maps sort of guest virtual addresses to what I'll call guest physical addresses,

590
00:38:32,510 --> 00:38:34,430
of course the guest physical addresses are

591
00:38:35,630 --> 00:38:41,150
the virtual machine monitor given the guest 32 gigabytes or however much,

592
00:38:41,180 --> 00:38:47,260
simulate physical memory for its use,

593
00:38:47,530 --> 00:38:53,500
presumably starting at, telling the guest operating system that

594
00:38:53,500 --> 00:38:56,740
its physical addresses start at 0 and go up for 32 megabytes,

595
00:38:56,740 --> 00:39:00,040
but of course you know they don't in real life on the real hardware,

596
00:39:00,040 --> 00:39:03,700
there are just 32 gigabytes of pages somewhere not contiguous,

597
00:39:05,040 --> 00:39:08,220
can't use, can't directly use the guest's physical addresses,

598
00:39:08,220 --> 00:39:12,030
because they don't correspond to real physical addresses,

599
00:39:12,030 --> 00:39:23,710
so instead the VMM is going to maintain a map for each virtual machine,

600
00:39:23,740 --> 00:39:28,600
that maps guest physical addresses to real physical addresses,

601
00:39:28,600 --> 00:39:31,550
what I call host physical addresses,

602
00:39:32,090 --> 00:39:34,640
so this map is like a page table

603
00:39:34,820 --> 00:39:37,760
has an entry for every page,

604
00:39:37,760 --> 00:39:41,100
every physical page the guests thinks exists

605
00:39:41,340 --> 00:39:46,230
and indicates what real physical page that guest physical address refers to

606
00:39:46,230 --> 00:39:48,360
that the VMM is allocated for it,

607
00:39:48,630 --> 00:39:54,810
and then, when the guest writes a new page table to satp,

608
00:39:55,110 --> 00:40:02,620
in the trap handler, for that VMM creates what's called a shadow page table,

609
00:40:03,270 --> 00:40:09,860
which is going to be what the VMM puts in the real satp,

610
00:40:10,650 --> 00:40:16,560
and this shadow page table is constructed by the combination of these two page tables

611
00:40:16,560 --> 00:40:24,040
and so it maps guest virtual addresses to host physical addresses,

612
00:40:24,040 --> 00:40:27,310
then is constructed by taking every entry in the guest page table,

613
00:40:27,460 --> 00:40:31,120
looking at the guest desired guest physical address,

614
00:40:31,420 --> 00:40:35,950
using the VMM map to translate that guest physical address to a real host physical address

615
00:40:35,950 --> 00:40:40,600
and putting that virtual physical pair into the shadow page table

616
00:40:41,050 --> 00:40:46,870
and then the virtual machine monitor sets this to be in satp as the real page table,

617
00:40:46,870 --> 00:40:51,720
before returning back to the guest kernel,

618
00:40:53,840 --> 00:40:55,760
so the guest kernel thinks it's one page table,

619
00:40:55,760 --> 00:40:59,690
but actually the real hardware is using this shadow page table instead.

620
00:41:01,290 --> 00:41:02,520
And this way there's the,

621
00:41:02,940 --> 00:41:07,980
this is what prevents the guest from escaping from the memory it's allowed to use,

622
00:41:08,220 --> 00:41:13,800
the the the shadow page table can only contain host physical addresses,

623
00:41:14,320 --> 00:41:19,560
that the VMM had allocated for that guest,

624
00:41:19,740 --> 00:41:22,650
guest theres nothing that guest can put in the page table,

625
00:41:22,650 --> 00:41:25,470
asks for that allow it to access a page

626
00:41:25,470 --> 00:41:28,050
that wasn't allocated to it by the virtual machine monitor.

627
00:41:30,940 --> 00:41:33,400
That's a critical piece of those isolation story here,

628
00:41:34,090 --> 00:41:37,210
any questions about the paging setup for trap-and-emulate?

629
00:41:40,070 --> 00:41:43,040
Sorry, so if it's if the operating system,

630
00:41:43,040 --> 00:41:47,940
the guest just wants to make a new, a new process,

631
00:41:47,940 --> 00:41:49,830
a new page table for the process,

632
00:41:50,320 --> 00:41:52,420
what does it do, what happens?

633
00:41:52,630 --> 00:41:55,090
The guest, the guest does, does the usual

634
00:41:55,090 --> 00:41:58,120
just does exactly what Linux or xv6 does right now,

635
00:41:59,020 --> 00:42:01,840
formats up a page table entries to make a page table

636
00:42:01,930 --> 00:42:03,670
and then it executes the instruction

637
00:42:03,670 --> 00:42:06,700
to assign that address of the page table into satp,

638
00:42:06,790 --> 00:42:09,750
so that's what the guest operating system does.

639
00:42:11,300 --> 00:42:14,870
And when the, but it can't actually assign the satp,

640
00:42:14,870 --> 00:42:17,180
because that's a privileged operation,

641
00:42:17,210 --> 00:42:19,700
so there's a trap into the virtual machine monitor,

642
00:42:19,910 --> 00:42:22,760
the virtual machine monitor inspects the instruction in trap,

643
00:42:22,760 --> 00:42:27,140
sees oh gosh that guest is trying to assign to satp,

644
00:42:27,660 --> 00:42:32,190
and then the virtual machine monitor would create this new shadow page table

645
00:42:32,340 --> 00:42:37,320
from the combination of the page table the guest ask, was trying to set up,

646
00:42:38,000 --> 00:42:40,400
the virtual machine monitor looks at the page table

647
00:42:40,610 --> 00:42:43,490
all the PTEs in the page table the guests was trying to set up,

648
00:42:43,730 --> 00:42:48,410
it runs it translates the physical address in each guest page table entry

649
00:42:48,650 --> 00:42:55,070
through this map to get a real physical address or to cause a real fault,

650
00:42:55,400 --> 00:42:59,450
if the guest is trying to use a physical address that is not allowed to

651
00:42:59,870 --> 00:43:04,070
and then the virtual machine monitor installs this shadow page table at the real satp

652
00:43:04,430 --> 00:43:06,470
and returns back to the guest.

653
00:43:08,780 --> 00:43:10,400
Oh, okay, okay I see, I see,

654
00:43:10,490 --> 00:43:11,420
okay, thank you.

655
00:43:11,960 --> 00:43:12,470
Yes.

656
00:43:19,160 --> 00:43:19,730
Okay.

657
00:43:23,070 --> 00:43:27,330
Okay, so this this shadow page table stuff is certainly one of the tricky aspects

658
00:43:31,510 --> 00:43:33,970
implementing a virtual machine monitor.

659
00:43:35,250 --> 00:43:37,710
There's actually another thing that,

660
00:43:37,710 --> 00:43:42,150
there's another way in which the guest operating system can interact with the page table,

661
00:43:42,150 --> 00:43:43,560
the guest operating system may actually,

662
00:43:43,770 --> 00:43:49,350
you know xv6 sometimes directly reads and writes page table entries in its page table,

663
00:43:50,200 --> 00:43:55,330
and you know so xv6 could can modify page table entry

664
00:43:55,330 --> 00:43:59,200
or read the dirty bits, for example in a page table entry,

665
00:43:59,230 --> 00:44:05,950
you know on the RISC-V, if, if a software modifies the page table entry,

666
00:44:06,370 --> 00:44:07,810
if you read the RISC-V spec,

667
00:44:07,960 --> 00:44:11,890
RISC-V is not required to do anything at that point,

668
00:44:11,890 --> 00:44:13,750
so if you modify a page table entry,

669
00:44:14,170 --> 00:44:17,800
the RISC-V microprocessor does not promise

670
00:44:17,800 --> 00:44:21,280
to immediately observe that modification to a page table entry,

671
00:44:21,280 --> 00:44:23,260
it may completely ignore it for the time being,

672
00:44:23,410 --> 00:44:25,480
instead what the manual says is,

673
00:44:25,600 --> 00:44:27,730
that if if you modify page table entries

674
00:44:27,730 --> 00:44:31,450
and you actually want the hardware MMU to see them,

675
00:44:31,570 --> 00:44:40,620
you have to execute, the sfence.vma instruction

676
00:44:40,770 --> 00:44:43,470
and the specs has only this instruction

677
00:44:43,470 --> 00:44:47,220
that causes the hardware to pay attention to your page table modifications.

678
00:44:47,370 --> 00:44:49,410
And so if you're building a virtual machine monitor,

679
00:44:49,980 --> 00:44:51,720
the virtual machine monitor on RISC-V

680
00:44:51,720 --> 00:44:57,430
can completely ignore the guest modifications to page table entries,

681
00:44:57,490 --> 00:45:00,490
but since you know the guest is going to issue,

682
00:45:00,670 --> 00:45:05,590
is going to execute an sfence.vma instruction after modifying page table entries,

683
00:45:05,590 --> 00:45:07,270
and this is a privileged instruction,

684
00:45:07,300 --> 00:45:09,310
you can tell because it starts with s,

685
00:45:09,310 --> 00:45:11,440
that's going to trap into the virtual machine monitor,

686
00:45:11,890 --> 00:45:18,560
virtual machine monitor is gonna [] knows that an sfence was executed,

687
00:45:18,560 --> 00:45:19,520
it looks the instruction,

688
00:45:19,580 --> 00:45:26,520
it's gonna re-scan the guest, the guest version of the current page table, current page table

689
00:45:26,700 --> 00:45:29,130
and look for page table entries that have changed

690
00:45:29,190 --> 00:45:33,990
and reflect those changes if they're legal into the shadow page table,

691
00:45:35,840 --> 00:45:36,710
reset the,

692
00:45:36,890 --> 00:45:39,170
actually got a real sfence.vma

693
00:45:39,170 --> 00:45:42,320
to get the real hardware to pay attention to the shadow page table,

694
00:45:42,320 --> 00:45:44,990
then return to the guest operating system.

695
00:45:45,410 --> 00:45:46,430
So this means that,

696
00:45:46,460 --> 00:45:51,470
there's only like the MMU actually just uses one page table, right,

697
00:45:51,470 --> 00:45:52,280
which is the shadow,

698
00:45:52,280 --> 00:45:55,280
it's not like it's using the EPT or anything like that.

699
00:45:55,730 --> 00:45:56,810
There's no EPT yet.

700
00:45:56,840 --> 00:46:01,340
Okay, so the guest just thinks it has a page table like the gva to gpa,

701
00:46:01,340 --> 00:46:05,120
but that's not actually doing any translation in the VMM,

702
00:46:05,480 --> 00:46:09,530
yeah, makes its own page table based on both of them combined.

703
00:46:09,770 --> 00:46:11,150
That's right, that's right,

704
00:46:11,150 --> 00:46:13,850
just to be clear the EPT is part of a different,

705
00:46:13,970 --> 00:46:17,870
quite different virtual machine implementation,

706
00:46:18,420 --> 00:46:21,120
virtual machine design that requires hardware support,

707
00:46:21,390 --> 00:46:22,890
assuming this is a story about

708
00:46:22,890 --> 00:46:25,920
how to build a virtual machine with no special hardware support

709
00:46:25,920 --> 00:46:29,330
other than trapping on privileged instructions.

710
00:46:31,680 --> 00:46:35,280
Does this mess up direct mapping in anyway?

711
00:46:37,040 --> 00:46:38,990
Well, there won't be a direct map,

712
00:46:39,780 --> 00:46:43,260
this will allow the guest,

713
00:46:43,290 --> 00:46:49,790
I mean, this will cause the guest kernel to run correctly,

714
00:46:50,720 --> 00:46:53,300
with what the guest kernel thinks is the direct mapping,

715
00:46:55,680 --> 00:46:58,620
but it's a direct, a direct mapping in the virtual world,

716
00:46:58,620 --> 00:47:02,290
but it's not a direct mapping on the, on the real machine.

717
00:47:05,130 --> 00:47:05,820
But it doesn't matter,

718
00:47:05,820 --> 00:47:12,800
because, because we're tricking, yeah we're tricking the guests,

719
00:47:13,160 --> 00:47:14,930
everything looks just like it was a direct mapping.

720
00:47:17,780 --> 00:47:18,920
Oh, one more question,

721
00:47:19,220 --> 00:47:20,990
you may be addressing this later,

722
00:47:20,990 --> 00:47:24,950
but I wonder like when we discussed the trap mechanism earlier

723
00:47:24,950 --> 00:47:29,220
and this must we mentioned the high performance cost to trapping,

724
00:47:29,670 --> 00:47:35,070
but this sounds like there's way more of performance [] when we use the VMM.

725
00:47:35,710 --> 00:47:38,410
Yes, yes, there's all these instructions,

726
00:47:38,410 --> 00:47:44,200
you know if you if your operating system may excuse a lot of privilege instructions, which may

727
00:47:44,410 --> 00:47:46,060
and you spend a lot of time in the operating system,

728
00:47:46,060 --> 00:47:48,040
then the traps you may have quite a few traps,

729
00:47:48,580 --> 00:47:50,500
that may cost you quite a bit of performance

730
00:47:50,500 --> 00:47:51,970
and that's what motivates

731
00:47:52,090 --> 00:47:56,020
and a little bit we'll talk about modern hardware support virtual machines,

732
00:47:56,020 --> 00:47:57,700
which is what today's paper was using

733
00:47:58,030 --> 00:48:02,050
and there high cost of the traps is a lot of the motivation

734
00:48:02,200 --> 00:48:07,930
for why Intel felt compelled to and AMD felt compelled to add hardware support

735
00:48:07,930 --> 00:48:09,490
for a much more efficient,

736
00:48:10,220 --> 00:48:14,660
or for virtual machine scheme that had much many fewer traps.

737
00:48:16,260 --> 00:48:18,390
Yes, that's quite important,

738
00:48:18,510 --> 00:48:19,680
but this actually ran,

739
00:48:19,680 --> 00:48:22,440
I mean for many years, this is what people did for virtual machines

740
00:48:22,440 --> 00:48:24,870
and it was very successful, and it works

741
00:48:24,870 --> 00:48:26,190
and it's so much slower,

742
00:48:27,420 --> 00:48:29,400
but not so much slower that people didn't like it,

743
00:48:29,400 --> 00:48:30,210
people like it a lot.

744
00:48:34,210 --> 00:48:39,340
Okay, any more questions about the trap-and-emulate strategy for page tables?

745
00:48:44,140 --> 00:48:48,310
Okay, let me, final a piece of the trap-and-emulate story,

746
00:48:51,220 --> 00:48:52,900
let me talk about devices.

747
00:48:56,240 --> 00:48:57,440
So here I'm talking about,

748
00:48:57,470 --> 00:49:03,740
you know ordinary operating system expects to be able to get a disk drive to storage file system on

749
00:49:03,740 --> 00:49:06,050
or maybe network interface card,

750
00:49:06,050 --> 00:49:08,450
and maybe it's in xv6 UART,

751
00:49:08,480 --> 00:49:10,700
so we can talk to its console,

752
00:49:11,090 --> 00:49:16,190
who knows, the sound card, graphics adapter, mouse, keyboard, all kinds of stuff,

753
00:49:16,310 --> 00:49:18,620
so the operating system, we need to,

754
00:49:18,620 --> 00:49:24,470
a virtual machine scheme has to have some provision to allow allow guests,

755
00:49:24,860 --> 00:49:29,300
to at least trick them into thinking that all these devices that they need really exist.

756
00:49:30,200 --> 00:49:35,960
And there's three main strategies that people use.

757
00:49:36,980 --> 00:49:42,290
One is just pick some very commonly used device in the classic that you need,

758
00:49:42,290 --> 00:49:46,010
say a disk drive and just do emulation,

759
00:49:47,070 --> 00:49:50,520
that is, you're not actually having a real device,

760
00:49:51,030 --> 00:49:57,060
that VMM just makes it look like this particular kind of disk drive exists

761
00:49:57,060 --> 00:49:58,710
and that the guest is talking to it.

762
00:49:59,860 --> 00:50:03,070
And the way you would drive this emulation,

763
00:50:03,130 --> 00:50:06,520
typically the guest operating system is gonna

764
00:50:07,450 --> 00:50:11,470
try to talk to the device through memory mapped control registers,

765
00:50:11,500 --> 00:50:15,460
so this is how xv6 talks to, it's UA- UART

766
00:50:15,490 --> 00:50:21,820
you know the serial port, the console device,

767
00:50:22,710 --> 00:50:25,110
that you type characters to and that displays characters to you,

768
00:50:25,320 --> 00:50:28,890
xv6 talking to control registers that are mapped,

769
00:50:28,890 --> 00:50:34,200
that assumes the hardware has mapped in a known address

770
00:50:34,590 --> 00:50:36,720
in the address in the kernel's address space,

771
00:50:37,440 --> 00:50:39,840
and so the way you emulate that in a virtual machine monitor is

772
00:50:40,650 --> 00:50:43,920
actually not map those pages in the guest,

773
00:50:43,920 --> 00:50:47,490
instead you would allow or have those pages be invalid

774
00:50:47,550 --> 00:50:52,230
so that every time the guest operating system tried to use the UART hardware,

775
00:50:52,230 --> 00:50:53,910
whatever device hardware,

776
00:50:54,090 --> 00:50:56,310
the VMM virtual machine monitor will get a trap

777
00:50:56,490 --> 00:50:58,740
and the virtual machine monitor will going to look at the instructions,

778
00:50:58,740 --> 00:51:01,440
oh, it's trying to send a character on the UART

779
00:51:01,470 --> 00:51:04,500
or read from the disk or who knows what,

780
00:51:05,390 --> 00:51:09,020
and the virtual machine monitor would have some simulation of a disk,

781
00:51:09,020 --> 00:51:12,200
a simulation of a serial device,

782
00:51:12,590 --> 00:51:16,940
and you know sort of invoke its simulation

783
00:51:16,940 --> 00:51:20,180
to figure out how to respond to the guest instruction

784
00:51:20,180 --> 00:51:22,910
and then allow the guest to resume.

785
00:51:24,460 --> 00:51:25,270
And so this is basically

786
00:51:25,270 --> 00:51:31,630
how QEMU implements the UART console device, that xv6 uses,

787
00:51:31,780 --> 00:51:35,170
it just has, there's actually no physical serial port in side,

788
00:51:35,170 --> 00:51:39,910
but QEMU emulates one to keep xv6 happy.

789
00:51:40,360 --> 00:51:41,740
And so this is a common strategy,

790
00:51:42,400 --> 00:51:45,220
it's can be very low performance though,

791
00:51:45,220 --> 00:51:47,950
because it involves a trap and the operating system,

792
00:51:47,950 --> 00:51:50,770
for every interaction between the guest and the device hardware,

793
00:51:51,770 --> 00:51:55,190
but for low speed stuff, it's works pretty well.

794
00:51:55,850 --> 00:51:58,400
The second strategy that's often used,

795
00:52:00,100 --> 00:52:01,540
and actually, but if your,

796
00:52:02,350 --> 00:52:06,400
if your goal is to provide is to be able to boot operating systems,

797
00:52:06,400 --> 00:52:09,880
that have no idea they're running on a virtual machine,

798
00:52:10,090 --> 00:52:12,040
this is pretty much the way you have to go,

799
00:52:14,340 --> 00:52:15,510
there's really no other choice.

800
00:52:15,510 --> 00:52:17,610
But in the modern world,

801
00:52:17,610 --> 00:52:21,690
you know, it's often the case that the operating systems are aware,

802
00:52:21,690 --> 00:52:23,670
that they're actually running at a low level,

803
00:52:23,670 --> 00:52:26,580
at least aware that they're running on top of a virtual machine,

804
00:52:26,940 --> 00:52:31,410
and so a different strategy is to provide virtual devices,

805
00:52:31,410 --> 00:52:35,180
that is not trying to emulate a real device,

806
00:52:35,240 --> 00:52:43,270
but cook up a device interface that is particularly efficient for the,

807
00:52:43,990 --> 00:52:48,580
provides efficient ways for the device driver in the guest,

808
00:52:48,640 --> 00:52:53,200
to be able to talk to a device support inside the virtual machine monitor,

809
00:52:53,590 --> 00:52:57,310
and so you might not have memory map control registers

810
00:52:57,310 --> 00:53:05,140
and said you might have sort of a queue of command structures in memory,

811
00:53:05,140 --> 00:53:11,800
in which the guest operating system would write its commands to the, to the device,

812
00:53:12,670 --> 00:53:15,460
and in fact xv6 also uses one of these,

813
00:53:15,460 --> 00:53:23,750
if you look at the xv6 VIRTIO_DISK, virtio_disk.c,

814
00:53:23,870 --> 00:53:29,750
you'll see the guest and the device driver

815
00:53:29,750 --> 00:53:34,400
intended to talk to a disk virtual device that's implemented by QEMU,

816
00:53:34,730 --> 00:53:40,040
and it uses either little or almost not,

817
00:53:40,070 --> 00:53:44,510
either little or no memory mapped control registers

818
00:53:44,510 --> 00:53:46,400
and so it doesn't really rely on traps,

819
00:53:46,520 --> 00:53:51,740
and instead it formats up this sort of queue of commands memory,

820
00:53:51,860 --> 00:53:52,820
as I mentioned,

821
00:53:53,980 --> 00:53:56,410
and then QEMU looks at these commands in memory

822
00:53:56,410 --> 00:53:58,810
and applies them not to a real disk,

823
00:53:58,810 --> 00:54:03,160
but to a file like for us fs.img,

824
00:54:03,460 --> 00:54:06,580
QEMU applies commands to fs.img

825
00:54:06,580 --> 00:54:10,490
instead of, instead of using a real piece of device hardware,

826
00:54:11,160 --> 00:54:12,540
just another strategy.

827
00:54:13,020 --> 00:54:16,380
And the third strategy that people use,

828
00:54:16,440 --> 00:54:18,750
so this is higher performance and straight emulation,

829
00:54:18,750 --> 00:54:22,230
because you can design the interface,

830
00:54:22,260 --> 00:54:23,970
so it doesn't require a lot of traps,

831
00:54:24,150 --> 00:54:31,110
a final strategy people use is pass through a real device,

832
00:54:33,910 --> 00:54:37,390
and that sort of classic situation for this network interface controllers,

833
00:54:37,390 --> 00:54:40,270
you know that provide access to the network,

834
00:54:40,510 --> 00:54:47,050
and modern network devices actually have hardware support

835
00:54:47,050 --> 00:54:50,800
for talking to multiple guest operating systems

836
00:54:50,800 --> 00:54:52,480
running under a virtual machine monitor,

837
00:54:52,570 --> 00:54:54,340
so you can configure a modern NIC

838
00:54:54,400 --> 00:55:00,150
to actually act as if it's multiple independent, apparently independent NICs,

839
00:55:00,150 --> 00:55:02,460
one for each guest operating system,

840
00:55:02,610 --> 00:55:05,850
and then the guest operating system can talk directly,

841
00:55:06,240 --> 00:55:08,460
can be configured by the virtual machine monitors,

842
00:55:08,460 --> 00:55:15,150
so that is allowed to talk directly to its sort of slice of the network interface card hardware,

843
00:55:16,080 --> 00:55:17,370
with very high efficiency,

844
00:55:17,840 --> 00:55:21,950
so this is the modern high performance way.

845
00:55:22,650 --> 00:55:24,750
The guest operating system probably,

846
00:55:25,440 --> 00:55:27,990
in theory I think you could design,

847
00:55:28,020 --> 00:55:29,790
you could set this up to the guest operating system

848
00:55:29,790 --> 00:55:32,750
wasn't really aware did anything odd was going on,

849
00:55:32,750 --> 00:55:36,350
but I think in practice, the guest operating system device drivers kind of know,

850
00:55:38,340 --> 00:55:41,340
they're talking to one of these special network interface cards.

851
00:55:42,690 --> 00:55:47,040
Alright, so, so these are the options for devices,

852
00:55:47,880 --> 00:55:53,700
in fact I I I believe that most of the difficulty

853
00:55:53,700 --> 00:55:59,420
in implementing virtual machine monitor today,

854
00:55:59,780 --> 00:56:05,720
comes in the form of trying to cook up device emulation and device drivers

855
00:56:05,720 --> 00:56:09,500
that are a sufficiently good,

856
00:56:09,500 --> 00:56:14,540
that they'll actually work correctly with a real guest operating systems,

857
00:56:14,600 --> 00:56:16,610
this is where probably the majority of the work is,

858
00:56:16,640 --> 00:56:20,880
particularly if you need to use this emulation strategy.

859
00:56:23,540 --> 00:56:24,830
Any questions about devices?

860
00:56:32,700 --> 00:56:36,930
Okay, what what exactly is I I didn't quite get the difference

861
00:56:36,930 --> 00:56:39,360
between the virtual and emulation,

862
00:56:39,450 --> 00:56:41,730
because they don't like they.

863
00:56:41,730 --> 00:56:43,500
They're similar, they're similar,

864
00:56:43,620 --> 00:56:46,530
the here's a way to think about it,

865
00:56:46,740 --> 00:56:50,700
if you're booting an operating system that has no idea about virtual machine,

866
00:56:52,100 --> 00:56:54,860
it probably has a lot of disk drivers in it,

867
00:56:54,860 --> 00:56:56,270
but they're all for real hardware,

868
00:56:56,300 --> 00:56:58,760
that you can go out physical chunks of hardware

869
00:56:58,760 --> 00:56:59,720
that you can go out and buy,

870
00:56:59,870 --> 00:57:00,350
and that means that

871
00:57:00,350 --> 00:57:03,020
if you want to boot that kind of operating system on your virtual machine,

872
00:57:03,200 --> 00:57:08,180
you need to have a exact emulation,

873
00:57:08,180 --> 00:57:10,610
you need to choose one of those real pieces of hardware

874
00:57:10,610 --> 00:57:14,750
and have a precise super accurate emulation of that hardware,

875
00:57:15,340 --> 00:57:17,860
so at the, and then,

876
00:57:18,450 --> 00:57:21,060
I mean people totally do that, so that works,

877
00:57:21,560 --> 00:57:28,100
however, and that would be fine, except most of these,

878
00:57:28,190 --> 00:57:32,810
for real hardware that the device interfaces were not design,

879
00:57:32,810 --> 00:57:34,910
the hardware interfaces were not designed

880
00:57:35,240 --> 00:57:38,630
to be efficient with a trap-and-emulate virtual machine monitor,

881
00:57:38,750 --> 00:57:41,000
and so it's very often the case that,

882
00:57:41,210 --> 00:57:46,280
the real devices requires you to read and write its control registers a lot,

883
00:57:46,900 --> 00:57:49,330
but the virtual machine monitor has to get control

884
00:57:49,330 --> 00:57:51,760
for every write of a device control register,

885
00:57:52,210 --> 00:57:53,830
because it needs to emulate

886
00:57:54,490 --> 00:57:58,120
and that means that every write of a device control register

887
00:57:58,120 --> 00:58:00,250
results in a trap into the virtual machine monitor,

888
00:58:00,250 --> 00:58:02,410
which costs maybe hundreds of cycles,

889
00:58:02,860 --> 00:58:06,160
that means this is slow, this is inefficient

890
00:58:06,340 --> 00:58:08,530
and so the difference here is that,

891
00:58:08,530 --> 00:58:12,190
instead of slavishly mimicking a real device,

892
00:58:12,220 --> 00:58:19,030
some designers come up with a device interface,

893
00:58:19,060 --> 00:58:21,580
that's not implemented by any real piece of hardware,

894
00:58:22,180 --> 00:58:24,100
but only implemented by a virtual machine monitor,

895
00:58:24,100 --> 00:58:28,000
and it just happens to be designed in a way that doesn't require a lot of traps,

896
00:58:29,160 --> 00:58:34,230
instead of chatting with control registers and expecting the device to respond immediately,

897
00:58:34,410 --> 00:58:35,700
which really requires a trap,

898
00:58:36,000 --> 00:58:41,220
instead the device driver and that sort of virtual hardware are decoupled

899
00:58:41,430 --> 00:58:44,940
and don't ever require sort of immediate interaction.

900
00:58:45,400 --> 00:58:49,960
Still, in that case, the guest needs its own like a new driver,

901
00:58:50,050 --> 00:58:52,390
so it's just like the guests will have a driver

902
00:58:52,390 --> 00:58:55,210
for this model of the disk and that model of the disk

903
00:58:55,210 --> 00:58:57,490
and also have a driver for a virtual disk.

904
00:58:57,550 --> 00:58:59,800
Right, and so the xv6 does,

905
00:58:59,800 --> 00:59:02,770
so so then, so if the functionality level,

906
00:59:02,800 --> 00:59:06,580
you play this game, maybe you can boot any operating system,

907
00:59:07,320 --> 00:59:08,490
whereas, if you play this game,

908
00:59:08,490 --> 00:59:13,230
you can only boot operating systems that have been taught about your virtual devices,

909
00:59:13,230 --> 00:59:15,270
if you want to use the virtual devices,

910
00:59:15,930 --> 00:59:17,640
turns out this is actually a standard,

911
00:59:18,120 --> 00:59:23,390
that's provided by multiple different virtual machine schemes,

912
00:59:23,420 --> 00:59:24,080
so with this,

913
00:59:24,560 --> 00:59:27,350
except for the fact that we never tested it on anything other than QEMU,

914
00:59:27,530 --> 00:59:30,680
this disk driver in xv6 might work,

915
00:59:31,250 --> 00:59:33,620
probably be modified to work on other virtual machines.

916
00:59:34,540 --> 00:59:37,540
So if xv6 was compiled for that board,

917
00:59:37,540 --> 00:59:40,300
that you showed some time in the beginning,

918
00:59:40,570 --> 00:59:42,760
in that case, you would have to have a different disk driver

919
00:59:42,760 --> 00:59:44,710
based on what disk that was running, right.

920
00:59:45,040 --> 00:59:47,560
Yeah, yeah, I think you may be able to buy disk interface,

921
00:59:47,950 --> 00:59:51,700
real hardware disk interfaces that now support this interface,

922
00:59:51,700 --> 00:59:54,820
but but most disk, most disk drive don't

923
00:59:54,820 --> 00:59:57,160
and we would have to implement a new as you said,

924
00:59:57,190 --> 01:00:00,790
we have to implement a new disk driver for real piece of hardware.

925
01:00:03,390 --> 01:00:03,930
Yes.

926
01:00:06,680 --> 01:00:07,370
Okay.

927
01:00:08,080 --> 01:00:09,550
Any other questions about devices?

928
01:00:14,370 --> 01:00:23,180
Alright, next topic I wanna talk about hardware support for virtual machines,

929
01:00:27,750 --> 01:00:32,770
and in particular Intel's VT-x scheme,

930
01:00:33,010 --> 01:00:39,830
so what's motivating what motivated Intel and other hardware providers

931
01:00:39,830 --> 01:00:44,510
to add direct hardware support for virtual machines is

932
01:00:44,570 --> 01:00:47,390
a, the fact that virtual machine uses pervasive,

933
01:00:47,540 --> 01:00:50,480
so a lot of their customers were running a lot of virtual machines,

934
01:00:50,660 --> 01:00:53,630
and b, the fact that trap-and-emulate as I just described it,

935
01:00:54,080 --> 01:00:56,510
often involves a lot of expensive traps,

936
01:00:56,510 --> 01:00:58,130
so it's not particularly efficient,

937
01:01:00,280 --> 01:01:03,910
and a third sort of less interesting perhaps motivation was that,

938
01:01:04,180 --> 01:01:08,860
although the RISC-V is pretty well suited to trap-and-emulate virtualization,

939
01:01:08,950 --> 01:01:13,360
the x86 Intel's microprocessor has a number of detailed features,

940
01:01:13,360 --> 01:01:18,340
which make it actually very difficult possible very difficult to virtualize,

941
01:01:18,520 --> 01:01:21,730
and so Intel is also motivated to try to fix that,

942
01:01:21,730 --> 01:01:25,630
because so many of his customers wanted to run virtual machine monitors.

943
01:01:26,920 --> 01:01:29,370
Alright, okay, so this hardware is,

944
01:01:29,370 --> 01:01:32,970
the main point is to make it be,

945
01:01:33,000 --> 01:01:36,510
allow you to build faster virtual machines using hardware support,

946
01:01:36,630 --> 01:01:42,150
and then another motivation was to make it easier to implement virtual machine,

947
01:01:42,920 --> 01:01:46,700
and this support has been around for maybe ten years

948
01:01:46,700 --> 01:01:50,600
and is now very, very widely used to build virtual machines.

949
01:01:50,930 --> 01:01:56,630
Okay, so the basic strategy is that

950
01:01:56,660 --> 01:02:00,230
all that virtual state that in my trap-and-emulate scheme,

951
01:02:00,500 --> 01:02:05,640
all the virtual state that was being maintained by the virtual machine monitor just in software,

952
01:02:05,820 --> 01:02:11,640
all that virtual state is going to be going to be implemented in the hardware,

953
01:02:11,670 --> 01:02:13,680
in these hardware supported schemes,

954
01:02:14,850 --> 01:02:20,160
and that will allow guest software to execute privileged instructions,

955
01:02:20,490 --> 01:02:27,980
affecting these virtual hardware supported registers directly rather than trapping,

956
01:02:28,340 --> 01:02:32,870
so the goal is now that guest will be able to execute privileged instructions, but not trap.

957
01:02:33,420 --> 01:02:35,540
And, the reason you know,

958
01:02:36,200 --> 01:02:37,310
so that works is that,

959
01:02:37,340 --> 01:02:40,460
again, we have a virtual machine monitor

960
01:02:41,550 --> 01:02:47,170
and a guest operating system in user level,

961
01:02:47,590 --> 01:02:52,480
and the hardware, now we know that in the hardware,

962
01:02:52,480 --> 01:02:59,680
we have you know a stvec and all those you know hardware registers,

963
01:03:06,620 --> 01:03:07,640
and there's all the,

964
01:03:07,670 --> 01:03:11,060
when we're running in the virtual new schemes, hardware support schemes,

965
01:03:11,060 --> 01:03:12,230
we're running the virtual machine monitor,

966
01:03:12,230 --> 01:03:14,780
we just use the real versions of these registers,

967
01:03:14,780 --> 01:03:16,160
but the hardware,

968
01:03:16,190 --> 01:03:18,950
when the virtual machine monitor tells the hardware,

969
01:03:18,950 --> 01:03:21,320
look please switch into guest mode,

970
01:03:21,770 --> 01:03:25,820
the hardware has a complete separate set of registers,

971
01:03:27,300 --> 01:03:30,480
dedicated for use by in guest mode.

972
01:03:31,360 --> 01:03:34,180
So the guest mode can read and write these registers,

973
01:03:34,180 --> 01:03:34,750
but it's not,

974
01:03:34,780 --> 01:03:39,850
it's reading it's reading writing its hardware copies of its versions of these registers

975
01:03:39,850 --> 01:03:41,350
rather than the real registers

976
01:03:41,350 --> 01:03:45,430
and the hardware has you know has some kind of extra checks,

977
01:03:45,430 --> 01:03:49,330
it makes on the the guest operating system can do

978
01:03:49,330 --> 01:03:53,170
to make sure that it can't abuse these registers to escape from the virtual machine.

979
01:03:54,240 --> 01:03:57,780
This is the basic, this is most of the basic strategy

980
01:03:58,290 --> 01:04:02,520
and in the terminology of these hardware supported virtual machine schemes,

981
01:04:02,640 --> 01:04:04,440
the name is Intel [one],

982
01:04:04,830 --> 01:04:08,430
the name for guest mode is non-root,

983
01:04:10,720 --> 01:04:17,960
and the name for host mode, we're using real registers is root,

984
01:04:17,960 --> 01:04:23,390
and so there's a set of non-root virtual registers for the virtual machine to use

985
01:04:23,390 --> 01:04:26,240
and there's a set of registers that are used when we are in root mode.

986
01:04:32,150 --> 01:04:36,520
So now when we're running in the guest kernel,

987
01:04:38,030 --> 01:04:44,220
it can execute any privileged instruction without trapping,

988
01:04:44,520 --> 01:04:46,920
so when wants to read or write the stvec,

989
01:04:46,950 --> 01:04:52,950
the hardware just that's read or write the non-root copy of the hardware stvec register,

990
01:04:53,490 --> 01:04:58,980
and so all this stuff proceeds at full speed without having to trap into VMM,

991
01:04:58,980 --> 01:05:03,630
so it's much faster for code that was incurring a lot of traps.

992
01:05:07,270 --> 01:05:08,800
The, you still have to,

993
01:05:08,800 --> 01:05:12,100
there's a whole bunch of stuff having involved in configuring this,

994
01:05:12,100 --> 01:05:15,670
when the virtual machine monitor wants to create a new virtual machine,

995
01:05:15,670 --> 01:05:17,320
actually has to tell the hardware,

996
01:05:17,770 --> 01:05:24,350
and so there is a down in the virtual machine monitors memory,

997
01:05:24,350 --> 01:05:27,960
there's this structure that the virtual machine monitor

998
01:05:27,960 --> 01:05:31,080
and the VT-x hardware used to communicate

999
01:05:31,080 --> 01:05:36,450
just called VMCS VM control something structure,

1000
01:05:37,560 --> 01:05:40,320
and when the virtual machine monitor wants to create a new virtual machine,

1001
01:05:40,320 --> 01:05:42,300
it creates one of these in memory

1002
01:05:42,300 --> 01:05:44,370
and fills in a bunch of configuration flags

1003
01:05:44,370 --> 01:05:47,850
and also initial values for all these registers

1004
01:05:47,850 --> 01:05:51,800
and then tells the VT-x hardware,

1005
01:05:51,800 --> 01:05:54,140
look I want to start running a new virtual machine,

1006
01:05:54,140 --> 01:05:55,730
and here's the initial state,

1007
01:05:56,150 --> 01:06:00,620
and so these new instructions which the paper mentions,

1008
01:06:00,620 --> 01:06:05,940
there's VMLAUNCH just like a new new machine instruction,

1009
01:06:05,940 --> 01:06:10,110
which you tell it the address of this and it starts running,

1010
01:06:10,870 --> 01:06:13,000
you know starting with these registers,

1011
01:06:13,000 --> 01:06:15,490
like starts running the guest kernel,

1012
01:06:15,850 --> 01:06:18,340
and there's also this VMRESUME,

1013
01:06:19,380 --> 01:06:24,190
because sometimes, break out of the kernel back, trap out of kernels at VMM,

1014
01:06:24,190 --> 01:06:25,120
and you need to resume it

1015
01:06:25,450 --> 01:06:28,840
and then code up here can run a new instruction called VMCALL,

1016
01:06:28,840 --> 01:06:34,430
which sort of intentionally exits from non-root mode,

1017
01:06:34,460 --> 01:06:37,670
and basically traps into the virtual machine monitor in root mode.

1018
01:06:39,820 --> 01:06:41,560
Right, when the virtual machine monitor

1019
01:06:42,160 --> 01:06:45,490
execute one of these instructions to jump into a guest,

1020
01:06:45,610 --> 01:06:48,520
the ways that it may come back,

1021
01:06:49,420 --> 01:06:52,990
guest now can execute ordinary privileged instructions without trapping,

1022
01:06:53,080 --> 01:06:54,460
but there's a bunch of reasons

1023
01:06:54,460 --> 01:06:57,190
why you may nevertheless return to the virtual machine mode,

1024
01:06:57,190 --> 01:06:59,610
one is intentional exit,

1025
01:07:00,120 --> 01:07:01,950
but also if the device interrupt goes off,

1026
01:07:01,950 --> 01:07:03,690
like the timer interrupt goes off,

1027
01:07:03,750 --> 01:07:09,030
that all the microprocessor will force a trap out of,

1028
01:07:09,670 --> 01:07:14,050
non-root mode out of the guest into root mode in the virtual machine monitor,

1029
01:07:14,140 --> 01:07:19,240
so in general device interrupts trap back into the virtual machine monitor

1030
01:07:19,240 --> 01:07:22,630
and so that means that a guest operating system can't hog the CPU,

1031
01:07:22,840 --> 01:07:26,380
every time the timer hardware timer ticks, the virtual machine monitor gets control,

1032
01:07:26,770 --> 01:07:29,830
and if there's multiple guests

1033
01:07:29,830 --> 01:07:34,900
and now basically time-share machine using the timer interrupts among all the different guests.

1034
01:07:40,930 --> 01:07:42,280
Okay, so this is basic strategy,

1035
01:07:42,280 --> 01:07:45,420
basically there's a second set of registers,

1036
01:07:50,020 --> 01:07:58,440
the other, the other big piece of machinery that VT-x provides is page table support,

1037
01:07:58,680 --> 01:08:02,040
you know when operating up here in the guest world,

1038
01:08:02,040 --> 01:08:03,750
we still need a page table,

1039
01:08:04,540 --> 01:08:07,270
you know we need the page table for two reasons,

1040
01:08:07,270 --> 01:08:11,260
one is the guest kernel wants to be able to configure its own page table,

1041
01:08:11,260 --> 01:08:15,100
wants to be able to load cr3

1042
01:08:15,100 --> 01:08:21,600
which is Intel equivalent of the satp register,

1043
01:08:21,600 --> 01:08:23,220
so we'd love to be able to

1044
01:08:23,250 --> 01:08:27,150
or VT-x allows the guest kernel to load any value it likes

1045
01:08:27,180 --> 01:08:32,220
into the cr3 register to set the page table,

1046
01:08:32,220 --> 01:08:36,600
and the hardware actually obey that page table that the guest kernel loads,

1047
01:08:36,930 --> 01:08:39,270
but we know that can be the, which is fantastic, right,

1048
01:08:39,360 --> 01:08:42,750
because now that's going to load a page table without trapping the VMM,

1049
01:08:43,480 --> 01:08:48,970
but we know that we can't just let the guests kernel put anything it likes on its page table,

1050
01:08:49,960 --> 01:08:50,680
without,

1051
01:08:50,920 --> 01:08:53,650
because that would allow it to read and write arbitrary memory,

1052
01:08:53,740 --> 01:08:59,320
so this VT-x scheme actually has another important register,

1053
01:08:59,320 --> 01:09:02,950
which is in fact part of the sort of real,

1054
01:09:03,220 --> 01:09:05,710
well, who knows where I should draw, but I'll draw it right here,

1055
01:09:07,350 --> 01:09:15,070
the extended page table register

1056
01:09:15,070 --> 01:09:16,420
and the virtual machine,

1057
01:09:16,420 --> 01:09:20,360
which points to a page table, right,

1058
01:09:21,380 --> 01:09:25,760
that maps, well, maps one kind of address or another kind of address,

1059
01:09:25,760 --> 01:09:27,890
and the virtual machine monitor sets,

1060
01:09:27,890 --> 01:09:30,560
when it's about to run a guest kernel,

1061
01:09:30,560 --> 01:09:34,070
it sets up an EPT for that kernel,

1062
01:09:34,280 --> 01:09:41,100
tells the hardware look here's the EPT for virtual machine I'm about to run

1063
01:09:41,100 --> 01:09:42,810
and then jumps into the virtual machine,

1064
01:09:42,900 --> 01:09:44,580
and then the game is that,

1065
01:09:45,430 --> 01:09:48,470
the MMU on this machine,

1066
01:09:48,500 --> 01:09:50,870
when it's translating a guest virtual address,

1067
01:09:50,870 --> 01:09:55,490
it first translates the guest virtual address to a guest physical address,

1068
01:09:55,520 --> 01:09:58,950
to the guests, the page table the guest sets up,

1069
01:09:58,950 --> 01:10:01,020
and then does another translation

1070
01:10:01,020 --> 01:10:05,790
of that guest physical address through the EPT to get a host physical address,

1071
01:10:06,560 --> 01:10:11,930
and that hardware does that automatically for every memory reference the guest does,

1072
01:10:11,960 --> 01:10:13,730
as this double level of translation,

1073
01:10:14,000 --> 01:10:17,210
and so this again gives the VMM control over

1074
01:10:17,210 --> 01:10:20,480
what physical memory the guest is allowed to use,

1075
01:10:20,480 --> 01:10:22,700
the guest can set up any page table it likes

1076
01:10:22,700 --> 01:10:23,930
and can do it quite efficiently,

1077
01:10:23,930 --> 01:10:26,240
because it can directly execute the instructions,

1078
01:10:26,270 --> 01:10:30,330
but it's still constrained by the EPT,

1079
01:10:30,330 --> 01:10:32,220
which the VMM configured to

1080
01:10:32,220 --> 01:10:37,980
be able to only use physical pages that the VMM wants it to use.

1081
01:10:40,560 --> 01:10:41,940
Any questions about the EPT?

1082
01:10:47,350 --> 01:10:49,240
Oh, sorry, I have a question about EPT,

1083
01:10:49,270 --> 01:10:52,840
about the the second set of registers,

1084
01:10:52,930 --> 01:10:57,400
so if you have two cores and you want to add two VMMs,

1085
01:10:57,700 --> 01:11:01,690
does it, do you get like a third copy of the registers?

1086
01:11:01,690 --> 01:11:06,400
Every core has its own set of these registers,

1087
01:11:06,850 --> 01:11:09,190
every core has a sort of independent,

1088
01:11:10,410 --> 01:11:15,630
independent instance of all this VT-x hardware,

1089
01:11:15,960 --> 01:11:20,160
every core, every core has its own 32 general purpose registers,

1090
01:11:20,310 --> 01:11:27,120
its own real control registers and its own virtual registers for guest mode,

1091
01:11:27,750 --> 01:11:29,880
its own, its own EPT.

1092
01:11:31,010 --> 01:11:33,860
So you have two different guests on two different cores,

1093
01:11:33,860 --> 01:11:35,840
they all have their own every register,

1094
01:11:37,050 --> 01:11:38,190
every core has its own.

1095
01:11:39,320 --> 01:11:41,240
So you need a new VMM too?

1096
01:11:41,510 --> 01:11:45,290
Well, I mean, it could just like an ordinary operating system,

1097
01:11:45,290 --> 01:11:47,540
like xv6 can support multiple processes

1098
01:11:47,540 --> 01:11:50,780
and it's all the same xv6,

1099
01:11:50,810 --> 01:11:57,720
but although, and just like xv6 has a separate struct proc for every process,

1100
01:11:58,080 --> 01:12:02,790
or virtual machine monitor would have a separate struct, struct vmm or whatever it is,

1101
01:12:03,090 --> 01:12:07,410
one for each guest to keep track of that guest information for that guest.

1102
01:12:08,290 --> 01:12:09,640
Okay, I see, thank you.

1103
01:12:10,090 --> 01:12:10,630
Yes.

1104
01:12:11,210 --> 01:12:12,770
And as I mentioned before the switching,

1105
01:12:13,130 --> 01:12:16,670
if you have one core and three guest,

1106
01:12:16,670 --> 01:12:18,650
switching can be driven by timer interrupts,

1107
01:12:18,650 --> 01:12:21,900
which go to the virtual machine monitor not the guest.

1108
01:12:26,730 --> 01:12:27,270
Okay.

1109
01:12:28,120 --> 01:12:30,130
More questions about virtual machines,

1110
01:12:30,160 --> 01:12:34,720
before I switch to the paper.

1111
01:12:39,410 --> 01:12:44,590
Alright, the paper takes this hardware is a starting point

1112
01:12:44,890 --> 01:12:48,040
and uses it for something else not a virtual machine,

1113
01:12:48,460 --> 01:12:50,110
so that's a lot of the interest in the papers,

1114
01:12:50,110 --> 01:12:54,850
that they took this hardware which is absolutely design just for virtual machines,

1115
01:12:55,180 --> 01:12:55,870
and the paper saying,

1116
01:12:55,870 --> 01:12:59,530
gosh, we could just use this hardware to do just makes not a virtual machine.

1117
01:13:00,670 --> 01:13:06,200
And what they're, a high-level view of what they're doing is,

1118
01:13:06,260 --> 01:13:10,070
they're just, they want to implement the ordinary processes,

1119
01:13:10,100 --> 01:13:11,570
now we're back in just Linux,

1120
01:13:11,900 --> 01:13:13,850
no virtual machines anymore, just Linux,

1121
01:13:13,880 --> 01:13:16,070
but assuming VT-x hardware is Dune,

1122
01:13:19,330 --> 01:13:22,110
we have Linux

1123
01:13:22,140 --> 01:13:28,050
and we assume we've loaded the Dune loadable kernel module into Linux,

1124
01:13:28,050 --> 01:13:31,530
now this Dune software is running in supervisor mode

1125
01:13:31,530 --> 01:13:32,820
as part of the Linux kernel,

1126
01:13:33,670 --> 01:13:36,640
but for the most part, we're you know we're running Linux

1127
01:13:36,640 --> 01:13:39,160
and we're expecting to run Linux processes.

1128
01:13:41,180 --> 01:13:43,250
So the abstraction of trying to support is

1129
01:13:43,250 --> 01:13:45,500
mostly the process abstraction with system calls

1130
01:13:45,500 --> 01:13:49,010
and all the sort of ordinary things that Linux processes can do,

1131
01:13:49,910 --> 01:13:54,560
but we want to use this VT-x hardware to give sort of more,

1132
01:13:54,590 --> 01:13:59,660
sort of allow ordinary processes to do some extra things

1133
01:14:01,850 --> 01:14:06,040
and there's really, so we're actually gonna run,

1134
01:14:06,040 --> 01:14:08,230
so Dune runs these processes

1135
01:14:08,290 --> 01:14:10,690
or allows a process to switch into Dune mode,

1136
01:14:10,690 --> 01:14:15,310
which means that instead of just being protected being isolated by a page table,

1137
01:14:15,430 --> 01:14:21,370
now this process is isolated by the complete VT-x apparatus,

1138
01:14:21,400 --> 01:14:24,670
so for this process, Dune is going to maintain,

1139
01:14:25,120 --> 01:14:30,880
this process now has this virtual set of of all the control registers,

1140
01:14:30,880 --> 01:14:33,160
like its own cr3 in it

1141
01:14:33,160 --> 01:14:35,890
and therefore its own page table,

1142
01:14:36,560 --> 01:14:42,900
because this process is going to run in non-root supervisor mode,

1143
01:14:42,900 --> 01:14:44,520
so it can run all the privileged instructions,

1144
01:14:44,520 --> 01:14:49,080
although against the virtual state implemented by VT-x.

1145
01:14:50,990 --> 01:14:54,560
So one of the critical things this process can do under Dune is

1146
01:14:54,560 --> 01:14:58,790
set up its own page table using its own hardware cr3,

1147
01:14:58,820 --> 01:15:03,580
of course Dune you know controls EPT for this process,

1148
01:15:03,580 --> 01:15:06,850
so and the EPT is going to be set up

1149
01:15:06,850 --> 01:15:10,330
to only have entries for this process's ordinary process memory,

1150
01:15:10,510 --> 01:15:12,700
so the process can put anything that like cr3,

1151
01:15:12,700 --> 01:15:16,690
but because the MMU translates through the EPT,

1152
01:15:16,690 --> 01:15:18,580
after translating through the ordinary page table,

1153
01:15:18,580 --> 01:15:21,550
the process still cannot escape its allocated memory,

1154
01:15:21,580 --> 01:15:24,550
so the process does have any sort of additional powers

1155
01:15:24,550 --> 01:15:27,830
with respect to other processes or kernel memory,

1156
01:15:27,860 --> 01:15:32,060
it just has now a more flexible way of setting up its own memory.

1157
01:15:33,700 --> 01:15:37,300
Alright, so one thing a Dune process can do is have it's own page table,

1158
01:15:37,780 --> 01:15:39,970
in fact, it's basically required to have its own page table,

1159
01:15:39,970 --> 01:15:42,800
because otherwise, it won't work,

1160
01:15:43,550 --> 01:15:46,430
and the other thing a process can do is

1161
01:15:46,460 --> 01:15:56,310
have a supervisor mode and user mode within its little virtual machine,

1162
01:15:56,520 --> 01:15:57,900
and be able to run,

1163
01:15:57,900 --> 01:16:02,340
be able to have the supervisor code set itself up to be protected

1164
01:16:02,730 --> 01:16:05,760
against the code that runs in guest user mode.

1165
01:16:06,160 --> 01:16:09,100
So the paper really talks about these two different uses,

1166
01:16:09,430 --> 01:16:12,220
two different things you can do with Dune.

1167
01:16:13,090 --> 01:16:18,040
So the this ability to get at,

1168
01:16:18,040 --> 01:16:21,940
for a process to get at the hardware support for supervisor versus user mode,

1169
01:16:22,900 --> 01:16:29,140
allows them to run untrusted plugin code here in a sandbox.

1170
01:16:31,660 --> 01:16:32,470
And so the idea is,

1171
01:16:32,470 --> 01:16:36,250
oh, maybe you're, you're, maybe the main program is like a web browser,

1172
01:16:36,760 --> 01:16:42,160
you know you can download web browser, download plugins that your web browser runs,

1173
01:16:42,250 --> 01:16:47,810
maybe a new video decoder

1174
01:16:47,810 --> 01:16:49,280
or a new ad blocker or something,

1175
01:16:49,280 --> 01:16:50,810
but we don't totally trust that plugin,

1176
01:16:50,810 --> 01:16:53,450
so we'd like to run it with restricted privileges somehow,

1177
01:16:54,740 --> 01:16:58,670
it's possible, but a little bit tricky to do in ordinary Linux,

1178
01:16:58,670 --> 01:17:04,460
but with Dune, now we can run the plugin appear in user space,

1179
01:17:04,460 --> 01:17:08,510
and the web browser which runs in the in the process supervisor mode

1180
01:17:08,570 --> 01:17:10,790
can configure the page table,

1181
01:17:11,910 --> 01:17:14,040
configure a different page table,

1182
01:17:14,400 --> 01:17:16,260
for use by this user code,

1183
01:17:16,260 --> 01:17:17,970
because it's allowed write cr3

1184
01:17:18,420 --> 01:17:23,280
and that can allow it to run this untrusted plugin code

1185
01:17:23,670 --> 01:17:26,160
with only allowing it restricted access

1186
01:17:26,190 --> 01:17:29,850
to just some pages of the web browser's memory,

1187
01:17:30,850 --> 01:17:33,910
so that even if plugin code malicious,

1188
01:17:33,910 --> 01:17:38,260
can't just arbitrarily read wirte the main web browser's memory,

1189
01:17:38,930 --> 01:17:43,430
and if the user code, user code may be expected to make system calls,

1190
01:17:44,070 --> 01:17:46,260
but those system calls,

1191
01:17:46,620 --> 01:17:54,400
actually trap into the supervisor mode of the process and not into Linux,

1192
01:17:54,400 --> 01:17:58,480
the user, this plugin code may think it's calling for fork or read or write who knows what,

1193
01:17:58,510 --> 01:18:02,650
but actually those attempts to execute system calls

1194
01:18:02,770 --> 01:18:05,960
trap into the web browser in the process,

1195
01:18:05,990 --> 01:18:07,130
and they can do whatever like,

1196
01:18:07,130 --> 01:18:11,390
they can not do the system call, execute system call or who knows what,

1197
01:18:12,350 --> 01:18:16,790
our web browser has full control over the sandboxed plugin code.

1198
01:18:19,740 --> 01:18:21,360
As a quick overview,

1199
01:18:21,360 --> 01:18:24,150
any any questions about using Dune sandbox?

1200
01:18:30,280 --> 01:18:31,570
And to be fair, this is something,

1201
01:18:31,570 --> 01:18:36,040
this is an effect that could be achieved by quite different techniques,

1202
01:18:36,070 --> 01:18:40,800
using existing Linux facilities,

1203
01:18:40,800 --> 01:18:46,080
but Dune allows you to provide in a particularly kind of elegant and efficient way

1204
01:18:47,070 --> 01:18:48,840
by using the VT-x hardware.

1205
01:18:51,550 --> 01:18:56,790
The other thing that the paper talks about using Dune for is

1206
01:18:56,790 --> 01:18:58,410
to make garbage collection faster,

1207
01:18:58,800 --> 01:19:00,150
and here it's,

1208
01:19:00,150 --> 01:19:05,280
the way it does that is by allowing the garbage collection,

1209
01:19:05,880 --> 01:19:08,280
we're not doing sandbox anymore,

1210
01:19:08,280 --> 01:19:10,710
we're actually not even using user mode,

1211
01:19:10,710 --> 01:19:12,270
we're just having one program,

1212
01:19:12,690 --> 01:19:16,710
we're, we're assuming that we're writing just whatever program who knows what,

1213
01:19:16,710 --> 01:19:18,360
but in a garbage collected language,

1214
01:19:18,360 --> 01:19:21,930
like Java or python or something,

1215
01:19:22,590 --> 01:19:24,060
garbage collection could be slow,

1216
01:19:25,000 --> 01:19:28,630
you know, there's dozens and dozens of tricks for making garbage collection faster,

1217
01:19:28,660 --> 01:19:31,420
but one of the things that's important in garbage collectors,

1218
01:19:31,420 --> 01:19:33,250
the garbage collectors is somewhat,

1219
01:19:33,250 --> 01:19:38,140
many garbage collectors trace find that memory is still alive, is still active,

1220
01:19:38,230 --> 01:19:42,790
by just tracing all the pointers through all objects starting at the registers,

1221
01:19:42,790 --> 01:19:47,050
and if doesn't find some object after it's completed trace,

1222
01:19:47,050 --> 01:19:51,310
then that object can't be reached, is referred to by any pointer,

1223
01:19:51,310 --> 01:19:52,780
it could be freed.

1224
01:19:53,600 --> 01:19:56,900
But many garbage collectors run at the same time

1225
01:19:56,900 --> 01:19:59,720
as in a different thread or something as the main program,

1226
01:19:59,930 --> 01:20:02,450
and so maybe the garbage collector has started tracing

1227
01:20:02,450 --> 01:20:06,350
pointers from maybe from some set of registers,

1228
01:20:06,350 --> 01:20:08,510
and this followed a pointer to this object,

1229
01:20:08,510 --> 01:20:10,190
which had pointers these objects,

1230
01:20:10,190 --> 01:20:13,130
and the garbage collectors following each of these pointers,

1231
01:20:13,550 --> 01:20:16,970
down to the tree or graph of objects,

1232
01:20:17,270 --> 01:20:21,550
may be the garbage collector has gone down here so far,

1233
01:20:22,220 --> 01:20:23,750
and actually trace through all these objects,

1234
01:20:23,750 --> 01:20:28,430
but then because the garbage collector is running concurrently with the program itself,

1235
01:20:28,820 --> 01:20:33,710
maybe the program modifies this object, the garbage collectors already traced through,

1236
01:20:34,480 --> 01:20:35,530
that's a bad deal,

1237
01:20:35,560 --> 01:20:39,130
because now the list of object pointers,

1238
01:20:39,130 --> 01:20:41,770
that garbage collectors decided alive or dead or whatever,

1239
01:20:41,770 --> 01:20:42,910
it may not be correct,

1240
01:20:42,910 --> 01:20:46,900
because the object is already seen has been modified by the program.

1241
01:20:48,490 --> 01:20:51,220
So, Dune using page table support

1242
01:20:51,220 --> 01:20:54,970
provides a way for the garbage collector to detect writes like that,

1243
01:20:55,690 --> 01:21:04,060
and in particular Dune sets up the cr3, the virtual cr3 supported by VT-x

1244
01:21:04,510 --> 01:21:06,100
to point to its own page table,

1245
01:21:07,000 --> 01:21:11,050
and then the leaves all these page table entries valid,

1246
01:21:11,050 --> 01:21:16,330
but it looks at the d bit, every page table entry has a dirty bit,

1247
01:21:16,540 --> 01:21:20,640
that in the case, there's been a write to that page,

1248
01:21:20,640 --> 01:21:23,130
so if the program writes some object,

1249
01:21:23,250 --> 01:21:26,310
then the dirty bit in the corresponding page,

1250
01:21:27,390 --> 01:21:30,660
in the page table, the dirty bit will be set,

1251
01:21:30,720 --> 01:21:34,140
and so the garbage collectors finished tracing through the objects,

1252
01:21:34,170 --> 01:21:36,780
it goes back and looks at the d bits in the page table,

1253
01:21:36,990 --> 01:21:41,340
defined all pages that contain objects that might have been modified

1254
01:21:41,340 --> 01:21:43,260
and re-scans those objects,

1255
01:21:43,590 --> 01:21:48,000
and it turns out that this facility of getting at the d bits

1256
01:21:48,330 --> 01:21:51,630
is difficult and slow with ordinary Linux,

1257
01:21:52,700 --> 01:21:53,930
I don't even know if Linux supports,

1258
01:21:53,930 --> 01:21:57,710
there are operating systems where you can make system calls to ask for d bits,

1259
01:21:58,610 --> 01:22:00,860
but if you use Dune and VT-x,

1260
01:22:00,860 --> 01:22:05,450
then the process could just use ordinary load and store instructions

1261
01:22:05,450 --> 01:22:08,930
to get the PTEs and therefore the d bits and it's very fast.

1262
01:22:09,920 --> 01:22:12,050
And so they showed you know that,

1263
01:22:12,050 --> 01:22:17,180
this makes this trick for some programs that are garbage collection intensive,

1264
01:22:17,600 --> 01:22:20,480
makes the programs significantly faster.

1265
01:22:23,260 --> 01:22:24,160
Any questions?

1266
01:22:26,500 --> 01:22:34,020
What would happen if a sandbox program wants to,

1267
01:22:35,140 --> 01:22:38,470
like run its own garbage collector or something, like that?

1268
01:22:38,470 --> 01:22:40,270
I see, so you're sort of using,

1269
01:22:40,270 --> 01:22:40,810
alright, alright,

1270
01:22:40,810 --> 01:22:44,230
so we got using Dune,

1271
01:22:45,130 --> 01:22:48,070
we have a Dune process,

1272
01:22:48,070 --> 01:22:55,150
that's actually using VT-x is a supervisor versus user mode,

1273
01:22:55,180 --> 01:22:57,280
we're running a plugin up here in user mode,

1274
01:22:57,280 --> 01:23:00,940
and the plugin it also it's also written in a garbage collected language

1275
01:23:00,940 --> 01:23:04,960
and would like to use to have its own page table,

1276
01:23:05,710 --> 01:23:09,550
its own cr3 point to its own page table with its own d bits.

1277
01:23:10,660 --> 01:23:12,580
No, that doesn't work,

1278
01:23:12,580 --> 01:23:14,890
because we're going to run,

1279
01:23:14,890 --> 01:23:18,340
the way Dune wants you to run plugins sandbox plugins is

1280
01:23:18,340 --> 01:23:22,270
to run them and used in guest user mode,

1281
01:23:22,880 --> 01:23:24,980
guest user mode is not allowed,

1282
01:23:25,100 --> 01:23:28,730
it's just like user mode is not allowed to think about cr3,

1283
01:23:29,240 --> 01:23:31,430
and so in user mode in guest user mode,

1284
01:23:31,430 --> 01:23:34,100
we don't get to have our own page table,

1285
01:23:34,100 --> 01:23:37,070
and so we don't get quick access to the d bits,

1286
01:23:38,610 --> 01:23:41,400
it's only in guest supervisor mode,

1287
01:23:42,050 --> 01:23:43,190
though we can have our own cr3,

1288
01:23:44,210 --> 01:23:46,220
so you can't,

1289
01:23:46,980 --> 01:23:50,250
well, there's no obvious way to combine the two tricks,

1290
01:23:50,610 --> 01:23:53,640
the two kinds of tricks Dune allows.

1291
01:23:57,380 --> 01:24:04,730
What about let's say somebody wrote a browser actually using Dune,

1292
01:24:04,820 --> 01:24:06,140
that would mean like,

1293
01:24:06,740 --> 01:24:09,050
that would be quite tough to make,

1294
01:24:09,050 --> 01:24:12,260
if some computers didn't support Dune or something right,

1295
01:24:12,620 --> 01:24:16,580
like it's hard to just put Chrome into and to use Dune,

1296
01:24:16,700 --> 01:24:19,190
if not everyone has that kernel modules.

1297
01:24:19,220 --> 01:24:23,630
Right, so first of all you have to be running on a computer that supports the VT-x,

1298
01:24:23,840 --> 01:24:25,940
you know the underlying computer support VT-x,

1299
01:24:25,940 --> 01:24:28,310
which means many Intel chips, many.

1300
01:24:29,960 --> 01:24:32,870
So, if you need VT-x to run Dune

1301
01:24:32,870 --> 01:24:34,040
and Dune had to be loaded

1302
01:24:34,040 --> 01:24:36,980
in order to run the browser that takes advantage of Dune,

1303
01:24:36,980 --> 01:24:39,080
so yeah, you've got to set this up correctly.

1304
01:24:41,330 --> 01:24:44,060
You know it's a research project,

1305
01:24:45,560 --> 01:24:49,300
it's intended to sort of get people thinking about

1306
01:24:49,300 --> 01:24:51,940
things that could be deployed in the real world,

1307
01:24:51,940 --> 01:24:54,500
if they were, they seem like they're valuable,

1308
01:24:55,220 --> 01:24:56,630
so you know just like Linux

1309
01:24:56,630 --> 01:25:01,040
and Linux is hundreds and hundreds of features it has,

1310
01:25:01,040 --> 01:25:05,590
and so somebody decided to add Dune to Linux you know as a standard feature,

1311
01:25:05,590 --> 01:25:07,090
then that could start relying on,

1312
01:25:07,480 --> 01:25:09,430
Chrome could just use it would not be a problem.

1313
01:25:17,710 --> 01:25:18,820
Sorry, so in a high-level,

1314
01:25:18,820 --> 01:25:23,040
Dune this like, like be like making a VM,

1315
01:25:23,040 --> 01:25:26,100
but instead of VM you are run a process.

1316
01:25:26,370 --> 01:25:30,220
Or yeah or, yeah, you can phrase it either way,

1317
01:25:30,220 --> 01:25:36,230
it's, I mean, it's it's it's supporting what's mostly a process abstraction,

1318
01:25:37,240 --> 01:25:40,060
but but but, it's using instead of using a page table hardware,

1319
01:25:40,450 --> 01:25:43,510
it's using the CPU hardware to support a process abstraction,

1320
01:25:44,330 --> 01:25:47,120
but instead of that particular CPU hardware,

1321
01:25:47,120 --> 01:25:49,870
it's using is the VT-x hardware,

1322
01:25:49,870 --> 01:25:52,470
which as a few extra features,

1323
01:25:52,800 --> 01:25:57,680
like, like the ability to set up your own page.

1324
01:25:59,010 --> 01:26:00,210
Right, right, I see,

1325
01:26:00,240 --> 01:26:02,940
I remember the paper I read process level abstraction,

1326
01:26:02,940 --> 01:26:04,440
but I didn't understand what it means,

1327
01:26:04,440 --> 01:26:05,970
but now I understand it, thank you.

1328
01:26:11,350 --> 01:26:13,060
Alright, now time is up,

1329
01:26:13,060 --> 01:26:14,500
I'm happy to continue,

1330
01:26:14,620 --> 01:26:17,110
anybody has more questions, happy to answer.

1331
01:26:18,840 --> 01:26:19,860
Yeah, so I had a question,

1332
01:26:19,860 --> 01:26:23,550
in particular about a something that said in the paper was,

1333
01:26:23,550 --> 01:26:28,230
if a Dune like a process a process inside Dune forks,

1334
01:26:28,410 --> 01:26:31,140
it becomes a non Dune process,

1335
01:26:31,140 --> 01:26:34,470
isn't that like a security flying away or or.

1336
01:26:34,770 --> 01:26:35,610
What's the attack?

1337
01:26:36,960 --> 01:26:39,990
Well, if you run something as a Dune process,

1338
01:26:40,020 --> 01:26:41,820
thinking that it's now safe,

1339
01:26:41,820 --> 01:26:45,840
but then it can run, it can just fork escape.

1340
01:26:46,020 --> 01:26:47,520
So, here's a possibility,

1341
01:26:48,250 --> 01:26:52,720
okay, so if let's see code done in supervisor mode,

1342
01:26:53,880 --> 01:26:55,500
there's no security problems,

1343
01:26:55,500 --> 01:26:57,120
this reflected this code,

1344
01:26:57,120 --> 01:27:00,980
because you already have whatever privileges where possible it already has,

1345
01:27:00,980 --> 01:27:03,050
it does not gain the extra privilege just fork.

1346
01:27:03,600 --> 01:27:04,260
Okay.

1347
01:27:04,590 --> 01:27:08,460
Code up, but maybe it's using Dune sandbox plugin,

1348
01:27:09,060 --> 01:27:11,250
and we have untrusted code up here,

1349
01:27:11,250 --> 01:27:16,960
that, that would be dangerous, you know, let it run without Dune,

1350
01:27:16,960 --> 01:27:20,110
because it's not trusted, we're using Dune sandbox,

1351
01:27:20,290 --> 01:27:21,610
so then if we forked,

1352
01:27:22,590 --> 01:27:26,550
okay, so this code cannot fork, right,

1353
01:27:26,550 --> 01:27:28,650
you can try to call the fork system call,

1354
01:27:29,160 --> 01:27:35,150
but a system call instruction here traps into the supervisor part of this process,

1355
01:27:35,420 --> 01:27:40,560
and presuming the supervisor part of this process is carefully written not to be tricked

1356
01:27:40,860 --> 01:27:43,110
and so it's not actually a fork.

1357
01:27:43,640 --> 01:27:44,480
So that doesn't work,

1358
01:27:44,570 --> 01:27:46,340
if the supervisor of code,

1359
01:27:46,340 --> 01:27:47,330
it is allowed to fork,

1360
01:27:47,330 --> 01:27:49,340
it is allowed to make system calls

1361
01:27:49,340 --> 01:27:52,190
that you get to fork this process with the same memory image,

1362
01:27:52,190 --> 01:27:55,980
so we'll get the plugin up here, and.

1363
01:27:56,160 --> 01:27:56,700
I see.

1364
01:27:56,940 --> 01:27:59,970
If you didn't realize that fork turned off Dune,

1365
01:28:00,580 --> 01:28:01,510
and it did,

1366
01:28:05,370 --> 01:28:07,200
I mean it's hard to see how this could actually happen,

1367
01:28:07,200 --> 01:28:11,220
but you know if it did something to resume execution of the plugin,

1368
01:28:11,220 --> 01:28:12,930
now that would be very foolish,

1369
01:28:12,990 --> 01:28:14,370
you know the plugin is a sandbox,

1370
01:28:14,520 --> 01:28:19,000
you know, in fact this you know the code jump in the sandbox here

1371
01:28:19,000 --> 01:28:20,380
involves privileged instructions,

1372
01:28:20,380 --> 01:28:21,790
just like it does on this slide,

1373
01:28:22,090 --> 01:28:27,500
because it switches, switches guest modes,

1374
01:28:27,500 --> 01:28:28,970
and if you execute that instruction here,

1375
01:28:28,970 --> 01:28:30,500
that's illegal instruction.

1376
01:28:32,160 --> 01:28:35,340
I guess, I guess what I was misunderstanding was,

1377
01:28:35,340 --> 01:28:37,860
I think that the plugin is not a process,

1378
01:28:37,860 --> 01:28:42,210
like the the Dune process is the sandbox, the plugin is just inside there,

1379
01:28:42,630 --> 01:28:45,240
process is just enabled to use features

1380
01:28:45,240 --> 01:28:48,060
to let the plugin run faster, basically.

1381
01:28:48,180 --> 01:28:53,560
That's right, you know we're absolutely assuming that this software down here is clever,

1382
01:28:53,560 --> 01:28:57,490
which is careful about what it likes,

1383
01:28:57,760 --> 01:29:02,060
about preventing a sandbox to actually work in real life.

1384
01:29:03,360 --> 01:29:09,090
And it's not, it's not unsafe, for the Dune process to have supervisor mode,

1385
01:29:09,090 --> 01:29:11,910
because it's actually supervisor mode in non-root mode,

1386
01:29:11,910 --> 01:29:15,690
which is the same as supervisor mode and a guest OS, right.

1387
01:29:15,870 --> 01:29:17,790
It's like you can let it do everything,

1388
01:29:17,790 --> 01:29:22,230
just, but because VT-x it's going to be like a virtual machine,

1389
01:29:22,230 --> 01:29:23,340
so it's not going to hurt us.

1390
01:29:23,580 --> 01:29:26,070
That's right, it can't escape from its address spaces,

1391
01:29:26,070 --> 01:29:30,270
EPT, is Dune a set of EPT to constrain it to its address space.

1392
01:29:33,100 --> 01:29:33,940
That makes sense.

1393
01:29:35,560 --> 01:29:37,060
So one last thing I had,

1394
01:29:37,060 --> 01:29:42,760
I I there was like a paragraph on on EPTs

1395
01:29:42,760 --> 01:29:48,730
and it said that the user page table can just expand the addresses

1396
01:29:48,880 --> 01:29:50,950
like re-map them to their original layout,

1397
01:29:51,420 --> 01:29:54,330
that was something I just didn't understand the whole paragraph.

1398
01:29:54,330 --> 01:29:56,040
So, I I don't.

1399
01:29:56,040 --> 01:29:57,450
Maybe that's a bit specific.

1400
01:29:58,280 --> 01:30:00,620
I think what's going on is that

1401
01:30:00,620 --> 01:30:09,840
the physical addresses are on the x86 are have fewer bits than virtual addresses,

1402
01:30:10,340 --> 01:30:11,270
so I'm kind of guessing,

1403
01:30:11,600 --> 01:30:16,040
and so that means that the EPT you know that,

1404
01:30:17,230 --> 01:30:19,900
the ordinary page table maps virtual addresses to physical addresses,

1405
01:30:19,900 --> 01:30:22,120
that physical addresses have fewer bits

1406
01:30:22,300 --> 01:30:25,150
and so that constructs the the,

1407
01:30:25,850 --> 01:30:30,440
that means, when Dune is setting up,

1408
01:30:31,100 --> 01:30:33,740
an address space for a process

1409
01:30:33,800 --> 01:30:34,760
or one way to look at is

1410
01:30:34,760 --> 01:30:36,800
when Dune setting up the address space for process,

1411
01:30:36,950 --> 01:30:44,010
the process address space has to fit in the smaller number of bits for a Dune process.

1412
01:30:44,040 --> 01:30:44,610
Okay.

1413
01:30:44,640 --> 01:30:46,440
Regular process is going to be used,

1414
01:30:46,530 --> 01:30:47,430
I don't know what the numbers are,

1415
01:30:47,430 --> 01:30:49,620
let's say 48 bit virtual addresses,

1416
01:30:49,710 --> 01:30:52,890
but maybe physical addresses are only 36 bits,

1417
01:30:53,420 --> 01:30:54,410
again, I'm making this up.

1418
01:30:54,470 --> 01:30:57,470
The ordinary process could use all 48 bits for virtual addresses,

1419
01:30:57,500 --> 01:31:00,230
a Dune process can only use 36 or whatever.

1420
01:31:00,820 --> 01:31:04,980
So there's different rules for things have to fit down.

1421
01:31:06,960 --> 01:31:07,620
Okay.

1422
01:31:13,220 --> 01:31:15,770
I had a question about the VT-x scheme

1423
01:31:15,830 --> 01:31:18,020
and how we're accessing page tables,

1424
01:31:18,560 --> 01:31:22,490
so when like in the way we're accessing page tables,

1425
01:31:22,640 --> 01:31:25,250
because we're going to the EPT

1426
01:31:25,250 --> 01:31:28,820
and then doing the second layer of translation there,

1427
01:31:28,820 --> 01:31:32,990
from the guest physical address to the host physical address,

1428
01:31:34,260 --> 01:31:38,640
is the latency of accesses to the page table actually lower?

1429
01:31:40,370 --> 01:31:43,940
It takes more time potentially takes more time possibly,

1430
01:31:43,940 --> 01:31:47,600
much more time to for the hardware MMU translated address,

1431
01:31:48,140 --> 01:31:49,730
because now it has to do two,

1432
01:31:49,790 --> 01:31:53,030
well, the the worst cases very much worse,

1433
01:31:53,030 --> 01:31:56,550
because, you know on the RISC-V,

1434
01:31:56,550 --> 01:31:59,730
there's multiple levels of the page table

1435
01:31:59,730 --> 01:32:04,470
and so the MMU be generated from this page from this page table page,

1436
01:32:04,470 --> 01:32:05,610
and then next and next,

1437
01:32:05,790 --> 01:32:08,850
each of those the xv6 also has multiple levels,

1438
01:32:09,870 --> 01:32:11,850
and so in the xv6,

1439
01:32:12,440 --> 01:32:14,600
in the lookup, in the first, in the main page table,

1440
01:32:14,600 --> 01:32:17,210
also has to make multiple memory references potentially,

1441
01:32:17,810 --> 01:32:21,020
each of those multiple memory references has to go through the EPT

1442
01:32:21,710 --> 01:32:24,560
and the EPT is also a multilevel page table,

1443
01:32:24,950 --> 01:32:30,230
and so I don't even know what the worst case number of memory references,

1444
01:32:30,230 --> 01:32:32,210
but it's quite a bit worse under VT-x

1445
01:32:32,210 --> 01:32:36,330
and it is with not that it is ordinary cases,

1446
01:32:36,330 --> 01:32:39,030
so there's potential there and in fact there's lots of caching,

1447
01:32:39,240 --> 01:32:41,670
so usually don't run up against that worst case, but.

1448
01:32:43,500 --> 01:32:49,330
And so virtual machines are they still like generally slow today,

1449
01:32:49,600 --> 01:32:53,770
and if so, I I guess I was wondering how does AWS work,

1450
01:32:53,770 --> 01:32:57,710
if it seems to be fast and it seems to be working well, so.

1451
01:32:58,070 --> 01:33:02,390
Yeah, my my belief is that they use VT-x hardware,

1452
01:33:03,100 --> 01:33:04,990
they use the support that we're talking about

1453
01:33:04,990 --> 01:33:11,320
and that is as well as clever device schemes for efficient device access,

1454
01:33:11,470 --> 01:33:17,840
and that the result is that AWS virtual machines are fast,

1455
01:33:19,160 --> 01:33:21,230
or not much slower than a real computer.

1456
01:33:22,850 --> 01:33:23,480
Cool thank you so much.

1457
01:33:25,970 --> 01:33:31,580
Oh, I had also another question on the shadow copy for trap-and-emulate,

1458
01:33:31,610 --> 01:33:34,400
so you said that it like,

1459
01:33:34,640 --> 01:33:36,410
I understand how you would make it,

1460
01:33:36,410 --> 01:33:40,460
but does it actually make the shadow copy or does it just,

1461
01:33:41,600 --> 01:33:43,520
I think it has to be the shadow copy right,

1462
01:33:43,520 --> 01:33:46,850
because it has to allow the process just to do it itself,

1463
01:33:46,850 --> 01:33:49,310
not like to goes to all the traps,

1464
01:33:49,310 --> 01:33:53,330
but it's doing every time, does it remember the previous.

1465
01:33:53,360 --> 01:33:57,980
Okay yeah, so yeah, so yeah, yes and yes,

1466
01:33:57,980 --> 01:34:01,940
the virtual machine monitor has to create a new page table or there,

1467
01:34:01,940 --> 01:34:04,390
you know, yes, has to create a new page table

1468
01:34:04,390 --> 01:34:07,550
and its virtual machine monitor's page table

1469
01:34:07,550 --> 01:34:10,190
which formatted up which is what the real hardware uses,

1470
01:34:10,220 --> 01:34:14,600
now of course there are plenty of opportunities for caching and for reuse,

1471
01:34:14,600 --> 01:34:17,480
so it's a it's a clever virtual machine monitors,

1472
01:34:17,480 --> 01:34:21,020
if they notice that oh the guest changed just one PTE,

1473
01:34:21,740 --> 01:34:24,230
then the virtual machine monitor may be able to

1474
01:34:24,230 --> 01:34:29,460
correspondingly limited amount of work to update its shadow page table.

1475
01:34:30,400 --> 01:34:31,720
And it also may keep,

1476
01:34:32,680 --> 01:34:37,870
you know when if it's sort of multiplexing time sharing among multiple virtual machines,

1477
01:34:37,870 --> 01:34:40,060
the virtual machine monitor will keep around

1478
01:34:40,090 --> 01:34:43,510
the shadow page tables for the virtual machines that aren't running,

1479
01:34:43,960 --> 01:34:46,330
so that it can reuse them directly,

1480
01:34:47,320 --> 01:34:49,390
when it switches back to that virtual machine.

1481
01:34:50,070 --> 01:34:51,180
Okay I see,

1482
01:34:51,210 --> 01:34:52,200
so does that mean that you have,

1483
01:34:52,200 --> 01:34:55,610
like, you have to remember a shadow copy

1484
01:34:55,610 --> 01:35:00,800
for like each process for each virtual machine.

1485
01:35:03,320 --> 01:35:07,670
Yes, there are many, many, many, many page tables

1486
01:35:07,790 --> 01:35:09,200
running around on the virtual machine,

1487
01:35:09,500 --> 01:35:14,090
virtual machine is aware of all page table switches that the guest does.

1488
01:35:14,640 --> 01:35:20,100
Yeah, it's, that the specific issue of maintaining the shadow page tables,

1489
01:35:21,090 --> 01:35:22,470
it has consumed a lot of work.

1490
01:35:23,900 --> 01:35:26,930
Right, thank you so much.

1491
01:35:26,930 --> 01:35:29,000
Before you know this is one of the many things

1492
01:35:29,000 --> 01:35:31,070
that hardware supported virtual machines,

1493
01:35:31,700 --> 01:35:33,110
made quite a bit easier.

1494
01:35:34,620 --> 01:35:35,370
Oh, okay, okay,

1495
01:35:35,370 --> 01:35:36,510
I see, I see, okay.

1496
01:35:36,540 --> 01:35:39,210
Because EPTs means you don't have to cook up your own shadow page.

1497
01:35:39,480 --> 01:35:42,900
Right, right, right, yeah that's nice, yeah, thank you.

1498
01:35:43,080 --> 01:35:43,620
Yes.

1499
01:35:51,010 --> 01:35:52,330
Alright, I gotta head up,

1500
01:35:52,330 --> 01:35:54,610
but I'll see you guys on Wednesday, thank you.

1501
01:35:54,850 --> 01:35:55,810
Thank you.

1502
01:35:56,860 --> 01:35:57,610
Thank you.

1503
01:36:02,010 --> 01:36:04,920
Is it okay, if you have time for one more question,

1504
01:36:05,700 --> 01:36:10,290
if if if this one is about the garbage collection,

1505
01:36:10,500 --> 01:36:14,130
of how like re-scans to see like the dirty bits,

1506
01:36:14,370 --> 01:36:20,050
like it is like a sort of a continued process

1507
01:36:20,050 --> 01:36:22,810
where like it continues to re-scan like indefinitely,

1508
01:36:22,810 --> 01:36:24,430
because, could it.

1509
01:36:26,300 --> 01:36:27,980
You're asking, yeah, whatever terminate,

1510
01:36:27,980 --> 01:36:30,770
supposing oh, there's always something new modified,

1511
01:36:30,860 --> 01:36:33,650
so in fact this potential problem,

1512
01:36:33,650 --> 01:36:35,390
in fact the garbage collector does is it,

1513
01:36:35,630 --> 01:36:40,830
it does one pass, one pass through to completion,

1514
01:36:41,100 --> 01:36:44,550
and then it freezes everything else, but the garbage collector,

1515
01:36:44,550 --> 01:36:45,900
so nothing else can happen,

1516
01:36:46,050 --> 01:36:48,000
then it goes back and look at the dirty pages,

1517
01:36:48,000 --> 01:36:49,380
but of course everything else is frozen

1518
01:36:50,040 --> 01:36:52,500
with no more no more dirty pages can occur,

1519
01:36:52,770 --> 01:36:55,110
and then the garbage, the garbage collector looks all dirty pages,

1520
01:36:55,110 --> 01:36:56,820
then it knows it's done yet,

1521
01:36:56,820 --> 01:36:58,830
you know does whatever it's supposed to do to finish up

1522
01:36:58,830 --> 01:36:59,640
and create a free listing

1523
01:37:00,150 --> 01:37:03,790
resumes all the threads they had stopped.

1524
01:37:04,440 --> 01:37:06,930
Oh, okay, yeah, okay, that makes a lot of sense,

1525
01:37:06,930 --> 01:37:09,180
I I don't know it froze everything else, but.

1526
01:37:09,330 --> 01:37:11,250
Yeah yeah, this is complex stuff

1527
01:37:11,250 --> 01:37:14,160
and of course there's not enough room in the paper Dune paper

1528
01:37:14,160 --> 01:37:18,570
to explain all the ins and outs what garbage collectors have to, sadly.

1529
01:37:20,400 --> 01:37:22,500
Alright, yeah, thank you so much.

1530
01:37:22,620 --> 01:37:24,690
Thank you, see you later.

