1
00:00:00,000 --> 00:00:02,430
Sound check, can everybody hear me?

2
00:00:04,690 --> 00:00:07,330
Yep. Yep. Okay.

3
00:00:07,780 --> 00:00:11,830
okay, so welcome to the next lecture in the 6.S081,

4
00:00:11,860 --> 00:00:18,850
wherever you are, in particular, I hope that the folks on the west coast or in Florida and Alabama do okay,

5
00:00:18,910 --> 00:00:21,790
you know the terrible circumstances there.

6
00:00:24,140 --> 00:00:28,280
So, the topic for today, where is virtual memory,

7
00:00:28,310 --> 00:00:30,530
particularly we're going to talk about page tables,

8
00:00:30,560 --> 00:00:33,350
we'll return to this topic a few times,

9
00:00:33,350 --> 00:00:35,150
there will be multiple [] lectures.

10
00:00:36,030 --> 00:00:41,310
And maybe just start off and you know get our question answer going again,

11
00:00:42,130 --> 00:00:51,280
I would like to ask you a little bit, what do you remember from about virtual memory from 6.004 maybe from 6.033 if you're taking that.

12
00:00:51,880 --> 00:00:55,330
I'll tell you my own sort of view on virtual memory,

13
00:00:55,330 --> 00:00:59,020
which is when I took it, to first learned about it, learned about it as a student,

14
00:00:59,230 --> 00:01:01,990
I thought it was pretty straightforward, you know how hard can it be,

15
00:01:01,990 --> 00:01:05,470
it's a table that maps virtual addresses to physical addresses,

16
00:01:05,880 --> 00:01:10,320
you know maybe a little more complicated, but not that complicated,

17
00:01:10,530 --> 00:01:20,690
only when you start programming with it I should really learned that virtual memory is tricky and fascinating, very powerful.

18
00:01:21,430 --> 00:01:30,610
And so hopefully in the next couple of lectures, in the next couple of labs, you you'll know appreciate virtual memory from that perspective.

19
00:01:30,760 --> 00:01:33,790
We want to ask me a couple people here that are online,

20
00:01:33,790 --> 00:01:39,820
you know what do you remember about virtual memory from either 6.004 or 6.033 you take it.

21
00:01:40,340 --> 00:01:47,070
Again, I'm just gonna call some names and you know share your memories about the.

22
00:01:47,100 --> 00:01:48,240
Adela Yang.

23
00:01:53,360 --> 00:01:54,500
Sorry, what's the question?

24
00:01:54,950 --> 00:02:01,220
What do you remember about virtual memory from maybe 6.004 or 6.033, if you have taken that.

25
00:02:02,020 --> 00:02:10,150
It uses like offset to save on like remembering virtual address to physical address map things.

26
00:02:11,650 --> 00:02:15,190
Okay, how about Abraham Caldera.

27
00:02:20,040 --> 00:02:21,600
Abraham, are you online?

28
00:02:23,230 --> 00:02:33,790
Yeah, my memory is that it uses, it's a way of one protecting the physical hardware by kind of [] representation of it,

29
00:02:34,480 --> 00:02:47,030
and then yeah you can have like some virtual address things like [] in 44 of bit, maps some physical address, that's usually I think 64 bits in fact.

30
00:02:48,100 --> 00:02:53,300
Okay good, how about Bibic Pendant.

31
00:02:56,750 --> 00:03:04,160
What I remember was you can have, each process has a separate address space,

32
00:03:04,620 --> 00:03:10,120
and, the memory management unit or I mean some other technique

33
00:03:10,120 --> 00:03:19,210
can be used to map the virtual addresses of the address space of each of the processes to the physical physical address,

34
00:03:20,040 --> 00:03:25,920
and the virtual address that the lower bits are kind of the same,

35
00:03:25,920 --> 00:03:31,950
so that, the the mapping is in blocks which helps with performance.

36
00:03:33,880 --> 00:03:35,470
Wiseley Wu.

37
00:03:39,580 --> 00:03:43,390
Yeah, yeah I guess what I remember most is

38
00:03:43,390 --> 00:03:51,150
that virtual address allows us to yeah protect physical addresses from each process,

39
00:03:51,630 --> 00:03:54,870
and we can use some clever manipulation,

40
00:03:54,870 --> 00:04:00,780
so that the bits that correspond to the physical address can be used somehow in the virtual addresses as well.

41
00:04:02,600 --> 00:04:05,150
Wilson Spearmen, Spearmen.

42
00:04:09,040 --> 00:04:11,950
Yeah, I remember it's really fundamental to isolation,

43
00:04:11,950 --> 00:04:18,520
because every process can basically pretend that it has its own set of memory to use.

44
00:04:20,470 --> 00:04:27,220
Good, good, well, so clearly that's awesome, so clear two themes here, correct,

45
00:04:27,220 --> 00:04:32,950
one is you know there's some form of mapping and the mapping is helpful in sort of achieving isolation,

46
00:04:33,670 --> 00:04:38,320
this is exactly the reason we're talking about virtual memory you know isolation.

47
00:04:38,850 --> 00:04:43,560
And so what we'll see is that, in the next, you know the next couple of lectures,

48
00:04:43,560 --> 00:04:45,690
in particular when we start programming use virtual memory,

49
00:04:45,930 --> 00:04:50,250
really get an in-depth understanding of what its power is.

50
00:04:50,780 --> 00:04:52,790
And so to get a sense of that,

51
00:04:52,790 --> 00:04:59,330
you know this is the first lecture and mostly focusing on the mechanisms for virtual memory,

52
00:04:59,390 --> 00:05:03,680
and then later we can see how we can use these mechanisms to achieve you know cool tricks.

53
00:05:04,670 --> 00:05:10,160
So the topic for today or agenda for today, the plan is sort of three part.

54
00:05:10,810 --> 00:05:13,150
First I'm going to talk about the address spaces,

55
00:05:13,180 --> 00:05:22,090
as some of you mentioned in your just what we, just mentioned, just briefly mentioned in response to this question.

56
00:05:22,420 --> 00:05:25,900
I'm going to talk about the paging hardware paging hardware,

57
00:05:27,020 --> 00:05:30,470
and I'm gonna focus of course on the paging hardware of the RISC-V,

58
00:05:31,390 --> 00:05:38,740
but basically every processor, modern processor has some form of paging hardware

59
00:05:38,770 --> 00:05:45,550
and sort of de-, if you will the default mechanism for actually supporting virtual memory.

60
00:05:46,270 --> 00:05:53,950
And then, the last part of the lecture is going to walk through some xv6 virtual memory code

61
00:05:54,280 --> 00:06:01,850
and layout of the kernel address space and user address spaces.

62
00:06:02,700 --> 00:06:04,350
So that's the main plan.

63
00:06:08,260 --> 00:06:14,230
Okay, so if we answers, you know remeber of you mentioned, in response to this question,

64
00:06:14,380 --> 00:06:21,820
you know one driving reason to have virtual memory is because you can use it to achieve isolation,

65
00:06:22,000 --> 00:06:25,420
if you set up the page tables correctly and program them correctly,

66
00:06:25,570 --> 00:06:28,270
then you can in principle achieve strong isolation.

67
00:06:29,020 --> 00:06:33,100
And so this is to remind us again, you know what we want with from isolation,

68
00:06:33,100 --> 00:06:35,380
let's say you know our standard picture,

69
00:06:35,380 --> 00:06:42,640
we have some user applications, like shell, cat, all the util things that you've built in lab one

70
00:06:42,940 --> 00:06:50,700
and we have kernel or kernel sitting below, the operating system sitting in kernel space.

71
00:06:51,300 --> 00:07:00,010
And you know what we like to do is sort of have you know boxes around these applications,

72
00:07:00,010 --> 00:07:02,170
so that they can't really affect each other

73
00:07:02,260 --> 00:07:08,680
and similar we wanted to be completely independent of the kernel, the operating system,

74
00:07:08,680 --> 00:07:13,330
so that if an application does something either accidentally bad or maliciously bad,

75
00:07:13,600 --> 00:07:15,670
that it doesn't really affect the operating system,

76
00:07:16,580 --> 00:07:17,570
so that's our goal.

77
00:07:17,900 --> 00:07:25,130
And the particular aspect of the problem that we want to focus on today is the memory side of things,

78
00:07:25,190 --> 00:07:27,890
so we really want to focus on memory isolation.

79
00:07:29,930 --> 00:07:35,690
And by default, if we don't do anything, we don't really have memory isolation right,

80
00:07:35,690 --> 00:07:41,120
because if you think about it there's going to be one RISC-V boards that I showed you last week,

81
00:07:41,120 --> 00:07:44,060
it has memory, a bunch of DRAM chips,

82
00:07:44,650 --> 00:07:50,980
in the DRAM chips you know the code for these applications is stored,

83
00:07:51,610 --> 00:07:56,230
for example somewhere in the memory is the kernel text data stack everything,

84
00:07:56,560 --> 00:07:59,500
somewhere in memory used to shell if the shell is running,

85
00:07:59,970 --> 00:08:02,490
somewhere in memory is the cat program.

86
00:08:04,640 --> 00:08:11,000
And so there's one sort of physical memory, you know sort of starting from zero to you know big big address,

87
00:08:11,240 --> 00:08:14,030
you know depending how much memory we have, really have in our machine

88
00:08:14,090 --> 00:08:17,000
and in that physical memory all these programs must be present,

89
00:08:17,420 --> 00:08:21,230
otherwise you know the processor can't even execute their instructions.

90
00:08:22,360 --> 00:08:24,670
This is what the risk you know clearly here is

91
00:08:24,820 --> 00:08:28,270
that let's say you know let's make a little bit you know simplistic,

92
00:08:28,270 --> 00:08:36,710
let's say the shell, you know sit for in address 0 to address 200, 2000, 1000 to 2000,

93
00:08:37,720 --> 00:08:42,550
and let's say you know the you know whatever cat has a programming error,

94
00:08:42,550 --> 00:08:53,120
it loads, you know in register a0, let's say loads the 1000, you know address basically corresponding to the start of the shell

95
00:08:53,420 --> 00:09:01,460
and then you know by accident, it executes sd instruction $7, a0,

96
00:09:02,980 --> 00:09:08,110
which has the effect of that, basically it writes the value 7 to the address 1000,

97
00:09:08,110 --> 00:09:14,050
and so it would be scribbling over you know the, basically the memory image that belongs to the shell,

98
00:09:14,830 --> 00:09:21,550
and so, now we're certainly not, certain would break isolation and be quite undesirable.

99
00:09:22,360 --> 00:09:27,880
And so we want something that basically really separates these memories from the different programs from each other,

100
00:09:27,880 --> 00:09:29,770
so that things like that just cannot happen.

101
00:09:31,590 --> 00:09:37,950
So one way you know to do that is an idea that's you know typically called address spaces.

102
00:09:44,500 --> 00:09:53,890
And the basic idea is straightforward, what we wanna do is basically give every application including the kernel its own address space.

103
00:09:55,090 --> 00:09:57,040
And so we can think about this example,

104
00:09:57,040 --> 00:10:03,690
we use cat running, you know it has an address space starting at zero you know to whatever some maximum value,

105
00:10:04,350 --> 00:10:11,370
say shell run has an address space, its own address space, also starting at address zero, going to some value,

106
00:10:11,520 --> 00:10:16,520
you know the kernel has its own address space, OS has its own address space.

107
00:10:17,640 --> 00:10:25,980
And so, for example when cat, you know refers to, really go back to the example of the previous slide where we did,

108
00:10:25,980 --> 00:10:30,360
whatever store 7 to you know a0.

109
00:10:30,950 --> 00:10:34,970
And let's say in a0, there's a value 1000,

110
00:10:34,970 --> 00:10:40,700
you know if cat execute an instruction, will write to the address 1000,

111
00:10:40,700 --> 00:10:46,100
but it's its own address 1000 it's not, you know the address of the 1000 of the shell,

112
00:10:46,400 --> 00:10:49,880
so basically every program runs with its own address space,

113
00:10:50,060 --> 00:10:53,960
has its own value and those addresses are completely independent.

114
00:10:54,360 --> 00:10:57,540
You know this notion of different address spaces,

115
00:10:57,570 --> 00:11:03,480
cat doesn't really have an ability to even refer to an address that actually belongs to the shell.

116
00:11:04,900 --> 00:11:10,270
And so that's sort of the game, that were the end goal that we'd like to achieve,

117
00:11:10,300 --> 00:11:12,370
because it's going to provide us with strong isolation,

118
00:11:12,370 --> 00:11:17,860
because you know it's just not possible for cat to refer to any other memory that is not its own.

119
00:11:19,080 --> 00:11:29,190
And so, our goal now [] basically sort of figure out how to multiplex as you will, all these different address bases on a single physical memory,

120
00:11:29,190 --> 00:11:31,920
because in the end, we only have a bunch of DRAM chips,

121
00:11:32,220 --> 00:11:35,430
were you know RAM chips where the memories locate.

122
00:11:36,930 --> 00:11:41,830
And so, and so I sort of plan.

123
00:11:41,830 --> 00:11:43,990
Okay, yeah, Amiar, you have a question, go ahead.

124
00:11:46,260 --> 00:11:53,760
Yeah, so I'm wondering in the configuration of the physical hardware, there's only so much space

125
00:11:54,180 --> 00:11:58,800
and in the virtual memory layout, there's also a max virtual address,

126
00:11:59,250 --> 00:12:03,990
by design is the virtual address made to be small enough.

127
00:12:04,510 --> 00:12:06,910
No, no, not necessarily,

128
00:12:06,910 --> 00:12:10,000
you know the virtual address space could be bigger than the physical memory,

129
00:12:10,000 --> 00:12:13,180
the physical memory could be bigger than the virtual address space

130
00:12:13,180 --> 00:12:14,980
and we'll see in a second how it all can happen,

131
00:12:15,130 --> 00:12:21,100
it's actually one of the cool parts about as we'll see with page tables, that's extremely flexible.

132
00:12:22,110 --> 00:12:27,630
So, is it, is it possible that like the physical memory gets exhausted,

133
00:12:28,280 --> 00:12:31,910
because so many processes use all their virtual space.

134
00:12:31,940 --> 00:12:35,750
Yeah, that's certainly possible and we'll see in a second how,

135
00:12:35,750 --> 00:12:38,570
for example you know you have a bunch of big applications

136
00:12:38,570 --> 00:12:41,570
that each have big page tables and they allocate a lot of memory,

137
00:12:41,570 --> 00:12:42,890
at some point you run out of memory.

138
00:12:43,920 --> 00:12:44,760
I see, thanks.

139
00:12:44,760 --> 00:12:48,840
And so where does this show up in xv6, anybody?

140
00:12:52,530 --> 00:12:58,370
You, you sure touched on a little bit in the syscall lab, that you're currently doing.

141
00:13:01,310 --> 00:13:02,630
Where are pages allocated.

142
00:13:08,660 --> 00:13:13,010
Or if you do syscall lab, you finished in one part of the syscall lab,

143
00:13:13,010 --> 00:13:15,230
[] printing how much free memory address is.

144
00:13:17,720 --> 00:13:18,140
kalloc?

145
00:13:18,140 --> 00:13:22,130
Yeah, kalloc right, kalloc have a list of free pages,

146
00:13:22,400 --> 00:13:25,910
if that list of free pages, there's an empty or runs out at some point,

147
00:13:26,120 --> 00:13:28,940
then you know kalloc is going to return a null pointer

148
00:13:29,240 --> 00:13:31,880
and hopefully the operation system does something [sensible],

149
00:13:31,880 --> 00:13:34,250
that basically propagated back to the user application,

150
00:13:34,250 --> 00:13:38,690
saying like well you know no more memory for you or no more memory in total for nobody.

151
00:13:40,970 --> 00:13:41,600
Okay?

152
00:13:43,110 --> 00:13:45,900
And there's a job for OS to handle those cases gracefully,

153
00:13:46,410 --> 00:13:50,040
gracefully generally means propagating an error message to user application.

154
00:13:57,280 --> 00:13:58,720
Okay, good.

155
00:13:59,400 --> 00:14:06,060
So how do you implement these address spaces, you know how basically multiplex all these address spaces across a single physical memory.

156
00:14:06,580 --> 00:14:12,760
And the most common approach and a very flexible approach is to use page tables.

157
00:14:17,330 --> 00:14:20,960
The idea is, this is a hardware support,

158
00:14:21,080 --> 00:14:27,710
so this is implemented in hardware by the processor or by unit called the memory management unit,

159
00:14:28,040 --> 00:14:30,440
so the picture that you should have your head is,

160
00:14:30,650 --> 00:14:35,370
you know yeah, the CPU, that executes instructions you know whatever are,

161
00:14:35,980 --> 00:14:46,990
you know, are store instruction that was you know putting $7 into a0 indirect,

162
00:14:47,580 --> 00:14:49,620
so that executes those kind of instructions

163
00:14:49,980 --> 00:14:55,560
and you know when it executes one of those store instruction, load instruction, whatever anything that actually has an address,

164
00:14:55,800 --> 00:14:59,190
you know that address we're going to think about as a virtual address,

165
00:14:59,220 --> 00:15:01,410
so it's not a physical address, it's a virtual address.

166
00:15:02,100 --> 00:15:05,190
And so, for example the value in a0 that we're using here,

167
00:15:05,250 --> 00:15:12,120
yeah say that's 1000, 0x1000 data is a virtual address

168
00:15:12,120 --> 00:15:17,580
and virtual addresses basically routed through something what's called the memory management unit,

169
00:15:21,160 --> 00:15:26,230
and the memory manager unit translates it into a physical address.

170
00:15:27,690 --> 00:15:32,670
And that physical address then was actually used to index into memory

171
00:15:33,120 --> 00:15:37,740
and load whatever value or store whatever value needs to be written there.

172
00:15:38,700 --> 00:15:41,610
And so the CPU, from the CPU point of view,

173
00:15:41,640 --> 00:15:48,150
it always issues, every instruction that [issues], once the MMU is enabled are virtual addresses.

174
00:15:49,100 --> 00:15:53,990
And to translate these virtual addresses to physical addresses, basically the MMU has a table,

175
00:15:55,060 --> 00:15:59,080
and virtual address on one side, physical address on one side,

176
00:15:59,350 --> 00:16:04,480
the other side potential here is our entry for 1000,

177
00:16:04,480 --> 00:16:14,190
and maybe that maps to whatever you know, 0x whatever you're [making something up], we'd like something value, somewhere in physical memory,

178
00:16:14,490 --> 00:16:19,050
so this mapping between virtual and physical is quite flexible.

179
00:16:19,890 --> 00:16:23,430
So on one side, we have the virtual address, on the other side of the physical addresses.

180
00:16:26,030 --> 00:16:29,690
Typically, you know this mapping itself is also stored in memory.

181
00:16:30,220 --> 00:16:40,300
And so the CPU has some register that basically points to, that contains the physical address of where the page table is stored.

182
00:16:40,720 --> 00:16:46,060
So somewhere in basically the page table or just map somewhere stored physical memory,

183
00:16:46,060 --> 00:16:49,410
let's say, yeah you know whatever address 10

184
00:16:49,860 --> 00:16:57,690
and basically this register which is called on the RISC-V satp, you know stores the address 10

185
00:16:57,780 --> 00:17:08,550
and so that the CPU can tell the memory manager unit where to find basically the map to actually translate virtual to physical addresses.

186
00:17:10,020 --> 00:17:13,710
And then the basic idea is to give every application it's own map.

187
00:17:14,310 --> 00:17:17,610
So you know cat is gonna have it's map. Oops.

188
00:17:19,120 --> 00:17:24,850
So every app, it's own. Oops.

189
00:17:25,180 --> 00:17:27,160
Yeah, Bibic go ahead.

190
00:17:29,410 --> 00:17:40,210
So the MMU, you said it doesn't necessarily store the mapping, so does it just just just do the translation,

191
00:17:40,240 --> 00:17:46,870
like it will read the memory and do the translation, but not necessarily store the mappings.

192
00:17:46,870 --> 00:17:49,600
That's exactly the right picture that you should have in your head.

193
00:17:52,780 --> 00:17:57,040
And every map, okay so the map itself stored in memory,

194
00:17:57,040 --> 00:18:00,130
MMU just basically walks or looks into the map

195
00:18:00,130 --> 00:18:03,910
and we'll see in a second you know this map is slightly more complicated than I was just draw here.

196
00:18:05,300 --> 00:18:10,540
So every app has its own its own map,

197
00:18:12,340 --> 00:18:15,520
and that map basically defines its address space.

198
00:18:16,380 --> 00:18:23,430
And so when the CPU or when the operating system switches the CPU from one process from one application to another application,

199
00:18:23,610 --> 00:18:27,360
it also switches the content of this satp register,

200
00:18:27,360 --> 00:18:32,580
to store the root of the map of the appropriate process.

201
00:18:33,410 --> 00:18:37,910
And so in that way, basically you know multiple applications to run on the CPU,

202
00:18:37,910 --> 00:18:41,000
every time we switch between from one application to the next application,

203
00:18:41,060 --> 00:18:46,910
we also switch the satp register to point to the appropriate map for that application.

204
00:18:47,430 --> 00:18:57,330
And in that way, basically virtual addresses for cat are translated differently than the virtual addresses for the shell,

205
00:18:57,330 --> 00:18:59,640
because you know each one of them has their own map.

206
00:19:02,380 --> 00:19:03,010
That makes sense?

207
00:19:06,470 --> 00:19:11,110
Okay, so we, this is the basic plan

208
00:19:11,140 --> 00:19:17,740
and the way I've drawn or gonna explain it so far it's pretty naive, and unreasonable.

209
00:19:18,240 --> 00:19:19,650
Yeah, Bibic, go head.

210
00:19:20,830 --> 00:19:28,910
I'm sorry, so the you said the satp register gets modified for the process,

211
00:19:28,940 --> 00:19:36,250
I am guessing the value of for satp register for each process is stored by the kernel.

212
00:19:36,490 --> 00:19:39,250
Yes yes, the kernel is writing satp register,

213
00:19:39,250 --> 00:19:45,040
in fact writing or reading, particular writing the satp register is a privilege instruction.

214
00:19:45,830 --> 00:19:49,880
So user application cannot just update the page map register

215
00:19:49,880 --> 00:19:52,070
and say like I want to run with this page map now,

216
00:19:52,460 --> 00:19:56,130
because that would violate isolation right,

217
00:19:56,130 --> 00:19:59,460
so it's only the kernel, only the code in kernel mode can actually update it.

218
00:20:03,730 --> 00:20:06,130
Okay, so as I said this picture is pretty naive,

219
00:20:06,190 --> 00:20:10,300
you know one thing I haven't really said anything about how this actually map works.

220
00:20:10,760 --> 00:20:18,560
And, you know the way I've drawn out seems to indicate basically for every virtual address, you have an entry in the map.

221
00:20:19,370 --> 00:20:26,360
And if you do that, how big would that be on RISC-V.

222
00:20:32,380 --> 00:20:33,100
Anybody?

223
00:20:36,150 --> 00:20:38,700
How many addresses are there on the RISC-V in principle

224
00:20:38,700 --> 00:20:41,610
or how big, how many addresses could registers store,

225
00:20:46,090 --> 00:20:49,640
registers are 64 bit wide, so, how many addresses.

226
00:20:52,490 --> 00:20:53,180
Anybody?

227
00:20:53,850 --> 00:20:57,060
I know I'm so insulting your intelligence by asking these questions, but.

228
00:21:00,110 --> 00:21:02,600
We have some answers in the chat, like 2 to the 64.

229
00:21:02,600 --> 00:21:05,660
I I didn't see the chat, sorry, yeah, 2 to 64.

230
00:21:05,690 --> 00:21:08,720
Let me see if I can actually pop up the chat, so I could see it.

231
00:21:13,460 --> 00:21:14,930
Yeah, 2 to 64, thank you.

232
00:21:17,000 --> 00:21:20,030
Alright, so this table would be gigantic,

233
00:21:20,420 --> 00:21:24,590
in fact, we know all memory would be consumed by just having the table,

234
00:21:24,590 --> 00:21:25,670
so that seems unreasonable.

235
00:21:26,350 --> 00:21:28,930
And so in fact you know that's not how things work.

236
00:21:29,520 --> 00:21:33,600
In fact I'm going to go in two steps to actually how it actually works in the RISC-V.

237
00:21:33,930 --> 00:21:41,490
So step one is you know don't [play the game] per address, but do per page.

238
00:21:44,580 --> 00:21:46,560
So you translate a page at a time

239
00:21:46,650 --> 00:21:54,590
and a page on the RISC-V is 4 kilobytes, which is a 4 and 4096 bytes.

240
00:21:55,140 --> 00:22:02,580
This is pretty common, almost all processors you know use roughly page size 4 kilobyte, or support page size 4 kilobytes.

241
00:22:03,420 --> 00:22:05,970
And so now getting translation works slightly differently,

242
00:22:06,000 --> 00:22:14,280
so here we have our virtual address, basically, we split in two pieces, an index and an offset,

243
00:22:15,300 --> 00:22:18,120
and so the offset is basically the byte within the page.

244
00:22:18,880 --> 00:22:26,530
And so when we do, when the MMU does the translation, it takes the index, indexes into the map,

245
00:22:26,980 --> 00:22:31,030
that gives you some physical page number in memory,

246
00:22:31,480 --> 00:22:37,330
and that physical page number that points to some physical page of 4096 bytes.

247
00:22:38,040 --> 00:22:42,750
And then the offset part, basically indexes into that physical page,

248
00:22:42,810 --> 00:22:53,520
for example, the offset is you know 12, then you know the, the 12th entry of that page is actually used.

249
00:22:54,110 --> 00:22:57,920
A lot of people, a lot of you, mentioned in the, mentioned in the,

250
00:22:59,100 --> 00:23:03,120
in response to the question, there's [always] some scheme of taking an offset

251
00:23:03,120 --> 00:23:11,190
and adding that to the base of the page to obtain the actual memory physical memory location,

252
00:23:11,190 --> 00:23:15,150
where value store, where value will be loaded too.

253
00:23:16,410 --> 00:23:18,630
And one of the interesting things about the RISC-V is

254
00:23:18,630 --> 00:23:26,570
and this is a response to some questions again, somebody asks like the physical or virtual addresses are 64 bits,

255
00:23:28,250 --> 00:23:32,330
which makes totally sense correct, because the RISC-V is 64 bit register.

256
00:23:33,220 --> 00:23:40,660
But in fact on the RISC-V processor that we're using, not all of the 64 bits actually used,

257
00:23:41,190 --> 00:23:45,030
namely, the top 25 are actually not used at all.

258
00:23:45,800 --> 00:23:49,160
And so that limits the size of virtual address,

259
00:23:49,370 --> 00:23:59,950
that limits the size of virtual address space 2 to the power of 39, which is roughly 512 gigabyte.

260
00:24:04,220 --> 00:24:13,250
And so of course you know later version of the processor might support bigger address spaces that is necessary and [could then] be done,

261
00:24:13,280 --> 00:24:21,500
and so for example some of those 25 bits that are basically used, could be used to build bigger virtual address spaces.

262
00:24:22,310 --> 00:24:26,420
And so, and so in the index and you know where 39 bits left,

263
00:24:26,450 --> 00:24:34,820
you know as the virtual address 27, 27 bits are index and we'll see you in a second why there are 27 are index

264
00:24:34,820 --> 00:24:43,800
and then the 12 are offset, and you know there has to be 12, because 2 to the power 12 is 4096.

265
00:24:45,420 --> 00:24:45,960
Alright?

266
00:24:46,590 --> 00:24:53,010
So that's virtual addresses on the RISC-V physical addresses, as you can see here are actually 56 bits wide.

267
00:24:57,940 --> 00:25:03,070
So the physical memory, you know can be bigger than the single virtual address space.

268
00:25:03,900 --> 00:25:05,880
But it's limited to 2 power up to 56,

269
00:25:05,970 --> 00:25:13,770
you know most boards probably you know don't support 2 to the power of 56 physical memory, because a gigantic amount of physical memory,

270
00:25:14,010 --> 00:25:20,970
but in principle a board could, you know, if you could manufacture it, support 2 to the power 56 physical memory.

271
00:25:22,020 --> 00:25:26,430
And so in this scheme, then if 56 bits for the physical address,

272
00:25:26,460 --> 00:25:29,580
44 are basically the physical page number, the PPN,

273
00:25:29,850 --> 00:25:34,530
12 again are the offset that are inherited directly from the virtual address.

274
00:25:36,810 --> 00:25:37,710
Does that make sense?

275
00:25:40,560 --> 00:25:44,250
So, you know stop for a second here, you collect your thoughts,

276
00:25:44,310 --> 00:25:49,410
the only point I wanted to make here is that this material is important,

277
00:25:49,410 --> 00:25:55,410
so just ask questions, the details matter, and it will be a large part of,

278
00:25:55,410 --> 00:26:01,560
you, you really need to understand all this stuff to be able to basically do lab, the next lab, page table lab.

279
00:26:02,580 --> 00:26:04,230
Yeah, Amiar, go ahead, please.

280
00:26:05,210 --> 00:26:08,690
If you can go back one slide, I hope the [screen], so I'm clear.

281
00:26:10,770 --> 00:26:14,720
Which one there, page tables slide? Yeah.

282
00:26:20,250 --> 00:26:21,990
This one? No.

283
00:26:22,670 --> 00:26:25,250
The most recent one, but it also doesn't really matter,

284
00:26:25,310 --> 00:26:27,170
yeah, this is perfect, thank you.

285
00:26:27,620 --> 00:26:37,790
So I'm wondering this 4096 byte range which we've called a page, is that assigned as a continuous chunk in memory.

286
00:26:37,940 --> 00:26:45,080
Yes, there's a continuous physical, continuous range of 4096 bytes in physical memory.

287
00:26:46,520 --> 00:26:49,520
I see and then the.

288
00:26:49,520 --> 00:26:52,550
You know the map at [granularity] of 4096 bytes.

289
00:26:53,490 --> 00:27:01,560
Okay, and then 12 the offset like 2 to the 12 is 4096, so that's sufficient to cover each of the chunks.

290
00:27:02,460 --> 00:27:03,600
Yeah each byte in the page.

291
00:27:04,760 --> 00:27:13,220
And where does the 56 come from in the diagram, I could follow up until then, but I didn't get where that came from.

292
00:27:13,220 --> 00:27:18,470
Designers cooked up, so the hardware designers decide how big you know physical addresses,

293
00:27:18,590 --> 00:27:28,520
basically for whatever board they want to design and so the RISC-V designers who decided at 56 that physical addresses were a good idea.

294
00:27:30,540 --> 00:27:35,040
And usually the way they come up with these numbers is they look at technology trends.

295
00:27:35,500 --> 00:27:38,980
And say like well we want to be able for the next sort of 5 years,

296
00:27:38,980 --> 00:27:43,690
you know we don't predict the physical memory will be ever bigger than 2 to the power 56.

297
00:27:44,740 --> 00:27:50,350
Probably they think it won't be bigger than something much smaller, but then you know give them some leeway,

298
00:27:50,350 --> 00:27:55,000
you know, in case you know their predictions wrong, they pick a slightly bigger number.

299
00:27:56,700 --> 00:27:57,330
Does that make sense?

300
00:27:57,330 --> 00:27:59,540
I see, yeah, thanks.

301
00:27:59,810 --> 00:28:01,190
Yeah a lot of people ask about this.

302
00:28:03,880 --> 00:28:07,360
Anybody else, who raised hand, I think there's a bunch of people asking questions

303
00:28:07,360 --> 00:28:13,030
and unfortunately my zoom doesn't show if more than two people raised hands, just multiple people are raising their hands.

304
00:28:13,710 --> 00:28:15,780
So you please jump in if you have a question.

305
00:28:20,160 --> 00:28:20,820
Okay.

306
00:28:21,570 --> 00:28:24,450
I have a question. Yeah go ahead.

307
00:28:24,660 --> 00:28:34,440
So if the virtual memory is up to 2 to the power of 27 and the physical memory is up to 2 to the power to the 56 right,

308
00:28:34,710 --> 00:28:46,130
so we could have, we have multiple processes that could exhaust all their virtual memories without using up all the physical memory.

309
00:28:48,320 --> 00:28:53,040
Yeah, that's absolutely correct.

310
00:28:53,980 --> 00:28:54,610
Okay.

311
00:28:54,730 --> 00:28:57,280
I have a question too,

312
00:28:57,280 --> 00:29:06,120
oh so this 56 for the physical address is that the, the number of possible memory locations,

313
00:29:06,510 --> 00:29:10,890
I I don't think it's the number of bits because the 64 bit machine,

314
00:29:11,160 --> 00:29:17,820
that 56 could go up to 64, but they just chose it to have just 56.

315
00:29:17,850 --> 00:29:24,300
That's correct, that's correct, one way to think about it, then they only have to run 56 wide on the board as opposed to 64.

316
00:29:25,530 --> 00:29:26,760
I see, thanks.

317
00:29:30,240 --> 00:29:30,780
Okay?

318
00:29:30,960 --> 00:29:32,490
I also have a question,

319
00:29:32,520 --> 00:29:37,140
so kind of could you go back one slide, maybe.

320
00:29:38,800 --> 00:29:45,790
So from the CPU, we go through the MMU and then to the memory,

321
00:29:46,210 --> 00:29:52,450
but where where here is the distinction for different processes,

322
00:29:52,570 --> 00:29:54,130
because like each process,

323
00:29:54,160 --> 00:30:01,060
like process like the shell process has something at address like 0x1000

324
00:30:01,120 --> 00:30:05,740
and then the ls process also has something at address 0x1000,

325
00:30:05,860 --> 00:30:11,260
so we need to translate those to different physical so yeah.

326
00:30:11,260 --> 00:30:17,410
The satp register, contains the register, contains the address of which map to use,

327
00:30:18,460 --> 00:30:22,690
so ls runs with its own map, you know cat run with its own map.

328
00:30:22,720 --> 00:30:26,800
Okay, so each process will have its completely own map.

329
00:30:28,140 --> 00:30:29,220
Makes sense, thank you.

330
00:30:29,740 --> 00:30:33,880
And in fact there's a great [way] to the next point,

331
00:30:34,180 --> 00:30:36,130
so if every process has its own map,

332
00:30:36,870 --> 00:30:40,170
you know how big is this map like that I'd drawn here.

333
00:30:40,870 --> 00:30:47,960
Well, that map is 2 to the power 27 entries correct, and that's pretty big.

334
00:30:49,030 --> 00:30:56,140
And that would fill physical memory reasonable quickly if every process exactly have complete you know [populated] map,

335
00:30:56,620 --> 00:30:59,770
and then there's gigantic, means that every process is very big,

336
00:31:00,160 --> 00:31:04,900
and so in fact this is not the way the hardware actually stores page tables,

337
00:31:04,900 --> 00:31:09,940
you can think about it conceptually as an array, you know going from 0 to 2 to power 27,

338
00:31:09,940 --> 00:31:11,770
but actually is not what happens in practice.

339
00:31:12,160 --> 00:31:15,520
In practice, it's a multi-level structure,

340
00:31:15,580 --> 00:31:25,600
that here actually the real RISC-V page table structure and what the hardware implements.

341
00:31:26,820 --> 00:31:31,650
And so what happens with the 27 bits that we saw earlier, the index,

342
00:31:32,260 --> 00:31:37,660
it's actually split in three 9 bit numbers.

343
00:31:38,220 --> 00:31:46,500
And the first the top 9 bits are used to index into the top level page table directory as they are called,

344
00:31:47,130 --> 00:31:55,600
and so in one directory, you know one of these guys, you know is 4096 bytes, 4096 bytes, just like the page size.

345
00:31:56,160 --> 00:32:08,500
A PTE entry one of the entries in the thing is 64 bytes, 64 bit I mean, sorry, like the register with, so 8 bytes.

346
00:32:09,000 --> 00:32:18,150
And so there's gonna mean that you do 4096 divided by 8, means there are 512 entries in one of those directory pages.

347
00:32:19,370 --> 00:32:24,620
So basically what happens is like the satp points to the top root directory,

348
00:32:24,650 --> 00:32:31,130
we take the top level 9 bits index into the page directory, and now gives us a new physical page number.

349
00:32:32,040 --> 00:32:35,820
And that physical page number is the page directory for the next level,

350
00:32:36,030 --> 00:32:41,910
so then we use the next level index to index into that page directory

351
00:32:42,060 --> 00:32:47,340
and then you know and so forth, you know we like to find one you know we get the bottom level page directory.

352
00:32:47,800 --> 00:32:52,570
And that basically gives us the entry, that maps the virtual address to physical address.

353
00:32:55,680 --> 00:32:59,160
So in some sense, it's very similar to where showed in the previous slide,

354
00:32:59,160 --> 00:33:02,520
except you know basically index happens in three steps instead of one step,

355
00:33:02,850 --> 00:33:06,120
and this is advantage, the main advantage of this scheme is that,

356
00:33:06,360 --> 00:33:11,610
if large parts of the address space are not being used, you don't have to have any page table entries for that.

357
00:33:12,930 --> 00:33:15,510
For example, let's say you have a address space,

358
00:33:16,120 --> 00:33:25,260
that has only one page like the bottom page 4096, and no other pages are in the address space,

359
00:33:25,560 --> 00:33:29,130
so only addresses 0 to 4095, 4096 are actually mapped,

360
00:33:29,490 --> 00:33:34,920
how many page table entry or page table directories do you need to map that particular page.

361
00:33:39,280 --> 00:33:45,240
Well, you need one of top, correct, and you need basically value in that entry for 0,

362
00:33:46,500 --> 00:33:51,300
the top level 9 bits, you know 0 0, so you need an entry for 0.

363
00:33:51,880 --> 00:33:58,870
So that means you need one middle level entry, you know that basically corresponds to the next, you know nine 0 bits

364
00:33:58,900 --> 00:34:01,360
and then one entry for the next nine 0 bits.

365
00:34:02,140 --> 00:34:07,000
So basically we get away with three page directories.

366
00:34:11,420 --> 00:34:16,370
In our previous scheme on the previous slide correct, we have 2 to the power 27 entries,

367
00:34:16,400 --> 00:34:20,360
now we basically have to have 3 times whatever 512 entries that were done.

368
00:34:21,920 --> 00:34:30,830
That's the main reason why you know actual hardware has a sort of hierarchical, multilevel tree scheme.

369
00:34:32,570 --> 00:34:34,670
Any questions about this, because it's pretty important.

370
00:34:36,270 --> 00:34:37,290
Samir, go ahead.

371
00:34:39,000 --> 00:34:47,920
So my question is, as since the PPN number from each page table is 44 bits,

372
00:34:48,440 --> 00:34:56,210
and the second, say the middle table [resides] on the virtual memory, where do we get the missing 12 bits from.

373
00:34:57,300 --> 00:35:02,310
Well, the final 12 bits, okay so good good good, so you're saying these 44 right.

374
00:35:02,980 --> 00:35:03,430
Yes.

375
00:35:03,430 --> 00:35:04,390
What is going on with that,

376
00:35:04,390 --> 00:35:15,680
well all page all page directories or page line, and so they basically they're physical page number is 44 plus 12 12 zero bits.

377
00:35:18,940 --> 00:35:23,860
And so what actually happens if we look at these PTE entries, they all have the same sort of form right,

378
00:35:23,860 --> 00:35:29,320
if you look at one of these guys, there are 44 bits, there are 12 bits zeros,

379
00:35:29,320 --> 00:35:35,200
so that gives us 44 plus 12 is 56, so that gives us a physical address, right.

380
00:35:36,610 --> 00:35:42,370
And so that means there's 64 bits, there's actually some bits left there not being used,

381
00:35:42,400 --> 00:35:48,190
in fact the bottom 12 bits will basically or the bottom 10 definitely bottom bits are not used at all

382
00:35:48,190 --> 00:35:55,600
and in fact the paging hardware stores or stores a bunch of flags that control the translation,

383
00:35:55,600 --> 00:35:57,070
we'll talk about those flags in the second.

384
00:35:57,740 --> 00:36:04,250
And but they're there to control the translation and they're stored basically in the bottom 10 bits.

385
00:36:05,100 --> 00:36:11,250
It also means that you know if you add these two up, that's 54 bits, basically there's ten bits left.

386
00:36:11,920 --> 00:36:16,420
There are unused, those 10 bits are again, you know for future growth,

387
00:36:16,810 --> 00:36:19,720
so at some point we might have a new type of RISC-V processor

388
00:36:19,960 --> 00:36:22,720
that will have a slightly different structure page tables,

389
00:36:22,840 --> 00:36:26,740
and it might actually have bigger than 44 bits for the physical page number.

390
00:36:29,440 --> 00:36:30,040
Okay? Thank you.

391
00:36:31,380 --> 00:36:36,540
In fact, you can see] it here, like if you look at a single entry, correct, that's drawn here,

392
00:36:36,540 --> 00:36:40,990
you know they're basically 10 bits left, that are not being used.

393
00:36:42,000 --> 00:36:46,350
Okay, so let's look at the flags for a second, because it's sort of important.

394
00:36:47,610 --> 00:36:51,690
So every translation in the bottom ten bits, there are a bunch of flag stored

395
00:36:51,990 --> 00:36:54,780
and the first flag is valid,

396
00:36:55,510 --> 00:37:01,990
if valid bit set, that means this is a valid PTE, and you can use it for translation.

397
00:37:03,150 --> 00:37:07,620
And so we're we're going to run my little example that I used here,

398
00:37:07,620 --> 00:37:13,350
three page directories were only entry zero is used, then only entry zero will have valid bits set

399
00:37:13,440 --> 00:37:17,070
and none of the other 511 entries, will not have valid bit set.

400
00:37:18,610 --> 00:37:26,440
And that basically tells the MMU well, you know you don't have to chase down this PTE, this PTE just contains no valid information.

401
00:37:27,820 --> 00:37:32,170
Then R means you're allowed to read from that page,

402
00:37:32,230 --> 00:37:34,990
write means you're allowed to write to the page,

403
00:37:35,230 --> 00:37:38,800
execute means you're allowed to execute instruction from it,

404
00:37:39,330 --> 00:37:46,320
user means you know this page is also accessible by a process running in user space,

405
00:37:47,340 --> 00:37:50,310
and then the other bits you not that important, it will show up at some point,

406
00:37:50,670 --> 00:37:52,770
those are sort of five important bits.

407
00:37:55,970 --> 00:37:56,840
Does that make sense?

408
00:37:59,300 --> 00:38:05,820
Yeah, Nithya, I'd probably mispronouncing your name, I apologize to you.

409
00:38:06,860 --> 00:38:08,900
That's that's the representation, thank you,

410
00:38:09,350 --> 00:38:13,220
I had a quick question about the three page tables,

411
00:38:13,820 --> 00:38:21,800
so how are the addresses or like the PPN values combined to form the final physical address I might miss that.

412
00:38:22,370 --> 00:38:25,310
Yeah, well I may not say that [] very explicitly,

413
00:38:25,400 --> 00:38:28,790
so the first PPN correct in top the page table,

414
00:38:29,330 --> 00:38:37,040
the first PPN in the top level of page directory contains the physical address of the next level down, right.

415
00:38:37,780 --> 00:38:40,480
And one contains the one next level down

416
00:38:40,480 --> 00:38:44,290
and then in the final one we still have are [] 44 bits,

417
00:38:44,380 --> 00:38:49,270
that contains then the actual physical address of the page that we're actually trying to translate to.

418
00:38:50,150 --> 00:38:51,770
Okay, that makes sense.

419
00:38:51,860 --> 00:38:54,830
Okay, and one interesting question, just let us [],

420
00:38:54,860 --> 00:38:59,540
before let me answer my own question before answering the two raised hands here,

421
00:38:59,690 --> 00:39:09,780
look back at this picture, why, why are the physical page numbers stored in these page directories, why not a virtual address.

422
00:39:11,520 --> 00:39:15,960
Because we need to look it up in memory like look up the next directory in memory.

423
00:39:16,110 --> 00:39:20,940
Yeah right, we could not have a translation scheme depends on yet another translation scheme,

424
00:39:20,940 --> 00:39:24,240
we could sort of recursive [] look, so that just doesn't make sense.

425
00:39:24,680 --> 00:39:27,570
That is exactly the right answer, it has to be a physical number,

426
00:39:27,600 --> 00:39:32,700
how about the satp, what do you satp, what does it store, it store a physical address or virtual address.

427
00:39:39,190 --> 00:39:43,510
Also physical, assuming that the first page directory is also in memory right.

428
00:39:44,710 --> 00:39:49,060
Yeah exactly, so it has to be a physical number, because we're actually trying to use it for translation.

429
00:39:50,120 --> 00:39:57,140
And, so you know the satp you need to know what the physical page number is [on] the [route] of the page directory.

430
00:39:59,180 --> 00:40:01,940
Okay, there were two other questions or to people who raise their hands,

431
00:40:02,240 --> 00:40:10,040
you do, repeat your question if if it hasn't been answered yet.

432
00:40:10,760 --> 00:40:14,030
So there's a hierarchy of three tables

433
00:40:14,360 --> 00:40:19,760
and each of them is indexed by a part of the virtual address, each nine bits long,

434
00:40:22,740 --> 00:40:28,200
so I'm not sure I understand how [chaining] between them happens

435
00:40:28,200 --> 00:40:35,220
and what it's [meant] to accomplish like shouldn't it be sufficient to just use those three nine bit addresses to index into each of them.

436
00:40:36,780 --> 00:40:42,330
That's correct, so the first top level nine bits are used to index that in the first top page level directory,

437
00:40:42,330 --> 00:40:44,880
the second in the next one and the third in the third one.

438
00:40:48,240 --> 00:40:57,090
So, maybe I'm just not understanding this correctly, so when a process requests a certain virtual address to be looked up,

439
00:40:57,330 --> 00:41:06,360
it loads into the satp register or the CPU does and that gets to the corresponding correct highest level page table,

440
00:41:07,640 --> 00:41:11,550
and then that page table will.

441
00:41:12,130 --> 00:41:16,990
And we use them to top level nine bits from the 27 to index into that page directory.

442
00:41:18,660 --> 00:41:20,850
And then what is what is the result of that,

443
00:41:20,850 --> 00:41:26,580
like if the result is there's nothing there, does the MMU create a page table.

444
00:41:26,610 --> 00:41:32,400
No no, the MMU basically tells the operating system or tells the processor, sorry I couldn't translate that address

445
00:41:32,580 --> 00:41:36,990
and basically turns into a page fault which we'll talk about a little bit later.

446
00:41:38,970 --> 00:41:42,120
But just cannot translate the address, it doesn't translate,

447
00:41:42,120 --> 00:41:47,130
it's like you know you can't divide by zero, you know if you try to do that the processor refuses to do it.

448
00:41:50,110 --> 00:41:51,250
I see, okay.

449
00:41:54,030 --> 00:41:55,650
Brandon, what about you Brandon?

450
00:41:56,320 --> 00:42:01,300
Yeah, so I just wanted to make sure I understand how, I think maybe we come up with it,

451
00:42:01,660 --> 00:42:09,160
but I want to understand how the kind of intermediate page tables, well how we calculate the physical address of those,

452
00:42:09,540 --> 00:42:15,420
so, is it correct that say if we were trying to find a second level page tables physical address,

453
00:42:15,420 --> 00:42:20,040
we would take the PPN from the first level page table, that's 44 bits

454
00:42:20,070 --> 00:42:25,710
and then we add the twelve bit offset from the original virtual address to get the full 56 bits, this question is.

455
00:42:26,010 --> 00:42:29,970
We don't add the offset from the virtual address, we just take twelve zero bits,

456
00:42:30,980 --> 00:42:32,960
so we take the PPN, that's 44 bits.

457
00:42:33,110 --> 00:42:33,980
Okay.

458
00:42:34,010 --> 00:42:40,280
Twelve zero bits at the bottom and that gives us 56 bit physical address and that's where the next page directories,

459
00:42:40,280 --> 00:42:43,100
and this requires that basically every page directories page aligned.

460
00:42:45,500 --> 00:42:47,300
I see, OK, that makes sense.

461
00:42:49,880 --> 00:42:53,300
So these are all great questions and these are all things you're gonna be struggling within the page table lab,

462
00:42:53,300 --> 00:42:55,790
so it's very good to ask them right now.

463
00:43:00,000 --> 00:43:01,950
Okay, let me see.

464
00:43:04,410 --> 00:43:14,020
Yes, okay, let me hold on for a second, I [] my thoughts, see where I am.

465
00:43:16,300 --> 00:43:25,150
Good good, good, okay, one, sort of, you know one other thing that I want to mention, because you will see that,

466
00:43:25,300 --> 00:43:29,470
is that if we think about this, you know the scheme that I just showed right,

467
00:43:29,470 --> 00:43:36,760
what really seems to be going on is that we load or store value to memory or the processor loads or stores of value to memory,

468
00:43:36,790 --> 00:43:39,280
we basically have to do three memory lookups right,

469
00:43:39,310 --> 00:43:45,040
one in the top of the page directory, one intermediate page directory and then one in the bottom level page directory.

470
00:43:45,500 --> 00:43:53,780
It looks like that you know any memory reference to virtual address basically requires three memory reach, and so that seems expensive.

471
00:43:54,540 --> 00:43:59,640
And so, what happens in practice where almost all every processor does is,

472
00:43:59,700 --> 00:44:04,290
it has a cache sitting on the side, that contains recently used translations,

473
00:44:05,300 --> 00:44:11,040
and this is called translation look-aside buffer,

474
00:44:11,790 --> 00:44:17,330
and you'll see that term quite often, the TLB.

475
00:44:18,370 --> 00:44:25,050
Basically it's nothing else than the cache of page table entries, PTE entries.

476
00:44:28,180 --> 00:44:32,110
So when the processor has you know the first time the processor routes and look up virtual address,

477
00:44:32,110 --> 00:44:38,230
you know walks this hardware, walks this page the three level page tables,

478
00:44:38,410 --> 00:44:44,320
that will come out with you know the final physical page finally of PPN for that particular virtual address,

479
00:44:44,500 --> 00:44:53,610
and then basically the the TLB stores that VA PA PN, PA mapping on the side

480
00:44:53,940 --> 00:45:00,090
and so then the next time you refer to that particular virtual address, can just look up straight up in the TLB

481
00:45:00,090 --> 00:45:03,420
and the TLB will respond instead of having to the page table walk.

482
00:45:05,240 --> 00:45:07,130
Yep, Amiar.

483
00:45:09,710 --> 00:45:16,970
So the TLB map virtual addresses to the physical address of the page,

484
00:45:17,150 --> 00:45:21,440
that the virtual address along with the offset, absolutely right,

485
00:45:22,490 --> 00:45:26,720
wouldn't it be more efficient to like cache at the page table level.

486
00:45:27,780 --> 00:45:31,260
Okay, so I let me take a step back here,

487
00:45:31,410 --> 00:45:34,050
there are many ways of implementing the TLB,

488
00:45:34,560 --> 00:45:37,500
the most important thing that you need to know is that there is a TLB,

489
00:45:38,230 --> 00:45:41,920
and the exact details of actually how the TLB has implemented,

490
00:45:41,920 --> 00:45:47,650
this sort of you know not the topic, we're gonna talk about in great amount of detail, that's not at all.

491
00:45:47,920 --> 00:45:51,340
And so this is really something that sits in side of the processor

492
00:45:51,340 --> 00:45:55,690
and is mostly hidden from the operating system, the operating system doesn't really know how the TLB operates,

493
00:45:56,270 --> 00:45:59,840
the only thing, the reason you need to know that the TLB exist,

494
00:46:00,050 --> 00:46:09,940
is that if you switch page tables, then, typically the operating system needs to tell the processor that it's switching page tables,

495
00:46:10,740 --> 00:46:14,450
and the TLB needs to be flushed.

496
00:46:16,790 --> 00:46:18,830
Because basically you send stale entries,

497
00:46:18,830 --> 00:46:23,570
if you switch to a new page table, the entries in the TLB may not be valid anymore

498
00:46:23,780 --> 00:46:28,100
and so they need to be removed, because otherwise you know the translation would be incorrect.

499
00:46:28,830 --> 00:46:35,340
And so the operating system is typically aware is aware that there's a, that there is a TLB,

500
00:46:35,370 --> 00:46:41,670
only basically tell the hardware, once in a while, saying okay we'll don't use them anymore, because I'm gonna switch page tables.

501
00:46:44,150 --> 00:46:55,000
And in fact on, you know, the the RISC-V the instruction to flush the TLB is called sfence_vma,

502
00:46:57,230 --> 00:47:01,040
I'm not actually, flush the TLB.

503
00:47:01,370 --> 00:47:01,880
Bibic.

504
00:47:04,900 --> 00:47:11,410
So I have a question, like not regarding TLB, but that brought kind of this question,

505
00:47:11,470 --> 00:47:21,370
the three level support, that the three level paging, that we have, is it implemented by the operating system or the hardware itself.

506
00:47:21,640 --> 00:47:25,400
Is implemented in hardware, so you know there's all happens in hardware,

507
00:47:25,670 --> 00:47:30,120
the MMU is a block of hardware, not in the operating system,

508
00:47:30,180 --> 00:47:33,150
we'll see in a second when we look at xv6,

509
00:47:33,390 --> 00:47:37,140
xv6 has some function that models the page table walk,

510
00:47:37,140 --> 00:47:41,220
because once in a while you know xv6 basically has to do what the hareware does,

511
00:47:42,040 --> 00:47:48,670
and so it also it does have a function called walk, that basically does exactly the same thing, but in software.

512
00:47:51,370 --> 00:47:53,380
So, can I ask a question,

513
00:47:54,520 --> 00:48:00,170
so where in this scheme does the processor cache [fit],

514
00:48:00,170 --> 00:48:04,070
does it happen before the address translation or after.

515
00:48:04,520 --> 00:48:10,580
Yeah, yeah okay, let me, so let's switch back a little bit a couple, let me see.

516
00:48:13,120 --> 00:48:17,410
Okay, usually MMU will really the way to think about is,

517
00:48:17,410 --> 00:48:22,650
that all this stuff you know the whole block is inside the processor silicon.

518
00:48:24,350 --> 00:48:27,920
So there's a RISC-V chip and inside of it is the CPU,

519
00:48:27,920 --> 00:48:32,030
in fact there are multiple CPU, correct, four cores and there's a MMU

520
00:48:32,240 --> 00:48:37,580
and you know you can think about that, either on this on the CPU side, you know there's a TLB.

521
00:48:41,330 --> 00:48:41,960
Okay?

522
00:48:44,450 --> 00:48:48,290
That makes sense, but I guess my question was about the like,

523
00:48:48,680 --> 00:48:53,960
cache in terms of not the TLB, but just a normal cache,

524
00:48:53,960 --> 00:48:57,740
like, because sometimes we don't actually go all the way to access the memory.

525
00:48:58,010 --> 00:49:02,060
Yeah good point, I think I showed like the scheme last [week] correct on Monday

526
00:49:02,060 --> 00:49:05,540
of the RISC-V processor and has l1 cache, it has l2 cache,

527
00:49:05,910 --> 00:49:11,420
some caches are indexed by physical address, some caches are indexed by virtual address,

528
00:49:11,900 --> 00:49:15,950
so the caches that are indexed by virtual address sit before the MMU,

529
00:49:16,560 --> 00:49:19,620
and cache their index by physical addresses after the MMU.

530
00:49:25,020 --> 00:49:25,590
Does that make sence?

531
00:49:25,800 --> 00:49:28,830
Can I also ask a question, my question is,

532
00:49:28,860 --> 00:49:32,880
you said that the TLB, it walks,

533
00:49:32,880 --> 00:49:38,490
so like to put stuff into TLB, the hardware walks through the page tables,

534
00:49:39,850 --> 00:49:43,720
why do we write walk function, if hardware can do that.

535
00:49:44,580 --> 00:49:51,360
Very good question, one reason, a couple reasons why we do it or why xv6 needs it,

536
00:49:51,360 --> 00:49:54,060
one is when it actually sets up the initial page tables,

537
00:49:54,980 --> 00:50:01,310
you know it needs to program the the three levels and so it needs to basically emulate the three levels.

538
00:50:02,120 --> 00:50:09,620
And other example, that you actually sort of run into or are running into in the syscall lab,

539
00:50:09,800 --> 00:50:11,270
is that when you copy,

540
00:50:11,420 --> 00:50:17,480
the in xv6 the kernel has its own page table and every user address space has its own page table,

541
00:50:18,140 --> 00:50:25,250
and with once in a while, for example sysinfo you know like, the point of sysinfo struct that lives in user space,

542
00:50:25,460 --> 00:50:29,570
the kernel needs to be translated to an address that it can use to read and write it.

543
00:50:30,340 --> 00:50:34,420
And so, for example if you're looking copyin or copyout,

544
00:50:34,750 --> 00:50:45,790
basically the kernel translates the user virtual address using the user virtual, using the user page table to get out of physical address,

545
00:50:45,790 --> 00:50:52,030
that kernel then get an address out actually then the kernel can use to read and write that memory.

546
00:50:54,570 --> 00:50:59,730
So there's a bunch of places where to show up and I'll talk about hopefully in whatever ten minutes fifteen minutes.

547
00:51:00,610 --> 00:51:06,430
I have a question, why doesn't the hardware like expose that walk function,

548
00:51:06,430 --> 00:51:09,130
so we don't have to write our own and potentially have bugs in it,

549
00:51:09,430 --> 00:51:15,970
why isn't there like you know maybe a privileged instruction that you can pass a virtual address and will give back the physical address.

550
00:51:16,380 --> 00:51:21,300
Well, this is just like just store to the virtual address, and you get the back and will do it right for you,

551
00:51:21,780 --> 00:51:27,720
so we'll see later on, in the next lab, the page table lab,

552
00:51:27,900 --> 00:51:32,250
in fact that's exactly what you'll be doing, you'll actually set up the page table slightly differently,

553
00:51:32,250 --> 00:51:36,750
so that you can avoid the walk in copy in and copyinstr.

554
00:51:42,500 --> 00:51:46,730
I think this will become clear in a second that we when we talk about we look at the xv6. Okay?

555
00:51:49,700 --> 00:51:51,170
Okay, good.

556
00:51:51,800 --> 00:51:58,100
One more extra, basically before jumping into xv6, I wanted to make one point,

557
00:51:58,610 --> 00:52:04,000
one way to think about you know, page tables,

558
00:52:05,980 --> 00:52:14,520
a popular way to phrase this, page tables provide a level of indirection,

559
00:52:19,670 --> 00:52:31,070
and, and that, and so basically this indirection, what I'm talking about, you know this mapping from virtual address to physical address,

560
00:52:31,520 --> 00:52:36,230
and this mapping is completely under control of the operating system,

561
00:52:38,350 --> 00:52:41,980
as we've seen, you know in the last couple slides, we talk,

562
00:52:42,280 --> 00:52:49,270
and that means that the operating system, because it has so much control over it, has control, complete control that translation,

563
00:52:49,480 --> 00:52:51,940
it can do all kinds of interesting tricks.

564
00:52:52,630 --> 00:52:56,860
And so for example like one trick, you know we'll talk a little bit about this,

565
00:52:56,860 --> 00:53:04,270
like if a page entry is invalid and will really return a page, you know the hardware will a raise page fault.

566
00:53:04,820 --> 00:53:10,910
In response, the page fault, the operating system could update the page tables and then maybe restart the instruction.

567
00:53:11,610 --> 00:53:18,630
And so there are all kinds of things they can do at run time by manipulating the page tables.

568
00:53:19,160 --> 00:53:26,480
And we're not going to talk about it today, but in two weeks, we'll have a lecture exactly about this topic,

569
00:53:26,480 --> 00:53:30,290
about what cool things can you do once you have page tables and page faults.

570
00:53:31,140 --> 00:53:38,250
But it's important to keep in mind that this is an incredibly powerful mechanism,

571
00:53:38,520 --> 00:53:42,510
that will provide the operating system with tremendous amount of flexibility.

572
00:53:43,410 --> 00:53:46,320
And this is one reason why page tables are so popular.

573
00:53:49,490 --> 00:53:53,750
Okay, so what I wanna do next, is actually talk about xv6,

574
00:53:54,580 --> 00:53:59,080
and sort of see how it all plays out in xv6.

575
00:53:59,610 --> 00:54:05,700
So the first thing, I'm gonna do, is going to look at the kernel page layout, if you will,

576
00:54:05,730 --> 00:54:09,870
and the mapping is on this slide,

577
00:54:10,410 --> 00:54:21,610
so here's the virtual address space of the kernel,

578
00:54:23,440 --> 00:54:28,330
and here is actually the physical memory, so this is basically whatever you can think about this is DRAM,

579
00:54:31,760 --> 00:54:35,690
and in fact it is not, let me take that back immediately,

580
00:54:35,870 --> 00:54:41,200
one part is DRAM, and one part is actually IO devices.

581
00:54:46,060 --> 00:54:52,030
And so, to sort of maybe I'm going to talk about the physical, the right side of the slide a little bit first

582
00:54:52,030 --> 00:54:53,740
and then we'll talk about the left side in the second.

583
00:54:54,360 --> 00:54:58,290
So the right side of the slide is completely determined by the hardware,

584
00:54:58,940 --> 00:55:02,900
and so the hardware designers, basically determine the layout of that is

585
00:55:02,960 --> 00:55:10,850
and you know as you saw before last week, when the kernel starts, it starts at this address 0x8000,

586
00:55:11,720 --> 00:55:14,840
and that's determined by the hardware designers,

587
00:55:15,140 --> 00:55:20,420
and so you should be more explicit, if you look at the board,

588
00:55:20,510 --> 00:55:26,240
this is the same picture of the board that I showed on Monday, but is hopefully a little better picture, it's easier to see,

589
00:55:26,300 --> 00:55:31,570
here's our RISC-V processor, and we now know correct in the RISC-V processor, there four cores,

590
00:55:31,600 --> 00:55:35,470
but there's also a MMU and there's also a TLB

591
00:55:35,470 --> 00:55:40,150
or multiple TLB every core has its own, and MMU and every core has its own TLB.

592
00:55:40,800 --> 00:55:47,680
And here are DRAM chips, and so basically the designers of the board have decided that,

593
00:55:47,890 --> 00:55:53,110
when you know after you know the translation from virtual to physical address,

594
00:55:53,200 --> 00:55:59,440
basic physical addresses that's starting you know at o eight you know a lot of zeros, actually go to the DRAM chips.

595
00:56:00,660 --> 00:56:04,740
Addresses below 0x8000, may go to different IO devices.

596
00:56:05,260 --> 00:56:12,130
And so the platform decides basically the designers this board have decided exactly what the physical layout.

597
00:56:12,770 --> 00:56:17,210
I think you can look that up the physical layout, if you want to, just let me show you,

598
00:56:17,210 --> 00:56:25,670
so here's the same manual that I showed you on on the Monday

599
00:56:25,730 --> 00:56:32,140
and if you go to actually go to page 31, I believe.

600
00:56:32,810 --> 00:56:36,140
Yeah, it's the page and if you go down,

601
00:56:36,140 --> 00:56:41,900
this is what's the memory, it will [spell] out the memory map is of the board

602
00:56:42,170 --> 00:56:45,470
and we'll see at address zero zero is reserved nothing is there,

603
00:56:46,000 --> 00:56:54,100
if you go scroll down in this memory map, you'll see some information about all the different things that are mapped,

604
00:56:54,100 --> 00:56:59,200
for example Ethernet board is mapped at 0 x one you know 0x something,

605
00:57:00,010 --> 00:57:04,720
if you go further down, oops, too much down,

606
00:57:05,020 --> 00:57:14,800
here you see the entry for 0x8000 correct and that actually is DDR memory, the Off-Chip Volatile Memory,

607
00:57:15,010 --> 00:57:18,010
so those are the DRAM chips, I just showed you on the previous slide.

608
00:57:19,520 --> 00:57:24,200
And so it's just good to keep your head correct, even though we're talking to QEMU, you know using software,

609
00:57:24,230 --> 00:57:28,100
in the end everything is determined by you know the actual board.

610
00:57:30,640 --> 00:57:38,150
Okay, so go back to my slides, so let's look at the layout.

611
00:57:38,180 --> 00:57:39,890
Yeah, Noah, go ahead.

612
00:57:41,360 --> 00:57:44,330
Yeah, when you say that this this layout is determined by the hardware,

613
00:57:44,330 --> 00:57:50,720
do you specifically mean like the CPU itself or the the board on which the CPU resides.

614
00:57:50,780 --> 00:57:52,700
The board in which the CPU resides, correct,

615
00:57:52,700 --> 00:57:59,210
because you know the board, you know the CPU is that grey thing in the middle that square thing, saying whatever RISC-V,

616
00:57:59,450 --> 00:58:04,430
the DRAM chips are sitting off off the processor, correct,

617
00:58:04,430 --> 00:58:09,950
it's the board designers who put the chip the DRAM, you know the many IO devices altogether.

618
00:58:11,580 --> 00:58:12,030
Got it, thank you.

619
00:58:12,030 --> 00:58:14,550
A large part of an operating system is actually

620
00:58:14,550 --> 00:58:18,390
you know CPU is one part, but the IO devices are at least as important, right

621
00:58:18,390 --> 00:58:23,670
and so when you're writing an operating system, you both have to deal with the CPU as well as you know with the IO devices,

622
00:58:23,670 --> 00:58:25,680
you know [if] you want to send a packet over the Internet,

623
00:58:25,920 --> 00:58:31,980
well, somebody has to, take, you know the network driver, the NIC card to actually do that,

624
00:58:31,980 --> 00:58:32,970
and that's the operating system.

625
00:58:35,430 --> 00:58:40,350
So going back to the right side of this picture correct, which is the physical address layout,

626
00:58:40,530 --> 00:58:45,390
you know we see basically the bottom was unused as I showed you on that document,

627
00:58:45,720 --> 00:58:50,040
it turns out that 0x1000 that physical address, that's where the boot ROM is,

628
00:58:50,040 --> 00:58:55,470
so when you turn on you know that board, the first thing that happens is actually code in the boot ROM runs.

629
00:58:55,930 --> 00:59:00,310
And when the boot ROM is done, it actually will jump to this [0x8000]

630
00:59:00,490 --> 00:59:04,690
and it's job of the operating system make sure that there's some, you know some data there.

631
00:59:05,430 --> 00:59:08,280
And then there's a bunch of other devices that we'll talk about,

632
00:59:08,280 --> 00:59:13,020
there is the interrupt controller, we'll talk about it next week,

633
00:59:13,500 --> 00:59:19,290
there's a CLINT, another part of the interrupt [story], that we'll talk about next week,

634
00:59:19,470 --> 00:59:21,960
so basically multiple devices can generate interrupts,

635
00:59:21,960 --> 00:59:26,760
there needs to be planned to route those interrupts to to the appropriate request level,

636
00:59:26,760 --> 00:59:30,000
and that's all implemented by those interrupt controllers.

637
00:59:30,530 --> 00:59:35,690
And let me finish, for a second, you know this, this slide before answer your question.

638
00:59:36,980 --> 00:59:46,850
Then there's a UART, that was the device, that was actually, the thing that actually, the device actually UART device, that actually interacts with the console and the display

639
00:59:47,090 --> 00:59:54,680
and then there's the VIRTIO_disk and that's the device, there's a device belong, it's that actually interacts with the disk

640
00:59:54,860 --> 01:00:03,720
and so when you write to location to address, let's say 0x2000, then, that physical address corresponds to the CLINT

641
01:00:03,810 --> 01:00:12,330
and so when you want to do store instruction, load instruction, you're reading and writing to the chip, that implements the CLINT,

642
01:00:13,190 --> 01:00:16,130
we'll see later what that exactly means, but basically you can think about

643
01:00:16,130 --> 01:00:19,820
this as interacting directly with the device and not reading or writing physical memory.

644
01:00:21,780 --> 01:00:22,650
Yeah, there's a question.

645
01:00:24,240 --> 01:00:32,370
So just trying to make sure the addresses below 0x8000, they don't really exist in DRAM,

646
01:00:33,660 --> 01:00:37,170
if when we mention those addresses, we directly go to the other hardwares.

647
01:00:37,200 --> 01:00:39,900
Yeah, yeah, so if you go back to this picture,

648
01:00:40,350 --> 01:00:46,660
anything above 0x8000, correct, that's these DRAM chips.

649
01:00:48,020 --> 01:00:54,710
And you know I can't draw, I can't point you to the CLINT, but like generally here is Ethernet,

650
01:00:55,980 --> 01:01:01,590
and so that's particular physical address and we can write you know load store instructions is called memory mapped IO,

651
01:01:01,800 --> 01:01:05,340
we can load and store instructions, we can program Ethernet controller.

652
01:01:09,340 --> 01:01:16,780
I also have a question, why was this big chunk at the top says unused, why is it not used.

653
01:01:17,110 --> 01:01:27,320
Oh Okay, so remember not every machine, not every, so there's 2 to the power 56 bytes physical address space,

654
01:01:27,770 --> 01:01:32,300
but you don't have those you know plugin that much memory into the board, if you don't want to,

655
01:01:32,940 --> 01:01:38,270
and so some parts of it may be unused, depending on how much you know DRAM chips actually sitting on the board.

656
01:01:42,300 --> 01:01:51,190
In fact, like in xv6, we I think limit ourselves to 128 megabyte and no more.

657
01:01:55,360 --> 01:02:03,070
So when a, when a load or store instruction goes out of the CPU,

658
01:02:03,100 --> 01:02:09,960
does that go like where does it get routed to the correct IO, like already from the CPU,

659
01:02:10,140 --> 01:02:13,590
so kind of like if the CPU before it sends it out,

660
01:02:13,590 --> 01:02:20,310
it says OK, if it's lower than zero x eight and all the zeros, then I'm going to send it to the correct IO device,

661
01:02:20,310 --> 01:02:26,580
and then otherwise I'm gonna send it to the to the memory like the DRAM chip.

662
01:02:27,050 --> 01:02:32,900
Yeah you know, you can think about as a demultiplexer sitting on the inside of the RISC-V block.

663
01:02:33,230 --> 01:02:36,180
Oh, it's also inside of that block, Okay.

664
01:02:38,140 --> 01:02:41,170
And the memory controller and does a routing.

665
01:02:44,750 --> 01:02:47,420
Good, very important to have that sort of all clear in your head.

666
01:02:51,430 --> 01:02:55,150
Are we, okay, so now I want to switch to the left side of this picture,

667
01:02:55,630 --> 01:03:02,560
and this is basically what xv6 sets up to the virtual address space that xv6 sets up,

668
01:03:02,560 --> 01:03:06,640
so when the machine boots, there's no page enable yet,

669
01:03:06,760 --> 01:03:12,310
xv6 sets up the first page tables the first virtual address space

670
01:03:12,310 --> 01:03:16,770
and that's actually the virtual address space, the kernel uses and we'll look at it in the second at the code,

671
01:03:17,100 --> 01:03:19,410
but, and this is the layout

672
01:03:19,440 --> 01:03:25,650
and it turns out you know, because we want to keep xv6 as simple as possible, it's easy for you to understand,

673
01:03:25,980 --> 01:03:32,430
the mapping from virtual to physical is mostly in identity mapping.

674
01:03:38,120 --> 01:03:46,190
So basically what that means is that the virtual address 0x2000 mapped to physical address 0x2000,

675
01:03:46,280 --> 01:03:49,610
so the kernel will set up the page tables exactly in that way,

676
01:03:49,880 --> 01:03:54,830
and so that means basically that you know all virtual addresses below PHYSTOP,

677
01:03:55,810 --> 01:04:02,620
which is the top of physical memory are identical to the physical addresses that are actually being used on the right side.

678
01:04:03,170 --> 01:04:07,220
And so this is why all the arrows are straight, because it's identity mapping.

679
01:04:09,290 --> 01:04:09,860
Okay?

680
01:04:10,830 --> 01:04:16,680
There are small changes to this, there two important things to mention.

681
01:04:17,620 --> 01:04:19,930
Amiar hold on a second.

682
01:04:19,930 --> 01:04:23,020
Well I try to first mention the two important things to mention,

683
01:04:23,500 --> 01:04:35,040
first of all, there's some pages, some maps very high up in memory, some pages very high in memory,

684
01:04:35,070 --> 01:04:42,030
for example the stack, kernel stack actually sets up, is also map high up in memory.

685
01:04:42,500 --> 01:04:47,330
And the reason is high up in memory, is because we have a guard page below it, that is not mapped.

686
01:04:47,840 --> 01:04:55,190
So the PTE entry below the kernel stack, of one of the kernel stack [] does have not have it's valid bit set.

687
01:04:55,700 --> 01:05:01,550
And, so if you know the kernel runs off its stack and will result in a page fault,

688
01:05:01,820 --> 01:05:05,900
which is better than basically scribbling over some other memory that the kernel has,

689
01:05:06,080 --> 01:05:08,870
you get an immediate panic, you know that something's bad to stack.

690
01:05:10,820 --> 01:05:16,700
Of course, we don't want to waste physical memory and so when we do that by basically putting the stack high,

691
01:05:16,940 --> 01:05:22,100
and a guard page, an empty guard PTE entry below it,

692
01:05:22,600 --> 01:05:26,770
and the guard page doesn't really consume any physical memory right,

693
01:05:26,770 --> 01:05:30,490
sitting high up in the virtual address space, so nothing is being consumed.

694
01:05:31,190 --> 01:05:34,970
But that means, that they're showing this case, stack page, for example is mapped twice,

695
01:05:35,360 --> 01:05:41,180
it's mapped at a high address and it's map directly by one of the addresses that below PHYSTOP.

696
01:05:42,590 --> 01:05:48,230
And so you can do, this is one example of all the sort of cool things you can do with page tables,

697
01:05:48,230 --> 01:05:52,490
you can map a physical address twice, you cannot map a physical address,

698
01:05:52,610 --> 01:05:58,340
you know it can be one to one mapping, one to many mapping, many to one mapping, all that kind of stuff is possible,

699
01:05:58,930 --> 01:06:03,640
xv6 does really, use many of them, but there's a couple places we use those tricks

700
01:06:03,850 --> 01:06:10,900
and stacking the guard page is one example of one of the cool trick that xv6 uses, mostly to track down bugs.

701
01:06:12,880 --> 01:06:15,730
The second thing I wanted to mention is that the permissions.

702
01:06:16,590 --> 01:06:23,550
So, for example the kernel text, the pages for the kernel text are mapped R-X, meaning you can read it and execute it,

703
01:06:23,760 --> 01:06:29,280
but you cannot write to kernel text and again this is basically avoid bugs, so that we catch them early,

704
01:06:29,430 --> 01:06:34,020
kernel data of course needs to be able to be written to and so it has mapped read write,

705
01:06:34,230 --> 01:06:42,480
but you cannot execute out of kernel data pages instructions, so the execute bit is not set.

706
01:06:45,950 --> 01:06:46,790
Does that make sense?

707
01:06:48,000 --> 01:06:52,890
I skip one or two questions, so if these questions are still not answered, you know please ask them.

708
01:06:55,790 --> 01:06:58,010
We have a question in the chat,

709
01:06:58,620 --> 01:07:04,350
do we have multiple kernel stacks for different processes like we have n kstacks for n processes.

710
01:07:06,790 --> 01:07:14,720
The answer is yes so every process every user process has a corresponding kernel stack, we'll see that in a little bit later.

711
01:07:17,350 --> 01:07:17,980
Okay?

712
01:07:19,160 --> 01:07:21,290
Okay, so let me.

713
01:07:21,320 --> 01:07:22,250
Amair, go ahead.

714
01:07:24,010 --> 01:07:32,130
So what's the virtual memory of another application map to somewhere in the physical memory in the unused space or.

715
01:07:32,430 --> 01:07:37,470
Yes, very good points, so there's a bunch of physical memory, correct,

716
01:07:37,470 --> 01:07:42,190
here's free memory, that's free memory here too, right,

717
01:07:42,610 --> 01:07:50,050
and we use that, xv6 use that free memory to basically store pages of page tables, user processes

718
01:07:50,200 --> 01:07:54,550
as well as you know the text and data of user level processes.

719
01:07:55,780 --> 01:07:58,480
And if we are on many many, many user processes at some point,

720
01:07:58,480 --> 01:08:03,040
we'll run out of free memory, and then basically fork or exec will return an error.

721
01:08:04,900 --> 01:08:11,890
But that means that the virtual space for process are much smaller than the virtual space for the kernel, right?

722
01:08:12,540 --> 01:08:18,660
Well, the virtual spaces as the same as the same size in principle, but it will be less [populated].

723
01:08:22,520 --> 01:08:26,480
Then let me, let's look at some code and I think that all this stuff becomes a bit more clear.

724
01:08:27,690 --> 01:08:31,020
I just want small thing is,

725
01:08:31,020 --> 01:08:38,040
so given that a lot of the like, each process has a big part of the memory map to the same location,

726
01:08:38,130 --> 01:08:44,550
is that optimized by like consolidating that into one place that mapping or no.

727
01:08:44,580 --> 01:08:47,280
Good, xv6 does not do that,

728
01:08:47,370 --> 01:08:52,380
like one of the challenge exercises in the page table lab is to actually implement that.

729
01:08:54,540 --> 01:08:55,020
I see.

730
01:08:55,170 --> 01:09:01,020
The real operating system would do that, yeah, very good question.

731
01:09:02,320 --> 01:09:05,950
I think you get a sense of, well all kinds of things are possible, once you have page tables.

732
01:09:08,800 --> 01:09:14,850
Okay, so let's do the usual thing, boot xv6 again,

733
01:09:14,850 --> 01:09:20,980
and again you know QEMU uses basically implementing the board, and you know let's.

734
01:09:21,670 --> 01:09:27,800
Oops, -gdb.

735
01:09:29,930 --> 01:09:33,710
Last time, we looked at how the booting happens correct

736
01:09:33,710 --> 01:09:44,600
and then we got to main and then basically one of the things that the kernel, where one of the function is called kvminit and that actually sets up the address space for the kernel.

737
01:09:45,100 --> 01:09:49,330
And so we saw in the picture where in the previous slide, what that you know looks like

738
01:09:49,330 --> 01:09:52,390
and here we go, see C code how it actually is being set up.

739
01:09:58,380 --> 01:10:03,750
And, why, hold on, something's not going as I wanted to.

740
01:10:04,350 --> 01:10:06,720
Am I in the right directories.

741
01:10:11,120 --> 01:10:14,210
Hold on a second here while I'm trying to sort out my problems.

742
01:10:16,590 --> 01:10:23,390
That is good, I mean the right directories.

743
01:10:23,420 --> 01:10:26,450
Yeah, -gnu -gdb.

744
01:10:28,080 --> 01:10:35,640
I want set a breakpoint for the main just to make sure, good and then I set a breakpoint at kvminit.

745
01:10:36,340 --> 01:10:37,840
Actually I can just step to it now,

746
01:10:38,430 --> 01:10:42,480
next consoleinit, printfinit, we saw it before,

747
01:10:43,250 --> 01:10:45,080
physical memory allocator,

748
01:10:47,040 --> 01:10:59,120
and, you know something happens that I am not expecting, what is going on.

749
01:11:02,660 --> 01:11:04,610
We're run is right before lecture.

750
01:11:04,610 --> 01:11:11,140
Ah here, that's what's going on, actually printing, okay, interesting.

751
01:11:11,620 --> 01:11:15,580
Okay, one more time, see if I can get lucky more, oops.

752
01:11:19,280 --> 01:11:20,360
[].

753
01:11:28,890 --> 01:11:33,670
Continue, hopefully it will get there, wait a little bit.

754
01:11:33,670 --> 01:11:35,530
Okay, great, we're at the kvminit,

755
01:11:35,860 --> 01:11:40,660
so basically we're now this function here, on the right side in the emacs buffer, you can see it.

756
01:11:41,260 --> 01:11:48,540
And, I think I've modified the function slightly, I hope I did.

757
01:11:53,140 --> 01:11:55,450
I think I did, well we'll see,

758
01:11:55,900 --> 01:11:59,350
and what we knew is going to walk step into the function,

759
01:12:00,070 --> 01:12:03,070
use the layout split, just eaiser to see.

760
01:12:03,650 --> 01:12:09,200
And this is the first thing that you can see is actually the kernel actually allocates a physical page for the top level page directory,

761
01:12:10,090 --> 01:12:14,560
and then it zeroes it out, so that all the PTE entries are zero.

762
01:12:15,360 --> 01:12:21,000
And then basically starts mapping in every device, IO device one by one.

763
01:12:21,630 --> 01:12:27,960
And so, for example the UART0 basically starts mapping maps that into the kernel address space

764
01:12:27,960 --> 01:12:30,930
and so we can look at a file called memlayout,

765
01:12:31,320 --> 01:12:37,350
is basically translate the page 31 that I showed you from the documents into a bunch of constants that we're using.

766
01:12:38,020 --> 01:12:46,650
And so, for example here it says what the address of 0x1000 is, what the UART0 address.

767
01:12:47,140 --> 01:12:55,300
And so, you know we can basically map it into the address space by calling this function kvmmap which I will look in a second.

768
01:12:56,040 --> 01:13:03,810
And then, in the first exercise of the page table lab, you are asked to implement a function called vmprint,

769
01:13:04,320 --> 01:13:08,010
and I implemented it too and I'm going to step over it

770
01:13:08,010 --> 01:13:16,700
and we'll see basically a page tables, kernel page table as it is set up after that one call to kvmmap,

771
01:13:16,730 --> 01:13:19,520
so I'm gonna do that, and going to print out something.

772
01:13:20,240 --> 01:13:22,160
And so we're going to look a little bit of the output here,

773
01:13:22,160 --> 01:13:30,200
so here's the page table that is the physical address of the top level page directory,

774
01:13:30,200 --> 01:13:33,770
so the thing that actually sits in satp, or will sit in satp.

775
01:13:34,600 --> 01:13:38,890
And then we have a entry zero of the top level page directory,

776
01:13:38,890 --> 01:13:48,000
has one PTE entry in it, and that is the, contains the physical address for the middle level page table directory,

777
01:13:48,580 --> 01:13:55,180
the middle page level directory has one entry namely 128 and that points to the bottom of the page table directory

778
01:13:55,180 --> 01:13:58,900
and the bottom page table directory has the entry then for the physical page.

779
01:13:59,420 --> 01:14:07,430
And you can see, indeed that the physical address, you know for that bottom level is 0x1000 corresponding to UART0.

780
01:14:08,900 --> 01:14:15,620
So basically virtual address 1000 translates to physical address [1000].

781
01:14:16,560 --> 01:14:21,270
And we can check double check that this is indeed all legit, right,

782
01:14:21,270 --> 01:14:30,720
by, let's take that address, that 0x10000000L and we're going to shift 12,

783
01:14:31,700 --> 01:14:38,420
and that should be, you know that gives the top level 27 bits,

784
01:14:39,070 --> 01:14:50,690
we shift 9, so I'm gonna take 0x10000 one zero zero zero, one zero, one more and we're gonna shift 9, print that,

785
01:14:53,010 --> 01:14:59,700
and that is 0x80 and actually print 0x80 as a decimal decimal number, it's going to be 128.

786
01:15:01,110 --> 01:15:01,710
Okay?

787
01:15:02,310 --> 01:15:05,370
So we see actually sort of you know it all sort of makes sense.

788
01:15:05,900 --> 01:15:09,440
We also see I printed out the flags here,

789
01:15:09,440 --> 01:15:19,520
and you know the bottom level has read, write and valid, because valid is one. Any questions about this?

790
01:15:24,760 --> 01:15:32,970
Okay, so the kernel basically proceeds you know doing setting up the whole address space in this way.

791
01:15:33,820 --> 01:15:38,860
And so we've called kvmmap for VIRTIO, for the CLINT, for the PLIC,

792
01:15:39,440 --> 01:15:44,300
maps the kernel text, maps the kernel memory or kernel data,

793
01:15:44,480 --> 01:15:46,880
and then the TRAMPOLINE page, that we'll talk about next week.

794
01:15:47,460 --> 01:15:53,550
And so in fact we can single step through this and then see what the final page directory looks like.

795
01:15:55,610 --> 01:15:58,520
So, next next next next.

796
01:15:59,330 --> 01:16:03,650
Basically, you know set the trampoline, so now we're going to print the complete page table directory.

797
01:16:04,220 --> 01:16:11,420
And you know we see basically a lot of PTE is actually being set up,

798
01:16:11,810 --> 01:16:14,690
and I'm not going to talk about in any detail,

799
01:16:14,870 --> 01:16:23,260
you know basically fills out the page directory to actually create a virtual mapping mapping that we basically saw in the previous slide.

800
01:16:24,810 --> 01:16:29,070
I expect, what I wanna do next is actually much more interesting.

801
01:16:29,690 --> 01:16:30,860
Yeah, I'm gonna.

802
01:16:32,270 --> 01:16:35,330
Yeah, I wanna go here actually, maybe already did this,

803
01:16:35,360 --> 01:16:39,170
there 21, no, I'm 21, okay so single step that.

804
01:16:40,550 --> 01:16:47,620
Okay, that's too bad I got past it, but basically, let me, let me restart this.

805
01:16:51,080 --> 01:17:01,660
And I wanna breakpoint at kvminithart, and continue.

806
01:17:03,680 --> 01:17:10,280
Now I'm here at kvminithart and you see here basically that will writing the satp register,

807
01:17:10,310 --> 01:17:18,560
so basically the kernel is going to enable the page table or the MMU, to basically start using the page table that we just set up.

808
01:17:19,470 --> 01:17:25,470
And one interesting question, okay, so let me go out layout split again,

809
01:17:26,020 --> 01:17:33,730
so, somewhere here correct is going to be, here's the instruction

810
01:17:33,940 --> 01:17:41,240
and so, once, something really dramatic happens after executing this instruction.

811
01:17:42,280 --> 01:17:46,360
Let's say yeah you know can say the same instruction exactly,

812
01:17:46,360 --> 01:17:53,200
but there's this this once this instruction is executed what will happen with the next address that's being translated.

813
01:17:58,310 --> 01:18:06,050
Well, at the point that we execute this instruction, before executing this instruction, there's no page tables enabled yet, so no translation happens,

814
01:18:06,410 --> 01:18:12,080
with the next and then the program counter is updated by four, and then the next instruction is executed

815
01:18:12,110 --> 01:18:16,220
and the program counter will be translated using the virtual page page table memory.

816
01:18:17,140 --> 01:18:21,280
And so this is a way to think about this, this is a dramatic moment,

817
01:18:21,610 --> 01:18:25,360
because basically the whole address translation they started to enable

818
01:18:25,360 --> 01:18:29,870
and every address needs you know maybe potentially something different, right,

819
01:18:29,870 --> 01:18:34,760
because before we're running, use physical addresses, then the page table haven't install and whatever is in the mapping,

820
01:18:34,760 --> 01:18:37,340
now there's the new meaning of a virtual address.

821
01:18:38,680 --> 01:18:42,820
And here's how this works out, you know the fact that this actually works out is remarkable,

822
01:18:42,820 --> 01:18:47,650
because like the next instruction, the next value is a virtual address and not a physical address,

823
01:18:48,700 --> 01:18:52,090
next instruction is going to be this, whatever 0x80001110.

824
01:18:52,760 --> 01:18:54,050
And why does this work out.

825
01:18:55,960 --> 01:18:59,650
Well, the reason works out is, because the kernel is set up with identity page mapping,

826
01:18:59,710 --> 01:19:03,510
so after we enable the virtual paging hardware,

827
01:19:03,750 --> 01:19:08,100
we actually you know this translator will translate again to the same physical address,

828
01:19:08,250 --> 01:19:12,870
so indeed we'll actually end up executing the right instruction,

829
01:19:12,960 --> 01:19:17,520
because that's actually exactly the instruction, that the memory location that the virtual hardware is programmed.

830
01:19:19,120 --> 01:19:20,170
So does this make sense?

831
01:19:22,920 --> 01:19:27,060
Again, one reason why programming virtual memory is difficult is,

832
01:19:27,060 --> 01:19:34,230
because once you execute one of these satp instructions, you know load a page table in the satp register,

833
01:19:34,260 --> 01:19:36,180
your world completely changes.

834
01:19:36,690 --> 01:19:40,350
And every address is now translated with the page able that you set up.

835
01:19:41,560 --> 01:19:46,990
And so what happens if the page table set up incorrectly, what would you, what might happen.

836
01:19:53,660 --> 01:19:57,880
Anybody who wants to say that answer or answered in the chat, either way.

837
01:20:00,510 --> 01:20:02,250
You could override kernel data.

838
01:20:02,980 --> 01:20:05,020
Yeah, you could overwrite kernel data, what else could happen,

839
01:20:05,020 --> 01:20:12,010
yeah, page fault, basically the mapping may be incorrect and basically the address can't be translated at all,

840
01:20:12,010 --> 01:20:16,480
and so the kernel can, you know the hardware won't do it and usally the kernel just stops and panics.

841
01:20:18,770 --> 01:20:19,610
Does that make sense?

842
01:20:21,000 --> 01:20:27,830
If you get a bug in your page tables, you know you're going to see these are errors or crashes.

843
01:20:28,720 --> 01:20:29,920
And so, one reason that,

844
01:20:29,920 --> 01:20:35,980
for example the next lab, the page table lab that will hand out or release tonight is gonna be hard,

845
01:20:35,980 --> 01:20:37,630
because those kind of bugs will show up,

846
01:20:38,200 --> 01:20:42,130
if you're not carefully enough or you haven't fully internalized some aspect yet

847
01:20:42,520 --> 01:20:46,690
and you're basically going to get a kernel crash and you're gonna have a hard time

848
01:20:46,690 --> 01:20:52,000
when you will take a little bit of time and energy on detective work to basically track down why that happened.

849
01:20:53,370 --> 01:20:57,640
And that's just the, that's just hard of like programming virtual memory,

850
01:20:58,320 --> 01:21:04,680
because it's such a powerful [primitive], you know you get wrong, you're going to have powerful consequences.

851
01:21:08,090 --> 01:21:13,160
Yet, the other hand is great amount of fun, so I don't want to end on a negative [note],

852
01:21:13,310 --> 01:21:18,590
but all that will give you sort of real understanding of actually what really virtual memory is and what it can do.

853
01:21:20,180 --> 01:21:22,760
Okay, I think I'm running out of time, so I'm gonna stop here,

854
01:21:22,820 --> 01:21:25,820
so people have time to go to the next class or next activity,

855
01:21:26,060 --> 01:21:30,470
but if you have any questions left you know please hang on and ask them.

856
01:21:31,440 --> 01:21:38,130
And, we'll see you on Monday, and good luck with finishing the syscall lab.

857
01:21:40,920 --> 01:21:43,860
Um, hi I have a question about walk,

858
01:21:44,190 --> 01:21:53,720
so it says and in the code, it returns the, like the first tables of PTE, right,

859
01:21:53,960 --> 01:22:03,460
but how does it work, then like the other functions when they expect the actual PTE than like the physical address.

860
01:22:05,680 --> 01:22:11,620
Yeah, basically this returns the PTE entry in the page table, right.

861
01:22:12,140 --> 01:22:19,000
And the kernel could read or write page table entries, and so now you can stick values into the PTE.

862
01:22:21,180 --> 01:22:25,680
And so maybe I can draw a picture, that is helpful.

863
01:22:26,330 --> 01:22:26,900
Let's see.

864
01:22:35,770 --> 01:22:37,690
So, basically we have a page directory,

865
01:22:45,000 --> 01:22:48,130
and you know this walk code,

866
01:22:48,130 --> 01:22:58,910
so the page directory has 512 PTEs in it, here's 0, here's 511,

867
01:22:59,570 --> 01:23:05,120
and basically what the function does, it returns the pointer to one of these PTEs,

868
01:23:06,040 --> 01:23:09,520
and so that's just a virtual address, and it points to that particular PTE.

869
01:23:10,210 --> 01:23:15,490
And now the kernel can you know manipulate that PTE by whatever writing values to it,

870
01:23:16,020 --> 01:23:22,130
like some physical address, maybe with some permissions or into it for the bottom ten bits.

871
01:23:23,730 --> 01:23:29,340
And then basically updates the page table directory and later on when you load that into satp,

872
01:23:29,880 --> 01:23:32,490
now that affect that change will go into affect.

873
01:23:35,350 --> 01:23:36,250
Does that make sense?

874
01:23:37,180 --> 01:23:38,110
Yeah, that makes sense.

875
01:23:38,110 --> 01:23:47,620
I guess I just confused like why does it do the work of going all the way to the third page table and then only return the first PTE.

876
01:23:47,890 --> 01:23:53,430
No, return actually is the bottom one, actually, let me be careful,

877
01:23:55,350 --> 01:24:00,930
if you know it goes through the n levels, started level two and then go to level one, again to level zero,

878
01:24:01,730 --> 01:24:09,740
if the alloc bit set, and level doesn't exist, it will create the intermediate page table directory,

879
01:24:10,580 --> 01:24:13,040
and zero it out and then keep going to look.

880
01:24:13,770 --> 01:24:17,580
So, you always end up on the bottom PTE,

881
01:24:18,580 --> 01:24:23,440
if alloc is not set, you stop at the first PTE, that doesn't have value.

882
01:24:25,560 --> 01:24:30,270
Okay, that makes sense, this is the last one, the actual on, gonna have, okay.

883
01:24:31,410 --> 01:24:32,610
Okay, thank you.

884
01:24:36,820 --> 01:24:37,840
Any other questions?

885
01:24:40,820 --> 01:24:45,110
So I have a question, basically everything made sense

886
01:24:45,140 --> 01:24:50,420
until we mapped the virtual addresses to of the kernel to the physical addresses.

887
01:24:53,800 --> 01:24:57,880
So my understanding is that each process will have its own page table,

888
01:24:57,880 --> 01:25:03,520
which is also a three level tree, which maps its virtual addresses to physical addresses,

889
01:25:03,730 --> 01:25:08,050
but when we map the kernel virtual addresses to physical addresses,

890
01:25:08,140 --> 01:25:14,140
I don't think we accounted for the [actual tree] of them virtual addresses of the kernel

891
01:25:14,170 --> 01:25:19,150
or where other processes will have their virtual addresses

892
01:25:19,390 --> 01:25:29,950
and, I'm sorry, virtual addresses like the page table trees and whatever the page table tree points at in the physical memory.

893
01:25:30,430 --> 01:25:38,140
Yeah, so yeah so so you're back this slide with the kernel address space, virtual kernel address space

894
01:25:38,470 --> 01:25:44,720
and so when the kernel allocates a proc, and page tables for that particular process,

895
01:25:44,720 --> 01:25:49,760
they're going to be allocated at of memory here, memory is not being used yet.

896
01:25:50,870 --> 01:26:00,170
And the kernel is going to program, will probably allocate a couple pages for the page table of the user process and will fill in the PTEs.

897
01:26:01,460 --> 01:26:04,640
And at some point when the kernel runs that process,

898
01:26:04,880 --> 01:26:15,640
it will load the root physical address for those pages that is allocated for that page table or basically page table that built, into the satp register.

899
01:26:16,660 --> 01:26:24,520
And at that point the processor will run with the virtual address space that the kernel constructed for that particular process.

900
01:26:27,140 --> 01:26:32,270
So the kernel give up some of its memory for processes,

901
01:26:32,270 --> 01:26:41,770
and then but then the virtual space in theory is as big for the process as the kernel, but in reality it is surely not.

902
01:26:42,450 --> 01:26:47,520
Yeah, here's a picture with the layout of virtual address space of a user level process

903
01:26:47,580 --> 01:26:55,350
and again it goes from zero to MAXVA, in the same way as the kernel address space does

904
01:26:55,770 --> 01:27:01,540
and it's basically has his own set of page tables to map those translation that the kernel set up.

905
01:27:03,190 --> 01:27:06,670
But we can't actually use all of the MAXVA virtual address.

906
01:27:06,670 --> 01:27:08,950
No we cannot, we run out of memory.

907
01:27:11,620 --> 01:27:16,660
So many of the processes are much much smaller, correct, than all of the virtual address space.

908
01:27:19,940 --> 01:27:20,690
I see, thank you.

909
01:27:23,260 --> 01:27:25,000
I've got a quick question. Yeah.

910
01:27:26,020 --> 01:27:28,120
Could you go back to the walk code?

911
01:27:28,450 --> 01:27:33,540
Yeah yeah absolutely, it's one of my favorite functions.

912
01:27:35,280 --> 01:27:42,570
Um, so I guess one thing I'm confused about is after you write to the satp register,

913
01:27:42,960 --> 01:27:46,770
can the kernel even access physical addresses directly,

914
01:27:46,770 --> 01:27:51,240
so it looks like in the code that it's converting you know like page was being sent to a physical address,

915
01:27:51,240 --> 01:27:56,990
but if satp is set, won't that be interpreted as a virtual address.

916
01:27:57,870 --> 01:28:04,830
Yeah, so, okay, so let's look at hartinit,

917
01:28:09,740 --> 01:28:14,500
so, kvminit, so built the kernel address space,

918
01:28:16,340 --> 01:28:29,060
the kernel page table initially a physical, address is translated to a physical address and that's actually written into the satp register.

919
01:28:30,380 --> 01:28:38,090
And at that point you know we're running with the address space that we've constructed, like before here this kvminit.

920
01:28:39,920 --> 01:28:49,270
And kvmmap is basically nothing else than calling walk for every address or every page and [at the range].

921
01:28:50,340 --> 01:28:52,260
And so what was your question?

922
01:28:53,660 --> 01:29:00,260
Um I guess, it's does walks still work the same way if you call it after satp is set.

923
01:29:00,590 --> 01:29:01,850
Yeah, why.

924
01:29:04,590 --> 01:29:09,450
Why we work out, the reason it work out, is because the kernel set up an identity mapping.

925
01:29:11,380 --> 01:29:14,820
Um, okay, right, right.

926
01:29:15,120 --> 01:29:22,320
Very important, very good question, a lot of things just happened to work out, because actually the identity mapping is set up.

927
01:29:24,650 --> 01:29:28,330
I see, okay I think that makes sense, yeah.

928
01:29:31,360 --> 01:29:37,840
I have a quick question, where the satp registers stored for all of the processes.

929
01:29:38,460 --> 01:29:44,040
There only one satp per core, but in every proc structure.

930
01:29:44,780 --> 01:29:45,440
Okay.

931
01:29:46,330 --> 01:29:56,100
If you look at proc.h, there is a pointer to the page table, you're.

932
01:29:56,160 --> 01:29:57,480
Okay, makes sense.

933
01:29:58,440 --> 01:30:03,420
And also, with regards to the three page tables,

934
01:30:03,420 --> 01:30:10,620
are like the three tables that can complete the full address and help you get a full address for [] something,

935
01:30:11,040 --> 01:30:17,880
how does how is that better, I guess than than having one giant page table, I didn't really fully understand.

936
01:30:17,880 --> 01:30:19,950
Good, a good question,

937
01:30:20,040 --> 01:30:24,210
the reason is because in the three level page table, you can leave a lot of entries empty,

938
01:30:25,060 --> 01:30:30,370
so, for example if you leave the entry in the top level page table directory empty,

939
01:30:30,520 --> 01:30:36,070
you don't have to create middle level page tables or bottom level page tables at all, for those entries.

940
01:30:37,070 --> 01:30:43,220
And so like this means like a big [] of the whole virtual address space doesn't have to have any mapping at all.

941
01:30:44,860 --> 01:30:45,700
Okay, okay.

942
01:30:45,700 --> 01:30:48,010
You don't have the table there, it just doesn't exist.

943
01:30:48,840 --> 01:30:55,140
I see, basically allocating these chunks on demand, [], Okay that makes sense.

944
01:30:55,170 --> 01:30:58,110
Yeah, you're starting basically with three page, three pages,

945
01:30:58,110 --> 01:31:02,550
namely, one for the top level, one for one intermediate, one, one bottom level

946
01:31:03,180 --> 01:31:06,360
and then as you go you create more page table directories.

947
01:31:06,740 --> 01:31:08,000
Okay, okay, cool.

948
01:31:09,140 --> 01:31:10,970
Cool, thank you so much. You're welcome.

949
01:31:12,930 --> 01:31:14,010
Any more questions?

950
01:31:14,690 --> 01:31:17,900
Um, sorry I have another one, it's really really small,

951
01:31:17,900 --> 01:31:26,150
but in the vm.c on line 43 41

952
01:31:27,140 --> 01:31:30,650
it says that, no, it might 43, my bad,

953
01:31:30,680 --> 01:31:36,530
it says PHYSTOP minus uint64 etext,

954
01:31:36,590 --> 01:31:45,570
but wouldn't that, would that go over the, I guess the memory that we shouldn't touch,

955
01:31:45,600 --> 01:31:50,040
I don't know if that makes sense, but wouldn't that go,

956
01:31:51,220 --> 01:31:54,730
I guess I don't understand would they go over free memory.

957
01:31:55,790 --> 01:32:08,400
No, I don't think so, so KERNBAE 0x8000 right, so that's the beginning of memory in kernel sits there

958
01:32:08,430 --> 01:32:15,320
and basically this thing is a size, right,

959
01:32:15,320 --> 01:32:25,830
so etext is the last address of the kernel, subtract KERNBASE that this will give you the size of the kernel in in byte.

960
01:32:26,520 --> 01:32:33,060
And you know, I don't know how much it is, but yeah yeah it's like you know sixty or ninety pages or something like that.

961
01:32:34,300 --> 01:32:37,570
And so this map is basically the text part of the kernel.

962
01:32:38,350 --> 01:32:48,310
And there's enough space, there's enough DRAM there to map that, the kernel text.

963
01:32:48,860 --> 01:32:50,540
I'm not sure I'm answering your question, but.

964
01:32:51,140 --> 01:32:57,380
Oh, I think, I think I understand, I thought that etext starts somewhere else,

965
01:32:57,380 --> 01:32:59,150
okay I think I understand now, thank you.

966
01:32:59,150 --> 01:33:02,870
Okay so etext, basically the last instruction, the address of the last instruction of the kernel.

967
01:33:03,670 --> 01:33:04,690
Okay, okay.

