1
00:00:07,260 --> 00:00:08,790
我说话清楚吗？

2
00:00:09,710 --> 00:00:10,910
是的。

3
00:00:11,270 --> 00:00:11,840
好的，很好。

4
00:00:12,230 --> 00:00:15,590
大家下午好，傍晚好，早上好，晚上好，

5
00:00:15,590 --> 00:00:16,460
不管你在哪里。

6
00:00:17,630 --> 00:00:22,130
让我们开始学习 6.S081 的第三节课，

7
00:00:22,130 --> 00:00:24,650
它是关于操作系统结构的。

8
00:00:25,400 --> 00:00:34,600
今天我要讲的主题分为四个内容，

9
00:00:34,600 --> 00:00:35,920
第一个是隔离，

10
00:00:36,510 --> 00:00:42,150
这是由操作系统结构设计目标驱动的。

11
00:00:42,330 --> 00:00:45,360
我会讲一下内核模式和用户模式，

12
00:00:47,380 --> 00:00:52,930
这是内核或操作系统与用户程序隔离的一种方式。

13
00:00:53,400 --> 00:00:55,260
然后我们讨论一下系统调用，

14
00:00:55,800 --> 00:01:01,320
它是用户程序访问内核的一种方式。

15
00:01:01,410 --> 00:01:03,180
让用户程序可以访问服务，

16
00:01:03,360 --> 00:01:09,480
而且我们研究一下在 xv6 中是怎样实现这种[简单]形式的。

17
00:01:09,510 --> 00:01:11,400
这些就是今天的重点。

18
00:01:12,160 --> 00:01:15,190
你还记得，

19
00:01:15,460 --> 00:01:20,830
回忆一下第一节课的内容。

20
00:01:21,370 --> 00:01:24,100
你脑海中的画面，

21
00:01:24,100 --> 00:01:26,470
这里有一些进程，

22
00:01:26,470 --> 00:01:34,780
比如 shell echo 或其他东西，比如 find ，

23
00:01:34,780 --> 00:01:37,300
无论你实现的任何程序，

24
00:01:37,720 --> 00:01:40,810
它们运行在操作系统之上。

25
00:01:42,520 --> 00:01:46,270
操作系统对硬件资源进行抽象，

26
00:01:46,810 --> 00:01:48,850
比如磁盘或 CPU ，

27
00:01:49,330 --> 00:01:55,390
操作系统和 shell 之间的接口通常与系统调用接口有关，

28
00:01:55,540 --> 00:01:59,050
我们考虑的接口是 Unix 接口。

29
00:02:01,680 --> 00:02:05,830
这里我们要看的是，

30
00:02:05,890 --> 00:02:09,670
你们差不多都用过 Unix 接口，

31
00:02:09,700 --> 00:02:13,750
在实验一 util 实验中，

32
00:02:13,750 --> 00:02:19,000
你使用系统调用接口或 Unix API 实现不同的应用程序。

33
00:02:19,450 --> 00:02:28,190
所以实验一 util 实验使用的是这张图片中的这一部分。

34
00:02:28,340 --> 00:02:30,290
我们现在要做的是，

35
00:02:30,290 --> 00:02:33,740
在第一节课或这节课以及后面的课程中，

36
00:02:33,830 --> 00:02:37,790
我们研究这些接口是怎样实现的。

37
00:02:38,260 --> 00:02:39,850
实际上，这学期的大部分课程，

38
00:02:39,850 --> 00:02:44,500
我们花实验弄清楚怎样实现接口，

39
00:02:44,590 --> 00:02:48,040
这节课将是这类课程的第一节课。

40
00:02:48,600 --> 00:02:54,450
幸运的是，你们通过邮件提了一些很好的问题，

41
00:02:54,630 --> 00:02:58,320
或者在网站上提交了很好的问题，

42
00:02:58,320 --> 00:03:02,280
我们不会直接讲很多细节，

43
00:03:02,280 --> 00:03:05,760
在这些深入操作系统课程中的第一节课上，

44
00:03:05,970 --> 00:03:07,710
我们会涉及不同的东西，

45
00:03:07,800 --> 00:03:12,090
但是很多东西会在后面的课程中变得更清楚，

46
00:03:12,090 --> 00:03:13,950
我们会更深入地研究。

47
00:03:14,520 --> 00:03:20,640
尽管如此，如果有什么东西不清楚，可以随意打断并提问。

48
00:03:22,020 --> 00:03:27,930
或许在继续之前，我先问一些问题，

49
00:03:27,930 --> 00:03:30,990
提问并回答，

50
00:03:31,410 --> 00:03:37,230
问题是在 util 实验中你学到的最有趣的事情是什么。

51
00:03:37,600 --> 00:03:40,270
首先，我会自己回答这个问题，

52
00:03:40,270 --> 00:03:45,130
在编写完成 util 实验后，令我惊讶的一件事是，

53
00:03:45,130 --> 00:03:49,600
我比之前更多地使用 xargs ，

54
00:03:49,600 --> 00:03:54,490
与 xargs 做相同事情的其他方法，一些命令，

55
00:03:55,300 --> 00:03:58,240
在做了 xargs 实验之后，

56
00:03:58,240 --> 00:04:01,300
以这种方式使用 xargs 更方便，

57
00:04:01,390 --> 00:04:05,980
我成为一名 xargs 更积极的用户，

58
00:04:06,040 --> 00:04:11,520
我很想知道你们的体验是什么。

59
00:04:12,330 --> 00:04:14,700
所以，我会点名，

60
00:04:14,700 --> 00:04:17,850
你可以关闭静音回答问题，

61
00:04:17,850 --> 00:04:22,410
说一下你关于 util 实验的体验。

62
00:04:23,320 --> 00:04:27,430
我来挑几个人， Andrew You 。

63
00:04:33,100 --> 00:04:35,620
Andrew ，你在线吗？

64
00:04:35,890 --> 00:04:40,780
对我来说最有趣的东西是管道，还有如何编写并发程序。

65
00:04:42,750 --> 00:04:45,510
你之前编写过管道编程吗，或者是第一次。

66
00:04:45,510 --> 00:04:49,890
不，我没有，我见过并发编程，但是没有见过操作系统管道。

67
00:04:51,660 --> 00:04:53,550
Elizabeth Weeks ，你觉得怎么样？

68
00:04:55,360 --> 00:05:00,370
是的，我同意这一点，我也发现操作系统管道非常有趣，

69
00:05:00,370 --> 00:05:04,780
而且质数实验也很酷，

70
00:05:04,780 --> 00:05:07,990
理解我需要关闭当前管道，

71
00:05:07,990 --> 00:05:10,750
它们之间有某种关联。

72
00:05:11,780 --> 00:05:17,480
是的，可能你会发现质数管道比你想象的要难，

73
00:05:18,230 --> 00:05:21,350
每次我都会感到意外，要想做对需要一些技巧。

74
00:05:23,330 --> 00:05:24,350
Jessica She.

75
00:05:26,300 --> 00:05:30,320
我也觉得质数实验非常有趣。

76
00:05:32,000 --> 00:05:35,600
好的，它有没有花了你很长时间或者觉得还好。

77
00:05:36,560 --> 00:05:43,520
嗯，在我意识到我的实现不是并发的之后，它花了我更多时间，

78
00:05:43,520 --> 00:05:46,850
所以思考这之间有什么不同是很有趣的。

79
00:05:48,500 --> 00:05:50,390
Robert Murphy 呢？

80
00:05:53,970 --> 00:05:58,100
好的，我想我的体验是，

81
00:05:59,740 --> 00:06:04,180
我发现用它设置的原始方法编程很有挑战性，

82
00:06:04,180 --> 00:06:07,960
所以我创建了很多很多围绕它们的帮助函数，

83
00:06:08,290 --> 00:06:09,880
这就是我所做的。

84
00:06:13,730 --> 00:06:17,530
好的，还有人有什么想法吗？

85
00:06:17,980 --> 00:06:19,450
Amanda ，说吧。

86
00:06:19,990 --> 00:06:22,960
我发现它很酷，

87
00:06:22,960 --> 00:06:28,480
就是标准输入和标准输出只是文件描述符 0 和 1 。

88
00:06:30,140 --> 00:06:33,650
好的。 xv6 没有隐藏这个，

89
00:06:33,740 --> 00:06:40,280
实际上在 C 标准库中，它会封装成接口，

90
00:06:40,280 --> 00:06:42,650
但是 xv6 没有对你隐藏它，

91
00:06:42,650 --> 00:06:46,130
最终，它会归结为文件描述符 0 和 1 ，

92
00:06:46,280 --> 00:06:47,600
还有 2 ，用来表示标准错误。

93
00:06:49,330 --> 00:06:52,780
好的， Alexandra 。

94
00:06:53,900 --> 00:07:01,040
我想，让我意外的一件事也是来自质数问题，

95
00:07:02,920 --> 00:07:06,160
有一个 bug 我花了很长时间，

96
00:07:06,160 --> 00:07:08,530
就是我没有意识到，

97
00:07:08,530 --> 00:07:17,410
当你打开一个管道，然后调用 fork ，

98
00:07:17,410 --> 00:07:21,970
然后这个管道就会有四个末端，

99
00:07:21,970 --> 00:07:28,540
因为管道既连接子进程又连接父进程，

100
00:07:29,080 --> 00:07:31,510
但是我只关掉了其中的两个。

101
00:07:33,030 --> 00:07:34,170
所以，就是这样。

102
00:07:34,530 --> 00:07:36,120
是的，一个普遍的问题。

103
00:07:36,930 --> 00:07:39,300
它有道理，但是因为某些原因，

104
00:07:39,300 --> 00:07:47,130
因为，特别是书上写到当你使用 fork ，所有打开的文件描述符都会被复制，

105
00:07:47,430 --> 00:07:52,950
但是我没有想到这个。

106
00:07:52,950 --> 00:07:57,750
熟悉它们的方法就是用它编程，实际使用它。

107
00:07:58,880 --> 00:08:01,910
很好，我希望你们喜欢这个实验，

108
00:08:01,910 --> 00:08:04,490
当然，我也希望你们喜欢后面的实验。

109
00:08:04,640 --> 00:08:07,760
所以今天的讲座，某种意义上是

110
00:08:07,760 --> 00:08:13,550
帮助你开始 syscall 实验，如果你还没有开始的话，

111
00:08:13,610 --> 00:08:16,880
还有，你可以随时打断我并提问。

112
00:08:17,560 --> 00:08:24,720
好的，我想做的第一件事是，讨论一下隔离性。

113
00:08:25,200 --> 00:08:29,370
为什么它重要，为什么我们这么关心。

114
00:08:29,550 --> 00:08:31,830
基本的描述是很简单的，

115
00:08:32,040 --> 00:08:35,580
我们有很多程序在这里，比如 shell echo find ，

116
00:08:35,790 --> 00:08:37,080
是由我们创建的，

117
00:08:37,080 --> 00:08:40,500
如果在 shell 或质数程序中有一个 bug ，

118
00:08:40,710 --> 00:08:43,410
它不会影响其他应用，

119
00:08:43,440 --> 00:08:46,050
特别是如果影响了 shell ，事情会变得很坏，

120
00:08:46,050 --> 00:08:50,100
因为如果某些东西破坏， shell 可能会杀掉程序。

121
00:08:50,960 --> 00:08:55,370
所以你希望在不同的应用之间存在强隔离。

122
00:08:55,900 --> 00:09:00,550
类似的，操作系统为所有应用程序提供服务，

123
00:09:00,730 --> 00:09:02,560
你希望是这种情况，

124
00:09:02,560 --> 00:09:06,490
如果你在 util 某个程序中引入一个 bug ，

125
00:09:06,490 --> 00:09:08,260
但是操作系统不会崩溃，

126
00:09:08,680 --> 00:09:11,380
比如你传入一些奇怪的参数给操作系统，

127
00:09:11,590 --> 00:09:14,260
也应该是这种情况，操作系统可以很好地处理。

128
00:09:14,710 --> 00:09:23,730
所以，我们也希望应用程序和操作系统之间有强隔离。

129
00:09:24,390 --> 00:09:26,940
一种思考方式是，

130
00:09:26,940 --> 00:09:32,820
问我们自己，如果没有操作系统会发生什么。

131
00:09:32,850 --> 00:09:36,030
考虑某种 strawman 设计。

132
00:09:40,010 --> 00:09:42,900
就是没有操作系统，

133
00:09:45,400 --> 00:09:49,390
或者你可以把操作系统当成 [] ，就是一个库，

134
00:09:49,420 --> 00:09:51,790
从 python 的角度考虑，

135
00:09:52,120 --> 00:09:58,450
使用 import os ，而 import os 会加载整个操作系统到应用程序，

136
00:09:58,600 --> 00:10:01,030
这就是你使用的编程接口。

137
00:10:01,670 --> 00:10:04,580
你可以这样想，

138
00:10:04,580 --> 00:10:06,470
这里我们有一个 shell ，

139
00:10:06,470 --> 00:10:10,550
可能它包含系统库，

140
00:10:10,730 --> 00:10:13,820
我们还有其他应用程序 echo ，

141
00:10:14,490 --> 00:10:22,500
这些应用程序，如果没有操作系统，就需要访问硬件，

142
00:10:23,190 --> 00:10:28,320
比如，它们会看到，这里有一个 CPU ，这里还有一个 CPU ，

143
00:10:28,840 --> 00:10:32,980
这里有一个磁盘，它们直接访问磁盘，

144
00:10:32,980 --> 00:10:36,370
这里有一个内存，它们直接访问内存。

145
00:10:37,370 --> 00:10:44,180
所以在应用程序和硬件之间没有抽象层，

146
00:10:44,420 --> 00:10:50,840
事实证明，在隔离方面，这不是一个好的设计。

147
00:10:51,550 --> 00:10:53,800
你可以看到隔离是怎么被打破的，

148
00:10:54,010 --> 00:11:00,160
我们假设，操作系统的一个目标是可以运行多个应用程序，

149
00:11:00,310 --> 00:11:02,110
所以肯定会有这种情况，

150
00:11:02,110 --> 00:11:05,860
每隔一段时间，它从一个应用程序切换到另一个应用程序，

151
00:11:05,920 --> 00:11:08,620
假设硬件只有一个 CPU ，

152
00:11:08,800 --> 00:11:12,610
所以我们在一个 CPU 上运行 shell ，周期地 [] ，

153
00:11:12,610 --> 00:11:14,500
让其他应用程序也可以运行。

154
00:11:15,500 --> 00:11:18,470
如果没有操作系统为我们做这个，

155
00:11:18,680 --> 00:11:22,880
shell 就必须每隔一段时间放弃 CPU ，

156
00:11:24,220 --> 00:11:29,080
做一个好人，表示我已经运行一会了，现在你可以运行了，

157
00:11:29,200 --> 00:11:31,180
这就是所谓的协作式调度。

158
00:11:31,830 --> 00:11:34,380
但是这对于隔离来说并不好，

159
00:11:34,560 --> 00:11:38,730
比如，如果 shell 中有一个无限循环，

160
00:11:38,910 --> 00:11:41,490
因此它永远不会放弃 CPU ，

161
00:11:41,960 --> 00:11:47,930
然后，没有其他应用程序可以运行，包括关闭 shell 的应用程序。

162
00:11:48,550 --> 00:11:53,290
所以，我们没有任何形式的强制复用。

163
00:11:54,090 --> 00:11:55,770
这是我们需要的，

164
00:11:55,800 --> 00:12:01,470
无论应用程序在做什么，它必须强制每隔一段时间放弃 CPU ，

165
00:12:01,500 --> 00:12:03,300
让其他应用程序可以运行。

166
00:12:04,730 --> 00:12:08,240
同样的，如果你考虑这个 strawman 设计，

167
00:12:08,420 --> 00:12:11,090
这里有一个物理内存，

168
00:12:11,090 --> 00:12:13,250
我画的这张图，

169
00:12:13,250 --> 00:12:15,260
应用程序位于硬件之上，

170
00:12:15,350 --> 00:12:22,910
这是物理内存，代码文本和程序数据在物理内存中，

171
00:12:22,910 --> 00:12:23,780
这是一个常用的内存。

172
00:12:24,740 --> 00:12:29,300
这里是 shell 使用的部分，

173
00:12:29,690 --> 00:12:33,800
这里是 echo 使用的部分。

174
00:12:34,760 --> 00:12:37,760
所以你会再次看到，

175
00:12:37,760 --> 00:12:40,520
如果像这么简单，

176
00:12:40,670 --> 00:12:45,740
这两块内存之间没有界限，

177
00:12:46,130 --> 00:12:54,540
比如 echo 保存数据到属于 shell 的 1000 地址，

178
00:12:54,540 --> 00:12:57,420
并写入值 x ，

179
00:12:57,780 --> 00:13:01,860
然后你就翻盖了 shell 的物理内存。

180
00:13:02,380 --> 00:13:04,240
这是非常错误的，

181
00:13:04,270 --> 00:13:07,900
因为产生了一个 bug ， echo 渗透到 shell 中，

182
00:13:08,080 --> 00:13:10,840
调试这类东西会非常困难，

183
00:13:10,870 --> 00:13:14,620
这给我们的是非强隔离。

184
00:13:15,350 --> 00:13:19,690
我们想要的是内存隔离，

185
00:13:19,690 --> 00:13:25,300
让一个应用程序不会覆盖另一个应用程序的内存。

186
00:13:26,220 --> 00:13:35,060
所以需要操作系统的一个原因是，

187
00:13:35,060 --> 00:13:41,090
在复用的同时，有强隔离性。

188
00:13:41,600 --> 00:13:43,100
如果不使用操作系统

189
00:13:43,100 --> 00:13:45,500
并且应用程序直接访问硬件，

190
00:13:45,530 --> 00:13:46,820
是很难达到（隔离）的要求的。

191
00:13:48,030 --> 00:13:53,130
所以这种将操作系统作为库的设计并不是一种很常见的设计，

192
00:13:53,130 --> 00:13:57,270
你可能在一些实时系统中看到，因为它们的应用程序都是可信任的，

193
00:13:57,540 --> 00:14:00,000
但是在大多数其他操作系统中，

194
00:14:00,090 --> 00:14:03,720
有操作系统来保证这种隔离。

195
00:14:05,460 --> 00:14:10,050
所以如果我们现在从这个角度看 Unix 接口，

196
00:14:14,350 --> 00:14:17,860
我们会看到这些接口是精心设计的，

197
00:14:18,650 --> 00:14:28,070
可以方便地实现复用和物理内存方面的强隔离，

198
00:14:28,490 --> 00:14:38,640
使用的方法就是这些接口抽象了硬件资源，

199
00:14:40,940 --> 00:14:45,350
在某种程度上，更简单地，或者并不简单，

200
00:14:45,350 --> 00:14:49,430
它让提供强隔离成为可能。

201
00:14:50,280 --> 00:14:53,160
我来举几个例子，

202
00:14:53,280 --> 00:14:57,930
比如我们之前看到的由 fork 创建的进程，

203
00:14:59,780 --> 00:15:02,720
它们不是真正的 CPU ，

204
00:15:02,720 --> 00:15:07,490
我的意思是它们对应 CPU ，由 CPU 来运行计算，

205
00:15:07,880 --> 00:15:14,360
但是因为应用程序不能直接访问 CPU ，而是通过进程抽象，

206
00:15:14,630 --> 00:15:18,740
使得幕后的内核可以在进程之间切换。

207
00:15:20,280 --> 00:15:25,830
不是直接操纵 CPU 或将 CPU 分配给应用程序，

208
00:15:25,950 --> 00:15:30,240
操作系统提供进程作为对 CPU 的抽象，

209
00:15:30,240 --> 00:15:36,090
所以操作系统可以复用一个或多个 CPU 到多个应用程序。

210
00:15:37,200 --> 00:15:45,170
同样，如果你考虑 exec ， exec 提供一个内存镜像，

211
00:15:45,560 --> 00:15:47,480
Amanda ，好的，说出你的问题。

212
00:15:47,930 --> 00:15:52,970
一个关于进程是 CPU 的抽象的问题，

213
00:15:53,270 --> 00:16:02,690
是一个进程使用 CPU 的一部分，另一个进程使用另一部分，

214
00:16:02,690 --> 00:16:05,300
或者如果是多核的，使用不同的 CPU ，

215
00:16:05,570 --> 00:16:08,900
或者你所说的进程而不是 CPU 是什么意思。

216
00:16:09,020 --> 00:16:13,730
好的，我的意思是一个 CPU 抽象成一个进程，

217
00:16:13,730 --> 00:16:16,070
好的，你可以这样想，

218
00:16:16,100 --> 00:16:22,370
我们在实验中使用的 RISC-V 处理器实际上有四个核，

219
00:16:22,930 --> 00:16:28,660
你可以同时运行四个进程，每个核一个进程，

220
00:16:29,260 --> 00:16:30,850
操作系统说做的就是，

221
00:16:30,850 --> 00:16:33,550
比如你有八个或七个应用程序，

222
00:16:33,790 --> 00:16:38,590
它会使用一些核，并通过时间复用，在不同的进程上，

223
00:16:38,590 --> 00:16:42,670
比如它会运行一个应用程序进程 100 微秒，

224
00:16:43,100 --> 00:16:48,350
然后停止，从 CPU 或内核中卸载进程，

225
00:16:48,380 --> 00:16:53,840
加载下一个应用程序进程，并运行 100 毫秒，

226
00:16:54,050 --> 00:16:58,790
它保证没有应用程序或进程运行超过 100 毫秒。

227
00:16:59,260 --> 00:17:01,780
我们将会在后面的课程中看到这是如何实现的，

228
00:17:01,900 --> 00:17:03,220
但这就是它的基本思想。

229
00:17:04,200 --> 00:17:08,340
好的，但是多个进程不能同时使用相同的 CPU 。

230
00:17:08,550 --> 00:17:09,900
是的，它是时间复用的。

231
00:17:10,260 --> 00:17:13,290
你运行一个一段时间，然后再运行下一个一段时间。

232
00:17:14,050 --> 00:17:14,800
好的，谢谢。

233
00:17:16,130 --> 00:17:22,460
好的，所以考虑 exec 的一种方式是，它是对内存的抽象。

234
00:17:28,400 --> 00:17:30,020
比如你想，

235
00:17:30,170 --> 00:17:33,260
exec 系统调用使用一个文件名，

236
00:17:33,260 --> 00:17:37,760
在那个文件中是一个程序镜像，

237
00:17:37,760 --> 00:17:46,880
保存了 text , global data ，这些组成了应用程序的内存，

238
00:17:47,210 --> 00:17:49,670
应用程序可以增加内存，

239
00:17:49,670 --> 00:17:55,220
比如通过调用 sbrk ，扩展其数据段，

240
00:17:55,280 --> 00:17:58,550
但是实际上对物理内存没有直接影响，

241
00:17:58,580 --> 00:18:05,390
你不能要求访问物理内存 1k 或 2k ，

242
00:18:05,510 --> 00:18:07,880
没有方法可以做到这个，

243
00:18:07,940 --> 00:18:10,880
再次强调，没有方法做到这个的原因是，

244
00:18:10,880 --> 00:18:14,150
因为操作系统提供内存隔离，

245
00:18:14,240 --> 00:18:20,390
因此控制了应用程序和物理硬件之间的交互。

246
00:18:20,780 --> 00:18:29,270
exec 系统调用，展示了不能直接访问内存。

247
00:18:29,540 --> 00:18:31,460
另一个例子是文件，

248
00:18:33,020 --> 00:18:35,420
文件是对磁盘块的抽象，

249
00:18:41,660 --> 00:18:47,720
而不是直接读写计算机磁盘的磁盘块，

250
00:18:47,900 --> 00:18:50,030
实际上，这在 Unix 上是不允许的，

251
00:18:50,030 --> 00:18:54,110
你访问存储系统的唯一方法就是通过文件，

252
00:18:54,110 --> 00:18:59,420
你可以读写文件，它提供了很方便的抽象，命名文件等等，

253
00:18:59,540 --> 00:19:05,600
然后操作系统自己决定如何对文件到磁盘块做映射，

254
00:19:05,600 --> 00:19:09,260
保证磁盘块只会出现在一个文件中，

255
00:19:09,290 --> 00:19:16,190
保证用户 a 不能读写用户 b 的文件。

256
00:19:16,520 --> 00:19:23,720
你知道文件抽象接口提供了强隔离，

257
00:19:23,930 --> 00:19:27,980
在不同用户之间，或者相同用户的不同进程之间。

258
00:19:29,370 --> 00:19:30,060
如你所见，

259
00:19:30,060 --> 00:19:35,970
在某些方面， Unix 接口，比如在 util 实验中使用的，

260
00:19:36,060 --> 00:19:40,230
是经过精心设计的，以一种方式对资源进行抽象，

261
00:19:40,260 --> 00:19:49,470
操作系统或接口可以对多个进程复用资源，并提供强隔离。

262
00:19:54,120 --> 00:19:55,170
这个有什么问题吗？

263
00:19:56,040 --> 00:19:56,910
我们在聊天中有一个问题，

264
00:19:56,910 --> 00:20:02,460
问题是是否更复杂的内核会试着重新调度同一个核的进程，以减少缓存缺失。

265
00:20:02,730 --> 00:20:07,890
是的，有一个叫做缓存亲和性的东西，

266
00:20:07,890 --> 00:20:12,000
现代操作系统中的这种转换非常复杂，

267
00:20:12,270 --> 00:20:17,070
试着避免缓存缺失或类似的事情来优化性能。

268
00:20:17,550 --> 00:20:20,820
你会在本学期晚些时候看到其中一些，

269
00:20:20,820 --> 00:20:23,580
那里我们会讨论高性能网络，

270
00:20:24,180 --> 00:20:25,440
它们也会出现在那里。

271
00:20:26,260 --> 00:20:27,640
聊天中的另一个问题，

272
00:20:27,880 --> 00:20:34,510
在 xv6 中，哪里可以看到操作系统复用进程。

273
00:20:34,510 --> 00:20:39,430
有一些相关的文件，但是 proc.c 可能是最相关的那个，

274
00:20:39,460 --> 00:20:42,670
这将是两三周后课程的主题，

275
00:20:43,060 --> 00:20:46,930
我们将深入细节，展示复用是如何发生的。

276
00:20:48,420 --> 00:20:51,750
所以你可以把这节课当成是很多不同部分的简介，

277
00:20:51,780 --> 00:20:54,210
因为我们必须从某个地方开始。

278
00:20:56,500 --> 00:21:03,970
好的，让我们回到之前的图片，

279
00:21:03,970 --> 00:21:06,760
当前我们有 shell 在运行，有 echo 在运行，

280
00:21:06,760 --> 00:21:09,690
不是那张图，是这张，在这边，

281
00:21:09,840 --> 00:21:12,270
我们有操作系统，有应用程序运行，

282
00:21:12,570 --> 00:21:15,510
我们应该考虑的一件事是，

283
00:21:15,510 --> 00:21:20,400
操作系统应该是防御性的。

284
00:21:23,160 --> 00:21:29,190
当你做内核开发时，这是一种重要的思维模式，

285
00:21:29,550 --> 00:21:35,340
操作系统必须确保任何东西都能正常运行，

286
00:21:35,340 --> 00:21:41,250
所以它必须设置一些东西，防止应用程序破坏操作系统。

287
00:21:45,670 --> 00:21:46,750
以下情况是很糟糕的，

288
00:21:46,750 --> 00:21:54,310
如果一个应用程序，因为意外或恶意传递错误参数给操作系统，

289
00:21:54,400 --> 00:21:55,990
而导致操作系统崩溃，

290
00:21:55,990 --> 00:21:59,140
这意味着拒绝服务所有其他应用程序。

291
00:21:59,710 --> 00:22:02,290
所以操作系统必须以一种方式编写，

292
00:22:02,290 --> 00:22:05,800
让它可以处理恶意应用程序。

293
00:22:06,400 --> 00:22:13,870
特别是，另一个要考虑是应用程序不能打破它的隔离。

294
00:22:21,230 --> 00:22:26,570
应用程序可能完全是恶意的，或许由攻击者编写的，

295
00:22:26,660 --> 00:22:32,840
攻击者可以想打破应用程序，获得内核控制权，

296
00:22:32,990 --> 00:22:35,660
一旦控制了内核，你就可以做任何事情，

297
00:22:35,660 --> 00:22:38,900
因为内核控制着所有硬件资源。

298
00:22:39,320 --> 00:22:42,560
所以操作系统必须编写成防御性的，

299
00:22:42,770 --> 00:22:45,980
防止出现这种事情。

300
00:22:46,640 --> 00:22:50,180
实现这个目标是很有技巧的，

301
00:22:50,390 --> 00:22:54,710
实际上，在 Linux 中，仍然有偶发的 bug ，

302
00:22:54,710 --> 00:23:03,350
内核 bug ，这些 bug 允许应用程序打破隔离，并获得控制权。

303
00:23:03,980 --> 00:23:08,120
但是这是一个持续性的问题，我们要尽可能的做好这项工作。

304
00:23:08,800 --> 00:23:11,920
这就是你开发内核时要有的思维模式，

305
00:23:11,920 --> 00:23:16,450
实际的应用程序可能是恶意的。

306
00:23:17,260 --> 00:23:32,340
这意味着在应用程序和操作系统之间必须有强隔离。

307
00:23:34,470 --> 00:23:39,570
如果操作系统需要是防御性的，需要处于可防御的位置，

308
00:23:39,630 --> 00:23:42,240
在应用程序之间必须有一道坚固的屏障，

309
00:23:42,240 --> 00:23:46,650
让操作系统可以真正执行它想执行的任何策略。

310
00:23:47,530 --> 00:23:53,980
这通常，实现强隔离的常用方法是硬件支持。

311
00:23:57,880 --> 00:24:00,160
在这节课中，我们稍微了解一下，

312
00:24:00,160 --> 00:24:02,500
但是我们在后面的课程中会深入更多细节。

313
00:24:02,500 --> 00:24:06,040
有两种方式的硬件支持，

314
00:24:06,310 --> 00:24:11,480
一种称为用户内核模式， /kernel 模式，

315
00:24:12,500 --> 00:24:15,560
在 RISC-V 中称为管理者模式，但是是一种东西。

316
00:24:16,260 --> 00:24:19,140
另一种是页表，虚拟内存。

317
00:24:24,240 --> 00:24:32,700
所有处理器，想要运行多应用程序操作系统的处理器，

318
00:24:32,910 --> 00:24:36,660
都支持用户内核模式和虚拟内存，

319
00:24:36,690 --> 00:24:40,380
它可能表现或实现有些许不同，

320
00:24:40,410 --> 00:24:42,150
但是基本上所有处理器都有它。

321
00:24:43,160 --> 00:24:48,770
我们在课程中使用的 RISC-V 处理器也有支持。

322
00:24:49,440 --> 00:24:50,850
所以，我来讲一下，

323
00:24:50,880 --> 00:24:53,520
我会先讲一下用户模式，内核模式，

324
00:24:53,520 --> 00:24:55,230
然后讲一下虚拟内存。

325
00:24:55,760 --> 00:24:59,120
主要从宏观角度，

326
00:24:59,480 --> 00:25:01,310
因为这里面有很多重要的细节，

327
00:25:01,310 --> 00:25:03,080
但这节课并不能包含这些。

328
00:25:04,840 --> 00:25:06,760
我们先来讨论一下用户内核模式，

329
00:25:14,600 --> 00:25:18,770
基本上就是处理器有两种操作模式，

330
00:25:18,860 --> 00:25:21,680
一种是用户模式，另一种是内核模式。

331
00:25:22,350 --> 00:25:28,480
当运行在内核模式， CPU 可以执行特权指令，

332
00:25:35,510 --> 00:25:37,220
[]回到第二[]。

333
00:25:37,310 --> 00:25:42,980
当运行在用户模式， CPU 只能执行非特权指令。

334
00:25:49,980 --> 00:25:52,650
非特权指令，你已经很熟悉了，

335
00:25:52,680 --> 00:25:58,860
比如 add sub ，对两个寄存器做加法或减法，

336
00:25:58,860 --> 00:26:05,100
所以这是很普通的，还有程序调用 jr ，所有分支指令，

337
00:26:05,310 --> 00:26:11,080
这些都是非特权指令，任何用户程序都可以执行。

338
00:26:11,970 --> 00:26:19,230
特权指令是引入直接操作硬件的指令，

339
00:26:19,230 --> 00:26:21,900
设置保护或类似的东西，

340
00:26:21,900 --> 00:26:28,730
比如配置页表寄存器，我们后面会谈到，

341
00:26:28,850 --> 00:26:34,630
或者设置禁止时钟中断。

342
00:26:39,350 --> 00:26:41,840
所以，处理器中有各种类型的状态，

343
00:26:42,110 --> 00:26:46,220
操作系统使用操作这些状态，

344
00:26:46,220 --> 00:26:49,730
都是由特权指令完成的。

345
00:26:50,360 --> 00:26:54,800
所以当用户程序试图执行特权指令，

346
00:26:55,280 --> 00:27:00,830
处理器规则不会执行，因为特权指令在用户模式下是不允许的，

347
00:27:01,070 --> 00:27:07,010
这会引起控制从用户模式到内核模式，

348
00:27:07,010 --> 00:27:09,170
让操作系统获得控制权，

349
00:27:09,170 --> 00:27:11,810
如果应用程序有问题，就可以杀掉它。

350
00:27:12,970 --> 00:27:19,060
为了进一步理解特权指令和非特权指令的不同，

351
00:27:19,390 --> 00:27:22,390
让我切换一下显示内容。

352
00:27:22,920 --> 00:27:31,080
这里右边显示的是一个文档， RISC-V 特权架构文档，

353
00:27:31,530 --> 00:27:34,110
这个文档包含所有特权指令，

354
00:27:34,110 --> 00:27:38,700
在网站（6.S081 课程主页）的 References 页面有它的链接，

355
00:27:38,880 --> 00:27:43,800
在接下来的几周或几乎一个月内，

356
00:27:43,830 --> 00:27:49,920
你会用到这里看到的所有特权指令，

357
00:27:49,950 --> 00:27:55,800
事实上，它们中的大多数会在下节课中出现，包含大量细节。

358
00:27:56,280 --> 00:27:58,320
可以这样想，

359
00:27:58,410 --> 00:28:02,160
用户程序不能执行特权指令，

360
00:28:02,370 --> 00:28:04,470
它们指令在内核模式下执行。

361
00:28:05,790 --> 00:28:10,800
所以，这是硬件支持强隔离的一个方面。

362
00:28:11,350 --> 00:28:13,030
好的， Amanda ，请继续。

363
00:28:13,750 --> 00:28:15,010
一个小问题，

364
00:28:15,010 --> 00:28:21,910
比如我想的是如果内核模式允许或不允许，

365
00:28:21,910 --> 00:28:26,110
那么谁运行的检查代码，判断是否是内核模式，

366
00:28:26,110 --> 00:28:29,560
它们如何知道处于内核模式，是有一个标志或者其他东西吗？

367
00:28:29,770 --> 00:28:31,720
是的，一般在处理器中有一个标志，

368
00:28:31,990 --> 00:28:38,200
在处理器中有一个标志位，用户模式使用 1 ，

369
00:28:38,640 --> 00:28:41,760
一般 1 是用户模式， 0 是内核模式。

370
00:28:42,360 --> 00:28:46,320
所以当处理器解码指令时，检查操作码，

371
00:28:46,410 --> 00:28:52,950
如果操作码是特权指令，并且那个位设置为 1 ，就会拒绝指定该指令。

372
00:28:54,400 --> 00:28:58,630
比如除零指令，就不允许执行。

373
00:28:59,200 --> 00:29:01,150
好的，但是如果那一位以某种方式改变，

374
00:29:01,150 --> 00:29:05,830
就可以覆盖用来控制的那一位。

375
00:29:06,010 --> 00:29:09,700
是的，你认为可以覆盖那一位的指令，

376
00:29:09,700 --> 00:29:12,160
它是特权指令还是非特权指令。

377
00:29:19,440 --> 00:29:20,310
有什么问题吗。

378
00:29:22,970 --> 00:29:27,560
设置那一位的指令当然是特权指令，

379
00:29:27,560 --> 00:29:31,370
因为用户程序不允许把那一位设置为内核模式，

380
00:29:31,370 --> 00:29:35,300
让它能够执行所有特权指令。

381
00:29:36,000 --> 00:29:37,230
所以那一位是受保护的。

382
00:29:39,200 --> 00:29:39,920
理解了吗？

383
00:29:40,770 --> 00:29:41,760
好的，是的。

384
00:29:44,130 --> 00:29:45,300
好的，

385
00:29:45,300 --> 00:29:50,130
这就是用户内核模式，或者宏观的用户内核模式，

386
00:29:50,160 --> 00:29:55,530
RISC-V 还有第三种模式，就是你们问到的，称为机器模式，

387
00:29:55,920 --> 00:29:58,050
我们可以忽略它，

388
00:29:58,080 --> 00:29:59,820
我不准备讲它，

389
00:29:59,850 --> 00:30:04,740
就是多了一级，有三级特权而不是两级。

390
00:30:05,290 --> 00:30:06,160
Amir ，继续。

391
00:30:07,860 --> 00:30:10,440
好的，我想知道关于安全方面，

392
00:30:10,440 --> 00:30:15,270
如果所有用户代码通过内核，目的是为了安全，

393
00:30:15,630 --> 00:30:16,560
但是有没有一种方式，

394
00:30:16,560 --> 00:30:24,000
计算机的用户可以完全绕过操作系统。

395
00:30:25,180 --> 00:30:29,650
不，不是，至少如果做的很小心，不会出现，

396
00:30:32,700 --> 00:30:34,980
如果可能，出现一种情况，

397
00:30:34,980 --> 00:30:40,590
一些程序具有过多的操作系统相关的权限，

398
00:30:41,100 --> 00:30:43,500
但是这些权限没有给每个用户，

399
00:30:43,860 --> 00:30:46,800
只有 root 用户拥有特定权限，

400
00:30:47,100 --> 00:30:50,220
可以执行对安全敏感的操作。

401
00:30:51,240 --> 00:30:55,920
那么 BIOS 呢， BIOS 是发生在操作系统之前还是之后。

402
00:30:55,920 --> 00:31:02,730
是的， BIOS 是同计算机一起的一个软件，

403
00:31:02,970 --> 00:31:08,340
它首先启动，并启动操作系统，

404
00:31:08,340 --> 00:31:14,210
所以 BIOS 是一段可信任的代码，是正确的，没有恶意的。

405
00:31:16,920 --> 00:31:18,000
Noah ，继续。

406
00:31:19,320 --> 00:31:27,330
是的，你提到设置内核模式标志位的指令是特权指令，

407
00:31:27,600 --> 00:31:36,000
那么用户程序怎么能，让内核执行任何内核指令，

408
00:31:36,000 --> 00:31:40,950
比如获得内核模式的指令就是一个特权指令，

409
00:31:40,950 --> 00:31:45,690
我猜应该有一个直接的[]让用户可以修改那个位。

410
00:31:46,060 --> 00:31:50,020
是的，这是正确的，这就是我们想要的方式，

411
00:31:50,380 --> 00:31:54,760
所以可以这样考虑，虽然不完全是 RISC-V 的工作方式，

412
00:31:54,760 --> 00:32:00,880
但是如果你在用户空间执行特权指令，试着执行特权指令……

413
00:33:08,190 --> 00:33:15,180
我回来了，不好意思，我的 zoom 客户端崩溃了。

414
00:33:17,430 --> 00:33:20,790
抱歉，我也不知道怎么回事，但是发生了。

415
00:33:25,600 --> 00:33:26,800
大家能听到我说话吗。

416
00:33:27,860 --> 00:33:28,550
是的，好的。

417
00:33:28,910 --> 00:33:29,360
好的。

418
00:33:29,660 --> 00:33:30,170
好的。

419
00:33:31,460 --> 00:33:34,880
好的，某个地方有个 bug 。

420
00:33:35,240 --> 00:33:44,880
好的，回到硬件支持的第二部分，

421
00:33:45,270 --> 00:33:51,270
几乎所有 CPU 都提供了， CPU 提供的虚拟内存。

422
00:34:02,890 --> 00:34:06,880
周三我会讲到更多细节，

423
00:34:07,030 --> 00:34:10,780
但是基本上，处理器有一个叫做页表的东西。

424
00:34:12,180 --> 00:34:15,060
你们应该已经在 6.004 中看到了，

425
00:34:15,090 --> 00:34:22,760
页表就是将虚拟地址映射到物理地址。

426
00:34:25,360 --> 00:34:29,800
基本思想是给每个进程提供自己的页表。

427
00:34:34,310 --> 00:34:39,990
使用这种方式，进程只能使用，

428
00:34:39,990 --> 00:34:44,280
只能访问它的页表中显示的物理内存，

429
00:34:44,670 --> 00:34:52,530
如果操作系统设置每个进程使用不相交的物理内存，

430
00:34:52,560 --> 00:34:55,770
那么进程甚至不能访问其他进程的物理内存，

431
00:34:55,800 --> 00:34:57,510
因为那些（地址）甚至不在它的页表中，

432
00:34:57,540 --> 00:35:01,350
所以，不能创建或写一个地址，

433
00:35:01,380 --> 00:35:05,040
允许进程访问其他进程的物理内存。

434
00:35:05,390 --> 00:35:07,550
所以，这提供了强内存隔离。

435
00:35:09,950 --> 00:35:13,580
页表定义了内存布局，

436
00:35:13,580 --> 00:35:19,580
每个应用程序，每个用户进程有自己的内存布局，相互独立。

437
00:35:20,220 --> 00:35:23,010
这提供了很强的内存隔离。

438
00:35:24,320 --> 00:35:25,880
所以现在我们可以做，

439
00:35:25,880 --> 00:35:27,500
如果我们用这种方式思考，

440
00:35:27,680 --> 00:35:31,640
那么我们可以重新画出之前的这张图，

441
00:35:31,700 --> 00:35:33,410
因为我们这样思考，

442
00:35:33,410 --> 00:35:37,880
你有一个盒子， ls 在它里面，

443
00:35:37,970 --> 00:35:42,770
我们有另一个盒子，而 echo 在这个盒子里，

444
00:35:43,740 --> 00:35:46,320
每个盒子包含地址，虚拟地址，

445
00:35:46,320 --> 00:35:51,570
从 0 到某个数值， 2 的多少次方，

446
00:35:51,690 --> 00:35:55,320
在 RISC-V 中，我们将在周三讨论。

447
00:35:55,500 --> 00:36:01,470
同样地， echo 的地址范围也是到 2^x 。

448
00:36:02,080 --> 00:36:07,390
所以 ls 有内存位置 0 ， echo 也有位置 0 ，

449
00:36:07,420 --> 00:36:08,830
通常是完全分开的，

450
00:36:08,920 --> 00:36:13,420
如果操作系统将虚拟地址 0 映射到不同部分的物理内存，

451
00:36:13,750 --> 00:36:18,340
那么 ls 不能访问 echo 的内存， echo 也不能访问 ls 的内存。

452
00:36:19,040 --> 00:36:22,130
类似地，内核位于下方，

453
00:36:22,550 --> 00:36:28,580
它也有自己的，至少在 xv6 中，有自己的地址范围，独立于应用程序。

454
00:36:29,090 --> 00:36:34,340
我们可以考虑用户内核模式，它位于边界之间，

455
00:36:34,370 --> 00:36:38,870
在用户空间运行的东西运行在用户模式，

456
00:36:41,020 --> 00:36:43,180
位于内核的东西运行在内核模式。

457
00:36:47,580 --> 00:36:52,650
这种图中，你应该知道操作系统位于内核模式，

458
00:36:53,070 --> 00:36:55,590
所以，这张图片应该出现在你的脑海中。

459
00:36:56,550 --> 00:36:59,730
到目前为止，这张图片有点太严格了，

460
00:36:59,820 --> 00:37:02,160
我们把所有东西都放在一个盒子里，

461
00:37:02,280 --> 00:37:05,460
但是没有办法使控制权从一个盒子转移到另一个盒子。

462
00:37:05,900 --> 00:37:07,190
当然，我们需要它发生，

463
00:37:07,220 --> 00:37:14,540
因为，比如 ls 可以想要调用 read 系统调用或 write 系统调用，

464
00:37:15,080 --> 00:37:18,740
或者 shell 想要调用 fork 或 exec ，

465
00:37:18,950 --> 00:37:27,650
所以需要一种方法，让应用程序以协调的方式将控制权转移到内核，

466
00:37:27,920 --> 00:37:30,020
让内核可以提供服务。

467
00:37:30,940 --> 00:37:33,940
所以，有一种方案，

468
00:37:33,940 --> 00:37:39,460
除了我之前讨论过的这两种硬件支持，

469
00:37:39,520 --> 00:37:43,660
有一种控制方法进入内核。

470
00:37:49,450 --> 00:37:56,470
在 RISC-V 中，有一个这样的指令，称为 ecall 指令。

471
00:37:58,000 --> 00:38:00,880
ecall 指令接受一个参数，一个数字，

472
00:38:02,210 --> 00:38:06,530
所以当用户程序想要将控制权转移到内核，

473
00:38:06,560 --> 00:38:10,820
调用 ecall 指令，使用数字，比如 2 3 4 5 ，

474
00:38:10,940 --> 00:38:16,530
这个数字就是应用程序想要访问的系统调用编号。

475
00:38:21,740 --> 00:38:23,480
这个指令做的是，

476
00:38:23,480 --> 00:38:32,210
进入内核中的一个由内核控制的特定位置，

477
00:38:32,960 --> 00:38:37,370
我们会在后面的一些课程中在 xv6 中看到。

478
00:38:37,370 --> 00:38:40,760
有一个单独的系统调用入口位置，

479
00:38:41,200 --> 00:38:47,650
每次应用程序调用 ecall ，应用程序进入内核的特定位置。

480
00:38:48,600 --> 00:38:51,960
所以，一种思考方式是，

481
00:38:52,170 --> 00:38:57,260
如果你调用 fork ，在用户空间调用 fork ，

482
00:38:57,260 --> 00:39:00,380
比如 shell 或 prime 程序调用 fork ，

483
00:39:00,680 --> 00:39:06,560
不论什么调用 fork ，实际上没有直接调用操作系统内核对应的函数，

484
00:39:06,680 --> 00:39:14,920
而是调用 ecall ，使用 fork 的系统调用编号，

485
00:39:17,080 --> 00:39:19,690
然后进入内核。

486
00:39:20,700 --> 00:39:22,380
所以这是一次内核转换，

487
00:39:23,060 --> 00:39:25,430
这是用户侧，这是内核侧，

488
00:39:25,910 --> 00:39:31,310
在内核侧，有一个函数 syscall 在 syscall.c 中，

489
00:39:31,490 --> 00:39:36,230
每次系统调用都会到这个特定的系统调用函数，

490
00:39:36,410 --> 00:39:42,260
系统调用查找数字，然后决定传递给寄存器 a0 的数字，

491
00:39:42,690 --> 00:39:47,880
系统调用查找那个寄存器 a0 ，查看是哪个数字，

492
00:39:47,880 --> 00:39:49,890
然后调用比如 fork 系统调用。

493
00:39:52,670 --> 00:39:54,680
为了理解清楚，

494
00:39:54,680 --> 00:39:57,440
这里是用户和内核的硬边界，

495
00:39:57,590 --> 00:40:03,060
用户不能直接调用这个 fork ，

496
00:40:03,240 --> 00:40:10,110
用户程序调用 fork 的唯一方法是通过 ecall 指令。

497
00:40:12,570 --> 00:40:24,700
所以我们有另一个，有另一个系统调用，比如 write ，

498
00:40:27,720 --> 00:40:35,040
它也是类似的， write 系统调用不能直接调用内核中的 write 代码，

499
00:40:35,070 --> 00:40:40,650
而是调用包装函数，

500
00:40:41,160 --> 00:40:43,170
系统调用[停止]并调用 ecall ，

501
00:40:44,560 --> 00:40:52,380
函数 write ，执行 ecall 指令使用参数 sys_write ，表示 write 系统调用，

502
00:40:52,560 --> 00:41:01,450
将控制权给 syscall ，然后 syscall 可以分配到 write 系统调用。

503
00:41:01,690 --> 00:41:03,940
这里有两个问题，请继续（提问）。

504
00:41:09,910 --> 00:41:11,290
我想我们都举手了。

505
00:41:12,660 --> 00:41:14,580
好的，我可以先提问。

506
00:41:15,640 --> 00:41:21,190
我的问题是，怎样或在哪里检查，

507
00:41:21,940 --> 00:41:27,040
比如 fork 或 write ，它们是否允许，

508
00:41:27,520 --> 00:41:33,010
目前，你只是调用 ecall ，使用系统调用编号，

509
00:41:33,040 --> 00:41:41,020
但是内核在哪里决定程序可以调用特定的内核系统调用。

510
00:41:41,430 --> 00:41:42,690
是的，这是个好问题，

511
00:41:42,690 --> 00:41:47,730
理论上，在内核侧，我们真正运行 fork 的这边，

512
00:41:48,240 --> 00:41:50,490
它可以实现任何想要的安全检查，

513
00:41:50,550 --> 00:41:53,130
可以检查系统调用的参数，

514
00:41:53,400 --> 00:41:57,780
决定应用程序是否允许执行系统调用 fork ，

515
00:41:57,960 --> 00:42:01,980
在 Unix 中，任何应用程序都可以调用 fork ，

516
00:42:02,160 --> 00:42:04,710
让我们来讨论 write ，

517
00:42:04,740 --> 00:42:15,090
write 需要检查，传给 write 的地址是否属于应用程序，

518
00:42:15,460 --> 00:42:23,650
内核不能写数据到不属于该应用程序的地方，

519
00:42:25,610 --> 00:42:28,830
还有更多线索，请提问。

520
00:42:30,260 --> 00:42:31,940
是的，我有一个问题，

521
00:42:32,390 --> 00:42:37,460
内核如何夺回从用户程序夺回控制权，

522
00:42:37,490 --> 00:42:42,290
在用户程序是恶意的或处于无限循环的情况下。

523
00:42:42,680 --> 00:42:45,170
是的，这种情况的方法是，

524
00:42:45,170 --> 00:42:47,690
我们会在后面几周讨论更多的细节，

525
00:42:47,900 --> 00:42:52,880
方法是内核对硬件编程设置一个定时器，

526
00:42:53,460 --> 00:42:59,880
在定时器结束后，会触发从用户空间切换到内核模式，

527
00:42:59,970 --> 00:43:01,950
在这个时间点，内核重新获得控制权，

528
00:43:02,250 --> 00:43:06,540
然后内核可以重新调度 CPU 给其他进程。

529
00:43:07,590 --> 00:43:09,090
好的，理解了，谢谢。

530
00:43:09,760 --> 00:43:14,200
是的，我们会在一段时间之后看到具体细节。

531
00:43:15,200 --> 00:43:16,430
还有问题吗？

532
00:43:18,690 --> 00:43:20,790
是的，有一个高层次的问题，

533
00:43:20,790 --> 00:43:28,170
为什么设计者使用 C 语言来实现操作系统。

534
00:43:29,120 --> 00:43:32,150
好的，好问题，

535
00:43:32,330 --> 00:43:37,790
C 语音给了你控制硬件的能力，

536
00:43:38,150 --> 00:43:43,220
比如，你可以对定时器编程，

537
00:43:43,550 --> 00:43:47,450
在 C 语言中，很容易做到，

538
00:43:47,480 --> 00:43:51,620
因为你可以控制任何硬件资源，

539
00:43:51,650 --> 00:43:54,920
部分原因是你可以转换任何东西，

540
00:43:55,280 --> 00:43:59,660
所以， C 语言是非常方便的编程语言，

541
00:43:59,660 --> 00:44:03,260
如果你需要底层编程，特别是与硬件交互。

542
00:44:06,620 --> 00:44:08,660
这并不意味着你不能使用别的语言，

543
00:44:08,720 --> 00:44:11,690
但这是历史上 C 语言成功的原因。

544
00:44:12,940 --> 00:44:13,900
我明白了，谢谢。

545
00:44:15,230 --> 00:44:20,390
为什么 C 比 C++ 更流行，仅仅是历史原因吗，

546
00:44:20,420 --> 00:44:22,580
比如那些应用程序，

547
00:44:22,820 --> 00:44:30,080
或者其他原因，比如大多数操作系统没有采用 C++ 。

548
00:44:30,590 --> 00:44:31,760
是的，大多数操作系统，

549
00:44:31,760 --> 00:44:35,600
我相信使用 C++ 编写操作系统是完全可能的，

550
00:44:35,750 --> 00:44:39,500
可能大多数不是使用 C++ 编写，

551
00:44:40,020 --> 00:44:45,690
Linux 使用 C 而不是 C++ 的原因，

552
00:44:45,690 --> 00:44:48,420
我想部分是因为 Linus 不喜欢 C++ 。

553
00:44:54,640 --> 00:44:55,480
还有其他问题吗？

554
00:45:04,300 --> 00:45:06,860
好的，所以在这个角度来看，

555
00:45:06,890 --> 00:45:15,470
我们有一种方式将控制权转移到内核，使用系统调用，使用 ecall 指令，

556
00:45:15,800 --> 00:45:22,310
内核负责实现真正的函数，

557
00:45:22,490 --> 00:45:25,820
确保检查参数或类似的事情，

558
00:45:25,820 --> 00:45:30,680
保证不会被骗而做一些坏事，

559
00:45:30,950 --> 00:45:38,880
从这种角度看，内核有时候称为可信任计算基础，

560
00:45:46,920 --> 00:45:49,560
有时在安全术语中称为 TCB 。

561
00:45:51,680 --> 00:45:58,670
可信任计算基础意思是，它必须正确，必须没有 bug 。

562
00:46:05,690 --> 00:46:07,310
因为如果内核中有 bug ，

563
00:46:07,340 --> 00:46:08,900
需要考虑这种方式，

564
00:46:08,900 --> 00:46:14,810
可能攻击者会利用那个 bug ，使 bug 变成一个漏洞。

565
00:46:15,320 --> 00:46:22,700
那个漏洞可能允许特定攻击者打破隔离，或者控制内核。

566
00:46:23,220 --> 00:46:27,360
这很重要，内核必须尽可能没有 bug 。

567
00:46:29,620 --> 00:46:42,660
内核必须将用户程序当成是恶意的。

568
00:46:47,210 --> 00:46:51,950
就像我之前说的，内核设计者必须有安全思维模式，

569
00:46:52,160 --> 00:46:55,460
在编写和实现内核代码的时候。

570
00:46:56,060 --> 00:47:00,800
达成这个目标的关键是没有 bug ，

571
00:47:00,800 --> 00:47:04,970
如果操作系统非常庞大，那不是那么简单的，

572
00:47:04,970 --> 00:47:09,530
几乎所有操作系统，用户广泛使用的，

573
00:47:09,740 --> 00:47:15,200
有时也会有安全性 bug ，它们随着时间得到修复，

574
00:47:15,200 --> 00:47:20,740
但是不论怎样，总会在某个时刻出现新的漏洞，

575
00:47:21,280 --> 00:47:24,880
后面你会看到为什么保证所有东西正确是如此困难，

576
00:47:25,000 --> 00:47:30,490
但是，你要理解内核必须做这些困难的事情，

577
00:47:30,790 --> 00:47:35,560
它要操作硬件，而且必须很小心地检查，

578
00:47:35,620 --> 00:47:39,850
很容易犯一个小错误，造成出现 bug 。

579
00:47:42,160 --> 00:47:51,100
所以一个显而易见的问题是，什么应该运行在内核模式，

580
00:47:51,130 --> 00:47:58,900
因为在内核模式中的内核代码是敏感代码，是可信任计算基础。

581
00:47:59,350 --> 00:48:03,730
这个问题的一种答案是，

582
00:48:03,730 --> 00:48:09,530
我们有用户内核边界，这边是用户，这边是内核，

583
00:48:09,590 --> 00:48:16,730
用户程序运行，而这里是运行在内核模式的程序，

584
00:48:16,790 --> 00:48:20,360
一种选择是将整个操作系统置于内核模式，

585
00:48:20,860 --> 00:48:27,580
比如，在大多数 Unix 操作系统中，整个 Unix 实现运行在内核模式。

586
00:48:27,790 --> 00:48:34,840
在 xv6 中，所有操作系统服务都在内核模式，

587
00:48:35,310 --> 00:48:40,760
这被称为宏内核设计。

588
00:48:47,550 --> 00:48:52,040
可以从几方面考虑这个设计，

589
00:48:52,100 --> 00:48:56,090
一方面它可能对减少 bug 不友好，

590
00:48:58,910 --> 00:49:06,410
因为任何宏内核设计的 bug 可能成为漏洞，这是不好的，

591
00:49:06,830 --> 00:49:10,160
我们有一个很大的操作系统在内核中，

592
00:49:10,160 --> 00:49:11,900
可能会有更多 bug ，

593
00:49:11,900 --> 00:49:18,080
统计数据表明每千行代码都会有一些 bug ，

594
00:49:18,470 --> 00:49:21,170
所以如果你有很多行代码在内核中，

595
00:49:21,260 --> 00:49:27,410
出现严重 bug 的可能性就会变高，

596
00:49:27,500 --> 00:49:34,070
所以宏内核设计的缺点是，从安全角度来说，有很多代码在内核中。

597
00:49:34,900 --> 00:49:37,390
好的方面是，

598
00:49:37,390 --> 00:49:41,590
操作系统包含所有不同的部分，

599
00:49:41,590 --> 00:49:48,120
可能包含文件系统，可能包含虚拟内存，可能包含进程，

600
00:49:48,900 --> 00:49:53,430
在操作系统中有实现特定功能的不同的子模块。

601
00:49:54,100 --> 00:50:00,630
好的方面是，这些不同的子模块可以紧密结合，

602
00:50:00,780 --> 00:50:05,960
它们都在一个程序中，这种联系会带来很好的性能。

603
00:50:11,250 --> 00:50:17,070
举个例子，如果你查看 Linux 操作系统，它达到了很好的性能。

604
00:50:17,540 --> 00:50:22,300
还有另外一种设计，

605
00:50:22,330 --> 00:50:27,970
主要目标是减少内核中的代码，就是所谓的微内核设计。

606
00:50:35,100 --> 00:50:40,410
在这种设计中，目标是在内核模式中运行尽量少的代码，

607
00:50:40,710 --> 00:50:43,380
比如，有一些东西在内核中，

608
00:50:44,210 --> 00:50:48,230
但是内核中包含很少的组件，

609
00:50:48,230 --> 00:50:52,130
一般包含某种形式的 IPC 或消息传递，

610
00:50:53,030 --> 00:50:59,650
少量的虚拟内存支持，基本上，只有页表相关的东西，

611
00:50:59,800 --> 00:51:06,260
一些复用不同 CPU 的东西，复用代码。

612
00:51:09,610 --> 00:51:14,500
但是通常的目标是使操作系统 bug 处于内核之外。

613
00:51:15,040 --> 00:51:18,310
比如，我们在这里有边界，

614
00:51:18,610 --> 00:51:24,700
我们要做的是把内核的其他部分当作普通用户程序，

615
00:51:24,730 --> 00:51:36,030
比如，你可能有一个用户进程，

616
00:51:36,180 --> 00:51:39,090
不是我想要的（颜色），但没关系，

617
00:51:39,420 --> 00:51:41,660
我做的是文件服务器，

618
00:51:42,280 --> 00:51:45,760
文件服务器只是在普通用户空间，

619
00:51:46,610 --> 00:51:47,990
用户空间，内核，

620
00:51:48,020 --> 00:51:52,310
尽管我意外使用了红色来画图，我希望是使用黑色，

621
00:51:52,490 --> 00:51:58,550
文件系统就像用户程序，比如 echo shell ，

622
00:51:58,580 --> 00:52:00,050
它们都运行在用户空间，

623
00:52:00,050 --> 00:52:02,030
我们可能有其他的用户程序，

624
00:52:02,030 --> 00:52:09,240
比如部分虚拟内存系统在用户模式运行普通用户程序。

625
00:52:09,920 --> 00:52:11,450
所以这是一种不错的设计，

626
00:52:11,450 --> 00:52:15,710
因为内核中的代码量可能很少。

627
00:52:18,820 --> 00:52:22,870
很少意味着更少的 bug 。

628
00:52:28,060 --> 00:52:33,040
一个问题是，当然我们需要安排 shell 可以访问文件系统，

629
00:52:33,040 --> 00:52:37,690
比如， shell 调用 exec ，必许有一种方式访问文件系统，

630
00:52:37,990 --> 00:52:44,850
通常工作方式是， shell 通过 IPC 系统发送一个消息给内核，

631
00:52:45,300 --> 00:52:50,460
内核查看，知道需要访问文件系统，发送给文件系统，

632
00:52:51,590 --> 00:52:55,050
文件系统工作，返回一条消息，

633
00:52:55,410 --> 00:52:58,650
表明这是 exec 系统调用的结果，

634
00:52:58,740 --> 00:53:00,960
然会发回给 shell 。

635
00:53:01,830 --> 00:53:06,270
所以，这通常是使用消息实现的，

636
00:53:06,270 --> 00:53:09,420
所以对于任何与文件服务的交互，

637
00:53:09,480 --> 00:53:15,240
现在必须跳入内核，跳出内核，再跳入内核，再跳出内核。

638
00:53:15,730 --> 00:53:17,560
与前面的设计比较，

639
00:53:17,950 --> 00:53:23,830
访问文件系统，有一次系统调用跳入，一次跳出。

640
00:53:24,320 --> 00:53:28,100
所以系统调用次数翻了一番。

641
00:53:28,860 --> 00:53:37,230
所以微内核方式的一个典型的问题或挑战是如何获得高性能。

642
00:53:37,890 --> 00:53:39,600
它由两部分组成，

643
00:53:40,700 --> 00:53:47,190
一个是在用户模式和内核之间来回切换来完成事情，

644
00:53:47,520 --> 00:53:54,120
第二是，因为不同的部分彼此隔离，没有紧密结合，

645
00:53:54,210 --> 00:53:56,900
使得安排更复杂，

646
00:53:56,900 --> 00:53:59,750
比如在宏内核中，每个部分都可以，

647
00:54:00,020 --> 00:54:04,610
比如文件系统，虚拟内存系统可以很容易地共享页缓存，

648
00:54:04,730 --> 00:54:07,370
这在微内核设计中是比较难的，

649
00:54:07,370 --> 00:54:10,700
因此，有时它更难获得高性能。

650
00:54:12,170 --> 00:54:16,250
这些是微内核和宏内核高层次的区别，

651
00:54:16,280 --> 00:54:20,390
在实践中，两种内核设计都有应用，

652
00:54:20,690 --> 00:54:27,410
因为历史原因，大多数桌面操作系统是宏内核系统。

653
00:54:27,840 --> 00:54:33,300
很多，如果你运行密集型，操作系统密集型应用程序，

654
00:54:33,300 --> 00:54:37,080
比如数据中心，它们一般运行在宏内核，

655
00:54:37,410 --> 00:54:40,830
主要是因为 Linux 提供了良好的性能，

656
00:54:40,980 --> 00:54:48,060
但是很多嵌入式系统比如 Minix 或 seL4 ，

657
00:54:48,060 --> 00:54:50,490
它们往往是微内核设计。

658
00:54:51,490 --> 00:54:52,930
两种设计都很流行，

659
00:54:53,200 --> 00:54:56,230
你可以从头开始设计一个新的操作系统，

660
00:54:56,470 --> 00:55:02,830
你可以从一个微内核设计开始。

661
00:55:03,300 --> 00:55:06,840
一旦你有一个像 Linux 的宏内核设计，

662
00:55:06,990 --> 00:55:11,190
重写成微内核设计会有很多工作要做，

663
00:55:11,190 --> 00:55:13,710
可能不利于[激励]，

664
00:55:13,710 --> 00:55:21,150
人们更想花时间来增加新功能，而不是重新设计内核。

665
00:55:22,190 --> 00:55:26,630
这是两种主要的设计，

666
00:55:26,630 --> 00:55:32,150
如你所知， xv6 是宏内核设计，是经典 Unix 系统所采用的，

667
00:55:32,390 --> 00:55:38,210
但是在本学期晚些时候，我们会讨论更多微内核设计的细节。

668
00:55:40,180 --> 00:55:45,130
还有什么问题吗，因为这是邮件问题中的热门话题。

669
00:55:54,630 --> 00:55:55,260
好的。

670
00:55:56,060 --> 00:55:58,640
好的，让我转换一下，

671
00:55:58,670 --> 00:56:03,980
我会转到一些代码，看看这些在 xv6 中是如何运行的。

672
00:56:05,930 --> 00:56:08,990
这里有两个窗口。

673
00:56:09,840 --> 00:56:14,010
在 emacs 窗口，是 proc 结构体，

674
00:56:14,400 --> 00:56:19,470
我首先做的是，查看一下代码库，

675
00:56:19,500 --> 00:56:21,000
你们可能已经做过了，

676
00:56:21,060 --> 00:56:26,880
你可以看到代码分为三个部分，一个是 kernel 。

677
00:56:27,700 --> 00:56:32,530
kernel 包含了所有的内核文件，

678
00:56:33,130 --> 00:56:40,210
xv6 是宏内核，所有这些程序编译成一个二进制文件 kernel ，

679
00:56:40,210 --> 00:56:42,220
那就是运行在内核模式的部分。

680
00:56:43,350 --> 00:56:48,390
然后有 user 部分，这些就是运行在用户模式的程序。

681
00:56:48,420 --> 00:56:51,360
这也是为什么一个叫做 kernel ，另一个叫做 user 。

682
00:56:52,080 --> 00:56:54,300
然后，还有一个程序叫做 mkfs ，

683
00:56:54,810 --> 00:57:00,240
它会构建一个空文件系统镜像，保存在磁盘上，

684
00:57:00,600 --> 00:57:04,350
让我们可以从一个空文件系统开始。

685
00:57:09,160 --> 00:57:12,940
好的，在继续之前，再次切换到，

686
00:57:12,940 --> 00:57:15,400
我想说一下内核是如何编译的。

687
00:57:16,130 --> 00:57:21,890
你可能已经看到这个，没有注意它，但理解它是很重要的。

688
00:57:22,460 --> 00:57:26,650
所以当 kernel ， kernel 的结构，

689
00:57:26,680 --> 00:57:31,120
makefile 选取 C 文件中的一个，比如 proc.c ，

690
00:57:31,950 --> 00:57:39,780
调用 GCC 编译器生成文件 proc.S ，

691
00:57:40,200 --> 00:57:41,700
再通过汇编器，

692
00:57:44,780 --> 00:57:47,120
这个是 RISC-V 汇编代码，

693
00:57:49,360 --> 00:57:55,180
然后产生一个文件 proc.o ，这是汇编程序的二进制版本，

694
00:57:57,140 --> 00:58:00,950
makefile 对 kernel 中的文件执行这个规则，

695
00:58:00,950 --> 00:58:05,810
比如，另一个， pipe ，也是同样的流程，

696
00:58:05,810 --> 00:58:13,100
GCC 将其编译成 pipe.S ，再通过汇编器我们得到 pipe.o 。

697
00:58:14,080 --> 00:58:21,320
然后加载器使用所有不同文件生成的 .o 文件，

698
00:58:21,320 --> 00:58:25,370
将它们链接在一起，生成 kernel 。

699
00:58:28,480 --> 00:58:30,040
就是我们要运行的东西。

700
00:58:30,880 --> 00:58:36,070
为了方便， makefile 也生成一个文件 kernel.asm ，

701
00:58:39,110 --> 00:58:44,240
它包含所有 kernel 反汇编代码，

702
00:58:44,270 --> 00:58:48,560
你可以查看它，在有内核 bug 的时候提供帮助，

703
00:58:48,560 --> 00:58:53,330
可以很容易看到 bug 发生时的指令。

704
00:58:53,820 --> 00:59:05,130
比如，这是 kernel.asm ，我们可以看到这是内核汇编指令。

705
00:59:05,640 --> 00:59:14,430
你需要知道一件事情，第一条指令位于地址 80000000 ，

706
00:59:14,430 --> 00:59:18,030
它是 auipc 指令， RISC-V 指令。

707
00:59:20,710 --> 00:59:23,870
有人知道这些是什么吗，

708
00:59:23,960 --> 00:59:27,980
0000a117, 83010113, 6505 。

709
00:59:34,730 --> 00:59:36,290
有人想回答这个问题吗？

710
00:59:36,880 --> 00:59:40,390
那是右边汇编指令的十六进制版本？

711
00:59:41,040 --> 00:59:41,850
是的，完全正确，

712
00:59:41,850 --> 00:59:50,480
所以 0000a117 是与文本的 auipc 相同的东西，

713
00:59:50,540 --> 00:59:54,710
所以这是实际指令的二进制编码。

714
00:59:56,150 --> 00:59:58,460
所以，每个指令都有二进制编码，

715
00:59:58,700 --> 01:00:02,360
kernel.asm 文件显示了这些二进制编码。

716
01:00:03,600 --> 01:00:04,650
这有时是很方便的，

717
01:00:04,650 --> 01:00:07,830
当你查看 GDB ，想知道实际发生了什么，

718
01:00:07,830 --> 01:00:09,600
你就可以看到二进制编码。

719
01:00:12,060 --> 01:00:12,750
好的。

720
01:00:13,610 --> 01:00:17,600
好的，当我们运行 xv6 ，我要运行，

721
01:00:17,600 --> 01:00:20,060
让我先在没有 GDB 的情况下运行。

722
01:00:20,650 --> 01:00:25,270
你知道编译很多东西，然后调用 QEMU 。

723
01:00:25,910 --> 01:00:31,550
这是一个 C 程序，用来模拟 RISC-V 处理器。

724
01:00:32,180 --> 01:00:35,840
你可以在这里看到 -kernel 标志，传递了内核，

725
01:00:36,380 --> 01:00:40,820
作为一个可以在 QEMU 中运行的程序，

726
01:00:41,180 --> 01:00:49,100
QEMU 和 内核约定任何程序的起始点是地址 80000000 。

727
01:00:50,120 --> 01:00:52,220
我们可以看到我们传递了很多标志给 QEMU ，

728
01:00:52,220 --> 01:01:00,140
m ，是虚拟机拥有的内存量，这个 RISC-V 机器，

729
01:01:00,140 --> 01:01:05,120
传递多少个 CPU 核，传递给这个机器，

730
01:01:05,120 --> 01:01:08,510
磁盘包含文件 fs.img 。

731
01:01:08,880 --> 01:01:12,930
所以设置了很多东西让 QEMU 像一台真正的计算机。

732
01:01:14,620 --> 01:01:17,200
所以你考虑 QEMU 的一种方式是，

733
01:01:17,320 --> 01:01:20,590
不要把它想成是一个 C 程序，

734
01:01:20,590 --> 01:01:23,590
而是想成像下面这样，

735
01:01:24,640 --> 01:01:34,950
把它想成这个，一块真正的电路板。

736
01:01:35,680 --> 01:01:39,340
比如，左边这个是一块 RISC-V 电路板，

737
01:01:39,580 --> 01:01:42,070
实际上，这块 RISC-V 电路板在我的办公室里，

738
01:01:42,490 --> 01:01:45,730
它可以启动 xv6 。

739
01:01:46,310 --> 01:01:50,180
所以当你在 QEMU 上运行你的内核，

740
01:01:50,180 --> 01:01:52,790
你应该想成是运行在这块板上。

741
01:01:53,360 --> 01:01:56,270
这块板有开关按钮，

742
01:01:56,420 --> 01:01:59,960
这里是 RISC-V 处理器，

743
01:02:00,350 --> 01:02:06,920
这里有外设空间，比如其中之一是以太网接口。

744
01:02:07,480 --> 01:02:10,540
一个是 PCIe 插槽，

745
01:02:10,540 --> 01:02:15,910
板上有 RAM 芯片，我不知道在哪里，但确实有。

746
01:02:16,480 --> 01:02:22,540
所以这是你编程的计算机硬件资源，

747
01:02:22,570 --> 01:02:28,190
所以 xv6 管理这块板，这是你脑海中通常会有的图像。

748
01:02:29,010 --> 01:02:35,270
实际上，如果你放大，你可以找到内部的所有文档。

749
01:02:35,790 --> 01:02:41,010
这个内部， RISC-V 处理器内部，

750
01:02:41,160 --> 01:02:45,090
RISC-V 处理器结构显示在这张图片上。

751
01:02:45,730 --> 01:02:51,090
这里可以看到有多个内核，实际上是四核，

752
01:02:51,600 --> 01:02:54,810
有一个 l2 缓存，

753
01:02:55,050 --> 01:02:58,170
有一个到 DRAM 的接口，

754
01:02:58,200 --> 01:03:01,020
有多种方式可以连接到外部世界，

755
01:03:01,020 --> 01:03:02,670
比如，这个是 UART0 ，

756
01:03:02,970 --> 01:03:08,790
UART0 连接着，一端是键盘，另一端是显示器。

757
01:03:09,300 --> 01:03:14,460
这里有让时钟运行的方法，

758
01:03:14,700 --> 01:03:16,980
后面我会讲到更多细节，

759
01:03:17,070 --> 01:03:24,210
但是这些是 xv6 或你要修改的东西与真实硬件交互的组件。

760
01:03:24,910 --> 01:03:33,050
事实上，计算机系统或计算机板与 QEMU 模拟的非常相似，

761
01:03:33,050 --> 01:03:38,450
除了 SiFive 制造的电路板的上的一些小细节。

762
01:03:39,450 --> 01:03:44,070
遗憾的是，我不能坐在办公室里展示真实的东西，

763
01:03:44,070 --> 01:03:47,910
自从三月，我就没有去过我的办公室了，可能积了很多灰尘，

764
01:03:48,600 --> 01:03:54,390
但是记住这点很重要，当你运行 QEMU ，你就像运行在真正的硬件上。

765
01:03:55,000 --> 01:03:56,830
只是能够使用软件。

766
01:04:02,620 --> 01:04:05,890
能理解吗，这里的[]。

767
01:04:11,560 --> 01:04:13,540
让我来多讲一点，

768
01:04:13,570 --> 01:04:21,680
QEMU 模拟 RISC-V 处理器是什么意思。

769
01:04:24,940 --> 01:04:31,420
如果你考虑它，像我说的， QEMU 是一个开源的 C 程序，

770
01:04:31,420 --> 01:04:35,410
它是一个很大的程序，你可以下载或 clone 它。

771
01:04:36,020 --> 01:04:40,990
但是 C 代码内部是一个 for 循环，一个无限 for 循环，

772
01:04:42,220 --> 01:04:53,140
它只是读指令， RISC-V 指令，读取 4 或 8 个字节，

773
01:04:53,530 --> 01:05:00,470
检查指令的比特位并对其进行解码，弄清操作码是什么。

774
01:05:03,620 --> 01:05:08,840
我们看到了一些指令，在 .asm 文件中的指令的二进制版本，

775
01:05:09,260 --> 01:05:16,730
解码指令，比如这是一条 add 指令， sub 指令，

776
01:05:16,730 --> 01:05:22,630
然后它在软件中执行指令。

777
01:05:25,240 --> 01:05:30,310
这就是它所做的，在每个核心上运行这个循环。

778
01:05:31,010 --> 01:05:35,780
除了做这些，这个循环还需要维护一些状态，维护所有寄存器状态。

779
01:05:37,020 --> 01:05:42,750
所以它有 C 风格的寄存器， x0 x1 等等。

780
01:05:44,280 --> 01:05:46,260
所以当它执行指令时，

781
01:05:46,260 --> 01:05:55,740
指令比如是 add a0, 1 到 7 ，然后存入 a0 ，

782
01:05:55,830 --> 01:06:01,600
它获取常数 7 和 1 ，把它们加起来并放入 a0 ，比如存入 7 。

783
01:06:02,190 --> 01:06:04,830
然后执行下一条指令，并继续执行。

784
01:06:05,900 --> 01:06:12,680
除了模拟所有非特权指令，它也模拟所有特权指令。

785
01:06:13,380 --> 01:06:17,400
这就是 QEMU 实质上所做的，

786
01:06:17,430 --> 01:06:22,020
对你来说，脑海中最好的图像是运行在一个真正的 RISC-V 处理器上，

787
01:06:22,610 --> 01:06:26,930
像你可能已经做过的，你们中许多人在 6.004 课程实现的那个。

788
01:06:30,310 --> 01:06:31,420
关于这个，有什么问题吗？

789
01:06:32,770 --> 01:06:40,150
是的，我想知道，它有没有采用什么硬件技巧，比如指令重叠或其他的。

790
01:06:41,000 --> 01:06:45,170
没有，它运行在一个真正的处理器上，

791
01:06:45,170 --> 01:06:48,770
当你运行 QEMU ，它可能运行在 x86 处理器上，

792
01:06:49,340 --> 01:06:54,470
那个 x86 处理器做了所有技巧，指令流水线或其他的，

793
01:06:54,470 --> 01:06:57,080
所以应该只是把 QEMU 当成一个 C 程序。

794
01:07:00,580 --> 01:07:01,750
理解了，谢谢。

795
01:07:08,350 --> 01:07:09,790
那么关于多线程呢，

796
01:07:09,790 --> 01:07:15,370
如果 QEMU 支持四核还是只支持一核，

797
01:07:15,670 --> 01:07:19,360
在这种情况下，它是否真正支持多线程。

798
01:07:20,020 --> 01:07:26,230
是的，我们在 Athena 上使用的或是你下载的 QEMU ，

799
01:07:26,230 --> 01:07:31,270
它们内部会使用多线程， QEMU 使用它获得并行能力，

800
01:07:31,270 --> 01:07:37,000
实际上，模拟的四核就是并行模拟的。

801
01:07:40,040 --> 01:07:43,850
我们将在后面的实验中看到，这是如何发挥作用的。

802
01:07:44,530 --> 01:07:48,010
所以，这些核心之间肯定是有真正的并行的。

803
01:07:54,090 --> 01:08:02,420
好的，我会查看 xv6 ，

804
01:08:02,420 --> 01:08:04,670
来了解一下它的结构是什么样的，

805
01:08:05,140 --> 01:08:08,260
在后面的课程中，我们会知道更多细节。

806
01:08:08,830 --> 01:08:13,930
所以我启动 QEMU ，并支持 GDB ，

807
01:08:13,930 --> 01:08:16,960
QEMU 内部支持 GDB 服务器。

808
01:08:17,560 --> 01:08:24,230
它启动了，等待 GDB 连接。

809
01:08:24,380 --> 01:08:29,570
在我的电脑上运行 risc64-linux-gnu-gdb 。

810
01:08:30,120 --> 01:08:33,930
在你们的电脑上，可能是 multi-arch 或其他东西，

811
01:08:34,170 --> 01:08:38,100
但是是为 RISC-V 64 编译的 GDB 。

812
01:08:39,580 --> 01:08:43,120
我在入口处设置断点，

813
01:08:43,120 --> 01:08:49,390
因为我们知道这是实际工作时跳到的第一条指令。

814
01:08:50,050 --> 01:08:51,730
我设置断点并运行，

815
01:08:52,150 --> 01:08:57,010
不是准确地在 8000 处中断，而是在 0a 处，

816
01:08:57,190 --> 01:08:58,750
我们查看右边，

817
01:08:59,050 --> 01:09:08,760
看到 0a 是读取控制系统寄存器 mhartid ，并加载它的值到 a1 中。

818
01:09:09,700 --> 01:09:15,010
所以 QEMU 模拟指令，执行指令，然后继续下一条指令。

819
01:09:16,800 --> 01:09:26,850
这个地址 8000 就是一个 QEMU 指定的地址，

820
01:09:26,850 --> 01:09:32,640
表明，如果你想使用 QEMU ，跳转到的第一条指令是那个地址。

821
01:09:33,170 --> 01:09:40,570
我们安排内核加载器加载 kernel 程序，

822
01:09:40,570 --> 01:09:45,760
有一个文件 kernel.ld ，指明内核应该如何加载，

823
01:09:46,000 --> 01:09:52,750
你可以在这里看到，内核使用的第一个地址就是 QEMU 指定的那个地址。

824
01:09:54,120 --> 01:09:55,380
我们就是这样开始的。

825
01:09:58,440 --> 01:09:59,610
能理解吗？

826
01:10:04,800 --> 01:10:10,950
我们可以在这里看到， GDB 显示了指令的二进制编码。

827
01:10:11,650 --> 01:10:19,880
我们可以看到，我猜 csrr 是四字节指令， addi 是两字节指令。

828
01:10:22,090 --> 01:10:29,350
好的，我要看一下，实际上是从 entry.S 开始的，

829
01:10:29,350 --> 01:10:32,590
没有分页，没有隔离，实际上开始于机器模式，

830
01:10:33,260 --> 01:10:40,400
xv6 尽快跳转到内核模式或者 RISC-V 中说的管理者模式，

831
01:10:40,580 --> 01:10:44,570
我在 main 设置一个断点，它运行在管理者模式，

832
01:10:44,630 --> 01:10:48,840
我运行到这里，然后达到 main 中的第一条指令，

833
01:10:48,960 --> 01:10:52,720
所以，让我来显示这个，这是 main ，

834
01:10:55,040 --> 01:10:59,060
我想在这种布局下运行 GDB ，分离模式。

835
01:11:02,290 --> 01:11:06,070
所以你可以在 GDB 中看到，接下来执行哪条指令，

836
01:11:06,070 --> 01:11:08,680
你可以看到，有一个断点在那个指令处。

837
01:11:09,260 --> 01:11:16,480
因为 QEMU 使用单 CPU 运行，使 GDB 更简单，

838
01:11:16,720 --> 01:11:21,860
所以只有一个核心活跃， QEMU 只模拟了一个核心，

839
01:11:22,190 --> 01:11:26,510
我可以单步运行，我可以运行到下一条指令，

840
01:11:26,510 --> 01:11:32,360
调用函数 consoleinit ，它所做的就是你所想的，设置 console 。

841
01:11:32,940 --> 01:11:36,150
一旦我们设置好 console ，就能打印东西，

842
01:11:36,210 --> 01:11:41,280
所以，随后你会看到新的一行，看到 xv6 booting 。

843
01:11:42,220 --> 01:11:47,230
好的，还有一些代码用来设置，

844
01:11:47,230 --> 01:11:50,140
有设置页面分配器，

845
01:11:50,290 --> 01:11:54,040
设置虚拟内存，我会在周三讨论，

846
01:11:54,190 --> 01:11:57,910
加载启用页面，我也会在周三讨论，

847
01:11:58,300 --> 01:12:02,860
设置初始进程，或设置进程表，

848
01:12:02,860 --> 01:12:05,890
根据内核位置设置代码，

849
01:12:06,340 --> 01:12:11,590
设置中断控制 plic ，我们会在讨论中断的时候讨论，

850
01:12:11,590 --> 01:12:18,750
但它是，我们使用中断访问磁盘，使用中断访问 console ，

851
01:12:19,140 --> 01:12:22,770
设置文件系统，分配 buffer 缓存，

852
01:12:24,240 --> 01:12:28,530
初始化 inode 缓存，初始化文件系统，初始化磁盘，

853
01:12:29,050 --> 01:12:33,550
一旦设置好所有东西，当操作系统运行时，

854
01:12:33,670 --> 01:12:37,180
可以开始运行第一个进程， userinit 进程。

855
01:12:37,890 --> 01:12:41,190
这里比较有意思，所以我要转到 userinit ，

856
01:12:41,250 --> 01:12:43,680
稍等，我会单步运行到那里。

857
01:12:46,040 --> 01:12:48,740
在继续之前，关于这些有什么问题吗？

858
01:12:54,180 --> 01:12:58,050
调用这些设置函数有特定顺序吗？

859
01:12:58,410 --> 01:13:04,920
是的，一些函数必须在其他函数之后运行，它们比较特别，

860
01:13:05,370 --> 01:13:08,880
其中一些无关紧要，但是有一些在其他之后运行是很重要的。

861
01:13:11,370 --> 01:13:11,850
好问题。

862
01:13:12,840 --> 01:13:18,440
好的，让我们转到 userinit ，

863
01:13:19,290 --> 01:13:22,980
基本上 userinit 有一些胶水代码，组织代码，

864
01:13:22,980 --> 01:13:28,740
利用所有[基础设施]，让第一个进程启动。

865
01:13:29,440 --> 01:13:35,440
xv6 需要一些镜像，我们不能真正运行文件系统或 exec ，

866
01:13:35,710 --> 01:13:39,790
所以 xv6 需要一些小的程序来启动，

867
01:13:39,880 --> 01:13:43,540
这个小程序就是 initcode ，

868
01:13:44,100 --> 01:13:49,560
这个程序的二进制版本已经静态链接或声明在内核中，

869
01:13:50,100 --> 01:13:57,030
事实上，这些代码对应这个用户程序，

870
01:14:00,290 --> 01:14:03,530
它是一个由汇编代码写成的程序，

871
01:14:03,740 --> 01:14:08,090
基本上，它加载地址 init 到 a0 ，

872
01:14:08,090 --> 01:14:10,730
加载地址 argv 到 a1 ，

873
01:14:11,150 --> 01:14:14,870
然后加载 exec 的系统调用编号到 a7 ，

874
01:14:14,930 --> 01:14:17,660
然后看这里，它调用 ecall 。

875
01:14:18,490 --> 01:14:19,750
它说做的是，

876
01:14:19,750 --> 01:14:30,950
执行三条指令，再执行第四条指令，将控制权转移回操作系统，

877
01:14:30,980 --> 01:14:36,520
如果我在 syscall 设置一个断点，并继续执行，

878
01:14:36,520 --> 01:14:42,620
然后 userinit 会创建初始进程，进入用户空间，

879
01:14:43,040 --> 01:14:48,260
执行这三条指令或四条指令，再返回内核空间。

880
01:14:49,040 --> 01:14:53,900
所以，这是 xv6 中用户程序运行的第一个系统调用，

881
01:14:53,930 --> 01:15:00,660
让我们看看会发生什么，所以继续，我们到达 syscall 。

882
01:15:04,540 --> 01:15:08,290
我们可以查看 syscall ，它是最下面的一个函数。

883
01:15:09,340 --> 01:15:16,360
现在我们回到内核空间了，我们看看 syscall 到底发生了什么，

884
01:15:16,360 --> 01:15:22,490
我会单步运行，看看它里面的过程，

885
01:15:22,490 --> 01:15:25,820
它拿出使用的系统调用编号，

886
01:15:25,820 --> 01:15:29,290
我们现在可以打印 num ，它的值是 7 。

887
01:15:29,980 --> 01:15:38,060
如果我们查看 kernel 里的 syscall.h ，

888
01:15:38,660 --> 01:15:40,610
里面定义了所有系统调用编号，

889
01:15:40,610 --> 01:15:44,030
我们可以看到 7 是系统调用 exec 。

890
01:15:44,940 --> 01:15:50,550
这告诉内核，某些用户程序调用 ecall 指令，

891
01:15:50,550 --> 01:15:59,950
想要调用，想要运行 exec 系统调用。

892
01:16:00,900 --> 01:16:03,030
我们可以再单步执行几步，

893
01:16:03,120 --> 01:16:06,420
我们到下一步，这一行执行 syscall ，

894
01:16:06,420 --> 01:16:11,790
让我们到那里，可以看到 num 作为一个数组的索引，

895
01:16:11,790 --> 01:16:13,830
这个数组有很多函数指针，

896
01:16:14,220 --> 01:16:20,130
[包括] SYS_exec 入口，指向 sys_exec 函数，

897
01:16:20,160 --> 01:16:21,840
所以我们单步运行到这里。

898
01:16:22,920 --> 01:16:31,790
我们看到我们在 sys_exec ，它在 sysfile 文件中。

899
01:16:32,810 --> 01:16:36,200
我们可以在这个窗口中移动多一点，

900
01:16:36,530 --> 01:16:40,970
我们可以在这里看到，系统调用。

901
01:16:41,670 --> 01:16:45,900
首先，它从用户空间获取参数，

902
01:16:45,900 --> 01:16:47,310
它获取路径名，

903
01:16:47,840 --> 01:16:50,090
我们跳的更远一些，

904
01:16:50,970 --> 01:17:02,090
memset ，为参数分配空间，将所有参数从用户空间复制到内核空间，

905
01:17:02,090 --> 01:17:05,030
我们会在后面几周看到更多细节，

906
01:17:05,030 --> 01:17:06,620
现在不用过多考虑它。

907
01:17:07,210 --> 01:17:11,500
基本上是有一些代码将参数从用户空间移动到内核空间，

908
01:17:11,500 --> 01:17:14,530
从用户地址空间到内核地址空间。

909
01:17:15,120 --> 01:17:18,300
我们查看 path ，你可以打印 path ，

910
01:17:18,750 --> 01:17:21,720
你会看到这是一个字符串，

911
01:17:21,750 --> 01:17:26,130
你会看到那个小 init 程序所做的，

912
01:17:26,310 --> 01:17:31,650
试图 exec init 程序，这是另一个程序了。

913
01:17:31,650 --> 01:17:35,220
所以，让我们看一下这里发生了什么。

914
01:17:38,140 --> 01:17:42,990
这里是 init ， init 基本上是为用户空间设置一些东西，

915
01:17:43,380 --> 01:17:48,870
打开 console ， console 的文件描述符，复制几次，调用 fork ，

916
01:17:49,440 --> 01:17:55,950
基本上第一件事情是，它创建一个进程，然后 exec shell ，

917
01:17:56,480 --> 01:18:00,140
最后 shell 可以运行。

918
01:18:01,030 --> 01:18:04,240
如果我继续，可能会再次中断，在 exec ，

919
01:18:04,240 --> 01:18:10,900
查看它的参数，实际上 exec 是在 exec shell 。

920
01:18:11,520 --> 01:18:14,010
一旦 exec shell ，让我们先这样做，

921
01:18:14,580 --> 01:18:18,660
然后会调用更多系统调用，某个时刻你会看到。

922
01:18:19,880 --> 01:18:23,390
好的，让我继续，然后 shell 就运行了。

923
01:18:24,930 --> 01:18:29,730
所以，这给了你一些感觉， xv6 是如何开始的，

924
01:18:29,730 --> 01:18:31,560
第一个 shell 运行，

925
01:18:31,740 --> 01:18:37,380
我们看到第一个系统调用是如何发生的。

926
01:18:38,180 --> 01:18:43,070
我们没有深入了解系统调用是如何进入退出的，

927
01:18:43,280 --> 01:18:47,960
我们会在后面几周的课程中讨论更多细节，

928
01:18:47,990 --> 01:18:52,310
但是这对于 syscall 实验已经足够了，

929
01:18:52,340 --> 01:18:54,230
这是我们这周布置的实验。

930
01:18:54,590 --> 01:18:57,590
所以这些是你们要了解的部分。

931
01:18:59,120 --> 01:19:02,390
在我结束之前，有什么问题吗，因为我们快没有时间了。

932
01:19:08,330 --> 01:19:09,470
你可以随意提问。

933
01:19:15,680 --> 01:19:21,410
我们有关于网络的东西吗，比如网络的实验。

934
01:19:21,830 --> 01:19:25,130
是的，最后一个实验是实现一个网络驱动，

935
01:19:25,620 --> 01:19:27,990
你需要写一些代码与硬件交互，

936
01:19:27,990 --> 01:19:34,290
你需要操作网卡网络驱动的寄存器，

937
01:19:34,680 --> 01:19:37,380
网卡连接在 RISC-V 板上，

938
01:19:37,380 --> 01:19:41,460
你可以看到它是一根电缆，插入以太网控制器，

939
01:19:41,820 --> 01:19:46,100
这里有一个以太网卡，你需要对它编程，

940
01:19:46,100 --> 01:19:48,950
你可以真正地通过互联网发送一些包。

941
01:19:51,680 --> 01:19:52,640
好的，谢谢。

942
01:19:52,940 --> 01:19:53,990
是的，那是最后一个实验。

943
01:19:58,160 --> 01:19:59,060
还有别的问题吗？

944
01:20:04,250 --> 01:20:05,330
让我来结束一下，

945
01:20:05,330 --> 01:20:12,410
我想 syscall 实验，因为我们没有深入很多细节，希望它不会太难，

946
01:20:12,440 --> 01:20:14,450
它可能比 util 实验简单，

947
01:20:14,940 --> 01:20:17,970
下一个实验可能比较难，

948
01:20:18,210 --> 01:20:20,100
所以想让所有实验正确是比较困难的，

949
01:20:20,100 --> 01:20:23,280
但是 syscall 实验不会太难，

950
01:20:23,280 --> 01:20:27,480
但是不要太晚开始，要早点开始，

951
01:20:27,660 --> 01:20:30,720
如果你遇到疑难的 bug ，我们可以帮助你，

952
01:20:30,780 --> 01:20:33,360
确保你的程序可以正常工作。

953
01:20:35,270 --> 01:20:39,830
就是这些，我要退出了，周三见。

