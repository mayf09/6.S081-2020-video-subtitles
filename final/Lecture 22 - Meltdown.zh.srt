1
00:00:00,950 --> 00:00:03,580
好的，有人听到我说话吗？

2
00:00:04,210 --> 00:00:05,980
好的。

3
00:00:07,480 --> 00:00:08,890
好的，今天我们要讲 meltdown ，

4
00:00:09,370 --> 00:00:13,210
我读这篇论文是因为，

5
00:00:13,690 --> 00:00:18,400
安全一直是一个话题，

6
00:00:18,400 --> 00:00:21,880
在内核的设计中出现了很多问题，

7
00:00:21,940 --> 00:00:23,530
我们在课程中谈到的，

8
00:00:24,400 --> 00:00:27,820
我们所知的主要策略，我们已经讨论过，

9
00:00:28,330 --> 00:00:32,320
内核主要提供安全的是隔离，

10
00:00:33,460 --> 00:00:36,280
用户程序可以从内核读取数据，

11
00:00:36,280 --> 00:00:40,780
但是用户程序不能读取其他用户的数据，

12
00:00:41,500 --> 00:00:45,590
我们看到的特别技术，

13
00:00:45,590 --> 00:00:48,740
操作系统为了实现隔离，

14
00:00:48,740 --> 00:00:51,620
或者硬件中的用户管理者模式之类的东西，

15
00:00:51,770 --> 00:00:53,870
以及硬件中的页表，

16
00:00:54,650 --> 00:00:59,090
以及一些设计精良的内核软件，

17
00:00:59,090 --> 00:01:00,740
比如系统调用是防御性的，

18
00:01:00,740 --> 00:01:05,720
对于如何使用用户提供的指针。

19
00:01:07,460 --> 00:01:09,680
但是值得思考的是，

20
00:01:09,770 --> 00:01:13,220
看看这类事情是如何出错的，

21
00:01:13,250 --> 00:01:16,910
我的意思是，内核努力提供隔离和安全，

22
00:01:16,910 --> 00:01:19,400
但是出现了一些问题。

23
00:01:19,550 --> 00:01:24,980
这篇论文是最有趣的问题之一，

24
00:01:24,980 --> 00:01:28,160
这是最近出现的操作系统安全问题。

25
00:01:28,520 --> 00:01:30,740
Meltdown 出现了，

26
00:01:30,740 --> 00:01:35,090
它在 2018 年初发布的，不久之前，

27
00:01:35,810 --> 00:01:38,390
很多人像我一样都觉得很惊讶，

28
00:01:38,390 --> 00:01:40,070
而且非常令人不安，

29
00:01:40,600 --> 00:01:43,570
非常令人不安地对于用户内核隔离。

30
00:01:46,020 --> 00:01:50,910
这破坏了信仰或者说某种非常基本的假设，

31
00:01:50,910 --> 00:01:55,710
硬件提供的页表会让你隔离，

32
00:01:55,710 --> 00:01:57,150
这就是故事的结束，

33
00:01:57,390 --> 00:02:01,380
而这次攻击完全不支持这种观点，

34
00:02:01,830 --> 00:02:05,100
此外，它是一个例子，

35
00:02:05,100 --> 00:02:08,730
最近几个称为微架构攻击的例子之一，

36
00:02:08,760 --> 00:02:17,550
涉及利用 CPU 内部隐藏的实现细节的攻击，

37
00:02:17,580 --> 00:02:22,770
甚至不知道 CPU 是如何工作的，

38
00:02:22,860 --> 00:02:24,300
但是人们猜测，

39
00:02:24,360 --> 00:02:28,230
而且他们基于正确猜测实现攻击，

40
00:02:28,650 --> 00:02:32,460
关于 CPU 实现隐藏细节（的猜测）。

41
00:02:34,060 --> 00:02:35,530
Meltdown 是可以修复的，

42
00:02:35,620 --> 00:02:39,250
而且似乎完全修复了，

43
00:02:39,640 --> 00:02:43,450
但尽管如此，这还是让人们感到恐惧，

44
00:02:43,630 --> 00:02:49,450
可能会有穷的类似的微架构攻击。

45
00:02:49,920 --> 00:02:55,740
所以这是最近发生的一件非常重要，值得我们了解的事情。

46
00:02:56,520 --> 00:03:06,320
让我先从攻击的核心开始，

47
00:03:06,410 --> 00:03:08,450
我们会谈谈这里发生的事情，

48
00:03:08,450 --> 00:03:12,310
但这是代码的简化版本，

49
00:03:12,310 --> 00:03:14,110
论文中关于攻击如何运作的，

50
00:03:14,410 --> 00:03:16,840
基本想法是你是一个攻击者，

51
00:03:16,990 --> 00:03:22,690
出于某种原因，你可以在某些计算机上运行软件，

52
00:03:22,690 --> 00:03:24,910
有一些你想偷的秘密，

53
00:03:24,940 --> 00:03:26,950
你不能直接获得秘密，

54
00:03:26,950 --> 00:03:30,070
但它们在内存中，可能是内核内存或其他进程内存，

55
00:03:30,130 --> 00:03:32,410
但是你已经能够运行一个进程，

56
00:03:32,410 --> 00:03:36,310
可能是因为你登录了 Athena 那样的分时机，

57
00:03:36,310 --> 00:03:40,210
或者是因为你在一些托管服务上购买了时间。

58
00:03:40,900 --> 00:03:45,430
所以，攻击允许你运行一个程序，

59
00:03:45,430 --> 00:03:49,330
你在自己的内存中声明一个缓冲区，

60
00:03:49,330 --> 00:03:53,920
所以这个 buf 是一个普通的用户可以访问的内存，

61
00:03:54,670 --> 00:03:59,740
你有想窃取的东西的内核的虚拟地址。

62
00:04:02,590 --> 00:04:04,210
你说，

63
00:04:04,240 --> 00:04:05,680
我在这里写的是

64
00:04:05,680 --> 00:04:09,310
C 和汇编语言的混合体，

65
00:04:09,310 --> 00:04:11,170
但我在第 3 行的意思是，

66
00:04:11,290 --> 00:04:14,830
你有要窃取的数据的内核虚拟地址，

67
00:04:14,830 --> 00:04:17,050
你想窃取的地址在 r1 中，

68
00:04:17,260 --> 00:04:25,180
在第 3 行，这是间接引用 r1 的指令，或者仅仅假设这是取消引用寄存器1并将其结果加载到寄存器2中的指令，

69
00:04:25,180 --> 00:04:27,310
并将它的结果放入 r2 中，

70
00:04:27,760 --> 00:04:29,680
这就是我们要运行的指令，

71
00:04:30,100 --> 00:04:31,810
然后有一条指令，

72
00:04:32,590 --> 00:04:37,120
获取 r2 的低位，

73
00:04:37,120 --> 00:04:42,340
所以这个攻击，这个特定版本的攻击只读取了一个位，

74
00:04:42,340 --> 00:04:46,600
只有内核的一个内存位置的一个低位，

75
00:04:47,200 --> 00:04:49,720
用它乘以 4096 ，

76
00:04:49,720 --> 00:04:51,130
因为它要么是 0 ，要么是 1 ，

77
00:04:51,130 --> 00:04:54,580
这意味着 r2 最终是 0 或 4096 ，

78
00:04:54,580 --> 00:04:57,610
然后我们简单地读取 buf 的内容，

79
00:04:57,790 --> 00:04:59,810
这是一个用户内存缓冲，

80
00:04:59,870 --> 00:05:04,490
我们简单地读取缓冲器 0 或缓冲器 4096 ，

81
00:05:06,200 --> 00:05:07,430
这就是基本的攻击。

82
00:05:11,640 --> 00:05:12,930
所以，有一个问题是，

83
00:05:13,860 --> 00:05:15,510
为什么这不能直接起作用，

84
00:05:15,600 --> 00:05:18,660
第三行读取这个内核地址，

85
00:05:19,540 --> 00:05:21,520
我们能不能只从内核读取地址。

86
00:05:25,620 --> 00:05:29,220
不，我们都相信答案不可能是肯定的，

87
00:05:29,220 --> 00:05:32,970
我们不可能在用户空间直接从内核中读取，

88
00:05:33,150 --> 00:05:39,510
CPU 的机制，有时这个不能工作，

89
00:05:39,630 --> 00:05:43,080
当我们使用内核虚拟地址时，

90
00:05:43,110 --> 00:05:46,830
这意味着在页表中查找，

91
00:05:47,240 --> 00:05:49,010
在页表中有权限位，

92
00:05:49,100 --> 00:05:51,710
并且我们假设操作系统

93
00:05:52,130 --> 00:05:56,690
没有对内核虚拟地址的页表条目设置标志，

94
00:05:56,690 --> 00:06:01,750
没有设置允许用户使用这些地址的标志，

95
00:06:01,750 --> 00:06:04,570
那是 RISC-V 上的 PTE_U 标志，

96
00:06:04,870 --> 00:06:08,590
所以，这个指令必须失败，一定会导致页面错误。

97
00:06:09,220 --> 00:06:10,780
事实上，如果我们运行这段代码，

98
00:06:10,780 --> 00:06:12,370
这条指令会导致页面错误，

99
00:06:12,550 --> 00:06:16,870
如果我们在这之后加一个代码，

100
00:06:16,870 --> 00:06:19,460
比如打印寄存器 3 中的值，

101
00:06:20,090 --> 00:06:21,950
我们在第 3 行得到一个页面错误，

102
00:06:21,950 --> 00:06:23,480
我们永远不会得到 print 语句，

103
00:06:23,720 --> 00:06:26,870
我们发现不能直接从内核窃取数据。

104
00:06:30,920 --> 00:06:34,820
然而，正如论文所示的那样，这个序列被证明是有用的。

105
00:06:36,380 --> 00:06:42,690
这篇论文假设的一件事，

106
00:06:42,810 --> 00:06:45,660
在很大程度上不再是真的，

107
00:06:45,750 --> 00:06:51,840
内核映射到每个用户进程地址空间，

108
00:06:52,240 --> 00:07:00,250
在页表中，用户代码运行全套内核 PTE ，

109
00:07:00,280 --> 00:07:02,890
但它们把 PTE_U 清除了，

110
00:07:03,130 --> 00:07:06,370
所以，用户代码会得到错误，

111
00:07:06,370 --> 00:07:09,700
如果它试图使用内核虚拟地址，

112
00:07:09,940 --> 00:07:11,320
所以所有这些映射，

113
00:07:11,320 --> 00:07:12,820
在写这篇论文的时候，

114
00:07:13,120 --> 00:07:16,300
所有这些映射都在那里，当在用户空间执行时，

115
00:07:16,450 --> 00:07:20,070
它们只是不能被用户代码使用，

116
00:07:20,100 --> 00:07:22,560
或者被用户代码使用时导致错误，

117
00:07:22,560 --> 00:07:25,590
操作系统设计人员

118
00:07:25,800 --> 00:07:31,200
在运行用户代码时，同时映射内核和用户地址的原因是，

119
00:07:31,200 --> 00:07:33,690
这使得系统调用速度相当快，

120
00:07:33,930 --> 00:07:36,150
因为这意味着在发生系统调用时，

121
00:07:36,240 --> 00:07:38,040
你不必切换页表，

122
00:07:38,040 --> 00:07:41,310
切换页表本身就需要时间，

123
00:07:41,490 --> 00:07:44,760
并且通常还会导致 CPU 缓存刷新，

124
00:07:44,820 --> 00:07:46,650
使得后续代码变慢。

125
00:07:48,160 --> 00:07:49,420
所以，人们得到了速度提升，

126
00:07:49,420 --> 00:07:53,020
通过始终在用户空间中映射用户和内核映射。

127
00:07:55,370 --> 00:07:58,460
但这个攻击正依赖于这种习惯。

128
00:08:00,040 --> 00:08:04,390
好的，我来解释一下这里发生了什么，

129
00:08:04,390 --> 00:08:05,440
使得这段代码有用，

130
00:08:05,440 --> 00:08:06,910
但是在我开始之前，

131
00:08:06,910 --> 00:08:12,600
关于这个代码片段，有没有什么问题？

132
00:08:15,280 --> 00:08:17,200
我想知道你是否可以重复，

133
00:08:17,470 --> 00:08:20,440
你刚才所说的内核到用户的映射，

134
00:08:20,980 --> 00:08:22,330
并且不需要寄存器。

135
00:08:22,630 --> 00:08:24,370
好的，我们看一下，

136
00:08:28,560 --> 00:08:30,150
你知道在 xv6 中，

137
00:08:30,180 --> 00:08:33,480
当进程在用户空间中执行时，

138
00:08:33,540 --> 00:08:35,280
如果你查看页表，

139
00:08:35,760 --> 00:08:38,580
页表有用户地址映射，

140
00:08:38,970 --> 00:08:40,680
比如 trampoline 页面，

141
00:08:40,680 --> 00:08:43,480
trampoline 页面，没有其他的了，

142
00:08:44,160 --> 00:08:45,630
这就是 xv6 的工作。

143
00:08:46,110 --> 00:08:51,810
这篇论文假设的页表跟那个不同，

144
00:08:52,380 --> 00:08:55,020
在写这篇论文的时候，

145
00:08:55,200 --> 00:08:59,860
大多数操作系统都有，

146
00:08:59,860 --> 00:09:05,200
在页表中有一套完整的内核映射，

147
00:09:06,100 --> 00:09:08,140
当用户代码运行时，

148
00:09:09,930 --> 00:09:14,580
所以，所有那些页表条目都会在那里，

149
00:09:14,580 --> 00:09:17,910
当用户代码运行时，所有内核页表条目都会在那里，

150
00:09:17,910 --> 00:09:22,320
但是由于每一个那些页表条目中的 PTE_U 位被清除，

151
00:09:22,320 --> 00:09:25,530
用户代码不能使用内核虚拟地址，

152
00:09:25,710 --> 00:09:27,150
但是映射就在那里，

153
00:09:27,300 --> 00:09:29,760
原因是，当你进行系统调用时，

154
00:09:29,880 --> 00:09:32,760
你不必切换页表，

155
00:09:33,060 --> 00:09:35,850
因为进行系统调用进入内核，

156
00:09:35,850 --> 00:09:37,620
当你使用相同的页表时，

157
00:09:37,620 --> 00:09:41,040
现在你可以使用所有这些内核 PTE ，

158
00:09:41,040 --> 00:09:42,150
因为你处于管理者模式，

159
00:09:42,180 --> 00:09:43,860
这节省了很多时间，

160
00:09:44,070 --> 00:09:46,440
在系统调用时进出内核。

161
00:09:47,230 --> 00:09:49,360
每个人都用这个技巧，

162
00:09:49,390 --> 00:09:52,630
这几乎可以肯定是英特尔的想法，

163
00:09:52,630 --> 00:09:54,920
关于你应该如何编写操作系统。

164
00:09:55,840 --> 00:09:57,550
好的，所以在整篇论文中，

165
00:09:57,550 --> 00:10:01,300
假设攻击的结构是这样的，

166
00:10:01,480 --> 00:10:02,530
当然避免它，

167
00:10:02,530 --> 00:10:06,130
是解决这个问题最直接的办法，

168
00:10:07,150 --> 00:10:08,440
但是，在编写这篇论文时，

169
00:10:08,710 --> 00:10:11,620
所有内核映射都存在于用户空间中。

170
00:10:13,760 --> 00:10:14,630
还有其他问题吗？

171
00:10:16,860 --> 00:10:20,850
所以你需要知道你想得到的地址。

172
00:10:21,090 --> 00:10:25,980
是的，没错，就是这样。

173
00:10:28,790 --> 00:10:30,080
这是一个很好的观点，

174
00:10:30,080 --> 00:10:32,030
你需要知道内核虚拟地址，

175
00:10:32,030 --> 00:10:34,820
这可能不是开玩笑的。

176
00:10:37,560 --> 00:10:41,370
你可能认为这会让攻击变得更难。

177
00:10:44,600 --> 00:10:49,000
但是首先从安全的哲学观点来看，

178
00:10:49,000 --> 00:10:53,020
你需要假设攻击者有无限的时间和耐心。

179
00:10:53,510 --> 00:10:55,220
如果在一些有价值的秘密，

180
00:10:55,520 --> 00:10:59,990
他们可能愿意花几个月的时间试图窃取这个秘密，

181
00:11:00,590 --> 00:11:02,480
或者更长时间，

182
00:11:02,870 --> 00:11:04,640
因为这可能是某人的密码，

183
00:11:04,640 --> 00:11:06,320
它保护各种有价值的东西，

184
00:11:06,320 --> 00:11:08,990
可能是钱或秘密电子邮件。

185
00:11:09,640 --> 00:11:12,970
所以，这意味着攻击者可能有时间

186
00:11:12,970 --> 00:11:16,820
尝试每一个内核地址，

187
00:11:16,850 --> 00:11:19,550
在那里寻找任何珍贵的数据，

188
00:11:19,640 --> 00:11:20,660
可能是密码，

189
00:11:20,870 --> 00:11:24,950
或者攻击者可能有时间学习查看内核代码，

190
00:11:24,950 --> 00:11:28,640
查看典型的编译内核并查找地址，

191
00:11:28,640 --> 00:11:30,920
可以在他们的内核中放打印语句，

192
00:11:30,920 --> 00:11:33,770
检查内核内存中的数据结构，

193
00:11:33,770 --> 00:11:35,870
直到他们了解内核是如何工作的，

194
00:11:36,530 --> 00:11:39,950
才能在这里找到这里的地址。

195
00:11:40,100 --> 00:11:43,900
因为这个游戏一直在进行，

196
00:11:43,930 --> 00:11:45,610
这个游戏的其他版本，

197
00:11:46,000 --> 00:11:48,070
安全游戏已经进行了很长一段时间了，

198
00:11:48,130 --> 00:11:53,010
内核会防御这些攻击，

199
00:11:53,010 --> 00:11:55,800
涉及猜测内核地址的攻击，

200
00:11:55,920 --> 00:11:59,490
这篇论文实际上提到的一件事是，

201
00:11:59,490 --> 00:12:06,360
这称为内核地址空间布局随机化，

202
00:12:06,360 --> 00:12:09,720
所以现代内核加载内核到随机地址，

203
00:12:10,140 --> 00:12:15,970
为了使猜测内核虚拟地址变得更加困难，

204
00:12:15,970 --> 00:12:19,150
早在这篇论文发表之前，他们就这样做了，

205
00:12:19,420 --> 00:12:22,180
因为它有助于防止其他攻击。

206
00:12:22,700 --> 00:12:24,890
所以，这就是游戏，

207
00:12:24,890 --> 00:12:29,810
但是我们必须假设攻击者，

208
00:12:29,840 --> 00:12:33,260
最终，攻击者可能会赢得这个游戏。

209
00:12:34,640 --> 00:12:40,340
好吧，我们假设攻击者知道一个内核虚拟地址，

210
00:12:40,340 --> 00:12:43,850
或者猜到一个，或者愿意穷尽每一个地址。

211
00:12:44,280 --> 00:12:47,970
这篇论文认为这是一个看似合理的策略，

212
00:12:48,240 --> 00:12:49,290
一旦有了 meltdown 。

213
00:12:51,810 --> 00:12:52,470
好的。

214
00:12:53,930 --> 00:12:55,340
好的，接下来会发生什么，

215
00:12:55,460 --> 00:12:58,540
所以我们想知道这段代码怎么会，

216
00:12:58,720 --> 00:13:01,300
可能被攻击者利用，

217
00:13:01,360 --> 00:13:03,340
答案是，

218
00:13:03,430 --> 00:13:08,740
如果 CPU 的工作方式和你在 CPU 手册上看到的一样，

219
00:13:08,830 --> 00:13:10,780
这个攻击当然是没有意义的，

220
00:13:10,810 --> 00:13:13,390
比如它会在指令 3 失败，

221
00:13:13,420 --> 00:13:14,440
并且结束，

222
00:13:14,590 --> 00:13:20,340
但事实证明， CPU 的工作方式比手册中的复杂得多，

223
00:13:20,490 --> 00:13:24,960
这个攻击方式成功的原因是，

224
00:13:24,960 --> 00:13:28,800
因为一些 CPU 的实现细节。

225
00:13:30,350 --> 00:13:33,410
实际上，攻击依赖于两个主要的东西，

226
00:13:33,410 --> 00:13:37,910
一种是 CPU 称为预测执行的实现技巧，

227
00:13:38,180 --> 00:13:39,440
我将首先谈到这一点，

228
00:13:39,620 --> 00:13:45,620
另一个攻击所依赖的实现技巧是 CPU 进行缓存的方式。

229
00:13:48,330 --> 00:13:49,050
好的。

230
00:13:49,620 --> 00:13:51,300
所以首先是预测执行，

231
00:13:52,920 --> 00:13:56,700
我也有一个代码示例，

232
00:13:57,120 --> 00:14:00,390
现在我说的不是安全问题，

233
00:14:01,220 --> 00:14:07,520
预测执行只是一种提高 CPU 性能的技术，

234
00:14:08,300 --> 00:14:10,670
一种 CPU 使用的优化技巧，

235
00:14:11,210 --> 00:14:17,050
想象一下，我们正在运行这段代码，

236
00:14:17,320 --> 00:14:19,360
这是一个有点人为的例子，

237
00:14:19,360 --> 00:14:23,920
但在某种程度上说明了预测执行的意义，

238
00:14:25,120 --> 00:14:29,200
假设我在寄存器 0 中有个地址，

239
00:14:29,320 --> 00:14:31,510
因为我程序的逻辑，

240
00:14:31,510 --> 00:14:33,640
地址要么有效要么无效，

241
00:14:33,640 --> 00:14:36,430
在某些情况下，它可能包含 0 ，

242
00:14:36,430 --> 00:14:39,920
比如我们还没有初始化我的数据。

243
00:14:39,950 --> 00:14:44,180
所以这假设在内存中的某个地方有一个 valid 变量，

244
00:14:44,660 --> 00:14:47,630
所以在使用这个地址之前，

245
00:14:48,230 --> 00:14:50,780
在第 4 行中的寄存器 0 中的地址，

246
00:14:50,780 --> 00:14:51,590
我们要测试，

247
00:14:51,620 --> 00:14:53,090
我们要从内存中加载 valid ，

248
00:14:53,090 --> 00:14:57,080
如果 valid 为 1 ，我们将使用这个地址，

249
00:14:57,500 --> 00:15:00,410
如果 valid 为 0 ，我们将看不到地址，

250
00:15:00,620 --> 00:15:03,830
如果 valid 为 1 ，那么我们将间接引用这个地址，

251
00:15:03,890 --> 00:15:06,380
把它指向的数据加载到寄存器 2 ，

252
00:15:06,530 --> 00:15:08,570
然后加一，这没什么关系，

253
00:15:08,600 --> 00:15:10,460
我们要用加载的数据做点什么，

254
00:15:10,610 --> 00:15:12,020
在这种情况下，对它加 1 ，

255
00:15:12,020 --> 00:15:16,800
并将寄存器 3 设置为那个数据加 1 。

256
00:15:17,800 --> 00:15:23,010
好的，在一个简单的 CPU 实现中，

257
00:15:24,370 --> 00:15:27,780
在第 2 行中，你可以加载，

258
00:15:28,380 --> 00:15:30,990
valid 是一个位于内存中的变量，

259
00:15:32,070 --> 00:15:34,140
你必须发布一些，

260
00:15:34,140 --> 00:15:34,740
这个会，

261
00:15:34,740 --> 00:15:38,550
第 2 行会使用 load 指令从内存中读取 valid ，

262
00:15:39,330 --> 00:15:41,790
或者相等，如果我们必须从内存中加载它，

263
00:15:42,500 --> 00:15:47,660
那需要数百次循环，在我们的 2GHz 机器上，

264
00:15:48,370 --> 00:15:52,240
任何从内存加载需要数百次循环，

265
00:15:52,300 --> 00:15:54,850
机器可以执行一条指令，

266
00:15:55,420 --> 00:15:57,250
每个周期最多执行一条指令，

267
00:15:57,250 --> 00:16:01,240
所以如果我们要在这里等待几百个周期，

268
00:16:01,480 --> 00:16:05,800
机器会在这里闲置数百个周期，

269
00:16:05,800 --> 00:16:06,820
浪费时间。

270
00:16:07,440 --> 00:16:11,880
因为这是一个显著的减速，

271
00:16:12,060 --> 00:16:13,080
如果一切顺利，

272
00:16:13,080 --> 00:16:15,750
我们能够在每个周期执行一条指令，

273
00:16:15,750 --> 00:16:17,430
而不是每几百个周期执行一次。

274
00:16:20,000 --> 00:16:24,530
所有现代的 CPU 都使用一种叫做分支预测的东西，

275
00:16:24,620 --> 00:16:26,780
这个 if 语句是一个分支，

276
00:16:27,530 --> 00:16:29,690
如果我们把它变成机器指令，

277
00:16:29,690 --> 00:16:31,100
我们看到这里是一个分支，

278
00:16:31,280 --> 00:16:32,690
这是一个条件分支，

279
00:16:32,690 --> 00:16:36,920
分支基于这个寄存器 1 是否等于 1 的测试，

280
00:16:37,220 --> 00:16:38,720
而 CPU 所做的是，

281
00:16:38,720 --> 00:16:41,240
它们使用叫做分支预测的东西，

282
00:16:41,660 --> 00:16:43,280
也就是说，对于每个分支，

283
00:16:43,310 --> 00:16:48,500
CPU 都会记住信息的缓存，

284
00:16:48,500 --> 00:16:51,290
关于程序中的每个分支，

285
00:16:51,350 --> 00:16:53,600
或者至少每个最近执行的分支，

286
00:16:53,810 --> 00:16:57,380
然后记起，那个分支是[拿了]还是没拿，

287
00:16:58,010 --> 00:17:03,660
如果 CPU 没有足够的信息来预测，

288
00:17:03,720 --> 00:17:06,390
这基于你上次执行分支的预测，

289
00:17:06,600 --> 00:17:09,270
即使 CPU 没有预测，

290
00:17:09,390 --> 00:17:13,640
它仍然可以继续执行指令，

291
00:17:14,630 --> 00:17:16,280
无论是你去的分支，

292
00:17:16,280 --> 00:17:19,520
或没有去的指令，假设分支没有选择，

293
00:17:19,580 --> 00:17:25,530
甚至在 CPU 知道条件是否为真之前，

294
00:17:25,890 --> 00:17:30,300
它会选择一种或另一种方式，并开始沿着这条路径执行，

295
00:17:30,480 --> 00:17:33,680
尽管这可能是条错误的路径，还不知道。

296
00:17:34,320 --> 00:17:35,400
所以在这种情况下，

297
00:17:35,580 --> 00:17:37,380
也许在这个加载完成之前，

298
00:17:37,380 --> 00:17:39,780
在知道 valid 的值之前，

299
00:17:40,020 --> 00:17:43,800
CPU 已经开始执行指令 4 ，

300
00:17:44,250 --> 00:17:47,790
并加载 r0 中的值，

301
00:17:47,880 --> 00:17:49,680
它可能是也可能不是有效的指针，

302
00:17:50,100 --> 00:17:52,500
一旦加载产生了一些结果，

303
00:17:52,650 --> 00:17:54,180
甚至可以加 1 ，

304
00:17:54,180 --> 00:17:56,220
并将寄存器 3 设置为那个值。

305
00:17:56,840 --> 00:17:59,030
也许在很久之后，

306
00:17:59,030 --> 00:18:02,360
当第 2 行的加载最终完成时，

307
00:18:02,750 --> 00:18:06,320
现在我们知道 valid 的值是什么，

308
00:18:06,590 --> 00:18:08,990
CPU 会，这个真的，

309
00:18:09,020 --> 00:18:11,180
它跟踪了这样一个事实，

310
00:18:11,180 --> 00:18:13,940
它执行第 4 行和第 5 行，

311
00:18:13,940 --> 00:18:16,310
但并不知道这样做是否合适，

312
00:18:17,060 --> 00:18:20,270
如果 valid 是 1 ，那没问题，继续运行，

313
00:18:20,300 --> 00:18:23,810
如果 valid 为 0 ， CPU 足够聪明

314
00:18:23,810 --> 00:18:28,700
来取消它执行第 4 行和第 5 行的结果，

315
00:18:28,760 --> 00:18:33,140
并在第 7 行的分支之后的适当位置重新开始执行。

316
00:18:34,260 --> 00:18:36,690
这种在你知道之前执行代码，

317
00:18:36,690 --> 00:18:40,440
你是否应该执行代码之前，被称为推测，

318
00:18:46,700 --> 00:18:48,920
再说一次，重点是性能，

319
00:18:48,920 --> 00:18:50,510
如果 CPU 猜测是正确的，

320
00:18:51,180 --> 00:18:54,540
那么它在开始执行这些指令时就有了很大的优势，

321
00:18:54,540 --> 00:18:57,960
而不必等待昂贵的内存加载。

322
00:19:00,660 --> 00:19:02,220
对于这意味着什么，有什么问题吗？

323
00:19:08,940 --> 00:19:19,250
好的，这个机器，硬件， CPU 里的晶体管都是非常复杂的，

324
00:19:19,610 --> 00:19:22,970
在 CPU 中有大量的工作来完成这项工作，

325
00:19:23,440 --> 00:19:25,900
没有一个是公开的，

326
00:19:25,900 --> 00:19:29,510
整个都是英特尔内部的东西，

327
00:19:29,570 --> 00:19:31,970
不在机器手册里。

328
00:19:32,550 --> 00:19:36,720
所以围绕 meltdown 和攻击，

329
00:19:36,720 --> 00:19:38,520
是一个很大的猜测，

330
00:19:38,520 --> 00:19:41,400
关于 CPU 内部可能发生的事，

331
00:19:41,400 --> 00:19:44,220
使这种攻击工作或不工作。

332
00:19:45,090 --> 00:19:48,460
好了，还是回到预测。

333
00:19:55,210 --> 00:19:57,160
有一件事是，

334
00:19:57,400 --> 00:20:05,460
为了取消推测预测失败的执行，

335
00:20:05,670 --> 00:20:09,900
机器保留了寄存器的影子版本，

336
00:20:10,200 --> 00:20:12,690
它被分配给寄存器 2 ，寄存器 3 ，

337
00:20:12,690 --> 00:20:15,900
它分配一个临时的寄存器，

338
00:20:16,560 --> 00:20:19,350
如果预测成功，

339
00:20:19,530 --> 00:20:23,010
那些影子寄存器会变为真实寄存器，

340
00:20:23,040 --> 00:20:24,060
如果失败，

341
00:20:24,120 --> 00:20:28,380
CPU 会丢弃那些影子寄存器。

342
00:20:28,710 --> 00:20:32,660
所以这两个任务 r2 和 r3 就像从来没有发生过。

343
00:20:37,310 --> 00:20:39,860
所以，在这段代码中，

344
00:20:39,860 --> 00:20:45,920
我们需要考虑如果寄存器 0 是有效指针会发生什么，

345
00:20:45,920 --> 00:20:49,270
还有如果它不是一个有效的指针呢？

346
00:20:49,300 --> 00:20:52,690
如果我们预测执行第 4 行，

347
00:20:53,140 --> 00:20:56,560
并且寄存器 2 是有效指针，

348
00:20:56,560 --> 00:21:00,010
然后 CPU 会执行加载，

349
00:21:00,700 --> 00:21:04,900
至少加载到寄存器 2 的临时版本中，

350
00:21:04,900 --> 00:21:05,980
所以我们会出去，

351
00:21:05,980 --> 00:21:10,650
尝试获取 r0 所指向的内容，

352
00:21:10,650 --> 00:21:12,660
那么这肯定会工作，

353
00:21:12,660 --> 00:21:17,040
如果 r0 指向的数据在缓存中，

354
00:21:17,130 --> 00:21:22,050
我不知道 CPU 是否会加载，

355
00:21:22,080 --> 00:21:23,370
如果它在缓存中未命中，

356
00:21:23,370 --> 00:21:25,230
它可能必须从内存中加载。

357
00:21:27,880 --> 00:21:29,680
但是，也许对我们来说更有趣的问题是，

358
00:21:29,680 --> 00:21:32,920
对于这个攻击，如果寄存器 0 不是有效的指针，

359
00:21:36,140 --> 00:21:40,010
在这种情况下，如果我们在这里预测执行，

360
00:21:40,980 --> 00:21:45,210
机器在这里不会出错，

361
00:21:45,210 --> 00:21:46,710
因为我们预测执行，

362
00:21:46,710 --> 00:21:50,430
机器不知道，它可以知道 r0 是无效的，

363
00:21:50,880 --> 00:21:56,490
这个预测执行指令试图使用无效指针，无效地址，

364
00:21:56,490 --> 00:21:58,020
但它不会产生页面错误，

365
00:21:58,110 --> 00:22:01,050
因为它不能这个执行

366
00:22:01,080 --> 00:22:07,230
valid 是正确预测执行还是错误预测，

367
00:22:07,230 --> 00:22:08,820
所以它只是，

368
00:22:09,120 --> 00:22:13,720
所以，它不会在第 4 行产生错误，

369
00:22:13,720 --> 00:22:17,680
直到 valid 的值是知道的，

370
00:22:17,680 --> 00:22:23,770
在这个预测分支之后，

371
00:22:23,800 --> 00:22:28,120
在机器知道情况之后，

372
00:22:28,510 --> 00:22:34,900
如果机器看到第 4 寄存器 0 是有效地址，

373
00:22:35,580 --> 00:22:38,100
然后 valid 是 1 ，

374
00:22:38,370 --> 00:22:42,300
然后，只有这样，机器才会真正产生页面错误，

375
00:22:42,570 --> 00:22:46,740
如果 r0 是无效地址，则有效地址是 0 ，

376
00:22:46,770 --> 00:22:50,030
机器不会产生页面错误。

377
00:22:50,960 --> 00:22:53,480
所以，关于是否出错的决定

378
00:22:53,540 --> 00:22:57,020
可能会推迟数百个周期，

379
00:22:57,110 --> 00:22:59,150
直到 valid 的值是知道的，

380
00:22:59,420 --> 00:23:02,390
这里的专业术语，

381
00:23:02,390 --> 00:23:08,570
指令是否被正确预测执行，

382
00:23:08,870 --> 00:23:13,040
而不是被丢弃，叫做 retirement 。

383
00:23:15,600 --> 00:23:19,430
所以我们说一条指令是预测的，

384
00:23:19,430 --> 00:23:21,020
在某个时刻退出了，

385
00:23:21,020 --> 00:23:24,490
那么我们知道它要么会被扔掉，

386
00:23:24,490 --> 00:23:29,530
要么是真实的，并应该提交到机器的可见状态，

387
00:23:29,800 --> 00:23:31,090
这个规则是，

388
00:23:33,220 --> 00:23:35,560
指令能退出，

389
00:23:35,710 --> 00:23:40,990
如果首先完成了内存加载的执行，比如加 1 操作，

390
00:23:40,990 --> 00:23:43,570
以及它之前的每条指令，

391
00:23:43,570 --> 00:23:45,670
在它还没有退出之前就执行了，

392
00:23:46,090 --> 00:23:48,730
所以，第 4 行不能退出，

393
00:23:48,730 --> 00:23:54,890
直到 valid 的加载完成，状态是可评估的，

394
00:23:54,890 --> 00:23:56,000
只有这样才能退出，

395
00:23:56,270 --> 00:23:58,130
所以它可能会出错，

396
00:23:58,280 --> 00:24:03,260
可能在内存加载后数百条指令之后，

397
00:24:05,370 --> 00:24:06,990
或者想要加载内存。

398
00:24:11,630 --> 00:24:14,240
作为这个攻击的关键细节，

399
00:24:16,690 --> 00:24:19,060
还有更多的。

400
00:24:19,870 --> 00:24:22,030
如果让它，

401
00:24:23,210 --> 00:24:25,220
如果 r0 中的地址是无效的，

402
00:24:25,220 --> 00:24:27,350
并且在页表中根本没有映射，

403
00:24:27,530 --> 00:24:30,230
然后不知道会发生什么。

404
00:24:32,850 --> 00:24:37,380
如果 r0 中的地址具有页表映射，

405
00:24:37,410 --> 00:24:39,210
但是没有权限，

406
00:24:39,240 --> 00:24:41,940
也就是 PTE_U 标志没有设置，

407
00:24:42,120 --> 00:24:45,360
那么英特尔机器做的是，

408
00:24:45,390 --> 00:24:50,640
加载数据并将其分配到临时寄存器 2 中，

409
00:24:51,840 --> 00:24:57,180
它可以被第 5 行的预测执行使用，

410
00:24:57,330 --> 00:25:01,320
所以即使 r0 是一个我们没有权限的地址，

411
00:25:01,320 --> 00:25:02,610
因为它是内核地址，

412
00:25:02,820 --> 00:25:06,930
我们仍然会看到它的值加载到 r3 中，它的值加 1 ，

413
00:25:06,990 --> 00:25:10,320
抱歉，我们看不到它，但它会加载到 r2 中，

414
00:25:10,680 --> 00:25:12,630
再加上 1 到 r3 ，

415
00:25:12,780 --> 00:25:16,050
然后当这个加载退出后，

416
00:25:16,290 --> 00:25:20,340
机器会意识到那是一个无效的加载，

417
00:25:20,370 --> 00:25:22,620
因为页表条目不允许它，

418
00:25:23,040 --> 00:25:24,690
所以我们会生成一个错误，

419
00:25:24,690 --> 00:25:28,650
并取消后续指令的执行，

420
00:25:28,650 --> 00:25:31,830
并取消这个指令的结果，

421
00:25:31,890 --> 00:25:35,170
回退对 r2 和 r3 的修改。

422
00:25:35,380 --> 00:25:41,460
所以在这个例子中，有两种预测在进行，

423
00:25:41,490 --> 00:25:44,640
一个是我们在预测这个分支，

424
00:25:44,640 --> 00:25:46,950
机器预测这个分支的去向，

425
00:25:47,400 --> 00:25:49,560
只是说，不管它去哪条路，

426
00:25:49,560 --> 00:25:51,390
我只是想试试看，

427
00:25:51,990 --> 00:25:55,380
另外，每次加载后都会有预测执行，

428
00:25:55,380 --> 00:25:57,000
我们预测，

429
00:25:57,000 --> 00:26:03,560
机器预测那个加载是否成功，关于加载是否成功完成。

430
00:26:03,920 --> 00:26:07,910
在加载的情况下，英特尔机器总是继续运行，

431
00:26:08,150 --> 00:26:10,010
如果可以提供数据，

432
00:26:11,110 --> 00:26:12,130
因为它在缓存中，

433
00:26:12,130 --> 00:26:14,920
或者至少页表条目存在，权限不存在，

434
00:26:15,220 --> 00:26:18,160
机器将预测继续执行，

435
00:26:18,520 --> 00:26:20,650
只有在退出时，

436
00:26:20,650 --> 00:26:23,950
加载才会产生故障，

437
00:26:24,040 --> 00:26:26,140
这将导致预测被取消。

438
00:26:28,660 --> 00:26:32,290
好的，关于这个东西，有什么问题吗？

439
00:26:39,870 --> 00:26:43,230
我有点困惑第二种猜测，

440
00:26:43,230 --> 00:26:45,630
它将 r0 加载到 r2 中，

441
00:26:46,290 --> 00:26:52,140
那么，这是否意味着将 r0 的值加载到 r2 中，

442
00:26:52,140 --> 00:26:53,610
并在稍后检查标志？

443
00:26:56,900 --> 00:27:01,180
是的，发生了什么，是的，完全正确，

444
00:27:01,270 --> 00:27:03,100
所以实际发生的情况是，

445
00:27:03,100 --> 00:27:04,630
在预测阶段，

446
00:27:07,190 --> 00:27:08,930
不管 r0 指向的是什么，

447
00:27:09,080 --> 00:27:12,590
如果它指向什么东西，

448
00:27:12,620 --> 00:27:14,060
如果 r0 指向任何东西，

449
00:27:14,120 --> 00:27:18,770
那么内存位置的数据将被加载到 r2 中，

450
00:27:19,740 --> 00:27:22,590
稍后，当这个加载退出时，

451
00:27:24,280 --> 00:27:27,280
然后会检查权限，

452
00:27:28,560 --> 00:27:30,930
如果我们没有加载的权限，

453
00:27:31,610 --> 00:27:35,510
那么所有后续指令结果会被取消，

454
00:27:35,510 --> 00:27:38,270
所有这些寄存器的修改都会被撤销，

455
00:27:39,180 --> 00:27:41,880
错误会出现，

456
00:27:42,180 --> 00:27:47,130
就像指令 4 之前的机器核寄存器一样。

457
00:27:47,250 --> 00:27:49,080
好的，这很有趣。

458
00:27:49,780 --> 00:27:50,350
是的。

459
00:27:52,700 --> 00:27:54,110
是的，我还有一个问题，

460
00:27:54,350 --> 00:27:58,610
是否有限制 CPU 的方法，

461
00:27:58,640 --> 00:28:02,330
在预测加载之前限制 CPU 检查权限。

462
00:28:06,380 --> 00:28:12,140
你的意思是，有没有办法让机器在加载之前做检查？

463
00:28:13,370 --> 00:28:14,900
是的，我想更具体一点，

464
00:28:14,900 --> 00:28:17,360
这是这个问题的唯一原因，

465
00:28:17,360 --> 00:28:22,340
但是其中一种方法是我们只加载一个页面，

466
00:28:23,170 --> 00:28:29,020
如果我们意识到它的权限会变坏，

467
00:28:29,110 --> 00:28:32,980
我们访问一个我们不应该能够访问的页面，

468
00:28:33,310 --> 00:28:36,820
预测执行能否取消，

469
00:28:36,820 --> 00:28:38,710
假设我们可以读取这些权限。

470
00:28:40,500 --> 00:28:42,810
是的，就是，

471
00:28:42,810 --> 00:28:46,110
好的，有两个答案，

472
00:28:46,110 --> 00:28:49,680
一个是，这不是英特尔 CPU 的实际工作方式，

473
00:28:50,700 --> 00:28:53,400
另一个答案是是的，

474
00:28:54,300 --> 00:28:56,610
我相信，那会更简单，

475
00:28:56,610 --> 00:29:00,690
对预测加载做强制检查，

476
00:29:00,690 --> 00:29:04,530
即使在预测寄存器 2 中，也永远不会被写入。

477
00:29:05,980 --> 00:29:07,540
所以，也许。

478
00:29:08,920 --> 00:29:11,080
事实上，

479
00:29:11,080 --> 00:29:12,940
我注意到论文中提到，

480
00:29:12,940 --> 00:29:17,290
meltdown 似乎不适用于 AMD CPU ，

481
00:29:17,440 --> 00:29:24,030
即使 AMD CPU 的使用手册与 Intel CPU 相同，

482
00:29:24,030 --> 00:29:27,780
是相同的指令集，也就是相同的东西，

483
00:29:27,840 --> 00:29:30,810
这个攻击在 AMD CPU 上不起作用，

484
00:29:31,140 --> 00:29:35,190
人们普遍认为原因是 AMD CPU ，

485
00:29:36,080 --> 00:29:38,240
即使是预测执行时，

486
00:29:39,520 --> 00:29:43,900
如果你没有权限读取这个地址，

487
00:29:43,930 --> 00:29:48,160
甚至不会预测加载值到 r2 中，

488
00:29:49,470 --> 00:29:52,200
这就是为什么攻击在 AMD CPU 上不起作用的原因，

489
00:29:52,410 --> 00:29:57,840
最近的英特尔 CPU 显然已经采用了这种方法，

490
00:29:57,840 --> 00:30:05,330
不会预测加载，如果它们没有权限。

491
00:30:06,500 --> 00:30:07,220
据我所知，

492
00:30:07,220 --> 00:30:11,290
这里没有明显的性能损失，

493
00:30:11,320 --> 00:30:12,910
我想信息都在那里了，

494
00:30:13,540 --> 00:30:18,550
但我不知道，可能只是几个[]，

495
00:30:18,550 --> 00:30:21,040
他们决定只在退出时使用。

496
00:30:23,620 --> 00:30:24,400
因为他们似乎就是这样。

497
00:30:24,400 --> 00:30:25,510
那非常有趣。

498
00:30:28,400 --> 00:30:31,940
是的，我的意思是，我提醒你这里有很多猜测，

499
00:30:33,050 --> 00:30:35,360
我相信我说的是真的，

500
00:30:35,360 --> 00:30:40,940
但是英特尔和 AMD 并没有披露发生的事情。

501
00:30:43,190 --> 00:30:49,130
好的，这里有一些很重要的术语，

502
00:30:49,250 --> 00:30:53,090
当你在 CPU 手册中读到，

503
00:30:53,090 --> 00:30:55,430
它说，加法指令使用两个寄存器，

504
00:30:55,430 --> 00:30:56,900
对它们相加，然后放到第三个寄存器中，

505
00:30:56,930 --> 00:31:01,680
这种设计方面的东西叫做架构，

506
00:31:03,130 --> 00:31:08,830
一种[]行为，

507
00:31:10,350 --> 00:31:12,300
机器的[]行为，

508
00:31:12,690 --> 00:31:14,940
所以，机器的[]行为是，

509
00:31:14,940 --> 00:31:17,670
如果你从某个地址加载时，产生页面错误，

510
00:31:17,670 --> 00:31:18,750
则不允许加载，

511
00:31:19,710 --> 00:31:23,340
这与机器实际所做的不同，

512
00:31:23,340 --> 00:31:27,270
就是所谓的微体系结构。

513
00:31:29,540 --> 00:31:32,330
这是机器有预测执行，

514
00:31:32,330 --> 00:31:34,670
做这些疯狂的事情，没有告诉你的，

515
00:31:34,820 --> 00:31:38,420
CPU 设计者的目的，

516
00:31:38,420 --> 00:31:42,140
在设计所有这些复杂的微体系架构优化时，

517
00:31:42,140 --> 00:31:43,490
它们是透明的，

518
00:31:43,760 --> 00:31:45,710
是的，它在内部做所有这些事情，

519
00:31:45,710 --> 00:31:48,950
但是看起来你从程序中得到的结果

520
00:31:48,980 --> 00:31:51,710
和一台更简单的机器上得到的结果是一样的，

521
00:31:51,710 --> 00:31:54,710
做了手册中简单的事情。

522
00:31:55,500 --> 00:31:57,210
它们应该是透明的。

523
00:31:57,240 --> 00:32:00,730
所以，比如，在某种程度上，

524
00:32:00,730 --> 00:32:03,370
Intel 在这里做的事情是透明的，

525
00:32:03,370 --> 00:32:06,970
是的，也许在你加载内存的时候，他们没有检查权限，

526
00:32:07,180 --> 00:32:09,940
但是如果退出有问题的话，

527
00:32:09,940 --> 00:32:11,560
它会取消所有这些影响，

528
00:32:11,560 --> 00:32:13,360
所以你永远不会看到那些内存，

529
00:32:13,360 --> 00:32:14,410
你不应该看到，

530
00:32:14,410 --> 00:32:17,890
所以，看起来和手册上说的一样，

531
00:32:17,980 --> 00:32:20,110
你不允许加载没有权限的东西。

532
00:32:22,040 --> 00:32:23,690
所以这个区别是，

533
00:32:26,050 --> 00:32:27,730
这个攻击的很多内容，

534
00:32:27,730 --> 00:32:30,190
在这里，它知道所有攻击的东西，

535
00:32:30,190 --> 00:32:32,380
知道很多内部发生了什么。

536
00:32:35,840 --> 00:32:40,240
好的，关于预测执行，还有其他问题吗？

537
00:32:47,840 --> 00:32:50,590
好的，我暂时把它放在一边，

538
00:32:50,590 --> 00:32:53,440
讨论一下微架构的另一部分，

539
00:32:59,240 --> 00:33:03,410
那就是缓存。

540
00:33:06,420 --> 00:33:08,730
每个人都知道有缓存，

541
00:33:08,730 --> 00:33:12,090
但是它们或多或少是透明的。

542
00:33:16,130 --> 00:33:17,720
让我画一张缓存的图，

543
00:33:17,720 --> 00:33:19,490
我认为这与缓存结构有关，

544
00:33:19,490 --> 00:33:21,590
我认为这与 meltdown 相关。

545
00:33:21,650 --> 00:33:23,360
所以首先你有，

546
00:33:24,500 --> 00:33:28,800
我们有核心，是机器的一部分，

547
00:33:28,800 --> 00:33:31,650
它解析指令并具有寄存器，

548
00:33:31,650 --> 00:33:34,470
并且有加法单元和除法单元，

549
00:33:34,470 --> 00:33:39,300
不管机器的什么执行部分，

550
00:33:39,300 --> 00:33:44,130
然后，当它需要进行加载或保存时，

551
00:33:45,710 --> 00:33:50,270
它与内存系统交互，

552
00:33:51,380 --> 00:33:53,360
内存系统具有高速缓存，

553
00:33:53,360 --> 00:33:55,700
在我们所说的机器中，

554
00:33:55,700 --> 00:34:03,140
有一种缓存叫做 L1 缓存，

555
00:34:03,620 --> 00:34:10,590
可能是 64 千字节的大小或不是很大，

556
00:34:10,590 --> 00:34:11,940
但它的速度非常快，

557
00:34:12,150 --> 00:34:15,630
如果你需要的数据在 L1 缓存中，

558
00:34:15,630 --> 00:34:18,360
你会在几个周期内得到回复，

559
00:34:18,390 --> 00:34:19,890
而 L1 缓存的结构，

560
00:34:19,890 --> 00:34:22,200
它有一些行，

561
00:34:22,920 --> 00:34:25,770
每个可能保存 64 字节的数据，

562
00:34:25,860 --> 00:34:29,520
这些行是缓存表的索引，

563
00:34:29,670 --> 00:34:32,910
这些行通过虚拟地址进行索引，

564
00:34:33,600 --> 00:34:36,150
如果虚拟地址在缓存中，

565
00:34:36,150 --> 00:34:41,220
然后，缓存保存具有该虚拟地址的数据，

566
00:34:41,370 --> 00:34:46,410
事实证明，

567
00:34:47,520 --> 00:34:50,910
L1 缓存条目包含权限的复制，

568
00:34:50,910 --> 00:34:54,870
从对应于这个虚拟地址的页表条目获得的（权限）。

569
00:34:55,460 --> 00:35:00,210
所以，这里有一张表，

570
00:35:01,270 --> 00:35:03,100
当内核使用加载指令时，

571
00:35:03,460 --> 00:35:05,290
发生的第一件事是，

572
00:35:05,290 --> 00:35:07,330
硬件在 L1 缓存中查找，

573
00:35:07,330 --> 00:35:09,670
查看是否存在一个缓存条目，

574
00:35:09,670 --> 00:35:14,350
它的虚拟地址与所请求的匹配，

575
00:35:15,610 --> 00:35:16,870
我们想要加载的地址，

576
00:35:16,870 --> 00:35:20,680
如果这样，我们可以让机器从缓存中返回这些数据，

577
00:35:20,980 --> 00:35:22,030
完成地非常快，

578
00:35:22,300 --> 00:35:24,190
如果它们不在 L1 缓存中，

579
00:35:24,190 --> 00:35:27,140
那么下一步是，

580
00:35:27,170 --> 00:35:31,910
内存系统的其他部分是用物理地址寻址，

581
00:35:31,910 --> 00:35:33,980
所以在这里，我们需要一个物理地址，

582
00:35:33,980 --> 00:35:36,020
如果我们没有在 L1 缓存中命中，

583
00:35:36,350 --> 00:35:41,090
这个转换后备缓冲器是页表项的缓存，

584
00:35:41,240 --> 00:35:43,100
它将查找虚拟地址，

585
00:35:43,100 --> 00:35:46,750
程序在转换后备缓冲器中发出的虚拟地址，

586
00:35:47,470 --> 00:35:48,160
它可能不在那里，

587
00:35:48,160 --> 00:35:49,810
在这种情况下，我们现在有很多工作要做，

588
00:35:49,810 --> 00:35:53,740
因为我们必须为内存加载相关的页表条目。

589
00:35:54,290 --> 00:35:56,780
但是我们假设我们命中了转换后备缓冲器，

590
00:35:56,900 --> 00:36:00,710
我们现在可以获得所需的物理地址，

591
00:36:00,890 --> 00:36:04,130
通常会有另一个更大的缓存，

592
00:36:04,830 --> 00:36:09,000
这是物理地址的索引。

593
00:36:10,880 --> 00:36:12,740
现在我们有了物理地址，

594
00:36:12,740 --> 00:36:14,000
我们可以查看这个缓存，

595
00:36:14,690 --> 00:36:16,610
如果我们在这里没有命中，

596
00:36:16,610 --> 00:36:19,910
那么我们发送物理地址到内存系统，

597
00:36:20,150 --> 00:36:20,900
需要很长时间，

598
00:36:20,900 --> 00:36:22,100
但是当我们最终拿回数据时，

599
00:36:22,100 --> 00:36:24,020
我们可以填充 L2 缓存，

600
00:36:24,650 --> 00:36:28,220
并用我们从内存中取回的内容填充 L1 缓存，

601
00:36:28,400 --> 00:36:31,870
并将数据返回给内核。

602
00:36:36,730 --> 00:36:37,690
这就是缓存。

603
00:36:43,060 --> 00:36:49,140
只是，通过命中 L1 缓存需要几个周期，

604
00:36:49,140 --> 00:36:52,470
命中 L2 缓存可能需要十几个周期，

605
00:36:52,620 --> 00:36:56,070
而错过那些，可能需要几百个循环，

606
00:36:56,800 --> 00:36:59,400
这些周期，

607
00:36:59,910 --> 00:37:03,540
比如，在 2GHz 的机器上是半纳秒。

608
00:37:05,130 --> 00:37:08,100
所以，有高速缓存是非常有利的，

609
00:37:08,100 --> 00:37:09,000
如果没有缓存，

610
00:37:09,000 --> 00:37:12,630
你将损失几百倍的性能，

611
00:37:12,750 --> 00:37:16,950
这些缓存对于良好的性能是非常关键的。

612
00:37:20,000 --> 00:37:26,590
现在，这个缓存是 L1 缓存，

613
00:37:27,140 --> 00:37:30,740
两个缓存都可以包含，

614
00:37:31,010 --> 00:37:32,360
如果我们在用户空间运行，

615
00:37:32,360 --> 00:37:36,110
这两个缓存，在操作系统中都是 meltdown 针对的，

616
00:37:36,320 --> 00:37:39,920
这两个缓存都可以包含用户数据和内核数据，

617
00:37:40,700 --> 00:37:42,680
L2 缓存可以包含内核数据，

618
00:37:42,680 --> 00:37:49,420
因为它是物理地址的，所以不会有问题。

619
00:37:49,540 --> 00:37:52,360
L1 缓存要稍微复杂一些，

620
00:37:52,360 --> 00:37:53,200
它是虚拟地址，

621
00:37:53,200 --> 00:37:55,180
当我们切换页表时，

622
00:37:55,390 --> 00:37:57,670
L1 缓存的内容不再有效，

623
00:37:57,670 --> 00:37:59,350
因为我们切换了页表，

624
00:37:59,350 --> 00:38:01,990
这意味着虚拟地址的含义改变了，

625
00:38:01,990 --> 00:38:04,750
所以当切换页表时，你必须刷新 L1 缓存，

626
00:38:04,960 --> 00:38:10,520
尽管有更复杂的技巧可以让你避免这种情况，

627
00:38:10,850 --> 00:38:15,140
但是，在这篇论文的时代的操作系统，

628
00:38:15,260 --> 00:38:19,070
在用户空间和内核空间之间切换时，不会切换页表，

629
00:38:19,070 --> 00:38:20,000
因为两者都是映射的，

630
00:38:20,150 --> 00:38:24,470
这意味着，我们不必刷新 L1 缓存中的数据，

631
00:38:24,710 --> 00:38:28,010
这意味着 L1 缓存中同时包含用户数据和内核数据，

632
00:38:28,010 --> 00:38:29,750
它使得系统调用变得更快，

633
00:38:30,200 --> 00:38:31,670
如果你调用一个系统调用，

634
00:38:31,670 --> 00:38:32,570
系统调用返回，

635
00:38:32,570 --> 00:38:37,750
缓存中可能仍然有有用的用户数据，

636
00:38:37,750 --> 00:38:40,040
因为我们没有改变，

637
00:38:40,040 --> 00:38:42,980
我们没有改变页表或这些地址的含义。

638
00:38:45,620 --> 00:38:47,750
不管怎样，这里可能有内核数据，

639
00:38:48,110 --> 00:38:49,340
即使你正在用户空间运行，

640
00:38:49,340 --> 00:38:52,710
L1 缓存中也很可能有内核数据，

641
00:38:53,070 --> 00:38:55,770
这些权限是从 TLB 复制出来的，

642
00:38:55,770 --> 00:38:57,330
从页表条目复制来的，

643
00:38:57,510 --> 00:39:01,290
告诉机器，即使数据在缓存中，

644
00:39:01,320 --> 00:39:02,490
你不能查看它，

645
00:39:03,130 --> 00:39:05,050
并引发页面错误。

646
00:39:11,870 --> 00:39:13,940
所以现在是提这件事的好时机，

647
00:39:15,220 --> 00:39:22,390
即使微结构优化的目的是它们是完全透明的，

648
00:39:24,910 --> 00:39:26,650
那不可能是真的，

649
00:39:26,740 --> 00:39:30,730
因为这些微架构优化的全部目的

650
00:39:30,730 --> 00:39:33,040
几乎就是为了提高性能，

651
00:39:33,160 --> 00:39:39,250
所以，它们至少在性能方面是可见的，

652
00:39:39,310 --> 00:39:41,680
你可以判断你的机器是否有缓存，

653
00:39:41,710 --> 00:39:43,360
因为如果它没有缓存，

654
00:39:43,390 --> 00:39:46,600
它的运行速度会慢几百倍，

655
00:39:47,020 --> 00:39:50,980
另外，你还可以判断要获取的数据在哪里，

656
00:39:51,010 --> 00:39:53,350
如果你能足够精确地测量时间，

657
00:39:53,590 --> 00:39:55,600
你做加载，你就能看出来，

658
00:39:55,900 --> 00:39:59,440
如果加载在几个周期内返回，数据一定已被缓存，

659
00:39:59,440 --> 00:40:02,380
如果加载在百倍周期之后返回，

660
00:40:03,360 --> 00:40:05,820
它们可能是从内存加载的，

661
00:40:06,210 --> 00:40:07,650
所以差异是明显的，

662
00:40:07,650 --> 00:40:12,600
如果你能测量出几纳秒甚至几十纳秒的时间，

663
00:40:12,780 --> 00:40:14,070
你可以分辨出不同之处，

664
00:40:14,220 --> 00:40:15,420
所以在性能层面上，

665
00:40:15,510 --> 00:40:18,390
微架构绝对不透明的。

666
00:40:19,120 --> 00:40:22,330
我们谈论的所有东西，分支预测，缓存或其他，

667
00:40:22,330 --> 00:40:28,300
所有这些东西至少在时间上是间接可见的。

668
00:40:30,990 --> 00:40:32,190
所以，当然很多人，

669
00:40:32,190 --> 00:40:40,020
即使微架构设计在任何细节层面上都是保密的，

670
00:40:40,440 --> 00:40:42,990
对于 Intel 来说，如何实现是他们的私有业务，

671
00:40:43,020 --> 00:40:48,630
事实上，它一直以来都是很多人非常感兴趣的，

672
00:40:48,630 --> 00:40:50,310
因为它对性能影响很大。

673
00:40:50,520 --> 00:40:55,230
所以，编译器编写者对微体系结构了解很多，

674
00:40:55,230 --> 00:40:58,350
因为，许多编译器优化

675
00:40:58,350 --> 00:41:04,890
都在隐式地利用人们对机器内部的良好猜测。

676
00:41:05,500 --> 00:41:11,800
并且实际上 CPU 制造商发布了优化指南，

677
00:41:11,830 --> 00:41:15,010
揭示了一些微架构的技巧，

678
00:41:15,100 --> 00:41:16,840
但它们很少涉及太多细节，

679
00:41:17,410 --> 00:41:23,560
当然没有足够的细节来真正理解为什么 meltdown 会起作用。

680
00:41:24,180 --> 00:41:27,240
所以微架构的东西处于

681
00:41:27,240 --> 00:41:34,540
在透明、可见和隐藏之间，

682
00:41:34,630 --> 00:41:39,460
当然有很多人感兴趣，

683
00:41:39,460 --> 00:41:41,800
很多人知道关于它的各种随机的事情。

684
00:41:43,800 --> 00:41:50,420
好的，所以为什么这些缓存的东西对于 meltdown 是感兴趣的，

685
00:41:50,540 --> 00:41:53,390
首先，关于缓存，有什么问题吗？

686
00:41:58,660 --> 00:42:02,530
好的，那么让我来谈谈，

687
00:42:03,720 --> 00:42:09,300
关于论文使用缓存的主要方式，

688
00:42:09,300 --> 00:42:13,800
论文讨论了这种技术，刷新并重新加载。

689
00:42:18,740 --> 00:42:21,760
刷新和重新加载的目的是什么，

690
00:42:21,760 --> 00:42:23,710
它回答的问题是，

691
00:42:24,850 --> 00:42:33,350
是否有一段特定的代码使用了位于特定地址的内存。

692
00:42:33,840 --> 00:42:39,120
这不是直接的安全漏洞，

693
00:42:39,120 --> 00:42:41,820
因为它只对你能得到的内存起作用。

694
00:42:42,210 --> 00:42:43,380
所以如果你的用户代码，

695
00:42:43,380 --> 00:42:45,060
你有一些内存，那就是你的内存，

696
00:42:45,060 --> 00:42:45,960
你可以使用它，

697
00:42:46,140 --> 00:42:48,600
你可以调用自己的一个函数，

698
00:42:48,600 --> 00:42:52,110
然后你就可以区分，

699
00:42:52,110 --> 00:42:54,120
你可以用刷新和重新加载来区分，

700
00:42:54,120 --> 00:42:58,800
你刚才执行的函数是否使用了内存，

701
00:42:59,320 --> 00:43:02,740
你不能直接使用这个攻击或者它不是攻击，

702
00:43:02,770 --> 00:43:04,990
你可以使用这个技术来确定

703
00:43:04,990 --> 00:43:09,010
其他进程使用的是否是私有内存，

704
00:43:11,110 --> 00:43:14,590
不过，因为进程有时会共享内存，是的，

705
00:43:16,180 --> 00:43:18,220
你也许还能做到，

706
00:43:18,220 --> 00:43:20,210
正确的说法是，

707
00:43:20,210 --> 00:43:22,760
你只能找到被允许访问的内存。

708
00:43:23,540 --> 00:43:24,980
好的，那么回答这个问题，

709
00:43:25,780 --> 00:43:29,620
有没有一个特定的函数使用这个内存。

710
00:43:29,650 --> 00:43:35,960
所以，第一步，我们要刷新，

711
00:43:35,960 --> 00:43:39,050
假设我们对地址 x 感兴趣，

712
00:43:41,240 --> 00:43:43,130
我们要刷新缓存，

713
00:43:43,130 --> 00:43:47,600
我们希望确保缓存不包含内存位置 x ，

714
00:43:47,600 --> 00:43:49,850
为了我们的方便，

715
00:43:50,270 --> 00:43:55,600
Intel 提供了一个名为 clFlash 的指令，

716
00:43:56,680 --> 00:43:58,210
你给它一个地址，

717
00:43:58,720 --> 00:44:01,660
并且它将删除，

718
00:44:01,660 --> 00:44:06,730
它将确保那个位置不会缓存，

719
00:44:07,120 --> 00:44:08,440
所以这是非常方便的。

720
00:44:10,360 --> 00:44:12,790
即使机器没有提供这条指令，

721
00:44:12,790 --> 00:44:15,760
有很多方法可以从缓存中清除东西，

722
00:44:15,760 --> 00:44:19,810
比如，如果你知道缓存中保存 64 千字节，

723
00:44:19,840 --> 00:44:22,810
那么很可能的情况是，

724
00:44:22,810 --> 00:44:26,410
如果你加载 64 千字节的随机内存，

725
00:44:26,760 --> 00:44:28,710
只是加载指令，

726
00:44:29,010 --> 00:44:32,040
这些将被加载到缓存中，

727
00:44:32,250 --> 00:44:35,760
在将 64 千字节的新数据加载到缓存后，

728
00:44:36,360 --> 00:44:38,100
之前放在里面的东西肯定都不见了，

729
00:44:38,130 --> 00:44:41,130
因为缓存只能容纳 64 千字节的大小。

730
00:44:41,580 --> 00:44:44,540
所以即使没有这个指令，

731
00:44:44,600 --> 00:44:47,090
你仍然可以刷新缓存中的所有内容。

732
00:44:47,660 --> 00:44:49,040
那么第二步是，

733
00:44:49,250 --> 00:44:54,770
你感兴趣的是某段特定的代码是否使用了数据 x ，

734
00:44:54,770 --> 00:44:57,140
你只需要调用那个代码，

735
00:44:57,920 --> 00:45:01,580
它所做的事情，可能使用 x ，也可能不使用，

736
00:45:02,590 --> 00:45:06,670
现在你想要确认 x 是否在缓存中，

737
00:45:06,670 --> 00:45:08,980
因为是，你刷新缓存，

738
00:45:09,010 --> 00:45:09,970
如果它现在在缓存里，

739
00:45:09,970 --> 00:45:12,130
一定是 f 导致加载，

740
00:45:12,670 --> 00:45:13,900
除非有其他事情发生。

741
00:45:14,140 --> 00:45:17,170
所以你需要加载，

742
00:45:17,170 --> 00:45:19,120
但是你想知道加载需要多长时间，

743
00:45:19,450 --> 00:45:21,700
所以我们说的是纳秒，

744
00:45:21,700 --> 00:45:24,310
比如 5 纳秒对比 100 纳秒，

745
00:45:24,310 --> 00:45:26,200
我们怎样才能如此精确地测量时间，

746
00:45:26,380 --> 00:45:29,170
这是一项艰巨的任务，

747
00:45:29,170 --> 00:45:32,740
然而， CPU 再次来到 [ra] ，

748
00:45:32,740 --> 00:45:37,360
提供了获取周期粒度时间的指令，

749
00:45:39,620 --> 00:45:41,360
它叫做 rdtsc ，

750
00:45:42,010 --> 00:45:47,140
所以我们只需要执行 rdtsc 指令，

751
00:45:47,170 --> 00:45:50,140
它告诉我们已经过去的周期数，

752
00:45:50,140 --> 00:45:53,620
从机器启动以来已经过去的机器周期。

753
00:45:54,330 --> 00:45:56,580
如果它是 2GHz 的机器，

754
00:45:56,580 --> 00:46:00,120
这意味着，我们这里的精确度是 0.5 纳秒，

755
00:46:00,830 --> 00:46:01,820
它相当小。

756
00:46:02,360 --> 00:46:04,850
现在我们要加载，

757
00:46:06,500 --> 00:46:13,840
比如 junk = *x ，

758
00:46:13,870 --> 00:46:17,860
我们要加载位置 x 的数据，

759
00:46:18,250 --> 00:46:19,690
我再获取一下时间，

760
00:46:23,300 --> 00:46:26,750
看一下 b 减去 a 的差值，

761
00:46:29,450 --> 00:46:33,620
如果 b 减去 a 等于 5 、 6 、 7 或其他，

762
00:46:33,620 --> 00:46:36,530
这意味着这个加载命中了缓存，

763
00:46:36,530 --> 00:46:38,600
这意味着这个函数使用了数据，

764
00:46:38,870 --> 00:46:41,180
如果 b 减去 a 是 150 ，

765
00:46:41,930 --> 00:46:45,530
则意味着 x 不在缓存中，

766
00:46:45,980 --> 00:46:50,410
这可能意味着 f ，

767
00:46:50,410 --> 00:46:52,660
这可能意味着 f 从未使用过 x ，

768
00:46:52,690 --> 00:46:54,520
这并不完全是一成不变的，

769
00:46:54,520 --> 00:46:57,970
因为 f 可能使用了 x ，然后使用了其他东西，

770
00:46:58,330 --> 00:47:00,940
与缓存中的 x 冲突，

771
00:47:00,940 --> 00:47:03,460
并且使 x 被踢出缓存。

772
00:47:03,580 --> 00:47:05,470
但是，对于简单的情况，

773
00:47:06,910 --> 00:47:11,260
b 减去 a 的值非常大，意味着 f 没有使用它，

774
00:47:11,260 --> 00:47:15,670
在 b 减去 a 的较小值中，表示 f 使用了那个数据。

775
00:47:18,070 --> 00:47:19,900
所以这还不是攻击，

776
00:47:19,900 --> 00:47:24,760
因为我们必须能够访问这个内存，

777
00:47:24,760 --> 00:47:26,230
这是我们的内存。

778
00:47:28,290 --> 00:47:31,560
关于刷新并重新加载，有什么问题吗？

779
00:47:40,340 --> 00:47:44,140
好的，我想这是所有的准备工作，

780
00:47:44,470 --> 00:47:46,360
让我们回到 meltdown 。

781
00:47:48,910 --> 00:47:51,040
所以这是一个更完整的版本，

782
00:47:51,040 --> 00:47:53,800
我在开始时向你们展示的 meltdown 的关键，

783
00:47:53,920 --> 00:47:57,280
这是一个更完整的 meltdown 。

784
00:47:59,690 --> 00:48:02,960
所以现在我增加了刷新并重新加载的部分。

785
00:48:04,380 --> 00:48:06,150
同样，我们再次声明这个 buf ，

786
00:48:06,210 --> 00:48:08,940
我们的想法是，

787
00:48:09,090 --> 00:48:13,050
我们只从内核中取出一位，

788
00:48:13,200 --> 00:48:17,370
我们要把这一位乘以 4096 ，

789
00:48:17,370 --> 00:48:19,440
所以我们希望使用刷新并重新加载，

790
00:48:19,440 --> 00:48:22,110
来查看 buf 0 在缓存中，

791
00:48:22,110 --> 00:48:24,540
或 buf 4096 在缓存中，

792
00:48:24,690 --> 00:48:29,130
之所以会有很大的分离，

793
00:48:30,280 --> 00:48:33,700
是因为这个硬件有一个预取器，

794
00:48:33,700 --> 00:48:35,560
所以，如果你从内存加载一个内容，

795
00:48:35,770 --> 00:48:38,290
它也会从内存加载下一部分内容，

796
00:48:38,320 --> 00:48:39,580
下一部分缓存行，

797
00:48:39,760 --> 00:48:42,790
所以我们不能有两个不同的缓存行，

798
00:48:42,820 --> 00:48:46,150
我们在特别近的地方进行刷新和重新加载，

799
00:48:46,560 --> 00:48:47,730
需要距离足够远，

800
00:48:47,730 --> 00:48:52,320
即使是硬件预加载也不会造成困惑。

801
00:48:53,030 --> 00:48:54,530
所以我们把整个论文分开，

802
00:48:55,760 --> 00:48:56,750
现在是刷新部分，

803
00:48:56,780 --> 00:48:58,850
我们只是调用这个 clflush 指令

804
00:48:59,060 --> 00:49:05,970
确保 buf 的相关部分没有被缓存。

805
00:49:06,700 --> 00:49:19,470
现在，我们利用，

806
00:49:19,500 --> 00:49:22,800
第 7 行可能不是必要的，

807
00:49:22,800 --> 00:49:26,850
但这里发生的事情是，我们正在利用，

808
00:49:27,360 --> 00:49:35,000
我将利用这段时间的空隙，

809
00:49:36,030 --> 00:49:41,780
我们做这个第 10 行的加载内核地址，

810
00:49:41,780 --> 00:49:42,860
但是它会出错，

811
00:49:43,700 --> 00:49:47,990
但是我们希望能够预测执行其他指令，

812
00:49:48,080 --> 00:49:51,140
在这条指令退出之前，

813
00:49:51,230 --> 00:49:55,520
在它引发故障并取消这些指令之前，

814
00:49:55,610 --> 00:49:58,880
如果这个负载退出，

815
00:49:58,880 --> 00:50:00,290
比如在这一点上，

816
00:50:00,700 --> 00:50:02,440
那对我们来说太早了，

817
00:50:02,620 --> 00:50:07,240
因为我们需要预测执行第 13 行，

818
00:50:07,510 --> 00:50:08,980
才能完成攻击，

819
00:50:09,160 --> 00:50:10,780
所以，我们希望确保

820
00:50:10,780 --> 00:50:14,470
这个加载不会退出，时间越长越好，

821
00:50:15,150 --> 00:50:20,120
以延迟故障和延迟预测取消。

822
00:50:20,480 --> 00:50:24,920
我们知道指令不会在所有之前的指令都退出之前退出，

823
00:50:25,400 --> 00:50:26,480
这是规则之一。

824
00:50:27,090 --> 00:50:28,560
所以在第 7 行，

825
00:50:28,620 --> 00:50:32,010
我们将使用一些昂贵的指令，

826
00:50:32,010 --> 00:50:33,600
这些指令很长一段时间内都不会完成，

827
00:50:33,840 --> 00:50:37,110
也许它加载其他已知必须来自内存的内容，

828
00:50:37,110 --> 00:50:38,580
所以这需要几百个周期，

829
00:50:38,580 --> 00:50:41,760
或者它做除法或平方根之类的，

830
00:50:41,760 --> 00:50:43,980
无论什么需要很长时间的事情，

831
00:50:44,070 --> 00:50:46,320
它在很长一段时间内都不会退出，

832
00:50:46,530 --> 00:50:50,340
因此导致这个负载在很长一段时间内不会退出，

833
00:50:50,550 --> 00:50:53,940
让这些指令有时间预测执行。

834
00:50:57,420 --> 00:50:59,010
好的，现在我们再次假设，

835
00:50:59,010 --> 00:51:01,830
我们在内核中有一个虚拟地址，

836
00:51:04,680 --> 00:51:06,960
执行第 10 行，

837
00:51:07,140 --> 00:51:09,150
第 10 行不会出现错误，

838
00:51:09,150 --> 00:51:10,590
我们知道它会出现错误，

839
00:51:10,590 --> 00:51:12,120
但是退出前不会出现错误，

840
00:51:12,120 --> 00:51:15,300
但是我们已经设置好了，

841
00:51:15,300 --> 00:51:17,640
所以暂时不会退出，因为它还没有退出，

842
00:51:18,390 --> 00:51:20,190
而且因为在 Intel CPU 上，

843
00:51:20,310 --> 00:51:23,790
即使你不被允许查看，数据也会返回，

844
00:51:23,940 --> 00:51:26,830
数据返回用于预测执行，

845
00:51:26,830 --> 00:51:28,270
即使你没有权限，

846
00:51:28,840 --> 00:51:32,050
这意味着我们可以预测执行，

847
00:51:32,320 --> 00:51:34,420
机器将预测执行第 11 行，

848
00:51:34,420 --> 00:51:37,560
并获得内核数据的低位，

849
00:51:38,040 --> 00:51:40,140
乘以 4096 ，

850
00:51:40,350 --> 00:51:43,770
第 13 行是另一个加载，

851
00:51:44,570 --> 00:51:50,800
使用 buf 的地址加上 r2 的内容的地址，

852
00:51:51,570 --> 00:51:54,510
我们知道它会被取消，

853
00:51:55,160 --> 00:51:57,620
因为我们知道这个会产生错误，

854
00:51:57,620 --> 00:52:00,440
我们知道对 r3 的写入会被取消，

855
00:52:00,470 --> 00:52:09,250
但是第 13 行将导致来自 buf 的一些数据加载到缓存中，

856
00:52:09,520 --> 00:52:12,400
即使它最终不会影响到寄存器 3 ，

857
00:52:12,490 --> 00:52:17,860
所以，第 13 行将导致某些内容被加载到缓存中，

858
00:52:18,100 --> 00:52:21,250
这取决于低位是否为 0 或 1 ，

859
00:52:21,880 --> 00:52:28,660
第 13 行将导致缓存包含 buf 0 或 buf 4096 ，

860
00:52:30,010 --> 00:52:33,250
然后，

861
00:52:33,460 --> 00:52:35,440
即使 r2 和 r3 已经取消，

862
00:52:35,500 --> 00:52:38,200
变化会在缓存中，

863
00:52:38,230 --> 00:52:40,600
因为假设它是隐藏的微架构状态，

864
00:52:40,600 --> 00:52:43,420
实际上，缓存会被修改。

865
00:52:44,680 --> 00:52:46,600
最后，在某个时刻，错误将会发生，

866
00:52:46,990 --> 00:52:50,740
我们需要在错误后进行恢复，

867
00:52:50,740 --> 00:52:52,510
但这只是一个页面错误，

868
00:52:52,510 --> 00:52:57,160
你可以或者用户进程可以注册一个页面错误处理程序，

869
00:52:57,340 --> 00:52:59,200
并在页面错误后重新获得控制权，

870
00:52:59,200 --> 00:53:03,730
论文还提到了几种在故障发生后可以继续的方法。

871
00:53:05,470 --> 00:53:06,940
现在我们要做的就是找出

872
00:53:06,940 --> 00:53:11,440
加载到缓存中的是 buf 0 还是 buf 4096 ，

873
00:53:11,620 --> 00:53:13,930
现在我们可以做刷新并重新加载的重新加载部分，

874
00:53:14,050 --> 00:53:17,290
我们读出准确的时间，

875
00:53:18,120 --> 00:53:20,460
加载 buf 0 ，再读一遍时间，

876
00:53:20,460 --> 00:53:22,800
加载 buf 1 ，再读一次时间，

877
00:53:22,800 --> 00:53:24,780
比较这两个时间上的差异，

878
00:53:24,930 --> 00:53:27,570
无论哪一个花费的时间较短，

879
00:53:28,140 --> 00:53:34,520
可能指示内核数据的低位是 0 还是 1 。

880
00:53:39,350 --> 00:53:43,490
然后我们将其重复几十亿次，

881
00:53:44,270 --> 00:53:45,770
我们可以扫描所有内核内存。

882
00:53:47,100 --> 00:53:49,080
但是在这个例子中，

883
00:53:49,230 --> 00:53:52,560
如果 b 减去 a 小于 c 减去 b ，

884
00:53:52,560 --> 00:53:56,400
这是否意味着 buf 0 被缓存了。

885
00:53:57,060 --> 00:54:00,420
让我看看是不是搞错了，

886
00:54:00,450 --> 00:54:03,630
b 减去 a 意味着 buf 0 是缓存的，

887
00:54:03,630 --> 00:54:06,600
是的，你说得对。

888
00:54:10,790 --> 00:54:15,180
现在我们[]，做得好。

889
00:54:17,540 --> 00:54:19,670
哦，抱歉，你是否需要，

890
00:54:19,820 --> 00:54:25,010
在第 9 行之前是否有一个 if ，

891
00:54:25,700 --> 00:54:30,050
我们是否需要 if ，还是仍然会这样。

892
00:54:31,980 --> 00:54:38,280
为了帮助我阐明预测执行的正当理由，

893
00:54:38,820 --> 00:54:43,410
即使我们不知道分支是否被选择，也要继续计算，

894
00:54:43,410 --> 00:54:47,610
但是这里真正的猜测核心是，

895
00:54:47,670 --> 00:54:51,740
我们不知道这个加载载会出现错误，

896
00:54:51,740 --> 00:54:56,150
所以机器预测执行通过加载，

897
00:54:56,330 --> 00:55:00,830
理论上，很可能不会出现错误，

898
00:55:00,830 --> 00:55:02,090
即使它们可能需要很长时间，

899
00:55:02,090 --> 00:55:04,340
比如一次加载可能需要数百个循环，

900
00:55:04,970 --> 00:55:06,440
所以我们希望能够，

901
00:55:06,470 --> 00:55:09,530
这样机器就会预测执行通过加载，

902
00:55:10,040 --> 00:55:14,140
即使它不知道会不会出错，

903
00:55:14,140 --> 00:55:16,300
如果加载出现错误，

904
00:55:16,300 --> 00:55:18,460
然后它会取消所有这些预测执行，

905
00:55:18,730 --> 00:55:20,980
这里会出现预测执行，

906
00:55:21,670 --> 00:55:27,970
任何时刻，你有一条长时间运行的指令可能会或不会成功，

907
00:55:28,000 --> 00:55:29,080
比如除法，

908
00:55:29,110 --> 00:55:31,030
我们不知道它是否被零除，

909
00:55:31,030 --> 00:55:33,940
所以除法器后的指令也在猜测。

910
00:55:35,980 --> 00:55:39,070
不管怎样，真正的预测执行从这里开始，

911
00:55:39,070 --> 00:55:40,120
实际上我们试着，

912
00:55:41,260 --> 00:55:43,930
为了让攻击更有可能成功，

913
00:55:43,930 --> 00:55:46,570
我们确保预测从这里开始，

914
00:55:46,570 --> 00:55:48,790
所以这才是我们真正关心的预测。

915
00:56:01,640 --> 00:56:02,690
还有其他问题吗？

916
00:56:06,100 --> 00:56:10,730
对于这个例子我们只读了一位，

917
00:56:13,050 --> 00:56:16,590
是否可以做一些简单的修改，

918
00:56:16,590 --> 00:56:19,890
我们可以读取完整的寄存器大小的位。

919
00:56:20,100 --> 00:56:22,590
是的，运行 64 次，每个位一次。

920
00:56:24,810 --> 00:56:29,760
为什么不能一次读取 64 位呢？

921
00:56:30,790 --> 00:56:34,290
六十，你需要这个 buf ，

922
00:56:34,320 --> 00:56:36,660
这个 buf 的大小必须是，

923
00:56:36,660 --> 00:56:44,430
达到 2 的位数次方的 4096 倍，

924
00:56:44,670 --> 00:56:46,050
所以 64 位太大了，

925
00:56:46,050 --> 00:56:48,810
我们没有足够的内存来制作那么大的 buf ，

926
00:56:50,810 --> 00:56:52,700
我们需要这个设置的方式。

927
00:56:54,810 --> 00:57:00,310
但不管怎样， 64 位太多了，

928
00:57:00,310 --> 00:57:02,080
你可以一次读取 8 位，

929
00:57:02,320 --> 00:57:09,350
让缓冲器大小为 256 乘以 4096 。

930
00:57:11,620 --> 00:57:13,060
这篇论文讨论了，

931
00:57:14,860 --> 00:57:16,540
论文观察到，

932
00:57:18,150 --> 00:57:23,500
由于大部分时间都在刷新并重新加载，

933
00:57:25,380 --> 00:57:27,720
如果你一次读取一个字节，

934
00:57:28,620 --> 00:57:36,750
则计算出字节的那些位需要 256 次刷新和重新加载，

935
00:57:38,310 --> 00:57:40,140
每个可能值对应一个。

936
00:57:40,800 --> 00:57:42,780
如果一次加载一个位，

937
00:57:43,140 --> 00:57:47,470
那么每个位只需要一次刷新和重新加载，

938
00:57:47,470 --> 00:57:51,460
可以是两个刷新并重新加载，

939
00:57:51,610 --> 00:57:52,930
所以如果你一次需要一个位，

940
00:57:53,140 --> 00:57:56,170
那么你只需要 16 次刷新并重新加载，

941
00:57:56,170 --> 00:57:57,160
如果你一次读取一个字节，

942
00:57:57,160 --> 00:57:59,800
则需要执行 256 次刷新和重新加载，

943
00:58:00,160 --> 00:58:00,910
这篇论文说，

944
00:58:00,910 --> 00:58:04,000
一次做一位比一次做一个字节要快。

945
00:58:05,890 --> 00:58:10,500
这看起来有点违反直觉，但似乎是真的。

946
00:58:18,960 --> 00:58:20,010
还有其他问题吗？

947
00:58:28,760 --> 00:58:32,810
那么这个用户程序，这个程序要从哪里运行，

948
00:58:33,890 --> 00:58:37,400
机器上有没有什么特别的位置，

949
00:58:37,400 --> 00:58:38,690
不一定是，

950
00:58:39,480 --> 00:58:41,220
我想说你把它写在哪里？

951
00:58:43,650 --> 00:58:47,340
这个程序是从哪里运行的，可以是一个用户程序吗？

952
00:58:47,880 --> 00:58:53,250
是的，那取决于你有什么样的权限使用这台机器，

953
00:58:53,250 --> 00:58:55,740
以及你想要窃取的数据在哪里，

954
00:58:56,070 --> 00:58:59,360
谁知道呢。

955
00:58:59,360 --> 00:59:02,150
比如，假设，

956
00:59:03,000 --> 00:59:05,610
你登录到 Athena 机器，

957
00:59:06,030 --> 00:59:08,160
这里有另外几百个用户，

958
00:59:08,250 --> 00:59:10,170
你想窃取某人的密码，

959
00:59:11,470 --> 00:59:12,340
而且你很有耐心，

960
00:59:13,030 --> 00:59:15,160
你可以使用，让我们假设，

961
00:59:15,160 --> 00:59:17,320
Athena 在几年前，

962
00:59:17,320 --> 00:59:19,000
Athena 运行的 Linux 版本

963
00:59:19,000 --> 00:59:22,840
将内核映射到每个进程地址空间，

964
00:59:23,140 --> 00:59:26,080
然后你就可以用 meltdown 得到一个个位，

965
00:59:26,560 --> 00:59:27,430
内核中的所有内容，

966
00:59:27,430 --> 00:59:30,820
包括 IO 缓冲区和网络缓冲区等，

967
00:59:30,910 --> 00:59:32,590
如果有人在输入密码，

968
00:59:32,620 --> 00:59:34,390
如果你够幸运或有耐心，

969
00:59:35,340 --> 00:59:36,570
有人在输入密码，

970
00:59:36,570 --> 00:59:37,830
你加载所有内核内存，

971
00:59:37,860 --> 00:59:41,760
你将在内核内存中看到那个密码。

972
00:59:42,580 --> 00:59:44,920
并且内核可能映射，

973
00:59:44,950 --> 00:59:47,590
比如 xv6 映射所有物理内存，

974
00:59:47,830 --> 00:59:49,690
这意味着你可能可以读取所有物理内存，

975
00:59:49,690 --> 00:59:53,200
即所有其他进程内存，

976
00:59:53,320 --> 00:59:55,690
在分时机器上使用这项技术。

977
00:59:56,640 --> 01:00:01,500
所以，我可以看到每个人的文本编辑器内容或我喜欢的任何内容。

978
01:00:02,500 --> 01:00:04,330
现在你必须，

979
01:00:05,460 --> 01:00:06,630
这是一种你可以使用它的方式，

980
01:00:06,630 --> 01:00:08,010
如果你使用的是分时机器，

981
01:00:08,010 --> 01:00:11,600
对于其他情况，情况会有所不同。

982
01:00:12,270 --> 01:00:13,170
了解了。

983
01:00:13,920 --> 01:00:16,740
分时技术不再那么普及了，

984
01:00:16,980 --> 01:00:20,130
但最致命的场景

985
01:00:20,130 --> 01:00:21,990
将是某种云计算，

986
01:00:21,990 --> 01:00:25,260
你使用像亚马逊这样的云提供商，

987
01:00:25,650 --> 01:00:28,620
而且在同一台机器上运行多个客户机。

988
01:00:29,280 --> 01:00:33,480
取决于他们如何设置虚拟机监视器的细节，

989
01:00:33,480 --> 01:00:36,090
或者容器系统之类的。

990
01:00:36,450 --> 01:00:40,640
如果你从亚马逊购买时间，

991
01:00:41,330 --> 01:00:46,720
然后，也许你可以窥探其他客户机软件的内存，

992
01:00:46,720 --> 01:00:48,580
运行在同一台亚马逊机器上的。

993
01:00:50,730 --> 01:00:51,900
所以我认为这是真的，

994
01:00:53,230 --> 01:00:55,120
这可能就是人们实际使用它的方式。

995
01:00:55,300 --> 01:00:59,170
另一个可能有用的是你的浏览器，

996
01:00:59,170 --> 01:00:59,800
当你在浏览时，

997
01:00:59,800 --> 01:01:03,070
Web 浏览器会在其中运行许多不受信任的代码，

998
01:01:03,070 --> 01:01:05,350
是由你随机访问的网站提供的，

999
01:01:07,330 --> 01:01:08,860
也许是以插件的形式，

1000
01:01:09,070 --> 01:01:12,370
也许是 Javascript 的形式加载到您的浏览器中，

1001
01:01:12,370 --> 01:01:15,840
由浏览器编译并执行，

1002
01:01:15,990 --> 01:01:19,500
这是可能的，实施这个攻击，

1003
01:01:19,770 --> 01:01:25,340
通过你浏览网页时，在浏览器中运行的代码。

1004
01:01:26,190 --> 01:01:26,970
你可能不会，

1005
01:01:28,060 --> 01:01:30,220
即使它从网站上运行他们的加载，

1006
01:01:30,220 --> 01:01:32,620
他们也会窃取你笔记本电脑中的任何东西。

1007
01:01:33,790 --> 01:01:36,040
我不知道这件事的细节是不是真的行得通。

1008
01:01:37,180 --> 01:01:42,190
有没有人演示过通过 Javascript 或 WebAssembly 的攻击？

1009
01:01:42,250 --> 01:01:43,150
我不知道，

1010
01:01:43,150 --> 01:01:46,300
我觉得人们肯定会担心 WebAssembly 。

1011
01:01:46,920 --> 01:01:49,230
我不知道攻击是否真的有可能，

1012
01:01:50,010 --> 01:01:53,280
对于 Javascript ，我知道，

1013
01:01:53,900 --> 01:01:57,760
也许症结在于准确的时间。

1014
01:01:59,370 --> 01:02:01,620
你不能得到这个纳秒的时间，

1015
01:02:01,680 --> 01:02:04,770
所以你现在不能执行刷新并重新加载，

1016
01:02:04,770 --> 01:02:07,200
除非一些更聪明的人

1017
01:02:07,200 --> 01:02:08,430
可以想出一个办法来做这件事，

1018
01:02:08,430 --> 01:02:13,250
我不知道 WebAssembly 更接近运行机器代码，

1019
01:02:13,250 --> 01:02:16,610
我不知道细节是怎么回事，

1020
01:02:16,610 --> 01:02:21,160
但是，很多人很快就想到了。

1021
01:02:25,250 --> 01:02:29,180
好的，事实是攻击并不总是有效的，

1022
01:02:29,420 --> 01:02:30,740
原因是，

1023
01:02:30,830 --> 01:02:31,520
我不认为，

1024
01:02:31,550 --> 01:02:35,120
作者从未解释过或只是猜测过，

1025
01:02:35,120 --> 01:02:38,000
你可以看到，我不知道你是否能看到这个，

1026
01:02:38,000 --> 01:02:39,140
也许你看不到这个，

1027
01:02:39,170 --> 01:02:41,990
但如果你翻到他们论文的最后一页，

1028
01:02:42,260 --> 01:02:44,060
你会看到它实际的输出，

1029
01:02:44,150 --> 01:02:47,150
他们在自己的机器上发动了攻击，

1030
01:02:47,150 --> 01:02:51,080
并从自己的机器上的内核中提取了一系列数据。

1031
01:02:51,530 --> 01:02:53,670
如果你仔细看，

1032
01:02:53,670 --> 01:02:56,040
你会发现这些很多行，

1033
01:02:56,370 --> 01:03:01,410
都是 xx xxx ， x 以及点，

1034
01:03:01,560 --> 01:03:04,620
在这些地方，他们没有提取到任何东西，

1035
01:03:04,650 --> 01:03:06,120
meltdown 失效了，

1036
01:03:06,540 --> 01:03:08,880
尽管他们重复了很多次。

1037
01:03:09,340 --> 01:03:11,530
你可以看出他们一定是，

1038
01:03:11,650 --> 01:03:16,480
这个论文的攻击版本重试了很多次，

1039
01:03:16,480 --> 01:03:19,570
因为第 6.2 节谈到了性能，

1040
01:03:19,870 --> 01:03:21,340
表示在某些情况下，

1041
01:03:21,490 --> 01:03:24,910
它们可以提取数据的速率仅为每秒 10 字节，

1042
01:03:25,450 --> 01:03:27,640
这意味着他们在那里一次又一次地尝试，

1043
01:03:27,640 --> 01:03:31,660
在几千次之后，他们终于设法获得了一些数据，

1044
01:03:31,660 --> 01:03:32,230
也就是，

1045
01:03:32,730 --> 01:03:37,860
刷新并重新加载表示两个缓存行有不同的加载时间。

1046
01:03:39,270 --> 01:03:40,710
所以有一些无法解释的事情，

1047
01:03:40,710 --> 01:03:45,180
关于为什么 meltdown 失败的频率很高，

1048
01:03:45,210 --> 01:03:47,580
获取一些数据，获取真实的数据，

1049
01:03:48,140 --> 01:03:49,970
还有一堆他们没有得到的数据，

1050
01:03:50,420 --> 01:03:54,370
我不知道人们，

1051
01:03:54,370 --> 01:03:56,410
据我所知，人们并不确定，

1052
01:03:56,410 --> 01:04:00,340
它成功或不成功的时候的条件是什么，

1053
01:04:00,490 --> 01:04:03,130
你知道最直接的可能性是，

1054
01:04:03,130 --> 01:04:07,420
如果内核数据在 L1 缓存中，则 meltdown 成功，

1055
01:04:07,420 --> 01:04:10,540
如果内核数据不在 L1 缓存中，则不会成功。

1056
01:04:10,600 --> 01:04:15,010
这很容易让人相信就是正在发生的事情，

1057
01:04:15,760 --> 01:04:17,500
因为如果它不在 L1 缓存中，

1058
01:04:17,620 --> 01:04:21,490
会有一大堆更多的机制参与到预测加载中，

1059
01:04:21,730 --> 01:04:26,740
很容易想象 CPU 对于预测加载，

1060
01:04:26,770 --> 01:04:28,990
可能还不知道是否需要，

1061
01:04:29,590 --> 01:04:34,840
不会费心去从内存加载东西。

1062
01:04:36,440 --> 01:04:39,280
但是，事情并没有那么简单，

1063
01:04:40,150 --> 01:04:41,500
你可以看出事情没有那么简单，

1064
01:04:41,500 --> 01:04:44,290
因为论文中说到有时当他们尝试，

1065
01:04:44,380 --> 01:04:47,650
重试了很多次，最后奏效了，

1066
01:04:47,710 --> 01:04:50,970
所以有一些更复杂的情况，

1067
01:04:51,000 --> 01:04:54,360
也许是在 CPU 内部的竞争，

1068
01:04:54,750 --> 01:04:57,030
它偶尔可以工作，

1069
01:04:57,800 --> 01:04:59,990
即使对于不在缓存中的数据。

1070
01:05:06,670 --> 01:05:08,650
论文的结尾也是，

1071
01:05:08,650 --> 01:05:10,420
如果你还没读到，它值得一读，

1072
01:05:10,420 --> 01:05:13,570
因为它解释了一种更真实的世界，

1073
01:05:13,570 --> 01:05:15,700
我们想找出这件事，

1074
01:05:15,700 --> 01:05:20,410
我们知道火狐的密码管理器里有密码，

1075
01:05:20,440 --> 01:05:21,430
我们想把它们弄出来，

1076
01:05:21,820 --> 01:05:23,680
然后用 meltdown 偷走他们，

1077
01:05:23,860 --> 01:05:26,680
你怎么找出地址，

1078
01:05:26,680 --> 01:05:30,100
比如，他们策划了一场完整的攻击，

1079
01:05:30,340 --> 01:05:34,290
我的意思是，完全由学者进行的攻击不是真正的袭击者，

1080
01:05:34,290 --> 01:05:37,290
但尽管如此，并填补了许多[务实]的细节。

1081
01:05:40,630 --> 01:05:44,290
我唯一想谈的就是他的修复，

1082
01:05:45,090 --> 01:05:46,380
你已经了解了一点。

1083
01:05:47,230 --> 01:05:52,560
这篇论文发表后，引起了很大的关注。

1084
01:05:52,560 --> 01:05:54,180
实际上，还有另一篇论文，

1085
01:05:54,180 --> 01:05:57,960
由同样的人撰写的关于不同攻击的论文，

1086
01:05:57,960 --> 01:06:03,320
也在 CPU 内部使用了不同类型的预测，称为 spectre 。

1087
01:06:03,350 --> 01:06:06,650
所以，这两份文件同时出来了，

1088
01:06:06,680 --> 01:06:09,920
非常令人兴奋。

1089
01:06:10,160 --> 01:06:11,150
所以人们争先恐后地，

1090
01:06:11,150 --> 01:06:13,700
人们意识到这是极具破坏性的，

1091
01:06:13,700 --> 01:06:14,990
因为我们现在谈论的是，

1092
01:06:15,110 --> 01:06:17,510
隔离性被打破了。

1093
01:06:17,940 --> 01:06:21,060
所以基本上不用再想它了，

1094
01:06:21,060 --> 01:06:26,430
但是这是一种打破页表保护的技术，

1095
01:06:26,460 --> 01:06:30,390
这就是我们如何实施用户和内核之间的隔离，

1096
01:06:30,390 --> 01:06:33,840
这就是根本性的攻击，

1097
01:06:34,350 --> 01:06:39,060
或者以任何方式破坏一项极其重要的安全措施，

1098
01:06:40,160 --> 01:06:41,330
从一个非常普遍的角度来看，

1099
01:06:41,330 --> 01:06:42,410
看起来你能看到任何东西。

1100
01:06:43,790 --> 01:06:47,600
所以人们非常争先恐后地部署修复方案，

1101
01:06:47,600 --> 01:06:52,490
很多操作系统出了立即修复，

1102
01:06:52,490 --> 01:06:56,730
在这篇论文发表后的几周内，

1103
01:06:56,730 --> 01:06:59,400
有时已经安装了这个叫做 KASLR 的东西，

1104
01:07:00,180 --> 01:07:03,510
现在在 Linux 中称为 kpti ，

1105
01:07:03,540 --> 01:07:06,060
这是一个相当直截了当的想法，

1106
01:07:06,330 --> 01:07:10,470
这个想法就是不将内核映射放在用户页表中，

1107
01:07:11,010 --> 01:07:15,030
并且如 xv6 中的那样，

1108
01:07:15,900 --> 01:07:18,540
在系统调用期间切换页表，

1109
01:07:18,540 --> 01:07:21,990
所以用户空间只有用户映射发起系统调用，

1110
01:07:22,020 --> 01:07:24,870
有类似 xv6 中的 trampoline 的安排，

1111
01:07:24,870 --> 01:07:29,190
你将页表切换到具有内核映射的页表，

1112
01:07:29,190 --> 01:07:30,240
为了执行内核。

1113
01:07:32,080 --> 01:07:34,780
这会导致攻击无法工作，

1114
01:07:34,990 --> 01:07:41,210
因为在那里你切换了页表，

1115
01:07:41,840 --> 01:07:45,470
在 r1 中的这个虚拟地址，

1116
01:07:47,400 --> 01:07:51,780
不仅不再有效，而且不再有意义，

1117
01:07:51,990 --> 01:07:54,300
因为没有给它的转换，

1118
01:07:55,080 --> 01:07:58,140
所以 CPU 不知道如何处理它，

1119
01:07:58,790 --> 01:08:00,950
这个虚拟地址不会被缓存，

1120
01:08:01,250 --> 01:08:03,470
它甚至不在 TLB 中，

1121
01:08:03,830 --> 01:08:05,600
所以内核没有方法

1122
01:08:05,600 --> 01:08:08,930
决定哪个内存对应于这个虚拟地址。

1123
01:08:10,600 --> 01:08:12,670
当这种攻击在用户空间中执行时，

1124
01:08:12,880 --> 01:08:15,670
因为这个内核的虚拟地址不再有任何意义，

1125
01:08:16,520 --> 01:08:19,520
不是非法的，只是没有意义，

1126
01:08:20,300 --> 01:08:22,550
所以这会导致攻击不起作用。

1127
01:08:23,420 --> 01:08:26,870
这个 KASLR 修复的缺点是，

1128
01:08:26,870 --> 01:08:30,110
现在系统调用更昂贵了，因为要切换页表。

1129
01:08:32,610 --> 01:08:34,080
如果你不执行任何操作，

1130
01:08:34,110 --> 01:08:37,680
切换页表会导致 TLB 刷新，

1131
01:08:37,680 --> 01:08:41,430
因为现在所有那些虚拟地址和 TLB 都是错误的虚拟地址，

1132
01:08:41,430 --> 01:08:43,200
不再与这个页表对应，

1133
01:08:43,350 --> 01:08:45,510
它会导致 L1 缓存被刷新，

1134
01:08:45,510 --> 01:08:46,830
因为它是虚拟地址，

1135
01:08:47,340 --> 01:08:50,310
所以，在某些机器上，

1136
01:08:50,310 --> 01:08:54,160
切换页表会使系统调用变得相当慢。

1137
01:08:56,820 --> 01:08:59,820
在最近的机器中，有一种叫做 PCID 的技巧，

1138
01:08:59,820 --> 01:09:01,380
你可以查到，

1139
01:09:01,380 --> 01:09:02,160
但基本上是，

1140
01:09:02,160 --> 01:09:05,610
你可以避免切换页表时刷新这些缓存，

1141
01:09:05,640 --> 01:09:06,930
虽然还需要一些时间。

1142
01:09:07,920 --> 01:09:10,260
如果你在网络上随便看看，

1143
01:09:10,260 --> 01:09:12,060
当时有很多人担心，

1144
01:09:12,060 --> 01:09:17,310
这种拆分，这种两页表的想法会非常慢，

1145
01:09:17,640 --> 01:09:21,390
事实上，这并不是一个严重的问题，

1146
01:09:21,420 --> 01:09:22,320
如果你四处看看，

1147
01:09:22,320 --> 01:09:26,130
你会发现人们对典型工作量的猜测，

1148
01:09:26,460 --> 01:09:29,880
它对典型工作量的整体性能有多大影响，

1149
01:09:29,880 --> 01:09:34,950
毕竟不会把所有的时间都花在进入和退出内核上，大概是 5% ，

1150
01:09:35,970 --> 01:09:37,770
所以这并不是一个很糟糕的决定。

1151
01:09:41,690 --> 01:09:45,940
关于 KASLR 修复，有什么问题吗？

1152
01:09:52,620 --> 01:09:54,930
所以人们很快就接受了这项技术，

1153
01:09:55,260 --> 01:09:57,750
事实上，已经有内核采用了它，

1154
01:09:57,750 --> 01:09:59,610
因为它防御了一些其他的攻击。

1155
01:10:02,200 --> 01:10:04,450
还有一个合理的硬件修复方案，

1156
01:10:04,450 --> 01:10:08,230
我相信 Intel 是在最近的处理器中制造的，

1157
01:10:08,230 --> 01:10:09,730
而 AMD 已经制造了，

1158
01:10:09,730 --> 01:10:17,540
这是因为权限，

1159
01:10:17,900 --> 01:10:20,480
这是缓存的结构，

1160
01:10:20,480 --> 01:10:24,110
当指令从 L1 缓存中加载某些东西时，

1161
01:10:24,110 --> 01:10:26,300
比如我们试图攻击的内核数据，

1162
01:10:27,050 --> 01:10:32,810
人们相信权限就在缓存条目中，

1163
01:10:33,050 --> 01:10:36,200
所以， CPU 在该点检查权限不会有任何问题，

1164
01:10:36,290 --> 01:10:41,860
实际上， AMD CPU 和现代的 Intel CPU ，

1165
01:10:42,070 --> 01:10:43,930
会很早就进行权限检查，

1166
01:10:43,930 --> 01:10:45,880
不会返回这个数据，

1167
01:10:46,120 --> 01:10:47,920
它们甚至不会把它返回给核心，

1168
01:10:48,040 --> 01:10:49,780
如果权限检查不起作用。

1169
01:10:49,930 --> 01:10:55,810
所以这些预测指令不能看到被禁止的数据。

1170
01:10:57,120 --> 01:11:00,000
我不知道你是否知道这个问题的答案，

1171
01:11:00,000 --> 01:11:04,800
可能只是推测，但并不是有意的，

1172
01:11:04,830 --> 01:11:07,710
但是为什么你认为 Intel 会这么做，

1173
01:11:07,740 --> 01:11:08,820
这看起来像是。

1174
01:11:09,120 --> 01:11:09,720
好的。

1175
01:11:09,930 --> 01:11:12,210
因为在我看来，这似乎是一场讨论，

1176
01:11:12,210 --> 01:11:15,030
我们应该检查临时指令的权限吗，

1177
01:11:15,030 --> 01:11:18,990
他们只是想，为什么麻烦只需要一个简单的检查。

1178
01:11:19,740 --> 01:11:20,610
为什么，

1179
01:11:20,790 --> 01:11:24,420
用户无法以任何一种方式查看数据，

1180
01:11:24,660 --> 01:11:26,220
通过早期检查。

1181
01:11:26,540 --> 01:11:30,290
这就像是一条非常关键的路径上的门，

1182
01:11:30,290 --> 01:11:34,830
L1 数据缓存的核心，

1183
01:11:35,340 --> 01:11:37,770
路径对性能极为关键，

1184
01:11:38,010 --> 01:11:40,890
如果你能减少几个晶体管，

1185
01:11:42,200 --> 01:11:43,910
从关键路径上减少，

1186
01:11:43,910 --> 01:11:46,640
在发出指令和取回数据之间，

1187
01:11:46,880 --> 01:11:50,270
这可能会让你拥有稍微快一点的周期时间，

1188
01:11:50,270 --> 01:11:51,770
并更快地运行程序。

1189
01:11:53,820 --> 01:11:55,080
所以一定是这样的，

1190
01:11:55,080 --> 01:11:56,640
我不知道一定是这样的，

1191
01:11:56,640 --> 01:11:58,920
但不难想象，

1192
01:11:58,920 --> 01:12:01,110
会花费几个晶体管，

1193
01:12:01,380 --> 01:12:04,320
来提前检查权限，

1194
01:12:04,650 --> 01:12:08,310
因为退出后，他们仍然需要所有的东西，

1195
01:12:08,490 --> 01:12:11,880
这并不是说早做就能省去他们以后的一些工作，

1196
01:12:12,030 --> 01:12:15,210
他们仍然必须将错误推迟到退出。

1197
01:12:17,400 --> 01:12:18,750
所以所有的东西，还在那里，

1198
01:12:19,750 --> 01:12:23,860
我只是猜测，这看起来不会有什么好处，

1199
01:12:23,860 --> 01:12:26,620
而且会有一点额外的工作。

1200
01:12:30,000 --> 01:12:32,460
以及进入任何一种完全不可见的方式，

1201
01:12:33,030 --> 01:12:35,790
在架构层面上，理论上也是不可见的。

1202
01:12:36,390 --> 01:12:41,700
是否有内核决定恢复 KASLR 修复程序，

1203
01:12:41,700 --> 01:12:44,820
现在 Intel 已经修复了 CPU ，

1204
01:12:44,910 --> 01:12:47,250
来再次提高性能。

1205
01:12:47,430 --> 01:12:49,200
我知道很多内核都是可选的，

1206
01:12:49,290 --> 01:12:55,750
我不太清楚 Intel 的修复是怎么回事，

1207
01:12:55,870 --> 01:12:57,970
我肯定他们已经有了解决办法，

1208
01:12:57,970 --> 01:13:02,750
但确切地说，我不知道发生了什么。

1209
01:13:03,140 --> 01:13:04,220
我认为在 Linux 内核中，

1210
01:13:04,220 --> 01:13:07,370
你可以直接问哪些硬件实现了修复，

1211
01:13:07,370 --> 01:13:11,360
Linux 会修改启用[缓解]，

1212
01:13:11,360 --> 01:13:13,280
根据硬件告诉它的。

1213
01:13:14,840 --> 01:13:15,410
也有可能。

1214
01:13:15,410 --> 01:13:18,140
所以你可以这么做，

1215
01:13:18,140 --> 01:13:21,170
你可以读取足够的关于处理器的信息，

1216
01:13:21,260 --> 01:13:23,750
内核知道如何去做。

1217
01:13:23,990 --> 01:13:25,940
你可以运行你的笔记本电脑，

1218
01:13:25,940 --> 01:13:26,750
有一个 Linux 命令，

1219
01:13:26,750 --> 01:13:31,420
它会告诉你，

1220
01:13:31,420 --> 01:13:34,990
在硬件中实施了哪些修复，

1221
01:13:36,040 --> 01:13:39,550
这是范围很广的各自的应用程序攻击。

1222
01:13:40,380 --> 01:13:43,170
你是说 Linux 会使用组合页表，

1223
01:13:43,170 --> 01:13:44,220
如果 CPU 。

1224
01:13:45,360 --> 01:13:45,900
好的。

1225
01:13:51,020 --> 01:13:52,940
我想， 99% 确认，

1226
01:13:52,940 --> 01:13:54,200
我最近没有检查过，

1227
01:13:54,230 --> 01:13:56,450
我相信情况仍是如此。

1228
01:14:04,040 --> 01:14:06,080
抱歉，那么人们是怎么做的，

1229
01:14:06,110 --> 01:14:08,840
比如他们是怎么找到这个的，

1230
01:14:08,990 --> 01:14:10,820
他们想要做什么。

1231
01:14:11,180 --> 01:14:12,560
他们想做什么，

1232
01:14:12,860 --> 01:14:14,480
试图闯入计算机。

1233
01:14:14,900 --> 01:14:20,980
谁知道他们实际想做什么，

1234
01:14:21,040 --> 01:14:25,570
我的意思是这些论文是由不同的学者撰写的，

1235
01:14:25,570 --> 01:14:32,300
也许他们的研究发现了安全问题。

1236
01:14:32,390 --> 01:14:33,740
我认为更多的是，

1237
01:14:33,740 --> 01:14:36,020
人们很长时间以来的动机是，

1238
01:14:36,020 --> 01:14:38,990
他们想要打破地址空间的随机化。

1239
01:14:40,020 --> 01:14:41,670
他们有更早的论文，

1240
01:14:41,670 --> 01:14:45,000
使用不同的方案试图打破地址随机化，

1241
01:14:45,000 --> 01:14:47,700
所以，有一组的研究人员

1242
01:14:47,700 --> 01:14:50,280
在这个领域，有这方面的背景。

1243
01:14:50,860 --> 01:14:54,400
我认为 project zero 是从一个完全不同的角度来的。

1244
01:15:00,170 --> 01:15:02,840
这是，像 Robert 之前说过的，

1245
01:15:02,840 --> 01:15:04,850
人们在这个领域已经工作了几十年，

1246
01:15:04,850 --> 01:15:11,610
试着找出漏洞，他们可以利用并理解。

1247
01:15:17,160 --> 01:15:20,730
所以，我想这是一个很难回答的问题，

1248
01:15:20,730 --> 01:15:27,100
但有多大可能会发生另一起类似的 meltdown 事件，

1249
01:15:27,100 --> 01:15:27,790
因为看起来。

1250
01:15:27,790 --> 01:15:29,380
极有可能。

1251
01:15:29,560 --> 01:15:30,160
好的，

1252
01:15:30,790 --> 01:15:35,530
从根本上讲，微架构变化。

1253
01:15:37,040 --> 01:15:39,920
是的，我想事情是这样的，

1254
01:15:39,920 --> 01:15:44,840
CPU 厂商几十年来一直是，

1255
01:15:45,490 --> 01:15:49,600
会加上越来越多的[乐观的]，

1256
01:15:49,600 --> 01:15:52,750
有许多很酷的小技巧，

1257
01:15:52,750 --> 01:15:56,050
在微架构中，让事情进行得更快，

1258
01:15:56,290 --> 01:16:02,050
人们并不太担心，

1259
01:16:02,050 --> 01:16:03,580
或者只是没有引起注意，

1260
01:16:03,580 --> 01:16:06,880
这可能是一个严重的安全问题，

1261
01:16:07,330 --> 01:16:09,820
所以现在人们非常意识到，

1262
01:16:09,820 --> 01:16:11,710
这可能是一个严重的安全问题，

1263
01:16:11,740 --> 01:16:13,840
但我们现在所处的位置是，

1264
01:16:13,840 --> 01:16:18,280
在 CPU 内部 30 年来的聪明想法中。

1265
01:16:18,640 --> 01:16:20,770
所以，很多，

1266
01:16:21,040 --> 01:16:22,450
自从这篇论文发表以来，

1267
01:16:22,450 --> 01:16:23,950
在这篇论文发表之前，

1268
01:16:24,100 --> 01:16:25,300
一大堆，

1269
01:16:25,510 --> 01:16:30,310
这种类型的攻击已经曝光，

1270
01:16:30,490 --> 01:16:38,110
各种不同的微结构 CPU ，

1271
01:16:38,230 --> 01:16:40,330
所以我认为一段时间，

1272
01:16:40,330 --> 01:16:42,490
在[稳定]之前。

1273
01:16:42,760 --> 01:16:45,580
在过去的两年里，我们看过安全会议，

1274
01:16:45,580 --> 01:16:48,730
基本上每年的会议

1275
01:16:48,730 --> 01:16:53,370
都是关于利用预测执行属性，

1276
01:16:53,460 --> 01:16:56,220
看看他们是否会发动攻击。

1277
01:16:57,210 --> 01:16:59,460
也许一个更大的问题是，

1278
01:17:00,240 --> 01:17:01,800
情况是不是，

1279
01:17:01,830 --> 01:17:06,390
有 15 、 20 或 30 件事情，

1280
01:17:06,390 --> 01:17:08,700
需要解决，

1281
01:17:08,700 --> 01:17:10,380
然后我们完成了，

1282
01:17:11,470 --> 01:17:20,330
或者有更高层次的方法出了问题，

1283
01:17:20,360 --> 01:17:21,590
你知道我们所有，

1284
01:17:22,260 --> 01:17:23,970
这可能太悲观了，

1285
01:17:23,970 --> 01:17:27,510
但人们对隔离作为一种想法很有信心，

1286
01:17:27,510 --> 01:17:29,460
有一件完全合理的事情要做，

1287
01:17:30,900 --> 01:17:33,450
假设隔离起作用，并将设计一些东西，

1288
01:17:33,450 --> 01:17:37,530
比如云计算和在浏览器中运行 Javascript ，

1289
01:17:37,530 --> 01:17:38,970
以及所有这些假设下的东西，

1290
01:17:39,000 --> 01:17:40,440
这可能不是真的，

1291
01:17:40,440 --> 01:17:43,020
但它被认为是足够接近真实的，

1292
01:17:43,260 --> 01:17:47,520
这种隔离导致它们不会成为严重的安全问题，

1293
01:17:47,850 --> 01:17:50,690
这实际上可能还是可行的，

1294
01:17:50,900 --> 01:17:55,540
但可以肯定的是，这个微架构攻击

1295
01:17:56,390 --> 01:17:59,750
并没有让这个故事看起来更有说服力。

1296
01:18:02,400 --> 01:18:04,020
更进一步的，

1297
01:18:04,410 --> 01:18:09,630
我不确定 [] CPU 设计，

1298
01:18:09,630 --> 01:18:18,210
但是，能不能直接扩展 CPU ，在没有微体系结构的情况下，

1299
01:18:18,390 --> 01:18:21,810
仍然保持它的高性能。

1300
01:18:21,990 --> 01:18:25,240
性能，我是说，人们相信这些东西。

1301
01:18:25,480 --> 01:18:27,970
安全也不错，不过是的。

1302
01:18:28,060 --> 01:18:29,620
有些事情很明显是可以修复的，

1303
01:18:29,620 --> 01:18:30,670
比如这个 meltdown 事件，

1304
01:18:30,670 --> 01:18:34,780
我的意思是有一个修复，你可以检查权限，

1305
01:18:35,230 --> 01:18:39,010
可能不会损失任何性能，

1306
01:18:39,220 --> 01:18:40,870
对于已经出现的其他一些攻击，

1307
01:18:43,590 --> 01:18:46,710
还不清楚你可以在不损失性能的情况下修复它们，

1308
01:18:46,770 --> 01:18:48,090
我是说一些非常深的东西，

1309
01:18:48,090 --> 01:18:49,860
就像我们分享的事实，

1310
01:18:50,130 --> 01:18:53,870
这里有很多分享，

1311
01:18:53,870 --> 01:18:55,850
比如云环境中的时间共享，

1312
01:18:55,850 --> 01:18:57,050
有很多共享，

1313
01:18:57,290 --> 01:19:06,890
比如，假设你的云服务器上有一个磁盘驱动器或网络，

1314
01:19:07,400 --> 01:19:11,240
你也许能得到云服务器上其他人的信息，

1315
01:19:11,450 --> 01:19:13,880
只需观察它们的流量，

1316
01:19:13,880 --> 01:19:18,140
干扰你的磁盘流量、网络流量或内存流量等。

1317
01:19:18,290 --> 01:19:19,460
所以有一种，

1318
01:19:20,240 --> 01:19:20,990
我不知道，

1319
01:19:20,990 --> 01:19:21,770
但这是实际的，

1320
01:19:21,770 --> 01:19:24,890
也许很多事情，

1321
01:19:24,890 --> 01:19:25,940
人们在这些事情中说，

1322
01:19:25,940 --> 01:19:27,590
攻击可能是不实际的，

1323
01:19:27,920 --> 01:19:30,540
事实证明它很实用。

1324
01:19:32,170 --> 01:19:33,460
我认为。

1325
01:19:34,690 --> 01:19:36,790
所以很多这种微架构的东西，

1326
01:19:36,790 --> 01:19:38,860
也许可以在不降低性能的情况下进行清理，

1327
01:19:38,860 --> 01:19:41,050
或者可能无法在不损失性能的情况下进行清理，

1328
01:19:41,350 --> 01:19:42,730
但我认为，

1329
01:19:43,750 --> 01:19:48,450
我认为这是一个比我们实施修复更严重的问题，

1330
01:19:50,260 --> 01:19:51,130
他们会消失的。

1331
01:19:52,650 --> 01:19:55,710
而最尖锐的地方是密码学，

1332
01:19:55,950 --> 01:19:58,350
已经有很多年，

1333
01:19:58,880 --> 01:20:01,220
人们在研究这种聪明，

1334
01:20:02,210 --> 01:20:10,440
通常缓存基于分时的密钥位，

1335
01:20:10,440 --> 01:20:12,510
和其他人的密码，

1336
01:20:12,930 --> 01:20:17,100
人们在同一台机器上运行密码学加密，

1337
01:20:17,580 --> 01:20:20,250
你能猜出我的密钥吗，

1338
01:20:20,250 --> 01:20:24,130
通过观察，通过进行缓存计时，

1339
01:20:24,490 --> 01:20:25,810
答案是绝对的。

1340
01:20:26,530 --> 01:20:29,140
而且它不是微架构的 bug ，

1341
01:20:32,010 --> 01:20:34,950
它是经常分享的结果。

1342
01:20:35,620 --> 01:20:37,210
不管怎么说，我不知道这件事会怎样发展，

1343
01:20:37,210 --> 01:20:38,800
这不是直截了当的。

1344
01:20:40,610 --> 01:20:42,230
我好奇的是，

1345
01:20:42,230 --> 01:20:44,480
当人们取得进展的时候，

1346
01:20:44,810 --> 01:20:49,880
只需测量 CPU 的电磁辐射，

1347
01:20:49,880 --> 01:20:53,000
并找出正在运行的指令和其中包含的数据，

1348
01:20:53,270 --> 01:20:55,910
使用机器学习有一定的精确度，

1349
01:20:55,910 --> 01:20:58,100
不是百分之百，不是很近，

1350
01:20:58,100 --> 01:21:01,100
但精确度高得吓人，

1351
01:21:01,100 --> 01:21:02,870
因为任何超过零的东西都是可怕的。

1352
01:21:07,840 --> 01:21:09,940
是的，我们知道，

1353
01:21:12,180 --> 01:21:14,970
好的，攻击有界限的，

1354
01:21:17,430 --> 01:21:20,520
在可能的攻击之间有一定的门槛，

1355
01:21:20,520 --> 01:21:23,760
但是，这看起来太贵了，

1356
01:21:23,760 --> 01:21:27,150
或者太痛苦，不管什么复杂的东西都不能实施。

1357
01:21:28,270 --> 01:21:31,220
而且，攻击真的可能会发生，

1358
01:21:31,220 --> 01:21:33,260
当然我们应该只防御第二类，

1359
01:21:33,260 --> 01:21:36,230
因为第一类通常太贵了，无法防御，

1360
01:21:36,620 --> 01:21:40,430
但随着包含计算机的东西的价值变得越来越大，

1361
01:21:40,430 --> 01:21:46,220
攻击者变得更聪明，更接近共享环境，

1362
01:21:47,000 --> 01:21:53,590
攻击足够可行以防御变化的一种阈值。

1363
01:21:58,610 --> 01:22:03,080
好了，我的课讲完了，

1364
01:22:03,080 --> 01:22:06,110
如果有问题的话，我很乐意回答更多的问题。

1365
01:22:09,210 --> 01:22:09,930
谢谢。

1366
01:22:11,280 --> 01:22:11,880
谢谢。

1367
01:22:12,750 --> 01:22:15,360
谢谢，我有个关于缓存的问题，

1368
01:22:15,600 --> 01:22:21,090
L1 缓存是每个 CPU 的。

1369
01:22:21,930 --> 01:22:22,530
是的。

1370
01:22:23,430 --> 01:22:25,080
而 L2 不是共享的。

1371
01:22:25,260 --> 01:22:28,980
那么这张图对于每个 CPU 来说是不一样的，

1372
01:22:28,980 --> 01:22:31,680
对于不同型号的 CPU 是不一样的，

1373
01:22:31,740 --> 01:22:35,870
今天的习惯是，

1374
01:22:35,900 --> 01:22:40,040
看起来比这个要复杂一点，

1375
01:22:40,160 --> 01:22:42,080
通常是多核，

1376
01:22:43,170 --> 01:22:46,230
2 4 8 或 64 等，

1377
01:22:46,980 --> 01:22:48,990
每一个都有一个 L1 缓存，

1378
01:22:48,990 --> 01:22:50,700
它离 CPU 很近，

1379
01:22:50,700 --> 01:22:52,830
但它又快又小，

1380
01:22:53,130 --> 01:22:55,620
每个核心通常还有更大的 L2 缓存，

1381
01:22:55,620 --> 01:23:01,310
它是专为那个 CPU 设计的。

1382
01:23:04,150 --> 01:23:12,930
然后，通常会有一个共享的 L3 缓存，

1383
01:23:13,170 --> 01:23:14,580
通常但不总是，

1384
01:23:14,760 --> 01:23:18,710
另一种方法是使 L2 缓存的总和

1385
01:23:18,710 --> 01:23:22,430
在某种程度上方便所有 CPU 使用，

1386
01:23:22,430 --> 01:23:25,280
这样我可以超高速访问 L2 缓存，

1387
01:23:25,280 --> 01:23:28,850
但是我可以得到其他人稍微重一点的[处罚]，

1388
01:23:28,850 --> 01:23:30,650
有效缓存大小越大，

1389
01:23:30,740 --> 01:23:33,440
所以，通常可以看到三级缓存，

1390
01:23:33,440 --> 01:23:37,850
或者是一种连接到二级缓存的缓存。

1391
01:23:41,000 --> 01:23:45,160
通常 L2 和 L3 是物理寻址的， L1 是虚拟的。

1392
01:23:47,980 --> 01:23:54,830
抱歉，有实际地址有什么意义。

1393
01:23:54,830 --> 01:23:59,810
是的，这很简单， L1 缓存中的东西是虚拟地址缓存。

1394
01:24:02,220 --> 01:24:05,850
如果相同的数据使用不同的虚拟地址，

1395
01:24:05,850 --> 01:24:09,510
虚拟地址缓存不会帮你找到它，

1396
01:24:10,060 --> 01:24:13,660
如果这些 L2 缓存在不同地址下，

1397
01:24:13,660 --> 01:24:14,920
则数据是独立的，

1398
01:24:15,130 --> 01:24:18,880
无论你的地址是什么虚拟地址。

1399
01:24:22,380 --> 01:24:24,330
MMU 在哪里使用，

1400
01:24:24,330 --> 01:24:27,180
它相对于 TLB 中的所有这些缓存。

1401
01:24:27,210 --> 01:24:30,180
哦，它不是，它是分布的，

1402
01:24:30,180 --> 01:24:33,570
我的意思是，最明显的，

1403
01:24:34,530 --> 01:24:37,500
我认为在现实生活中，

1404
01:24:38,930 --> 01:24:42,050
TLB 最关键的是，

1405
01:24:42,050 --> 01:24:45,200
我认为它通常与 L1 缓存并行索引。

1406
01:24:46,300 --> 01:24:47,710
所以如果你命中缓存，

1407
01:24:47,920 --> 01:24:50,350
L1 缓存，尽管可能会有。

1408
01:24:52,740 --> 01:24:54,300
不管怎样，如果你错过了 L1 缓存，

1409
01:24:54,300 --> 01:24:56,220
那么现在你有物理的，

1410
01:24:56,220 --> 01:24:57,990
你同时在 TLB 中查找，

1411
01:24:57,990 --> 01:25:00,000
现在物理可以寻址了，

1412
01:25:01,550 --> 01:25:05,690
MMU 不只是一个放在某个地方的盒子，

1413
01:25:05,690 --> 01:25:08,350
它有点[牵涉其中]。

1414
01:25:09,890 --> 01:25:12,080
好的，但这不是硬件吗，所以。

1415
01:25:12,230 --> 01:25:13,730
哦，一切都是硬件，是的。

1416
01:25:15,530 --> 01:25:20,480
但请记住，这些芯片上有数十亿个晶体管，

1417
01:25:20,630 --> 01:25:22,610
所以，是的，也许是硬件问题，

1418
01:25:22,610 --> 01:25:26,900
但我们谈论的是非常复杂的硬件，

1419
01:25:27,140 --> 01:25:31,700
它是使用非常复杂的软件设计，

1420
01:25:31,730 --> 01:25:36,150
所以它可以做非常复杂的事情，

1421
01:25:36,510 --> 01:25:37,410
所以，它是硬件，

1422
01:25:37,410 --> 01:25:41,660
但是，它一点也不简单。

1423
01:25:43,320 --> 01:25:49,800
表映射是否像页表映射一样最终会出现在缓存中，

1424
01:25:49,800 --> 01:25:52,260
或者它们总是通过 TLB 路由，

1425
01:25:52,290 --> 01:25:53,400
因为如果你错过了，

1426
01:25:53,400 --> 01:25:55,890
TLB 你必须去内存检索。

1427
01:25:55,890 --> 01:25:59,640
对，所以它们肯定是 L2 缓存可以保存的，

1428
01:26:00,790 --> 01:26:02,770
从 L2 缓存的角度来看，

1429
01:26:03,190 --> 01:26:07,070
TLB 未命中、 TLB 重新加载只是内存访问，

1430
01:26:07,070 --> 01:26:09,560
所以 TLB 需要加载一堆页表垃圾文件，

1431
01:26:09,860 --> 01:26:11,240
这只是一个内存加载，

1432
01:26:11,240 --> 01:26:13,970
可以很容易地将内容缓存到 L2 中。

1433
01:26:13,970 --> 01:26:15,140
但它必须跳到 L1 ，

1434
01:26:15,140 --> 01:26:17,180
因为 L1 有虚拟地址，但是。

1435
01:26:17,180 --> 01:26:21,200
我不认为 TLB 会查询 L1 。

1436
01:26:21,200 --> 01:26:21,560
好的。

1437
01:26:22,510 --> 01:26:24,700
因为它是虚拟地址。

1438
01:26:25,980 --> 01:26:29,070
然后是一件关于 spectre 攻击的事。

1439
01:26:30,110 --> 01:26:32,510
你怎么会，

1440
01:26:32,540 --> 01:26:37,190
我至少听说过十几次 meltdown 检查，

1441
01:26:37,190 --> 01:26:39,710
每次我看的时候都不明白，

1442
01:26:39,710 --> 01:26:42,230
所以这是我第一次真正明白发生了什么，

1443
01:26:42,410 --> 01:26:44,030
但是对于 spectre ，

1444
01:26:44,150 --> 01:26:47,970
它与 meltdown 有多么相似？

1445
01:26:47,970 --> 01:26:48,600
不是。

1446
01:26:48,840 --> 01:26:50,430
不是，好的。

1447
01:26:52,230 --> 01:26:53,970
或者，他们会，

1448
01:26:55,560 --> 01:26:59,700
我对 spectre 攻击的理解是，通过训练分支预测器，

1449
01:26:59,730 --> 01:27:05,880
另一个你想要攻击的代码。

1450
01:27:05,910 --> 01:27:11,060
让我们假设另一个进程，你和它共享一些内存。

1451
01:27:11,060 --> 01:27:14,180
因为它和你运行一样的程序，

1452
01:27:14,180 --> 01:27:17,090
但运行该程序的是其他用户。

1453
01:27:18,040 --> 01:27:29,920
分支预测器使用的表共享在不同的，

1454
01:27:29,920 --> 01:27:31,420
如果我运行 CPU ，

1455
01:27:31,420 --> 01:27:34,390
可能在同一 CPU 的不同超线程上运行，

1456
01:27:34,390 --> 01:27:37,990
每个人都看到相同的分支预测器，

1457
01:27:38,020 --> 01:27:41,350
所以我可以训练分支预测器以某种方式预测分支，

1458
01:27:41,590 --> 01:27:42,970
然后我会让你运行，

1459
01:27:44,230 --> 01:27:47,890
你在运行我训练的分支预测器。

1460
01:27:47,890 --> 01:27:50,470
这意味着我可以欺骗你的程序，

1461
01:27:50,470 --> 01:27:53,980
让它预测执行我选择的指令。

1462
01:27:54,790 --> 01:27:55,840
对，现在只是推测，

1463
01:27:55,840 --> 01:27:56,830
所以它们当然会被撤销，

1464
01:27:56,830 --> 01:28:00,370
但是它们会导致缓存加载，

1465
01:28:00,880 --> 01:28:03,580
在某种程度上我可以控制。

1466
01:28:04,180 --> 01:28:05,920
因为我控制着预测执行，

1467
01:28:05,920 --> 01:28:07,000
如果我们共享内存，

1468
01:28:07,000 --> 01:28:09,340
我可以使用刷新并重新加载来检测

1469
01:28:09,930 --> 01:28:13,890
你的程序加载了预测执行的哪个缓存行。

1470
01:28:15,390 --> 01:28:16,890
哦，那样的话，

1471
01:28:16,890 --> 01:28:20,130
你不需要，

1472
01:28:20,130 --> 01:28:24,750
比如直接寻址一块内存，

1473
01:28:24,750 --> 01:28:28,590
你只需要确保程序被预测执行，

1474
01:28:28,740 --> 01:28:31,020
而在 meltdown 中，我们自己做的，

1475
01:28:31,020 --> 01:28:34,200
但在 spectre 中，直接到那里，

1476
01:28:34,590 --> 01:28:35,340
这有点酷，

1477
01:28:35,370 --> 01:28:36,090
因为你可以，

1478
01:28:36,090 --> 01:28:40,080
只要通过训练分支预测器来加载这个秘密，

1479
01:28:40,080 --> 01:28:41,610
而不需要知道秘密在哪里，

1480
01:28:42,300 --> 01:28:43,650
你知道某些，

1481
01:28:43,740 --> 01:28:45,510
你一定要知道。

1482
01:28:45,510 --> 01:28:47,160
你需要知道非常详细的情况。

1483
01:28:47,160 --> 01:28:49,170
是的，抱歉，你得知道。

1484
01:28:49,350 --> 01:28:51,030
但是你必须自己。

1485
01:28:51,060 --> 01:28:51,390
是的。

1486
01:28:51,390 --> 01:28:52,200
这不是秘密，

1487
01:28:52,200 --> 01:28:53,580
你可能在运行一个程序，

1488
01:28:54,000 --> 01:28:55,140
我知道你在运行什么程序。

1489
01:28:55,140 --> 01:28:59,380
好的，理解了，谢谢。

1490
01:29:01,700 --> 01:29:02,990
是的，我只是在想，

1491
01:29:02,990 --> 01:29:06,830
当像这样的一篇研究论文发表的时候，

1492
01:29:06,830 --> 01:29:09,200
给到人们，

1493
01:29:09,200 --> 01:29:12,200
Linux 和 Windows 以及 Intel 的人

1494
01:29:12,200 --> 01:29:14,750
都在争先恐后地修补这个漏洞，

1495
01:29:14,750 --> 01:29:17,900
但是黑客也可以从这篇论文中学到东西，

1496
01:29:17,900 --> 01:29:19,640
哦，这是一种我们可以使用的方法，

1497
01:29:20,190 --> 01:29:22,740
我在想，

1498
01:29:22,740 --> 01:29:25,470
作为一名研究人员，有没有一种普遍的做法，

1499
01:29:25,470 --> 01:29:27,510
我们正在写的论文

1500
01:29:27,510 --> 01:29:31,170
会先给好人，

1501
01:29:31,170 --> 01:29:32,040
这样他们就可以。

1502
01:29:32,040 --> 01:29:37,380
是的，作者先通知每一个 CPU 制造商和操作系统制造商。

1503
01:29:37,380 --> 01:29:38,550
在发表论文之前。

1504
01:29:39,030 --> 01:29:40,830
有一个完整的协议，

1505
01:29:41,460 --> 01:29:44,520
这类事情会被接受，

1506
01:29:44,520 --> 01:29:46,020
除非你遵守协议。

1507
01:29:46,650 --> 01:29:48,660
这并不意味着袭击者没有使用它，

1508
01:29:48,660 --> 01:29:52,650
因为可能攻击者在 20 年前发现了这个，但是。

1509
01:29:53,070 --> 01:29:56,430
好的，谢谢。

1510
01:29:57,480 --> 01:29:59,280
这不是直截了当的，

1511
01:29:59,370 --> 01:30:00,810
我认为在这个特殊的情况下，

1512
01:30:00,810 --> 01:30:04,290
我想 Intel 不太感兴趣，

1513
01:30:05,020 --> 01:30:08,530
Linux 社区和 Intel 之间的合作并不完全顺利。

1514
01:30:10,940 --> 01:30:11,870
当这种情况发生时，

1515
01:30:12,530 --> 01:30:14,690
我认为他们在做一些工作，但是。

1516
01:30:18,670 --> 01:30:19,990
我觉得有点吓人，

1517
01:30:19,990 --> 01:30:22,600
因为我在维基百科上看到，

1518
01:30:22,600 --> 01:30:28,570
Ubuntu 补丁是在论文发表后发布的，

1519
01:30:28,600 --> 01:30:31,030
我觉得很可怕，但是。

1520
01:30:38,120 --> 01:30:40,490
非常感谢。

1521
01:30:42,240 --> 01:30:42,960
谢谢。

1522
01:30:43,170 --> 01:30:45,660
谢谢，我们下周见。

