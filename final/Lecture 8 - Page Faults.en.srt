1
00:00:12,310 --> 00:00:15,310
Okay, okay, we get a sound check, can everybody hear me?

2
00:00:18,980 --> 00:00:19,490
Yep.

3
00:00:19,880 --> 00:00:23,840
Okay, good, whatever, let's going.

4
00:00:23,840 --> 00:00:29,570
Good afternoon, or good evening or good morning or good night, wherever you are.

5
00:00:30,110 --> 00:00:33,950
Today's lecture, I'm going to be, about page fault.

6
00:00:34,780 --> 00:00:40,210
In particular, we're gonna plan is to,

7
00:00:41,930 --> 00:00:55,100
cover implement, implemented number of virtual memory features, using page faults.

8
00:01:03,680 --> 00:01:09,050
And the features that we're gonna be looking at are lazy allocation,

9
00:01:09,760 --> 00:01:11,890
which is the topic of the next lab.

10
00:01:14,950 --> 00:01:29,950
Yeah, we're gonna look at demand, copy-and-write fork, demand paging, and memory map files, mmap.

11
00:01:32,540 --> 00:01:34,370
And, um.

12
00:01:35,080 --> 00:01:40,060
And almost you know in sort of [] operating system actually implements all these features,

13
00:01:40,930 --> 00:01:44,950
look inside of Linux, you'll see all these features actually are implemented.

14
00:01:45,160 --> 00:01:48,340
In xv6, as it stands none of them are implemented.

15
00:01:49,340 --> 00:01:52,880
In fact, what page fault does in xv6,

16
00:01:52,880 --> 00:01:57,380
if page fault happens in user space, basically kill the process, whatever [interesting].

17
00:01:57,920 --> 00:02:00,050
And so in this lecture, we're going to explore

18
00:02:00,050 --> 00:02:04,940
what interesting things, you could do in the page fault handler to actually implement these features.

19
00:02:05,270 --> 00:02:12,290
So this lecture a little bit less walking through code and understanding existing code, a little bit more design level.

20
00:02:12,410 --> 00:02:15,260
In the sense, we don't even have code to look at.

21
00:02:16,130 --> 00:02:18,950
Another thing that's important to mention is lazy allocation,

22
00:02:18,950 --> 00:02:20,180
is topic of the next lab,

23
00:02:20,450 --> 00:02:21,950
hopefully it will push out today.

24
00:02:22,100 --> 00:02:27,500
And copy-on-write fork, it's gonna be a topic of one of the labs

25
00:02:27,620 --> 00:02:32,030
and mmap is going to be another topic of one of the subsequent labs.

26
00:02:32,500 --> 00:02:36,370
So this is gonna be one of the interesting parts of an operating system,

27
00:02:36,460 --> 00:02:39,280
we're gonna be spending quite a bit of time on these labs.

28
00:02:41,110 --> 00:02:44,680
Now, you know before diving into details,

29
00:02:44,680 --> 00:02:50,200
it is probably helpful to take a little bit of step back

30
00:02:50,230 --> 00:02:56,320
and so you can think about virtual memory having two major benefits.

31
00:03:02,370 --> 00:03:07,330
One is isolation, so isolation in the sense that,

32
00:03:07,540 --> 00:03:12,100
virtual memory allows the operating system to give every application it's own address space,

33
00:03:12,160 --> 00:03:20,650
and so it's impossible for one application to, or by accidental or maliciously to modify another application address space.

34
00:03:21,080 --> 00:03:25,550
It also provides isolation between user and kernel address space as we talk about quite a bit

35
00:03:25,730 --> 00:03:27,830
and as you've seen in the page table lab.

36
00:03:28,570 --> 00:03:34,480
But sort of another view or another benefit of virtual memory,

37
00:03:34,480 --> 00:03:36,850
you know alluded to a couple times earlier

38
00:03:37,150 --> 00:03:39,940
is that it provides a level of indirection,

39
00:03:47,340 --> 00:03:50,910
you know, the processor instructions, you know only use virtual addresses,

40
00:03:51,680 --> 00:03:57,410
but the kernel gets to sort of define the mapping from virtual addresses to physical addresses,

41
00:03:58,800 --> 00:04:05,720
and that allows all kinds of interesting -, interesting features,

42
00:04:05,720 --> 00:04:09,140
like the ones we're gonna be talking about in this lecture.

43
00:04:10,910 --> 00:04:13,180
The. Second.

44
00:04:18,200 --> 00:04:19,400
And the.

45
00:04:24,280 --> 00:04:30,400
The kernel controls this particular mapping from virtual to physical address space

46
00:04:30,490 --> 00:04:34,090
and most so far in xv6, that mapping has to be quite boring,

47
00:04:34,960 --> 00:04:37,270
in fact the kernel is mostly direct mapping

48
00:04:37,450 --> 00:04:41,920
and a couple of interesting things that we do, xv6 does,

49
00:04:41,950 --> 00:04:45,160
which is mapping one as we've seen, the trampoline page,

50
00:04:46,330 --> 00:04:50,650
allowed kernel map one page into many address spaces,

51
00:04:50,770 --> 00:04:55,210
another interesting case that we've seen is the guard page,

52
00:04:55,750 --> 00:05:02,020
to protect stack, both in the kernel, in kernel space and user space and kernel space.

53
00:05:02,940 --> 00:05:04,350
But if you think about it,

54
00:05:04,350 --> 00:05:07,950
so far that mapping has been relatively static,

55
00:05:07,980 --> 00:05:13,290
you know we set it up once, you know maybe per user, kernel page table mapping,

56
00:05:13,290 --> 00:05:17,310
setup once in the beginning and processes once at fork

57
00:05:17,370 --> 00:05:20,700
and they're sort of the kernel doesn't really do anything else with this mapping.

58
00:05:21,680 --> 00:05:27,050
And what page fault gives us is actually to make these maps dynamic.

59
00:05:27,440 --> 00:05:35,950
So using page faults, and we can change,

60
00:05:37,170 --> 00:05:47,050
the kernel can change the mapping, sort of dynamically on the fly.

61
00:05:47,080 --> 00:05:52,990
And this turns out to be extremely powerful mechanism,

62
00:05:52,990 --> 00:05:57,550
so you can combine page tables and page faults,

63
00:05:57,820 --> 00:06:02,500
you, have enormous, kernel has an enormous amount of flexibility.

64
00:06:03,000 --> 00:06:07,740
And the flexibility [comes down], because you can change the level of [direction] on the fly.

65
00:06:09,960 --> 00:06:12,210
And, so what we're going to be doing is basically

66
00:06:12,210 --> 00:06:20,460
looking at all kinds of usages of this dynamic re-mapping or dynamic changing of the page tables,

67
00:06:20,460 --> 00:06:22,530
that gives you interesting features.

68
00:06:24,770 --> 00:06:27,050
So the first thing, we may want to think about,

69
00:06:27,110 --> 00:06:30,860
is a little bit, is what information is needed,

70
00:06:30,890 --> 00:06:33,440
you know if here in a page fault happens,

71
00:06:34,740 --> 00:06:40,630
and, kernel wants to respond to this page fault,

72
00:06:40,630 --> 00:06:44,530
you know what information does it need to actually be able to respond.

73
00:06:45,270 --> 00:06:56,510
You know sort of quite you know obviously, we'd like to have the virtual address of, virtual address of faulting,

74
00:07:00,040 --> 00:07:01,600
where gonna cause page fault.

75
00:07:05,270 --> 00:07:11,390
Say you want to see this, the faulting virtual address.

76
00:07:15,440 --> 00:07:20,600
And you've seen presumably some of these panic calls in your page fault lab,

77
00:07:20,600 --> 00:07:23,450
and you know the kernel actually has extra [status],

78
00:07:23,450 --> 00:07:26,030
in fact that prints them out when we actually page fault happens

79
00:07:26,150 --> 00:07:31,790
and it happens to be sitting in the stval register.

80
00:07:35,530 --> 00:07:40,600
So when user application, causes a page fault,

81
00:07:40,840 --> 00:07:44,590
the page fault basically invokes the same trap machinery,

82
00:07:44,710 --> 00:07:46,810
that Robert discussed in the last lecture,

83
00:07:47,080 --> 00:07:48,730
it's almost completely identical,

84
00:07:48,910 --> 00:07:56,020
but in the case of page fault, it also will put the faulting address into that stval register.

85
00:07:57,370 --> 00:08:00,160
So that is, one thing that we probably want to know,

86
00:08:00,160 --> 00:08:03,160
the second thing that we probably want to know is the type of fault.

87
00:08:11,580 --> 00:08:13,920
Because it may be, in terms of,

88
00:08:13,920 --> 00:08:16,620
we may want to do respond different differently

89
00:08:16,620 --> 00:08:21,120
in terms of to page fault due to a load instruction

90
00:08:21,270 --> 00:08:23,820
or page fault due to a store instruction,

91
00:08:23,850 --> 00:08:26,370
or page fault due to a jump instruction.

92
00:08:26,880 --> 00:08:32,970
And, so in fact if you look at the RISC-V documentation.

93
00:08:33,930 --> 00:08:37,260
Here's the RISC-V documentation in here,

94
00:08:37,320 --> 00:08:41,550
in the scause, we that we was mentioning the trap lecture,

95
00:08:41,700 --> 00:08:49,780
there are, a member of causes that actually related to page faults,

96
00:08:49,990 --> 00:08:55,570
so yeah but if you look at number thirteen, it's a load page fault,

97
00:08:55,750 --> 00:08:58,360
number fifteen is a store page fault,

98
00:08:58,510 --> 00:09:00,880
and number twelve is an instruction page fault.

99
00:09:01,410 --> 00:09:06,030
So these are, in the scause register, then we get that information.

100
00:09:08,880 --> 00:09:14,950
And so there's three different types, you know read write and instruction.

101
00:09:16,820 --> 00:09:17,960
And just go back,

102
00:09:17,990 --> 00:09:25,040
you know the one scause, you know actually was caused by the [ecall] instruction,

103
00:09:25,040 --> 00:09:27,650
to actually the kernel transfer is number eight.

104
00:09:28,310 --> 00:09:31,370
Alright, so that's the one that we saw in the trap lecture,

105
00:09:31,370 --> 00:09:33,560
that we spend a lot of time thinking about in that trap lecture.

106
00:09:33,620 --> 00:09:36,500
But basically all the other page faults or exceptions

107
00:09:37,460 --> 00:09:43,130
use the same mechanism to transfer from user space to kernel space

108
00:09:43,460 --> 00:09:47,270
and once in kernel space, in the case of the page fault,

109
00:09:47,270 --> 00:09:50,900
the stval register set, scause register set.

110
00:09:52,060 --> 00:09:55,810
Then the third thing, that we probably want to know is

111
00:09:55,870 --> 00:10:07,150
the instruction or address the virtual address of instruction, that cause the page fault.

112
00:10:14,890 --> 00:10:16,570
And, you know, anybody remember

113
00:10:16,570 --> 00:10:21,610
where you know from the trap lecture, where the where the instruction is, where the addresses?

114
00:10:25,220 --> 00:10:25,880
Anybody?

115
00:10:26,560 --> 00:10:29,410
Is it sepc? Yeah exactly.

116
00:10:29,680 --> 00:10:35,620
And there's this register, sepc correct, the supervisor exception exception program counter,

117
00:10:35,740 --> 00:10:42,540
there is where it is and where is that saved as part of the trap handling code?

118
00:10:45,000 --> 00:10:45,930
In the trapframe?

119
00:10:46,140 --> 00:10:47,670
Yeah, there's in the trapframe correct,

120
00:10:47,670 --> 00:10:52,980
there's trapframe epc, actually has the exception program counter.

121
00:10:54,150 --> 00:10:57,180
So we think about the hardware mechanism actually what xv6 does,

122
00:10:57,270 --> 00:11:01,860
we have three pieces of information are probably extremely valuable to us, when we get actually page fault,

123
00:11:01,890 --> 00:11:06,480
namely the address of cause fault, the type of fault

124
00:11:06,750 --> 00:11:10,710
and the exception program counter like where did it happen to user space.

125
00:11:11,200 --> 00:11:13,930
And the reason we care a lot about the exception program counter is

126
00:11:13,930 --> 00:11:19,240
because when we probably want to repair, in the handler going to repair the pagetable

127
00:11:19,660 --> 00:11:22,090
and then we're gonna basically restart the same instruction

128
00:11:22,420 --> 00:11:26,950
and hopefully the after repairing the page fault or reparing the pagetables

129
00:11:26,980 --> 00:11:29,170
that instruction can just run without any trouble.

130
00:11:29,560 --> 00:11:35,200
And so it's important that we can be resume the instruction that actually that we cause fault.

131
00:11:38,370 --> 00:11:39,270
Is that all makes sense?

132
00:11:42,960 --> 00:11:46,020
Okay, so now I'm gonna look at,

133
00:11:46,140 --> 00:11:50,700
you know the basic mechanism and basic information that the RISC-V is actually giving us

134
00:11:51,000 --> 00:11:59,110
and I want to look at, basically go through a list of, you know features

135
00:11:59,170 --> 00:12:01,480
that will help us, you know we understand actually

136
00:12:01,480 --> 00:12:09,600
how we can use the page fault handler to repair the pagetable and do interesting things.

137
00:12:09,930 --> 00:12:19,610
So the first thing I want to look at is allocation, in particular, you know sbrk.

138
00:12:25,210 --> 00:12:29,020
So sbrk is the system call, that xv6 provides,

139
00:12:29,140 --> 00:12:33,880
that allows an application to basically grow grow its heap

140
00:12:34,150 --> 00:12:40,150
when the application starts sbrk points here,

141
00:12:41,470 --> 00:12:44,020
at the bottom of the heap, you know top of the stack,

142
00:12:44,410 --> 00:12:49,330
in fact it's the same place where you know p->sz basically you know points to.

143
00:12:50,200 --> 00:12:51,550
And so when sbrk called,

144
00:12:51,700 --> 00:12:54,610
for example, sbrk called, it's like one two three four five,

145
00:12:54,610 --> 00:12:56,950
you know the number of pages that you know you want to allocate,

146
00:12:57,250 --> 00:13:07,760
the sbrk system call basically bumps up you know this boundary, to something there.

147
00:13:08,350 --> 00:13:15,430
And that and so what, that means that when the sbrk actually happens or sbrk system call is called,

148
00:13:15,460 --> 00:13:22,750
the kernel allocation physical memory, map it into the address space of the user application,

149
00:13:23,050 --> 00:13:26,140
zero the memory and then basically return from the system call.

150
00:13:27,210 --> 00:13:35,280
And after time and the application can grow, you know that physical memory or memory that it needs

151
00:13:35,280 --> 00:13:39,450
or it might want by just calling multiple times to sbrk.

152
00:13:39,950 --> 00:13:45,500
The application also decrease or shrink its address space by calling sbrk with a negative number.

153
00:13:46,830 --> 00:13:50,490
But I want to focus on the case where we're growing the address space.

154
00:13:50,730 --> 00:13:57,060
And in xv6 as it is, the sbrk is eager

155
00:13:57,900 --> 00:14:00,210
or does what we're gonna call eager allocation,

156
00:14:03,650 --> 00:14:09,560
namely as soon as the sbrk called,

157
00:14:09,620 --> 00:14:14,690
the kernel will immediately allocate the physical memory that the application is asking for.

158
00:14:15,570 --> 00:14:17,190
And it turns out that in practice,

159
00:14:17,370 --> 00:14:21,740
it's actually hard for applications to predict, how much memory they need,

160
00:14:22,310 --> 00:14:30,030
so, typically applications tend to over ask,

161
00:14:36,600 --> 00:14:38,670
and so they ask a lot more than they really need,

162
00:14:38,910 --> 00:14:45,720
and often that means which means that basically you know the address space will grow quite a bit,

163
00:14:45,840 --> 00:14:48,930
even with memory does actually never used by the application.

164
00:14:49,530 --> 00:14:52,380
You might think that was stupid, how could that happen,

165
00:14:52,620 --> 00:14:55,710
well, you know, think about if you write an application program

166
00:14:55,710 --> 00:14:59,880
and the typical application program maybe reach an input

167
00:14:59,880 --> 00:15:03,780
or has a matrix that uses for some computation,

168
00:15:04,140 --> 00:15:08,100
and often the application writer sort of plans for the worst case,

169
00:15:08,130 --> 00:15:13,560
you know allocates memory for the biggest matrix, the application might never ever need.

170
00:15:13,980 --> 00:15:15,390
But in the common case,

171
00:15:15,510 --> 00:15:20,460
application maybe computes are much smaller input or a much smaller matrix

172
00:15:20,760 --> 00:15:25,260
and so it's quite common, in fact for application programmers

173
00:15:25,260 --> 00:15:27,780
and probably if you think about your own applications written

174
00:15:27,840 --> 00:15:31,260
to actually over ask and actually [own] their use.

175
00:15:32,100 --> 00:15:36,180
And we'd like to, principle, not a big problem,

176
00:15:36,180 --> 00:15:39,510
but you know using actually virtual memory and page fault handlers,

177
00:15:39,750 --> 00:15:46,410
we can actually totally totally responded at, in sort of an intelligent manner,

178
00:15:46,860 --> 00:15:50,250
and, by basically doing lazy allocation.

179
00:15:59,060 --> 00:16:01,550
And the basic idea is very simple,

180
00:16:01,700 --> 00:16:08,140
at sbrk, we're basically gonna do almost nothing,

181
00:16:08,350 --> 00:16:12,040
the only thing that we need to know, remember of course that we get grow address space,

182
00:16:12,040 --> 00:16:20,470
so the only thing we are going to be doing is actually bumping up you know p->sz, you know, whatever with the number,

183
00:16:21,690 --> 00:16:24,930
you know set p->sz to one of the new size plus you know n

184
00:16:24,930 --> 00:16:27,660
and you know what n is the amount of memory that's allocated.

185
00:16:28,600 --> 00:16:30,940
And then you know, that we don't allocate,

186
00:16:30,940 --> 00:16:33,580
the kernel doesn't allocate any physical memory at that particular point of time,

187
00:16:33,580 --> 00:16:35,440
it doesn't zero, there's absolutely nothing.

188
00:16:37,570 --> 00:16:40,930
Then, at some point the application will use or might use that memory, correct,

189
00:16:40,930 --> 00:16:43,630
if it is actually one of the pieces of memory that it really needs

190
00:16:43,870 --> 00:16:46,480
and that will cause a page fault.

191
00:16:47,360 --> 00:16:52,960
Because we didn't map, that memory actually into the page map yet,

192
00:16:53,350 --> 00:17:01,030
and so, if we do reference virtual address, you know above, you know, this p->sz, but below p->sz plus n,

193
00:17:01,180 --> 00:17:07,540
what we'd like to be happening is that you know the kernel allocate a page and restarts instruction.

194
00:17:08,190 --> 00:17:10,440
So, if we get a page fault

195
00:17:10,590 --> 00:17:22,240
and we see that the virtual address is bigger than p->sz, it's below, sorry, these below p->sz, for p->sz,

196
00:17:22,240 --> 00:17:26,170
then we know that this must be virtual address I guess above stack,

197
00:17:28,770 --> 00:17:32,310
we know that this is an address that actually comes out of the heap,

198
00:17:32,430 --> 00:17:37,200
but for which we, the kernel hasn't allocated any physical memory yet.

199
00:17:38,050 --> 00:17:41,680
And so the response to this page fault could be reasonably straightforward,

200
00:17:41,680 --> 00:17:45,670
in the page fault handler itself, we can allocate a page,

201
00:17:46,420 --> 00:17:58,310
using kalloc, allocate one page, zero the page, map the page into the pagetable,

202
00:17:58,310 --> 00:18:04,730
so updating the pagetables, then basically restart the instruction.

203
00:18:07,000 --> 00:18:10,330
So, for example is a load instruction or a store instruction

204
00:18:10,450 --> 00:18:18,010
that loads from or to read you know from not allocated piece of memory that actually the process has,

205
00:18:18,280 --> 00:18:24,280
now after we mapped in this physical page, the restart instruction should just work.

206
00:18:25,210 --> 00:18:26,230
Amiar, go ahead.

207
00:18:28,260 --> 00:18:33,300
Right, so I was wondering in the case where we're doing eager allocation,

208
00:18:33,750 --> 00:18:37,560
and there comes a point where process consumes so much memory,

209
00:18:37,560 --> 00:18:40,920
that it actually exhausts the physical memory resource,

210
00:18:41,910 --> 00:18:45,300
if we don't do eager allocation, we do lazy instead,

211
00:18:46,470 --> 00:18:49,950
at what point would the application know that there is no physical memory.

212
00:18:50,700 --> 00:18:52,770
Yeah, that's a great question,

213
00:18:52,890 --> 00:18:56,130
you know, basically you know it almost looks through the application,

214
00:18:56,130 --> 00:19:00,030
there's this illusion of unlimited physical amount of memory.

215
00:19:00,750 --> 00:19:03,990
You know, at some point of course, you know you might use so much,

216
00:19:03,990 --> 00:19:07,020
you know that basically use all physical memory,

217
00:19:07,020 --> 00:19:09,360
and so if then it touches one more page,

218
00:19:09,420 --> 00:19:12,390
which there's no physical memory present at that particular point in time.

219
00:19:12,860 --> 00:19:15,230
Then you know there's a couple of actions that the kernel can take

220
00:19:15,260 --> 00:19:17,840
and I'll talk about more sophisticated ones later,

221
00:19:18,050 --> 00:19:21,230
what you're gonna be doing in the lazy lab

222
00:19:21,440 --> 00:19:26,180
is you know if the memories up and there's no more free memory,

223
00:19:26,390 --> 00:19:31,210
you just return an error, actually kill the process in that particular case.

224
00:19:32,660 --> 00:19:36,140
And so because you're out of memory, so there's nothing kernel can do

225
00:19:36,170 --> 00:19:38,960
and at that point, you know return or kill the process.

226
00:19:40,970 --> 00:19:42,830
That's you're going to do in lazy lab,

227
00:19:42,830 --> 00:19:44,060
we'll see later in this lecture,

228
00:19:44,060 --> 00:19:45,650
you can be more sophisticated than that.

229
00:19:48,040 --> 00:19:50,530
And I think this is generally brings up a topic

230
00:19:50,530 --> 00:19:54,970
that is we have a collection of processes running on an operating system,

231
00:19:54,970 --> 00:19:56,530
there's a limited amount of physical memory,

232
00:19:56,710 --> 00:20:00,610
and that limited physical memory must be shared in some way between the applications.

233
00:20:01,040 --> 00:20:05,150
And so I'll talk a little bit much more about it in 10,20 minutes.

234
00:20:07,440 --> 00:20:11,340
Okay, there's a question in the chat.

235
00:20:11,460 --> 00:20:18,660
Why is the condition virtual address, virtual address [booms] doesn't start at zero.

236
00:20:19,150 --> 00:20:24,940
OK, there's a question about this particular check here.

237
00:20:26,140 --> 00:20:32,030
So, remember, we have our stack here,

238
00:20:32,590 --> 00:20:38,290
and we have our data here and we have our text in user process

239
00:20:38,620 --> 00:20:42,520
and basically we've bumped up p->sz to something bigger.

240
00:20:45,120 --> 00:20:48,660
We've bumped up the [growth], we havn't the allocated memory here yet,

241
00:20:48,690 --> 00:20:51,150
so this memory has not been physically allocated yet,

242
00:20:51,150 --> 00:20:54,900
so this check this check if the address falls below p->sz

243
00:20:54,900 --> 00:20:57,750
and it actually is a valid address in the user address space,

244
00:20:57,750 --> 00:21:01,350
if there above p->sz, presumably that's a programming error,

245
00:21:01,500 --> 00:21:06,360
and the program or user applications trying to reference in memory that actually doesn't have.

246
00:21:07,390 --> 00:21:08,770
Hopefully that answered the question.

247
00:21:11,380 --> 00:21:12,160
Yeah, thank you.

248
00:21:12,810 --> 00:21:21,750
Okay, so to get a little bit of feel, you know what it actually means and this lazy allocation,

249
00:21:22,020 --> 00:21:30,990
and that's probably, the only sort of programming or code things that were going to be doing today is,

250
00:21:31,020 --> 00:21:36,420
let's try to sort of sketch out or look actually how will look in the in code.

251
00:21:38,350 --> 00:21:41,080
When the [], you see that it will be surprising easy

252
00:21:41,290 --> 00:21:47,290
and furthermore it's probably big help for the lazy lab.

253
00:21:48,150 --> 00:21:51,240
And so, hopefully that will help you get going pretty straightforwardly.

254
00:21:52,600 --> 00:21:59,730
And at large [resources] to look at a couple page faults.

255
00:21:59,730 --> 00:22:03,000
I have a question, actually we got a point,

256
00:22:03,810 --> 00:22:06,030
why do we actually need to kill the application,

257
00:22:06,060 --> 00:22:10,950
could the operating system just to return like a [negative], out of memory trying to something else.

258
00:22:11,970 --> 00:22:14,940
Let's respond to the question a little bit later,

259
00:22:14,940 --> 00:22:17,400
in the page fault, we're going to just kill the process,

260
00:22:17,780 --> 00:22:21,320
but you know we could be more sophisticated, in [] lab,

261
00:22:21,950 --> 00:22:23,270
real kernels are more sophisticated.

262
00:22:25,060 --> 00:22:27,520
Okay, although in the end they might still kill,

263
00:22:27,790 --> 00:22:30,730
if there's no more memory, what what's there to be done,

264
00:22:30,760 --> 00:22:32,170
you know there's basically no choice.

265
00:22:34,140 --> 00:22:37,200
Okay, so the first thing we're going to modify,

266
00:22:37,200 --> 00:22:41,490
so remember that's growproc you know actually grows to address space with the application,

267
00:22:41,490 --> 00:22:43,080
allocates memory and all that kind of stuff,

268
00:22:43,170 --> 00:22:44,310
we're just not gonna do that,

269
00:22:45,090 --> 00:22:51,790
you're just gonna set p->sz, you know to p->sz plus n.

270
00:22:52,120 --> 00:22:55,870
So let's assume that number only growing and not worry about shrinking for now,

271
00:22:56,290 --> 00:22:57,520
and that is what we're gonna be doing.

272
00:22:58,350 --> 00:23:04,260
So this grows the virtual address space by n, that's all we're going to be doing.

273
00:23:05,920 --> 00:23:08,020
Let's see if I can make no programming mistakes,

274
00:23:08,050 --> 00:23:11,930
I did make a programming mistake, I guess.

275
00:23:13,060 --> 00:23:15,880
I don't have proc p here, so myproc.

276
00:23:24,000 --> 00:23:27,300
Yeah, so the program just runs as usual we boot,

277
00:23:27,450 --> 00:23:32,220
I think if we do like echo hi, we're gonna get actually a page fault

278
00:23:32,250 --> 00:23:35,310
and the reason that we get a page fault is because,

279
00:23:35,310 --> 00:23:42,090
the shell who's gonna fork you know echo and then the child's gonna exec echo,

280
00:23:42,270 --> 00:23:44,130
the shell actually allocate some memory,

281
00:23:44,630 --> 00:23:48,590
and so the shell calls sbrk and things are not looking good,

282
00:23:48,620 --> 00:23:53,000
but it's sort of interesting to look at, you know, the information here,

283
00:23:53,270 --> 00:24:00,130
so here's it prints out the scause register, the value scause and it's fifteen.

284
00:24:00,660 --> 00:24:03,180
Anybody, remember what fifteen is?

285
00:24:06,860 --> 00:24:09,440
You know from that table I just show you a little bit a while ago,

286
00:24:09,440 --> 00:24:11,660
actually used to write or store page fault.

287
00:24:12,420 --> 00:24:16,020
We see this process three, that's probably the shell.

288
00:24:16,520 --> 00:24:20,510
And we actually see the exception program counter, it's one two a four

289
00:24:20,660 --> 00:24:24,710
and we see the address given the virtual address in which we fault, which is 4008.

290
00:24:25,440 --> 00:24:31,420
And so let's look at the, you know, we can look at the assembly of the shell,

291
00:24:31,780 --> 00:24:35,710
makefile nice for us, nice enough for us to actually generate that

292
00:24:36,250 --> 00:24:40,700
and we can look at the address 12a4.

293
00:24:41,660 --> 00:24:45,830
And you know we see indeed, you know, there's a store instruction right,

294
00:24:45,830 --> 00:24:49,880
the store instruction and, it looks like that's where we're faulting.

295
00:24:50,860 --> 00:24:56,050
So you know scroll back a little bit and look at this assembly here,

296
00:24:56,050 --> 00:25:00,700
you know we see that actually this is in part of the implementation of malloc.

297
00:25:01,330 --> 00:25:05,230
So that seems totally reasonable, here's malloc implementation,

298
00:25:05,470 --> 00:25:12,460
not surprising that we, presumably we use sbrk to get some memory for implementing the user malloc.

299
00:25:13,060 --> 00:25:19,900
And, we're basically initializing a free list of the use the memory that we've just gotten from the kernel,

300
00:25:20,140 --> 00:25:27,070
and this line 12a4, [] writes, you know, I guess write something insides

301
00:25:27,340 --> 00:25:32,110
but we were writing to memory that actually hasn't been allocated.

302
00:25:33,240 --> 00:25:36,330
Another reason that we could see that the memory probably not allocated is,

303
00:25:36,630 --> 00:25:41,580
the I think shell actually has four pages of text and data

304
00:25:41,820 --> 00:25:45,660
and we're basically sitting just above the fourth page, in the fifth page,

305
00:25:45,660 --> 00:25:47,640
in fact we're sitting eight bytes above it,

306
00:25:47,970 --> 00:25:49,140
that sort of makes sense,

307
00:25:49,440 --> 00:25:53,310
look at the instruction again, where at 124a,

308
00:25:53,790 --> 00:26:02,130
you know see here basically probably a0 holds 4000 and eight is the additional offset,

309
00:26:02,160 --> 00:26:06,220
you know that we're actually referencing, that's the fault.

310
00:26:07,050 --> 00:26:13,110
And now what we like to do, is you know do something slightly more sophisticated.

311
00:26:13,660 --> 00:26:19,210
Then, we're gonna be doing and so let's go to trap.c,

312
00:26:27,280 --> 00:26:31,390
and look at usertrap, this happens in usertrap,

313
00:26:34,600 --> 00:26:38,980
usertrap is the function that we, Robert had discussed a week ago,

314
00:26:39,250 --> 00:26:43,780
and it just goes through the different causes and perform some action,

315
00:26:43,870 --> 00:26:47,770
so we're a little bit, here's, this line is scause eight

316
00:26:47,770 --> 00:26:50,620
and you know that's the point we're going to process system calls.

317
00:26:51,360 --> 00:26:57,420
Then there's a line that checks whether there was any a device interrupt and processes inside of device interrupt,

318
00:26:57,840 --> 00:27:02,910
and if there's none of those to happen, then basically we get this a trap and the process of being killed.

319
00:27:03,610 --> 00:27:05,740
And basically what we need to do is,

320
00:27:05,740 --> 00:27:11,750
you need to add some code here, that you know checks for another case, right,

321
00:27:11,750 --> 00:27:17,350
basically I guess the case that we want to [] a line is if r_scause,

322
00:27:18,050 --> 00:27:25,440
[] call it like it's r_scause is fifteen,

323
00:27:27,550 --> 00:27:28,810
we want to do something else.

324
00:27:32,000 --> 00:27:32,840
Does that make sense?

325
00:27:34,620 --> 00:27:35,760
So what do you want to do here,

326
00:27:42,130 --> 00:27:45,970
what is sort of the plan for [] for these couple lines of code?

327
00:27:50,130 --> 00:28:02,960
We want to check if p->sz is more than the virtual address that in stval, perhaps.

328
00:28:03,760 --> 00:28:05,620
Yeah, go ahead.

329
00:28:06,480 --> 00:28:14,520
Oh, and this is the case then do something like uvmalloc, I think.

330
00:28:15,170 --> 00:28:16,280
That's one way we could do it,

331
00:28:16,340 --> 00:28:19,370
so I'm going to cut some corners just for a demo

332
00:28:19,370 --> 00:28:22,940
and presumably in the lab itself, you will need to do a little bit more work,

333
00:28:23,120 --> 00:28:28,850
but basically here's the sort, I think [] code section of code, we need.

334
00:28:29,670 --> 00:28:31,140
So let's see.

335
00:28:32,700 --> 00:28:33,750
Where I was.

336
00:28:34,410 --> 00:28:40,000
Here's usertrap, let me just kind of paste into it.

337
00:28:41,230 --> 00:28:44,950
And we can look at, you know just a print statement for debugging

338
00:28:45,010 --> 00:28:49,480
and basically we're going to do in this handler, I'm gonna allocate a physical page.

339
00:28:50,190 --> 00:28:56,580
If there's no physical page, mean we're out of memory, we're gonna kill the process for now,

340
00:28:56,640 --> 00:28:59,370
if there's a physical page, we'll zero the page,

341
00:28:59,850 --> 00:29:06,750
then we just map the page at the appropriate address, in the address space of the user

342
00:29:06,840 --> 00:29:10,920
in particular map it on the rounded down virtual address,

343
00:29:11,130 --> 00:29:17,730
so the faulting address 4008 here, and so that's eight bytes into the fifth page

344
00:29:17,880 --> 00:29:22,830
and we want to map that physical page at the bottom of the physical, virtual page, so at 4000,

345
00:29:23,530 --> 00:29:27,100
rounded down to 4000 then we map 4000 to this physical page.

346
00:29:27,950 --> 00:29:32,450
And then of course we have to set the usual permission bits, you know u bit, read and write.

347
00:29:34,140 --> 00:29:34,860
Does that make sense?

348
00:29:38,380 --> 00:29:40,240
Yeah, I guess I can get rid of this line.

349
00:29:42,540 --> 00:29:44,820
So let's see, let's try it out.

350
00:29:49,750 --> 00:29:51,940
And I guess I made some mistakes.

351
00:29:54,570 --> 00:29:58,500
I think that on the else, you don't have an opening bracket at the bottom.

352
00:29:59,430 --> 00:30:06,320
Oh yeah, yeah, so if, I do I do I need one more, oh yeah.

353
00:30:10,340 --> 00:30:14,420
Oh, sorry, I mean on the else right here, you don't have an opening bracket right,

354
00:30:14,900 --> 00:30:20,390
like when is else printf usertrap unexpected scause.

355
00:30:24,580 --> 00:30:29,230
And hopefully all [work], excellent, so echo hi.

356
00:30:29,800 --> 00:30:32,440
Now, of course we're going to be optimistic and hope it works,

357
00:30:32,470 --> 00:30:33,730
I'll tell you it won't work,

358
00:30:34,520 --> 00:30:36,800
but we did get two page faults right,

359
00:30:36,800 --> 00:30:39,530
we gotta page fault 4008, you know primarily [],

360
00:30:39,530 --> 00:30:40,820
because we've got another page fault.

361
00:30:41,380 --> 00:30:47,380
And so the only problem we've left is there's a uvmunmap complaining that,

362
00:30:51,360 --> 00:30:56,490
as complaining that there are some page that we're trying to unmap is actually not mapped.

363
00:30:57,050 --> 00:30:58,340
And what could it be.

364
00:31:02,450 --> 00:31:04,430
What would you think if we get this panic.

365
00:31:07,200 --> 00:31:07,980
Anybody?

366
00:31:13,620 --> 00:31:17,000
What memories being unmapped here, most likely.

367
00:31:21,900 --> 00:31:25,680
The one that was lazily allocated not actually allocated.

368
00:31:25,950 --> 00:31:30,870
Yeah, exactly the memory [] lazily allocated, but actually it hasn't been used yet, right.

369
00:31:30,870 --> 00:31:33,510
And so there is no physical page for that particular lazy memory.

370
00:31:34,220 --> 00:31:40,660
And so, in this case when the pte is zero, you know there's no mapping yet,

371
00:31:40,900 --> 00:31:45,100
that's not really panic, you know this is actually what we expect you know could happen right.

372
00:31:45,770 --> 00:31:48,410
And in fact for that page, you don't have to do anything,

373
00:31:48,650 --> 00:31:51,290
you can just continue to go to the next page.

374
00:31:53,620 --> 00:31:54,400
Does that make sense?

375
00:31:56,000 --> 00:32:00,140
So let's do that, now those are the echo hi,

376
00:32:00,350 --> 00:32:02,840
and we've got two page faults, but hi works,

377
00:32:02,900 --> 00:32:11,540
and so we're basically you know have sort of a very basic minimal lazy allocation scheme working.

378
00:32:14,700 --> 00:32:15,870
Any questions about this?

379
00:32:16,820 --> 00:32:21,620
Sorry, I didn't really follow, why you could just continue, could you explain that again.

380
00:32:22,010 --> 00:32:31,060
Yeah, so the the bug indicated that we had were trying to free page that actually is not mapped.

381
00:32:32,480 --> 00:32:35,780
And you know how could that happen, well the only reason that could happen is

382
00:32:35,780 --> 00:32:39,740
because sbrk moved up p->sz,

383
00:32:39,980 --> 00:32:43,700
but never used, the application never used in that memory

384
00:32:43,730 --> 00:32:47,090
and so it actually has no mapping yet, because it was actually not allocated.

385
00:32:47,660 --> 00:32:52,580
Because we're lazily allocating, we're only allocating physical memory for those pages when we need it,

386
00:32:52,850 --> 00:32:55,250
if we didn't need it, then there will be no mapping

387
00:32:55,250 --> 00:32:57,890
and so it's totally reasonable that there actually is going to be a case

388
00:32:58,040 --> 00:33:02,690
where there's no mapping for virtual address, because they're actually wasn't allocated yet.

389
00:33:03,130 --> 00:33:05,710
And for that case, we just have to do nothing,

390
00:33:05,830 --> 00:33:09,710
you know, we can free the page, but there is no free page,

391
00:33:09,950 --> 00:33:13,040
and so the best thing is to continue and just go to the next page in the loop.

392
00:33:14,380 --> 00:33:16,450
Okay, that makes sense, thank you.

393
00:33:16,920 --> 00:33:20,850
Yeah, if we didn't do continue, but basically you know just kept going,

394
00:33:20,850 --> 00:33:24,720
then we would actually create a page that would be you can do free the page,

395
00:33:25,740 --> 00:33:26,910
that's why it continues there.

396
00:33:27,550 --> 00:33:28,210
Make sense.

397
00:33:30,770 --> 00:33:32,060
Another question,

398
00:33:32,600 --> 00:33:39,170
in uvmunmap, I assumed the panic was that was there was there for a reason,

399
00:33:39,380 --> 00:33:44,420
so a more correct a more reasonable implementation is to have two versions

400
00:33:44,630 --> 00:33:46,160
and we would use the one that doesn't panic.

401
00:33:47,090 --> 00:33:50,330
Yeah, because why was the the panic,

402
00:33:50,330 --> 00:33:55,790
while it was basically an invariant that used to be true for unmodified xv6,

403
00:33:56,270 --> 00:34:00,740
actually unmodified xv6 should never have a case where those user memory that was not map.

404
00:34:01,500 --> 00:34:02,820
And so therefore the panic goes up,

405
00:34:03,120 --> 00:34:05,490
we now change the design of xv6,

406
00:34:05,550 --> 00:34:09,720
so we have to adjust and this invariant is no longer true,

407
00:34:09,930 --> 00:34:11,250
so we've got to remove the panic

408
00:34:11,250 --> 00:34:19,350
and because that invariant is just not true, legitimately not true anymore.

409
00:34:20,290 --> 00:34:21,730
I see, thanks.

410
00:34:23,880 --> 00:34:24,510
That makes sense?

411
00:34:26,300 --> 00:34:28,910
So, so a couple comments,

412
00:34:28,910 --> 00:34:33,740
this will hopefully help a lot with next lab,

413
00:34:33,740 --> 00:34:37,970
in fact this is one of the three components of the lab, of the next lab,

414
00:34:37,970 --> 00:34:39,500
one of the first things you have to do

415
00:34:39,830 --> 00:34:42,110
and hopefully this will save you some time,

416
00:34:42,410 --> 00:34:47,960
maybe make up for all the pain that you went through in the page fault lab.

417
00:34:48,760 --> 00:34:51,190
But clearly not enough right,

418
00:34:51,190 --> 00:34:52,720
yeah, so like what things are,

419
00:34:52,750 --> 00:34:54,780
you know, we made these changes,

420
00:34:54,780 --> 00:34:56,670
but more things are still probably broken.

421
00:35:01,090 --> 00:35:02,380
One already was mentioned,

422
00:35:02,410 --> 00:35:06,700
I actually didn't do it to check whether actually the virtual address was below p->sz

423
00:35:06,700 --> 00:35:08,140
which we probably should do.

424
00:35:08,840 --> 00:35:10,250
Any other things that might be broken?

425
00:35:17,560 --> 00:35:18,220
Anybody?

426
00:35:25,020 --> 00:35:30,180
Number of bytes to grow the process by sbrk is an int and not an unsigned int,

427
00:35:30,180 --> 00:35:32,520
so negative numbers could be used.

428
00:35:33,560 --> 00:35:36,590
Yes, and negative numbers can use and that means shrinking the address space,

429
00:35:36,980 --> 00:35:38,120
so if we shrink the address space,

430
00:35:38,120 --> 00:35:39,530
we also have to be a little careful.

431
00:35:40,110 --> 00:35:45,750
So it turns out there's a whole bunch of, as usual, in an operating system and a whole bunch of different cases, right,

432
00:35:45,750 --> 00:35:49,890
where which we're going to be looking at this particular pagetable entry

433
00:35:50,130 --> 00:35:53,730
and for all those different cases we might actually have to modify xv6 slightly.

434
00:35:54,290 --> 00:35:56,990
And that's exactly what basically the lab is about

435
00:35:56,990 --> 00:36:00,650
is you know doing good enough job that basically you can pass usertests.

436
00:36:01,060 --> 00:36:05,020
Usertests will stress a whole bunch of other cases that you will need to deal with.

437
00:36:07,550 --> 00:36:08,150
Okay?

438
00:36:11,340 --> 00:36:12,450
Any questions so far?

439
00:36:18,300 --> 00:36:19,440
Okay, let me,

440
00:36:19,500 --> 00:36:26,280
in that case I want to talk about a bunch of other usages or cool things you can do

441
00:36:26,280 --> 00:36:30,060
once you have page faults and pagetables are updated dynamically.

442
00:36:30,870 --> 00:36:37,590
Another one that is almost trivial, but you know commonly used

443
00:36:37,590 --> 00:36:46,060
is what's called zero filled, zero fill on demand.

444
00:36:51,300 --> 00:36:56,880
It turns out that in operating systems, you know there are many null pages.

445
00:36:58,140 --> 00:37:03,310
And, so, for example if you look at the address space in user space,

446
00:37:03,490 --> 00:37:07,450
xv6 doesn't really is not as [advanced],

447
00:37:07,450 --> 00:37:10,450
but if you look at the layout of a binary,

448
00:37:10,660 --> 00:37:11,950
I mean [],

449
00:37:11,950 --> 00:37:14,740
you know there's some text, there's what's called the data segment

450
00:37:15,070 --> 00:37:18,370
and there's typically also what something is called the BSS segment.

451
00:37:20,170 --> 00:37:24,790
And so when the compiler produces a binary,

452
00:37:24,790 --> 00:37:26,650
you know basically fills in these three segments,

453
00:37:26,830 --> 00:37:28,480
the text you know the instructions,

454
00:37:28,480 --> 00:37:35,950
you know the data is basically global variables, that actually have a value that is not zero, so initialized data.

455
00:37:41,860 --> 00:37:44,080
In BBS, is basically a description,

456
00:37:44,110 --> 00:37:46,540
that says well there's a whole bunch of variables

457
00:37:46,690 --> 00:37:49,960
and it's basically their sizes and they all should be zero.

458
00:37:51,010 --> 00:37:54,070
And the reason that they are basically not listed out,

459
00:37:54,100 --> 00:37:56,800
you know or the memory is not right there in the files,

460
00:37:56,800 --> 00:37:58,360
because it will save a lot of

461
00:37:58,360 --> 00:38:00,910
for example, if you declare big matrix in C,

462
00:38:01,150 --> 00:38:03,280
on the top of the file is a global variable

463
00:38:03,280 --> 00:38:05,620
and it's automatically attribute zeros,

464
00:38:05,800 --> 00:38:08,500
why allocate all the space in the file,

465
00:38:08,590 --> 00:38:14,080
just like no that basically you know for this particular variable in the content should be zero.

466
00:38:15,320 --> 00:38:18,650
And amazingly on exec, on a normal operating system on exec,

467
00:38:18,920 --> 00:38:23,320
we'll look at these three segments,

468
00:38:23,320 --> 00:38:26,680
[] usual thing that xv6 does for text and data,

469
00:38:26,770 --> 00:38:33,670
but for BSS, it will allocate you know memory to hold the BSS and basically stick zeroes in there.

470
00:38:34,120 --> 00:38:40,140
So, allocated address space takes data in it

471
00:38:40,140 --> 00:38:45,040
and then we're basically look at, the equivalent of the BSS,

472
00:38:45,040 --> 00:38:47,290
you know all the global variables that basically zero

473
00:38:47,290 --> 00:38:48,790
and maybe many many pages,

474
00:38:51,540 --> 00:38:53,880
and all those pages basically have to have the content zero,

475
00:38:55,570 --> 00:38:57,010
so that's the virtual address space.

476
00:38:57,010 --> 00:38:58,960
And so typical trick, you know, to do is

477
00:38:58,960 --> 00:39:01,900
to say like wow, I've got so many pages that need to have zero,

478
00:39:01,930 --> 00:39:04,330
what I'm gonna do in physical memory,

479
00:39:05,160 --> 00:39:09,390
this is the virtual address space and the physical address memory,

480
00:39:09,660 --> 00:39:15,430
what I'm gonna do is you're going to allocate one zero page, and fill it with zeros,

481
00:39:15,610 --> 00:39:19,640
and basically map all the other pages to that one page.

482
00:39:24,200 --> 00:39:28,580
You know saving myself, you know lots you know, lots of physical memory, at least at start up.

483
00:39:29,520 --> 00:39:33,570
And of course those mappings has to be limit care, dominate care,

484
00:39:33,600 --> 00:39:37,020
we can't, you know we cannot allow write to it right,

485
00:39:37,020 --> 00:39:39,660
because everybody's relying on the fact that actually stays zero,

486
00:39:39,690 --> 00:39:41,400
so we just map it read only.

487
00:39:43,440 --> 00:39:47,370
And then, at some point, when an application starts writing to one of

488
00:39:47,370 --> 00:39:53,700
you know that basically started as a loader and in store, if one of the pages that actually part of the BSS,

489
00:39:53,940 --> 00:39:58,650
so because he wants you to whatever store one or two there content there,

490
00:39:58,770 --> 00:40:00,000
we'll going to get a page fault.

491
00:40:06,240 --> 00:40:11,610
And so what should we do on the page fault, in this particular case.

492
00:40:15,170 --> 00:40:15,770
Anybody?

493
00:40:23,850 --> 00:40:27,680
Go ahead, anybody, I do what should we do in the page fault here.

494
00:40:28,430 --> 00:40:36,090
I think we should make a new page and all write zeroes and rerun that instruction.

495
00:40:36,450 --> 00:40:37,380
Yeah exactly,

496
00:40:37,380 --> 00:40:42,810
so let's let's assume this were my drawing, that's actually the store instruction happens to one of the top.

497
00:40:43,460 --> 00:40:45,050
And what we really want to do basically is

498
00:40:45,140 --> 00:40:49,640
allocate a new physical page, a page memory you know kalloc, put zeros in there,

499
00:40:49,640 --> 00:40:51,140
because you know that's what we're expecting

500
00:40:51,380 --> 00:40:55,160
and then we can change the top mapping for the one for this particular,

501
00:40:55,620 --> 00:40:59,790
because this guy [], let me assume that there's this one,

502
00:40:59,940 --> 00:41:02,790
we can change this mapping, you know to be read write,

503
00:41:03,960 --> 00:41:06,910
and pointed to the new page,

504
00:41:11,860 --> 00:41:21,290
and then you basically so copy or update pte, and then restart the instruction.

505
00:41:28,780 --> 00:41:29,350
And that's it.

506
00:41:30,610 --> 00:41:32,830
Why is this an effective

507
00:41:32,860 --> 00:41:35,350
why, why do we think this is actually a good optimization.

508
00:41:39,570 --> 00:41:41,430
Why do operating systems do it.

509
00:41:49,190 --> 00:41:49,880
Anybody?

510
00:41:52,420 --> 00:41:53,770
You don't need it though.

511
00:41:54,280 --> 00:41:55,840
Go ahead.

512
00:41:57,200 --> 00:42:00,560
You don't need to use as much memory as the user requests,

513
00:42:00,560 --> 00:42:04,340
so it's just better to build it when it when you need it.

514
00:42:04,700 --> 00:42:07,460
Yeah, makes sense, similar to the lazy allocation,

515
00:42:07,460 --> 00:42:11,600
basically if the program say allocated huge you know array

516
00:42:11,600 --> 00:42:14,030
or you know for the worst possible input,

517
00:42:14,490 --> 00:42:16,620
it's a global array, it all has to be zero,

518
00:42:16,620 --> 00:42:18,480
but maybe only fraction is being used.

519
00:42:20,230 --> 00:42:21,400
What's the second advantage.

520
00:42:28,830 --> 00:42:30,960
Second advantage you have to do less work in exec

521
00:42:31,320 --> 00:42:36,300
and so the program may start quicker and get basically better interactive performance,

522
00:42:36,300 --> 00:42:38,250
because you don't really have to allocate memory,

523
00:42:38,250 --> 00:42:39,420
you don't really have zero memory,

524
00:42:39,420 --> 00:42:41,220
you only have to allocate zero one page

525
00:42:41,460 --> 00:42:44,130
and the rest like just mapping the pagetables,

526
00:42:44,130 --> 00:42:45,660
you just have to write the pte entries.

527
00:42:47,340 --> 00:42:47,970
Does that make sense?

528
00:42:49,400 --> 00:42:56,160
But our updates or writes, so they will become slower,

529
00:42:56,160 --> 00:42:58,980
because every time a page fault will occur and.

530
00:42:59,400 --> 00:43:01,800
Yeah so you know there's absolute point,

531
00:43:02,010 --> 00:43:05,370
so we basically postponed some of the cost later, right,

532
00:43:05,860 --> 00:43:08,410
at the point that we do the page fault,

533
00:43:08,830 --> 00:43:13,390
and you know partially relying or hoping that maybe not all the pages are being used.

534
00:43:13,840 --> 00:43:18,130
Good like for example if the pages four ninety six four thousand ninety six bytes,

535
00:43:18,490 --> 00:43:23,590
you know basically we're gonna take one page fault per 4096 zeros, right.

536
00:43:24,190 --> 00:43:25,630
And so do some [] there.

537
00:43:27,700 --> 00:43:29,200
But it's a great point,

538
00:43:29,230 --> 00:43:32,980
you know certainly we've made page, we have added the cost of the page fault.

539
00:43:33,530 --> 00:43:36,740
How much is the cost of the page fault, how should we think about that.

540
00:43:38,140 --> 00:43:41,770
These are comparable to store instruction more is much more expensive.

541
00:43:48,300 --> 00:43:50,250
More expensive, right.

542
00:43:50,310 --> 00:43:51,240
Yeah, why.

543
00:43:52,720 --> 00:44:01,920
Store will just like need to record, it will take some time to get to the to RAM,

544
00:44:01,920 --> 00:44:04,830
but the fault will have to go to the kernel.

545
00:44:05,510 --> 00:44:08,720
Yeah, so, in fact how many store instruction were there,

546
00:44:08,720 --> 00:44:13,370
even in the, the trap handling code that Robert showed you last week

547
00:44:13,550 --> 00:44:17,000
or actually that you're doing currently in the trap lab.

548
00:44:19,500 --> 00:44:21,840
Well at least like a hundred.

549
00:44:21,990 --> 00:44:24,840
Yeah at least a hundred, correct, used to save store registers.

550
00:44:25,710 --> 00:44:26,880
So there's quite a bit

551
00:44:26,880 --> 00:44:31,320
and so there's both the overhead of transferring from user space to kernel space as well

552
00:44:31,320 --> 00:44:36,000
as all the instructions that are being executed to save and restore state.

553
00:44:36,660 --> 00:44:38,820
So page fault is definitely not free,

554
00:44:39,390 --> 00:44:41,490
so the question that was asked earlier very good question.

555
00:44:45,570 --> 00:44:46,200
Okay.

556
00:44:47,190 --> 00:44:51,930
So let's look at some more optimizations that what can do,

557
00:44:51,930 --> 00:44:56,640
these ones are sort of reasonable boring, or maybe reasonable straightforward,

558
00:44:56,640 --> 00:45:00,960
and we're gonna hopefully get a little bit more couple more exciting ones.

559
00:45:02,120 --> 00:45:04,580
See what is next what I wanted to do about it.

560
00:45:05,160 --> 00:45:10,890
Next one, it's a very common one, in many operating systems implemented

561
00:45:10,920 --> 00:45:14,940
and the fact that will also be one of the topics in the one of the labs.

562
00:45:16,250 --> 00:45:18,050
So let's do the next one.

563
00:45:19,010 --> 00:45:30,770
And that is copy-on-write fork, or something called COW fork.

564
00:45:34,960 --> 00:45:40,540
And you know, observation is pretty straightforward,

565
00:45:40,540 --> 00:45:43,360
in fact we made this observation a couple times in lecture.

566
00:45:44,170 --> 00:45:46,510
Um, but when.

567
00:45:48,680 --> 00:45:52,670
Let's say you know the shell, we're talking [] a second ago,

568
00:45:52,670 --> 00:45:56,060
so shell runs and process's command

569
00:45:56,060 --> 00:45:59,390
and it actually does fork to create child,

570
00:46:00,670 --> 00:46:03,490
and so the fork you know basically keep copy of shell

571
00:46:03,880 --> 00:46:06,250
and so we got a parent and we got the child

572
00:46:06,550 --> 00:46:09,730
and the child almost one of the first things it does is an exec,

573
00:46:09,850 --> 00:46:11,650
maybe execute a couple of instructions

574
00:46:11,920 --> 00:46:14,590
and then actually execs, for example to run echo.

575
00:46:16,800 --> 00:46:20,880
And as we now know, saw in last lab,

576
00:46:21,030 --> 00:46:25,080
you know the fork creates a complete duplicate of the shell address space,

577
00:46:25,260 --> 00:46:27,180
and then exec the first thing that basically does,

578
00:46:27,180 --> 00:46:32,160
it throws out away and replaces it with an address space containing echo.

579
00:46:33,060 --> 00:46:35,760
And so it seems slightly wasteful right,

580
00:46:35,760 --> 00:46:40,240
yeah, so here let's say we have our parent virtual address space,

581
00:46:41,290 --> 00:46:43,900
and then here we have a child.

582
00:46:46,030 --> 00:46:49,930
And what we're actually doing in user physical memory,

583
00:46:52,970 --> 00:46:56,510
and in the normal case in xv6 or in unmodified xv6,

584
00:46:56,660 --> 00:47:01,820
you know there's a bunch of like there were four pages, we saw that the shell has one two three four.

585
00:47:02,340 --> 00:47:07,470
And, you know when we start, when fork runs,

586
00:47:07,620 --> 00:47:11,070
basically you do look at those four pages one two three four

587
00:47:11,250 --> 00:47:16,200
and copy all the content you know from those pages the parent into the child.

588
00:47:17,180 --> 00:47:22,940
And then as soon as the exec happens, basically we're going to free these pages.

589
00:47:23,420 --> 00:47:26,930
And allocate new pages actually have the content of echo in it.

590
00:47:27,990 --> 00:47:34,670
So, a good organization one that actually tends to be very effective for this particular sequence

591
00:47:34,880 --> 00:47:41,060
is that you know if we if the parent has these four mappings, you know in its address space,

592
00:47:42,020 --> 00:47:46,550
going from whatever the zero goes here, the first one goes there and whatever.

593
00:47:47,980 --> 00:47:50,500
Instead, when we create the child's address space,

594
00:47:50,500 --> 00:47:53,200
instead of creating copying and allocating new physical memory,

595
00:47:53,230 --> 00:47:59,830
what we could do is just share the physical pages that parent actually already has allocated.

596
00:48:00,540 --> 00:48:07,140
And so we just set the ptes with child to the same pointing to the same physical pages as in the parent.

597
00:48:08,780 --> 00:48:10,670
And we're going to be a little careful again, correct,

598
00:48:10,670 --> 00:48:13,490
because if the child wants to modify one of these pages,

599
00:48:13,580 --> 00:48:16,760
that updates should not be visible to the parent,

600
00:48:16,760 --> 00:48:19,370
because we want strong isolation between the parent and child,

601
00:48:19,370 --> 00:48:21,050
so we need to be a little more careful,

602
00:48:21,350 --> 00:48:23,000
so to be a little more careful about,

603
00:48:23,000 --> 00:48:28,790
what we can do is just map those pages both the child and the parent read only.

604
00:48:32,870 --> 00:48:36,170
And then of course we're going to get a page fault at some point,

605
00:48:36,750 --> 00:48:39,060
because the parent is going to run where the child is going to run.

606
00:48:40,130 --> 00:48:45,800
And, maybe you know the child or parent will do a store instruction

607
00:48:45,800 --> 00:48:49,520
to maybe save the data to some global variable somewhere,

608
00:48:50,020 --> 00:48:52,840
and at that point you know, that that will cause a page fault,

609
00:48:52,840 --> 00:48:55,930
because you were writing to a page that is mapped read only,

610
00:48:56,110 --> 00:48:57,070
we get a page fault

611
00:48:57,160 --> 00:48:58,240
and so what do we need to do.

612
00:48:58,240 --> 00:48:59,860
Well, we need to make a copy of the page,

613
00:49:03,120 --> 00:49:07,860
so let's assume that's the child that actually does the store instruction,

614
00:49:07,980 --> 00:49:09,660
so we allocate a new page,

615
00:49:11,400 --> 00:49:17,580
we copy the content of of the page that were faulted on into this new page,

616
00:49:17,820 --> 00:49:20,550
we map that page into the child,

617
00:49:20,550 --> 00:49:22,350
and this guy we can map read write,

618
00:49:22,350 --> 00:49:26,400
because now private page only visible in the child's address space,

619
00:49:26,700 --> 00:49:29,100
in fact the page that actually will be fault on,

620
00:49:29,100 --> 00:49:32,390
we can also now map page read write into the parent.

621
00:49:34,060 --> 00:49:39,270
And so we copy the page, map it and restart instruction.

622
00:49:44,940 --> 00:49:47,820
And when restarting starting really means you know doing userret

623
00:49:48,210 --> 00:49:53,940
the same way that return to user space, in the last week's lecture.

624
00:49:56,690 --> 00:49:59,150
Does this make sense, any questions about this one.

625
00:49:59,720 --> 00:50:08,120
I'm sorry, when you say we mapped the parents virtual address to we also read write,

626
00:50:08,210 --> 00:50:12,080
how do we find it out, is the same as the child's?

627
00:50:12,200 --> 00:50:18,350
Yeah because the address space of the child is a duplicate of the parents address space right,

628
00:50:18,350 --> 00:50:21,290
so if we fault to a particular virtual address,

629
00:50:21,640 --> 00:50:23,260
seems the address spaces are equal,

630
00:50:23,470 --> 00:50:28,630
you know the same virtual address both the parents address space and in the child's address space.

631
00:50:31,580 --> 00:50:32,870
Makes sense, thank you.

632
00:50:36,490 --> 00:50:37,720
Another question?

633
00:50:37,900 --> 00:50:38,350
Yeah.

634
00:50:39,130 --> 00:50:45,610
For, let's say, like some parent [] process, maybe like the first one that launches,

635
00:50:45,760 --> 00:50:52,220
does it use its pages, god, does it set just read permissions

636
00:50:52,460 --> 00:50:57,380
or does it start off with read write, when it forks it modifies.

637
00:50:58,060 --> 00:50:59,530
OK, OK, it's up to you,

638
00:51:00,640 --> 00:51:03,580
if I knew this is also one lab,

639
00:51:04,240 --> 00:51:07,540
you can implement copy-on-write after the lazy lab,

640
00:51:07,930 --> 00:51:09,490
you have some freedom

641
00:51:09,490 --> 00:51:11,950
and an easy thing to do is just also map read only,

642
00:51:12,280 --> 00:51:13,510
you will get a page fault,

643
00:51:13,840 --> 00:51:17,530
and then you do whatever you normally also would do in the copy-on-write.

644
00:51:18,030 --> 00:51:21,030
So you can use the same mechanism, in both cases.

645
00:51:22,750 --> 00:51:28,000
There's no reason to actually specialize for some separate for the first process.

646
00:51:30,100 --> 00:51:30,520
Okay thanks.

647
00:51:31,960 --> 00:51:35,150
So, I also have a question,

648
00:51:35,150 --> 00:51:42,020
given that we like kind of copy whole tables, sorry, whole pages around pretty often,

649
00:51:42,770 --> 00:51:48,920
does any, like memory hardware implement like a specific instruction,

650
00:51:48,920 --> 00:51:53,810
because basically memory hardware will usually just have like some data lines

651
00:51:53,810 --> 00:51:57,590
to say read me or stored just memory,

652
00:51:57,650 --> 00:52:01,220
but we have like [] copy page a to page b.

653
00:52:02,510 --> 00:52:08,090
Yeah, x86 example has hardware instructions for copying range of memory.

654
00:52:08,560 --> 00:52:11,470
You know RISC-V doesn't.

655
00:52:12,180 --> 00:52:17,280
Um, yeah, but of course you know in, in a very high performance implementation,

656
00:52:17,550 --> 00:52:21,030
all the reads writes will be pipelined,

657
00:52:21,390 --> 00:52:24,810
in hopefully run at the speed of the memory bandwidth.

658
00:52:28,150 --> 00:52:35,050
Note that actually, in principle, we might be lucky and we're saving, correct, on loads and stores or copies,

659
00:52:35,290 --> 00:52:38,080
because in this particular picture, I made only one copy

660
00:52:38,140 --> 00:52:42,130
and in the unmodified case, we would have copied all four pages.

661
00:52:43,120 --> 00:52:48,760
And so, hopefully this is strictly better, both in terms of memory consumption and in terms of performance,

662
00:52:48,910 --> 00:52:50,020
you know fork will just be faster.

663
00:52:54,090 --> 00:52:55,290
I have a quick question,

664
00:52:55,470 --> 00:52:59,370
when when the page fault occurs

665
00:52:59,370 --> 00:53:04,620
and we see that it was essentially like we were trying to write to a read only address,

666
00:53:04,830 --> 00:53:10,380
how does the kernel tell, like this is a situation where it's copy-on-write fork

667
00:53:10,440 --> 00:53:16,560
versus just a situation where the memory it was trying to write was was marked as read only for some legitimate reason

668
00:53:16,560 --> 00:53:17,820
other than copy-on-write fork

669
00:53:17,820 --> 00:53:21,900
is just kind of an invariance that if a its user memory,

670
00:53:21,900 --> 00:53:25,380
then it will be mapped read write, unless it was a result of copy-on-write fork.

671
00:53:25,880 --> 00:53:30,710
Yeah yeah, so it is an invariant that needs to be maintained in the kernel

672
00:53:30,710 --> 00:53:34,730
and the kernel must recognize in some way that this is a copy-on-write page, if you will.

673
00:53:35,340 --> 00:53:37,500
And so I'm very glad you asked the question,

674
00:53:37,500 --> 00:53:43,290
because it turns out you know the RISC-V hardware, almost all pagetable hardware actually has support for this.

675
00:53:43,870 --> 00:53:46,180
And we didn't mention it earlier,

676
00:53:46,180 --> 00:53:53,080
but here's are usual you know, whatever two level, or multilevel pagetable use pte,

677
00:53:56,040 --> 00:54:01,170
and you're looking at pte, you know I talked about the bits you know one zero through seven,

678
00:54:01,200 --> 00:54:04,110
but not about these two bits, RSW.

679
00:54:06,190 --> 00:54:09,640
And, they are reserved for supervisor software.

680
00:54:10,200 --> 00:54:17,010
So the supervisor software, this is the kernel, you can use these bits at its own free will.

681
00:54:17,550 --> 00:54:19,560
And so one thing one could do is

682
00:54:19,560 --> 00:54:23,970
like say decide that being a basically means this is a copy-on-write page or copy-on-write fault.

683
00:54:24,610 --> 00:54:30,610
And so when the kernel programs these page tables for copy-on-write,

684
00:54:30,610 --> 00:54:37,370
you can just put on the ptes, you know for these particular pages, the bits,

685
00:54:37,370 --> 00:54:39,170
you know set to be a copy-on-write,

686
00:54:39,200 --> 00:54:41,030
so that when the page fault happens

687
00:54:41,270 --> 00:54:44,090
and we see that the copy-on-write bit set,

688
00:54:44,180 --> 00:54:45,890
then we just go off into this,

689
00:54:46,780 --> 00:54:51,560
and otherwise we do something else, for example, maybe the lazy allocation.

690
00:54:54,310 --> 00:54:54,970
Does that make sense?

691
00:54:56,450 --> 00:54:57,230
Yep, thank you.

692
00:54:57,980 --> 00:55:02,420
And in fact in in the lab, one of the things you will be doing is

693
00:55:02,420 --> 00:55:06,020
probably use that bit you know set a copy-on-write in the pte.

694
00:55:07,380 --> 00:55:11,850
There's one more [] that will show up in the copy-on-write lab

695
00:55:11,850 --> 00:55:20,430
is that there's some currently in xv6, basically a physical page more or less only belongs to one process,

696
00:55:20,820 --> 00:55:24,840
with the exception of the trampoline page, which that trampoline were never free,

697
00:55:24,840 --> 00:55:27,030
so that's not really going to a particular big issue.

698
00:55:27,630 --> 00:55:35,680
But for these pages you now we have multiple processes or multiple address spaces pointing to the same physical address,

699
00:55:36,180 --> 00:55:39,730
and so, for example if the parent exits right away,

700
00:55:39,730 --> 00:55:41,650
we're gonna live with care and be careful right,

701
00:55:41,650 --> 00:55:45,580
because can we free that page immediately, if the parent exits.

702
00:55:50,520 --> 00:55:54,810
Maybe not, because there may be multiple children processes.

703
00:55:54,810 --> 00:55:57,000
Yeah, there might be child using that page

704
00:55:57,000 --> 00:56:02,490
and so we've kernel would free that page, then, you know we're gonna be in trouble,

705
00:56:02,520 --> 00:56:05,430
because basically the if you look at kfree,

706
00:56:05,430 --> 00:56:08,880
kfree actually writes all kinds once on a free page

707
00:56:09,180 --> 00:56:10,860
and so then the child runs with that page

708
00:56:10,860 --> 00:56:12,450
and all kinds of bizarre things are gonna happen.

709
00:56:14,040 --> 00:56:16,080
So what should you be now for free.

710
00:56:23,450 --> 00:56:28,370
Free, if you don't have children, I guess.

711
00:56:28,400 --> 00:56:32,030
Yeah, we may be better way of sort of a more general version of that statement

712
00:56:32,030 --> 00:56:39,930
is to say well what we really need to do is we need a ref count every physical page.

713
00:56:41,130 --> 00:56:45,000
And when we free the page, we decrease the ref down by one

714
00:56:45,180 --> 00:56:48,270
and if the ref count reaches zero, then actually we can free the page.

715
00:56:48,940 --> 00:56:54,280
And so you will have to introduce some additional data structure or meta information in the copy-on-write,

716
00:56:54,280 --> 00:56:56,560
[] actually do that ref counting.

717
00:56:59,740 --> 00:57:00,820
Where can we store this,

718
00:57:00,820 --> 00:57:04,840
because this if we ever have the ref count every single page, that can be a lot.

719
00:57:05,320 --> 00:57:09,520
Yeah well for every physical page of memory, we will have to do a ref count.

720
00:57:10,760 --> 00:57:12,470
Yeah, you can get away with a little bit less,

721
00:57:12,470 --> 00:57:14,540
but then we're in for simplification in lab,

722
00:57:14,540 --> 00:57:18,350
we're just for everyone for every 4096 bytes,

723
00:57:18,820 --> 00:57:20,260
we need to contain a reference count.

724
00:57:23,630 --> 00:57:31,460
Can we write that down in those other two free bits and say that, no more than four.

725
00:57:31,880 --> 00:57:38,300
Good yeah, not unreasonable,

726
00:57:38,300 --> 00:57:41,210
but you know if you're fork it multiple times,

727
00:57:41,640 --> 00:57:42,990
that be too bad, right,

728
00:57:44,320 --> 00:57:47,950
after three times or four times, you can't do can't do the optimization anymore.

729
00:57:52,120 --> 00:57:53,890
Yeah there's some freedom here.

730
00:57:54,960 --> 00:58:01,050
Also, do you really need to use that bit to specify if it's a copy-on-write,

731
00:58:01,050 --> 00:58:07,860
because the kernel could also maintain some information about the processes that.

732
00:58:08,430 --> 00:58:11,730
Yeah yeah yeah, you could you could do anything,

733
00:58:11,730 --> 00:58:14,460
some other matter information along with the process address space

734
00:58:14,460 --> 00:58:18,180
to say basically well virtual addresses between this and that are text addresses,

735
00:58:18,480 --> 00:58:22,170
so we have a page fault there and it must be copy-on-write or something.

736
00:58:23,090 --> 00:58:24,950
In fact one of the later labs,

737
00:58:24,950 --> 00:58:31,540
you know you'll certainly extend the meta information that xv6 maintains, exactly for that reason.

738
00:58:34,110 --> 00:58:37,020
There's a bit of freedom here and when you start implementing these labs.

739
00:58:41,040 --> 00:58:42,330
Any further questions about this?

740
00:59:03,900 --> 00:59:09,420
Okay, let's go to the next one, there's something called demand paging,

741
00:59:11,350 --> 00:59:14,590
another very popular one in most operating systems implemented.

742
00:59:17,100 --> 00:59:21,090
And so the you know it just goes back basically to exec.

743
00:59:24,220 --> 00:59:27,190
So currently in unmodified xv6,

744
00:59:27,190 --> 00:59:34,860
you know xv6 loads the text segment, and the data segment profile

745
00:59:34,950 --> 00:59:42,790
and maps in eagerly in basically into the pagetable.

746
00:59:46,960 --> 00:59:51,250
And basically the same observation that we made for lazy and zero filled,

747
00:59:51,370 --> 00:59:54,430
is that well what we could do is like why do it eagerly,

748
00:59:54,490 --> 00:59:59,950
why not just wait a little while, until to see if actually the application really needs,

749
00:59:59,950 --> 01:00:03,760
you know those particular set of instructions, you know the binary might be very big.

750
01:00:04,270 --> 01:00:09,730
In instead of actually loading it all in you know from disk,

751
01:00:09,730 --> 01:00:11,440
it tends to be expensive operation,

752
01:00:11,740 --> 01:00:17,350
maybe the data segment is much bigger than really needs than the typical use case requires,

753
01:00:17,440 --> 01:00:18,970
we don't really have to do that.

754
01:00:19,700 --> 01:00:25,670
And so instead of, on exec, instead of actually we allocate the virtual address space,

755
01:00:25,670 --> 01:00:31,580
you know allocate the address space for the text and the data that's in the file,

756
01:00:31,700 --> 01:00:35,420
but in the ptes were not mapped all,

757
01:00:35,690 --> 01:00:39,020
we're just gonna keep you know pte for one of these pages,

758
01:00:39,020 --> 01:00:42,020
we just cannot set valid bit, so valid bit to zero.

759
01:00:44,180 --> 01:00:48,020
And of course you know, when we're gonna get our first page fault,

760
01:00:49,840 --> 01:00:53,530
if we do this in exec and let's say we modify xv6 to do this.

761
01:00:54,350 --> 01:00:56,060
When will our first page fault happen,

762
01:00:59,900 --> 01:01:06,300
what's the first instruction that is being run for user address or user program.

763
01:01:09,690 --> 01:01:11,130
Where does the user program start.

764
01:01:12,220 --> 01:01:15,880
Is it loading the initial code, in uvminit.

765
01:01:16,000 --> 01:01:20,410
Yeah okay, we're just [],

766
01:01:20,410 --> 01:01:24,190
modifying exec and not called the uvminit, where.

767
01:01:28,660 --> 01:01:32,110
So mostly when we actually if you remember from for [] or something like that,

768
01:01:32,110 --> 01:01:35,320
you know the place where an application starts exactly address zero,

769
01:01:35,980 --> 01:01:38,110
pictures a little bit is leading here,

770
01:01:38,110 --> 01:01:42,010
but here's text, here zero it goes up to some number

771
01:01:42,190 --> 01:01:44,470
and basically the first instruction whatever sits here,

772
01:01:44,800 --> 01:01:46,540
that's the first instruction that we're gonna actually,

773
01:01:46,540 --> 01:01:49,930
that address, that's the first instruction, we're going to get a page fault, right.

774
01:01:51,190 --> 01:01:52,990
Because we have not loaded it.

775
01:02:02,940 --> 01:02:04,140
So what do you want the page fault.

776
01:02:07,930 --> 01:02:09,400
Well we're going to do in the page fault,

777
01:02:09,550 --> 01:02:14,950
it's basically will note that this is one of these on demand pages,

778
01:02:15,420 --> 01:02:18,360
we have to remember somewhere earlier,

779
01:02:18,360 --> 01:02:23,690
that you know this corresponds to some, that this corresponds to some file.

780
01:02:25,920 --> 01:02:38,970
Imagine what we're gonna do in the page fault handler is read, you know that block page from file into memory,

781
01:02:41,890 --> 01:02:46,840
map the memory into the pagetable,

782
01:02:49,460 --> 01:02:50,870
then restart the instruction,

783
01:02:56,720 --> 01:02:59,300
and, then we're off for running right.

784
01:02:59,300 --> 01:03:01,640
And so we're gonna go in the worst case,

785
01:03:01,640 --> 01:03:05,480
if the user program uses all of its text, uses all of this data,

786
01:03:05,600 --> 01:03:11,900
then we're going to get a page fault for every page, you know in the, in the program.

787
01:03:12,590 --> 01:03:15,050
But you know we get lucky in the program,

788
01:03:15,050 --> 01:03:16,700
it doesn't use all of its data segment

789
01:03:16,700 --> 01:03:18,260
or doesn't use all of its text segment,

790
01:03:18,380 --> 01:03:20,630
then we might save some memory

791
01:03:20,630 --> 01:03:24,970
and we certainly make exec you know perform, you know, much quicker

792
01:03:24,970 --> 01:03:26,620
and it'll be a little bit more interactive,

793
01:03:26,770 --> 01:03:28,480
assumes the program starts boom it's running,

794
01:03:28,930 --> 01:03:31,240
well we actually have to do any work exactly.

795
01:03:33,480 --> 01:03:35,310
Does that makes this observation makes sense?

796
01:03:42,140 --> 01:03:53,470
Okay so there's a slight extension to demand paging, so this is the second part of the demand paging.

797
01:03:59,150 --> 01:04:00,140
Right, there's more.

798
01:04:04,960 --> 01:04:06,490
Part two demand paging,

799
01:04:06,730 --> 01:04:09,100
in principle, there's a little bit of problem here,

800
01:04:09,130 --> 01:04:10,630
that we haven't really discussed,

801
01:04:10,990 --> 01:04:12,220
it might be the case,

802
01:04:12,250 --> 01:04:14,290
may be the file that we're actually reading

803
01:04:14,290 --> 01:04:17,620
or the text and data segments are even bigger than what actually is in physical memory,

804
01:04:17,650 --> 01:04:21,820
or if multiple applications started with demand paging,

805
01:04:21,850 --> 01:04:27,280
maybe there's some of their binarys, it's basically bigger than there actually is a physical memory.

806
01:04:28,700 --> 01:04:34,010
And so, the typical thing you know what, if you go down this demand paging,

807
01:04:34,010 --> 01:04:37,820
[] is to actually if you run out of memory,

808
01:04:38,990 --> 01:04:42,410
so if kalloc returns zero, it's out of memory.

809
01:04:45,440 --> 01:04:48,310
So, for example, you know your demand page,

810
01:04:48,340 --> 01:04:55,780
you get a page fault at some page, that needs to be a paged in from a file system,

811
01:04:56,050 --> 01:04:59,170
but you don't have any more free pages, you need to do something.

812
01:04:59,720 --> 01:05:02,570
And so the typical this comes back to earlier question,

813
01:05:02,570 --> 01:05:05,090
for example the same is to for lazy or

814
01:05:05,510 --> 01:05:07,070
you know what to do if you run out of memory.

815
01:05:07,610 --> 01:05:08,720
So if you run out of memory,

816
01:05:08,720 --> 01:05:14,240
one option that you really clearly have is to evict a page.

817
01:05:19,260 --> 01:05:24,210
You can for example instead of you know you can for example and pick the page and write to the file back.

818
01:05:25,020 --> 01:05:28,710
So for example it's a data page that got modified,

819
01:05:28,710 --> 01:05:31,200
so you can write it back to the file system.

820
01:05:32,160 --> 01:05:34,770
And then once you pick the page

821
01:05:34,800 --> 01:05:36,420
and then you have a new free page

822
01:05:36,750 --> 01:05:42,510
and you can put the use that you use the new just free page,

823
01:05:47,020 --> 01:05:50,440
to satisfy you know the fault that you had

824
01:05:50,650 --> 01:05:52,570
and then basically restarting instruction again.

825
01:05:58,810 --> 01:06:00,880
Again, restarting instruction is a little more complicated,

826
01:06:00,880 --> 01:06:04,390
because the whole machinery to basically do userret

827
01:06:04,780 --> 01:06:09,310
and started and transfer back to user space, etc.

828
01:06:11,070 --> 01:06:13,950
And so this is a typical operating system will do this

829
01:06:14,010 --> 01:06:17,760
and of course the key question is like what page to evict.

830
01:06:19,890 --> 01:06:21,180
Which one to choose?

831
01:06:22,340 --> 01:06:24,110
So what are some candidates

832
01:06:24,110 --> 01:06:28,860
you know what do, what would be a reasonable policy for choosing a page to evict.

833
01:06:30,280 --> 01:06:31,630
Least recently used.

834
01:06:31,930 --> 01:06:45,290
Yeah, so this is the most commonly used strategy, least recently used, or LRU.

835
01:06:47,860 --> 01:06:53,050
And, that was gonna page was typically is thrown out,

836
01:06:53,500 --> 01:06:58,120
there's a couple sort of twist typically [] some small optimizations that do,

837
01:06:58,420 --> 01:07:00,190
if you have to pick the page

838
01:07:00,190 --> 01:07:04,760
and you have to choice between dirty page and non-dirty page,

839
01:07:04,760 --> 01:07:07,100
so dirty pages page where there was a store to

840
01:07:07,520 --> 01:07:11,450
and non-dirty pages or pages basically has been read, but not written to,

841
01:07:11,750 --> 01:07:14,550
which one would you prefer evict first.

842
01:07:16,700 --> 01:07:21,290
Dirty one, because you would have to write the dirty one at some point anyway.

843
01:07:21,840 --> 01:07:22,830
Yeah.

844
01:07:23,460 --> 01:07:26,460
So sorry, say again actually just double-check there.

845
01:07:27,130 --> 01:07:32,650
I said dirty, because dirty pages would need to be written into memory at some point.

846
01:07:33,180 --> 01:07:37,740
Yeah that's true, then maybe now you have to write it twice,

847
01:07:37,770 --> 01:07:40,320
you know once you write it may be modified later again.

848
01:07:41,490 --> 01:07:42,750
And so actually typically.

849
01:07:42,870 --> 01:07:45,120
OK OK's I see.

850
01:07:45,120 --> 01:07:50,320
Exactly the opposite, they choose a page that actually has not been written or it's not dirty,

851
01:07:50,320 --> 01:07:51,550
because you don't have to do anything,

852
01:07:51,700 --> 01:07:52,780
you can just reuse it,

853
01:07:52,810 --> 01:07:57,880
you can just take mark if it is present in in pagetable one,

854
01:07:57,910 --> 01:08:01,150
you mark there is non valid and then you're done.

855
01:08:01,700 --> 01:08:04,550
And then you can reuse that page in another pagetable.

856
01:08:05,340 --> 01:08:11,490
And so the preference intensity is a take pages that have been not non-dirty ones first.

857
01:08:13,600 --> 01:08:17,900
Can I just ask for a clarification on the dirty pages.

858
01:08:18,400 --> 01:08:18,730
Yeah.

859
01:08:18,730 --> 01:08:23,620
So, I I know, like in a cache,

860
01:08:23,620 --> 01:08:26,590
when we have memory and then we say okay a line is dirty,

861
01:08:26,590 --> 01:08:28,360
because it hasn't been written to memory,

862
01:08:28,540 --> 01:08:32,650
but what about a page in memory like what does it correspond to like, how is it dirty,

863
01:08:32,650 --> 01:08:34,570
where does it have to be written back to,

864
01:08:34,690 --> 01:08:36,250
it just exists in memory right,

865
01:08:36,250 --> 01:08:39,820
isn't that the whole whole thing like it doesn't exist anywhere else really,

866
01:08:40,120 --> 01:08:41,410
so when can it be dirty.

867
01:08:41,890 --> 01:08:44,470
Yeah okay, so for example if the demand page file page,

868
01:08:45,290 --> 01:08:47,000
actually we'll talk about in a second,

869
01:08:47,000 --> 01:08:50,930
like in the next, maybe a little bit too much,

870
01:08:50,960 --> 01:08:53,600
but if you memory map files,

871
01:08:53,630 --> 01:08:58,250
where you map a file into memory,

872
01:08:58,250 --> 01:09:00,890
and then do store to it, then you would dirty that page.

873
01:09:01,280 --> 01:09:02,630
Okay so that only applies

874
01:09:02,630 --> 01:09:08,090
when like a page actually response not just to some memory, but also to a file or something else.

875
01:09:08,270 --> 01:09:10,360
Okay, okay, that makes sense.

876
01:09:10,570 --> 01:09:10,870
Yeah.

877
01:09:13,020 --> 01:09:18,280
Okay, so just to, you know just to make one more two more points related to this,

878
01:09:18,580 --> 01:09:22,510
if you look at this pte again,

879
01:09:23,220 --> 01:09:24,900
so we saw this RSW bit,

880
01:09:25,050 --> 01:09:28,650
you'll notice there actually is a bit seven, that is the dirty bit.

881
01:09:29,320 --> 01:09:33,340
So when the paging hardware where the hardware ever writes you know to page

882
01:09:33,340 --> 01:09:34,690
then [watch] this set dirty bits,

883
01:09:34,840 --> 01:09:36,280
so the operating system later can see,

884
01:09:36,280 --> 01:09:39,940
, oh, this actually page can easily see this page that's actually written to.

885
01:09:41,290 --> 01:09:47,700
And similarly there is a A bit, that stands for access,

886
01:09:48,760 --> 01:09:54,520
and so whenever pages either written or written either read or written the access bit will be set.

887
01:09:55,090 --> 01:09:58,540
And, and why is it useful to know?

888
01:10:07,430 --> 01:10:09,080
In one way, could that help the kernel?

889
01:10:09,730 --> 01:10:15,040
Well, the ones that haven't been accessed, you can, you can evict right.

890
01:10:15,650 --> 01:10:19,580
Yeah, what are you saying that if you want to implement these recently used,

891
01:10:20,280 --> 01:10:25,590
if, if you find a page that basically hasn't been accessed in some period of time,

892
01:10:25,590 --> 01:10:27,390
you know it actually hasn't been recently used,

893
01:10:27,420 --> 01:10:29,190
so it actually is a candidate for eviction,

894
01:10:29,460 --> 01:10:33,450
while the pages that have the access bit set are not really candidates for eviction.

895
01:10:34,990 --> 01:10:41,680
So, A bit typically used where actually is typically used to implement this LRU strategy.

896
01:10:44,540 --> 01:10:53,540
Okay, but would you have to reset the access bits to not access every once in a while.

897
01:10:53,570 --> 01:10:56,480
Exactly, that's exactly what the typical operation system will do.

898
01:10:57,170 --> 01:10:59,510
And if they [] even maybe for all memory,

899
01:10:59,510 --> 01:11:02,480
they [sweep] for memory [],

900
01:11:02,480 --> 01:11:06,020
famous algorithm, which is called the clock algorithm that is one way of doing it.

901
01:11:10,810 --> 01:11:14,200
[] why would you need to set it, why would you to reset it.

902
01:11:14,740 --> 01:11:17,350
Well, if you want to know when our pages recently used,

903
01:11:17,410 --> 01:11:20,380
you need and you make a periodic decision,

904
01:11:20,800 --> 01:11:24,160
then say maybe every hundred milliseconds or whatever every seconds,

905
01:11:24,160 --> 01:11:25,960
you clear the access bit,

906
01:11:26,320 --> 01:11:28,780
yeah it gets access in the next hundred milliseconds,

907
01:11:28,780 --> 01:11:30,760
you know it was used in the last hundred milliseconds.

908
01:11:32,730 --> 01:11:36,840
And the pages that don't have the access bit set were not used in last in the milliseconds.

909
01:11:39,150 --> 01:11:42,120
And so then you can keep counters with how intentionally they used

910
01:11:42,120 --> 01:11:48,210
and what is and for really especially the [steppingstone] to [sophisticate] our implementation.

911
01:11:52,840 --> 01:11:53,800
Okay.

912
01:11:55,350 --> 01:11:58,500
I want to talk about one more used to,

913
01:11:59,310 --> 01:12:04,740
the last one actually you also will be implementing in one of the labs.

914
01:12:05,440 --> 01:12:07,900
And that is a memory mapped files.

915
01:12:21,140 --> 01:12:25,340
The idea is that you know we're we have our address space,

916
01:12:25,760 --> 01:12:31,220
what we really want to do is basically be able to load the whole file or parts of the file into the address space,

917
01:12:31,370 --> 01:12:35,390
so that we can just manipulate the content of the file using load store instructions,

918
01:12:36,650 --> 01:12:41,840
instead of read else you can write.

919
01:12:42,400 --> 01:12:43,840
And to be able to support that,

920
01:12:43,840 --> 01:12:50,470
you know a typical operating system where most modern operating systems called provide a system call mmap,

921
01:12:52,120 --> 01:13:01,770
and basically mmap takes a virtual address or pick some virtual address length, protection, flags,

922
01:13:02,420 --> 01:13:03,410
we're going to talk about

923
01:13:03,710 --> 01:13:07,520
and then file descriptor of an open file and an offset.

924
01:13:08,960 --> 01:13:11,090
Maybe [with] this's like you should

925
01:13:11,120 --> 01:13:16,460
map you know this file descriptor to this addressing a virtual address,

926
01:13:16,460 --> 01:13:21,380
you know file descriptor starting from offset in the file f,

927
01:13:21,710 --> 01:13:25,490
you know map that in at the address at the virtual address va.

928
01:13:26,420 --> 01:13:29,720
And do that we have some protection read, write etc.

929
01:13:30,830 --> 01:13:32,150
So let's say is read write,

930
01:13:32,270 --> 01:13:39,980
then you know the kernel when and so, the way it currently implements mmap is,

931
01:13:40,190 --> 01:13:43,730
it does eagerly, which is like most systems does do it eagerly,

932
01:13:43,940 --> 01:13:48,200
basically copy, read all the bytes starting from offset,

933
01:13:48,410 --> 01:13:51,650
[] bytes starting from offset into memory,

934
01:13:51,770 --> 01:13:59,450
sets up the ptes to point to the physical memory for blocks are located

935
01:13:59,660 --> 01:14:08,680
and basically from then on the application use [], use load and store instructions to actually modify the file

936
01:14:08,830 --> 01:14:11,530
and the maybe when they were all done,

937
01:14:11,770 --> 01:14:14,500
there's typically a corresponding unmap call,

938
01:14:14,860 --> 01:14:22,310
that, and at length, then allows the application to say, OK I'm done with this particular file

939
01:14:22,370 --> 01:14:26,030
and at the point of unmap and we need to write back the dirty blocks.

940
01:14:32,190 --> 01:14:34,410
And we can easily figure out which blocks are dirty,

941
01:14:34,620 --> 01:14:37,680
because they have D bit set into pte.

942
01:14:38,660 --> 01:14:43,370
Now, of course in any memory or sophisticated memory implementation,

943
01:14:43,640 --> 01:14:45,500
this is all done [lately],

944
01:14:45,500 --> 01:14:47,570
you know you just don't map the file immediately,

945
01:14:47,780 --> 01:14:49,820
you just keep a record somewhere on the [],

946
01:14:49,820 --> 01:14:54,530
saying like well you know this PTE really belongs to this particular file descriptor,

947
01:14:54,530 --> 01:14:57,140
so there's some information maintained on the side

948
01:14:57,140 --> 01:15:02,260
which is typically called in a structure called the vma or the virtual memory area.

949
01:15:07,810 --> 01:15:10,210
For example, for this file f would be one vma

950
01:15:10,210 --> 01:15:14,320
and in a vma we record the file descriptor the offset etc,

951
01:15:14,560 --> 01:15:17,950
where the actual content that then we should live

952
01:15:17,950 --> 01:15:23,680
and so when we get a page fault for a particular address that's in this vma,

953
01:15:23,740 --> 01:15:28,480
then we can go off and the kernel can read it from disk and bring it into memory.

954
01:15:30,340 --> 01:15:32,440
And in response to an earlier question

955
01:15:32,440 --> 01:15:34,480
is one of the reasons that this dirty bit is important,

956
01:15:34,480 --> 01:15:37,510
because as mmap, you have to write back the dirty blocks.

957
01:15:40,930 --> 01:15:41,770
Does this make sense?

958
01:15:43,960 --> 01:15:45,100
I have a question.

959
01:15:46,510 --> 01:15:49,450
Maybe this is a more general issue,

960
01:15:49,450 --> 01:15:56,230
but could it ever be an issue of say multiple process [] are memory mapping the same file on secondary storage

961
01:15:56,290 --> 01:15:58,740
and then like [synchronization] is.

962
01:15:59,130 --> 01:16:03,300
Good question, so what is the semantics in Unix in general

963
01:16:03,300 --> 01:16:08,070
like what happens if multiple processes read or write to the same file using read or write system calls.

964
01:16:18,930 --> 01:16:20,430
Did you needs guarantee anything.

965
01:16:22,500 --> 01:16:23,700
It's undefined.

966
01:16:24,560 --> 01:16:28,730
Yeah yeah there's like no the reason write will show up in some order

967
01:16:28,820 --> 01:16:30,590
or the writes will show up in some order,

968
01:16:30,620 --> 01:16:34,240
so if two process you write to the same block of the file,

969
01:16:34,330 --> 01:16:38,380
you know either the first process writes go or the second process writes go, one of two.

970
01:16:38,940 --> 01:16:40,530
And so here's basically the same thing,

971
01:16:40,530 --> 01:16:42,120
we don't really have to guarantee anything.

972
01:16:42,980 --> 01:16:47,210
If you want to do a more sophisticated Unix operating system support file locking,

973
01:16:47,760 --> 01:16:51,840
where you can lock files and then you can properly synchronize,

974
01:16:52,080 --> 01:16:57,100
by default, there's no synchronization, or no synchronization at this level.

975
01:17:01,880 --> 01:17:02,450
That makes sense?

976
01:17:04,440 --> 01:17:07,470
I'm sorry, what is length and what is flags.

977
01:17:07,830 --> 01:17:13,320
Of [like] length is the length of the you know the area you want to map the file number of bytes.

978
01:17:13,890 --> 01:17:19,080
Flags read write X flags, you know you'll see that when you do a map,

979
01:17:19,080 --> 01:17:23,640
I think this has to do with whether the area is mapped private or shared.

980
01:17:24,250 --> 01:17:28,450
If it's mapped shared and then it can be shared among multiple processes.

981
01:17:35,160 --> 01:17:36,450
Any further questions about this?

982
01:17:41,540 --> 01:17:44,570
If some other process modifies the file in this,

983
01:17:44,600 --> 01:17:47,750
that means that this will not be reflected here, right.

984
01:17:48,470 --> 01:17:54,200
That's correct, unless I think if mapped shared, then you're supposed to reflect those changes.

985
01:17:55,030 --> 01:17:57,940
Right, but then they would be using the same file descriptor.

986
01:18:01,240 --> 01:18:04,990
I'm hazy on the exact semantics of mmap,

987
01:18:04,990 --> 01:18:07,360
when things are shared and what exactly happens there.

988
01:18:08,220 --> 01:18:10,770
Okay I guess so I guess in like the idiomatic case,

989
01:18:10,770 --> 01:18:14,070
and shared they would have to reflect it,

990
01:18:14,070 --> 01:18:20,820
but if a process just like actually open the same file name completely set separately I think,

991
01:18:21,540 --> 01:18:23,850
it could be a [un synced], even if it's shared.

992
01:18:31,040 --> 01:18:36,890
Okay, so, so this is after the file system lab, you actually do memory map files.

993
01:18:37,420 --> 01:18:40,510
And that will be our last virtual memory sort of lab,

994
01:18:40,540 --> 01:18:46,240
unless you decide at the end to do more virtual memory features or exercises or whatever you wanna do,

995
01:18:46,660 --> 01:18:50,440
you know the main job is to conclude this lecture.

996
01:18:51,100 --> 01:18:53,210
The, sort of summary.

997
01:18:56,000 --> 01:19:01,370
You know, we've lived in the past, in terms of great detail exactly how pagetables work.

998
01:19:03,050 --> 01:19:05,510
We've done a couple labs, one lab of the pagetables,

999
01:19:05,510 --> 01:19:10,810
we've looked a lot like how traps work, and you know page fault,

1000
01:19:11,170 --> 01:19:13,990
and it turns out if you combine the two,

1001
01:19:16,250 --> 01:19:24,620
now you're gonna implement very powerful and elegant virtual memory features.

1002
01:19:25,780 --> 01:19:27,580
And you know went through a whole list of them,

1003
01:19:28,030 --> 01:19:31,990
mostly focusing on the ones, that actually going to be implementing future lab,

1004
01:19:32,380 --> 01:19:34,810
but you know this is only a subset,

1005
01:19:34,840 --> 01:19:41,840
for example of the ones that you know some operating systems implement the typical operating system to implement all the ones that actually discussed today.

1006
01:19:42,400 --> 01:19:44,170
If you look at Linux and as all of them.

1007
01:19:45,800 --> 01:19:47,900
And many more interesting other tricks,

1008
01:19:47,960 --> 01:19:51,950
but this hopefully gives you good sense, you know sort out the power of virtual memory,

1009
01:19:52,190 --> 01:19:56,240
once you dynamically can change the pagetables in the page fault handler.

1010
01:19:59,010 --> 01:20:01,410
I think there's exactly at 25,

1011
01:20:01,410 --> 01:20:03,180
so maybe that's a good point to stop,

1012
01:20:03,180 --> 01:20:05,340
but if you have any questions, feel free to ask them.

1013
01:20:08,250 --> 01:20:11,040
If not, you know we should, good luck finishing the trap lab.

1014
01:20:11,870 --> 01:20:14,420
I hope it's not as painful as the year,

1015
01:20:15,510 --> 01:20:17,970
we're not as hard as the pagetable lab.

1016
01:20:21,650 --> 01:20:23,390
Sorry I had another question,

1017
01:20:23,390 --> 01:20:25,940
when you map in the previous slide,

1018
01:20:25,970 --> 01:20:30,650
when you map the whole file or when you put it into memory,

1019
01:20:30,770 --> 01:20:37,200
and it turns out to be longer than length, then, what happens.

1020
01:20:37,680 --> 01:20:40,230
Sorry if the file doesn't fit in the virtual address space?

1021
01:20:41,040 --> 01:20:47,490
Oh I guess it was like length is how much of the file, we want.

1022
01:20:48,390 --> 01:20:54,630
Yes, so length, just like we want to map like ten bytes out of the file descriptor starting at offset off.

1023
01:20:55,580 --> 01:20:58,670
Oh, okay, okay, so if the file is longer than,

1024
01:20:58,670 --> 01:21:01,640
we're not gonna put all of it into memory.

1025
01:21:03,610 --> 01:21:05,320
Okay I see, thank you.

1026
01:21:08,500 --> 01:21:13,870
I got a question, I've got a question on the evicting pages.

1027
01:21:15,300 --> 01:21:19,140
So basically we talked about it after the demand paging part two,

1028
01:21:19,140 --> 01:21:21,000
but is that a general procedure,

1029
01:21:21,000 --> 01:21:22,590
we would use in any of these techniques,

1030
01:21:22,590 --> 01:21:24,930
if we discover that we're out of physical boundary.

1031
01:21:24,960 --> 01:21:27,720
Yeah that's just the common majorly mechanism,

1032
01:21:27,720 --> 01:21:30,210
like, so even in lazy allocation,

1033
01:21:30,210 --> 01:21:35,910
we run at the point where there's no memory available anymore to allocate to the page

1034
01:21:36,150 --> 01:21:38,490
and you know we support demand paging

1035
01:21:38,490 --> 01:21:42,180
or whatever we evict you know some page you typically using LRU.

1036
01:21:43,440 --> 01:21:43,770
Okay.

1037
01:21:43,950 --> 01:21:46,590
One way to think about is that in steady state,

1038
01:21:46,590 --> 01:21:51,930
the operating system basically runs with all memory in use at any time.

1039
01:21:52,520 --> 01:21:56,180
And want to use all memory

1040
01:21:56,690 --> 01:21:58,340
and so when we start something new,

1041
01:21:58,370 --> 01:21:59,840
you know we have to make some room

1042
01:21:59,900 --> 01:22:01,940
and LRU is basically a way to do it.

1043
01:22:03,290 --> 01:22:05,000
Okay, makes sense, thank you.

