1
00:00:00,000 --> 00:00:05,700
我开始了，大家能看到我分享的屏幕吗？

2
00:00:06,700 --> 00:00:08,830
我希望每个人都能听到我说话。

3
00:00:11,630 --> 00:00:12,230
让我。

4
00:00:12,970 --> 00:00:13,600
我想是好的。

5
00:00:13,780 --> 00:00:18,180
好的，今天我要讨论一下文件系统，

6
00:00:18,210 --> 00:00:23,100
我们会用三节课来讲解文件系统，

7
00:00:23,310 --> 00:00:28,200
两节在 xv6 环境中，一节在 Linux 环境中。

8
00:00:28,690 --> 00:00:35,770
实际上，这是关于 xv6 的最后一个话题，

9
00:00:35,770 --> 00:00:39,520
这周过后，我们基本上完成了 xv6 。

10
00:00:40,230 --> 00:00:46,470
所以，文件系统，你们都知道，并使用它，

11
00:00:46,560 --> 00:00:52,980
它是操作系统中最面向用户的方面之一，

12
00:00:52,980 --> 00:00:54,360
除了 shell 。

13
00:00:54,600 --> 00:00:57,930
所以，我们现在想知道，

14
00:00:57,930 --> 00:00:59,340
而这几节课讲的就是，

15
00:00:59,340 --> 00:01:00,810
文件系统底层到底发生了什么，

16
00:01:00,960 --> 00:01:02,880
以及它是如何实现的。

17
00:01:02,880 --> 00:01:05,940
这让人兴奋，因为你一直在使用它。

18
00:01:06,520 --> 00:01:11,320
也许在深入任何细节之前，我们先来问个问题，

19
00:01:11,680 --> 00:01:16,900
在某种程度上，因为你几乎每天都在使用文件系统，

20
00:01:16,990 --> 00:01:20,200
在某种程度上， xv6 文件系统不同于

21
00:01:20,200 --> 00:01:25,570
你日常使用的文件系统。

22
00:01:26,460 --> 00:01:27,840
我会把它们提供给大家，

23
00:01:27,840 --> 00:01:30,170
看看他们是怎么想的。

24
00:01:30,170 --> 00:01:33,140
比如 Kendall ， Kendall Garner 。

25
00:01:34,700 --> 00:01:38,120
你有没有注意到 xv6 有什么不同或相似之处？

26
00:01:45,850 --> 00:01:47,710
我不确定我们能不能听到你， Kendall 。

27
00:01:49,500 --> 00:01:50,670
我在这里。

28
00:01:51,320 --> 00:01:51,830
好的。

29
00:01:51,980 --> 00:01:52,850
好的。

30
00:01:52,880 --> 00:01:53,780
好的。

31
00:01:53,900 --> 00:01:55,940
所以其中一个问题就是大小，

32
00:01:56,090 --> 00:01:59,510
或者至少 xv6 支持的文件的大小

33
00:01:59,510 --> 00:02:01,790
比许多其他文件系统小得多，

34
00:02:01,790 --> 00:02:05,060
另外，有些文件的名称相对较短。

35
00:02:05,590 --> 00:02:10,720
还有一个功能，更多的是使用[][]，

36
00:02:10,930 --> 00:02:11,350
它没有，

37
00:02:11,350 --> 00:02:14,020
我认为它没有文件系统的写入时复制。

38
00:02:15,590 --> 00:02:17,930
很好，有什么相似之处。

39
00:02:20,120 --> 00:02:23,120
它在总体结构上是相似的，

40
00:02:23,150 --> 00:02:26,600
所以有文件名，

41
00:02:26,600 --> 00:02:29,090
有 inode ，目录等等。

42
00:02:30,360 --> 00:02:32,240
是的，不错。

43
00:02:32,330 --> 00:02:36,940
那 Adella Yang 呢。

44
00:02:38,790 --> 00:02:42,900
你如何比较 xv6 文件系统与你使用的文件系统。

45
00:02:47,380 --> 00:02:48,190
抱歉，是什么。

46
00:02:48,670 --> 00:02:50,290
问题是，你会如何，

47
00:02:50,320 --> 00:02:52,870
你如何比较 xv6 文件系统

48
00:02:52,900 --> 00:02:55,570
与你在日常生活中使用的文件系统，

49
00:02:55,990 --> 00:02:57,130
或者在你的笔记本电脑上，

50
00:02:57,130 --> 00:02:58,600
不管你用的是什么电脑。

51
00:03:00,700 --> 00:03:03,250
有没有相似之处。

52
00:03:04,460 --> 00:03:08,240
是的，比如文件系统的路径系统，

53
00:03:08,480 --> 00:03:14,230
比如路径和文件系统是分层的。

54
00:03:16,060 --> 00:03:17,890
是的，这是一个很好的观点。

55
00:03:18,220 --> 00:03:19,900
好的，所以，

56
00:03:19,900 --> 00:03:22,450
所以让我，稍微深入一点，

57
00:03:22,450 --> 00:03:25,120
稍微谈一下文件系统的属性，

58
00:03:25,120 --> 00:03:27,130
有点[突出]，

59
00:03:27,520 --> 00:03:30,850
有一个我想你刚才在这里提到的，

60
00:03:30,850 --> 00:03:39,960
是用户友好的命名，

61
00:03:40,980 --> 00:03:45,000
特别是路径名，它的层次结构，

62
00:03:45,120 --> 00:03:48,900
帮助人们组织他们的文件和目录，

63
00:03:48,900 --> 00:03:51,390
无论你想使用什么术语，

64
00:03:51,810 --> 00:03:56,190
它使人们共享文件更方便，

65
00:03:58,850 --> 00:04:03,840
在用户和进程之间。

66
00:04:04,830 --> 00:04:09,780
你可以方便地给它们命名。

67
00:04:10,390 --> 00:04:12,100
然后可能最重要的是，

68
00:04:12,130 --> 00:04:16,960
至少为目前我们在 xv6 中看到的所有子系统做好了准备，

69
00:04:17,020 --> 00:04:18,370
它们提供了持久化存储，

70
00:04:21,770 --> 00:04:23,450
或者有时候被称为耐久性。

71
00:04:26,440 --> 00:04:29,020
我的意思是，如果你关掉电脑，

72
00:04:29,140 --> 00:04:30,340
你做了一些工作，

73
00:04:30,340 --> 00:04:32,590
关掉了电脑或者笔记本电脑，

74
00:04:32,980 --> 00:04:35,800
几天后你回来，

75
00:04:35,800 --> 00:04:36,970
重新打开电脑，

76
00:04:37,090 --> 00:04:38,380
文件还在那里，

77
00:04:39,030 --> 00:04:42,420
你可以继续使用它们工作。

78
00:04:43,200 --> 00:04:45,720
这不同于进程，

79
00:04:45,720 --> 00:04:48,990
或者目前为止我们看到的资源，

80
00:04:48,990 --> 00:04:52,620
如果计算机重新启动，它们消失了，

81
00:04:52,620 --> 00:04:53,880
你必须重新开始，

82
00:04:53,880 --> 00:04:56,430
但是文件系统可以提供这种持久性。

83
00:04:57,060 --> 00:05:01,220
所以它们是，你们所有人都在使用它们，

84
00:05:01,340 --> 00:05:03,320
接下来几节课我们要做的是，

85
00:05:03,320 --> 00:05:06,050
了解它在内部是如何工作的。

86
00:05:06,650 --> 00:05:09,260
这很有趣，有很多原因。

87
00:05:18,080 --> 00:05:23,640
一个是抽象本身，它是有用的。

88
00:05:27,150 --> 00:05:29,340
所以理解幕后很有趣，

89
00:05:29,340 --> 00:05:31,530
实际上，它的抽象是如何实现的。

90
00:05:32,100 --> 00:05:35,640
这里面有几个关键的有趣的方面。

91
00:05:35,670 --> 00:05:38,310
一个是崩溃安全，

92
00:05:43,140 --> 00:05:44,130
它是这种情况，

93
00:05:44,130 --> 00:05:48,330
比如在文件系统操作期间，

94
00:05:48,330 --> 00:05:50,640
计算机崩溃了，

95
00:05:50,820 --> 00:05:54,690
在重启后，文件系统仍然保持完好，

96
00:05:54,690 --> 00:05:58,380
文件系统的所有变量仍然存在，

97
00:05:58,560 --> 00:06:00,810
而且你可以访问你的大部分文件，

98
00:06:01,050 --> 00:06:02,070
这会是一场灾难，

99
00:06:02,070 --> 00:06:04,890
如果计算机在文件系统操作过程中崩溃，

100
00:06:05,290 --> 00:06:07,690
你重新启动，但是没有了文件系统，

101
00:06:07,720 --> 00:06:10,060
或者磁盘上的数据结构已损坏，

102
00:06:10,330 --> 00:06:12,580
你丢失了它们。

103
00:06:13,240 --> 00:06:18,790
所以这是一个非常重要的话题，[]

104
00:06:19,090 --> 00:06:21,550
所以我们将在周三讨论这个，

105
00:06:21,550 --> 00:06:23,740
这是周三课程的主要话题。

106
00:06:26,810 --> 00:06:28,520
然后有一个一般性问题，

107
00:06:28,520 --> 00:06:33,510
关于文件系统在磁盘上如何安排。

108
00:06:35,000 --> 00:06:38,330
你知道，这些文件，这些目录，

109
00:06:38,420 --> 00:06:41,240
它们都必须以某种方式在磁盘上表示，

110
00:06:41,240 --> 00:06:44,030
因为如果你关机后，再回来，

111
00:06:44,030 --> 00:06:46,160
所有的数据还得在那里，

112
00:06:46,160 --> 00:06:48,440
所以在这个数据结构上

113
00:06:48,620 --> 00:06:52,080
以表示文件系统的数据结构

114
00:06:52,080 --> 00:06:53,520
或者文件系统的内容。

115
00:06:54,480 --> 00:06:56,010
在 xv6 中，

116
00:06:56,010 --> 00:07:01,110
当然表示或数据结构非常简单，

117
00:07:01,110 --> 00:07:03,830
只是出于教学上的原因，

118
00:07:03,830 --> 00:07:07,070
而真实的文件系统有更复杂的数据结构，

119
00:07:07,070 --> 00:07:09,530
但是你可以把它想象成在这个数据结构上。

120
00:07:10,840 --> 00:07:13,300
所以我们会在今天的课程中看到很多这样的内容。

121
00:07:13,630 --> 00:07:18,130
最后，让它变得有趣的是性能。

122
00:07:20,360 --> 00:07:25,610
通常存储文件系统的设备，

123
00:07:25,610 --> 00:07:28,340
存储设备通常很慢。

124
00:07:35,930 --> 00:07:38,150
比如，读或写一个块，

125
00:07:38,150 --> 00:07:42,890
在 SSD 固态硬盘上的速度是 1 毫秒，

126
00:07:43,160 --> 00:07:45,860
而在 1 毫秒内，你可以做大量的工作。

127
00:07:46,340 --> 00:07:50,450
所以，尽量避免使用磁盘是很重要的，

128
00:07:50,840 --> 00:07:52,250
我们会看到有多种方法，

129
00:07:52,250 --> 00:07:52,940
我们会看到，

130
00:07:52,940 --> 00:07:56,630
比如，所有文件系统都有某种缓冲区缓存

131
00:07:56,720 --> 00:07:57,800
或块缓存。

132
00:08:01,300 --> 00:08:06,040
而且你还可以看到更多形式或更多的并发性。

133
00:08:06,800 --> 00:08:10,910
比如，如果你执行路径名查找，

134
00:08:11,000 --> 00:08:14,660
通常是关联的操作，

135
00:08:14,660 --> 00:08:16,670
按层级查找目录，

136
00:08:16,670 --> 00:08:20,520
你查找目录[]，

137
00:08:20,520 --> 00:08:21,930
在目录中查找文件名，

138
00:08:21,930 --> 00:08:23,970
然后检查下一个目录，等等，

139
00:08:24,300 --> 00:08:25,770
你想要的情况是，

140
00:08:25,770 --> 00:08:28,260
如果一个进程正在进行路径名查找，

141
00:08:28,260 --> 00:08:31,470
另一进程可以并发或并行运行。

142
00:08:31,500 --> 00:08:33,960
与第一个查找路径名的进程一起。

143
00:08:34,860 --> 00:08:37,500
所以我们会看到并发出现，

144
00:08:37,590 --> 00:08:40,770
这也是文件系统中的一个大的话题。

145
00:08:42,840 --> 00:08:44,970
有趣的另一个原因是

146
00:08:44,970 --> 00:08:46,650
它将成为两个实验的主题。

147
00:08:47,580 --> 00:08:52,470
我们接下来的实验将完全集中在文件系统上，

148
00:08:52,470 --> 00:08:56,130
之后的实验是虚拟内存和文件系统的组合，

149
00:08:56,130 --> 00:08:58,980
即使是今天或本周的实验，

150
00:08:58,980 --> 00:09:03,030
也有一个组件试图让缓冲区缓存更加并行。

151
00:09:05,180 --> 00:09:06,950
所以这就是为什么它很有趣的原因，

152
00:09:08,360 --> 00:09:10,910
你应该开始

153
00:09:10,970 --> 00:09:14,420
了解文件系统必须提供什么，

154
00:09:14,510 --> 00:09:19,190
让我们再来看看基本的文件系统调用，

155
00:09:19,810 --> 00:09:27,350
去看 API 示例。

156
00:09:27,350 --> 00:09:30,920
如果你查看这些文件系统调用的 API ，

157
00:09:30,980 --> 00:09:33,350
然后我们可以看到这里有几个有趣的属性，

158
00:09:33,350 --> 00:09:35,150
关于实现，它们一定是真的。

159
00:09:35,870 --> 00:09:39,710
所以文件系统调用，

160
00:09:42,810 --> 00:09:47,200
我们在这个学期的早些时候就见过它们，

161
00:09:47,290 --> 00:09:51,850
我们看过大多数其他 Unix 系统调用如何实现它，

162
00:09:51,850 --> 00:09:54,820
比如 dork exec 和管道，所有的东西，

163
00:09:54,910 --> 00:09:57,280
基本上，这几节课的重点是

164
00:09:57,280 --> 00:09:59,200
如何实现文件系统调用。

165
00:10:00,400 --> 00:10:06,670
首先，让我们从一个简单的情况开始。

166
00:10:08,640 --> 00:10:12,510
假设我们创建了一个文件 x/y ，

167
00:10:13,080 --> 00:10:19,740
或者文件 y 在目录 x 中。

168
00:10:23,700 --> 00:10:24,960
是啊，它可能，糟糕。

169
00:10:27,740 --> 00:10:34,870
是的，在文件 x 中，

170
00:10:34,870 --> 00:10:36,940
我们必须提供一些标志，

171
00:10:36,940 --> 00:10:38,260
我们并不关心这些标志，

172
00:10:38,260 --> 00:10:39,610
所以我忽略它们，

173
00:10:40,270 --> 00:10:41,740
所以，这将创建一个文件，

174
00:10:41,740 --> 00:10:45,370
返回文件描述符给调用者，

175
00:10:45,580 --> 00:10:49,090
然后调用者，用户应用程序可以写，

176
00:10:49,120 --> 00:10:50,680
通过这个文件描述符，

177
00:10:50,680 --> 00:10:52,450
就像我们之前看到的，

178
00:10:52,810 --> 00:10:57,650
这里有 write(fd, "abc", 3) 。

179
00:10:58,550 --> 00:10:59,810
还有一件事，

180
00:10:59,810 --> 00:11:05,120
已经有很多东西可以从这两个调用中看出。

181
00:11:05,120 --> 00:11:11,280
首先是路径名，

182
00:11:13,910 --> 00:11:15,350
它在接口中出现，

183
00:11:15,350 --> 00:11:17,060
我们必须实现的，

184
00:11:17,710 --> 00:11:21,130
名字人类可读的，

185
00:11:22,680 --> 00:11:23,850
它们不是数字，

186
00:11:23,970 --> 00:11:26,190
它们是由用户选择的。

187
00:11:29,280 --> 00:11:31,530
这里另一个有趣的事情是，

188
00:11:31,530 --> 00:11:32,940
在 write 系统调用中，

189
00:11:33,600 --> 00:11:35,790
没有偏移量作为参数，

190
00:11:36,440 --> 00:11:37,850
所以偏移量是隐式的，

191
00:11:39,350 --> 00:11:43,800
所以文件系统某个地方必须存储偏移量，

192
00:11:44,490 --> 00:11:45,960
如果你第二次调用 write ，

193
00:11:45,960 --> 00:11:47,040
write 最终，

194
00:11:47,040 --> 00:11:50,130
下一组字节将写入到位置 4 。

195
00:11:52,480 --> 00:11:55,930
也许有一些我们没有看过的更有趣的调用，

196
00:11:55,930 --> 00:11:59,710
比如， xv6 和所有 Unix 文件系统

197
00:11:59,710 --> 00:12:03,430
基本上都支持创建链接的调用，

198
00:12:04,190 --> 00:12:07,970
为了使同一文件具有多个名称，

199
00:12:08,000 --> 00:12:10,760
比如，它可能调用 link ，

200
00:12:10,760 --> 00:12:15,890
为原始文件创建第二个名称，

201
00:12:15,890 --> 00:12:21,200
比如，为我们之前创建的文件 y 创建名称 z 。

202
00:12:24,040 --> 00:12:25,600
所以，多个名称，

203
00:12:32,780 --> 00:12:36,140
可能文件系统内部需要以某种方式跟踪，

204
00:12:36,140 --> 00:12:39,260
多个名称可能指向同一个文件。

205
00:12:40,030 --> 00:12:47,980
我们可能会在文件打开时，删除或更改名称空间，

206
00:12:48,010 --> 00:12:51,150
比如，我们可以调用，

207
00:12:51,180 --> 00:12:52,860
用户可能调用一个进程，

208
00:12:52,860 --> 00:12:56,340
同一进程可能会调用 unlink 来删除指定文件。

209
00:12:56,980 --> 00:13:01,570
事实上，我们删除了之前打开的文件 x/y ，

210
00:13:01,570 --> 00:13:03,400
但是我们仍然有一个打开的文件描述符，

211
00:13:03,760 --> 00:13:06,040
所以我们仍然可以给它写入，

212
00:13:07,530 --> 00:13:10,860
所以我们仍然可以写入到 fd ，

213
00:13:10,890 --> 00:13:14,860
比如字符，不管什么， d e 和 f ，

214
00:13:16,150 --> 00:13:17,590
实际上，它一切都很顺利。

215
00:13:18,440 --> 00:13:22,640
所以当文件在使用时，

216
00:13:22,640 --> 00:13:26,300
它周围的命名空间实际上是可以改变的。

217
00:13:27,160 --> 00:13:29,290
所以必须是这样的，

218
00:13:29,290 --> 00:13:30,400
如果你看一下这个，

219
00:13:30,400 --> 00:13:31,210
这些事情，

220
00:13:31,210 --> 00:13:34,570
文件系统内部发生了一系列有趣的事情，

221
00:13:34,840 --> 00:13:38,740
比如，文件描述符必须关联，

222
00:13:39,220 --> 00:13:45,400
我们有一些与名字无关的对象，

223
00:13:45,940 --> 00:13:47,800
因为即使名字改了，

224
00:13:47,800 --> 00:13:53,920
文件描述符仍然指向或引用相同的文件对象。

225
00:13:54,790 --> 00:13:57,760
所以，如果你想一想，

226
00:13:57,760 --> 00:13:58,660
情况肯定是这样的，

227
00:13:58,660 --> 00:14:05,110
必须有一些文件的内部表示，

228
00:14:05,230 --> 00:14:06,490
在操作系统中，

229
00:14:06,490 --> 00:14:08,770
与名称本身无关。

230
00:14:10,630 --> 00:14:12,490
所以我们马上就会看到，

231
00:14:12,490 --> 00:14:15,280
但我还想在这里说明另一点是，

232
00:14:15,610 --> 00:14:17,140
文件系统的目标是

233
00:14:17,140 --> 00:14:20,140
实现像我们在这里看到的 API ，

234
00:14:20,140 --> 00:14:22,660
它是一种典型的文件系统 API 。

235
00:14:23,140 --> 00:14:26,830
这当然不是能够访问存储系统的唯一方法，

236
00:14:27,070 --> 00:14:29,260
或者把信息存储在磁盘上，

237
00:14:29,260 --> 00:14:31,990
我们可以想象完全不同的 API 。

238
00:14:32,480 --> 00:14:38,260
比如，数据库，

239
00:14:38,680 --> 00:14:40,180
持久化存储一些数据，

240
00:14:40,210 --> 00:14:45,970
但是对数据的访问提供了非常不同的编程 API 或用户 API ，

241
00:14:46,180 --> 00:14:48,160
跟文件系统相比。

242
00:14:48,640 --> 00:14:51,430
所以重要的是，要记住，

243
00:14:51,940 --> 00:14:55,660
还有其他方法组织存储系统，

244
00:14:55,660 --> 00:14:57,970
我们的重点将放在文件系统上，

245
00:14:57,970 --> 00:15:00,220
通常由操作系统提供。

246
00:15:00,890 --> 00:15:04,730
而数据库通常在文件系统之上实施，

247
00:15:04,730 --> 00:15:07,490
或者围绕文件系统的大部分工作中，

248
00:15:07,880 --> 00:15:10,940
你不能直接访问磁盘。

249
00:15:12,750 --> 00:15:14,370
我们在聊天中有两个问题。

250
00:15:14,580 --> 00:15:15,210
好的。

251
00:15:16,780 --> 00:15:20,640
让我，请继续问任何问题。

252
00:15:22,090 --> 00:15:25,840
所以， link 递增对底层文件描述符的引用，

253
00:15:25,840 --> 00:15:27,790
而 unlink 递减？

254
00:15:27,790 --> 00:15:31,090
是的，这是正确的，我们稍后再详细讨论这个问题。

255
00:15:31,770 --> 00:15:35,280
这里的另一个问题是关于软链接和硬链接的问题。

256
00:15:35,310 --> 00:15:39,570
今天我不会讲的太多，

257
00:15:39,570 --> 00:15:43,080
但是你将实现软链接

258
00:15:43,080 --> 00:15:47,760
在即将到来的文件系统实验中。

259
00:15:48,640 --> 00:15:50,830
xv6 本身实现了硬链接，

260
00:15:50,830 --> 00:15:53,080
你还要实现软链接。

261
00:15:55,040 --> 00:15:57,050
还有问题吗，还有其他问题吗？

262
00:16:04,490 --> 00:16:07,250
link 是在 inode 上操作，

263
00:16:07,250 --> 00:16:09,110
不是在文件描述符上，是吗？

264
00:16:09,290 --> 00:16:12,830
没错， link 在 inode 上工作，

265
00:16:12,830 --> 00:16:13,400
让我。

266
00:16:13,700 --> 00:16:15,230
让我们到那里。

267
00:16:15,230 --> 00:16:17,590
所以，文件系统结构。

268
00:16:20,250 --> 00:16:22,500
那么文件系统维护什么样的结构

269
00:16:22,500 --> 00:16:27,110
来实现刚才提到的 API 。

270
00:16:27,320 --> 00:16:30,350
所以首先最重要的属性是 inode ，

271
00:16:31,880 --> 00:16:36,380
所以这是一个表示文件的对象，独立于名称，

272
00:16:36,530 --> 00:16:41,820
所以，文件信息，独立于名称。

273
00:16:45,390 --> 00:16:48,900
实际上， inode 的命名方式是

274
00:16:48,900 --> 00:16:51,930
inode 数字只是一个数字。

275
00:16:52,620 --> 00:16:56,340
所以，文件系统内部引用 inode ，

276
00:16:56,580 --> 00:16:59,310
是通过编号，而不是实际路径名称。

277
00:17:00,500 --> 00:17:02,900
我们也知道，从这个讨论中知道，

278
00:17:03,020 --> 00:17:06,410
inode 必须有链接计数，

279
00:17:08,600 --> 00:17:11,720
为了记录，

280
00:17:12,880 --> 00:17:14,860
为了记录名字的数目，

281
00:17:14,860 --> 00:17:17,080
它们指向特定的 inode ，

282
00:17:17,140 --> 00:17:19,030
文件只能在以下情况下删除，

283
00:17:19,240 --> 00:17:21,700
当链接计数为 0 时。

284
00:17:22,590 --> 00:17:25,200
这要稍微复杂一点，

285
00:17:25,530 --> 00:17:30,010
还必须有打开的 fd 计数，

286
00:17:30,190 --> 00:17:33,070
即文件具有的文件描述符数，

287
00:17:33,430 --> 00:17:36,730
只有当这两个值都为零时，才能删除文件。

288
00:17:43,070 --> 00:17:47,780
我们也知道， write 没有偏移量，

289
00:17:47,780 --> 00:17:48,740
read 也没有，

290
00:17:48,740 --> 00:17:54,540
所以，文件描述符必须隐式维护一个偏移量。

291
00:18:01,950 --> 00:18:02,670
好的?

292
00:18:03,650 --> 00:18:09,080
所以，文件系统中的中心数据结构是 inode ，

293
00:18:09,080 --> 00:18:15,750
然后是与进程交互的文件描述符。

294
00:18:19,820 --> 00:18:26,210
所以，即使文件系统在 API 方面非常相似，

295
00:18:26,210 --> 00:18:28,700
它们的实现方式是不同的，

296
00:18:29,090 --> 00:18:35,630
但它们中的许多都有一种类似的结构。

297
00:18:40,050 --> 00:18:42,090
而且因为文件系统相当复杂，

298
00:18:42,090 --> 00:18:47,250
将它们组织成一层，有助于组织它们。

299
00:18:47,750 --> 00:18:49,520
我想的是，

300
00:18:49,520 --> 00:18:51,980
在最下面，这是磁盘，

301
00:18:53,120 --> 00:18:56,150
一些存储设备保存着这些数据。

302
00:18:56,870 --> 00:18:59,450
并且提供了持久性和耐久性，

303
00:18:59,750 --> 00:19:01,340
通常，这里有一些东西，

304
00:19:01,340 --> 00:19:04,310
比如缓冲区在它的上面，

305
00:19:05,600 --> 00:19:10,040
为了避免访问磁盘太多。

306
00:19:10,040 --> 00:19:13,220
所以我们把缓存数据放在内存中。

307
00:19:13,220 --> 00:19:16,360
所以这是内存，

308
00:19:20,560 --> 00:19:23,590
这是设备。

309
00:19:27,980 --> 00:19:31,130
对于持久性，通常会提供记录层，

310
00:19:31,160 --> 00:19:33,860
很多文件系统具有某种形式的日志记录。

311
00:19:34,540 --> 00:19:36,460
我们周三会更多地讨论这个，

312
00:19:36,460 --> 00:19:37,630
所以我先跳过这个话题。

313
00:19:38,220 --> 00:19:42,300
在 xv6 中的最高层，

314
00:19:42,780 --> 00:19:45,060
有一个 icache ，就是 inode 缓存，

315
00:19:45,270 --> 00:19:47,580
这主要是为了同步，

316
00:19:47,970 --> 00:19:49,800
我们也稍后再谈。

317
00:19:54,430 --> 00:19:57,760
所以 inode 通常比磁盘块要小，

318
00:19:57,760 --> 00:20:00,400
许多 inode 打包到一个磁盘块中，

319
00:20:00,970 --> 00:20:04,630
为这些单独的 inode 提供同步，

320
00:20:04,870 --> 00:20:07,300
xv6 维护着 icache 。

321
00:20:08,020 --> 00:20:13,150
然后是 inode 本身的实现，

322
00:20:13,150 --> 00:20:17,670
读取和写入字节。

323
00:20:20,610 --> 00:20:22,380
然后在它之上，

324
00:20:23,310 --> 00:20:28,510
我们有名称，比如路径名和文件描述符操作。

325
00:20:29,640 --> 00:20:33,060
无论如何，每个文件系统的组织方式略有不同，

326
00:20:33,090 --> 00:20:34,890
并且层也可能略有不同，

327
00:20:35,220 --> 00:20:38,550
也许层并不总是那么严格，

328
00:20:38,700 --> 00:20:40,830
即使是 xv6 ，它也不总是非常严格的，

329
00:20:41,130 --> 00:20:44,100
但是这是一个很好的思考方式，

330
00:20:44,100 --> 00:20:47,220
几乎所有文件系统都有组件

331
00:20:47,220 --> 00:20:48,720
对应于不同部分，

332
00:20:48,720 --> 00:20:53,940
有缓冲区缓存、日志记录、 inode 和路径名。

333
00:20:54,600 --> 00:20:57,060
所以工作是通过，

334
00:20:57,090 --> 00:21:00,720
通过这些不同的文件系统层。

335
00:21:01,980 --> 00:21:05,310
让我从最底层说起。

336
00:21:10,000 --> 00:21:13,520
只是看一下聊天。

337
00:21:13,670 --> 00:21:18,440
所以，让我从存储设备开始说起。

338
00:21:22,030 --> 00:21:25,660
有很多不同类型的存储设备，

339
00:21:25,840 --> 00:21:32,860
有不同的性能、容量和耐久度，

340
00:21:33,130 --> 00:21:36,580
但是最常见的两个是，

341
00:21:36,610 --> 00:21:39,880
你们可能很熟悉 SSD 固态硬盘，

342
00:21:41,000 --> 00:21:44,750
也有有些人可能

343
00:21:44,750 --> 00:21:47,780
只是简单地说选择硬盘或磁盘。

344
00:21:48,540 --> 00:21:52,140
你知道它们提供了大量的存储空间，

345
00:21:52,350 --> 00:21:56,070
以合理的价格，以不同的性能，

346
00:21:56,070 --> 00:21:58,770
SSD 通常具有

347
00:21:58,770 --> 00:22:02,980
数百微秒到毫秒级的访问时间，

348
00:22:04,110 --> 00:22:08,190
而磁盘通常是十毫秒级，

349
00:22:08,800 --> 00:22:11,740
对于单个读写块来说。

350
00:22:12,940 --> 00:22:16,720
这里的术语有点困惑，

351
00:22:16,720 --> 00:22:21,870
术语扇区，还有块，

352
00:22:24,430 --> 00:22:29,680
历史上扇区是最小单位，

353
00:22:29,710 --> 00:22:34,810
磁盘可以读取或写入，

354
00:22:34,870 --> 00:22:38,950
所以通常是 512 个字节，

355
00:22:39,690 --> 00:22:41,730
而块大小通常，

356
00:22:41,760 --> 00:22:45,210
块通常是操作系统或文件系统的说法，

357
00:22:45,210 --> 00:22:47,130
或者是由文件系统定义的，

358
00:22:47,340 --> 00:22:50,190
比如在 xv6 中是 1024 字节，

359
00:22:50,490 --> 00:22:51,570
所以这是两个扇区，

360
00:22:51,570 --> 00:22:54,690
通常情况下，块的大小是一个或多个扇区。

361
00:22:55,120 --> 00:22:59,230
有时，人们也将磁盘上的扇区称为块，

362
00:22:59,230 --> 00:23:03,340
所以术语不是特别精确。

363
00:23:04,590 --> 00:23:08,310
这些设备是连接在某个总线上，

364
00:23:09,060 --> 00:23:12,360
总线连接到 CPU 上，

365
00:23:12,950 --> 00:23:15,770
内存可能在这边，

366
00:23:17,850 --> 00:23:20,370
可能有多个 CPU ，

367
00:23:20,370 --> 00:23:23,160
文件系统运行在 CPU 上，

368
00:23:23,160 --> 00:23:26,010
将其内部数据结构保存在内存中，

369
00:23:26,070 --> 00:23:34,320
对 SSD 或硬盘的读写，

370
00:23:34,320 --> 00:23:36,120
是写入块或读取块。

371
00:23:36,180 --> 00:23:39,880
所以，接口非常简单，

372
00:23:40,740 --> 00:23:44,910
它通常只是使用块编号读或写。

373
00:23:46,020 --> 00:23:48,180
这有点过于简单化了，

374
00:23:48,180 --> 00:23:50,130
但是接口的核心大概就是这样的，

375
00:23:50,790 --> 00:23:56,460
在内部，固态硬盘和硬盘的工作方式完全不同，

376
00:23:56,460 --> 00:23:59,760
但是硬件将大部分抽出，

377
00:23:59,790 --> 00:24:06,660
通常是某种标准协议，比如 PCI 或 PCIe ，

378
00:24:06,660 --> 00:24:11,610
这是处理器或文件系统用户磁盘驱动程序

379
00:24:11,610 --> 00:24:14,630
用于与磁盘交互，

380
00:24:14,630 --> 00:24:16,220
通常从磁盘驱动来看，

381
00:24:16,220 --> 00:24:20,600
大多数磁盘看起来都是一样的，

382
00:24:20,750 --> 00:24:25,040
只需要提供一个块编号和一些数据就可以读写，

383
00:24:25,400 --> 00:24:28,220
把它发出去，

384
00:24:28,220 --> 00:24:30,830
或者写入设备的控制寄存器，

385
00:24:30,830 --> 00:24:32,360
设备就会完成它的工作。

386
00:24:33,760 --> 00:24:37,620
从文件系统的角度来看，

387
00:24:37,830 --> 00:24:41,160
虽然磁盘有非常不同的，

388
00:24:41,160 --> 00:24:43,260
存储设备有非常不同的属性，

389
00:24:43,440 --> 00:24:47,640
从驱动的角度来看，

390
00:24:47,670 --> 00:24:50,010
你可以用大致相同的方式编程。

391
00:24:53,840 --> 00:24:54,890
有什么问题吗，

392
00:24:54,920 --> 00:24:56,930
我不会太多谈论存储设备，

393
00:24:56,930 --> 00:24:58,790
所以如果你有任何问题，

394
00:24:58,790 --> 00:25:00,620
现在是提问的好时机。

395
00:25:11,240 --> 00:25:12,830
是的，我有个问题，

396
00:25:12,860 --> 00:25:19,360
用于调用读或写的接口是否

397
00:25:19,360 --> 00:25:22,090
提供了同步和异步选项。

398
00:25:22,450 --> 00:25:24,370
是的，通常都是这样的，

399
00:25:24,370 --> 00:25:27,190
它非常类似于，

400
00:25:27,190 --> 00:25:30,280
你可以考虑磁盘的驱动程序

401
00:25:30,550 --> 00:25:32,740
与控制台驱动程序相同的方式，

402
00:25:33,040 --> 00:25:38,590
CPU 或驱动向设备发出命令，

403
00:25:38,770 --> 00:25:41,050
开始读或写，

404
00:25:41,320 --> 00:25:43,210
然后在设备完成后的某个时刻，

405
00:25:43,210 --> 00:25:44,320
然后生成一个中断，

406
00:25:44,320 --> 00:25:46,660
表示，好的我已经完成了读或写，

407
00:25:46,780 --> 00:25:49,030
然后这意味着完成了。

408
00:25:50,060 --> 00:25:52,160
当然，驱动程序，

409
00:25:52,250 --> 00:25:55,580
因为这个设备比控制台更复杂，

410
00:25:55,580 --> 00:25:58,550
它的驱动程序比控制台驱动程序要复杂得多，

411
00:25:58,550 --> 00:26:00,830
我们在上一节课中看到的，

412
00:26:00,890 --> 00:26:02,270
基本上是相同的结构，

413
00:26:02,660 --> 00:26:05,600
下半部，上半部，中断，

414
00:26:05,990 --> 00:26:08,270
以及读取或写入控制寄存器。

415
00:26:10,850 --> 00:26:11,810
好的，谢谢。

416
00:26:16,490 --> 00:26:19,460
好的，从文件系统的角度来看，

417
00:26:19,490 --> 00:26:24,830
考虑磁盘的方式非常简单。

418
00:26:25,400 --> 00:26:28,730
有一个读写块或扇区，

419
00:26:28,910 --> 00:26:29,960
但我们可以想象一下，

420
00:26:29,960 --> 00:26:35,840
磁盘是巨大的块数组，

421
00:26:36,340 --> 00:26:38,470
从 0 开始，

422
00:26:39,280 --> 00:26:40,120
然后是 1 ，

423
00:26:40,920 --> 00:26:43,530
然后增加到磁盘的大小。

424
00:26:44,300 --> 00:26:48,080
文件系统的作用是

425
00:26:48,080 --> 00:26:51,620
在磁盘上放置所有数据结构，

426
00:26:51,620 --> 00:26:56,600
以一种可以在重启后重新构建文件系统的方式。

427
00:26:57,740 --> 00:27:00,500
所以有不同的方式去做，

428
00:27:00,500 --> 00:27:05,690
xv6 使用非常简单的布局结构，

429
00:27:05,750 --> 00:27:10,940
但是，不是完全使用，

430
00:27:10,940 --> 00:27:17,540
典型的文件系统操作。

431
00:27:18,110 --> 00:27:21,170
所以，通常块 0 不使用，

432
00:27:21,170 --> 00:27:25,440
或用于引导扇区以引导操作系统。

433
00:27:27,470 --> 00:27:30,500
块 1 通常是所谓的超级块，

434
00:27:31,350 --> 00:27:34,620
超级块描述了文件系统，

435
00:27:35,500 --> 00:27:38,380
它可能会说磁盘上有这么多块，

436
00:27:38,380 --> 00:27:39,910
它们构成了文件系统，

437
00:27:40,030 --> 00:27:41,320
稍后我们会看到，

438
00:27:41,320 --> 00:27:43,120
xv6 在其中包含了更多信息，

439
00:27:43,120 --> 00:27:44,890
像大多数其他文件系统一样。

440
00:27:45,410 --> 00:27:46,790
例如，在 xv6 中，

441
00:27:46,910 --> 00:27:52,670
日志从块 2 到块 32 。

442
00:27:55,110 --> 00:27:56,490
是的，这是日志。

443
00:27:57,460 --> 00:27:59,020
当然，日志可以有不同的大小，

444
00:27:59,020 --> 00:28:00,280
事实上，在超级块中，

445
00:28:00,280 --> 00:28:03,340
写着日志的长度是 30 个块。

446
00:28:04,200 --> 00:28:11,910
然后，在 xv6 中，从块 32 到 45 ，

447
00:28:11,940 --> 00:28:12,990
如果我没记错的话，

448
00:28:14,050 --> 00:28:15,910
保存这 inodes ，

449
00:28:18,160 --> 00:28:19,090
就像我之前说的那样，

450
00:28:19,120 --> 00:28:22,510
多个 inode 打包成一个单独的，

451
00:28:22,540 --> 00:28:25,060
这个块我想 inode 是，

452
00:28:26,470 --> 00:28:28,750
我想，我不记得了，

453
00:28:28,750 --> 00:28:34,620
但我认为它是 64 字节，或 128 字节，我相信是 64 字节。

454
00:28:34,950 --> 00:28:39,390
在那之后，有一个 bitmap 块，

455
00:28:39,420 --> 00:28:42,870
是我们构建文件系统的详细方式，

456
00:28:43,440 --> 00:28:46,830
这个 bitmap 块是一个块的大小，

457
00:28:48,680 --> 00:28:52,430
这些跟踪数据块，

458
00:28:52,960 --> 00:28:54,460
它是不是空闲的。

459
00:28:54,820 --> 00:28:59,260
在那之后，从这里到那里，都是数据块，

460
00:28:59,350 --> 00:29:03,430
数据块保存文件内容或目录内容。

461
00:29:05,140 --> 00:29:11,230
通常所有 bitmap 块和 inode 块以及记录块，

462
00:29:11,380 --> 00:29:14,080
有时称为元数据块，

463
00:29:16,940 --> 00:29:18,620
它们并不存储实际数据，

464
00:29:18,620 --> 00:29:22,820
但它们为文件系统保存元数据信息来完成工作，

465
00:29:23,350 --> 00:29:25,420
比如位图和索引节点。

466
00:29:28,580 --> 00:29:30,470
到目前为止，有什么问题吗？

467
00:29:33,160 --> 00:29:35,440
我有一个关于引导块的问题，

468
00:29:35,440 --> 00:29:40,960
它是否包含用于引导操作系统的代码或其他内容。

469
00:29:41,500 --> 00:29:47,890
是的，没错，它通常包含一个块代码，

470
00:29:47,920 --> 00:29:50,020
足够让操作系统开始运行，

471
00:29:50,020 --> 00:29:54,040
然后，可能会从文件系统加载操作系统的更多部分。

472
00:29:57,810 --> 00:29:58,470
谢谢。

473
00:29:58,740 --> 00:30:03,900
那么这是否意味着 xv6 的代码实际上存储在虚拟磁盘上，

474
00:30:03,930 --> 00:30:06,330
或者是怎么回事。

475
00:30:06,330 --> 00:30:09,990
xv6 我们使用 QEMU ，得到一些[]，

476
00:30:10,320 --> 00:30:13,350
QEMU 有一个标志， -kernel ，

477
00:30:13,350 --> 00:30:17,220
它指向引导内核的位置，

478
00:30:17,220 --> 00:30:19,410
然后加载到一个特定的地址，

479
00:30:19,410 --> 00:30:23,220
到物理内存中， 0x80000 ，

480
00:30:23,760 --> 00:30:25,950
所以当我们使用 QEMU 时，

481
00:30:25,950 --> 00:30:26,730
按照我们使用 QEMU 的方式，

482
00:30:26,730 --> 00:30:30,120
我们不必担心引导扇区或类似的事情。

483
00:30:31,420 --> 00:30:36,730
好的，所以当你运行 QEMU 时，

484
00:30:36,760 --> 00:30:42,130
你只要就像通过命令行一样把程序传进来，

485
00:30:42,130 --> 00:30:43,210
然后它就会运行它，

486
00:30:43,210 --> 00:30:46,000
它不需要从虚拟磁盘和其他东西中读取它。

487
00:30:46,990 --> 00:30:47,680
理解了。

488
00:30:51,530 --> 00:30:55,240
好的，就像，比如，

489
00:30:55,960 --> 00:30:59,590
所以假设我知道 64 个字节，

490
00:30:59,590 --> 00:31:03,580
现在如果你想读取 inode 10 ，

491
00:31:08,540 --> 00:31:10,670
你应该怎么做。

492
00:31:11,550 --> 00:31:12,930
如何读取 inode 10 ？

493
00:31:18,370 --> 00:31:19,180
有人知道吗？

494
00:31:22,530 --> 00:31:24,300
inode 10 在哪个块上？

495
00:31:25,660 --> 00:31:27,520
你需要加上，

496
00:31:27,820 --> 00:31:32,230
使用 inode 编号加上偏移量，

497
00:31:32,230 --> 00:31:33,400
所以是 10 加 32 。

498
00:31:33,880 --> 00:31:39,000
所以是 32 加 10 或者其他的东西。

499
00:31:47,880 --> 00:31:51,180
是 10 除以大小吗？

500
00:31:51,210 --> 00:31:54,240
是的， inode 编号，

501
00:31:55,090 --> 00:32:03,190
inode 编号乘以，我们以字节为单位，乘以 64 ，

502
00:32:03,970 --> 00:32:06,010
除以 1024 ，

503
00:32:08,540 --> 00:32:11,540
所以， inode 0 最终出现在块 32 中，

504
00:32:12,040 --> 00:32:15,560
无论哪个 inode ，

505
00:32:15,710 --> 00:32:18,410
1024 除以 64 是多少？

506
00:32:23,640 --> 00:32:26,370
16？是的， 16 ，

507
00:32:26,370 --> 00:32:29,610
所以 inode 17 会在哪里，

508
00:32:32,960 --> 00:32:35,360
应该在块 33 ，对吧。

509
00:32:37,710 --> 00:32:38,340
这能理解吗？

510
00:32:39,520 --> 00:32:40,840
所以，给出 inode 编号，

511
00:32:40,840 --> 00:32:45,760
我们就可以在磁盘上找到 inode 存储的字节。

512
00:32:47,370 --> 00:32:48,000
好的?

513
00:32:50,580 --> 00:32:52,860
好的，我们来看一下，

514
00:32:53,310 --> 00:32:56,910
在磁盘 inode 上的实际是什么。

515
00:33:04,850 --> 00:33:06,920
根据我们知道的，

516
00:33:06,950 --> 00:33:11,630
你将看到数据结构， 64 字节大小，

517
00:33:13,760 --> 00:33:16,310
通常有一个 type ，

518
00:33:16,880 --> 00:33:18,530
我们稍后会谈到，

519
00:33:18,530 --> 00:33:20,690
比如 type 是文件或目录。

520
00:33:21,050 --> 00:33:22,340
还有 link ，

521
00:33:23,640 --> 00:33:28,980
link 计数跟踪多个名称或指向同一 inode 。

522
00:33:29,580 --> 00:33:31,230
还有以字节为单位的 size 。

523
00:33:32,960 --> 00:33:37,760
在 xv6 中，文件系统中的这些略有不同，

524
00:33:37,760 --> 00:33:39,380
具体的表现形式是，

525
00:33:39,710 --> 00:33:41,480
在 xv6 中，

526
00:33:41,840 --> 00:33:43,910
多一点空间。

527
00:33:49,760 --> 00:33:53,330
在 xv6 中，后面跟着的是块编号，

528
00:33:54,120 --> 00:33:58,680
所以，后面是块 0 ，块 1 ，

529
00:33:59,240 --> 00:34:02,480
实际上，有 12 个这样的块编号，

530
00:34:03,140 --> 00:34:05,270
这 12 个直接块编号，

531
00:34:10,510 --> 00:34:11,680
这些直接块编号

532
00:34:11,680 --> 00:34:15,910
对应于构成该文件的前 12 个块。

533
00:34:16,440 --> 00:34:18,930
如果文件只有两个字节长，

534
00:34:18,990 --> 00:34:22,770
这里只有一个块编号 0 ，

535
00:34:23,100 --> 00:34:27,760
块编号 0 是磁盘的块编号，

536
00:34:27,760 --> 00:34:31,150
它包含该文件的前几个字节。

537
00:34:32,290 --> 00:34:36,040
然后有一个间接的块编号，

538
00:34:41,570 --> 00:34:45,820
这是一个块编号对应于一个块，

539
00:34:46,550 --> 00:34:50,670
它本身的块是 1024 字节，

540
00:34:50,670 --> 00:34:55,540
保存 256 个块编号。

541
00:35:01,800 --> 00:35:09,850
所以从块编号 0 到 11 都是直接块编号，

542
00:35:09,850 --> 00:35:19,120
然后是块编号 12 保存那个间接块，

543
00:35:19,480 --> 00:35:23,230
指向间接块编号。

544
00:35:25,900 --> 00:35:33,580
这就是 xv6 中文件的布局。

545
00:35:35,300 --> 00:35:38,690
那么基于这个， xv6 中的最大文件是多少呢？

546
00:35:45,880 --> 00:35:46,540
有人知道吗？

547
00:35:54,240 --> 00:35:58,590
它是 268 乘以 1024 字节。

548
00:35:58,950 --> 00:36:07,960
是的， 256 加上 12 个直接块编号乘以 1024 ，

549
00:36:07,990 --> 00:36:10,720
我们就得到了以字节为单位的最大文件大小。

550
00:36:12,840 --> 00:36:13,770
它是多少？

551
00:36:19,460 --> 00:36:22,340
换个说法，它是 268 千字节。

552
00:36:24,470 --> 00:36:26,780
你能在 268 千字节中存储什么？

553
00:36:30,510 --> 00:36:36,110
你能在里面存储视频或者一首歌吗？

554
00:36:39,050 --> 00:36:40,700
如果是一首短歌，是的。

555
00:36:42,170 --> 00:36:43,460
很短的歌，是的。

556
00:36:44,060 --> 00:36:46,640
所以这些文件非常小，

557
00:36:47,000 --> 00:36:49,850
真实的文件系统文件要大得多。

558
00:36:50,120 --> 00:36:52,850
那么，如何处理文件系统表示，

559
00:36:52,850 --> 00:36:56,360
可以让文件变得更大。

560
00:37:01,560 --> 00:37:04,530
你可以增加间接的部分吗？

561
00:37:05,400 --> 00:37:08,760
是的，比如，你可以在下面有另一个块，

562
00:37:08,760 --> 00:37:10,230
可能是两倍间接，

563
00:37:14,170 --> 00:37:19,370
就像我们以前看到的那种页表类型的数据结构一样，

564
00:37:19,370 --> 00:37:22,970
那个双倍间接块指向 256 个间接块编号，

565
00:37:22,970 --> 00:37:25,220
每一个都指向另一个块编号，

566
00:37:25,610 --> 00:37:28,760
最大文件尺寸要大得多。

567
00:37:29,440 --> 00:37:33,880
只是对这些数据结构的一种练习，

568
00:37:33,880 --> 00:37:36,610
你可以选择类似的数据结构，比如树，

569
00:37:36,610 --> 00:37:41,110
但也有可能实现为 B-Tree 或其他复杂的东西。

570
00:37:41,800 --> 00:37:44,980
xv6 是非常简单的，

571
00:37:44,980 --> 00:37:49,750
基本上它是仿照最初的第六版 Unix 。

572
00:37:51,120 --> 00:37:53,880
但你可以让使用更复杂的方案，

573
00:37:53,910 --> 00:37:56,790
事实上，在文件系统实验里，

574
00:37:56,850 --> 00:38:01,560
你可以实现双倍间接块编号来支持更大的文件。

575
00:38:04,260 --> 00:38:05,340
关于这个，有什么问题吗？

576
00:38:10,530 --> 00:38:13,620
抱歉，是 256 个块吗，

577
00:38:13,620 --> 00:38:17,250
因为就像一个整体的块，

578
00:38:18,500 --> 00:38:20,480
间接块。

579
00:38:20,600 --> 00:38:23,510
这是一个间接的块编号，所以这不算，

580
00:38:23,510 --> 00:38:26,600
所以间接块中有 256 个，

581
00:38:26,780 --> 00:38:30,710
加上 12 个直接的块编号，就是 268 个。

582
00:38:32,620 --> 00:38:36,850
哦，抱歉，我的问题是为什么是 256 。

583
00:38:37,030 --> 00:38:40,690
哦，因为可能块编号是 4 个字节。

584
00:38:43,300 --> 00:38:47,260
所以 1024 除以 4 是 256 个条目。

585
00:38:47,920 --> 00:38:50,000
好的，谢谢。

586
00:38:50,120 --> 00:38:51,830
这也是有点[可笑的]，

587
00:38:51,830 --> 00:38:54,590
如果块编号只有 4 个字节，这个能有多大？

588
00:39:04,610 --> 00:39:05,240
有人知道吗？

589
00:39:16,280 --> 00:39:18,680
2 的 32次方，对吧，

590
00:39:19,490 --> 00:39:20,690
有些东西比这更大，

591
00:39:20,900 --> 00:39:28,650
所以，通常人们使用比 32 位更大的尺寸来存储块编号。

592
00:39:30,820 --> 00:39:31,420
好的?

593
00:39:32,080 --> 00:39:33,370
有什么问题吗，更多的问题？

594
00:39:36,430 --> 00:39:38,560
对于最大文件大小，

595
00:39:38,980 --> 00:39:42,880
您能再解释一遍吗，比如。

596
00:39:43,550 --> 00:39:44,690
好的，当然可以。

597
00:39:44,930 --> 00:39:47,000
每个块能不能，

598
00:39:47,210 --> 00:39:51,440
间接块引用的每个块，

599
00:39:51,440 --> 00:39:55,400
能不能指向更多块，

600
00:39:55,610 --> 00:39:56,420
如果有用的话。

601
00:39:56,420 --> 00:39:59,840
在默认的 xv6 设计中，不是这样，

602
00:39:59,840 --> 00:40:02,840
基本上 12 个直接块编号，

603
00:40:02,840 --> 00:40:04,970
和 256 个间接块编号，

604
00:40:05,210 --> 00:40:06,140
没有其他了。

605
00:40:06,840 --> 00:40:09,960
在下一个实验中，

606
00:40:09,960 --> 00:40:12,540
你要给 inode 添加一个双重间接块，

607
00:40:12,900 --> 00:40:14,910
所以你要从 bn0 到 11 中选择一个，

608
00:40:14,910 --> 00:40:17,130
把它变成一个双重间接块。

609
00:40:17,660 --> 00:40:21,200
而这个双重间接块将指向，

610
00:40:21,230 --> 00:40:25,550
这里我们有有 256 个的间接块编号，

611
00:40:26,880 --> 00:40:30,090
然后，它本身指向块。

612
00:40:31,060 --> 00:40:33,520
现在，文件可以放在那里。

613
00:40:36,040 --> 00:40:37,480
哦，好的，谢谢。

614
00:40:39,300 --> 00:40:43,380
好的，现在，让我们看看实现 read 系统调用。

615
00:40:44,000 --> 00:40:49,250
我们从操作系统引导开始，

616
00:40:49,460 --> 00:40:59,680
要读取字节 8000 。

617
00:41:04,320 --> 00:41:07,050
是的，你怎么知道读哪个块，

618
00:41:09,380 --> 00:41:12,830
哪个块包含字节 8000 。

619
00:41:17,340 --> 00:41:19,380
你如何计算或如何查找，

620
00:41:19,410 --> 00:41:20,850
给出这个数据结构，

621
00:41:21,300 --> 00:41:23,400
这个非常简单的数据结构，

622
00:41:23,400 --> 00:41:25,830
你怎么计算出块编号，

623
00:41:25,890 --> 00:41:28,860
或者找出包含字节 8000 的块编号。

624
00:41:36,070 --> 00:41:37,000
有人知道吗？

625
00:41:38,670 --> 00:41:41,290
你是不是减去，

626
00:41:41,320 --> 00:41:46,120
比如，首先减去前十二个直接块的字节数。

627
00:41:46,300 --> 00:41:46,870
嗯。

628
00:41:47,430 --> 00:41:51,600
然后看看间接块中的偏移量是多少。

629
00:41:52,080 --> 00:41:54,150
是的，所以好的，在 8000 的情况下，

630
00:41:54,150 --> 00:41:56,640
我们做的是除以 1024 ，

631
00:41:56,640 --> 00:41:57,900
因为那是块大小，

632
00:42:00,000 --> 00:42:03,240
结果是 7 ，对吧。

633
00:42:05,250 --> 00:42:08,790
这意味着第 7 个块，

634
00:42:09,120 --> 00:42:12,870
在直接块编号里的第 7 个，

635
00:42:13,140 --> 00:42:16,710
有包含字节 8000 的块编号。

636
00:42:17,750 --> 00:42:22,100
所以 bn7 不管块编号的什么数字，

637
00:42:22,100 --> 00:42:25,790
包含这个特定的文件，

638
00:42:26,540 --> 00:42:32,900
字节 8000 找出那个字节在块中的确切位置，

639
00:42:32,900 --> 00:42:38,220
我们用 8000 对 1024 取模，

640
00:42:40,690 --> 00:42:43,840
我想大概是 832 。

641
00:42:46,460 --> 00:42:49,880
好的，所以要读取字节 8000 ，

642
00:42:49,880 --> 00:42:52,370
文件系统会查看 inode ，

643
00:42:53,090 --> 00:42:55,910
取字节数除以 1024 ，

644
00:42:55,970 --> 00:42:57,500
进入索引，

645
00:42:58,000 --> 00:43:01,840
查看是否小于 12 ，然后是一个直接块编号，

646
00:43:02,200 --> 00:43:06,370
只需从 inode 获取直接的块编号，，

647
00:43:06,580 --> 00:43:10,360
读取块，然后取出 8000 字节，

648
00:43:10,360 --> 00:43:14,680
通过计算 8000 对 1024 取模，

649
00:43:14,680 --> 00:43:16,780
它会给我们偏移量 832 ，

650
00:43:16,780 --> 00:43:21,250
这就是文件的 8000 字节的位置。

651
00:43:22,760 --> 00:43:23,480
好的?

652
00:43:24,690 --> 00:43:27,390
所以，这些信息足够得出结论，

653
00:43:27,390 --> 00:43:29,520
现在这里有足够的信息

654
00:43:29,520 --> 00:43:32,880
来实现 read write 系统调用，

655
00:43:32,880 --> 00:43:40,470
至少找出哪些磁盘块需要读取或写入，

656
00:43:41,100 --> 00:43:43,500
对于读或写系统调用。

657
00:43:46,630 --> 00:43:47,170
好的。

658
00:43:51,520 --> 00:43:53,260
让我简单地谈一下目录。

659
00:43:56,100 --> 00:43:58,200
关于文件系统最酷的事情之一，

660
00:43:58,200 --> 00:44:01,470
有一个分层的名称空间，

661
00:44:01,470 --> 00:44:06,540
你可以使用用户友好的名称，

662
00:44:06,540 --> 00:44:11,110
在文件系统中。

663
00:44:11,720 --> 00:44:14,210
有趣的是，

664
00:44:14,210 --> 00:44:17,330
一个很酷的设计是，

665
00:44:17,600 --> 00:44:19,070
大多数 Unix 文件系统所做的，

666
00:44:19,070 --> 00:44:21,820
目录基本上就是文件，

667
00:44:22,380 --> 00:44:24,120
除了文件具有某种结构,

668
00:44:28,440 --> 00:44:30,180
文件系统理解的。

669
00:44:30,830 --> 00:44:35,300
事实上，在 xv6 中，数据结构非常简单，

670
00:44:36,230 --> 00:44:39,920
目录由目录项组成。

671
00:44:40,690 --> 00:44:45,280
而每个条目都有固定的格式，

672
00:44:45,490 --> 00:44:50,880
它在前两个字节中包含 inode 编号，

673
00:44:51,860 --> 00:44:58,720
在剩余的 14 个字节中包含文件名，

674
00:44:58,720 --> 00:45:00,520
所以总共是 16 个字节。

675
00:45:03,280 --> 00:45:08,140
这些信息基本上已经足够了，

676
00:45:08,170 --> 00:45:11,020
我们实现了路径名查找。

677
00:45:18,070 --> 00:45:19,720
所以，比如，更清楚一点，

678
00:45:19,720 --> 00:45:25,770
假设我们想要查找路径名 y/x ，

679
00:45:26,470 --> 00:45:27,970
我们该怎么做呢？

680
00:45:29,750 --> 00:45:33,800
你知道这个路径名表示，

681
00:45:33,800 --> 00:45:35,840
我们必须从根 inode 开始。

682
00:45:39,990 --> 00:45:41,070
通过它，

683
00:45:41,070 --> 00:45:43,950
有一个固定的 inode 编号，

684
00:45:43,980 --> 00:45:47,160
根 inode 编号有一个预先定义的固定编号，

685
00:45:47,160 --> 00:45:49,260
在 xv6 中，这个数字是 1 。

686
00:45:50,520 --> 00:45:52,980
那么我们如何找到根 inode 编号呢？

687
00:45:56,930 --> 00:45:59,360
现在我们回到之前的图片，

688
00:45:59,450 --> 00:46:00,680
是的，它是编号 1 ，

689
00:46:00,710 --> 00:46:03,830
我们知道 inode 从块 32 开始，

690
00:46:03,830 --> 00:46:05,750
所以它一定是块 32 ，

691
00:46:05,750 --> 00:46:12,430
所以在第 1 个块的字节 64 到 128 ，

692
00:46:12,460 --> 00:46:15,200
包含根 inode 编号，

693
00:46:15,200 --> 00:46:17,810
所以，文件系统可以读取根 inode 编号。

694
00:46:18,760 --> 00:46:19,390
好的?

695
00:46:21,060 --> 00:46:24,090
然后按照路径名查找和工作的方式，

696
00:46:24,090 --> 00:46:26,460
它查看块，

697
00:46:30,890 --> 00:46:35,200
你知道名字 y ，

698
00:46:37,040 --> 00:46:39,020
所以文件系统通过，

699
00:46:39,020 --> 00:46:45,320
到达 inode 所在的块，文件 inode 1 ，

700
00:46:45,320 --> 00:46:46,310
一个接一个，

701
00:46:46,310 --> 00:46:48,740
查看这些块的数据，

702
00:46:49,010 --> 00:46:51,260
看字符串 y 是否存在。

703
00:46:51,900 --> 00:46:54,840
它如何找到 inode 1 的所有块，

704
00:46:54,840 --> 00:46:58,950
看 bn0 ，第一个块，

705
00:46:59,370 --> 00:47:01,800
查看 x 是否在其中，

706
00:47:01,800 --> 00:47:04,950
如果不是，会读取第二个块，等等，

707
00:47:04,980 --> 00:47:06,540
直到在某一时刻，

708
00:47:06,540 --> 00:47:08,310
它要么找到它，要么找不到它。

709
00:47:10,140 --> 00:47:11,490
如果它找到它，

710
00:47:11,490 --> 00:47:13,110
让我们找文件 x ，

711
00:47:13,950 --> 00:47:18,390
在目录中，会有 inode 编号，比如 251 ，

712
00:47:19,010 --> 00:47:20,840
然后我们就可以从那里开始了，

713
00:47:20,840 --> 00:47:22,460
我们可以说，好的，

714
00:47:22,460 --> 00:47:30,250
现在读取 inode 251 ，

715
00:47:31,150 --> 00:47:37,180
查看它的块。

716
00:47:39,230 --> 00:47:40,940
好的，我做错了我的例子，

717
00:47:40,940 --> 00:47:44,680
这是 y ，它会获取 x 的块。

718
00:47:47,080 --> 00:47:48,310
然后，我们，

719
00:47:48,310 --> 00:47:49,630
所以 inode 编号，

720
00:47:49,630 --> 00:47:52,030
我们会把它作为路径名查找的结果返回。

721
00:47:55,540 --> 00:47:56,650
对于这个，有什么问题吗？

722
00:48:05,900 --> 00:48:06,560
你知道。

723
00:48:06,560 --> 00:48:07,310
这个。

724
00:48:07,340 --> 00:48:13,670
是的，这是磁盘中目录的布局，

725
00:48:13,910 --> 00:48:17,360
但是，在元数据块中的是否有一些位，

726
00:48:17,360 --> 00:48:20,810
指示当前是目录还是文件。

727
00:48:21,260 --> 00:48:22,970
是的，它实际上在 inode 中，

728
00:48:23,240 --> 00:48:26,920
inode 的类型说明了是目录或文件，

729
00:48:26,920 --> 00:48:28,600
如果你查找，

730
00:48:29,020 --> 00:48:31,960
而 inode 是一个文件，

731
00:48:31,960 --> 00:48:33,820
那么文件系统会返回一个错误。

732
00:48:37,260 --> 00:48:38,850
我明白了，谢谢。

733
00:48:40,890 --> 00:48:41,550
好的?

734
00:48:46,080 --> 00:48:51,090
很明显这种数据结构并不是特别高效，

735
00:48:51,090 --> 00:48:54,750
要找到目录名，你必须扫描，

736
00:48:54,870 --> 00:49:01,350
一个真正的文件系统可能会使用更复杂的数据结构，

737
00:49:01,780 --> 00:49:06,520
让这种查找比 xv6 快得多。

738
00:49:08,970 --> 00:49:12,990
但是，这是一个关于数据结构设计的问题，

739
00:49:12,990 --> 00:49:14,940
而不是操作系统设计的问题。

740
00:49:17,230 --> 00:49:20,980
你可以使用你最喜欢的数据结构，

741
00:49:20,980 --> 00:49:22,930
并将它转换[]数据结构，

742
00:49:22,930 --> 00:49:24,970
然后希望能获得更好的性能。

743
00:49:26,450 --> 00:49:29,060
但是为了简单和容易解释，

744
00:49:29,090 --> 00:49:31,280
这里是非常简单的数据结构。

745
00:49:37,530 --> 00:49:38,130
好的?

746
00:49:40,080 --> 00:49:41,580
好的，接下来我要做的是

747
00:49:41,580 --> 00:49:44,220
对这个有更具体的感受，

748
00:49:44,220 --> 00:49:48,360
看看在 xv6 中实际是如何工作的，

749
00:49:48,390 --> 00:49:52,290
这对下一个实验是很有帮助的。

750
00:49:52,910 --> 00:49:56,960
我要看一下 xv6 ，

751
00:49:56,960 --> 00:50:00,050
通常的 screen 。

752
00:50:02,520 --> 00:50:05,990
所以，我要重启 xv6 的第一件事，

753
00:50:05,990 --> 00:50:09,410
它总是，我输入 make clean ，

754
00:50:09,650 --> 00:50:11,990
你们可能还记得，

755
00:50:11,990 --> 00:50:13,700
或者你们中的许多人都遇到过这种情况，

756
00:50:13,700 --> 00:50:15,380
你需要新的文件系统，

757
00:50:15,590 --> 00:50:16,820
你必须运行 make clean ，

758
00:50:16,820 --> 00:50:20,540
因为，然后 make qumu 将会构建一个新的干净的文件系统。

759
00:50:21,540 --> 00:50:23,310
所以我们开始吧。

760
00:50:25,640 --> 00:50:29,960
我们看到 xv6 已经启动，

761
00:50:29,990 --> 00:50:33,200
但是我首先要指出的是，

762
00:50:33,200 --> 00:50:39,350
在这里，你看到有一个调用创建一个文件系统，

763
00:50:39,350 --> 00:50:42,860
所以这会产生一个新的磁盘镜像，

764
00:50:42,980 --> 00:50:46,610
在磁盘映像中包含了一些文件，

765
00:50:46,610 --> 00:50:48,320
我们在命令行中指定的，

766
00:50:49,100 --> 00:50:49,880
并使它更快，

767
00:50:49,880 --> 00:50:53,150
创建包含那些文件的 QEMU 文件系统，

768
00:50:53,150 --> 00:50:54,500
那些文件作为文件系统内容。

769
00:50:55,510 --> 00:50:57,520
你可以看到 xv6 ，

770
00:50:57,520 --> 00:51:01,000
提供了一些关于文件系统的信息，

771
00:51:01,210 --> 00:51:03,760
它表示有 46 个元数据块，

772
00:51:03,760 --> 00:51:06,040
包括启动块，超级块，

773
00:51:06,040 --> 00:51:09,880
30 个 日志块， 13 个 inode 块， 1 个位图块，

774
00:51:10,270 --> 00:51:13,270
然后是 954 个数据块，

775
00:51:13,300 --> 00:51:14,920
所以这是一个很小的文件系统，

776
00:51:14,920 --> 00:51:16,510
总共只有 1000 块。

777
00:51:17,020 --> 00:51:20,260
你们在实验中要做的一件事是，

778
00:51:20,260 --> 00:51:21,190
支持更大的文件，

779
00:51:21,190 --> 00:51:24,460
你还必须使用更大的文件系统。

780
00:51:27,050 --> 00:51:31,000
然后，我稍微修改了 xv6 ，

781
00:51:31,000 --> 00:51:33,610
来写或打印一些东西。

782
00:51:33,610 --> 00:51:35,680
当我们写入特定的块的时候。

783
00:51:36,290 --> 00:51:38,990
比如，我们看到几个文件系统调用，

784
00:51:38,990 --> 00:51:40,910
在 xv6 启动时，

785
00:51:40,910 --> 00:51:42,770
执行了一系列文件系统调用，

786
00:51:42,950 --> 00:51:46,640
写了块 33 33 46 和 32 。

787
00:51:47,430 --> 00:51:50,970
我们要执行指令，

788
00:51:50,970 --> 00:51:52,170
我们要查看，

789
00:51:52,170 --> 00:51:55,590
哪些块编号被写入，

790
00:51:55,890 --> 00:52:00,270
是由那个命令引起的，

791
00:52:00,270 --> 00:52:01,590
我们要理解，

792
00:52:01,650 --> 00:52:03,960
这些 write 是什么意思，

793
00:52:03,960 --> 00:52:06,630
我们想看到它们是否真的，

794
00:52:08,730 --> 00:52:11,220
看看发生了什么才是我们真正期待的。

795
00:52:12,110 --> 00:52:15,110
所以我要创建一个文件，

796
00:52:15,110 --> 00:52:16,040
echo hi,

797
00:52:17,480 --> 00:52:19,010
是的，我要创建一个文件 x 。

798
00:52:21,310 --> 00:52:27,760
让我把它复制出来，

799
00:52:27,760 --> 00:52:33,260
这样我就可以标记这个，

800
00:52:33,290 --> 00:52:35,030
我将在几个地方标记，

801
00:52:35,030 --> 00:52:37,490
为了帮助理解，

802
00:52:39,850 --> 00:52:41,710
可能在这里，

803
00:52:44,990 --> 00:52:46,430
然后可能在这里。

804
00:52:48,680 --> 00:52:49,430
好的。

805
00:52:50,240 --> 00:52:54,260
基本上这里有几个阶段，

806
00:52:54,260 --> 00:52:56,630
一个是创建文件的阶段，

807
00:52:59,970 --> 00:53:06,930
然后是写文件，也就是 write hi ，

808
00:53:06,960 --> 00:53:09,180
然后再写一次，

809
00:53:10,260 --> 00:53:15,670
写入换行到文件中。

810
00:53:18,540 --> 00:53:20,790
所以，你可以查看 echo 程序，

811
00:53:20,790 --> 00:53:22,050
这就是它所做的。

812
00:53:23,560 --> 00:53:24,250
我可以把它找出来，

813
00:53:28,460 --> 00:53:30,830
为了[完整性]，

814
00:53:30,830 --> 00:53:35,160
所以， echo ，看看它的参数，

815
00:53:35,160 --> 00:53:39,660
write 的参数写入文件描述符 1 ，

816
00:53:39,660 --> 00:53:43,050
然后在末尾添加一个换行。

817
00:53:43,620 --> 00:53:44,310
好的?

818
00:53:44,890 --> 00:53:49,780
所以，这些就是每个操作中涉及的磁盘写入序列。

819
00:53:50,640 --> 00:53:53,310
让我们依次看看，

820
00:53:53,310 --> 00:53:54,870
试着理解发生了什么事。

821
00:53:55,460 --> 00:53:57,050
我要做的，

822
00:53:57,050 --> 00:53:59,240
可能是最简单的事情，

823
00:53:59,240 --> 00:54:01,280
把这个移过去。

824
00:54:07,880 --> 00:54:13,490
好的，所以很方便理解发生了什么，

825
00:54:13,490 --> 00:54:14,540
我们不看代码，

826
00:54:14,540 --> 00:54:17,060
而是只看这个磁盘布局，

827
00:54:17,120 --> 00:54:18,830
试图弄清楚，

828
00:54:19,100 --> 00:54:22,340
在这些特殊的操作中可能会发生什么。

829
00:54:39,280 --> 00:54:39,910
好的。

830
00:54:42,310 --> 00:54:46,270
那么我们怎么看这个 write 。

831
00:54:53,210 --> 00:54:55,070
有人知道这是什么吗？

832
00:54:56,230 --> 00:54:57,250
我们在创建一个文件，

833
00:54:57,250 --> 00:54:59,470
那么我们期望文件系统做什么。

834
00:55:00,340 --> 00:55:02,440
它写入了 inode 条目。

835
00:55:03,200 --> 00:55:05,330
是的，所以第一件事是，

836
00:55:05,330 --> 00:55:07,820
好的，它是 33 ，

837
00:55:07,820 --> 00:55:09,380
我们对块 33 有什么了解？

838
00:55:10,210 --> 00:55:11,560
如果我们看一下磁盘布局图。

839
00:55:14,130 --> 00:55:16,500
它包含一个空闲 inode 。

840
00:55:17,020 --> 00:55:18,220
是的，它包含，

841
00:55:18,220 --> 00:55:21,640
我们知道 inode 1 在 32 ，

842
00:55:21,640 --> 00:55:27,100
所以我们分配的 inode ，

843
00:55:27,100 --> 00:55:29,230
可能是位于块 33 的 inode 。

844
00:55:29,870 --> 00:55:32,720
假设第一次写入可能只是标记，

845
00:55:32,720 --> 00:55:35,030
这个 inode 是要使用的，

846
00:55:35,090 --> 00:55:37,100
所以我认为 xv6 的实现方式是，

847
00:55:37,280 --> 00:55:40,320
它在 inode 中使用 type 字段，

848
00:55:40,320 --> 00:55:43,320
指示 inode 空闲，文件或目录，

849
00:55:43,350 --> 00:55:47,190
所以它从空闲变成文件，

850
00:55:47,190 --> 00:55:51,660
并写入磁盘，标记为已使用。

851
00:55:52,960 --> 00:55:56,290
我们认为下一个 write 33 是什么？

852
00:56:02,320 --> 00:56:06,810
填充 inode 条目需要信息。

853
00:56:07,110 --> 00:56:10,020
是的，确实填充 inode 信息，

854
00:56:10,080 --> 00:56:12,300
inode 可能有条目，

855
00:56:12,300 --> 00:56:16,620
比如将链接计数设置为 1 ，或类似的东西。

856
00:56:21,230 --> 00:56:22,130
46 是什么，

857
00:56:22,130 --> 00:56:24,170
我们期望 46 32 是什么，

858
00:56:24,200 --> 00:56:24,980
它可能是什么。

859
00:56:30,300 --> 00:56:33,360
46 是第一个数据吗，

860
00:56:33,450 --> 00:56:36,090
不，是位图。

861
00:56:36,640 --> 00:56:38,320
不，它只是一个数据块，

862
00:56:38,350 --> 00:56:40,180
你说得对，这是第一个数据块。

863
00:56:41,260 --> 00:56:42,940
那么你认为这是谁的数据块？

864
00:56:45,640 --> 00:56:50,860
是根目录条目？

865
00:56:51,440 --> 00:56:54,140
是的，没错，这可能是块，

866
00:56:54,960 --> 00:56:59,860
根目录的第一个块，

867
00:57:01,040 --> 00:57:03,550
是 inode 1 ，对吧。

868
00:57:04,420 --> 00:57:07,720
我们为什么要写入它，

869
00:57:09,180 --> 00:57:09,600
发生了什么。

870
00:57:09,600 --> 00:57:16,880
因为我们正在创建 x ，

871
00:57:17,620 --> 00:57:20,020
我们将一个新文件 x 添加到当前目录中，

872
00:57:20,020 --> 00:57:21,850
将它添加到文件层次结构中。

873
00:57:21,940 --> 00:57:24,700
是的，没错，我们这样做，

874
00:57:24,700 --> 00:57:30,100
我们刚刚在根目录中添加了一个条目，

875
00:57:30,100 --> 00:57:33,310
即条目 x ，使用我们分配的 inode ，

876
00:57:33,400 --> 00:57:36,040
在一两步之前。

877
00:57:37,250 --> 00:57:37,970
这能理解吗？

878
00:57:40,030 --> 00:57:41,830
那么我们认为 write 32 是什么？

879
00:57:47,190 --> 00:57:47,940
对于块 32 ，

880
00:57:47,940 --> 00:57:49,020
那么现在要做的是，

881
00:57:49,020 --> 00:57:51,000
回去看看磁盘布局图。

882
00:57:51,630 --> 00:57:53,010
块 32 是什么？

883
00:57:55,490 --> 00:57:56,960
可能是 inode 1 。

884
00:57:57,790 --> 00:58:00,490
是的，它将包括 inode 1 ，

885
00:58:00,550 --> 00:58:02,260
包括所有其他 inode ，

886
00:58:02,260 --> 00:58:03,790
因为 inode 比块小，

887
00:58:03,790 --> 00:58:05,650
但它将包括 inode 1 。

888
00:58:06,210 --> 00:58:07,530
你认为它为什么写入，

889
00:58:07,680 --> 00:58:09,870
inode 中可能发生了哪些更改，

890
00:58:09,870 --> 00:58:12,210
需要 inode 实际写入磁盘。

891
00:58:13,390 --> 00:58:14,230
大小。

892
00:58:14,410 --> 00:58:16,030
是的，大小改变了，

893
00:58:16,030 --> 00:58:16,720
大小改变了，

894
00:58:16,720 --> 00:58:19,660
因为我们将目录增加了 16 个字节，

895
00:58:19,660 --> 00:58:21,370
保存条目 x 。

896
00:58:24,220 --> 00:58:27,760
然后还有一个写入 33 ，

897
00:58:28,030 --> 00:58:31,120
我暂且不提这个，

898
00:58:31,180 --> 00:58:36,470
基本上，我们再次更新 x 的 inode ，

899
00:58:36,500 --> 00:58:39,800
即使没有写入什么。

900
00:58:41,540 --> 00:58:42,290
好的?

901
00:58:44,380 --> 00:58:45,490
所以这是第一阶段。

902
00:58:45,520 --> 00:58:47,890
现在我们来看第二个，

903
00:58:48,310 --> 00:58:49,900
所以有创建，

904
00:58:49,900 --> 00:58:51,760
现在我们来看一下第二阶段，

905
00:58:51,760 --> 00:58:52,720
或者第一次写入，

906
00:58:52,720 --> 00:58:55,030
将 hi 写入到文件 x 。

907
00:58:57,470 --> 00:58:59,810
好的，我们认为 45 是什么？

908
00:59:01,910 --> 00:59:04,160
位图？

909
00:59:04,280 --> 00:59:05,360
是的，是位图，

910
00:59:05,360 --> 00:59:07,550
这里发生的事情是，

911
00:59:08,200 --> 00:59:10,840
文件系统扫描位图块，

912
00:59:11,260 --> 00:59:13,570
为了找出没有使用过的块，

913
00:59:13,690 --> 00:59:19,360
找到位 0 ，然后设置为 1 ，

914
00:59:19,360 --> 00:59:22,210
表明这个块现在正在使用。

915
00:59:22,890 --> 00:59:26,430
所以它写入 45 到磁盘中，

916
00:59:26,430 --> 00:59:28,230
更新位图块。

917
00:59:30,180 --> 00:59:33,480
你觉得位图分配器选了哪个块？

918
00:59:36,690 --> 00:59:38,070
595？

919
00:59:38,130 --> 00:59:39,780
是的，很有可能，

920
00:59:39,780 --> 00:59:42,660
因为紧接着我们看到写入 595 ，

921
00:59:43,280 --> 00:59:47,240
很可能这个块是分配给文件 x 的。

922
00:59:47,720 --> 00:59:49,280
所以，在 inode 中，

923
00:59:49,310 --> 00:59:53,510
文件 x 的 bn0 是数字 595 。

924
00:59:54,640 --> 00:59:58,660
那么第一个字节是什么，

925
00:59:58,990 --> 01:00:04,120
在这个写之后，块 595 的第一个字节的值是多少。

926
01:00:05,560 --> 01:00:06,790
H.

927
01:00:06,820 --> 01:00:07,630
H ，是的。

928
01:00:07,900 --> 01:00:12,310
第二个写的是什么，这一个。

929
01:00:14,030 --> 01:00:14,720
i 。

930
01:00:15,200 --> 01:00:17,270
是的，是 i ，

931
01:00:17,270 --> 01:00:21,110
因为每个 echo ，字符是一个接一个的，

932
01:00:21,940 --> 01:00:24,160
好的，我们认为这个 33 是什么？

933
01:00:28,500 --> 01:00:29,730
再次更新大小。

934
01:00:30,180 --> 01:00:31,890
是的，更新 inode 的大小，

935
01:00:31,890 --> 01:00:33,720
因为现在它有两个字节。

936
01:00:34,760 --> 01:00:35,540
这能理解吗？

937
01:00:37,740 --> 01:00:43,590
问题， 595 看起来在磁盘中的位置很高，

938
01:00:43,860 --> 01:00:46,770
那是因为那里目前有着其他的东西，

939
01:00:46,770 --> 01:00:49,950
比如内核引导代码和其他已经启动的东西吗？

940
01:00:50,010 --> 01:00:52,890
是的，我们可以回到这个屏幕，

941
01:00:52,890 --> 01:00:54,930
我们可以看看 make fs 做了什么，

942
01:00:54,930 --> 01:00:57,600
所以 make fs 在那里存储了很多文件，

943
01:00:58,410 --> 01:01:01,050
在我们创建文件 x 之前。

944
01:01:01,800 --> 01:01:04,170
我们创建了所有这些文件。

945
01:01:05,540 --> 01:01:09,470
所以很大一部分磁盘已经被文件填满了，

946
01:01:09,470 --> 01:01:15,350
相当数量的块已经被这些文件使用。

947
01:01:18,660 --> 01:01:19,320
明白了。

948
01:01:20,800 --> 01:01:24,340
写入块 595

949
01:01:24,370 --> 01:01:29,470
是否与上次的 inode 有关，

950
01:01:29,500 --> 01:01:32,500
比如在 write 32 。

951
01:01:32,530 --> 01:01:34,480
是的，完全正确，

952
01:01:34,480 --> 01:01:37,630
这个写入 33 可能有很多东西发生，

953
01:01:37,630 --> 01:01:38,830
大小更新了，

954
01:01:40,640 --> 01:01:45,010
并且 bn0 和 bn1 更新了，

955
01:01:45,040 --> 01:01:48,700
抱歉，只有 bn0 被更新，包含 595 ，

956
01:01:48,700 --> 01:01:51,640
这些信息都被更新到 inode ，

957
01:01:51,640 --> 01:01:54,040
然后写入磁盘。

958
01:01:59,340 --> 01:01:59,970
能理解吗?

959
01:02:01,580 --> 01:02:03,200
是的，谢谢。

960
01:02:04,430 --> 01:02:08,570
很好，这就是磁盘布局的本质，

961
01:02:08,960 --> 01:02:11,210
希望你能很好地理解

962
01:02:11,210 --> 01:02:15,440
这些是如何工作的。

963
01:02:15,440 --> 01:02:17,720
所以现在我们将更详细地看一下，

964
01:02:17,720 --> 01:02:19,190
在代码中，

965
01:02:19,310 --> 01:02:26,120
看看更多一个层次的细节。

966
01:02:26,830 --> 01:02:30,560
好的，重新分 inode 后的第一件事，

967
01:02:30,560 --> 01:02:36,500
我们先来看看是怎么发生的，

968
01:02:36,500 --> 01:02:40,370
所以，在 sysfile 中，让我们看一下[]。

969
01:02:43,940 --> 01:02:47,780
这里是与文件系统调用相关的所有调用，

970
01:02:47,780 --> 01:02:50,300
发生的第一件事是 sys_open ，

971
01:02:50,300 --> 01:02:51,800
因为我们要创建一个文件，

972
01:02:52,440 --> 01:02:55,260
因为 open 要调用 create ，

973
01:02:59,570 --> 01:03:00,860
这里是 create 。

974
01:03:01,520 --> 01:03:03,860
create 稍后将看到，

975
01:03:04,250 --> 01:03:08,390
将路径名解析为最后一个目录，

976
01:03:08,920 --> 01:03:12,100
遍历目录，然后查找，

977
01:03:12,130 --> 01:03:13,450
并真正关心的，

978
01:03:13,930 --> 01:03:15,850
看看文件是否已经存在，

979
01:03:15,850 --> 01:03:18,280
如果文件存在，可能会返回错误。

980
01:03:19,830 --> 01:03:22,080
然后它调用 ialloc ，

981
01:03:22,110 --> 01:03:24,330
这是那个调用，

982
01:03:24,330 --> 01:03:29,280
为文件 x 分配 inode ，

983
01:03:29,850 --> 01:03:32,940
让我们看看，它在 fs.c 中。

984
01:03:37,840 --> 01:03:39,580
这里是 alloc ，

985
01:03:39,610 --> 01:03:41,380
像大多数 xv6 代码一样，

986
01:03:41,380 --> 01:03:42,940
它非常简单，

987
01:03:42,940 --> 01:03:44,260
但性能不是特别高。

988
01:03:44,880 --> 01:03:46,320
它所做的是，

989
01:03:46,320 --> 01:03:50,490
它遍历所有的 inode 编号，

990
01:03:51,090 --> 01:03:53,640
从 1 到任意最大 inode 数，

991
01:03:53,640 --> 01:03:56,880
在这个特定的文件系统上，

992
01:03:57,120 --> 01:04:01,860
然后到达那个 inode 编号的块，

993
01:04:01,860 --> 01:04:03,300
所以，从 1 开始，

994
01:04:03,690 --> 01:04:06,270
包含 inode 编号 1 的块，

995
01:04:06,660 --> 01:04:13,480
然后查看那个 inode 编号是否可用，

996
01:04:13,480 --> 01:04:14,740
如果它不是，

997
01:04:14,770 --> 01:04:15,670
如果它是空闲的，

998
01:04:15,970 --> 01:04:19,630
然后把它设置给文件，

999
01:04:19,630 --> 01:04:22,480
通过这种方式将其标记为已分配，

1000
01:04:22,810 --> 01:04:24,010
并写入磁盘，

1001
01:04:24,040 --> 01:04:26,890
这个 log_write ，有我使用的 print 语句，

1002
01:04:27,220 --> 01:04:28,930
我把它们放到 log_write ，

1003
01:04:29,230 --> 01:04:35,660
所以 log_write 是我们看到第一次写入，

1004
01:04:35,990 --> 01:04:38,480
以我们执行的写入顺序，

1005
01:04:39,500 --> 01:04:40,880
文件系统说做的。

1006
01:04:40,910 --> 01:04:41,750
这能理解吗？

1007
01:04:47,880 --> 01:04:48,810
非常有趣，

1008
01:04:48,930 --> 01:04:52,110
所以这是一系列事件

1009
01:04:52,110 --> 01:04:55,170
让你第一次写入磁盘，

1010
01:04:55,590 --> 01:04:57,510
有趣的问题是，

1011
01:04:58,200 --> 01:05:05,160
如果多个进程同时调用 create 会发生什么，

1012
01:05:05,190 --> 01:05:09,390
多核机器可以并行运行，

1013
01:05:09,420 --> 01:05:13,350
同时下来，几乎同时到达 ialloc ，

1014
01:05:13,680 --> 01:05:16,290
然后它们要调用 bread ，

1015
01:05:16,860 --> 01:05:18,300
所以这里有一些故事，

1016
01:05:18,720 --> 01:05:22,830
或者这些写是如何彼此不干扰的。

1017
01:05:23,700 --> 01:05:25,620
是的，这很值得一看，

1018
01:05:26,070 --> 01:05:28,350
因为在某种意义上，这实际上是

1019
01:05:28,350 --> 01:05:33,420
你正在做的实验的最后一部分，

1020
01:05:33,420 --> 01:05:35,040
所以它会进入缓冲区高速缓存。

1021
01:05:37,940 --> 01:05:40,010
那么让我们来看看 bread ，

1022
01:05:40,580 --> 01:05:42,350
在 bread 中，第一件事是，

1023
01:05:42,350 --> 01:05:43,970
它调用 bget ，

1024
01:05:44,000 --> 01:05:48,200
bget 基本上是在缓冲区高速缓存获取一个插槽。

1025
01:05:48,660 --> 01:05:51,990
让我们看一下 bget ，

1026
01:05:51,990 --> 01:05:53,520
因为有一个非常棘手的代码。

1027
01:05:55,700 --> 01:06:01,040
那么，这里的前几行是怎么回事。

1028
01:06:03,810 --> 01:06:06,720
我想你们中的一些人，已经详细看过了这段代码，

1029
01:06:06,720 --> 01:06:07,770
作为本实验的一部分，

1030
01:06:08,510 --> 01:06:09,500
锁实验。

1031
01:06:10,170 --> 01:06:11,400
那么这里是怎么回事。

1032
01:06:18,480 --> 01:06:23,310
它对链表加锁，并检查是否有任何，

1033
01:06:23,460 --> 01:06:28,470
查看缓存中有没有我们要找的东西。

1034
01:06:28,980 --> 01:06:31,770
是的，所以这是缓存，

1035
01:06:31,770 --> 01:06:34,110
实际上，我们要找的是

1036
01:06:34,110 --> 01:06:37,410
无论什么块编号，块编号 33 ，

1037
01:06:37,740 --> 01:06:41,790
我们查看缓存里是否已经有编号 33 的块。

1038
01:06:43,040 --> 01:06:48,470
如果是这样的话，它就会增加引用数量，

1039
01:06:48,590 --> 01:06:52,130
然后释放 bcache 锁，

1040
01:06:52,160 --> 01:06:54,380
因为我们已经完成了对缓存的查看，

1041
01:06:54,680 --> 01:06:55,880
我们知道它在那里，

1042
01:06:56,210 --> 01:06:59,390
我们知道那里有一个块的缓冲区，

1043
01:06:59,630 --> 01:07:04,820
然后，发生的下一步是非常有趣的。

1044
01:07:06,490 --> 01:07:12,850
下一步，块缓存会尝试获取缓冲区的锁。

1045
01:07:13,660 --> 01:07:19,750
所以，如果多个进程同时调用 bget ，

1046
01:07:19,780 --> 01:07:23,500
其中一个会获得 bcache 锁，对吧。

1047
01:07:24,350 --> 01:07:26,750
它会扫描缓冲区缓存，

1048
01:07:26,780 --> 01:07:29,840
没有人可以在特定时间内修改缓冲区缓存，

1049
01:07:30,420 --> 01:07:32,850
找出块编号是否在那里，

1050
01:07:32,850 --> 01:07:35,130
如果块编号在那里，

1051
01:07:35,130 --> 01:07:36,540
它会增加引用数量，

1052
01:07:36,600 --> 01:07:39,480
表明它有一个引用，

1053
01:07:39,480 --> 01:07:42,100
对于这个特定的锁，

1054
01:07:42,100 --> 01:07:44,530
然后释放 bcache 锁。

1055
01:07:44,800 --> 01:07:47,290
如果有第二个进程等待，

1056
01:07:47,960 --> 01:07:51,560
为了扫描这个缓存，

1057
01:07:51,680 --> 01:07:54,260
它可能不能马上获得锁，

1058
01:07:54,650 --> 01:07:57,050
可能是第二个扫描的进程，

1059
01:07:57,050 --> 01:07:59,630
也想扫描这个块 33 。

1060
01:08:00,140 --> 01:08:06,140
它也会获得引用，增加引用计数，

1061
01:08:06,410 --> 01:08:09,110
到 2 或 3 ，不管是什么

1062
01:08:09,320 --> 01:08:12,350
然后它们两个都会试着调用 acquiresleep ，

1063
01:08:13,200 --> 01:08:15,210
在那个特定缓冲器 33 上。

1064
01:08:16,120 --> 01:08:19,030
acquiresleep 是另一种类型的锁，

1065
01:08:19,210 --> 01:08:21,400
我们称它们为睡眠锁，

1066
01:08:21,580 --> 01:08:23,290
稍后我们会讨论，

1067
01:08:23,500 --> 01:08:28,570
基本上，这会获得缓冲区上的锁，

1068
01:08:28,750 --> 01:08:33,340
所以，进程中的一个将获得缓冲器 33 的锁。

1069
01:08:33,900 --> 01:08:37,290
并将继续进行，并且返回，

1070
01:08:37,590 --> 01:08:39,870
并通过[]，

1071
01:08:40,140 --> 01:08:42,060
扫描块 33 ，

1072
01:08:42,060 --> 01:08:44,220
看看是否 inode 是真正空闲的。

1073
01:08:45,580 --> 01:08:49,360
另一个进程在 acquiresleep 等待，

1074
01:08:49,360 --> 01:08:53,890
等待第一个进程完成所有操作。

1075
01:08:58,380 --> 01:08:59,400
对于这个，有什么问题吗？

1076
01:09:01,970 --> 01:09:03,740
我有个问题，

1077
01:09:05,440 --> 01:09:10,390
当块的引用计数不是 0 时，

1078
01:09:10,390 --> 01:09:13,870
关于块改变有没有什么重要的，

1079
01:09:13,900 --> 01:09:15,760
因为某些事情可能会发生，

1080
01:09:15,760 --> 01:09:21,550
在释放 bcache 和获取块的锁之间。

1081
01:09:22,600 --> 01:09:24,910
是的，原则是，

1082
01:09:24,910 --> 01:09:27,010
好的，这里我要说明几个点，

1083
01:09:27,010 --> 01:09:30,970
xv6 遵循的规则是

1084
01:09:30,970 --> 01:09:33,550
任何对于 bache 本身的修改，

1085
01:09:33,610 --> 01:09:35,050
你都需要持有 bcache 锁。

1086
01:09:36,180 --> 01:09:38,700
对于任何对于块 33 的修改，

1087
01:09:38,730 --> 01:09:41,070
你需要持有块 33 的睡眠锁。

1088
01:09:41,790 --> 01:09:43,800
所以在任何特定的时间点，

1089
01:09:44,100 --> 01:09:52,080
在释放之后， b->refcnt 大于 0 ，

1090
01:09:52,410 --> 01:09:55,770
并且不会对缓冲器高速缓存进行修改，

1091
01:09:56,010 --> 01:09:57,510
缓冲器高速缓存只会驱逐，

1092
01:09:57,920 --> 01:09:59,990
或者具有引用计数 0 的东西，

1093
01:09:59,990 --> 01:10:03,290
refcnt 不会有大于 0 。

1094
01:10:04,120 --> 01:10:05,140
所以我们可以肯定的是，

1095
01:10:05,140 --> 01:10:09,250
这个块，这个缓冲区不会接触 bcache 本身，

1096
01:10:09,550 --> 01:10:11,350
其他进程可能正在查找，

1097
01:10:11,350 --> 01:10:14,770
可能正在查找 bcache 中的条目，

1098
01:10:15,010 --> 01:10:20,220
但它不会从 bcache 中删除，对吧。

1099
01:10:21,160 --> 01:10:21,490
是的，理解了。

1100
01:10:21,490 --> 01:10:24,190
而第二个锁，睡眠锁，

1101
01:10:24,190 --> 01:10:26,770
用来保护缓冲区的内容，

1102
01:10:27,440 --> 01:10:31,850
确保只有一个进程在读取或写入缓冲区，

1103
01:10:32,150 --> 01:10:33,410
在任何时间点。

1104
01:10:36,060 --> 01:10:38,100
这很重要，

1105
01:10:38,550 --> 01:10:43,940
会有什么不好的，

1106
01:10:43,940 --> 01:10:49,870
如果块 33 在缓存的不同的插槽中出现两次。

1107
01:10:53,100 --> 01:10:55,830
是的，因为那样任何都会有正确的信息了，对吧。

1108
01:10:56,720 --> 01:10:57,500
是的，没错，

1109
01:10:57,500 --> 01:11:02,330
比如，进程 1 写入 inode 19 ，

1110
01:11:02,330 --> 01:11:04,520
而另一个进程写入 inode 20 ，

1111
01:11:04,520 --> 01:11:07,010
所以，如果它们都获得了缓冲区的句柄，

1112
01:11:07,280 --> 01:11:10,700
表示块 33 ，

1113
01:11:11,000 --> 01:11:13,310
一个可能更新 inode 18 ，

1114
01:11:13,310 --> 01:11:14,840
另一个是 19 ，

1115
01:11:14,840 --> 01:11:17,600
第一个可能安排 18 写回到磁盘上，

1116
01:11:17,630 --> 01:11:21,740
然后修改 19 的进程写回到 19 ，

1117
01:11:21,860 --> 01:11:24,560
会覆盖 18 所做的更改，

1118
01:11:24,650 --> 01:11:26,120
是 inode 18 所做的。

1119
01:11:26,690 --> 01:11:27,620
所以这太可怕了，

1120
01:11:28,070 --> 01:11:29,480
所以，必须是这种情况，

1121
01:11:29,750 --> 01:11:34,910
块编号只能在缓冲区缓存中出现一次。

1122
01:11:38,380 --> 01:11:39,670
这里有一个不变量，

1123
01:11:39,670 --> 01:11:42,550
你需要维护，

1124
01:11:42,550 --> 01:11:46,690
当你做块缓存实验，锁实验时，

1125
01:11:46,690 --> 01:11:48,850
本周的实验里。

1126
01:11:50,140 --> 01:11:51,670
这能理解吗，那个不变量？

1127
01:11:54,220 --> 01:11:56,650
是的，这是个离题的问题，

1128
01:11:57,010 --> 01:12:00,370
可能有一些块有多个引用，

1129
01:12:00,970 --> 01:12:06,130
然后可能其中一个进程接触到这个块，

1130
01:12:06,430 --> 01:12:09,970
通过强制写入磁盘来刷新高速缓存，

1131
01:12:09,970 --> 01:12:13,510
其他人看到的东西会发生什么。

1132
01:12:14,070 --> 01:12:18,280
是的，就像我做的，如果写，

1133
01:12:18,280 --> 01:12:20,440
好的，第一个进程在某个点上完成了，

1134
01:12:20,440 --> 01:12:24,220
会调用 release ，

1135
01:12:24,220 --> 01:12:26,290
所以你可以想一想，

1136
01:12:26,680 --> 01:12:29,650
当第一个进程完成，

1137
01:12:29,650 --> 01:12:32,020
通过读写块 33 ，

1138
01:12:32,290 --> 01:12:34,150
它会调用 brelse 释放那个缓存，

1139
01:12:34,540 --> 01:12:37,870
这会减少 refcnt ，

1140
01:12:38,460 --> 01:12:40,050
releasesleep 锁，

1141
01:12:40,080 --> 01:12:42,000
也就是说，如果有人在等，

1142
01:12:42,000 --> 01:12:44,490
任何其他等待特定缓冲区的进程，

1143
01:12:44,730 --> 01:12:48,150
现在能够获得缓冲区上的睡眠锁，

1144
01:12:48,390 --> 01:12:55,050
会看到之前做的修改。

1145
01:12:55,050 --> 01:12:56,430
所以，如果两个进程返回，

1146
01:12:56,430 --> 01:12:58,980
更新 inode 18 和 inode 19 ，

1147
01:12:58,980 --> 01:13:00,660
它们都在块 33 上，

1148
01:13:00,930 --> 01:13:02,580
那么如果第一个过程完成了，

1149
01:13:02,670 --> 01:13:04,560
它修改的 18 是可见的，

1150
01:13:04,920 --> 01:13:08,160
所以下一个，

1151
01:13:08,160 --> 01:13:11,340
下一个进程会分配 inode 19 ，

1152
01:13:11,370 --> 01:13:13,680
因为现在 18 已经标记为文件了，

1153
01:13:14,820 --> 01:13:17,370
后面的任何进程都会观察到这些变化。

1154
01:13:20,400 --> 01:13:20,940
理解了吗?

1155
01:13:23,220 --> 01:13:24,600
好的，谢谢。

1156
01:13:25,550 --> 01:13:27,350
这正是我们所希望的情况，

1157
01:13:28,400 --> 01:13:31,340
如果一个进程创建 inode 或创建文件，

1158
01:13:31,340 --> 01:13:33,800
那么后面的进程读取，

1159
01:13:33,800 --> 01:13:35,240
应该能观察那个文件。

1160
01:13:37,650 --> 01:13:42,370
好的，因为一个更小的细节，

1161
01:13:42,400 --> 01:13:44,170
正如你在代码中看到的，

1162
01:13:44,170 --> 01:13:48,330
在进程中对缓冲区使用了睡眠锁，

1163
01:13:48,540 --> 01:13:53,940
所以睡眠锁与普通锁或旋转锁略有不同，

1164
01:13:54,150 --> 01:13:56,100
让我们来看一下睡眠锁。

1165
01:13:57,050 --> 01:13:58,820
你会看到它是什么。

1166
01:13:59,350 --> 01:14:00,970
所以我们需要获取睡眠锁。

1167
01:14:02,040 --> 01:14:04,320
是的，当它发生的时候，

1168
01:14:04,350 --> 01:14:06,240
它获取某些字段，

1169
01:14:06,690 --> 01:14:10,740
获取与睡眠锁相关的自旋锁，

1170
01:14:11,160 --> 01:14:13,470
如果锁真的被持有了，

1171
01:14:14,170 --> 01:14:15,520
好的，旋转锁被持有了，

1172
01:14:15,520 --> 01:14:19,450
那么，如果锁真的被持有了。

1173
01:14:19,450 --> 01:14:23,310
好的，让我先看看头文件，

1174
01:14:23,310 --> 01:14:25,320
头文件包含一个 locked 字段，

1175
01:14:25,900 --> 01:14:31,250
然后，就这样了。

1176
01:14:33,800 --> 01:14:35,030
所以，基本上。

1177
01:14:38,110 --> 01:14:40,120
那是自旋锁。

1178
01:14:40,150 --> 01:14:41,440
是的，是自旋锁。

1179
01:14:46,000 --> 01:14:51,490
哦，是的，这是自旋锁。

1180
01:14:55,280 --> 01:14:55,970
很好。

1181
01:15:01,020 --> 01:15:04,860
抱歉，如果锁持有了，

1182
01:15:05,010 --> 01:15:06,960
睡眠锁被持有，它进入睡眠状态。

1183
01:15:08,160 --> 01:15:09,540
它会自行排定调度。

1184
01:15:10,140 --> 01:15:13,980
为什么对这些缓冲器

1185
01:15:13,980 --> 01:15:16,980
我们使用睡眠锁而不是自旋锁，

1186
01:15:17,820 --> 01:15:20,790
因为我们间接地使用自旋锁来实现休眠锁，

1187
01:15:21,060 --> 01:15:22,890
为什么不直接用普通的呢？

1188
01:15:26,760 --> 01:15:29,190
因为磁盘操作需要很长时间？

1189
01:15:29,740 --> 01:15:32,110
是的，原因有很多，

1190
01:15:32,110 --> 01:15:37,480
在自旋锁上有各种各样的限制，

1191
01:15:37,570 --> 01:15:39,700
自旋锁的限制之一是什么。

1192
01:15:43,990 --> 01:15:44,530
你要做什么。

1193
01:15:44,530 --> 01:15:46,000
中断必须关闭。

1194
01:15:46,330 --> 01:15:47,920
是的，它们会关闭中断。

1195
01:15:48,830 --> 01:15:52,160
所以我们开始这个操作，

1196
01:15:52,520 --> 01:15:56,330
在缓冲器上持有自旋锁，

1197
01:15:56,330 --> 01:15:58,310
然后我们再也不会从磁盘让出。

1198
01:15:58,700 --> 01:16:00,170
嗯，也许还有另一个核心，

1199
01:16:00,170 --> 01:16:01,700
但是如果我们只有一个核心，

1200
01:16:01,700 --> 01:16:03,290
我们永远不会从它让出，是吧。

1201
01:16:05,320 --> 01:16:07,360
出于同样的原因，

1202
01:16:07,360 --> 01:16:10,300
你不能持有自旋锁进入睡眠。

1203
01:16:10,930 --> 01:16:13,960
所以，我们有了这些睡眠锁，

1204
01:16:13,960 --> 01:16:15,490
这是一种长期的锁，

1205
01:16:15,490 --> 01:16:19,810
对于这个特定情况。

1206
01:16:20,310 --> 01:16:23,220
所以我们可以持有锁，

1207
01:16:23,220 --> 01:16:25,950
睡眠锁的优点之一，

1208
01:16:25,950 --> 01:16:27,570
我们可以持有它们通过中断，

1209
01:16:27,840 --> 01:16:29,490
因为磁盘操作，

1210
01:16:29,490 --> 01:16:30,960
我们可以长时间持有它们。

1211
01:16:32,010 --> 01:16:34,890
如果我们在等待那把锁，

1212
01:16:34,890 --> 01:16:37,740
我们也不会让 CPU 保持忙碌，

1213
01:16:37,740 --> 01:16:39,090
或花费在 CPU 上，

1214
01:16:39,150 --> 01:16:42,090
我们通过调用 sleep 来释放 CPU 。

1215
01:16:43,530 --> 01:16:44,190
这能理解吗？

1216
01:16:49,580 --> 01:16:50,570
对于这个，有什么问题吗？

1217
01:16:56,490 --> 01:17:00,840
好的，我们再来看一件事，

1218
01:17:00,840 --> 01:17:07,360
这就是 brelse 。

1219
01:17:08,190 --> 01:17:10,170
所以我们已经看了一点，

1220
01:17:10,170 --> 01:17:12,750
brelse 释放睡眠锁，

1221
01:17:12,780 --> 01:17:15,570
然后获取 bcache 锁，减少 refcnt ，

1222
01:17:15,570 --> 01:17:18,990
表示一个进程对这个缓冲区不再感兴趣。

1223
01:17:19,590 --> 01:17:22,170
然后，如果 refcnt 为 0 ，

1224
01:17:22,440 --> 01:17:29,690
它稍微操作一下缓冲区列表，

1225
01:17:29,690 --> 01:17:30,740
它在这里做什么。

1226
01:17:38,220 --> 01:17:47,350
它将 b 插入到列表中 b->head 之后。

1227
01:17:47,470 --> 01:17:49,030
是的，这是它做做什么，

1228
01:17:49,030 --> 01:17:50,050
那是什么意思。

1229
01:17:52,340 --> 01:17:55,460
让我们返回，让我们来看看。

1230
01:17:56,640 --> 01:18:00,080
它是最近使用过。

1231
01:18:00,140 --> 01:18:04,640
是的，移动到最近使用的缓冲区的位置。

1232
01:18:05,340 --> 01:18:06,600
这一点很重要，

1233
01:18:06,600 --> 01:18:12,150
因为当我们在块缓存中找不到块的时候，

1234
01:18:12,770 --> 01:18:16,490
那么我们需要一些东西来腾出空间，对吧。

1235
01:18:17,280 --> 01:18:19,920
所以我们遍历块，

1236
01:18:19,920 --> 01:18:23,100
我们从最近使用的一个开始。

1237
01:18:24,800 --> 01:18:26,120
先想一想这一点。

1238
01:18:27,540 --> 01:18:32,460
所以，我们使用缓冲区，可能刚刚逐出。

1239
01:18:33,540 --> 01:18:35,100
为什么这是个好的策略。

1240
01:18:41,610 --> 01:18:44,760
通常情况下，系统服从时间局部性。

1241
01:18:45,180 --> 01:18:48,570
是的，如果块是最近用过的，

1242
01:18:48,570 --> 01:18:49,920
这可能是一个很好的迹象，

1243
01:18:49,920 --> 01:18:51,780
表明它可能会很快再次被使用。

1244
01:18:52,390 --> 01:18:54,640
所以不把它赶出去是个好主意。

1245
01:18:55,320 --> 01:18:57,270
你想要，通常情况下，

1246
01:18:57,270 --> 01:19:00,960
即使有本地缓存，

1247
01:19:00,960 --> 01:19:05,070
最近最少使用的块，

1248
01:19:05,070 --> 01:19:08,670
可能是未来最有可能使用的块，

1249
01:19:08,820 --> 01:19:10,560
所以，这是一个很好的[驱逐]。

1250
01:19:12,220 --> 01:19:12,910
这能理解吗？

1251
01:19:18,160 --> 01:19:19,720
好的。

1252
01:19:21,920 --> 01:19:25,280
所以，让我回到幻灯片上，

1253
01:19:25,280 --> 01:19:30,980
所以， bcache 代码中有一点小偏差，

1254
01:19:30,980 --> 01:19:37,450
在块缓存中。

1255
01:19:40,200 --> 01:19:42,720
在这里有几个有趣的事情，

1256
01:19:42,720 --> 01:19:43,890
有一个不变量，

1257
01:19:43,890 --> 01:19:48,310
内存中只有一份块的副本。

1258
01:19:50,840 --> 01:19:52,250
作为重要的变量

1259
01:19:52,280 --> 01:19:54,260
必须由块缓存维护，

1260
01:19:54,260 --> 01:19:55,790
它有睡眠锁，

1261
01:19:55,820 --> 01:19:58,940
和我们以前见过的不同类型的锁，

1262
01:19:59,510 --> 01:20:03,320
它可以跨越 IO 操作，实现 LRU ，

1263
01:20:03,350 --> 01:20:05,630
最近最少缓存替换策略，

1264
01:20:05,840 --> 01:20:08,780
需要有两个级别的锁，

1265
01:20:09,540 --> 01:20:13,170
在它的实现中，

1266
01:20:13,170 --> 01:20:16,560
一级是为了保护 bcache 内部数据结构，

1267
01:20:16,860 --> 01:20:21,720
然后另一级锁，通过睡眠锁对不同的缓存加锁。

1268
01:20:26,570 --> 01:20:27,410
这能理解吗？

1269
01:20:29,230 --> 01:20:30,370
好的。

1270
01:20:32,200 --> 01:20:33,610
我的时间快用完了，

1271
01:20:33,610 --> 01:20:35,590
所以让我停在这里，

1272
01:20:35,890 --> 01:20:38,980
很快总结一下我们到目前为止所看到的，

1273
01:20:38,980 --> 01:20:39,790
在下周三，

1274
01:20:39,790 --> 01:20:42,970
我们将关注崩溃安全问题。

1275
01:20:43,210 --> 01:20:46,570
文件系统在这个数据结构上，

1276
01:20:47,410 --> 01:20:48,880
今天演讲的大部分时间，

1277
01:20:48,880 --> 01:20:52,240
我们都集中在数据结构上，

1278
01:20:52,270 --> 01:20:56,710
对于 xv6 ，磁盘上的这个数据结构，

1279
01:20:56,710 --> 01:20:59,710
我们看到 xv6 有一个非常简单的。

1280
01:21:04,480 --> 01:21:05,470
但是你可以想象一下，

1281
01:21:05,470 --> 01:21:07,600
比如实现更复杂的。

1282
01:21:07,930 --> 01:21:09,640
我们花了很多时间的另一件事是

1283
01:21:09,640 --> 01:21:10,840
查看这个块缓存，

1284
01:21:10,840 --> 01:21:12,520
这对性能至关重要，

1285
01:21:12,760 --> 01:21:16,150
因为对磁盘的读写是昂贵的，

1286
01:21:16,180 --> 01:21:19,330
那里有几百微秒到几毫秒的时间，

1287
01:21:19,540 --> 01:21:21,670
块缓存可以确保，

1288
01:21:22,030 --> 01:21:25,450
如果最近从磁盘读取了块，

1289
01:21:25,450 --> 01:21:27,580
我们不会再从磁盘中读取它。

1290
01:21:28,620 --> 01:21:30,750
好的，然后是周三，

1291
01:21:30,750 --> 01:21:32,460
我要谈的是崩溃安全，

1292
01:21:33,890 --> 01:21:38,720
是文件系统设计的另一个吸引人的方面，

1293
01:21:38,720 --> 01:21:41,120
事实上，我们将花两节课来讲解崩溃安全问题。

1294
01:21:41,660 --> 01:21:44,480
我们将在周三看到一个慢的日志设计，

1295
01:21:44,480 --> 01:21:45,170
然后在下周，

1296
01:21:45,170 --> 01:21:48,350
我们将了解 Linux ext3 如何进行日志记录，

1297
01:21:48,470 --> 01:21:50,330
是一个更快的方案。

1298
01:21:51,620 --> 01:21:52,850
如果你有任何其他问题，

1299
01:21:52,850 --> 01:21:54,530
请随意提问，

1300
01:21:54,560 --> 01:21:56,360
我很乐意回答，

1301
01:21:56,360 --> 01:21:59,080
否则，周三见。

1302
01:22:02,160 --> 01:22:03,000
好的，谢谢。

1303
01:22:04,370 --> 01:22:07,640
我有一个关于 brelse 的问题。

1304
01:22:08,330 --> 01:22:08,810
是的。

1305
01:22:09,640 --> 01:22:15,460
看起来像是它释放了块的锁，

1306
01:22:15,520 --> 01:22:19,600
在它修改了 refcnt 之后。

1307
01:22:19,720 --> 01:22:20,320
嗯。

1308
01:22:21,180 --> 01:22:22,650
为什么这样可以？

1309
01:22:22,890 --> 01:22:23,940
是的，好问题。

1310
01:22:25,580 --> 01:22:26,750
所以我们知道，

1311
01:22:26,930 --> 01:22:29,510
假设我们释放了睡眠锁，

1312
01:22:29,570 --> 01:22:34,490
如果其他程序正在等待，

1313
01:22:34,490 --> 01:22:36,260
或者要获取睡眠锁，

1314
01:22:36,290 --> 01:22:38,180
这对 refcnt 是什么意思？

1315
01:22:41,300 --> 01:22:43,640
它是 0 ？

1316
01:22:45,230 --> 01:22:46,700
不，

1317
01:22:46,700 --> 01:22:50,330
如果 n 个进程正在等待缓冲区。

1318
01:22:50,480 --> 01:22:52,100
哦，好的。

1319
01:22:52,220 --> 01:22:52,850
refcnt 是什么？

1320
01:22:54,390 --> 01:22:56,670
至少是 1 。

1321
01:22:57,290 --> 01:22:58,580
是的，多于 1 ，

1322
01:22:58,580 --> 01:22:59,870
如果 10 个进程正在等待，

1323
01:22:59,870 --> 01:23:00,860
则 refcnt 会是 10 。

1324
01:23:01,640 --> 01:23:02,810
是的，好的。

1325
01:23:03,380 --> 01:23:07,460
所以，这一行代码，

1326
01:23:07,460 --> 01:23:08,090
它所做的，

1327
01:23:08,090 --> 01:23:10,760
就是更新一个 refcnt ，

1328
01:23:10,790 --> 01:23:12,860
就是执行释放的进程，

1329
01:23:12,860 --> 01:23:15,620
并且它将 refcnt 减少 1 。

1330
01:23:16,490 --> 01:23:18,500
如果其他人在等待，

1331
01:23:18,620 --> 01:23:21,080
refcnt 肯定不是 0 ，

1332
01:23:21,080 --> 01:23:22,970
它永远不会执行这个代码。

1333
01:23:25,640 --> 01:23:26,150
好的?

1334
01:23:26,180 --> 01:23:28,130
好的，好的，我明白了，

1335
01:23:28,160 --> 01:23:29,810
我想我明白了。

1336
01:23:30,380 --> 01:23:32,000
一个更进一步的问题是，

1337
01:23:32,000 --> 01:23:39,500
为什么两个字节对于 inode 编号是足够的。

1338
01:23:39,590 --> 01:23:43,310
它不是，它小得离谱，对吧，

1339
01:23:43,520 --> 01:23:45,470
因为你可以拥有多少个 inode ？

1340
01:23:46,800 --> 01:23:49,020
2 的 8 次方？

1341
01:23:49,520 --> 01:23:53,330
是的，随便吧，两个字节。

1342
01:23:53,570 --> 01:23:54,860
16 位。

1343
01:23:55,640 --> 01:23:58,640
[] [] ，32000 个 inode 。

1344
01:23:59,540 --> 01:24:03,200
对于 20 世纪 60 年代或 70 年代来说，这是很多的 inode ，

1345
01:24:03,230 --> 01:24:05,360
但对今天来说肯定是不够的。

1346
01:24:06,700 --> 01:24:11,110
所以，今天的文件系统使用更大的数字或更多的位。

1347
01:24:12,140 --> 01:24:13,800
好的，我明白了。

1348
01:24:13,800 --> 01:24:14,970
我想我的问题是

1349
01:24:15,090 --> 01:24:20,240
关于 xv6 的架构，

1350
01:24:20,930 --> 01:24:24,680
这 16 位的 inode ，

1351
01:24:25,160 --> 01:24:27,080
它们在哪里，

1352
01:24:27,320 --> 01:24:30,680
我们还能在哪里看到这个数字出现。

1353
01:24:31,490 --> 01:24:34,640
好的，它是两个字节，

1354
01:24:34,850 --> 01:24:37,820
在磁盘上，它是两个字节。

1355
01:24:38,420 --> 01:24:41,390
任何数字，

1356
01:24:41,870 --> 01:24:43,070
当它编译时，

1357
01:24:43,070 --> 01:24:46,040
当它位于寄存器或内存中时。

1358
01:24:46,580 --> 01:24:49,130
磁盘 inode 是，

1359
01:24:49,160 --> 01:24:55,510
让我看看，

1360
01:24:56,170 --> 01:24:59,590
正如之前所说的，磁盘 inode 实际上是，

1361
01:25:03,900 --> 01:25:05,130
使用一个直接条目，

1362
01:25:05,130 --> 01:25:06,840
我们看到是一个无符号短整型，

1363
01:25:06,870 --> 01:25:08,880
而[另一个]则是两个字节的 16 位。

1364
01:25:09,520 --> 01:25:12,790
inode 在内存中表示形式，

1365
01:25:13,540 --> 01:25:16,660
好的，是在，

1366
01:25:18,910 --> 01:25:21,400
在内存中表示的 inode ，

1367
01:25:21,940 --> 01:25:26,840
这个数字是整型，

1368
01:25:26,840 --> 01:25:29,750
你知道我们编译 C 代码的方式，

1369
01:25:29,750 --> 01:25:31,760
而整型恰好是 4 个字节。

1370
01:25:34,480 --> 01:25:38,050
好的，我明白了，谢谢，非常感谢。

