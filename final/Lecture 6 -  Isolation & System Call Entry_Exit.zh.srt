1
00:00:02,310 --> 00:00:03,120
好的。

2
00:00:03,780 --> 00:00:05,490
我准备开始了。

3
00:00:05,820 --> 00:00:07,770
首先，大家都能听到我说话吗？

4
00:00:09,150 --> 00:00:09,840
是的。

5
00:00:10,320 --> 00:00:11,910
好的，非常感谢。

6
00:00:13,300 --> 00:00:15,370
好，今天我要讲的是，

7
00:00:15,640 --> 00:00:19,750
在用户代码中运行程序

8
00:00:19,780 --> 00:00:23,050
和在内核中执行之间的转换，

9
00:00:23,410 --> 00:00:25,330
这就是必须要发生的转换，

10
00:00:25,330 --> 00:00:27,340
每当程序进行系统调用时，

11
00:00:27,370 --> 00:00:30,820
通过一个错误，比如页面错误，除零错误，

12
00:00:30,910 --> 00:00:33,700
或者设备决定中断

13
00:00:33,700 --> 00:00:36,550
并且由内核设备驱动程序提供服务。

14
00:00:38,020 --> 00:00:41,710
这里面有很多精心的设计和一些重要的细节，

15
00:00:41,710 --> 00:00:46,540
深入了解这些 trap 是如何从用户到内核的，

16
00:00:46,660 --> 00:00:48,790
细节很重要，

17
00:00:48,790 --> 00:00:53,800
对于实施隔离安全和性能，

18
00:00:53,800 --> 00:00:57,280
有很多程序进行了大量的内核转换，

19
00:00:57,310 --> 00:01:00,400
或者由于系统调用页面错误，

20
00:01:01,000 --> 00:01:02,770
它可以是非常重要的

21
00:01:02,770 --> 00:01:06,330
trap 机制尽可能地[]。

22
00:01:07,530 --> 00:01:12,450
好的，开始的情况是比较熟悉的，

23
00:01:12,840 --> 00:01:16,800
我们有用户程序，

24
00:01:16,800 --> 00:01:18,600
我使用 shell 作为示例。

25
00:01:19,570 --> 00:01:21,130
在用户空间中运行。

26
00:01:21,520 --> 00:01:24,620
嗯，我们有一个内核，

27
00:01:24,620 --> 00:01:28,490
shell 希望进行系统调用进入内核。

28
00:01:29,100 --> 00:01:32,490
将使用 write ，使用 shell 输出其提示符，

29
00:01:32,490 --> 00:01:35,850
引导 xv6 之后发生的第一次写入，

30
00:01:36,120 --> 00:01:39,330
使用 shell 用来写入的 write 系统调用作为示例。

31
00:01:39,840 --> 00:01:41,070
所以我们需要弄清楚，

32
00:01:41,070 --> 00:01:45,330
如何真正从 shell 运行中转换，

33
00:01:45,330 --> 00:01:48,030
具有用户权限的用户空间，

34
00:01:48,450 --> 00:01:50,760
在内核中运行则具有管理员权限，

35
00:01:51,060 --> 00:01:55,230
硬件的状态将非常重要，

36
00:01:55,230 --> 00:01:56,100
因为我们所做的很多事情

37
00:01:56,100 --> 00:01:58,200
都在某种程度上改变了硬件状态，

38
00:01:58,200 --> 00:02:01,260
从适合运行用户代码的状态

39
00:02:01,260 --> 00:02:04,950
到适合运行内核代码的状态。

40
00:02:06,060 --> 00:02:07,560
我们所关心的状态，

41
00:02:07,890 --> 00:02:12,960
最重要的可能是 32 个用户寄存器。

42
00:02:13,440 --> 00:02:16,590
你还记得周一的讨论中提到的这一点，

43
00:02:16,740 --> 00:02:21,270
我们有所有的用户寄存器，比如 a0 和 a1 。

44
00:02:22,910 --> 00:02:26,030
RISC-V 总共有 32 个，

45
00:02:26,090 --> 00:02:28,190
我们可以在用户代码使用它们。

46
00:02:28,720 --> 00:02:31,720
如果它们全部使用，将获得最高的性能，

47
00:02:31,720 --> 00:02:33,250
它们中的许多有特殊的目的，

48
00:02:33,250 --> 00:02:37,510
我们将看到的，特别有趣的一个是栈指针，

49
00:02:37,540 --> 00:02:41,290
实际上是这 32 个通用寄存器中的一个。

50
00:02:42,340 --> 00:02:47,230
好的，我们有这些寄存器，包括栈指针，

51
00:02:47,350 --> 00:02:51,130
硬件中有单独的程序计数器寄存器。

52
00:02:51,580 --> 00:02:56,260
当前模式可以是管理员模式，

53
00:02:56,260 --> 00:02:58,300
当然也可以是用户模式。

54
00:02:58,700 --> 00:03:01,160
我们在 shell 里执行。

55
00:03:02,840 --> 00:03:05,660
然后是许多寄存器，特殊寄存器，

56
00:03:05,660 --> 00:03:08,120
它们控制着 CPU 的工作方式，

57
00:03:08,120 --> 00:03:12,890
比如 satp 寄存器，它包含指向页表的指针，

58
00:03:12,980 --> 00:03:14,480
还有其他几个

59
00:03:14,480 --> 00:03:16,370
对这场讨论非常重要，

60
00:03:16,550 --> 00:03:21,130
有 stvec ，它是（处理中断）指令的地址，

61
00:03:21,130 --> 00:03:24,640
该指令处理内核中的 trap 。

62
00:03:25,450 --> 00:03:29,800
有一个名为 SEPC 的寄存器，用于在 trap 期间保存程序计数器，

63
00:03:29,800 --> 00:03:34,690
还有一个叫 sscratch 的寄存器也很重要，

64
00:03:34,990 --> 00:03:39,010
这是系统调用时正在运行的计算机的状态，

65
00:03:39,010 --> 00:03:41,080
实际上我们需要改变这种状态，

66
00:03:41,080 --> 00:03:44,950
或者作为进入内核的一部分对状态执行操作，

67
00:03:45,280 --> 00:03:49,720
并设置为只在内核中运行普通的 C 函数。

68
00:03:50,210 --> 00:03:52,580
当然在 trap 发生的时候，

69
00:03:52,850 --> 00:03:57,260
CPU 的所有状态都设置为运行用户代码，而不是内核代码。

70
00:03:57,880 --> 00:03:59,590
因此，发生的事情

71
00:03:59,590 --> 00:04:01,390
在某种程度上是我将要谈论的内容的预览，

72
00:04:01,720 --> 00:04:05,980
一个是，我们需要保存全部的 32 个寄存器，

73
00:04:05,980 --> 00:04:10,510
因为我们希望透明地恢复用户代码，

74
00:04:10,660 --> 00:04:14,110
特别是在不是用户代码预期的设备中断的情况下，

75
00:04:14,440 --> 00:04:16,510
我们希望能够让内核为中断提供服务，

76
00:04:16,510 --> 00:04:20,590
然后恢复用户代码，而不会注意到任何差异，

77
00:04:20,590 --> 00:04:23,710
这意味着这 32 个寄存器不能被内核干扰，

78
00:04:24,100 --> 00:04:26,680
从内核开始，你需要使用它拥有的寄存器

79
00:04:26,680 --> 00:04:28,000
将它们全部保存在某个地方，

80
00:04:28,000 --> 00:04:29,590
首先，这些需要保存。

81
00:04:30,460 --> 00:04:33,250
程序计数器也需要保存在某个地方，

82
00:04:33,310 --> 00:04:36,790
因为我们需要一个用户寄存器，

83
00:04:36,790 --> 00:04:40,930
因此，我们需要在用户程序停止的地方继续执行，

84
00:04:41,140 --> 00:04:44,020
我们将模式切换到管理者模式，

85
00:04:44,600 --> 00:04:47,960
因为我们需要使用内核中的各种权限。

86
00:04:48,920 --> 00:04:54,300
页表指针目前指向用户页表，

87
00:04:54,300 --> 00:04:58,920
它只包含用户程序需要的映射。

88
00:04:59,350 --> 00:05:00,790
再加上一两个，我们会看到的，

89
00:05:00,790 --> 00:05:02,950
但是用户页表不包含

90
00:05:02,950 --> 00:05:05,020
大量内核数据的映射，

91
00:05:05,320 --> 00:05:08,980
因此，在运行大多数内核代码之前，我们需要切换页表。

92
00:05:10,430 --> 00:05:12,200
我们需要将栈指针切换

93
00:05:12,200 --> 00:05:14,240
指向内核中某个位置的栈，

94
00:05:14,240 --> 00:05:17,300
因为我们需要调用 C 函数使用的栈。

95
00:05:17,920 --> 00:05:18,370
嗯。

96
00:05:19,830 --> 00:05:21,780
最后，我们需要跳进，

97
00:05:21,810 --> 00:05:22,770
一旦我们把这些都设置好了，

98
00:05:22,770 --> 00:05:24,900
并将所有这些资源

99
00:05:24,900 --> 00:05:27,420
转换为适合在内核中使用的资源，

100
00:05:27,540 --> 00:05:29,640
我们需要跳到内核 C 代码，

101
00:05:29,640 --> 00:05:32,160
一旦我们进入 C 代码，

102
00:05:32,520 --> 00:05:36,660
事情就像往常一样，

103
00:05:36,660 --> 00:05:38,700
我们只是在内核中运行 C 程序，

104
00:05:38,940 --> 00:05:40,560
至少到目前为止，

105
00:05:40,560 --> 00:05:44,460
我们稍后会讨论内核中 C 代码做了什么，

106
00:05:44,490 --> 00:05:46,680
但今天的讨论是

107
00:05:46,680 --> 00:05:49,140
如何从用户空间进入内核，

108
00:05:49,140 --> 00:05:52,680
在那里我们可以在内核中运行 C 代码。

109
00:05:53,510 --> 00:05:55,340
有几个高层次的目标，

110
00:05:55,340 --> 00:05:57,920
这限制了我们在这方面的设计选择，

111
00:05:58,310 --> 00:06:00,860
一个是为了安全和隔离，

112
00:06:00,860 --> 00:06:02,090
我们不想让

113
00:06:02,090 --> 00:06:06,140
用户代码干扰这个用户内核转换，

114
00:06:06,140 --> 00:06:08,270
在某种程度上可能会破坏安全

115
00:06:08,390 --> 00:06:10,250
所以这意味着，

116
00:06:10,250 --> 00:06:14,630
trap 中涉及的各种硬件和内核机制，

117
00:06:14,750 --> 00:06:17,750
不能指望任何来自用户空间的东西，

118
00:06:17,870 --> 00:06:20,450
我们不能对这些寄存器做任何假设，

119
00:06:20,450 --> 00:06:23,270
它们可能包含恶意值，

120
00:06:23,480 --> 00:06:26,180
所以基本上 xv6 trap 处理程序

121
00:06:26,180 --> 00:06:30,200
甚至不会真正查看这些寄存器，只是将它们保存起来。

122
00:06:31,340 --> 00:06:34,070
好的，所以我们要小心，

123
00:06:34,340 --> 00:06:36,470
在 trap 机制期间

124
00:06:36,470 --> 00:06:39,660
针对故意恶意的用户代码保持隔离，

125
00:06:39,900 --> 00:06:41,880
另一件重要的事是，

126
00:06:42,060 --> 00:06:44,130
我们希望这个对用户代码是透明的，

127
00:06:44,160 --> 00:06:46,350
我们希望能够处理 trap ，

128
00:06:46,350 --> 00:06:47,520
并在内核中处理我们的事情，

129
00:06:47,520 --> 00:06:48,930
并恢复用户代码，

130
00:06:48,930 --> 00:06:51,690
而用户代码不会注意到发生了什么。

131
00:06:52,060 --> 00:06:54,100
这是为了让编写用户代码变得更容易。

132
00:06:56,770 --> 00:06:59,170
而且，要注意的是，

133
00:06:59,200 --> 00:07:01,720
我们这里关心的是隔离安全，

134
00:07:01,720 --> 00:07:03,310
今天我们想谈谈。

135
00:07:04,690 --> 00:07:07,360
这些涉及进入内核的安全方面，

136
00:07:07,390 --> 00:07:09,940
当然，这个系统调用实现，

137
00:07:09,940 --> 00:07:12,520
内核中实际的 write 实现，

138
00:07:12,670 --> 00:07:15,280
此外，内核中的所有内容都必须小心，

139
00:07:15,310 --> 00:07:17,500
也必须写得仔细和安全，

140
00:07:18,310 --> 00:07:22,870
因此，即使这种向内核的转换是完全安全的，

141
00:07:22,900 --> 00:07:25,810
内核的其他部分都必须安全地编写，

142
00:07:25,810 --> 00:07:28,930
而且要注意，用户代码可能会试图欺骗它。

143
00:07:30,810 --> 00:07:34,410
我想说的一件特别重要的事情是，

144
00:07:34,410 --> 00:07:38,190
模式标志控制的是什么，

145
00:07:39,180 --> 00:07:41,400
模式可以是用户模式或管理员模式，

146
00:07:41,400 --> 00:07:44,040
当然，用户可以使用任何用户空间，

147
00:07:44,040 --> 00:07:47,340
模式标志被设置管理员，则在内核中执行，

148
00:07:47,460 --> 00:07:52,710
但重要的是要确切地知道我们获得了什么特权，

149
00:07:52,740 --> 00:07:55,080
通过将模式从用户改变为管理员，

150
00:07:55,140 --> 00:07:56,790
结果是。

151
00:07:57,320 --> 00:08:00,650
这些额外的特权是相当有限的，

152
00:08:00,920 --> 00:08:03,260
这是你在管理员模式下可以做的，

153
00:08:03,260 --> 00:08:04,880
在用户模式下不能做，

154
00:08:05,180 --> 00:08:11,030
可能不是你想的那样的特权，

155
00:08:11,030 --> 00:08:14,750
这正是它所控制的管理员模式。

156
00:08:15,760 --> 00:08:22,240
它所做的一件事是你可以读写控制寄存器。

157
00:08:23,110 --> 00:08:26,720
而且，如果你在管理员模式，

158
00:08:26,720 --> 00:08:30,520
你可以读写 SATP ，即页表指针，

159
00:08:30,520 --> 00:08:34,570
这个 stvec 指针，控制 trap 进入内核的位置，

160
00:08:36,080 --> 00:08:39,290
这个寄存器在 trap 期间保存程序计数器，

161
00:08:39,290 --> 00:08:42,450
到 sscatch 寄存器加某些值，

162
00:08:42,930 --> 00:08:45,120
因此管理员模式可以读写这些寄存器，

163
00:08:45,120 --> 00:08:46,230
而用户代码则不能。

164
00:08:46,590 --> 00:08:50,160
另一件事，管理员模式代码可以做的是，

165
00:08:50,250 --> 00:08:53,070
它可以使用 PTE ，

166
00:08:54,620 --> 00:08:58,010
设置了 PTE_U 标志。

167
00:08:59,100 --> 00:08:59,910
我不知道你是否还记得，

168
00:08:59,910 --> 00:09:02,640
但是在每个页表条目上都有

169
00:09:02,640 --> 00:09:04,230
这个 PTE_U 标志被设置或不被设置。

170
00:09:05,870 --> 00:09:07,880
带有此标志的，

171
00:09:07,880 --> 00:09:10,010
不好意思，

172
00:09:10,040 --> 00:09:11,480
可以使用 PTE 。

173
00:09:12,450 --> 00:09:15,480
它们没有设置 PTE_U 标志，

174
00:09:15,510 --> 00:09:17,430
如果 PTE_U 标志被设置，

175
00:09:17,430 --> 00:09:19,980
这意味着用户代码可以使用该页表项，

176
00:09:20,670 --> 00:09:22,530
如果在页表条目中没有设置该标志，

177
00:09:22,530 --> 00:09:24,990
这意味着只有管理者模式才能使用它。

178
00:09:25,560 --> 00:09:29,040
你会发现这有点重要，

179
00:09:29,040 --> 00:09:32,490
但是，这些确实是管理者模式唯一可以做的事情，

180
00:09:32,490 --> 00:09:34,020
它不能特别做其他任何事情，

181
00:09:34,020 --> 00:09:37,980
例如，管理者模式代码不能

182
00:09:37,980 --> 00:09:40,620
读写任意地址，

183
00:09:40,810 --> 00:09:42,520
比如物理地址，

184
00:09:42,520 --> 00:09:46,360
管理者模式被强制通过页表（访问内存），

185
00:09:46,420 --> 00:09:47,650
就像任何其他代码一样，

186
00:09:47,740 --> 00:09:49,960
如果虚拟地址不在页面中，

187
00:09:49,990 --> 00:09:52,660
不在 satp 指向的当前页表中，

188
00:09:53,050 --> 00:09:56,920
或者它设置了 PTE_U 标志，

189
00:09:56,950 --> 00:09:58,390
这意味着它是用户 PTE ，

190
00:09:58,390 --> 00:10:01,300
则管理员模式不能使用该地址，

191
00:10:01,540 --> 00:10:07,570
所以我们在管理模式下也被限制到任何虚拟地址，

192
00:10:07,850 --> 00:10:10,490
在当前页表上设置了虚拟地址。

193
00:10:11,990 --> 00:10:15,890
就是这样，所以我们就被允许做这些事情，

194
00:10:15,890 --> 00:10:17,000
因此，我们将看到，

195
00:10:17,330 --> 00:10:22,160
trap 代码可以做什么，这是一个重要的约束。

196
00:10:22,760 --> 00:10:26,230
当我们进入内核的时候，什么都不能做，

197
00:10:27,070 --> 00:10:28,240
预习一下，

198
00:10:28,480 --> 00:10:32,740
这节课中，我将在 gdb 中花大部分时间，

199
00:10:32,740 --> 00:10:35,080
跟踪整个执行过程

200
00:10:35,560 --> 00:10:39,520
内核中的 trap 条目的返回值，

201
00:10:39,760 --> 00:10:43,240
这里有很多细节，以便。

202
00:10:45,300 --> 00:10:50,220
也许对你有点帮助，看看接下来会发生什么，

203
00:10:50,940 --> 00:10:56,950
我们将跟踪 shell 调用以进行写入，

204
00:10:57,160 --> 00:10:58,210
从 shell 的角度来看，

205
00:10:58,210 --> 00:11:00,760
只是作为 shell 的一部分的 C 函数调用，

206
00:11:01,030 --> 00:11:03,700
实际上 write 实现了这一点，

207
00:11:03,700 --> 00:11:05,920
write 会发出系统调用，

208
00:11:05,950 --> 00:11:07,810
通过发出 ecall 指令，

209
00:11:09,680 --> 00:11:15,140
直接跳转到内核管理者模式，

210
00:11:15,140 --> 00:11:17,000
这是第一条指令

211
00:11:17,300 --> 00:11:19,610
在内核和管理者模式中执行，

212
00:11:19,790 --> 00:11:24,800
是用汇编语言编写的函数 uservec 。

213
00:11:26,140 --> 00:11:28,870
这是 trampoline 的一部分，

214
00:11:33,400 --> 00:11:36,160
在内核代码的 trampoline.S 中，

215
00:11:36,160 --> 00:11:37,930
所以第一个被执行的代码，

216
00:11:37,930 --> 00:11:40,090
是这个 uservec 汇编函数。

217
00:11:40,620 --> 00:11:45,240
接下来，汇编函数跳转到 C 代码，

218
00:11:45,240 --> 00:11:49,670
特别是 trap.c 中名为 usertrap 的函数。

219
00:11:50,850 --> 00:11:55,260
现在我们开始 C 代码，所以事情就容易理解了，

220
00:11:55,440 --> 00:11:58,680
usertrap 执行系统调用，

221
00:11:58,990 --> 00:12:00,730
它调用一个名为 syscall 的函数。

222
00:12:02,580 --> 00:12:04,740
它查看表中的系统调用号，

223
00:12:04,890 --> 00:12:07,980
并调用内核内的特定函数，

224
00:12:07,980 --> 00:12:11,910
它实现了调用我们系统，就是 write ，

225
00:12:11,910 --> 00:12:13,590
write 来做这件事，

226
00:12:13,590 --> 00:12:19,020
安排写入的任何字节显示在控制台上，

227
00:12:20,130 --> 00:12:24,300
并且当它完成时，返回到这个系统调用函数，

228
00:12:24,660 --> 00:12:28,080
然后系统调用函数返回到用户空间，

229
00:12:28,080 --> 00:12:29,370
因为我们想恢复。

230
00:12:29,740 --> 00:12:32,890
在这个 ecall 之后，有很多东西，

231
00:12:32,920 --> 00:12:34,270
是必须要发生的。

232
00:12:34,790 --> 00:12:36,440
为了返回用户空间，

233
00:12:36,440 --> 00:12:41,530
有一个单独的函数 usertrapret ，

234
00:12:42,900 --> 00:12:45,090
它是用 C 写的，在 trap.c 中，

235
00:12:45,090 --> 00:12:48,450
这一部分确实会返回到用户空间，

236
00:12:48,450 --> 00:12:50,460
这在 C 代码中很方便，

237
00:12:50,550 --> 00:12:54,240
有一些最后的事情只能在汇编代码中完成，

238
00:12:55,000 --> 00:12:56,710
这方面的代码是在汇编程序期间编写的，

239
00:12:56,710 --> 00:13:00,400
在这个 trampoline 页面中，有一个名为 userret 的函数。

240
00:13:03,710 --> 00:13:07,790
最后的汇编工作，

241
00:13:07,790 --> 00:13:11,680
最后这个汇编函数执行，

242
00:13:11,680 --> 00:13:14,620
机器指令返回到用户空间，

243
00:13:14,620 --> 00:13:19,030
并在 ecall 之后恢复执行。

244
00:13:20,770 --> 00:13:22,840
好的，有没有什么问题，

245
00:13:22,840 --> 00:13:25,960
我要换成用 gdb 查看代码，

246
00:13:26,860 --> 00:13:29,080
关于高层次图示有什么问题吗？

247
00:13:36,970 --> 00:13:38,980
好的，我要进行。

248
00:13:40,820 --> 00:13:41,570
对不起，我听不清。

249
00:13:42,270 --> 00:13:46,650
嗯，我想一下， vm.c 函数是在什么模式下运行？

250
00:13:47,690 --> 00:13:50,660
vm.c 中的函数，其中的所有内容都是内核的一部分，

251
00:13:50,660 --> 00:13:52,100
它运行在管理者模式。

252
00:13:56,200 --> 00:13:56,620
明白了。

253
00:13:57,700 --> 00:13:58,210
好的。

254
00:14:00,440 --> 00:14:03,350
好的，有人问为什么这些函数要这样命名？

255
00:14:03,710 --> 00:14:04,340
嗯。

256
00:14:05,960 --> 00:14:07,760
命名有点灾难，

257
00:14:07,760 --> 00:14:11,090
明年我决定让它们变得更好理解。

258
00:14:13,830 --> 00:14:17,280
我想命名问题可能与寄存器的名称有关，

259
00:14:17,280 --> 00:14:18,840
在前一块页上显示的寄存器。

260
00:14:19,740 --> 00:14:21,420
管理者模式都是以 s 开头。

261
00:14:24,180 --> 00:14:28,680
另外，有五个人选了这些名字。

262
00:14:29,040 --> 00:14:34,320
有人问 vm.c 函数不是直接访问物理内存吗？

263
00:14:34,380 --> 00:14:35,760
这是绝对正确的，

264
00:14:35,880 --> 00:14:37,380
它们被允许这样做的原因是，

265
00:14:37,380 --> 00:14:42,240
内核在页表中精心设置了直接的映射，

266
00:14:42,510 --> 00:14:44,640
页表中有很多 PTE ，

267
00:14:44,640 --> 00:14:50,340
这导致每当内核试图读取或写入物理地址时，

268
00:14:50,340 --> 00:14:54,360
它实际上是由内核页表转换的虚拟地址

269
00:14:54,360 --> 00:14:58,110
并且是与发出的虚拟地址相等的物理地址。

270
00:14:58,760 --> 00:15:01,130
所以这在内核中非常方便，

271
00:15:01,370 --> 00:15:03,680
一旦你使用内核页表，

272
00:15:03,710 --> 00:15:06,020
这个内核有所有这些直接映射，

273
00:15:06,260 --> 00:15:08,450
但在我们准备好之前，

274
00:15:08,940 --> 00:15:13,410
当前直到 trap 机制切换到内核页表，

275
00:15:13,500 --> 00:15:15,180
这些映射都不可用，

276
00:15:15,780 --> 00:15:18,930
在内核 trap 代码切换到内核页表之前，

277
00:15:18,930 --> 00:15:20,220
我们仍在使用用户页表，

278
00:15:20,220 --> 00:15:24,630
对于物理地址，它没有这些方便的映射。

279
00:15:29,580 --> 00:15:30,600
好的。

280
00:15:34,400 --> 00:15:35,690
我可以问个问题吗？

281
00:15:36,140 --> 00:15:36,770
请问。

282
00:15:37,220 --> 00:15:44,730
嗯，我不知道这可能跟刚才说的不太相关，

283
00:15:44,730 --> 00:15:47,970
但是，读写系统调用，

284
00:15:47,970 --> 00:15:52,620
与内存存储相比是相当昂贵的，

285
00:15:52,620 --> 00:15:55,110
因为你必须实际切换模式并来回切换，

286
00:15:55,410 --> 00:15:57,420
有没有可能就像，

287
00:15:57,800 --> 00:16:02,030
当你打开文件时不是取回文件描述符，

288
00:16:02,030 --> 00:16:07,100
而是可以使用系统调用来调用它来获取页表映射，

289
00:16:07,190 --> 00:16:10,130
然后你只需写到某个地址，

290
00:16:10,340 --> 00:16:13,040
刚刚映射到设备的（的地址），

291
00:16:13,280 --> 00:16:14,870
你可以设置这些限制，

292
00:16:14,870 --> 00:16:19,910
这样程序就只能写入，就像文件描述符一样，

293
00:16:19,910 --> 00:16:23,810
它被允许通过虚拟页表映射，

294
00:16:23,810 --> 00:16:25,670
而不是跳回内核。

295
00:16:26,210 --> 00:16:27,800
是的，这是一个很好的观察，

296
00:16:27,830 --> 00:16:31,310
事实上，许多操作系统都提供

297
00:16:31,310 --> 00:16:33,830
这种所谓的内存映射文件访问，

298
00:16:33,830 --> 00:16:37,860
其中与文件内容相对应的映射页，

299
00:16:37,950 --> 00:16:41,490
进入用户虚拟地址空间，

300
00:16:41,490 --> 00:16:43,770
所以你可以直接通过内存读取或写入它们，

301
00:16:44,190 --> 00:16:46,950
事实上，你将在几周内的

302
00:16:46,950 --> 00:16:49,860
mmap 实验中实现此版本。

303
00:16:51,230 --> 00:16:54,710
事实上，正如你所说的那样，它要快得多，

304
00:16:54,980 --> 00:16:56,810
对于许多程序的调用读取和写入。

305
00:16:59,100 --> 00:16:59,610
好的。

306
00:17:02,380 --> 00:17:06,070
我要切换到 gdb 了。

307
00:17:19,540 --> 00:17:21,490
好的，现在大家都应该，

308
00:17:26,200 --> 00:17:28,240
能看到我的屏幕共享。

309
00:17:29,660 --> 00:17:30,320
嗯。

310
00:17:31,210 --> 00:17:34,150
我们将查看 xv6 系统的 write 。

311
00:17:34,770 --> 00:17:37,470
shell 对其初始提示符的写入，

312
00:17:37,890 --> 00:17:39,120
在系统中使用的方式，

313
00:17:39,120 --> 00:17:44,460
你可以在 sh.c 中看到发起此操作的用户代码。

314
00:17:44,960 --> 00:17:48,670
我确信在进行 write 系统调用，

315
00:17:49,090 --> 00:17:58,270
使用美元符号，提示我们启动 gdb 。

316
00:18:03,330 --> 00:18:09,270
太好了，那么当用户代码在 shell 调用 write 时实际发生了什么呢？

317
00:18:09,270 --> 00:18:11,850
write 只是一个库函数，

318
00:18:11,850 --> 00:18:17,160
是一部分，连接到 shell ，

319
00:18:17,520 --> 00:18:23,500
你可以在 usys.S 中看到它的源码。

320
00:18:24,660 --> 00:18:26,520
就是这些指令，

321
00:18:26,520 --> 00:18:30,120
这是 write 函数的实现，

322
00:18:30,390 --> 00:18:31,680
shell 实际上调用的，

323
00:18:32,100 --> 00:18:34,950
这是一个非常短的函数，

324
00:18:35,070 --> 00:18:39,300
它所做的就是将一个数字 SYS_write 加载到 a7 中，

325
00:18:39,300 --> 00:18:42,840
它定义为 16 ，这告诉内核，

326
00:18:43,350 --> 00:18:48,000
我想运行第 16 个系统调用，就是 write 。

327
00:18:48,340 --> 00:18:51,880
然后这个函数使用 ecall 指令，

328
00:18:52,120 --> 00:18:55,780
实际上就是将代码转入内核，

329
00:18:55,810 --> 00:18:59,860
内核做这件事，然后当内核完成时，

330
00:18:59,860 --> 00:19:04,690
它返回到用户空间，执行 ecall 之后的指令，

331
00:19:04,840 --> 00:19:08,410
这里是返回到 shell 的 write 操作，

332
00:19:09,010 --> 00:19:11,710
从 write 库函数返回到 shell 中。

333
00:19:12,960 --> 00:19:13,980
所以我想要做的

334
00:19:13,980 --> 00:19:15,870
是展示系统调用的一部分，

335
00:19:15,990 --> 00:19:20,670
我将首先在 ecall 指令上设置一个断点，

336
00:19:21,120 --> 00:19:24,120
我们当然需要知道它的地址，

337
00:19:24,420 --> 00:19:27,390
我们可以通过查看 sh.asm 找到，

338
00:19:27,390 --> 00:19:30,690
是 xv6 编译过程产生的，

339
00:19:32,420 --> 00:19:36,080
sh.asm 是汇编代码，

340
00:19:36,080 --> 00:19:42,690
包含 shell 指令地址，

341
00:19:43,050 --> 00:19:45,480
我将在 ecall 指令上设置一个断点，

342
00:19:45,480 --> 00:19:49,230
即地址 0xde6 。

343
00:19:51,310 --> 00:19:54,250
我要开始运行 xv6 ，

344
00:19:54,670 --> 00:19:58,570
我希望让系统在 shell 中断，

345
00:19:58,630 --> 00:20:00,280
在执行 ecall 之前。

346
00:20:02,100 --> 00:20:05,580
好的，太好了，现在你可以从 gdb 上看到，

347
00:20:05,580 --> 00:20:09,480
我们即将执行那个 ecall 。

348
00:20:10,330 --> 00:20:15,880
让我们检查一下，我们是不是在想的那里，

349
00:20:16,240 --> 00:20:18,520
打印，我们可以打印程序计数器，

350
00:20:18,730 --> 00:20:21,040
就是我们设置断点的 0xde6 。

351
00:20:24,750 --> 00:20:29,430
我们也可以把所有的 32 个寄存器打印出来。

352
00:20:30,060 --> 00:20:32,340
其中一些值，

353
00:20:32,340 --> 00:20:34,410
我们不知道，也不关心它们是什么，

354
00:20:34,440 --> 00:20:39,510
但是 a0 a1 和 a2 是 shell 传递给 write 的三个参数，

355
00:20:40,590 --> 00:20:41,490
所以这些参数是，

356
00:20:41,490 --> 00:20:43,620
a0 中的文件描述符 2 ，

357
00:20:44,040 --> 00:20:48,390
a1 中指向 shell 要写入的字符缓冲区的指针，

358
00:20:48,750 --> 00:20:51,570
以及 a2 中它要写入的字符数。

359
00:20:52,150 --> 00:20:53,620
我们可以确信，

360
00:20:53,620 --> 00:20:55,900
查看的代码就是我们想要看的。

361
00:20:56,820 --> 00:21:03,160
通过打印 shell 要写入的缓冲区中的字节，

362
00:21:03,160 --> 00:21:05,950
事实上，这是一个美元符号和一个空格，

363
00:21:05,950 --> 00:21:10,670
所以，我们在我们希望在的系统调用。

364
00:21:11,350 --> 00:21:12,250
需要注意的一件事是

365
00:21:12,250 --> 00:21:15,790
程序计数器和堆栈指针都在低地址，

366
00:21:15,910 --> 00:21:17,350
地址非常接近于零，

367
00:21:17,350 --> 00:21:21,430
这强化了我们的信念，

368
00:21:21,430 --> 00:21:23,410
我们仍然在用户地址运行，

369
00:21:23,410 --> 00:21:26,470
用户地址空间中的地址都很小，

370
00:21:26,500 --> 00:21:28,420
一旦我们到达内核，就会看到地址是，

371
00:21:28,800 --> 00:21:31,680
内核在内存中的要高得多。

372
00:21:35,020 --> 00:21:40,930
好的，系统调用的要点是要切换很多状态，

373
00:21:40,930 --> 00:21:44,170
必须切换的最重要的状态之一

374
00:21:44,170 --> 00:21:47,740
在它被切换之前，我们不得不使用当前的页表。

375
00:21:48,280 --> 00:21:51,400
我们可以查看 satp 。

376
00:21:52,860 --> 00:21:56,430
但是我们在那里得到的只是物理内存页表中的地址，

377
00:21:56,430 --> 00:21:57,810
并没有告诉我们

378
00:21:57,840 --> 00:22:01,230
页表的映射是什么样子，

379
00:22:01,260 --> 00:22:06,960
幸好 QEMU 有办法打印当前页表，

380
00:22:06,990 --> 00:22:12,990
如果我按下 control-a c ，我进入 QEMU 监视器或控制台，

381
00:22:13,410 --> 00:22:18,550
如果我输入 info mem ，它会打印完整的页表，

382
00:22:19,150 --> 00:22:21,010
{}这是一个非常小的页表，

383
00:22:21,010 --> 00:22:23,050
只包含 6 个映射，

384
00:22:23,650 --> 00:22:25,780
当然这是 shell 的页表。

385
00:22:26,290 --> 00:22:28,810
Shell 是一个相当小的程序，

386
00:22:29,080 --> 00:22:33,850
这 6 个映射是按 shell 指令的顺序排列的，

387
00:22:34,230 --> 00:22:40,850
shell 的数据，访问栈保护页的无效页，

388
00:22:40,850 --> 00:22:43,250
以防 shell 试图使用过多的栈空间，

389
00:22:43,400 --> 00:22:44,660
我们可以看到它是无效的，

390
00:22:44,660 --> 00:22:47,360
因为它没有设置 U 标志，

391
00:22:47,390 --> 00:22:51,350
在这里，在属性或标志列中，

392
00:22:52,330 --> 00:22:55,660
这些都是 PTE 下划线标志 r w 和 x ，

393
00:22:55,660 --> 00:22:59,290
控制 PTE 是否可以读、写或执行，

394
00:22:59,920 --> 00:23:01,120
下一列是 u ，

395
00:23:01,120 --> 00:23:03,610
这就是是否设置了 PTE_U 标志

396
00:23:03,610 --> 00:23:08,930
并且用户代码只能使用设置了 U 标志的 PTE 条目，

397
00:23:12,880 --> 00:23:15,640
我不知道下一栏是什么，我得承认，

398
00:23:15,640 --> 00:23:16,750
再下一栏是 a ，

399
00:23:16,750 --> 00:23:19,360
表示 PTE 条目是否使用过，

400
00:23:19,360 --> 00:23:23,990
以及 d 表示是否曾经对该地址写入。

401
00:23:28,260 --> 00:23:29,490
好的，那么我们有这个小的页表，

402
00:23:29,490 --> 00:23:32,010
顺便说一下，在最后两个页表条目中，

403
00:23:32,010 --> 00:23:36,030
都位于一个很大的虚拟地址上，

404
00:23:36,410 --> 00:23:40,340
非常接近虚拟地址空间的顶部，

405
00:23:40,610 --> 00:23:44,090
这就是你们在书中读到的这两个，

406
00:23:44,090 --> 00:23:46,730
我会听到更多关于 trapframe 的页面，

407
00:23:46,730 --> 00:23:48,830
这个是 trampoline 页面，

408
00:23:48,830 --> 00:23:52,250
你可以看到，它们都没有设置 u 标志，

409
00:23:52,520 --> 00:23:57,110
所以用户代码不能访问这两个地址中的任何一个，

410
00:23:57,560 --> 00:24:00,530
但是一旦我们进入管理者模式，我们就可以进入这两个页面。

411
00:24:05,130 --> 00:24:05,760
好的。

412
00:24:07,120 --> 00:24:08,620
嗯，有一点需要注意，

413
00:24:08,620 --> 00:24:12,130
这个页表没有内核中的任何东西的映射，

414
00:24:12,610 --> 00:24:14,170
没有物理地址映射，

415
00:24:14,170 --> 00:24:16,090
没有内核数据映射，

416
00:24:16,120 --> 00:24:18,190
内核指令或其他任何东西，

417
00:24:18,190 --> 00:24:21,610
这只接受最后两页，

418
00:24:21,880 --> 00:24:25,390
现在，这是几乎完全专用于用户执行的页表，

419
00:24:25,570 --> 00:24:28,870
并且对于执行内核并不特别有用。

420
00:24:30,410 --> 00:24:33,800
好的，在页表顶部

421
00:24:33,800 --> 00:24:37,100
列出的属性是什么？

422
00:24:37,160 --> 00:24:39,590
我相信这意味着页表曾经，

423
00:24:40,110 --> 00:24:44,040
该页表项曾经被代码访问过，

424
00:24:44,720 --> 00:24:48,140
就是有没有访问地址

425
00:24:48,140 --> 00:24:50,110
到这个页表。

426
00:24:52,160 --> 00:24:55,370
d 是程序是否曾经写过。

427
00:24:57,270 --> 00:25:00,940
他们已经通过这个页表条目进行了存储，

428
00:25:01,030 --> 00:25:04,270
这些都是硬件

429
00:25:04,270 --> 00:25:06,070
为了操作系统的方便而维护的，

430
00:25:06,070 --> 00:25:10,000
以及比 xv6 更复杂的操作系统。

431
00:25:10,650 --> 00:25:14,100
如果页面的物理内存不足，我们需要将其逐出，

432
00:25:14,100 --> 00:25:17,640
它们可能需要将一些内存页面写入磁盘，

433
00:25:18,040 --> 00:25:22,360
并使页面条目无效以释放物理内存，

434
00:25:22,450 --> 00:25:24,520
很多策略，

435
00:25:24,520 --> 00:25:28,510
你可以想象一个操作系统使用的 pic 页面存在，

436
00:25:28,660 --> 00:25:30,640
现在我们查看比特，

437
00:25:30,640 --> 00:25:33,370
看看这个页表条目是否曾经被使用过，

438
00:25:33,580 --> 00:25:35,860
它最近还没有用过或者已经用过了，

439
00:25:35,860 --> 00:25:39,490
那么这是一个很好的驱逐到磁盘的候选对象。

440
00:25:40,470 --> 00:25:43,800
d 告诉内核

441
00:25:43,800 --> 00:25:48,840
这一页实际上是从磁盘读取后写入的，

442
00:25:50,780 --> 00:25:52,490
xv6 实际上并不使用这些标志。

443
00:25:55,520 --> 00:25:57,500
好的，还有其他问题吗？

444
00:26:02,390 --> 00:26:06,050
好的，我们来执行这个。

445
00:26:06,950 --> 00:26:11,480
我来提醒一下，我们将在哪里打印出 write 的内容，

446
00:26:11,480 --> 00:26:17,690
我们在 write 库函数，在一个 shell 中，

447
00:26:18,170 --> 00:26:20,570
并且程序计数器指向 ecall 指令，

448
00:26:20,570 --> 00:26:22,280
我们即将执行 ecall 指令，

449
00:26:23,000 --> 00:26:25,370
仍在用户空间，但不会持续很长时间。

450
00:26:27,310 --> 00:26:28,900
我执行了 ecall 指令，

451
00:26:30,380 --> 00:26:32,600
好的，那么第一个问题是我们在哪里。

452
00:26:33,440 --> 00:26:37,190
在 ecall 之后，我们可以查看程序计数器。

453
00:26:38,660 --> 00:26:41,510
我们看到，现在这是一个非常低的数字 d6 ，

454
00:26:41,510 --> 00:26:42,710
那是非常高的数字，

455
00:26:42,800 --> 00:26:45,770
事实上，我们看到程序计数器是一个虚拟地址，

456
00:26:45,860 --> 00:26:49,050
就像指令使用的所有地址一样。

457
00:26:50,240 --> 00:26:52,100
我们可以看看页表，

458
00:26:52,430 --> 00:26:55,550
实际上，为了确保正确，让我们检查一下页表，

459
00:26:55,550 --> 00:26:59,150
我再次对 QEMU 输入 info mem ，

460
00:26:59,660 --> 00:27:01,010
这是完全相同的页表，

461
00:27:02,220 --> 00:27:03,390
那里什么都没变，

462
00:27:03,480 --> 00:27:06,240
我们将查找新的当前程序计数器，

463
00:27:06,240 --> 00:27:07,620
程序计数器

464
00:27:07,830 --> 00:27:12,570
在这个 trampoline 页面开头处，

465
00:27:12,570 --> 00:27:16,560
这在用户内存中映射了高地址。

466
00:27:17,460 --> 00:27:21,000
这是正在执行的，我们可以看到指令在那里，

467
00:27:21,350 --> 00:27:22,550
那些我要用的指令。

468
00:27:24,620 --> 00:27:25,460
嗯。

469
00:27:31,340 --> 00:27:33,050
这些都是指令，

470
00:27:34,020 --> 00:27:38,550
内核在管理者模式下执行的第一条指令，

471
00:27:38,550 --> 00:27:40,350
在 trap 刚开始的时候，

472
00:27:40,560 --> 00:27:42,300
并在 gdb 中抛出了一些奇怪的东西，

473
00:27:42,300 --> 00:27:44,730
我们实际上已经执行了第一条指令，

474
00:27:45,210 --> 00:27:47,100
在本页的开头。

475
00:27:49,050 --> 00:27:51,870
我们即将执行第二条指令。

476
00:27:53,560 --> 00:27:55,000
我们可以看看寄存器。

477
00:27:57,060 --> 00:28:00,450
我不知道你是否还记得这些寄存器值，但是这里什么都没有改变，

478
00:28:00,450 --> 00:28:04,200
这些与用户程序具有的寄存器内容完全相同，

479
00:28:04,470 --> 00:28:07,680
所以这些都充满了用户的值，对他们中的许多人来说

480
00:28:07,710 --> 00:28:11,220
就我们所知它们都是唯一值存在的地方，

481
00:28:11,220 --> 00:28:12,450
因此，我们必须非常小心，

482
00:28:12,450 --> 00:28:15,660
在这一点上不能实际使用任何寄存器，

483
00:28:16,220 --> 00:28:20,210
如果没有先将这些寄存器保存在某个地方以便我们可以恢复它们，

484
00:28:20,390 --> 00:28:21,920
因为如果内核在此时

485
00:28:21,920 --> 00:28:24,740
使用这些寄存器中的任何一个，它将被重写。

486
00:28:25,100 --> 00:28:28,010
不管用户值是多少，

487
00:28:28,010 --> 00:28:30,020
然后如果我们试图恢复用户程序，

488
00:28:30,020 --> 00:28:32,870
我们就不能用正确的值设置它的寄存器，

489
00:28:32,870 --> 00:28:36,020
用户程序会做一些完全错误的事情。

490
00:28:37,500 --> 00:28:38,160
有问题吗？

491
00:28:38,310 --> 00:28:39,060
是。

492
00:28:39,390 --> 00:28:43,290
您能回到之前看到的说明面板上吗？

493
00:28:43,320 --> 00:28:47,280
我想知道 csrrw 指令在做什么。

494
00:28:51,070 --> 00:28:52,570
csrrw ，

495
00:28:52,570 --> 00:28:55,480
好的，我们几分钟后会谈到，

496
00:28:56,080 --> 00:28:57,310
但你问题的答案是，

497
00:28:57,310 --> 00:29:03,940
该指令将 a0 与特殊临时寄存器的内容交换。

498
00:29:04,780 --> 00:29:09,730
所以是的，这是很重要的。

499
00:29:10,390 --> 00:29:12,700
基本上回答了这样一个问题，

500
00:29:12,700 --> 00:29:17,020
如果内核 trap 代码不能使用任何寄存器，它怎么能做任何事情，

501
00:29:17,560 --> 00:29:20,980
这个问题的答案是，出口确实必须执行这个，

502
00:29:21,320 --> 00:29:24,590
csrrw a0 sscratch 指令，

503
00:29:24,920 --> 00:29:28,280
这在 scratch 时保存 a0 ，

504
00:29:28,310 --> 00:29:30,800
并且将 scratch 加载到 a0 中。

505
00:29:31,880 --> 00:29:36,170
因此，现在内核可以在此指令之后使用 a0 进行任何操作。

506
00:29:38,890 --> 00:29:39,790
好的，谢谢。

507
00:29:39,970 --> 00:29:40,570
好的。

508
00:29:41,710 --> 00:29:45,970
好的，我们目前的地址是 0x3ffffff000 ，

509
00:29:46,090 --> 00:29:48,160
现在这最后一个页面是 trampoline 页面，

510
00:29:48,160 --> 00:29:50,950
我们目前正在 trampoline 页面中执行，

511
00:29:50,980 --> 00:29:56,230
它包含内核 trap 处理代码的第一条指令。

512
00:29:58,000 --> 00:30:02,200
ecall 不会切换页表，这是 ecall 非常重要的一点，

513
00:30:02,200 --> 00:30:04,780
这意味着这些最早的指令

514
00:30:04,780 --> 00:30:07,570
必须出现在每个用户页表中。

515
00:30:08,080 --> 00:30:10,240
因为 ecall 不切换页表，

516
00:30:10,240 --> 00:30:12,610
我们需要执行内核的第一位，

517
00:30:12,820 --> 00:30:14,470
在用户页表中的某个位置，

518
00:30:14,470 --> 00:30:16,000
这个 trampoline 页面，

519
00:30:16,090 --> 00:30:19,240
内核仔细地映射到每个用户页表中，

520
00:30:19,840 --> 00:30:23,380
这为内核提供了在 trap 开始时执行的位置，

521
00:30:23,380 --> 00:30:25,060
当我们仍在使用用户页表时，

522
00:30:25,300 --> 00:30:30,370
其控制方式是通过 stvec 寄存器，

523
00:30:30,370 --> 00:30:32,940
这是另一个特权寄存器，

524
00:30:32,940 --> 00:30:35,520
仅管理者模式可读写，

525
00:30:36,000 --> 00:30:39,450
内核在进入用户空间之前设置 stvec ，

526
00:30:39,660 --> 00:30:42,780
指向内核希望 trap 放置的位置。

527
00:30:43,110 --> 00:30:44,310
所以你可以看到内核，

528
00:30:44,310 --> 00:30:49,710
之前已将 stvec 设置为 0x3ffffff000 地址，

529
00:30:49,710 --> 00:30:51,810
这是 trampoline 页面的开始。

530
00:30:52,360 --> 00:30:54,310
就是这个 stvec 寄存器，

531
00:30:54,520 --> 00:30:57,910
它的内容就是为什么在 ecall 之后，

532
00:30:58,060 --> 00:31:01,750
我们最终在这个特定的地方执行。

533
00:31:05,060 --> 00:31:06,410
最后我只想提醒你们，

534
00:31:06,410 --> 00:31:08,600
即使 trampoline 和 trap 帧页面

535
00:31:08,600 --> 00:31:11,690
被映射到用户页表用户地址空间，

536
00:31:11,930 --> 00:31:14,150
用户代码也不能写入它们，

537
00:31:14,580 --> 00:31:18,540
因为它们的 PTE 没有 u 标志，

538
00:31:18,540 --> 00:31:21,090
因此，它们受到保护，不受用户代码的影响。

539
00:31:21,880 --> 00:31:24,940
这就是为什么这个小技巧是安全的原因。

540
00:31:27,120 --> 00:31:30,030
我一直在告诉你，假设

541
00:31:30,060 --> 00:31:31,620
我们处于管理者模式，

542
00:31:31,650 --> 00:31:35,250
我不知道有什么方法可以直接找出机器处于什么模式，

543
00:31:35,700 --> 00:31:40,470
但我确实观察到程序计数器当前在页面中执行，

544
00:31:40,470 --> 00:31:44,580
没有设置 PTE_U 标志的 trampoline 页面，

545
00:31:44,880 --> 00:31:48,450
这只能在没有崩溃的情况下发生，如果我们处于管理者模式，

546
00:31:48,480 --> 00:31:53,490
所以我从没有崩溃以及程序计数器值推断，

547
00:31:53,490 --> 00:31:55,440
我们肯定处于管理者模式。

548
00:31:57,790 --> 00:32:00,970
我们是怎么走到这的，当然是通过 ecall ，

549
00:32:00,970 --> 00:32:03,340
ecall 实际上改变了三件事。

550
00:32:03,640 --> 00:32:07,060
首先， ecall 将模式从用户模式更改为管理者模式，

551
00:32:07,630 --> 00:32:12,850
第二， ecall 将程序计数器寄存器保存在 sepc 寄存器中，

552
00:32:12,880 --> 00:32:14,290
所以我们可以看到它的效果。

553
00:32:14,900 --> 00:32:17,180
我想程序计数器，

554
00:32:17,180 --> 00:32:19,340
它当然不再是用户程序计数器，

555
00:32:19,430 --> 00:32:21,140
即使当其他寄存器在，

556
00:32:21,580 --> 00:32:25,300
这个值是从 stvec 复制过来的。

557
00:32:26,010 --> 00:32:30,340
我们还可以打印，保存的，

558
00:32:30,760 --> 00:32:35,260
这是管理者模式例外程序的计数器，

559
00:32:35,290 --> 00:32:38,620
但这是 ecall 保存用户程序计数器，

560
00:32:38,920 --> 00:32:42,070
它具有熟悉的值 0xde6 ，

561
00:32:42,070 --> 00:32:46,390
该地址是 ecall 指令在用户空间中的地址。

562
00:32:47,130 --> 00:32:49,860
所以我们至少有一个寄存器被 ecall 存起来了。

563
00:32:50,510 --> 00:32:52,520
最后一件事， ecall 做的第三件事，

564
00:32:52,520 --> 00:32:57,020
它跳转到 stvec 指向的指令。

565
00:33:02,270 --> 00:33:04,190
好的，嗯。

566
00:33:04,940 --> 00:33:06,050
所以现在需要做的是，

567
00:33:06,050 --> 00:33:07,610
ecall 为我们做了点工作，

568
00:33:07,610 --> 00:33:09,620
但事实证明，我们还远没有准备好

569
00:33:09,620 --> 00:33:12,560
在内核中执行普通的 C 代码，

570
00:33:12,560 --> 00:33:17,660
现在要做的是我们需要保存 32 个用户寄存器内容，

571
00:33:17,990 --> 00:33:19,310
这样我们以后就可以恢复它们，

572
00:33:19,310 --> 00:33:21,320
当我们想恢复用户代码时，

573
00:33:21,920 --> 00:33:24,110
现在我们需要切换到内核页表，

574
00:33:24,110 --> 00:33:26,150
因为目前我们使用的是用户页表，

575
00:33:26,510 --> 00:33:29,030
我们需要创建栈或查找栈，

576
00:33:29,030 --> 00:33:32,360
并将栈指针寄存器设置为指向内核栈，

577
00:33:32,360 --> 00:33:34,850
让我们可以运行需要栈的 C 代码，

578
00:33:35,000 --> 00:33:36,320
然后，我们需要跳转到

579
00:33:36,320 --> 00:33:39,920
内核中 C 代码的某个合理位置。

580
00:33:40,700 --> 00:33:42,530
现在顺便说一句，

581
00:33:43,580 --> 00:33:46,580
ecall 没有为我们做任何这些事情。

582
00:33:47,070 --> 00:33:49,290
但是你可以让硬件

583
00:33:49,290 --> 00:33:51,540
定义 ecall 来做更多事情。

584
00:33:53,390 --> 00:33:56,330
对于我们来说，这些步骤要多得多，而不是把它们留给软件，

585
00:33:56,330 --> 00:34:00,620
正如我们将在软件过程中看到的，这并不是特别简单，

586
00:34:01,310 --> 00:34:04,640
所以你应该问问你自己，为什么 ecall 不能做更多的工作，

587
00:34:04,670 --> 00:34:06,800
从用户空间进入内核，

588
00:34:06,920 --> 00:34:10,020
为什么不保存它们的用户寄存器，

589
00:34:10,020 --> 00:34:14,460
或者切换页表指针指向内核页表，

590
00:34:14,460 --> 00:34:18,570
或者自动将栈指针设置为指向内核栈，

591
00:34:19,020 --> 00:34:21,630
或者直接跳转到内核 C 代码，

592
00:34:21,630 --> 00:34:25,260
而不必经历所有这些复杂的汇编代码。

593
00:34:26,990 --> 00:34:30,170
实际上已经有机器完成了所有这些事情，

594
00:34:30,530 --> 00:34:34,730
在系统调用期间的硬件中实现，

595
00:34:35,840 --> 00:34:37,100
RISC-V 不会做任何一件事，

596
00:34:37,100 --> 00:34:38,930
RISC-V 实际上采取的态度是，

597
00:34:38,930 --> 00:34:43,820
ecall 做了它可能做的最低要求，

598
00:34:43,820 --> 00:34:45,440
而把其他的一切都留给软件。

599
00:34:45,860 --> 00:34:47,000
这样做的原因是，

600
00:34:47,000 --> 00:34:52,280
因为 RISC-V 设计者希望允许软件具有最大的灵活性，

601
00:34:52,280 --> 00:34:53,960
操作系统程序员

602
00:34:53,960 --> 00:34:57,080
可以随心所欲地设计程序操作系统。

603
00:34:57,540 --> 00:35:02,550
所以虽然 xv6 没有使用这种自由的方式，

604
00:35:02,760 --> 00:35:04,560
但是其他操作系统是这样做的，

605
00:35:04,590 --> 00:35:09,840
我们可以举几个软件可以做的事情的例子，

606
00:35:10,170 --> 00:35:11,910
因为 ecall 太简单了，

607
00:35:12,300 --> 00:35:12,780
嗯。

608
00:35:14,540 --> 00:35:17,000
也许一些操作系统可以执行，

609
00:35:17,000 --> 00:35:21,320
在不切换页表的情况下执行 trap 或系统调用，

610
00:35:21,470 --> 00:35:25,220
搜索页面表，如果 ecall 强迫你这样做的话会很昂贵，

611
00:35:25,400 --> 00:35:29,060
现在这就排除了非常精简的可能性，

612
00:35:29,420 --> 00:35:32,870
一些不切换页表的系统调用的实现。

613
00:35:33,360 --> 00:35:38,840
有些操作系统既有用户虚拟地址，也有内核虚拟地址，

614
00:35:38,840 --> 00:35:39,950
放入单个页表中，

615
00:35:39,950 --> 00:35:42,350
并对用户和内核使用相同的页表，

616
00:35:42,350 --> 00:35:44,360
因此甚至不必切换页表，

617
00:35:44,360 --> 00:35:47,300
当在用户和内核之间转换时，

618
00:35:47,930 --> 00:35:50,030
对于它们，如果你调用交换页表，

619
00:35:50,030 --> 00:35:52,190
只会是一种浪费，让事情慢下来。

620
00:35:52,620 --> 00:35:56,640
可能在某些情况下，比如系统调用，

621
00:35:57,180 --> 00:35:59,370
某些寄存器不需要保存，

622
00:35:59,400 --> 00:36:00,900
以及哪些必须被保存，

623
00:36:00,900 --> 00:36:03,750
这取决于软件或语言和编译器，

624
00:36:03,750 --> 00:36:07,770
但是可以通过少于 32 个寄存器来节省大量时间，

625
00:36:07,800 --> 00:36:09,540
所以你不想让 ecall 强迫你，

626
00:36:10,080 --> 00:36:14,220
你不一定希望 ecall 强制保存所有寄存器。

627
00:36:14,720 --> 00:36:18,200
最后，一些简单的系统调用可能根本不需要栈，

628
00:36:18,200 --> 00:36:22,520
所以再说一次，操作系统非常关心性能，

629
00:36:22,520 --> 00:36:26,000
这很好， ecall 不会将任何特定的栈策略强加给你。

630
00:36:26,810 --> 00:36:33,060
再说一遍，有很多聪明的硬件或软件方案，

631
00:36:33,060 --> 00:36:37,350
用于非常精简的高性能系统调用和跟踪，

632
00:36:37,380 --> 00:36:40,380
因为这个东西的性能是非常重要的，

633
00:36:40,380 --> 00:36:41,640
人们对此非常关心。

634
00:36:43,080 --> 00:36:46,560
好的，那么回到 xv6 和 RISC-V 。

635
00:36:48,360 --> 00:36:50,550
我们首先要做的是保存一些寄存器，

636
00:36:50,550 --> 00:36:55,410
如果没有寄存器，我们几乎不能在 RISC-V 上做任何事情，

637
00:36:56,290 --> 00:36:57,580
在不能使用寄存器的情况下，

638
00:36:57,580 --> 00:37:00,280
那么，保存用户寄存器的选项有哪些呢？

639
00:37:01,130 --> 00:37:03,740
在其他机器上，我们也许可以，

640
00:37:03,740 --> 00:37:06,140
只需将 32 个寄存器的内容

641
00:37:06,140 --> 00:37:08,000
写入物理内存中方便的位置即可。

642
00:37:08,400 --> 00:37:11,040
我们不能在 RISC-V 上真正做到这一点，

643
00:37:11,040 --> 00:37:15,000
因为管理者代码不允许直接访问物理内存，

644
00:37:15,030 --> 00:37:16,800
我们只能使用页表中的内容，

645
00:37:16,800 --> 00:37:18,450
页表中的内容不多。

646
00:37:19,290 --> 00:37:24,060
xv6 做不到的另一种可能性是，

647
00:37:24,090 --> 00:37:27,840
只需将 satp 设置为内核页表，

648
00:37:27,990 --> 00:37:30,180
然后我们可以使用所有内核映射，

649
00:37:30,180 --> 00:37:33,570
或许可以用它们来帮助我们保存用户寄存器，

650
00:37:33,930 --> 00:37:36,750
而且这是合法的，管理者模式当然可以修改 satp 。

651
00:37:37,950 --> 00:37:41,700
然而，在 trap 处理程序中的这一点，即在开始处，

652
00:37:42,270 --> 00:37:44,640
我们甚至不知道内核页表的地址，

653
00:37:44,730 --> 00:37:49,410
以及执行修改 satp 的指令，

654
00:37:49,590 --> 00:37:53,400
要求从寄存器加载到 satp 的地址，

655
00:37:53,700 --> 00:37:58,200
所以我们甚至执行指令来改变页表，

656
00:37:58,200 --> 00:38:00,090
我们需要一些备用寄存器，

657
00:38:00,120 --> 00:38:03,410
以便将新的页表地址放入这些寄存器中，

658
00:38:03,410 --> 00:38:07,010
因此，我们可以执行 satp 修改指令。

659
00:38:08,920 --> 00:38:12,130
好的，我们需要保存用户寄存器，

660
00:38:12,400 --> 00:38:19,690
对于 xv6 如何在 RISC-V 上执行此操作，解决方案分为两个部分。

661
00:38:19,750 --> 00:38:22,720
一个是解决方案的一部分，

662
00:38:23,870 --> 00:38:27,890
xv6 到每个用户地址，每个用户页表映射，

663
00:38:27,890 --> 00:38:33,650
这个 trapframe 页和每个进程都有自己的 trapframe 页。

664
00:38:34,180 --> 00:38:38,130
而且 trapframe 页实际上包含

665
00:38:38,130 --> 00:38:39,990
一些有趣的不同类型的数据，

666
00:38:39,990 --> 00:38:44,700
但是现在包含的最重要的数据是 32 个插槽，

667
00:38:44,910 --> 00:38:49,290
内存中用于保存 32 个寄存器的空插槽。

668
00:38:49,410 --> 00:38:53,880
所以，现在 trap 处理代码中的好消息是我们有了一个映射，

669
00:38:53,880 --> 00:38:57,240
我们保证之前由内核设置了一个映射，

670
00:38:57,300 --> 00:39:00,680
在指向某个位置的用户页表中，

671
00:39:00,680 --> 00:39:05,420
为我们保存进程、用户寄存器做好了准备。

672
00:39:07,740 --> 00:39:14,160
可以肯定的是，它始终是 0x3ffffff000 虚拟地址。

673
00:39:14,770 --> 00:39:18,250
如果你想看看它们在那个 trapframe 里到底是什么，

674
00:39:18,250 --> 00:39:19,180
它是，嗯。

675
00:39:20,540 --> 00:39:30,070
xv6 放在那里的内容在 proc.h 中定义，

676
00:39:30,070 --> 00:39:31,690
trapframe 结构体就在这里，

677
00:39:31,690 --> 00:39:33,790
所以你可以看到，嗯。

678
00:39:34,710 --> 00:39:36,270
每个插槽里应该放些什么，

679
00:39:36,300 --> 00:39:38,760
这里有 32 个插槽，

680
00:39:38,760 --> 00:39:42,930
你需要 ra sp gp 等用来保存寄存器的位置，

681
00:39:42,930 --> 00:39:45,660
开头的这五个，

682
00:39:45,660 --> 00:39:47,730
很快就会派上用场，

683
00:39:47,730 --> 00:39:49,830
这些值是内核预先放置在

684
00:39:49,830 --> 00:39:53,070
trapframe 的插槽中。

685
00:39:53,800 --> 00:39:56,560
例如 trapframe 中的第一个插槽

686
00:39:56,770 --> 00:39:58,660
包含指向内核页表的指针，

687
00:39:58,870 --> 00:40:01,870
这将是我们很快要达到的值。

688
00:40:02,490 --> 00:40:04,980
trap 处理代码将加载到 satp 中。

689
00:40:06,270 --> 00:40:10,060
好的，那么，如何保存寄存器的部分答案是，

690
00:40:10,240 --> 00:40:15,610
内核方便地映射了 trapframe 和每个用户页表，

691
00:40:15,610 --> 00:40:21,190
另一个是，这个指令，之前提到过的 sscratch 寄存器，

692
00:40:21,610 --> 00:40:23,800
所以有专门的 sscratch 寄存器，

693
00:40:24,190 --> 00:40:27,070
由 RISC-V 提供，

694
00:40:27,070 --> 00:40:29,050
我们将把它用于。

695
00:40:30,150 --> 00:40:32,190
内核在进入用户空间之前，

696
00:40:32,190 --> 00:40:33,870
在那里放置一个指向 trapframe 的指针，

697
00:40:33,870 --> 00:40:39,450
基本上就是指向，放入 satp ，这个地址，

698
00:40:39,780 --> 00:40:42,060
为了方便 trap 处理代码，

699
00:40:42,120 --> 00:40:44,700
更重要的是，有一个 RISC-V 指令，

700
00:40:44,850 --> 00:40:47,310
它允许我们交换任何寄存器，

701
00:40:47,550 --> 00:40:49,980
以及将保存 sscratch 寄存器，

702
00:40:49,980 --> 00:40:56,070
将 sscatch 的值加载到我们指定的任何寄存器中。

703
00:40:56,620 --> 00:41:00,670
如你所见，如果我看一下 trampoline 代码。

704
00:41:01,860 --> 00:41:05,280
我们现在就在 trampoline 代码的开头。

705
00:41:06,120 --> 00:41:08,940
它做的第一件事是 csrrw 指令，

706
00:41:11,060 --> 00:41:11,870
说明，

707
00:41:11,870 --> 00:41:14,780
这是源码窗口，

708
00:41:14,780 --> 00:41:17,000
我们可以看到 gdb 在内核中看到的内容，

709
00:41:17,180 --> 00:41:21,380
我们刚刚执行了这个交换指令。

710
00:41:22,260 --> 00:41:24,000
让我们将 a0 和 sscratch 互换，

711
00:41:24,240 --> 00:41:27,990
为了看看它做了什么，让我们打印出 a0 ，

712
00:41:28,500 --> 00:41:33,840
a0 现在是这个 0x3fffffe000 值，它是一个指针。

713
00:41:34,680 --> 00:41:36,750
是 trapframe 的虚拟地址，

714
00:41:36,870 --> 00:41:38,970
它之前在 sscratch 里，我们刚把它交换了。

715
00:41:39,590 --> 00:41:41,930
然后我们可以把 sscratch 中的内容打印出来，

716
00:41:43,790 --> 00:41:46,730
它是 2 ，这是 a0 寄存器的旧值，

717
00:41:46,730 --> 00:41:50,510
当然， a0 保存 write 函数的第一个参数，

718
00:41:50,970 --> 00:41:54,360
是 shell 传递到的文件描述符，

719
00:41:54,390 --> 00:41:58,680
所以我们保存了 a0 ，并且有一个指向 trapframe 的指针。

720
00:41:59,630 --> 00:42:01,520
现在，

721
00:42:01,580 --> 00:42:04,040
我们可以很好地保存寄存器了，

722
00:42:04,040 --> 00:42:08,960
事实上，这就是 trampoline 代码中

723
00:42:08,960 --> 00:42:11,300
接下来的 30 多条指令，

724
00:42:11,420 --> 00:42:15,140
它是系统的个 sd 指令，

725
00:42:15,140 --> 00:42:18,560
保存 64 位存储指令，

726
00:42:18,560 --> 00:42:20,120
将每个寄存器

727
00:42:20,600 --> 00:42:25,760
保存到 trapframe 中 a0 的不同偏移量，

728
00:42:25,760 --> 00:42:29,300
现在在交换后包含指向 trapframe 的指针，

729
00:42:29,510 --> 00:42:33,530
这可以更改此页面的虚拟地址。

730
00:42:34,510 --> 00:42:39,550
我们只是保存每个寄存器到 trapframe 的不同偏移量，

731
00:42:42,130 --> 00:42:44,740
所有的保存有点无聊，所以我跳过它们。

732
00:42:45,410 --> 00:42:50,590
嗯。让我设定一个中断点，再往前走。

733
00:42:55,880 --> 00:42:56,780
教授，有个问题。

734
00:42:56,810 --> 00:42:57,410
好的。

735
00:42:58,200 --> 00:43:01,830
当我们用 a0 交换它时，

736
00:43:02,470 --> 00:43:05,140
trapframe 的地址怎么会出现在 sscratch 中呢？

737
00:43:05,910 --> 00:43:13,020
好的，在内核过渡到用户空间之前，

738
00:43:14,120 --> 00:43:21,890
将 sscratch 设置为等于 0x3fffffe000 ，这个虚拟地址是 trapframe 。

739
00:43:22,730 --> 00:43:25,400
因此，当我们在 shell 中执行用户空间时，

740
00:43:25,400 --> 00:43:28,610
sscratch 具有指向 trapframe 的指针，

741
00:43:29,140 --> 00:43:35,480
然后 shell 执行 ecall ，

742
00:43:36,140 --> 00:43:38,390
它跳到 trampoline 的起始处，

743
00:43:38,390 --> 00:43:40,100
trampoline 的第一个指令，

744
00:43:40,100 --> 00:43:44,390
csrrw 指令交换 a0 和 sscratch ，

745
00:43:44,900 --> 00:43:46,310
所以现在 sscratch 的旧值，

746
00:43:46,310 --> 00:43:48,590
也就是说， trapframe 现在在 a0 。

747
00:43:50,190 --> 00:43:51,180
这回答了你的问题吗。

748
00:43:53,230 --> 00:43:55,960
我想我在想在什么地方，

749
00:43:56,020 --> 00:44:00,010
在分配进程期间会发生这种情况吗，

750
00:44:00,040 --> 00:44:01,960
比如 sscratch 寄存器在哪里。

751
00:44:02,080 --> 00:44:06,100
这个 sscratch 寄存器，它本身就在 CPU 上。

752
00:44:06,620 --> 00:44:08,360
CPU 中的特殊寄存器。

753
00:44:08,970 --> 00:44:12,810
内核设置它，嗯，好的，

754
00:44:14,370 --> 00:44:18,420
有点牵扯进去，就是它设置的实际位置，

755
00:44:18,420 --> 00:44:20,370
我现在在右边给你们展示的是

756
00:44:20,820 --> 00:44:24,160
是内核（执行）的代码，

757
00:44:24,160 --> 00:44:29,710
内核在返回用户空间时执行的最后两条指令，

758
00:44:30,340 --> 00:44:34,030
发生的是它在内核之后做的最后一件事，

759
00:44:34,030 --> 00:44:37,000
恢复所有用户寄存器，

760
00:44:37,000 --> 00:44:39,580
并且准备好返回到用户空间，

761
00:44:39,760 --> 00:44:41,890
它实际上又进行了一次交换，

762
00:44:42,160 --> 00:44:44,770
内核设置 a0 为 trapframe ，

763
00:44:45,280 --> 00:44:49,090
sscratch 仍然保存的用户 a0 。

764
00:44:49,980 --> 00:44:53,520
所以内核会进行这种交换，结果是 sscratch 有一个指针，

765
00:44:53,520 --> 00:44:57,130
在 a0 中的 trapframe ，

766
00:44:57,920 --> 00:45:02,030
用户 a0 ，然后 sret 返回到用户空间，

767
00:45:02,180 --> 00:45:04,700
所以你可能会想， a0 怎么会有这样的值，

768
00:45:04,700 --> 00:45:08,040
有 trapframe 的地址，

769
00:45:08,520 --> 00:45:10,950
回答这个问题是，嗯，

770
00:45:13,130 --> 00:45:15,950
我们现在看 trap.c ，

771
00:45:17,120 --> 00:45:20,150
在这最后一个 C 函数中，

772
00:45:20,270 --> 00:45:23,640
它将转移到用户空间。

773
00:45:24,710 --> 00:45:28,550
这个 C 函数做的最后一件事，是在这里调用这个函数。

774
00:45:29,460 --> 00:45:33,240
无论这个 fn 是什么，它传递的参数

775
00:45:33,660 --> 00:45:38,020
都是 trapframe 和用户页表，

776
00:45:38,560 --> 00:45:41,680
所以在 C 代码中，当你调用一个函数时，

777
00:45:41,680 --> 00:45:43,660
第一个参数进入 a0 ，

778
00:45:44,170 --> 00:45:48,000
这就是 a0 在 trapframe 上保持指针的原因。

779
00:45:49,120 --> 00:45:51,910
这个函数，它的值在这里设置为，

780
00:45:52,650 --> 00:45:56,970
在接近末尾的 trampoline 页面中，我向你展示了代码。

781
00:45:59,690 --> 00:46:00,740
这个代码。

782
00:46:02,220 --> 00:46:04,980
这是不是你要的答案。

783
00:46:06,120 --> 00:46:07,020
谢谢。

784
00:46:07,620 --> 00:46:11,760
不好意思，我也搞不清楚我不确定，

785
00:46:11,880 --> 00:46:14,850
所以当你开始你的过程时，

786
00:46:15,290 --> 00:46:17,930
它运行，然后在某些时候，

787
00:46:17,930 --> 00:46:21,500
我猜这不等于什么，

788
00:46:21,500 --> 00:46:26,180
那么在什么时候调用这个返回函数的呢，

789
00:46:26,270 --> 00:46:29,150
因为它应该在 ecall 之前调用，

790
00:46:30,000 --> 00:46:34,140
但是它没有回来，你之前没有返回，

791
00:46:34,350 --> 00:46:37,830
我不知道我不明白你说的 usertrapret 。

792
00:46:39,000 --> 00:46:41,940
好的，这个问题的一个答案可能是，

793
00:46:41,970 --> 00:46:48,450
内核总是或机器在内核中引导，

794
00:46:49,850 --> 00:46:51,680
因此，当机器在内核中启动时，

795
00:46:51,950 --> 00:46:56,230
任何时候进入用户空间的唯一途径，

796
00:46:56,880 --> 00:47:00,720
你知道第一次或从系统调用返回时，

797
00:47:01,080 --> 00:47:04,200
实际上是执行这个 sret 指令，

798
00:47:05,440 --> 00:47:07,750
这条 sret 指令就是解决问题的方法，

799
00:47:07,750 --> 00:47:13,780
RISC-V 定义为从管理者模式转换到用户模式，

800
00:47:14,530 --> 00:47:18,830
因此在任何用户代码执行之前，

801
00:47:18,950 --> 00:47:22,030
内核执行我在这里展示的代码，

802
00:47:22,030 --> 00:47:24,280
在这两个编辑器缓冲区中，

803
00:47:24,820 --> 00:47:29,620
设置所有内容，比如 sscratch stvec 。

804
00:47:33,200 --> 00:47:34,820
好的，我明白了，谢谢。

805
00:47:35,270 --> 00:47:35,660
不用谢。

806
00:47:36,730 --> 00:47:38,020
我有个问题，

807
00:47:38,020 --> 00:47:41,020
我不确定我们是谈到这个了还是我错过了

808
00:47:41,020 --> 00:47:44,620
但是当我们在汇编代码中调用 ecall 指令时，

809
00:47:45,220 --> 00:47:47,680
是什么触发 trampoline 代码启动，

810
00:47:47,770 --> 00:47:52,570
比如 CPU 模式是从管理者模式切换过来的，

811
00:47:52,570 --> 00:47:55,090
对不起，是从用户模式切换过来的吗？管理者模式是另一回事。

812
00:47:55,480 --> 00:47:56,860
好的，嗯。

813
00:47:57,990 --> 00:48:00,570
所以我们正在执行的代码是 ecall ，

814
00:48:01,010 --> 00:48:03,020
shell 在用户空间中执行它，

815
00:48:03,290 --> 00:48:05,000
ecall 做了几件事，

816
00:48:05,120 --> 00:48:08,750
ecall 指令将模式设置为管理者模式，

817
00:48:09,400 --> 00:48:16,000
并且 ecall 指令将程序计数器保存在 sepc 中，

818
00:48:16,360 --> 00:48:20,440
并且 ecall 指令将程序计数器设置为等于

819
00:48:21,560 --> 00:48:23,930
名为 stvec 的控制寄存器，

820
00:48:24,260 --> 00:48:26,450
stvec 是内核在进入用户空间之前

821
00:48:26,450 --> 00:48:29,060
设置的众多东西之一。

822
00:48:31,750 --> 00:48:35,140
这里是 stvec ，内核设置它，

823
00:48:35,470 --> 00:48:37,600
到 trampoline 页面的开头，

824
00:48:37,630 --> 00:48:39,860
就是这里的地址。

825
00:48:40,680 --> 00:48:42,450
所以当 ecall 发生时，

826
00:48:42,450 --> 00:48:46,320
ecall 只是将 stvec 复制到程序计数器中并继续，

827
00:48:46,320 --> 00:48:51,510
但是现在程序计数器正在 trampoline 页面中执行这个地址。

828
00:48:54,500 --> 00:48:55,970
清楚了，谢谢。

829
00:48:56,990 --> 00:48:57,320
好的。

830
00:49:00,520 --> 00:49:02,050
我也有一个问题。

831
00:49:02,620 --> 00:49:09,460
为什么，所以一些寄存器保存在 trapframe 中，

832
00:49:09,520 --> 00:49:11,290
是否应该，

833
00:49:11,900 --> 00:49:17,030
也是用户程序可以访问的寄存器，

834
00:49:19,510 --> 00:49:29,000
为什么我们要把这个作为内存中的一个新的区域，

835
00:49:29,000 --> 00:49:31,790
而不是使用程序栈。

836
00:49:34,660 --> 00:49:37,660
好吧，嗯，伙计，这里可能有两个问题。

837
00:49:37,660 --> 00:49:42,420
一个是，也许我们为什么要保存这些寄存器。

838
00:49:43,700 --> 00:49:46,160
内核必须保存寄存器的原因是，

839
00:49:46,160 --> 00:49:48,680
内核即将运行 C 代码，

840
00:49:48,680 --> 00:49:51,700
它会覆盖那些寄存器，

841
00:49:52,060 --> 00:49:55,480
如果我们想要正确恢复用户代码，

842
00:49:55,480 --> 00:49:57,550
我们恢复它需要寄存器

843
00:49:57,550 --> 00:50:01,060
保持其从 ecall 开始原始值，

844
00:50:01,090 --> 00:50:02,050
让我们执行它，

845
00:50:02,260 --> 00:50:06,440
我们必须保存 trapframe 中的所有寄存器，

846
00:50:06,980 --> 00:50:10,040
这样以后，我们就可以恢复它们的值，

847
00:50:10,250 --> 00:50:12,930
在恢复用户代码之前。

848
00:50:14,280 --> 00:50:15,570
也许你问题的另一半是，

849
00:50:15,570 --> 00:50:17,760
为什么它们保存在 trap 帧中，

850
00:50:17,760 --> 00:50:20,040
而不是保存在用户栈中。

851
00:50:20,580 --> 00:50:21,570
这个问题的答案是，

852
00:50:21,570 --> 00:50:24,420
我们甚至不确定用户程序是否有栈。

853
00:50:24,820 --> 00:50:28,330
当然，有些编程语言没有栈，

854
00:50:28,810 --> 00:50:31,750
栈指针没有特别指向任何东西，

855
00:50:31,810 --> 00:50:33,130
可能是零值，

856
00:50:33,460 --> 00:50:35,770
还有一些编程语言，它们有一个栈，

857
00:50:35,770 --> 00:50:38,260
但它的格式是，

858
00:50:38,580 --> 00:50:42,120
一些奇怪的格式，内核无法理解，

859
00:50:42,120 --> 00:50:43,800
可能因为编程语言

860
00:50:43,800 --> 00:50:47,860
从堆中以小块的形式分配栈，

861
00:50:48,550 --> 00:50:50,830
编程语言运行库可以理解，

862
00:50:50,830 --> 00:50:53,650
如何将这些小的内存块用作栈，

863
00:50:53,650 --> 00:50:57,000
但是你知道，内核并不知道。

864
00:50:57,610 --> 00:51:00,580
因此，如果我们想要能够任意地运行，

865
00:51:00,580 --> 00:51:02,500
用多种不同语言编写的用户程序，

866
00:51:02,740 --> 00:51:07,930
内核不能对用户内存的部分做出任何假设，

867
00:51:07,930 --> 00:51:11,710
它被允许存在或有效，或者被允许读或写，

868
00:51:12,220 --> 00:51:13,330
因此内核必须

869
00:51:13,330 --> 00:51:16,510
在某种程度上独立保存它们，保存寄存器。

870
00:51:17,200 --> 00:51:21,010
这就是内核在自己的内存中保存内容的原因，

871
00:51:21,010 --> 00:51:23,730
保存在 trapframe ，而不是在用户内存中。

872
00:51:24,610 --> 00:51:25,510
好的，有道理。

873
00:51:29,820 --> 00:51:30,300
好的。

874
00:51:31,930 --> 00:51:32,950
还有别的问题吗。

875
00:51:40,120 --> 00:51:47,880
好的，我们还在阅读 trampoline 代码的开头。

876
00:51:48,120 --> 00:51:51,540
这些代码，不幸的是，我们将其称为

877
00:51:51,540 --> 00:51:56,160
uservec 和 trampoline 代码，

878
00:51:56,490 --> 00:51:57,990
我们刚刚开始执行它，

879
00:51:58,050 --> 00:52:02,010
我想我刚刚在这段代码中设置了一个断点，

880
00:52:02,970 --> 00:52:06,180
在保存了所有寄存器后，

881
00:52:06,210 --> 00:52:11,750
我想我给这个指令设置了一个断点，

882
00:52:12,200 --> 00:52:14,900
我们将继续执行，跳过所有这些保存

883
00:52:14,900 --> 00:52:16,940
所有用户寄存器的 trapframe 。

884
00:52:17,630 --> 00:52:20,960
好的，现在我们执行加载指令，

885
00:52:20,960 --> 00:52:25,430
加载指令正在加载到栈指针寄存器，

886
00:52:25,490 --> 00:52:28,670
作为值加载的是第八个插槽。

887
00:52:29,370 --> 00:52:32,310
由 a0 指向的内存中的块，

888
00:52:32,430 --> 00:52:35,280
我们记得 a0 指向，这个 trapframe ，

889
00:52:35,700 --> 00:52:39,900
到这个虚拟地址的倒数第二页。

890
00:52:40,600 --> 00:52:45,790
trap 页面的格式，但 trapframe 。

891
00:52:46,880 --> 00:52:47,930
这是 trap 页的首页，

892
00:52:47,930 --> 00:52:53,090
我们已经方便地将每个字段以字节为单位标记为其偏移量，

893
00:52:53,450 --> 00:52:55,550
所以这意味着他们在第八个装载，

894
00:52:56,280 --> 00:52:58,050
从 trapframe 的第八个字节开始，

895
00:52:58,050 --> 00:53:00,720
意味着我们正在加载内核栈指针，

896
00:53:00,720 --> 00:53:04,620
内核在进入用户空间之前设置的事情之一，

897
00:53:04,620 --> 00:53:06,840
它将 trapframe 中的这个插槽

898
00:53:07,050 --> 00:53:11,200
设置为等于此进程的内核栈，

899
00:53:11,620 --> 00:53:16,810
所以这里的这条指令是初始化栈指针，

900
00:53:16,810 --> 00:53:20,140
指向此进程的内核栈的顶部，

901
00:53:20,380 --> 00:53:23,900
是运行用户代码所需执行的操作的一部分。

902
00:53:25,930 --> 00:53:27,070
好的，那么剩下的，

903
00:53:27,070 --> 00:53:31,450
在到达 trampoline 代码末尾的几条指令。

904
00:53:32,220 --> 00:53:34,050
我们加载了栈指针，

905
00:53:34,650 --> 00:53:37,050
因此，也许我可以打印栈指针，并查看。

906
00:53:39,160 --> 00:53:40,000
是的，这是。

907
00:53:40,770 --> 00:53:50,520
嗯。好的，这就是内核，

908
00:53:50,520 --> 00:53:52,920
这个进程的内核栈位于高内存上，

909
00:53:52,920 --> 00:53:58,930
因为 xv6 特别对待内核设置，

910
00:53:58,930 --> 00:54:02,470
这样你就可以在每个内核栈下放置一个保护页。

911
00:54:03,810 --> 00:54:06,270
嗯，好的，这个加载到 tp ，

912
00:54:06,870 --> 00:54:11,190
因为 RISC-V 没有直接的方式，

913
00:54:11,190 --> 00:54:15,330
找出你在多个内核中的哪个内核上运行，

914
00:54:15,630 --> 00:54:22,830
xv6 实际上将称为 hart id 的内核编号保存在 tp 寄存器中。

915
00:54:22,920 --> 00:54:25,050
这在内核中的很多地方都有使用，

916
00:54:25,050 --> 00:54:28,080
举个例子，它是一种机制，

917
00:54:28,080 --> 00:54:34,070
让内核代码找出当前在该内核上运行的进程，

918
00:54:35,220 --> 00:54:39,540
好的，如果我们执行这个，

919
00:54:41,070 --> 00:54:43,530
tp ，运行在内核 0 上，这是有意义的，

920
00:54:43,530 --> 00:54:45,360
因为我已经将 QEMU 设置为

921
00:54:45,360 --> 00:54:49,950
仅将一个内核分配给 xv6 或实际上在内核 0 上运行。

922
00:54:51,830 --> 00:54:58,010
嗯，下一件事是加载地址，

923
00:54:59,620 --> 00:55:02,290
实际加载到 t0 。

924
00:55:06,180 --> 00:55:13,260
我想加载了指向我们要执行的第一个 C 函数的指针，

925
00:55:13,290 --> 00:55:14,370
就是 usertrap ，

926
00:55:14,370 --> 00:55:15,810
所以我们在几条指令中使用它，

927
00:55:15,810 --> 00:55:19,170
只需跳到 usertrap C 函数。

928
00:55:19,870 --> 00:55:22,630
加载到 t1 ，

929
00:55:23,260 --> 00:55:28,140
正在加载内核页表的地址，

930
00:55:28,590 --> 00:55:32,060
你可以打印，即将切换页表，

931
00:55:32,660 --> 00:55:35,180
这个东西，

932
00:55:35,180 --> 00:55:38,030
其实不是字面上的内核页表地址，

933
00:55:38,030 --> 00:55:41,570
这是你需要放入 satp 的东西，

934
00:55:42,100 --> 00:55:44,830
即具有内核页表的地址，

935
00:55:44,830 --> 00:55:47,140
但是对一些额外的标志位的情况下进行了移位。

936
00:55:47,760 --> 00:55:50,820
但只要执行 csrrw 指令，

937
00:55:50,820 --> 00:55:54,210
将交换用户页表和内核页表，

938
00:55:54,420 --> 00:55:58,260
现在让我查看当前页表确认一下。

939
00:55:58,660 --> 00:56:02,050
我们仍在使用这个非常小的用户页表执行，

940
00:56:02,350 --> 00:56:06,400
并单步运行以执行加载和 satp 。

941
00:56:08,770 --> 00:56:09,430
嗯。

942
00:56:11,140 --> 00:56:12,400
我们将再次查看内核页面，

943
00:56:12,400 --> 00:56:14,500
现在我们在完全不同的页表中，

944
00:56:14,500 --> 00:56:15,790
这是内核页表，

945
00:56:16,330 --> 00:56:18,700
然后你可以看到所有这些不同的内存区域，

946
00:56:18,700 --> 00:56:20,200
和设备控制寄存器，

947
00:56:20,200 --> 00:56:26,660
现在内核设置在自己的大内核页表中，

948
00:56:26,870 --> 00:56:29,090
所以我们成功地交换了页表。

949
00:56:29,740 --> 00:56:31,000
现在是内核页表，

950
00:56:31,450 --> 00:56:33,010
所以现在我们处于相当好的状态，

951
00:56:33,010 --> 00:56:34,090
因为我们有栈，

952
00:56:34,480 --> 00:56:36,310
我们有内核页表，

953
00:56:36,310 --> 00:56:37,570
我们可以读到内核数据

954
00:56:37,600 --> 00:56:42,580
已经准备好在内核中执行 C 代码了，

955
00:56:43,210 --> 00:56:48,200
但有一个问题是，为什么我们不是崩溃了，

956
00:56:48,560 --> 00:56:50,780
毕竟我们是在内存中的某个地方执行，

957
00:56:50,810 --> 00:56:53,270
并且程序计数器保存虚拟地址，

958
00:56:53,390 --> 00:56:55,940
如果我们交换页表，

959
00:56:56,170 --> 00:56:59,350
为什么不会造成一些随机的垃圾数据

960
00:56:59,350 --> 00:57:03,040
或者没有东西映射到新页表中，

961
00:57:03,070 --> 00:57:04,720
在我们执行之后。

962
00:57:05,470 --> 00:57:07,990
我们没有崩溃，也没有实际执行这些指令。

963
00:57:08,660 --> 00:57:10,490
有谁能猜到发生了什么事吗？

964
00:57:13,280 --> 00:57:15,680
我想是因为，哦，对不起，

965
00:57:17,040 --> 00:57:20,040
因为我们还在 trampoline 代码里，

966
00:57:20,040 --> 00:57:25,710
并且 trampoline 被映射到用户和内核的相同虚拟地址。

967
00:57:26,260 --> 00:57:27,460
绝对正确，

968
00:57:27,820 --> 00:57:29,950
我不知道你是否还记得，

969
00:57:29,950 --> 00:57:31,720
这里映射的是用户页面表中的内容，

970
00:57:31,840 --> 00:57:34,780
但是内核页表末尾的这个映射，

971
00:57:34,810 --> 00:57:37,690
在相同的地方是完全相同的映射，

972
00:57:38,080 --> 00:57:40,270
与 trampoline 映射一样，

973
00:57:40,840 --> 00:57:42,340
在用户页表的末尾，

974
00:57:42,370 --> 00:57:43,750
所有其他映射都不同，

975
00:57:44,480 --> 00:57:45,740
但是这个映射是一样的，

976
00:57:45,740 --> 00:57:48,050
这是保存正在执行的指令的映射，

977
00:57:48,050 --> 00:57:50,870
因为当我们交换页表时它没有改变，

978
00:57:51,800 --> 00:57:53,600
我们实际上继续执行，

979
00:57:53,600 --> 00:57:58,040
我们仍然在执行相同的指令序列，也没有崩溃。

980
00:57:59,140 --> 00:58:03,550
这就是 trampoline 页面的特殊之处，

981
00:58:03,580 --> 00:58:10,680
它在用户页表和内核页表中都有映射，

982
00:58:10,950 --> 00:58:13,110
这也是被称为 trampoline （蹦床） 页面的原因，

983
00:58:13,200 --> 00:58:15,120
因为你可以在上面弹跳，

984
00:58:15,810 --> 00:58:18,960
从用户空间到内核空间。

985
00:58:20,760 --> 00:58:23,820
下一条指令，这个 jr 将要弹跳，

986
00:58:24,030 --> 00:58:27,900
直接走出 trampoline 进入内核 C 代码。

987
00:58:28,430 --> 00:58:32,360
看看我们要去哪里， jr 就像跳到一个子程序，

988
00:58:32,450 --> 00:58:34,940
由寄存器 t0 指向的子程序，

989
00:58:35,930 --> 00:58:37,610
打印 t0 查看我们要去哪里。

990
00:58:39,420 --> 00:58:44,170
嗯，也许我们在那里打印指令。

991
00:58:46,520 --> 00:58:49,010
好的，这些就是我们要跳到那里的指令，

992
00:58:49,010 --> 00:58:52,100
在 usertrap 函数的开头，

993
00:58:53,560 --> 00:58:57,100
usertrap 只是一个 C 函数，

994
00:58:57,480 --> 00:58:58,830
定义在 trap.c 中。

995
00:59:01,040 --> 00:59:04,730
这是 usertrap ，我们将从汇编代码跳到使用 trap ，

996
00:59:04,730 --> 00:59:06,770
利用具有内核页表的栈，

997
00:59:07,220 --> 00:59:11,360
让我来执行指令。

998
00:59:12,040 --> 00:59:18,990
我要打开，打开 C 代码的显示，

999
00:59:18,990 --> 00:59:21,540
gdb 现在[] C 代码。

1000
00:59:23,820 --> 00:59:25,440
好的，现在我们处在一个更加理智的世界里，

1001
00:59:25,440 --> 00:59:26,880
我们只是在执行 C 代码，

1002
00:59:27,120 --> 00:59:28,950
应该更容易理解一点，

1003
00:59:29,220 --> 00:59:32,370
还有你知道的，仍然要花一些时间

1004
00:59:32,370 --> 00:59:35,550
读写各种有趣的控制寄存器，

1005
00:59:35,550 --> 00:59:39,490
但是，环境更好，

1006
00:59:39,490 --> 00:59:41,770
比在 trap 帧的神秘程度要低得多。

1007
00:59:43,420 --> 00:59:44,020
好的。

1008
00:59:48,140 --> 00:59:50,300
对于这一点，有什么问题吗。

1009
00:59:53,890 --> 00:59:55,510
嗯，我有个问题，

1010
00:59:55,510 --> 01:00:00,460
为什么我们没有在 gdb 看到 ecall 是做什么的，

1011
01:00:03,010 --> 01:00:04,630
也许我错过了，

1012
01:00:04,630 --> 01:00:09,280
但是我想我们已经直接跳到 trampoline 上了。

1013
01:00:11,930 --> 01:00:19,560
ecall 确实跳了， ecall 做的是，

1014
01:00:19,740 --> 01:00:23,340
只需切换，将模式位更改为管理员模式，

1015
01:00:23,820 --> 01:00:31,370
而 ecall 设置程序计数器寄存器等于，

1016
01:00:31,370 --> 01:00:35,390
无论内核发生什么，存储在 stvec 中的值。

1017
01:00:36,400 --> 01:00:40,000
我将存储刚刚打印的值 0x3ffffff000 ，

1018
01:00:40,000 --> 01:00:43,510
这是 trampoline 页面内核存储的开始。

1019
01:00:43,740 --> 01:00:46,680
在进入用户空间之前在 stvec 中的编号，

1020
01:00:47,130 --> 01:00:53,430
因此， ecall 所处的位置就是 stvec 的程序计数器。

1021
01:00:53,820 --> 01:00:55,860
这是 trampoline 页面的开始。

1022
01:00:58,560 --> 01:00:59,700
这回答了你的问题吗。

1023
01:01:02,240 --> 01:01:03,920
是的，我想是的。

1024
01:01:08,610 --> 01:01:14,370
好的，现在我们在 usertrap ， usertrap 就像一个 trampoline 页面，

1025
01:01:14,370 --> 01:01:20,630
就像 trampoline 页面上为一些不同种类的 trap ，

1026
01:01:20,630 --> 01:01:23,780
有系统调用异常，比如被零除，

1027
01:01:23,780 --> 01:01:25,940
或使用未映射的虚拟地址，

1028
01:01:26,150 --> 01:01:27,440
或有设备中断，

1029
01:01:27,440 --> 01:01:28,460
它们都来到这里

1030
01:01:28,730 --> 01:01:33,550
因此 usertrap 可以保存和恢复一些硬件状态，

1031
01:01:33,550 --> 01:01:38,470
但它也需要查看引起 trap 的状态，

1032
01:01:38,500 --> 01:01:41,410
弄清楚如何处理它。

1033
01:01:42,220 --> 01:01:45,700
所以当我们在用户陷阱中执行时，我们会看到这两种情况，

1034
01:01:45,880 --> 01:01:50,730
让我运行一下 usertrap ，

1035
01:01:50,730 --> 01:01:54,240
让我们看看，它在这里做的第一件事是，

1036
01:01:54,330 --> 01:01:57,210
它改变 stvec 寄存器，

1037
01:01:57,390 --> 01:02:03,550
xv6 处理 trap 的方式不同，

1038
01:02:03,550 --> 01:02:06,310
取决于它们是来自用户空间还是来自内核，

1039
01:02:06,640 --> 01:02:10,810
我们只讨论了如果用户空间发生 trap 会发生什么，

1040
01:02:10,960 --> 01:02:13,360
事件的顺序完全不同，

1041
01:02:13,750 --> 01:02:17,260
对于内核中发生的，来自内核的 trap ，

1042
01:02:17,260 --> 01:02:19,540
因为毕竟，比如说内核，

1043
01:02:20,120 --> 01:02:21,950
我已经在使用内核页表了，

1044
01:02:22,040 --> 01:02:24,830
当你在内核中发生 trap ，

1045
01:02:24,830 --> 01:02:26,180
你已经有了内核页表，

1046
01:02:26,180 --> 01:02:28,010
有很多事情是不一定要发生，

1047
01:02:28,430 --> 01:02:31,010
如果 trap 在内核中发生，

1048
01:02:31,520 --> 01:02:34,580
所以在深入了解内核代码之前，

1049
01:02:34,730 --> 01:02:37,370
我们将 stvec 更改为指向 kernelvec ，

1050
01:02:37,370 --> 01:02:39,620
它是内核 trap 处理程序，

1051
01:02:39,710 --> 01:02:41,240
而不是用户 trap 处理程序。

1052
01:02:43,250 --> 01:02:46,040
出于各种原因，我们需要，

1053
01:02:46,040 --> 01:02:47,900
我们需要找出我们正在运行的进程，

1054
01:02:48,080 --> 01:02:50,120
我们通过调用这个 myproc 函数来实现这一点，

1055
01:02:50,570 --> 01:02:52,190
并且 myproc 实际上查看一个列表，

1056
01:02:52,190 --> 01:02:55,940
由当前内核编号， hart id ，

1057
01:02:56,180 --> 01:02:58,490
你记得我们把它放入 tp 。

1058
01:02:59,300 --> 01:03:02,630
嗯，这就是 myproc 计算出当前正在运行的进程的过程。

1059
01:03:07,150 --> 01:03:08,830
我们需要保存，

1060
01:03:08,830 --> 01:03:14,890
用户程序计数器还在 sepc 中，

1061
01:03:14,950 --> 01:03:18,820
但是因为当我们在内核中时可能发生的一件事是，

1062
01:03:18,820 --> 01:03:21,340
我们可能会切换到另一个进程，

1063
01:03:21,400 --> 01:03:25,710
而另一个进程可能进入该进程用户空间，

1064
01:03:25,920 --> 01:03:29,170
而另一个进程可能会进行系统调用，

1065
01:03:29,170 --> 01:03:31,390
这使得 sepc 被重写，

1066
01:03:31,480 --> 01:03:37,690
我们必须保存 sepc 和与此过程相关的一些内存，

1067
01:03:37,720 --> 01:03:38,830
这样它就不会被覆盖，

1068
01:03:39,190 --> 01:03:43,060
我们用这个 trapframe 来保存 epc ，

1069
01:03:43,060 --> 01:03:44,350
还有很多其他的东西，

1070
01:03:44,770 --> 01:03:48,530
不管怎样，这就是当前代码行正在做的事情。

1071
01:03:49,520 --> 01:03:50,540
接下来的事情，

1072
01:03:50,540 --> 01:03:57,590
我们需要弄清楚我们为什么来这里，

1073
01:03:57,770 --> 01:04:00,770
scause RISC-V 的 scause 寄存器，

1074
01:04:00,950 --> 01:04:03,860
根据 trap 发生的原因，具有不同的数字。

1075
01:04:05,340 --> 01:04:09,090
某种异常或系统调用或设备中断，

1076
01:04:09,150 --> 01:04:13,170
8 表示我们因为系统调用而进入 trap 。

1077
01:04:15,430 --> 01:04:20,590
事实上， scause 8 ，它在这是 8 就是因为系统调用，

1078
01:04:21,100 --> 01:04:23,680
所以我们将执行这条语句。

1079
01:04:24,770 --> 01:04:28,670
第一件事是，如果某个其他进程杀死这个进程，

1080
01:04:28,670 --> 01:04:33,320
我们不想继续，但 shell 并非如此。

1081
01:04:33,940 --> 01:04:39,880
RISC-V 程序计数器保存在 spec ，

1082
01:04:39,970 --> 01:04:44,440
是引起 trap 的指令的地址，

1083
01:04:45,410 --> 01:04:50,210
但是当我们恢复时，我们想要恢复 ecall 之后的下一条指令，

1084
01:04:50,600 --> 01:04:55,130
因此，这个代码持久化需要返回的调用。

1085
01:04:56,080 --> 01:04:59,440
我们将保存的用户程序计数器加 4 ，

1086
01:04:59,440 --> 01:05:02,290
这样我们就可以在下一条指令中继续，

1087
01:05:02,290 --> 01:05:04,990
而不要重新执行 ecall 。

1088
01:05:08,140 --> 01:05:13,000
好的，接下来， xv6 启用中断，

1089
01:05:13,000 --> 01:05:15,520
在处理系统调用时，只有中断

1090
01:05:15,850 --> 01:05:20,500
可以更快地提供服务，某些系统调用需要很长时间。

1091
01:05:21,190 --> 01:05:25,630
中断始终由 RISC-V trap 硬件关闭，

1092
01:05:26,200 --> 01:05:29,380
因此我们必须在这里显式地重新打开它们。

1093
01:05:30,250 --> 01:05:34,120
接下来发生的是，我们调用这个 syscall 函数，

1094
01:05:34,120 --> 01:05:41,450
syscall 是在 syscall.c 中定义的。

1095
01:05:42,820 --> 01:05:45,700
这就是它所做的，它查找 syscall 编号，

1096
01:05:45,700 --> 01:05:50,850
在页面顶部的这个系统调用表中，

1097
01:05:51,750 --> 01:05:54,840
如果你还记得 shell write 函数，

1098
01:05:54,840 --> 01:06:00,000
将寄存器 a7 设置为系统调用号 16 进行写入，

1099
01:06:00,270 --> 01:06:04,380
所以 syscall 的作用是获取保存的 a7 ，

1100
01:06:04,560 --> 01:06:08,130
被 trampoline 代码保存在 trapframe 里，

1101
01:06:09,230 --> 01:06:14,470
并使用它来索引此指向函数的指针表，

1102
01:06:14,470 --> 01:06:15,970
这些函数实现了每个系统调用。

1103
01:06:17,420 --> 01:06:22,700
所以我们现在要[]这个数字， print num ，

1104
01:06:22,790 --> 01:06:25,640
这就是保存在 a7 中的，实际上是 16 ，

1105
01:06:25,760 --> 01:06:28,610
和 shell 原来放在那里的 16 一样。

1106
01:06:30,530 --> 01:06:31,250
嗯。

1107
01:06:32,610 --> 01:06:36,600
系统调用代码索引调用表，

1108
01:06:37,110 --> 01:06:38,670
我们可以找出哪些函数可以，

1109
01:06:39,600 --> 01:06:41,580
它是从系统调用表中取出的，

1110
01:06:42,380 --> 01:06:43,610
通过单步进入，

1111
01:06:43,700 --> 01:06:45,950
现在我们在 write ，或 SYS_write 。

1112
01:06:46,040 --> 01:06:50,690
所以，在 sysfile.c 文件中，

1113
01:06:52,560 --> 01:06:56,910
sys_write 是 write 系统调用的内核实现。

1114
01:06:57,810 --> 01:07:00,570
我就不详细说了，这里很复杂，

1115
01:07:00,570 --> 01:07:02,700
从外面和里面会发生什么，

1116
01:07:02,700 --> 01:07:04,530
而且这个系统调用的实现，

1117
01:07:04,710 --> 01:07:05,460
对于本课程，

1118
01:07:05,460 --> 01:07:07,770
我只对进出内核感兴趣，

1119
01:07:08,970 --> 01:07:16,100
所以我要跳过，

1120
01:07:25,860 --> 01:07:28,170
实际的系统调用实现。

1121
01:07:28,200 --> 01:07:30,060
有一件有趣的事情需要注意，

1122
01:07:30,060 --> 01:07:32,820
系统调用需要找到它们的参数，

1123
01:07:32,850 --> 01:07:34,890
你还记得 write 的参数，

1124
01:07:34,890 --> 01:07:37,350
一个 buff 指针还有其他两个，

1125
01:07:37,560 --> 01:07:40,140
系统调用代码获取它们的方式，

1126
01:07:40,140 --> 01:07:42,090
就是查看这些，

1127
01:07:43,430 --> 01:07:49,230
好的，查看这个 trapframe ，

1128
01:07:49,560 --> 01:07:51,870
就像我们可以在 trapframe 中查找 a7 ，

1129
01:07:51,990 --> 01:07:54,810
我们可以查找 a0 ，这是第一个参数，

1130
01:07:54,810 --> 01:07:56,580
我们查看 a1 ，这就是 buff 指针，

1131
01:07:56,580 --> 01:07:58,500
我们可以查看 a2 ，这是第二个参数，

1132
01:07:58,710 --> 01:08:03,490
也就是要写入的字节数。

1133
01:08:05,020 --> 01:08:06,940
好的，那么系统调用就完成它的工作，

1134
01:08:06,940 --> 01:08:09,760
然后，最终 sys_write 返回。

1135
01:08:13,190 --> 01:08:15,110
看看会发生什么，

1136
01:08:15,170 --> 01:08:17,120
这个分配的原因是，

1137
01:08:17,120 --> 01:08:21,680
我们将 trapframe 中的 a0 赋值的原因是，

1138
01:08:21,680 --> 01:08:24,980
这个系统调用都有返回值。

1139
01:08:26,030 --> 01:08:28,100
比如 write 返回，写入的字节数，

1140
01:08:28,310 --> 01:08:31,250
约定，并针对 RISC-V 上的 C 代码，

1141
01:08:31,250 --> 01:08:35,090
将返回值放入寄存器 a0 ，

1142
01:08:35,120 --> 01:08:36,440
通过你正在调用的任何函数，

1143
01:08:36,800 --> 01:08:38,780
因此，要模拟返回值，

1144
01:08:38,780 --> 01:08:42,170
我们只需将返回值放入 trapframe 中的 a0 中，

1145
01:08:42,560 --> 01:08:45,500
当我们回到用户空间时，我们会看到它，

1146
01:08:45,800 --> 01:08:50,900
trapframe 中的 a0 插槽恢复到真正的 a0 寄存器，

1147
01:08:50,900 --> 01:08:58,080
并且 shell 将 a0 的值看作从 write 返回的值，

1148
01:08:58,590 --> 01:09:05,510
并通过这个执行，print p->trapframe->a0 ，

1149
01:09:05,900 --> 01:09:09,740
我们也会看到值，也就是 write 的返回值，

1150
01:09:09,740 --> 01:09:13,250
表示它实际上是按照指令写了两个字节。

1151
01:09:13,980 --> 01:09:19,850
好的，现在我们又回到了 trap.c ，

1152
01:09:19,850 --> 01:09:24,750
usertrap 紧接在对 syscall 调用之后，

1153
01:09:24,750 --> 01:09:27,060
现在，使用这个 p ，

1154
01:09:27,060 --> 01:09:29,790
它检查进程是否已终止，

1155
01:09:29,790 --> 01:09:32,340
因为你不想恢复已经被终止的进程，

1156
01:09:32,340 --> 01:09:34,620
当然，我们的 shell 没有终止。

1157
01:09:35,790 --> 01:09:38,940
跳过这个然后，

1158
01:09:40,570 --> 01:09:44,020
usertrap 调用单独的函数 usertrapret ，

1159
01:09:44,050 --> 01:09:47,380
为了设置我之前谈到的所有东西，

1160
01:09:47,380 --> 01:09:50,140
每当我在进入用户空间之前，

1161
01:09:50,140 --> 01:09:51,880
内核做这个那个，

1162
01:09:52,240 --> 01:09:54,220
usertrapret ，

1163
01:09:54,700 --> 01:09:57,550
负责设置所有这些东西。

1164
01:10:00,490 --> 01:10:03,580
所以我们可以看到所有不同的东西，它做，

1165
01:10:11,440 --> 01:10:13,630
它关闭中断，

1166
01:10:13,720 --> 01:10:16,150
并且当它们在系统调用期间被打开，

1167
01:10:16,330 --> 01:10:17,140
现在被关闭，

1168
01:10:17,140 --> 01:10:19,810
因为我们即将修改 stvec

1169
01:10:20,020 --> 01:10:25,120
指向用户 trap 处理程序，

1170
01:10:25,510 --> 01:10:28,510
而当我们在内核时，指向内核 trap 处理程序，

1171
01:10:28,780 --> 01:10:29,800
所以我们关闭了中断，

1172
01:10:29,800 --> 01:10:33,430
因为一旦我们将 stvec 更改为指向用户 trap 处理程序，

1173
01:10:33,430 --> 01:10:34,870
我们仍然在内核中执行，

1174
01:10:34,990 --> 01:10:38,950
如果中断发生，则我们转到用户 trap 处理程序，

1175
01:10:39,010 --> 01:10:40,570
即使我们在内核中执行，

1176
01:10:40,660 --> 01:10:46,280
由于各种原因，会导致内核故障。

1177
01:10:46,520 --> 01:10:50,720
因此，我们关闭中断，并在这两个时间之间保持关闭。

1178
01:10:51,140 --> 01:10:54,170
从我们设置 stvec 的下一行开始，

1179
01:10:54,410 --> 01:10:59,120
在最后的 sret 指令中指向 trampoline ，

1180
01:10:59,120 --> 01:11:00,710
返回到用户空间。

1181
01:11:01,220 --> 01:11:03,860
trampoline 最后的 sret 指令，

1182
01:11:04,430 --> 01:11:06,620
重新打开中断。

1183
01:11:07,200 --> 01:11:11,190
所以当我们在用户代码中执行时，中断是开启的，

1184
01:11:11,190 --> 01:11:12,480
即使我们刚把它们关掉。

1185
01:11:13,350 --> 01:11:18,300
接下来的几行，填充我们之前看到的 trapframe 插槽，

1186
01:11:18,300 --> 01:11:23,260
包含对 trampoline 代码方便的各种值。

1187
01:11:23,290 --> 01:11:27,230
所以，这里的代码，存放一个指针

1188
01:11:27,230 --> 01:11:30,860
到 trapframe 中的内核页表，

1189
01:11:31,190 --> 01:11:35,750
它存放指向此进程、内核栈指针，

1190
01:11:36,940 --> 01:11:38,980
存放在 trapframe 里。

1191
01:11:40,890 --> 01:11:42,960
指向 usertrap 函数的指针，

1192
01:11:42,960 --> 01:11:46,050
这是 trampoline 代码最后跳转的地方。

1193
01:11:47,440 --> 01:11:50,020
存放当前的内核编号，

1194
01:11:50,530 --> 01:11:52,360
从 tp 寄存器读取，

1195
01:11:52,360 --> 01:11:56,710
使得 trampoline 代码可以恢复相同的值，

1196
01:11:57,010 --> 01:11:58,900
因为用户代码可能会干扰它。

1197
01:12:01,320 --> 01:12:02,130
有一个问题。

1198
01:12:02,280 --> 01:12:02,790
是。

1199
01:12:03,000 --> 01:12:06,000
我们为什么不把 sepc 保存到 trampoline ？

1200
01:12:08,370 --> 01:12:09,030
可以这样。

1201
01:12:11,420 --> 01:12:15,560
是的， sepc 可以保存在 trampoline ，

1202
01:12:15,560 --> 01:12:17,420
而不是将其与其他寄存器一起保存，

1203
01:12:17,810 --> 01:12:22,440
我们完全可以修改 xv6 来保存它，

1204
01:12:22,440 --> 01:12:23,760
它为你保存的。

1205
01:12:24,840 --> 01:12:28,040
可能记得是，只是碰巧保存了一下，

1206
01:12:28,040 --> 01:12:32,820
以及 usertrap 和 C 代码，而不是汇编代码，在 trampoline 代码中。

1207
01:12:34,950 --> 01:12:38,850
我不认为，我想不出一个好的理由来做这件事。

1208
01:12:40,240 --> 01:12:44,560
用户寄存器确实需要在在汇编代码中保存。

1209
01:12:45,300 --> 01:12:49,260
因为据我所知，任何 C 代码都是由编译器生成代码，

1210
01:12:49,260 --> 01:12:53,990
修改任何用户寄存器，

1211
01:12:53,990 --> 01:12:56,540
保存这些用户寄存器很重要，

1212
01:12:56,540 --> 01:12:58,340
在汇编代码中，在进入 C 代码之前。

1213
01:12:59,160 --> 01:13:01,950
但是我们可以早点或晚点保存 sepc 。

1214
01:13:04,470 --> 01:13:07,680
好的，所以当 usertrapret 准备 trap 时，

1215
01:13:07,680 --> 01:13:10,230
我们准备了 trapframe ，

1216
01:13:10,230 --> 01:13:13,260
其中包含下次需要的所有这些值。

1217
01:13:13,950 --> 01:13:17,460
有一个从用户空间到内核 trap 的转换。

1218
01:13:19,760 --> 01:13:24,740
我们在 sstatus 控制寄存器中设置了几项内容，

1219
01:13:24,920 --> 01:13:30,050
结果是 sstatus 中的这个 spp 位，

1220
01:13:30,080 --> 01:13:36,240
控制 sret 返回的模式，

1221
01:13:36,240 --> 01:13:40,810
通过清除它，我们是说下次执行 sret 时，

1222
01:13:40,900 --> 01:13:43,840
我们希望进入用户模式，而不是管理者模式，

1223
01:13:44,290 --> 01:13:50,120
这个 spie 位控制是否启用中断，

1224
01:13:51,290 --> 01:13:55,280
在我们执行 sret 之后，然后进入用户空间，

1225
01:13:55,280 --> 01:13:56,780
我们确实希望它们能够启用。

1226
01:13:56,780 --> 01:13:59,320
所以，我要设置 spie 位，

1227
01:13:59,650 --> 01:14:01,870
我将把这个新的修改状态

1228
01:14:01,870 --> 01:14:04,360
写入实际硬件状态寄存器。

1229
01:14:06,590 --> 01:14:08,540
它证明了 sret 是做什么的。

1230
01:14:10,450 --> 01:14:13,120
你知道我们要执行的 trampoline 代码末尾的 sret ，

1231
01:14:13,120 --> 01:14:14,800
sret 做的是，

1232
01:14:14,800 --> 01:14:19,120
将程序计数器设置为等于 sepc 寄存器，

1233
01:14:19,900 --> 01:14:22,510
所以我们现在要设置 sepc 寄存器，

1234
01:14:22,510 --> 01:14:26,170
以保存用户程序计数器。

1235
01:14:27,170 --> 01:14:30,680
如果你记得我们最近保存了 trapframe ，

1236
01:14:30,770 --> 01:14:31,880
这就是这里正在发生的事情。

1237
01:14:33,480 --> 01:14:40,960
你还记得 trapframe 包含指向内核页表的指针，

1238
01:14:40,960 --> 01:14:42,790
因为 trampoline 需要转换成这个，

1239
01:14:43,240 --> 01:14:46,210
我们需要准备出特殊的位模式，

1240
01:14:46,210 --> 01:14:49,150
你需要写入 satp 的操作已在此完成。

1241
01:14:50,290 --> 01:14:51,160
而且。

1242
01:14:52,740 --> 01:14:57,210
很抱歉，我们现在正在准备一个指向用户页表的指针。

1243
01:14:57,950 --> 01:15:00,890
我们需要在进入用户空间的过程中切换到它。

1244
01:15:02,350 --> 01:15:05,290
我们实际上要在汇编代码中进行切换，

1245
01:15:05,320 --> 01:15:07,720
因为它必须在 trampoline 上进行，

1246
01:15:07,960 --> 01:15:11,980
因为只有 trampoline 中的代码在用户空间和内核空间中都被映射，

1247
01:15:12,370 --> 01:15:15,240
所以我们只能真正交换页表，

1248
01:15:15,240 --> 01:15:16,530
我们在 trampoline 上执行，

1249
01:15:16,530 --> 01:15:18,450
但我们还没有在 trampoline 上执行，

1250
01:15:18,720 --> 01:15:20,610
我们仍然只是在一个普通的 C 函数中，

1251
01:15:20,610 --> 01:15:22,020
所以我们准备了这个指针，

1252
01:15:22,620 --> 01:15:27,240
我们将把它作为 a1 中的第二个参数传递给汇编代码。

1253
01:15:28,250 --> 01:15:34,010
这里的这一行所做的就是计算地址，

1254
01:15:34,010 --> 01:15:38,010
我们想要跳到 trampoline 代码末尾的地方，

1255
01:15:38,010 --> 01:15:43,460
这里有一个，我们要用 userret ，

1256
01:15:43,460 --> 01:15:45,530
这是将我们

1257
01:15:45,530 --> 01:15:47,120
带回用户空间的指令地址，

1258
01:15:47,450 --> 01:15:51,020
这个小公式计算出，

1259
01:15:52,500 --> 01:15:56,100
trampoline 中虚拟地址

1260
01:15:56,310 --> 01:15:58,440
对应于 userret 函数。

1261
01:16:02,980 --> 01:16:03,730
哎呀。

1262
01:16:05,930 --> 01:16:07,910
好的，我们来计算一下它的地址。

1263
01:16:09,640 --> 01:16:13,540
userret 函数，然后这个乱七八糟的，这个下一行，

1264
01:16:14,030 --> 01:16:18,740
调用使用 fn 变量作为函数指针，

1265
01:16:18,740 --> 01:16:23,420
并跳转到 a0 a1 中带有这两个参数的函数。

1266
01:16:24,240 --> 01:16:29,950
现在我们可以直接去 trampoline 代码了。

1267
01:16:33,790 --> 01:16:36,850
trampoline 代码，有。

1268
01:16:38,820 --> 01:16:40,350
好的，首先我们切换到用户页表，

1269
01:16:40,350 --> 01:16:41,490
我的意思是，实际上执行这个命令，

1270
01:16:41,490 --> 01:16:43,350
我们可以看到页表发生了变化，

1271
01:16:43,470 --> 01:16:47,490
作为验证，我们仍然使用大的内核页表。

1272
01:16:48,400 --> 01:16:49,180
嗯。

1273
01:16:50,750 --> 01:16:53,060
我将快速浏览 usertrapret ，

1274
01:16:53,090 --> 01:16:55,580
直到我们到了它跳到 trampoline 。

1275
01:16:57,240 --> 01:16:58,110
噢。

1276
01:16:59,200 --> 01:17:00,280
好的，我们在 trampoline 了。

1277
01:17:07,350 --> 01:17:09,030
这些指令即将

1278
01:17:09,030 --> 01:17:10,860
在这里开始执行 trampoline 代码，

1279
01:17:10,860 --> 01:17:16,160
我们现在可以，再次，打印页表，

1280
01:17:16,310 --> 01:17:18,950
仍然是内核页表。

1281
01:17:20,080 --> 01:17:22,000
不过，这里要发生的第一件事是，

1282
01:17:22,000 --> 01:17:24,760
trampoline 代码将会加载，

1283
01:17:25,070 --> 01:17:29,060
指向用户页表的指针到 satp 寄存器。

1284
01:17:30,000 --> 01:17:33,090
所以我们现在交换页表，我输入 info mem ，

1285
01:17:33,500 --> 01:17:35,510
我们现在有一个小得多的用户页表，

1286
01:17:35,510 --> 01:17:38,420
但幸运的是还有 trampoline 页面映射，

1287
01:17:38,420 --> 01:17:40,460
这样我们就不会在下一条指令上崩溃。

1288
01:17:41,790 --> 01:17:45,360
接下来会发生什么，是。

1289
01:17:47,090 --> 01:17:51,080
刚才我给大家看的，

1290
01:17:51,080 --> 01:17:54,560
这段代码的第二件最后一件事是

1291
01:17:54,560 --> 01:17:58,490
在跳入用户空间时交换 sscratch 和 a0 ，

1292
01:17:58,700 --> 01:18:00,470
所以我们需要设置 sscratch ，

1293
01:18:00,500 --> 01:18:02,450
它是保存的用户 a0 ，

1294
01:18:02,450 --> 01:18:03,950
所以当我们交换的时候，

1295
01:18:04,690 --> 01:18:07,510
a0 具有接收到的用户 a0 ，

1296
01:18:07,540 --> 01:18:10,640
最终 a0 指向 trapframe ，

1297
01:18:10,640 --> 01:18:14,150
因为 C 代码传递的是第一个参数，

1298
01:18:14,390 --> 01:18:18,410
112(a0) 是保存的 a0 的地址，

1299
01:18:18,800 --> 01:18:20,540
在要加载的 trapframe 中。

1300
01:18:21,170 --> 01:18:24,260
然后放入 t0 ，然后将其加载到 sscratch 。

1301
01:18:24,630 --> 01:18:30,100
此时，我们仍在运行内核内容和所有寄存器。

1302
01:18:31,230 --> 01:18:35,340
接下来的 32 条指令，是从 trapframe 加载出来，

1303
01:18:35,340 --> 01:18:40,260
a0 将所有保存的用户寄存器

1304
01:18:40,470 --> 01:18:46,570
从 trapframe 加载到实际寄存器中，

1305
01:18:46,570 --> 01:18:50,470
已经接近能够运行用户代码，

1306
01:18:50,500 --> 01:18:53,560
我将跳过所有这些加载。

1307
01:18:56,140 --> 01:19:00,440
在我们接近用户空间之前，有什么问题吗。

1308
01:19:02,440 --> 01:19:04,000
有一个简短的问题，

1309
01:19:04,000 --> 01:19:06,640
trapframe a0 中的值，

1310
01:19:06,640 --> 01:19:09,460
现在是我们进行的那个系统调用的返回值吗？

1311
01:19:11,330 --> 01:19:12,500
嗯。

1312
01:19:14,800 --> 01:19:19,090
是的，现在 a0 控制着 tramframe ，

1313
01:19:19,090 --> 01:19:21,970
但是在我们执行完之后，

1314
01:19:21,970 --> 01:19:28,440
好的，用户保存的当前位置，

1315
01:19:29,120 --> 01:19:33,020
是的，我在调用用户保存的 a0 ，

1316
01:19:33,020 --> 01:19:36,470
但实际上系统调用返回的内容会覆盖它，

1317
01:19:36,830 --> 01:19:40,940
使用我们希望 shell 在 a0 中看到的返回值，

1318
01:19:41,540 --> 01:19:44,990
所以我们用 2 覆盖了 a0 的当前位置。

1319
01:19:45,780 --> 01:19:48,750
因为返回值为 sscatch ，

1320
01:19:48,750 --> 01:19:50,160
希望它等于2，

1321
01:19:51,160 --> 01:19:53,380
它等于 2 。

1322
01:19:55,980 --> 01:19:56,970
这回答了你的问题吗？

1323
01:19:57,960 --> 01:19:58,740
是的，我想是的。

1324
01:19:58,890 --> 01:19:59,400
好的。

1325
01:19:59,460 --> 01:20:03,660
我会跳过所有这些加载恢复，

1326
01:20:04,180 --> 01:20:07,000
为了将用户值从 trapframe 保存到寄存器中，

1327
01:20:07,390 --> 01:20:10,090
我现在要打印寄存器。

1328
01:20:11,180 --> 01:20:12,890
嗯，实际上。

1329
01:20:16,620 --> 01:20:19,080
打印寄存器，我不知道这些看起来是不是很眼熟，

1330
01:20:19,080 --> 01:20:21,990
但是它们是同一组用户寄存器，

1331
01:20:21,990 --> 01:20:24,450
你在这个练习开始的时候就看到了，

1332
01:20:24,630 --> 01:20:29,960
例如 a1 或栈指针在存储器中保持这个值，

1333
01:20:29,960 --> 01:20:32,150
在内存中适合于用户栈的小值，

1334
01:20:32,860 --> 01:20:36,190
a1 是我们向 write 传递的缓冲区指针，

1335
01:20:36,520 --> 01:20:38,260
2 是字节数，

1336
01:20:38,530 --> 01:20:44,210
然而， a0 是个例外，不是接收到的用户值，

1337
01:20:44,210 --> 01:20:46,460
因为它仍然有指向 trapframe 的指针。

1338
01:20:49,100 --> 01:20:50,780
让我们看看我们即将执行的，

1339
01:20:52,830 --> 01:20:59,320
要执行的 csrrw a0 sscratch ，

1340
01:20:59,320 --> 01:21:03,400
就在 trampoline 的尽头，在返回用户空间之前，

1341
01:21:03,400 --> 01:21:05,440
将交换 a0 和 sscratch ，

1342
01:21:06,280 --> 01:21:08,460
scratch 包含。

1343
01:21:12,680 --> 01:21:14,240
嗯，是这个 sscratch 。

1344
01:21:16,640 --> 01:21:22,390
2 是关于该内核指针的返回值 a0 ，

1345
01:21:22,390 --> 01:21:27,580
它指向 trapframe ，

1346
01:21:27,580 --> 01:21:31,420
但是在执行 csrrw 指令交换它们之后，

1347
01:21:31,450 --> 01:21:36,460
我们能看到 a0 包含这个返回值 2 ，

1348
01:21:36,820 --> 01:21:43,140
而 sscratch 保存指向 trapframe 的指针，

1349
01:21:43,140 --> 01:21:46,110
这是内存中倒数第二页，

1350
01:21:46,500 --> 01:21:49,680
该值将保留在 sscratch ，

1351
01:21:49,680 --> 01:21:52,050
直到用户程序执行另一个 trap ，

1352
01:21:52,050 --> 01:21:55,510
那时 trap 控制代码，我们之前讨论的，

1353
01:21:55,510 --> 01:21:58,270
我们能在 trapframe 使用 sscratch 。

1354
01:21:59,080 --> 01:22:02,300
好的，我们还在内核中，

1355
01:22:02,690 --> 01:22:05,060
这是我们在内核中的最后一条指令，

1356
01:22:05,930 --> 01:22:08,240
当我执行这个 sret 时，

1357
01:22:09,280 --> 01:22:12,340
它将切换到用户模式，

1358
01:22:12,550 --> 01:22:14,950
在我这样做之前，让我们先来看看。

1359
01:22:17,300 --> 01:22:21,260
它将切换用户模式，将 sepc 复制到 pc ，

1360
01:22:21,260 --> 01:22:30,330
因为我们还在用 trampoline 上的 pc 执行任务，

1361
01:22:30,510 --> 01:22:36,000
因此， sret 将切换用户模式，复制 sepc 到 pc 。

1362
01:22:36,350 --> 01:22:41,810
然后继续执行，所以我将运行 sret 。

1363
01:22:42,480 --> 01:22:46,860
砰，我们现在又回到原点了。

1364
01:22:48,640 --> 01:22:52,060
我可以寻址 0xdea ，它是一个低地址，

1365
01:22:52,210 --> 01:22:55,240
很可能是用户内存，它是。

1366
01:22:55,980 --> 01:23:00,960
回顾 sh.asm 和地址 0xdea 。

1367
01:23:03,970 --> 01:23:08,290
实际上是 write 结束时返回函数的地址。

1368
01:23:09,870 --> 01:23:15,550
a0 是这个它们应该返回的返回值。

1369
01:23:16,730 --> 01:23:18,110
所以我们回到了用户空间，

1370
01:23:18,110 --> 01:23:21,710
我们可以执行从 write 系统返回到 shell 的操作，

1371
01:23:22,350 --> 01:23:24,360
从进行系统调用的 write 库函数。

1372
01:23:25,020 --> 01:23:26,310
好的，有什么问题吗？

1373
01:23:28,880 --> 01:23:30,530
嗯，不好意思，你能再重复一遍吗，

1374
01:23:30,530 --> 01:23:34,400
在 sret 期间中断发生了什么。

1375
01:23:37,750 --> 01:23:39,400
中断之后发生了什么。

1376
01:23:39,520 --> 01:23:42,010
你说我们把它们关了，

1377
01:23:42,130 --> 01:23:44,890
然后又有别的东西把它们打开了。

1378
01:23:45,840 --> 01:23:50,020
sret ， sret 重新启用中断，

1379
01:23:50,410 --> 01:23:53,080
所以 sret ，最后一条指令，

1380
01:23:53,080 --> 01:23:55,270
我们在内核中以管理者模式执行的，

1381
01:23:56,260 --> 01:23:58,000
刚才我忘了说，

1382
01:23:58,000 --> 01:24:01,600
但也将程序计数器设置为等于 sepc ，

1383
01:24:01,600 --> 01:24:06,950
切换到用户模式 sret 将重新启用中断。

1384
01:24:07,840 --> 01:24:10,330
这意味着你知道，

1385
01:24:10,330 --> 01:24:11,980
用户程序可能会运行很长时间，

1386
01:24:11,980 --> 01:24:14,320
能够接受磁盘中断或其他任何情况很好，

1387
01:24:15,040 --> 01:24:17,140
当用户程序正在运行时。

1388
01:24:18,320 --> 01:24:19,460
我明白了，谢谢你。

1389
01:24:20,770 --> 01:24:21,730
还有其他问题吗？

1390
01:24:25,860 --> 01:24:26,010
好的。

1391
01:24:28,100 --> 01:24:31,520
好的，总结一下系统调用，

1392
01:24:31,550 --> 01:24:32,990
看起来有点像函数调用，

1393
01:24:32,990 --> 01:24:36,290
它们在某种程度上被认为很像函数调用，

1394
01:24:36,290 --> 01:24:42,020
但是用户内核转换比函数调用要复杂得多，

1395
01:24:42,020 --> 01:24:46,460
由于隔离的要求有很大的复杂性，

1396
01:24:46,460 --> 01:24:48,860
内核就不能信任用户空间中的任何东西。

1397
01:24:49,330 --> 01:24:53,860
并且还希望具有简单且非常快速的硬件机制，

1398
01:24:53,860 --> 01:24:56,950
xv6 不太关心性能，

1399
01:24:56,950 --> 01:25:00,670
但是在一般的操作系统设计者和 CPU 设计者中，

1400
01:25:00,850 --> 01:25:02,320
他们非常感兴趣的是

1401
01:25:02,320 --> 01:25:06,310
你能以多快的速度，以及 trap 的效率。

1402
01:25:08,040 --> 01:25:10,980
xv6 以一种特殊的方式做所有这些事情，

1403
01:25:10,980 --> 01:25:12,660
当然还有其他方法可以做到这一点，

1404
01:25:13,110 --> 01:25:16,530
几个问题如果你设计问题替代方案，

1405
01:25:16,530 --> 01:25:17,370
你可以想一想，

1406
01:25:17,820 --> 01:25:24,180
一个就是你能不能想办法把硬件方面或者软件方面，

1407
01:25:24,180 --> 01:25:28,650
你重新设计 xv6 ，重新设计 RISC-V 以使整个序列更简单，

1408
01:25:29,490 --> 01:25:32,850
或者你能想出让整个过程更快的方法吗？

1409
01:25:33,640 --> 01:25:36,190
另一组问题让你保持头脑清醒，

1410
01:25:36,730 --> 01:25:41,260
恶意程序是否可以

1411
01:25:41,260 --> 01:25:46,310
滥用这些机制中的任何一个来破坏隔离。

1412
01:25:48,090 --> 01:25:50,790
好了，这就是我对这堂课要说的全部内容。

1413
01:25:50,820 --> 01:25:52,530
我很乐意回答大家的问题。

1414
01:25:54,650 --> 01:25:56,420
嗯，对不起，我还有另一个问题。

1415
01:25:56,570 --> 01:25:56,990
请问。

1416
01:25:56,990 --> 01:26:02,250
我看到有一个 uie 寄存器，

1417
01:26:02,490 --> 01:26:04,890
是的，我想它在 sstatus ，

1418
01:26:05,280 --> 01:26:06,480
但是我们不使用它，

1419
01:26:07,320 --> 01:26:11,430
我们只使用 sie ，并在用户空间中将其设置为 false ，

1420
01:26:11,430 --> 01:26:14,630
为什么我们不使用 uie 。

1421
01:26:14,630 --> 01:26:18,610
uie ，天啊，答案是我不知道。

1422
01:26:21,640 --> 01:26:22,360
嗯。

1423
01:26:24,720 --> 01:26:29,460
我们 s p ，我们说的是 spie 。

1424
01:26:30,550 --> 01:26:32,470
我们实际上可能最终会设置。

1425
01:26:33,810 --> 01:26:37,410
嗯，我对 uie 一无所知，我只能猜一下，

1426
01:26:37,590 --> 01:26:40,890
让我想想，我要猜猜这里到底发生了什么。

1427
01:26:42,510 --> 01:26:44,220
在此代码中，我们所在的位置。

1428
01:26:45,800 --> 01:26:51,500
嗯，好的，那么我们现在在 usertrapret ，

1429
01:26:51,500 --> 01:26:55,640
返回或设置 spie sstatus ，

1430
01:26:56,150 --> 01:27:02,360
我相信 sret 指令会复制这个 spie ，

1431
01:27:02,810 --> 01:27:05,450
这是这个以前的名字，

1432
01:27:05,450 --> 01:27:07,910
管理者以前终端开启（spie），

1433
01:27:08,210 --> 01:27:12,340
我怀疑 sret 将该位复制到，

1434
01:27:15,120 --> 01:27:17,370
复制到任何控制中断和用户模式，

1435
01:27:17,370 --> 01:27:21,070
这可能是 uie ， sstatus 的一个位，

1436
01:27:21,970 --> 01:27:23,080
这就是我的猜想。

1437
01:27:24,420 --> 01:27:25,590
我明白了，谢谢你。

