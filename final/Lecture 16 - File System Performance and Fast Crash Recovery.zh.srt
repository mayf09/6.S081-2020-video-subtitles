1
00:00:02,020 --> 00:00:04,150
好的，是时候开始了。

2
00:00:05,740 --> 00:00:09,370
好的，就想 Frans 所说的，

3
00:00:09,370 --> 00:00:11,650
随时可以打断进行提问，

4
00:00:11,650 --> 00:00:14,740
并且可以让你的摄像头开着，

5
00:00:14,740 --> 00:00:17,450
这样我们就可以看到彼此。

6
00:00:18,320 --> 00:00:20,870
这将是另一节关于日志的课，

7
00:00:21,230 --> 00:00:26,540
这一次对 Linux 中现在的日志系统的研究，

8
00:00:26,810 --> 00:00:28,580
ext3 文件系统，

9
00:00:28,580 --> 00:00:30,260
它应用非常广泛，

10
00:00:30,620 --> 00:00:35,480
而且我们尝试涉足一些现实世界的设计问题，

11
00:00:35,510 --> 00:00:39,870
高性能文件系统必须处理的，

12
00:00:39,870 --> 00:00:41,940
当它将日志添加到文件系统时。

13
00:00:42,550 --> 00:00:44,740
我要花几分钟，

14
00:00:44,920 --> 00:00:47,890
回顾一下为什么我们谈论日志，

15
00:00:48,820 --> 00:00:53,500
我们觉得日志很重要的原因是，

16
00:00:53,500 --> 00:00:56,800
它是一个非常成功和重要的想法，

17
00:00:57,550 --> 00:01:01,210
日志是一种神奇的方式，

18
00:01:01,210 --> 00:01:07,270
将崩溃恢复添加到几乎任何现有存储系统。

19
00:01:07,940 --> 00:01:11,070
在很多方面是不相关的，

20
00:01:11,070 --> 00:01:12,990
无论你想存储的是什么。

21
00:01:13,410 --> 00:01:18,660
所以，你可以看到日志应用于大量不同的存储情况，

22
00:01:19,200 --> 00:01:21,000
当然有数据库和文件系统，

23
00:01:21,000 --> 00:01:23,190
而且还有许多非常专业的系统，

24
00:01:23,670 --> 00:01:26,190
它们需要存储东西并在崩溃后恢复。

25
00:01:26,460 --> 00:01:30,780
你还可以看到在分布式系统中大量使用日志，

26
00:01:30,780 --> 00:01:34,620
作为从故障中恢复的一种方式，

27
00:01:34,860 --> 00:01:37,980
因为与其他东西相比，日志是一种结构化的方式，

28
00:01:37,980 --> 00:01:40,770
这是崩溃前发生的所有事情，

29
00:01:40,770 --> 00:01:42,360
如果我们能理解它们，

30
00:01:42,360 --> 00:01:45,120
也许我们就能更容易地从崩溃中恢复。

31
00:01:46,700 --> 00:01:50,180
再加上有大量有趣的东西可以细想，

32
00:01:50,210 --> 00:01:56,820
当你尝试构建高性能日志系统时。

33
00:01:57,560 --> 00:01:59,060
就像我几分钟前提到的，

34
00:01:59,060 --> 00:02:03,590
作为术语，当我们讨论日志时，

35
00:02:03,680 --> 00:02:06,770
它谈论的事情和今天的读物完全一样，

36
00:02:06,860 --> 00:02:09,680
读物说的是 journal 这个词，

37
00:02:09,710 --> 00:02:11,150
它们是同义词。

38
00:02:12,200 --> 00:02:14,630
此外，今天的读物谈到了

39
00:02:14,660 --> 00:02:16,700
在 ext2 中增加 journal ，

40
00:02:16,970 --> 00:02:20,720
结果文件系统的现代名称是 ext3 ，

41
00:02:22,810 --> 00:02:24,820
我就是这么称呼它的。

42
00:02:25,840 --> 00:02:29,570
好的，我想花点时间，

43
00:02:29,600 --> 00:02:34,700
我要谈论 ext3 的方式是

44
00:02:35,630 --> 00:02:38,150
将它与 xv6 进行某种程度的对比，

45
00:02:38,150 --> 00:02:42,830
并解释 ext3 修复一些性能问题的方法，

46
00:02:43,010 --> 00:02:46,640
xv6 日志具有的问题，

47
00:02:46,640 --> 00:02:49,730
并在过程中改变一些语义，

48
00:02:52,220 --> 00:02:53,720
在崩溃中会发生什么。

49
00:02:55,380 --> 00:03:01,410
好的，这是 xv6 的日志回顾，

50
00:03:01,560 --> 00:03:02,580
应该记住，

51
00:03:09,500 --> 00:03:13,640
这个 xv6 的文件系统磁盘，

52
00:03:13,820 --> 00:03:16,850
你可以认为它有两个部分，

53
00:03:16,850 --> 00:03:19,340
它上面有一个文件系统树，

54
00:03:19,340 --> 00:03:20,960
有一个根目录，

55
00:03:20,960 --> 00:03:25,070
在根目录下，可能还有其他目录，

56
00:03:25,100 --> 00:03:28,760
可能是目录一和目录二，

57
00:03:28,760 --> 00:03:31,610
我们可以认为文件系统只是一个数据结构，

58
00:03:31,610 --> 00:03:33,380
是一个树形结构的数据结构，

59
00:03:33,650 --> 00:03:38,000
可能它有文件，位于目录中，

60
00:03:38,120 --> 00:03:42,950
每个文件中都有一些块编号，

61
00:03:43,100 --> 00:03:46,130
还有一些其他的数据，不是树形结构，

62
00:03:46,130 --> 00:03:50,450
比如，这里有一个位图，表示每个块，

63
00:03:50,480 --> 00:03:53,750
它是空闲的还是分配的。

64
00:03:54,540 --> 00:04:00,420
索引结点，目录内容和位图块

65
00:04:00,420 --> 00:04:02,070
被称为元数据，

66
00:04:02,760 --> 00:04:07,740
对比保存文件内容的块，我们称为文件内容块。

67
00:04:08,640 --> 00:04:10,920
好的，那么除了文件系统，

68
00:04:11,370 --> 00:04:15,240
xv6 日志，在磁盘的开头附近，

69
00:04:15,240 --> 00:04:17,640
xv6 日志相对简单，

70
00:04:17,640 --> 00:04:19,470
它有 header 块，

71
00:04:20,990 --> 00:04:27,830
然后是一些区块，包含块的更新版本。

72
00:04:27,830 --> 00:04:31,310
来自文件系统数据块和元数据块。

73
00:04:33,510 --> 00:04:36,030
在这个开始的 header 块中，

74
00:04:36,060 --> 00:04:38,940
有一个块编号，

75
00:04:39,060 --> 00:04:45,190
那些日志中的块应该写入的位置，

76
00:04:45,190 --> 00:04:47,530
比如，第一个应该去块 17 ，

77
00:04:47,530 --> 00:04:50,260
然后是 29 ，无论是什么。

78
00:04:51,550 --> 00:04:52,750
然后在计算机中，

79
00:04:54,310 --> 00:04:58,300
我们有一些用户进程可能调用 write create ，

80
00:04:58,300 --> 00:05:00,430
某些其他修改文件系统的系统调用。

81
00:05:03,110 --> 00:05:06,890
而且，计算机中有一个块缓存，

82
00:05:06,890 --> 00:05:09,530
最初 write 只会进入块缓存，

83
00:05:13,470 --> 00:05:16,560
它只是磁盘上块的拷贝，

84
00:05:17,410 --> 00:05:21,880
所以最初 write 更新文件块或索引节点

85
00:05:21,880 --> 00:05:24,190
或其他写入到那里的任何东西，

86
00:05:24,190 --> 00:05:26,320
然后在操作结束时，

87
00:05:27,490 --> 00:05:28,900
这些数据块被复制到日志中，

88
00:05:28,900 --> 00:05:30,550
当我们复制完所有数据块时，

89
00:05:30,550 --> 00:05:33,540
然后我们将块编号写入 header 块，

90
00:05:33,540 --> 00:05:37,980
表示这个事务更新已完成。

91
00:05:39,060 --> 00:05:41,430
在文件系统的代码中，你会看到，

92
00:05:43,240 --> 00:05:47,470
每个修改文件系统的系统调用，

93
00:05:48,070 --> 00:05:49,420
某处有一个 begin_op ，

94
00:05:49,420 --> 00:05:54,610
表示将要开始对文件系统的一组更新，

95
00:05:54,790 --> 00:05:57,670
在我做完之前，不要做它们中的任何一个，

96
00:05:57,790 --> 00:05:58,480
所以我们有，

97
00:05:58,480 --> 00:06:01,060
然后有些读取和写入块，

98
00:06:01,060 --> 00:06:03,830
然后是 end_op ，

99
00:06:04,690 --> 00:06:06,760
它告诉文件系统日志系统

100
00:06:06,970 --> 00:06:09,310
完全完成我要执行的所有写入。

101
00:06:09,550 --> 00:06:12,940
所以，在 begin_op 和 end_op 之间，

102
00:06:12,940 --> 00:06:15,160
写入仅进入缓存，

103
00:06:15,400 --> 00:06:18,970
当系统调用进行 end_op 调用时，

104
00:06:19,180 --> 00:06:24,220
然后，文件系统将修改后的块从缓存复制到日志中。

105
00:06:24,670 --> 00:06:28,780
在将所有这些修改过的数据块写入日志后，

106
00:06:28,810 --> 00:06:32,290
只有这样，文件系统才会将块编号写入

107
00:06:32,590 --> 00:06:36,040
单个磁盘中，写入到 header 块。

108
00:06:36,760 --> 00:06:38,740
这称为提交点，

109
00:06:38,770 --> 00:06:42,880
这是文件系统将这些块编号写入 header 块之前的点，

110
00:06:43,120 --> 00:06:44,530
如果发生了崩溃，

111
00:06:44,650 --> 00:06:47,680
这些写入都不会应用，

112
00:06:48,130 --> 00:06:50,110
在崩溃和重新启动之后。

113
00:06:50,750 --> 00:06:54,050
在文件系统写入 header 块的块编号之后，

114
00:06:54,470 --> 00:06:56,360
在这个写入完成后，

115
00:06:56,390 --> 00:06:57,830
那么可以保证，

116
00:06:57,860 --> 00:06:59,390
即使在这一点上发生崩溃，

117
00:06:59,630 --> 00:07:01,820
恢复软件也会查看日志，

118
00:07:01,850 --> 00:07:04,520
看到在 header 块中有块编号，

119
00:07:04,580 --> 00:07:08,150
将这些在 header 块中提到的块写入

120
00:07:08,180 --> 00:07:11,990
它们在文件系统的原位置。

121
00:07:12,960 --> 00:07:15,450
所以这里是一种技术，

122
00:07:15,600 --> 00:07:17,430
允许所有的写入，

123
00:07:17,430 --> 00:07:20,910
在 begin_op 和 end_op 之间的系统调用中发生

124
00:07:21,780 --> 00:07:24,540
是原子的，关于崩溃，

125
00:07:25,160 --> 00:07:27,440
要么所有的事情都发生，

126
00:07:28,380 --> 00:07:31,860
因为文件系统在崩溃之前只写 header 块，

127
00:07:32,100 --> 00:07:33,360
或者它们都没有发生，

128
00:07:33,980 --> 00:07:37,670
因为崩溃发生在文件系统写入 header 块之前。

129
00:07:39,620 --> 00:07:41,720
所以重要的是，在崩溃和重启之后，

130
00:07:41,720 --> 00:07:44,330
有一些恢复软件可以运行来读取日志，

131
00:07:44,420 --> 00:07:45,680
查看 header 块，

132
00:07:45,710 --> 00:07:49,490
并确定块编号是不是在 header 块中，

133
00:07:49,580 --> 00:07:50,510
如果是，

134
00:07:50,990 --> 00:07:55,400
写操作可能会将所有这些数据块重写到它们的原位置，

135
00:07:55,580 --> 00:07:58,130
如果 header 块中没有任何块编号，

136
00:07:58,130 --> 00:07:59,570
则恢复软件不会执行任何操作。

137
00:08:02,260 --> 00:08:03,790
关于这个快速复习，有什么问题？

138
00:08:10,740 --> 00:08:14,790
好的，有几点非常重要，

139
00:08:16,660 --> 00:08:21,820
记住 xv6 ，甚至大多数日志记录系统。

140
00:08:21,850 --> 00:08:24,610
一个是 xv6 以及所有日志系统

141
00:08:24,610 --> 00:08:27,280
都遵循所谓的预写规则。

142
00:08:28,530 --> 00:08:35,510
也就是说，当你有一些操作的一些写入，

143
00:08:35,510 --> 00:08:37,550
而这些写入都需要是原子的，

144
00:08:39,760 --> 00:08:47,220
系统必须将所有这些更新的的数据写入日志，

145
00:08:47,340 --> 00:08:50,730
在允许将应用这些更新之前，

146
00:08:50,760 --> 00:08:52,590
到文件系统中的原位置，

147
00:08:52,770 --> 00:08:56,520
也就是说，我们需要预先声明所有更新，

148
00:08:56,520 --> 00:08:59,400
我们想要是原子的，

149
00:08:59,430 --> 00:09:00,570
在日志中预先声明它们，

150
00:09:00,570 --> 00:09:03,060
在我们可以将任何一个应用到文件系统之前，

151
00:09:03,270 --> 00:09:04,650
即所谓的预写规则。

152
00:09:05,970 --> 00:09:11,790
这是日志允许崩溃恢复的基础。

153
00:09:12,360 --> 00:09:15,660
所以，预先规则允许这些更新

154
00:09:15,660 --> 00:09:18,610
相对于崩溃看起来是原子的。

155
00:09:18,970 --> 00:09:21,310
还有一条我没有谈到的规则，

156
00:09:23,800 --> 00:09:28,910
那就是我们不能释放或重复使用日志，

157
00:09:28,910 --> 00:09:31,730
xv6 对每个系统调用反复使用日志，

158
00:09:31,730 --> 00:09:32,930
每个系统调用一次，

159
00:09:32,990 --> 00:09:34,970
我们不允许重用日志，

160
00:09:35,000 --> 00:09:37,370
在日志中的所有写入

161
00:09:37,370 --> 00:09:40,070
都已经写入磁盘上的原位置之前。

162
00:09:40,510 --> 00:09:43,570
所以这也是我所说的释放法则，

163
00:09:47,690 --> 00:09:54,580
也就是说，我们不能覆盖或重用日志，直到，

164
00:09:54,580 --> 00:09:58,330
或者部分日志包含指定事务，

165
00:09:58,570 --> 00:10:00,340
一组需要原子的写入，

166
00:10:00,400 --> 00:10:01,930
我们不能重用这部分日志，

167
00:10:01,930 --> 00:10:03,340
直到所有写入，

168
00:10:03,520 --> 00:10:04,690
不是部分日志，

169
00:10:04,690 --> 00:10:08,060
所有它们都被反映到

170
00:10:08,060 --> 00:10:13,070
文件系统中的原位置。

171
00:10:13,280 --> 00:10:15,200
所以， xv6 中的事务，

172
00:10:15,200 --> 00:10:18,740
end_op 触发了大量工作，

173
00:10:18,740 --> 00:10:22,640
而文件系统，正如我提到的那样，写入所有日志，

174
00:10:22,640 --> 00:10:25,600
日志写入 header 日志，写入 header 块，

175
00:10:25,630 --> 00:10:30,700
然后文件系统将所有这些块写入它们的原始位置，

176
00:10:30,700 --> 00:10:33,310
这是假设不发生崩溃的情况下。

177
00:10:33,670 --> 00:10:36,550
所以文件系统第二次写入时，

178
00:10:36,550 --> 00:10:39,400
所有块到它们在磁盘上的原位置，

179
00:10:39,400 --> 00:10:42,700
然后在所有原位置都被更新之后，

180
00:10:42,760 --> 00:10:44,740
只有在那时，文件系统才继续，

181
00:10:45,040 --> 00:10:50,230
xv6 文件系统从 header 块中擦除这些块编号，

182
00:10:50,230 --> 00:10:52,930
表明我们已完成这个事务，

183
00:10:53,170 --> 00:10:54,670
并且可以重用日志。

184
00:10:54,880 --> 00:10:57,670
删除块编号是至关重要的，

185
00:10:57,730 --> 00:10:59,710
在向日志中写入任何新内容之前，

186
00:10:59,710 --> 00:11:01,240
因为我们不想处于这样的情况，

187
00:11:01,240 --> 00:11:04,960
在 header 中先前事务的一些块编号，

188
00:11:05,110 --> 00:11:08,710
但是块来自新的事务，

189
00:11:09,260 --> 00:11:11,840
可能是不同的块编号在日志中，

190
00:11:12,170 --> 00:11:15,590
因为崩溃可能会应用这些内容

191
00:11:15,890 --> 00:11:20,120
应用留在 header 块中过期的块编号。

192
00:11:20,150 --> 00:11:21,740
所以你先删除 header 块，

193
00:11:21,920 --> 00:11:23,180
所以这是一条释放规则，

194
00:11:23,180 --> 00:11:27,680
规定在我们被允许从日志中删除事务之前，

195
00:11:27,710 --> 00:11:29,660
我们必须将所有这些块写入文件系统。

196
00:11:31,920 --> 00:11:33,870
好的，这样做的最终效果是

197
00:11:33,870 --> 00:11:39,550
复杂的或需要多次写入的文件系统更新，

198
00:11:39,580 --> 00:11:42,580
实际效果是使每个系统调用是原子的，

199
00:11:43,060 --> 00:11:45,610
对于崩溃来说，全部写入或没有写入。

200
00:11:47,680 --> 00:11:55,130
好的，日志方案通向 Linux 的桥梁是

201
00:11:55,130 --> 00:11:58,220
是关于 xv6 日志有什么问题，

202
00:11:58,220 --> 00:12:02,090
为什么 Linux 不使用与 xv6 完全相同的方案。

203
00:12:02,720 --> 00:12:04,370
答案是它很慢，

204
00:12:04,490 --> 00:12:06,710
xv6 方案相当慢，

205
00:12:08,240 --> 00:12:09,140
每个系统调用，

206
00:12:09,140 --> 00:12:12,830
在 xv6 中，比如 write 或 create 这样的系统调用返回前，

207
00:12:12,920 --> 00:12:16,850
我刚才说的这些东西都要完成，

208
00:12:16,910 --> 00:12:22,340
所以，在你的文件创建系统调用返回用户空间之前，

209
00:12:22,990 --> 00:12:25,810
它必须完成 end_op 所做的所有工作，

210
00:12:25,810 --> 00:12:27,610
这意味着将每个块写入日志，

211
00:12:27,610 --> 00:12:28,780
写入 header 块，

212
00:12:28,840 --> 00:12:31,090
写入所有块到这里的位置，

213
00:12:31,090 --> 00:12:32,200
并删除 header 块，

214
00:12:32,200 --> 00:12:33,370
然后就可以返回了。

215
00:12:33,400 --> 00:12:34,840
在此期间，

216
00:12:35,360 --> 00:12:38,330
不仅每个系统调用需要很长时间，

217
00:12:38,330 --> 00:12:41,210
而且文件系统中不会发生其他事情，

218
00:12:41,240 --> 00:12:44,330
当所有系统调用提交，

219
00:12:44,660 --> 00:12:47,300
将其块写入其原位置。

220
00:12:47,300 --> 00:12:49,820
所以系统调用一次只发生一个，

221
00:12:49,940 --> 00:12:53,600
并且每个系统调用都需要许多磁盘写入。

222
00:12:54,500 --> 00:12:58,520
每个系统调用必须

223
00:12:58,520 --> 00:13:02,360
等待其所有磁盘写入完成的术语称为同步。

224
00:13:02,840 --> 00:13:10,940
嗯，这个，可能拼写不一样。

225
00:13:11,210 --> 00:13:14,180
无论如何，对于磁盘来说， xv6 系统调用是同步的。

226
00:13:14,180 --> 00:13:15,140
所以它们非常慢，

227
00:13:15,350 --> 00:13:19,220
对于机械磁盘更是慢的可怕，

228
00:13:19,220 --> 00:13:23,090
因为每一次写入都需要 10 毫秒。

229
00:13:23,270 --> 00:13:24,980
我们谈论的是许多写入的系统调用，

230
00:13:24,980 --> 00:13:30,680
所以， xv6 在一秒钟内只能执行几个文件系统修改系统调用。

231
00:13:31,240 --> 00:13:35,260
我想如果我们运行 xv6 固态硬盘速度更快，

232
00:13:35,260 --> 00:13:38,050
但仍然没有达到应有的效率。

233
00:13:39,260 --> 00:13:42,200
另一个需要注意的更详细的事情是，

234
00:13:42,200 --> 00:13:44,990
每个块在 xv6 方案中写入两次，

235
00:13:45,710 --> 00:13:47,120
它第一次写入日志，

236
00:13:47,120 --> 00:13:49,310
然后第二次写入磁盘。

237
00:13:49,790 --> 00:13:51,140
所以这也是，

238
00:13:51,820 --> 00:13:53,020
有好的理由，

239
00:13:53,020 --> 00:13:57,640
但是 ext3 可以部分修复这个问题。

240
00:13:59,730 --> 00:14:02,250
好的，那么在 Linux 上，

241
00:14:02,280 --> 00:14:05,820
根据今天的论文，它是，

242
00:14:06,420 --> 00:14:12,050
我要谈谈这个 ext3 文件系统，

243
00:14:12,050 --> 00:14:16,790
今天的论文经过几年的变化，

244
00:14:16,790 --> 00:14:18,110
在更多的发展之后，

245
00:14:19,020 --> 00:14:21,000
并得到广泛应用。

246
00:14:22,520 --> 00:14:27,000
好的，所以 ext3 ，

247
00:14:29,660 --> 00:14:34,640
它是对之前的无日志文件系统的修改。

248
00:14:34,640 --> 00:14:39,640
所以，他们真的利用现有存储系统，

249
00:14:39,640 --> 00:14:41,620
并在它上面加上日志，

250
00:14:41,620 --> 00:14:48,610
使底层 ext2 文件系统几乎没有修改，

251
00:14:48,610 --> 00:14:50,800
虽然不是完全没有。

252
00:14:50,950 --> 00:14:54,970
所以，从某种意义上说，日志是一种非常容易，

253
00:14:55,240 --> 00:14:57,700
至少，对它们来说升级很容易。

254
00:14:58,490 --> 00:15:10,240
ex3 保持着类似于 xv6 的数据结构，

255
00:15:10,240 --> 00:15:15,790
在内存中，有一个块缓存，一个回写缓存，

256
00:15:19,450 --> 00:15:21,100
这里有一些缓存块，

257
00:15:21,920 --> 00:15:22,970
其中一些是干净的，

258
00:15:22,970 --> 00:15:24,290
因为它们没有被修改，

259
00:15:24,290 --> 00:15:26,000
因为它们与磁盘上的内容完全相同，

260
00:15:26,000 --> 00:15:26,870
有一些是脏的，

261
00:15:26,870 --> 00:15:28,640
它们被写入，

262
00:15:28,880 --> 00:15:30,320
自从从磁盘读取它们，

263
00:15:30,560 --> 00:15:31,940
有一些人是固定的，

264
00:15:31,940 --> 00:15:34,520
因为它们不允许被写回磁盘，

265
00:15:34,670 --> 00:15:36,200
因为回写规则，

266
00:15:36,440 --> 00:15:40,520
我是说因为释放规则，预写规则。

267
00:15:41,130 --> 00:15:46,800
ext2 还维护一些事务信息，

268
00:15:49,840 --> 00:15:55,060
你可以维护多个事务的信息，

269
00:15:55,060 --> 00:15:58,420
它们在不同运行阶段并行。

270
00:15:58,570 --> 00:16:01,960
所以，可能有许多不同的事务，

271
00:16:01,960 --> 00:16:05,740
ext3 系统跟踪着，

272
00:16:06,250 --> 00:16:08,860
每个事务都有一个序列号，

273
00:16:12,460 --> 00:16:16,780
事务系统的一些块编号，

274
00:16:16,810 --> 00:16:21,880
日志系统记住事务修改的块，

275
00:16:22,210 --> 00:16:26,600
所以这是一组块编号。

276
00:16:27,400 --> 00:16:29,800
这是缓存块，

277
00:16:29,800 --> 00:16:33,280
因为任何修改至少开始只发生在缓存中。

278
00:16:33,820 --> 00:16:36,280
然后是一组被称为 handle 的东西，

279
00:16:39,970 --> 00:16:44,380
它们是有关仍在并发执行的系统调用的信息，

280
00:16:44,470 --> 00:16:46,540
并且作为事务的一部分，

281
00:16:46,540 --> 00:16:49,480
以及读取和写入缓存块。

282
00:16:51,000 --> 00:16:56,840
在磁盘上，

283
00:16:56,840 --> 00:17:00,140
就像 xv6 一样，有通常的文件系统树，

284
00:17:00,720 --> 00:17:03,810
索引节点目录块和文件等等，

285
00:17:04,050 --> 00:17:07,500
还有一些位图块

286
00:17:07,650 --> 00:17:13,050
表示每个数据块是否已分配，

287
00:17:13,530 --> 00:17:17,190
这些就是我所说的文件系统数据块的原位置，

288
00:17:17,580 --> 00:17:23,270
然后在磁盘的指定部分，是日志。

289
00:17:25,510 --> 00:17:27,760
目前为止，这与 xv6 非常相似，

290
00:17:27,790 --> 00:17:32,160
主要区别在于 ext3 能够

291
00:17:32,160 --> 00:17:36,270
同时跟踪多个事务

292
00:17:36,270 --> 00:17:39,060
在其执行的不同阶段。

293
00:17:42,290 --> 00:17:47,960
现在我想更仔细地看看 ext3 中的日志，

294
00:17:47,960 --> 00:17:51,770
与 xv6 日志略有不同。

295
00:17:58,730 --> 00:18:00,260
有一种日志格式，

296
00:18:04,010 --> 00:18:08,000
在日志的开头，有一些东西叫做超级块，

297
00:18:11,080 --> 00:18:14,820
这是日志超级块，

298
00:18:14,820 --> 00:18:17,010
与文件系统的超级块不同。

299
00:18:18,290 --> 00:18:27,020
日志超级块包含日志中第一个有效事务的偏移量和序列号，

300
00:18:27,050 --> 00:18:28,340
所以会有一个偏移量，

301
00:18:28,990 --> 00:18:31,780
只是在日志中的一个字节数，块编号，

302
00:18:31,780 --> 00:18:33,730
然后是这个序列号，

303
00:18:33,730 --> 00:18:37,060
记得我说过每个事务都有自己的序列号，

304
00:18:37,240 --> 00:18:38,950
然后剩下的日志，

305
00:18:38,950 --> 00:18:43,570
日志只是磁盘上已知大小的一串连续数据块。

306
00:18:46,150 --> 00:18:49,180
每个事务，剩下的日志包含事务，

307
00:18:49,210 --> 00:18:52,420
每个事务包含一个描述块，

308
00:18:55,510 --> 00:18:59,440
包含块编号，

309
00:19:00,300 --> 00:19:04,180
非常像 xv6 中的 header 块。

310
00:19:04,180 --> 00:19:05,830
然后，

311
00:19:05,830 --> 00:19:07,630
对于每个块编号，

312
00:19:07,630 --> 00:19:13,370
实际更新的内容块对应于块编号，

313
00:19:13,370 --> 00:19:17,180
最后，对于完成并提交的事务，

314
00:19:17,600 --> 00:19:19,250
这里会有一个提交块，

315
00:19:22,590 --> 00:19:25,410
这是日志中一个单独的块。

316
00:19:26,380 --> 00:19:30,430
因为可以有多个事务日志，

317
00:19:30,430 --> 00:19:36,310
那个提交块后面可能是下一个描述块，

318
00:19:36,580 --> 00:19:38,110
然后是一些数据块，

319
00:19:38,110 --> 00:19:43,150
然后也许下一个事务的提交块。

320
00:19:44,610 --> 00:19:45,720
所以我们有多个，

321
00:19:46,110 --> 00:19:47,250
日志文件可能相当长，

322
00:19:47,250 --> 00:19:49,770
并包含多个事务。

323
00:19:52,600 --> 00:19:54,430
所以我们可以可以，

324
00:19:54,460 --> 00:19:56,980
它们之间的偏移量和序列号，

325
00:19:57,100 --> 00:20:00,810
指向最开始的，

326
00:20:00,960 --> 00:20:06,750
编号最小的有效事务日志的开头。

327
00:20:10,950 --> 00:20:15,180
这里的一些小细节会很重要，

328
00:20:15,180 --> 00:20:19,230
这些是描述符块和提交块，

329
00:20:20,760 --> 00:20:24,510
为了能够将它们与数据块区分，

330
00:20:24,600 --> 00:20:27,570
如果它们在崩溃和恢复后扫描日志时，

331
00:20:27,660 --> 00:20:31,830
提交块的描述以魔数开始，

332
00:20:31,830 --> 00:20:34,810
它是一个 32 位数，

333
00:20:34,810 --> 00:20:40,230
在数据中不太可能发生，

334
00:20:41,350 --> 00:20:48,320
帮助日志软件区分描述符和提交块与数据块。

335
00:20:52,460 --> 00:20:55,670
好的，记住这个结构，

336
00:20:55,670 --> 00:21:00,950
我要谈谈 ext3 获得良好性能的高级方法。

337
00:21:00,950 --> 00:21:02,660
有三个主要原因。

338
00:21:02,780 --> 00:21:04,940
但是，有一个问题，

339
00:21:05,090 --> 00:21:10,370
是否有可能至少该系统在提交块之前有描述符块，

340
00:21:10,370 --> 00:21:12,800
比如两个事务同时进行。

341
00:21:13,930 --> 00:21:18,120
日志中可以有多个事务。

342
00:21:19,160 --> 00:21:22,730
在下一个事务开始之前，这个事务完成。

343
00:21:23,210 --> 00:21:25,490
是的，我们正在讨论这件事，

344
00:21:25,490 --> 00:21:27,230
但是是这样的，

345
00:21:27,230 --> 00:21:33,760
是的，一次只有一个未完成事务，

346
00:21:34,150 --> 00:21:38,160
这张图片不太合适，

347
00:21:38,160 --> 00:21:39,840
因为当前打开的事务，

348
00:21:40,140 --> 00:21:46,470
当前打开的事务是系统调用正在向其中执行写入的事务，

349
00:21:47,310 --> 00:21:50,550
所以当前打开的事务只存在于内存中，

350
00:21:51,670 --> 00:21:54,760
因为当前的系统调用是更新，

351
00:21:54,820 --> 00:21:59,110
它们只是更新内存中的文件系统块缓存块，

352
00:21:59,470 --> 00:22:06,770
当 ext3 系统决定结束当前打开的事务时，

353
00:22:07,370 --> 00:22:08,750
在它决定结束时，

354
00:22:08,930 --> 00:22:10,400
它会做两件事，

355
00:22:10,400 --> 00:22:12,470
一个是它启动一个新的打开的事务，

356
00:22:12,470 --> 00:22:13,790
也就是下一个事务，

357
00:22:13,880 --> 00:22:19,130
然后它写入刚刚完成的事务，

358
00:22:19,370 --> 00:22:21,890
开始将刚刚完成的事务写入磁盘，

359
00:22:21,890 --> 00:22:23,030
可能需要相当长的时间。

360
00:22:24,080 --> 00:22:29,690
所以，整个故事是，

361
00:22:29,690 --> 00:22:31,610
有一些更老的事务在磁盘上，

362
00:22:31,610 --> 00:22:33,020
所有都是关闭的，

363
00:22:33,200 --> 00:22:37,430
加上一个在内存中打开的事务。

364
00:22:38,690 --> 00:22:39,620
并且至少最开始，

365
00:22:39,620 --> 00:22:41,840
磁盘上的这些事务

366
00:22:42,520 --> 00:22:46,450
可能仅以日志记录的形式存在，

367
00:22:46,480 --> 00:22:49,540
还没有写到它们的原地址，

368
00:22:49,540 --> 00:22:51,340
然后一段时间后，

369
00:22:51,580 --> 00:22:54,610
从最早的事务开始，

370
00:22:54,820 --> 00:22:58,540
日志系统会写入，

371
00:22:59,380 --> 00:23:02,080
将日志中的这些更新块写入它们的原位置，

372
00:23:02,080 --> 00:23:05,500
然后，一旦每个完整的事务完成，

373
00:23:05,560 --> 00:23:10,760
然后，日志系统可以释放并重用日志中的这些空间，

374
00:23:11,120 --> 00:23:12,770
所以这是一个环形的日志，

375
00:23:12,770 --> 00:23:15,590
当你到达日志末尾时，

376
00:23:15,590 --> 00:23:20,660
日志系统开始使用开头的块，

377
00:23:20,720 --> 00:23:23,450
你必须释放它们，

378
00:23:24,050 --> 00:23:26,150
将它们写入原位置来释放这些块，

379
00:23:26,150 --> 00:23:27,080
然后才能使用它们。

380
00:23:29,590 --> 00:23:30,160
好的。

381
00:23:31,110 --> 00:23:35,790
好的，有三种方式可以让 ext3 获得良好性能，

382
00:23:36,210 --> 00:23:40,410
一个是它有异步系统调用，

383
00:23:40,410 --> 00:23:44,580
也就是系统调用在写磁盘之前就返回，

384
00:23:44,610 --> 00:23:49,020
系统调用只是更新内存中的缓存块，然后返回，

385
00:23:49,020 --> 00:23:50,640
不需要写入磁盘，

386
00:23:50,640 --> 00:23:52,140
不需要等待磁盘写入，

387
00:23:52,680 --> 00:23:54,330
虽然需要等待磁盘读取。

388
00:23:55,470 --> 00:23:58,860
下一个获得高性能方法是批处理，

389
00:24:01,690 --> 00:24:05,560
我们可以将多个系统调用在单个事务中批量处理。

390
00:24:06,010 --> 00:24:08,980
最后一个获得高性能的方法是并发。

391
00:24:12,480 --> 00:24:13,560
这些是所有的事情，

392
00:24:13,560 --> 00:24:18,900
ext3 做的，而 xv6 没有做的事情。

393
00:24:20,270 --> 00:24:24,560
好的，我将分别谈谈这三个高性能技术。

394
00:24:28,170 --> 00:24:31,530
抱歉，我想问一下批处理的事，

395
00:24:32,640 --> 00:24:36,450
我想 xv6 允许多个系统调用

396
00:24:36,450 --> 00:24:42,720
同时执行 start_op end_op ，

397
00:24:42,780 --> 00:24:46,110
然后它们一起提交。

398
00:24:46,230 --> 00:24:49,050
是的， xv6 是有限数量的批处理。

399
00:24:50,370 --> 00:24:52,110
好的，谢谢。

400
00:24:56,340 --> 00:25:03,920
好的，那么第一个，异步系统调用，

401
00:25:08,520 --> 00:25:10,350
这意味着系统调用返回，

402
00:25:10,410 --> 00:25:13,020
但是它们修改了缓存中的块，然后返回，

403
00:25:13,590 --> 00:25:17,020
没有触发磁盘写入。

404
00:25:18,280 --> 00:25:21,940
所以，这对系统调用快速返回是一个明显的优势。

405
00:25:22,800 --> 00:25:25,620
它也支持 IO 并发，

406
00:25:25,890 --> 00:25:30,840
即应用程序可以进行一些文件系统调用，

407
00:25:30,840 --> 00:25:35,010
这意味着文件系统要做大量的磁盘写入，

408
00:25:35,610 --> 00:25:38,580
但是应用可以返回到计算

409
00:25:39,140 --> 00:25:43,460
与文件系统执行写入并行，

410
00:25:43,460 --> 00:25:45,650
那些系统调用所需的写入，

411
00:25:46,670 --> 00:25:48,500
这就是 IO 并发。

412
00:25:49,600 --> 00:25:51,730
如果没有异步系统调用，

413
00:25:51,820 --> 00:25:54,190
就很难获得 IO 并发性，

414
00:25:55,520 --> 00:26:00,590
很难在磁盘操作和应用程序计算之间重叠，

415
00:26:00,590 --> 00:26:04,130
如果应用程序必须等待磁盘写入完成。

416
00:26:05,070 --> 00:26:10,110
异步系统调用的另一个好处是，

417
00:26:10,290 --> 00:26:13,950
它们使执行大量批处理变得更容易，

418
00:26:14,250 --> 00:26:15,900
可以帮助批处理。

419
00:26:19,080 --> 00:26:24,720
异步系统调用的缺点是，

420
00:26:25,690 --> 00:26:28,540
这意味着因为系统调用返回，

421
00:26:28,570 --> 00:26:31,630
并不意味着工作，

422
00:26:31,840 --> 00:26:36,820
（并不意味着）系统调用应该做的工作已经完成，

423
00:26:36,880 --> 00:26:38,770
所以，如果你编写一个程序，

424
00:26:38,770 --> 00:26:41,380
它创建文件并写入一些数据，

425
00:26:41,380 --> 00:26:42,700
然后关闭该文件，

426
00:26:42,700 --> 00:26:46,030
然后在控制台上打印完成给用户，

427
00:26:46,470 --> 00:26:49,590
然后你拔下电脑电源，

428
00:26:50,650 --> 00:26:51,820
重新启动电脑，

429
00:26:51,820 --> 00:26:53,170
你的数据可能不在那里了，

430
00:26:53,200 --> 00:26:55,120
即使所有系统调用都返回了，

431
00:26:55,120 --> 00:26:57,220
即使程序说，

432
00:26:57,250 --> 00:26:59,620
我调用了那些系统调用，而且它们返回了。

433
00:27:00,140 --> 00:27:05,810
这意味着在一个异步系统调用的世界里，

434
00:27:05,870 --> 00:27:08,330
应用程序必须写得更仔细，

435
00:27:08,330 --> 00:27:13,310
如果它们关心自己在崩溃中的行为，

436
00:27:13,340 --> 00:27:15,200
这是一个很大的问题，

437
00:27:17,360 --> 00:27:20,840
在 xv6 中，如果一个写入返回，

438
00:27:21,420 --> 00:27:22,950
数据就在磁盘上，

439
00:27:22,950 --> 00:27:25,020
并且在崩溃后还在那里，

440
00:27:25,020 --> 00:27:27,180
在 ext3 中，如果写入返回，

441
00:27:27,900 --> 00:27:30,870
你对崩溃后会发生什么一无所知，

442
00:27:30,900 --> 00:27:31,860
可能在那里，也可能不在那里。

443
00:27:32,440 --> 00:27:37,750
所以，尽管异步系统调用可能编写谨慎的程序，

444
00:27:37,750 --> 00:27:39,700
比如数据库就需要小心，

445
00:27:39,910 --> 00:27:41,740
文本编辑器需要小心，

446
00:27:41,770 --> 00:27:42,880
如果我写一个文件，

447
00:27:42,880 --> 00:27:44,260
我不想，

448
00:27:44,590 --> 00:27:47,710
如果我在文本编辑器里写一个文件的时候停电了，

449
00:27:47,740 --> 00:27:51,820
我不想在启动之后看到乱码或部分文件，

450
00:27:51,850 --> 00:27:54,400
我想看的是旧文件或新文件。

451
00:27:54,920 --> 00:27:59,720
所以文件系统还提供了一些用于谨慎应用的技术，

452
00:27:59,750 --> 00:28:05,170
在崩溃的情况下获得可预测的行为，

453
00:28:05,170 --> 00:28:10,990
主要工具是系统调用 fsync ，

454
00:28:10,990 --> 00:28:14,230
所有 Unix 系统都有，

455
00:28:14,230 --> 00:28:16,060
这里说的是，

456
00:28:17,200 --> 00:28:18,670
你向它传递一个文件描述符，

457
00:28:19,240 --> 00:28:22,810
它告诉文件系统，执行所有写入，

458
00:28:22,900 --> 00:28:25,420
我可能调用了写入很多东西并调用 fsync ，

459
00:28:25,450 --> 00:28:27,640
我现在想让你真正写入，

460
00:28:27,670 --> 00:28:31,480
不要在写入到磁盘之前从系统调用返回，

461
00:28:31,480 --> 00:28:35,410
保证它们还在那里，如果发生崩溃。

462
00:28:35,530 --> 00:28:39,550
所以，如果你查看数据库或文本编辑器的代码，

463
00:28:39,550 --> 00:28:42,190
还有其他关心它们数据的程序，

464
00:28:42,310 --> 00:28:45,430
你会看到一些对 fsync 的调用，

465
00:28:45,810 --> 00:28:49,960
为了克服这个，

466
00:28:50,620 --> 00:28:52,960
为了避免这些异步系统调用。

467
00:28:52,990 --> 00:28:55,300
大多数程序，比如编译器，

468
00:28:55,300 --> 00:28:56,380
这不是大问题，

469
00:28:56,380 --> 00:29:00,130
如果发生崩溃，编译器的输出消失了，

470
00:29:00,130 --> 00:29:01,720
有很多很多程序，

471
00:29:01,900 --> 00:29:03,010
不会调用 fsync ，

472
00:29:03,010 --> 00:29:06,550
很高兴得到异步系统调用的良好性能，

473
00:29:06,970 --> 00:29:08,980
并不担心它们的崩溃行为。

474
00:29:12,530 --> 00:29:13,280
好的，那么。

475
00:29:13,400 --> 00:29:16,910
这是不是有时也叫 flush ，

476
00:29:16,910 --> 00:29:20,390
因为我以前听过这个词。

477
00:29:20,450 --> 00:29:21,830
是的，你可以，

478
00:29:21,890 --> 00:29:24,410
一种合理的解释 fsync 作用的方式是，

479
00:29:24,470 --> 00:29:28,280
它将这个文件的所有写入刷新到磁盘，

480
00:29:28,370 --> 00:29:29,300
并且返回，

481
00:29:30,080 --> 00:29:31,760
flush 是一个合理的词，

482
00:29:31,940 --> 00:29:33,320
flush 写入到磁盘中。

483
00:29:37,090 --> 00:29:38,710
好的，这就是异步系统调用。

484
00:29:38,710 --> 00:29:43,690
ext3 使用的下一种技术是批处理。

485
00:29:46,560 --> 00:29:51,270
这里的做法是，

486
00:29:51,270 --> 00:29:52,590
在任何时候，

487
00:29:52,590 --> 00:30:00,560
ext3 中总是有一个打开的事务，

488
00:30:01,480 --> 00:30:04,150
ext3 中的事务可以

489
00:30:04,150 --> 00:30:08,650
保存许多不同系统调用的写入，

490
00:30:08,890 --> 00:30:13,360
所以 ext3 要做的是启动一个新事务，

491
00:30:13,360 --> 00:30:15,850
然后在接下来的几秒钟内，

492
00:30:15,850 --> 00:30:18,040
执行的所有系统调用都是，

493
00:30:18,130 --> 00:30:21,970
它们的写入都是那个大事务的一部分，

494
00:30:22,210 --> 00:30:23,110
我认为默认情况下，

495
00:30:23,200 --> 00:30:27,010
ext3 只在每 5 秒创建一个新事务，

496
00:30:27,040 --> 00:30:30,970
所以每个事务可能有最多 5 秒的系统调用，

497
00:30:31,300 --> 00:30:32,740
所以作为一个大的批处理，

498
00:30:32,740 --> 00:30:34,660
然后在 5 秒钟结束时，

499
00:30:36,480 --> 00:30:39,450
ext3 提交这个单个的大事务，

500
00:30:39,450 --> 00:30:41,610
可能包含上百个更新块，

501
00:30:43,020 --> 00:30:46,020
将这个事务作为单个事务提交。

502
00:30:46,440 --> 00:30:48,060
所以这个有优势的的原因，

503
00:30:48,930 --> 00:30:52,320
首先，它分散了一些固定的事务成本，

504
00:30:52,350 --> 00:30:55,950
摊销了很多系统调用中固定的事务成本，

505
00:30:55,950 --> 00:30:59,700
比如，你必须写入描述符块和提交块，

506
00:31:00,030 --> 00:31:02,760
你必须在机械驱动器上寻找，

507
00:31:02,760 --> 00:31:03,750
至少你必须寻找，

508
00:31:03,810 --> 00:31:06,300
让驱动器旋转到日志所在的位置，

509
00:31:06,300 --> 00:31:07,860
这些都是很大的开销，

510
00:31:08,160 --> 00:31:10,890
而它们对于批处理只需要做一次，

511
00:31:10,890 --> 00:31:12,210
而不是每个系统调用一次。

512
00:31:12,540 --> 00:31:17,100
因此，它降低了这些成本的影响。

513
00:31:17,580 --> 00:31:18,990
另一个大事是，

514
00:31:19,320 --> 00:31:22,800
另一个大事是它允许写入吸收，

515
00:31:23,850 --> 00:31:25,860
也就是说，

516
00:31:29,000 --> 00:31:30,410
它是这种情况，

517
00:31:30,440 --> 00:31:33,110
你有一个完整的系统调用序列，

518
00:31:33,110 --> 00:31:36,590
一次又一次地修改完全相同的块，

519
00:31:36,740 --> 00:31:39,890
比如，如果我创建了一大堆文件，

520
00:31:40,070 --> 00:31:42,350
我需要分配一堆 inode ，

521
00:31:42,350 --> 00:31:46,040
所有的 inode 都很小，可能只有 64 个字节，

522
00:31:46,040 --> 00:31:47,840
这么多 inode 可以放在一个块中，

523
00:31:48,050 --> 00:31:50,180
所以，连续创建一堆文件

524
00:31:50,330 --> 00:31:54,320
会使几个块中的许多 inode 变脏，

525
00:31:54,600 --> 00:31:57,090
因为有很多块的 inode 。

526
00:31:57,120 --> 00:32:01,680
类似地，如果我要将大量数据写入文件，

527
00:32:01,680 --> 00:32:03,630
我可能需要分配很多数据块，

528
00:32:03,660 --> 00:32:08,910
我可能会翻转空闲位图中的许多位，

529
00:32:09,630 --> 00:32:11,790
如果我分配彼此相邻的块，

530
00:32:11,910 --> 00:32:14,160
它们的位将放在同一个块中，

531
00:32:14,520 --> 00:32:17,340
所以，我可能在一个块中放很多位，

532
00:32:17,430 --> 00:32:23,250
所以，许多系统调用可能会一次又一次地操作相同的块。

533
00:32:23,250 --> 00:32:25,880
在使用批处理的系统中，

534
00:32:25,910 --> 00:32:28,820
这些很多写入相同的数据块，

535
00:32:28,820 --> 00:32:31,790
只是对缓存发生得非常快，

536
00:32:31,940 --> 00:32:34,100
只是数据块的缓存拷贝，

537
00:32:34,100 --> 00:32:35,390
因为我们还没有写入磁盘，

538
00:32:35,600 --> 00:32:40,360
然后，我们将这些少量数据块写入磁盘，

539
00:32:40,390 --> 00:32:42,460
只在事务结束时写入一次，

540
00:32:42,610 --> 00:32:47,110
而单个块写入日志，

541
00:32:47,170 --> 00:32:51,610
将许多修改的系统调用放入同一个块中。

542
00:32:51,640 --> 00:32:53,050
所以，这种写入吸收可以减少总次数的数量，

543
00:32:54,940 --> 00:33:00,280
明显减少我们必须写入块的总次数，

544
00:33:00,280 --> 00:33:04,020
与类似 xv6 的同步系统相比。

545
00:33:05,870 --> 00:33:10,790
最后的重大优势是磁盘调度，

546
00:33:12,530 --> 00:33:17,810
一般来说，即使我们，

547
00:33:18,590 --> 00:33:21,800
假设我们必须向磁盘写入一千个块，

548
00:33:22,340 --> 00:33:24,230
它的效率要高得多，

549
00:33:24,260 --> 00:33:25,520
当然是在机械磁盘上，

550
00:33:25,520 --> 00:33:27,110
但是即使在固态驱磁盘中，

551
00:33:27,170 --> 00:33:32,090
为了在顺序位置中一次写入一千个块，

552
00:33:32,150 --> 00:33:33,380
就像你对日志所做的那样，

553
00:33:33,800 --> 00:33:35,240
做这个要快的多，

554
00:33:35,240 --> 00:33:39,980
跟写入一千个块每次都在不同的地方比较，

555
00:33:40,370 --> 00:33:42,290
甚至一千个块，

556
00:33:42,320 --> 00:33:46,490
甚至在日志中写入相同的块一千次。

557
00:33:47,860 --> 00:33:51,910
所以，通过让磁盘进行大批量写入，

558
00:33:52,240 --> 00:33:54,490
这样可以更有效率，

559
00:33:55,660 --> 00:33:58,000
我们不仅获得效率

560
00:33:58,000 --> 00:34:01,030
从顺序写入日志中的很多块，

561
00:34:01,180 --> 00:34:04,150
但是即使我们要写入原位置，

562
00:34:04,150 --> 00:34:07,540
为一批写入，

563
00:34:07,540 --> 00:34:11,200
由单个大事务中的一批操作产生，

564
00:34:11,530 --> 00:34:16,090
如果我们可以向该驱动器大量的写入，

565
00:34:16,090 --> 00:34:17,530
即使有不同的位置，

566
00:34:17,530 --> 00:34:19,060
因为有原位置，

567
00:34:19,680 --> 00:34:22,020
涉及多个不同的系统调用，

568
00:34:22,290 --> 00:34:28,020
如果我们允许磁盘调度大量不同的写入，

569
00:34:28,050 --> 00:34:29,760
它可以选一个顺序把它们放进去，

570
00:34:29,760 --> 00:34:32,520
这在机械磁盘上特别有效率，

571
00:34:32,520 --> 00:34:36,930
这对它们进行排序，

572
00:34:36,930 --> 00:34:39,750
按驱动器上的磁道号进行排序，

573
00:34:39,750 --> 00:34:43,740
从一个到另一个只需一次小的寻找，

574
00:34:43,800 --> 00:34:45,090
它们可以进行这种排序，

575
00:34:45,180 --> 00:34:48,080
如果你同时得到所有的块。

576
00:34:48,500 --> 00:34:50,060
即使是在固态硬盘上，

577
00:34:50,060 --> 00:34:53,240
这里也有一些小优势，

578
00:34:53,240 --> 00:34:55,430
给磁盘大量的工作去做。

579
00:34:56,150 --> 00:34:59,990
不管怎么说，你能得到这种磁盘调度，

580
00:35:00,500 --> 00:35:03,590
如果你有非常大批量写入交给磁盘，

581
00:35:03,650 --> 00:35:05,270
所以这是批处理的又一个优势。

582
00:35:09,180 --> 00:35:10,590
好的，

583
00:35:11,410 --> 00:35:17,770
ext3 的最后一个重大优势是并发，

584
00:35:18,190 --> 00:35:22,310
它有两种并发性，

585
00:35:22,310 --> 00:35:29,310
与 xv6 比较。

586
00:35:34,340 --> 00:35:38,660
一个是，它可以允许多个系统调用同时执行，

587
00:35:38,660 --> 00:35:43,520
所以，我们可以并行进行多个系统调用。

588
00:35:45,520 --> 00:35:47,620
因为至少，

589
00:35:49,340 --> 00:35:56,670
在 ext3 决定关闭并提交当前事务之前，

590
00:35:58,110 --> 00:35:59,670
系统调用不必相互等待，

591
00:35:59,670 --> 00:36:02,190
它们都可以修改属于当前事务的块，

592
00:36:02,190 --> 00:36:06,910
并且所有这些系统调用都可以并行执行，

593
00:36:06,910 --> 00:36:09,370
并向当前事务添加块，

594
00:36:09,610 --> 00:36:11,980
这在多核计算机上尤为重要，

595
00:36:12,040 --> 00:36:13,690
在没有不同内核的地方，

596
00:36:13,690 --> 00:36:14,980
我们等待锁，

597
00:36:15,850 --> 00:36:19,690
在 xv6 经常是不允许的，

598
00:36:19,720 --> 00:36:20,920
系统调用不能进行，

599
00:36:20,920 --> 00:36:26,010
因为当前事务正忙于做其他事情。

600
00:36:26,690 --> 00:36:28,580
在 ext3 中的大多数情况下，

601
00:36:29,780 --> 00:36:32,840
许多系统调用都可以修改当前事务。

602
00:36:33,860 --> 00:36:37,520
ext3 获得并发性的另一种方式是

603
00:36:37,730 --> 00:36:40,040
可以有多个事务，

604
00:36:40,070 --> 00:36:43,640
处于不同执行阶段的旧事务。

605
00:36:46,670 --> 00:36:51,620
所以，只有一个打开的事务可以接收系统调用，

606
00:36:51,620 --> 00:36:54,800
但是其他正在向磁盘写入内容的事务可以并行进行，

607
00:36:55,040 --> 00:36:58,250
所以很多老的事务，

608
00:37:00,470 --> 00:37:04,880
在事务生命周期中的不同阶段，

609
00:37:04,880 --> 00:37:06,500
可以并行进行。

610
00:37:07,820 --> 00:37:09,860
首先，这里有一个打开的事务，

611
00:37:12,220 --> 00:37:15,790
可以有一些最近的事务，

612
00:37:15,940 --> 00:37:18,640
文件系统正在提交它们，

613
00:37:18,640 --> 00:37:21,400
但它们仍在将数据块写入磁盘，

614
00:37:21,430 --> 00:37:26,460
所以，我们有一些事务正在提交到日志中。

615
00:37:30,280 --> 00:37:32,020
我们不用等这些结束，

616
00:37:32,080 --> 00:37:36,250
我们可以在新的打开事务中继续系统调用，

617
00:37:36,250 --> 00:37:39,400
虽然之前仍在写入日志的事务

618
00:37:39,430 --> 00:37:42,250
还没有完成，仍在提交中。

619
00:37:42,730 --> 00:37:43,930
当然，这个阶段结束，

620
00:37:43,930 --> 00:37:48,010
当事务将提交块写入磁盘中的日志时。

621
00:37:49,790 --> 00:37:52,130
可以存在事务，

622
00:37:52,130 --> 00:37:55,340
甚至更旧的事务正在写入，

623
00:37:56,250 --> 00:38:00,630
它们的块缓存到原位置，

624
00:38:01,830 --> 00:38:03,090
修改后的数据块，

625
00:38:03,150 --> 00:38:07,470
最后，没有更多工作，

626
00:38:07,470 --> 00:38:12,030
那么最老的事务可以被释放。

627
00:38:13,960 --> 00:38:15,700
这并不需要工作本身，

628
00:38:15,700 --> 00:38:16,600
工作是，

629
00:38:17,860 --> 00:38:21,760
它在写事务到它们的原位置，

630
00:38:21,790 --> 00:38:24,580
不管怎样，通常存在多个事务，

631
00:38:25,270 --> 00:38:27,430
存在于不同的阶段。

632
00:38:28,450 --> 00:38:30,400
所以，特别是，

633
00:38:30,520 --> 00:38:34,240
新的系统调用可以在不等待较旧事务的情况下执行，

634
00:38:34,240 --> 00:38:36,370
完成对日志的提交，

635
00:38:36,400 --> 00:38:39,610
或完成写入它们的原位置，

636
00:38:40,180 --> 00:38:41,500
与 xv6 不同的是，

637
00:38:41,500 --> 00:38:45,490
新的系统调用必须等待所有完成，

638
00:38:46,710 --> 00:38:48,330
对于之前的事务。

639
00:38:49,100 --> 00:38:50,000
我有一个问题，

640
00:38:50,540 --> 00:38:51,620
那么它是如何工作的，

641
00:38:51,620 --> 00:38:53,300
当有操作时，

642
00:38:53,300 --> 00:38:56,120
或者当有东西写入缓存块时，

643
00:38:56,150 --> 00:38:58,700
而块也在被写入到磁盘中。

644
00:38:59,260 --> 00:39:01,870
好的，所以这，

645
00:39:01,870 --> 00:39:03,610
这确实是个问题，

646
00:39:03,640 --> 00:39:09,300
而且，

647
00:39:10,660 --> 00:39:12,550
这里有一个潜在的困难，

648
00:39:12,550 --> 00:39:17,860
因为事务写入日志的内容

649
00:39:17,860 --> 00:39:23,170
应该仅包括由该事务中的系统调用进行的更新，

650
00:39:23,410 --> 00:39:26,590
不应包括其他块更新，

651
00:39:26,620 --> 00:39:29,440
由事务后的系统调用所做的，

652
00:39:29,680 --> 00:39:32,380
因为如果你这样做了，

653
00:39:32,410 --> 00:39:36,670
你可能会有提交的风险，

654
00:39:36,670 --> 00:39:42,580
日志更新只表示了部分系统调用，

655
00:39:42,790 --> 00:39:44,500
因为我们希望确保

656
00:39:44,500 --> 00:39:50,250
事务只包含所有给定的系统调用更新，

657
00:39:50,400 --> 00:39:52,800
所以，我们不能允许事务

658
00:39:53,130 --> 00:39:59,310
包含事务开始关闭后发生的任何更新，

659
00:39:59,880 --> 00:40:01,710
ext3 解决它的方法，

660
00:40:02,350 --> 00:40:04,210
至少在理论上，

661
00:40:04,210 --> 00:40:05,230
它制作一个副本，

662
00:40:05,530 --> 00:40:08,530
当它决定结束当前打开的事务时，

663
00:40:08,830 --> 00:40:12,640
它会复制该事务的所有块，

664
00:40:12,640 --> 00:40:15,130
直到它结束该事务为止。

665
00:40:15,730 --> 00:40:18,530
所以它在某种程度上复制了所有的块，

666
00:40:18,530 --> 00:40:20,750
然后，通过复制的块，

667
00:40:20,930 --> 00:40:24,230
那个事务提交它的日志，

668
00:40:24,560 --> 00:40:29,670
任何较新的事务都有它们自己修改的块副本，

669
00:40:29,670 --> 00:40:32,760
与提交到日志的副本不同。

670
00:40:34,570 --> 00:40:36,520
为了让这个更高效，

671
00:40:36,520 --> 00:40:39,130
系统使用了写入时复制方案，

672
00:40:39,130 --> 00:40:42,820
避免复制，直到它注意到

673
00:40:42,820 --> 00:40:45,430
更新的事务需要写入那个块。

674
00:40:46,080 --> 00:40:47,130
酷，理解了。

675
00:40:51,730 --> 00:40:53,020
好的。

676
00:40:54,590 --> 00:40:57,950
很好，并发可以提高性能的原因，

677
00:40:57,950 --> 00:41:00,620
它可以帮助我们，

678
00:41:01,070 --> 00:41:02,660
如果我们可以并行运行系统调用，

679
00:41:02,660 --> 00:41:04,670
我们得到了多核并行，

680
00:41:04,880 --> 00:41:10,340
如果我们可以同时运行应用程序和系统调用，

681
00:41:10,340 --> 00:41:11,210
我们正在写入磁盘，

682
00:41:11,210 --> 00:41:13,520
我们可以获得 IO 并发性，

683
00:41:13,520 --> 00:41:16,160
它可以在 CPU 之间重叠，

684
00:41:16,520 --> 00:41:19,520
CPU 执行和磁盘 IO 。

685
00:41:19,670 --> 00:41:20,990
所有这些帮助，

686
00:41:21,290 --> 00:41:25,310
更有效地利用硬件资源和使用机器。

687
00:41:27,370 --> 00:41:30,070
好的，有没有关于并发性的问题？

688
00:41:35,810 --> 00:41:38,390
好的，我想让你感受一下

689
00:41:38,390 --> 00:41:41,120
实际的文件系统代码，

690
00:41:41,180 --> 00:41:46,050
如果你查看文件系统的 Linux 源码，

691
00:41:46,990 --> 00:41:48,850
从抽象的层次，

692
00:41:49,300 --> 00:41:51,850
这是每个系统调用的样子。

693
00:41:52,030 --> 00:41:55,180
你可能有 unlink 系统调用，

694
00:41:57,710 --> 00:42:03,110
这在 xv6 中非常熟悉，

695
00:42:03,350 --> 00:42:05,420
每个系统调用需要说，

696
00:42:05,450 --> 00:42:08,060
这是写入序列的开始，

697
00:42:08,090 --> 00:42:09,710
我即将执行一系列写入操作，

698
00:42:09,710 --> 00:42:11,720
它们需要关于崩溃是原子的。

699
00:42:11,720 --> 00:42:12,710
所以，任何系统调用，

700
00:42:14,900 --> 00:42:17,510
必须有一个清晰的开头和结尾，

701
00:42:17,810 --> 00:42:21,680
这两点之间的一切都需要是原子的。

702
00:42:22,270 --> 00:42:27,980
这里有一个名为 start 的系统调用，

703
00:42:30,620 --> 00:42:31,940
事实证明，

704
00:42:32,030 --> 00:42:36,350
ext3 必须知道处于活动状态的不同系统调用，

705
00:42:36,770 --> 00:42:39,500
原因我会马上解释。

706
00:42:39,710 --> 00:42:41,420
所以，每个系统调用，

707
00:42:41,420 --> 00:42:43,760
当我调用 start 时，会得到一个所谓的句柄，

708
00:42:44,240 --> 00:42:48,500
这是这个特定系统调用的唯一标识符，

709
00:42:48,920 --> 00:42:53,330
它创建的写入是日志，

710
00:42:53,330 --> 00:42:54,770
文件系统用于跟踪，

711
00:42:54,770 --> 00:42:58,650
那个写入是由这个特定的系统调用完成的，

712
00:42:59,070 --> 00:43:01,530
然后系统调用这些读写块，

713
00:43:01,560 --> 00:43:04,050
所以它获得块，

714
00:43:04,050 --> 00:43:08,760
或者一个块缓冲器缓存，

715
00:43:08,910 --> 00:43:10,790
调用它，

716
00:43:11,000 --> 00:43:12,590
它给出句柄，

717
00:43:12,590 --> 00:43:14,690
然后是它需要读写的块。

718
00:43:18,090 --> 00:43:19,500
然后它可能会执行大量这样的写入操作。

719
00:43:19,500 --> 00:43:22,140
如果你需要修改很多块。

720
00:43:22,600 --> 00:43:27,220
然后修改缓存中的块。

721
00:43:31,680 --> 00:43:32,940
当它完成时，

722
00:43:33,180 --> 00:43:35,280
这个特定的系统调用完成时，

723
00:43:35,640 --> 00:43:37,320
它发出一个 stop 调用，

724
00:43:39,970 --> 00:43:42,040
并传递句柄给 stop 调用。

725
00:43:45,490 --> 00:43:52,570
所以，这些是为了通知日志系统，

726
00:43:52,570 --> 00:43:54,850
一旦系统调用开始，

727
00:43:54,970 --> 00:43:56,980
不允许提交事务，

728
00:43:57,010 --> 00:44:00,970
直到该事务中开始的所有系统调用都已完成。

729
00:44:01,180 --> 00:44:06,490
因为它们是多个事务，

730
00:44:07,210 --> 00:44:09,160
系统必须能够联系，

731
00:44:09,160 --> 00:44:10,540
使用句柄的一个原因，

732
00:44:10,540 --> 00:44:13,090
文件系统可以记得

733
00:44:13,090 --> 00:44:16,000
对于每个系统调用是哪个事务的一部分。

734
00:44:16,000 --> 00:44:18,430
所以它知道，哦，这个刚结束，

735
00:44:19,810 --> 00:44:22,960
这是特定事务等待的系统调用之一，

736
00:44:22,960 --> 00:44:24,370
在它可以提交之前。

737
00:44:26,850 --> 00:44:28,830
我们将句柄传递给 get 系统调用，

738
00:44:28,830 --> 00:44:32,670
每个事务都有一堆块，

739
00:44:32,670 --> 00:44:36,810
与作为该事务的一部分的被修改的块相关。

740
00:44:37,140 --> 00:44:38,430
所以，我们在这里要说的，

741
00:44:38,430 --> 00:44:41,010
除了获得块的指针之外，

742
00:44:41,070 --> 00:44:42,510
我们告诉日志系统，

743
00:44:42,510 --> 00:44:46,050
这个块编号是这个事务的一部分，

744
00:44:46,050 --> 00:44:48,090
这个句柄所关联的（事务）。

745
00:44:51,110 --> 00:44:53,570
这个 stop 调用并不会调用提交，

746
00:44:53,840 --> 00:44:55,220
它只是告诉日志系统，

747
00:44:55,220 --> 00:45:01,040
在这个事务中活动的系统调用减少了一个。

748
00:45:01,860 --> 00:45:03,990
所以，一个事务可以提交，

749
00:45:03,990 --> 00:45:09,090
只有这个事务中启动的所有系统调用都调用了 stop 时，

750
00:45:09,090 --> 00:45:10,980
事务必须做一些记录，

751
00:45:10,980 --> 00:45:12,840
记住开始的所有句柄，

752
00:45:12,840 --> 00:45:17,190
这样，当它们调用 stop 时，可以进行检查。

753
00:45:20,440 --> 00:45:22,630
所以考虑到这个结构，

754
00:45:22,630 --> 00:45:25,240
我将展示完整的序列，

755
00:45:25,240 --> 00:45:28,270
提交事务需要什么。

756
00:45:28,450 --> 00:45:30,670
所以，在某个时候，当所有的，

757
00:45:31,030 --> 00:45:34,780
每隔 5 秒，文件系统会考虑，

758
00:45:34,780 --> 00:45:37,900
哦，现在是提交当前打开的事务的好时机。

759
00:45:38,600 --> 00:45:40,820
所以，这是会发生的事，

760
00:45:42,180 --> 00:45:47,280
当文件系统提交事务时。

761
00:45:47,280 --> 00:45:48,720
所以，有这些步骤。

762
00:45:55,810 --> 00:46:01,110
所以，首先，我们必须阻塞所有新的系统调用，

763
00:46:01,230 --> 00:46:08,630
我们需要让我们的事务只反映整个系统调用，

764
00:46:08,630 --> 00:46:11,540
所以我们不想让任何新的开始，

765
00:46:12,620 --> 00:46:14,900
当我们试图提交事务时，

766
00:46:15,020 --> 00:46:18,200
我们希望只包括已经开始的系统调用，

767
00:46:19,100 --> 00:46:21,020
所以你需要阻塞新的系统调用。

768
00:46:21,020 --> 00:46:22,820
还有另一个原因，我要谈一谈，

769
00:46:25,630 --> 00:46:27,550
为什么我们需要阻塞新的系统调用。

770
00:46:29,980 --> 00:46:32,110
这是一个小的性能缺陷，

771
00:46:32,110 --> 00:46:34,510
这里会有一段时间，

772
00:46:34,510 --> 00:46:38,410
系统调用必须等待并且不允许执行，

773
00:46:38,440 --> 00:46:39,400
所以那太糟糕了。

774
00:46:40,040 --> 00:46:41,570
第二步是，

775
00:46:42,400 --> 00:46:44,140
有一些已经启动的系统调用，

776
00:46:44,140 --> 00:46:45,430
它们是该事务的一部分，

777
00:46:46,510 --> 00:46:48,370
我们需要等它们完成，

778
00:46:48,610 --> 00:46:53,140
所以我们需要等待未完成的系统调用，

779
00:46:54,850 --> 00:46:55,960
它们在这个事务中。

780
00:46:59,440 --> 00:47:02,740
因为我们当然希望事务反映它们的所有写入，

781
00:47:03,220 --> 00:47:04,660
所以我们需要等它们完成。

782
00:47:05,170 --> 00:47:07,180
接下来发生的事情是，

783
00:47:07,180 --> 00:47:10,240
一旦该事务的所有系统调用都完成，

784
00:47:10,300 --> 00:47:11,860
并且完成对缓存的写入，

785
00:47:11,920 --> 00:47:14,230
就可以启动新事务，

786
00:47:14,230 --> 00:47:16,270
并让这些被阻塞的系统调用继续进行。

787
00:47:16,540 --> 00:47:19,090
所以现在我们要打开一个新的事务，

788
00:47:19,580 --> 00:47:23,120
为任何后续的系统调，

789
00:47:28,710 --> 00:47:29,790
但是现在，

790
00:47:29,820 --> 00:47:32,160
我继续我们最初的事务，

791
00:47:32,160 --> 00:47:33,690
它现在已经结束。

792
00:47:34,860 --> 00:47:38,010
所以记住 ext3 中的日志

793
00:47:38,010 --> 00:47:41,010
包含描述符、数据块和提交块。

794
00:47:41,850 --> 00:47:48,640
现在，我们知道修改的全部数据块，

795
00:47:48,670 --> 00:47:51,010
这个事务中的所有系统调用（所修改的），

796
00:47:51,430 --> 00:47:53,830
因为它们都使用一个句柄调用了 get ，

797
00:47:53,830 --> 00:47:57,400
告诉我们是哪个事务的一部分，

798
00:47:57,490 --> 00:48:00,220
我们知道该事务的全部修改块，

799
00:48:00,370 --> 00:48:02,350
所以现在我们可以写一个描述符块，

800
00:48:05,960 --> 00:48:08,180
有所有块编号，

801
00:48:09,460 --> 00:48:12,490
对于这个事务的的所有脏块。

802
00:48:17,770 --> 00:48:21,460
我们还将写入修改的块，

803
00:48:21,460 --> 00:48:25,600
从磁盘缓存到日志中，

804
00:48:25,720 --> 00:48:28,240
事实上，如果有人问一个问题，

805
00:48:28,240 --> 00:48:30,520
如果下一个事务修改了这个会发生什么，

806
00:48:30,520 --> 00:48:32,650
我们在这个阶段实际写入的是

807
00:48:32,650 --> 00:48:38,150
这个事务块保存的副本，

808
00:48:38,150 --> 00:48:39,920
在它完成时。

809
00:48:41,050 --> 00:48:46,240
所以，我要把块写入日志。

810
00:48:52,070 --> 00:48:56,900
现在，我们要等这些写入结束，

811
00:49:02,630 --> 00:49:06,830
这些需要完成，然后我们才能继续。

812
00:49:07,980 --> 00:49:11,970
一旦确保描述符和数据块在磁盘上，

813
00:49:12,000 --> 00:49:14,730
然后，我们可以将提交记录写入日志。

814
00:49:21,180 --> 00:49:25,620
一旦写入完成，我们就必须等待它完成。

815
00:49:31,420 --> 00:49:34,030
所以我们在等待提交写入完成，

816
00:49:34,150 --> 00:49:36,940
一旦提交写入完成，

817
00:49:37,600 --> 00:49:38,770
这个事务，

818
00:49:38,770 --> 00:49:41,170
用技术术语来说，

819
00:49:41,170 --> 00:49:44,530
就是这个事务达到了提交点，

820
00:49:46,060 --> 00:49:50,530
在这一点上保证写入和事务在崩溃中幸存下来，

821
00:49:50,710 --> 00:49:54,850
如果崩溃发生在写提交块之前，

822
00:49:55,560 --> 00:49:59,850
事务的写入不会出现在崩溃并重启之后，

823
00:50:00,240 --> 00:50:01,680
并运行恢复软件，

824
00:50:01,800 --> 00:50:03,030
如果崩溃现在发生，

825
00:50:03,030 --> 00:50:07,110
在提交块已经写入磁盘之后，

826
00:50:07,530 --> 00:50:09,990
然后可以保证

827
00:50:10,460 --> 00:50:13,940
保证事务中的所有写入

828
00:50:13,940 --> 00:50:16,520
在崩溃、重启和恢复之后出现。

829
00:50:18,010 --> 00:50:20,920
好的，现在，

830
00:50:21,040 --> 00:50:24,850
所有这些事情都是在幕后发生的，

831
00:50:24,850 --> 00:50:27,220
没有进程在等待这些东西，

832
00:50:28,540 --> 00:50:31,720
现在，我们可以将事务块写入

833
00:50:32,390 --> 00:50:34,310
它们在文件系统中的原位置。

834
00:50:43,540 --> 00:50:47,320
我将在几分钟后讨论，

835
00:50:47,620 --> 00:50:50,620
在这些写入都完成后，

836
00:50:51,200 --> 00:50:55,430
作为该事务一部分的所有块，

837
00:50:55,550 --> 00:51:00,860
只有那时，我们才能重用那部分日志。

838
00:51:03,760 --> 00:51:05,590
所以在一个非常繁忙的系统中，

839
00:51:05,860 --> 00:51:08,050
如果日志头赶上了尾，

840
00:51:08,050 --> 00:51:10,960
可能无法启动新事务，

841
00:51:10,960 --> 00:51:14,140
直到最旧的事务的所有这些写入完成，

842
00:51:14,170 --> 00:51:16,510
因为我们可能需要日志空间，

843
00:51:16,510 --> 00:51:17,740
所以我们不会，

844
00:51:17,950 --> 00:51:20,290
我们可能需要重用最旧的事务日志空间，

845
00:51:20,290 --> 00:51:21,370
我们必须进行写入

846
00:51:21,370 --> 00:51:24,970
写入所有缓存块到它们的原位置，

847
00:51:25,600 --> 00:51:28,540
通常人们尽量把日志做得足够大，

848
00:51:28,540 --> 00:51:30,280
这种情况很少发生，

849
00:51:30,370 --> 00:51:33,130
所以，这些东西可以在后台进行。

850
00:51:35,490 --> 00:51:36,810
任何关于这些步骤，有什么问题吗？

851
00:51:39,600 --> 00:51:41,730
哦，抱歉，那些东西在哪里运行？

852
00:51:42,560 --> 00:51:43,130
它们什么？

853
00:51:43,130 --> 00:51:48,290
我们写入这些文件系统的东西。

854
00:51:51,480 --> 00:51:57,570
哦，你说没有程序等着这些事情做完，

855
00:51:57,600 --> 00:52:01,680
那么它们在哪里运行？

856
00:52:02,520 --> 00:52:05,700
哦，有一个后台线程，

857
00:52:07,270 --> 00:52:11,380
在内核中专门有一个后台线程。

858
00:52:12,130 --> 00:52:13,540
我明白了，谢谢。

859
00:52:18,500 --> 00:52:22,930
我有关于重用部分日志的问题，

860
00:52:23,110 --> 00:52:23,890
所以，让我们，

861
00:52:24,550 --> 00:52:28,540
比如，最终我们开始使用日志的特定部分，

862
00:52:29,880 --> 00:52:33,600
而日志那个特定的部分，

863
00:52:33,720 --> 00:52:36,690
日志的特定部分，

864
00:52:36,690 --> 00:52:39,360
在我的新事务中，

865
00:52:39,360 --> 00:52:44,220
最终使用刚刚被释放的日志部分，

866
00:52:44,250 --> 00:52:45,570
没有其他的了，

867
00:52:45,600 --> 00:52:48,380
没有空间给日志了，

868
00:52:48,680 --> 00:52:52,010
然后系统只是等待，

869
00:52:52,250 --> 00:52:56,170
直到日志的另一部分被释放，

870
00:52:56,200 --> 00:52:58,270
或者它会做一些其他事情？

871
00:52:58,690 --> 00:53:01,090
是的，它会等待，

872
00:53:01,840 --> 00:53:04,540
让我来画一张图，

873
00:53:04,570 --> 00:53:07,930
确定我回答的问题是对的。

874
00:53:08,200 --> 00:53:11,800
我们可以把日志看作是这条线，

875
00:53:11,800 --> 00:53:12,580
是磁盘的一部分，

876
00:53:12,700 --> 00:53:13,840
在任何给定的时间，

877
00:53:13,840 --> 00:53:19,940
也许最老的有效事务是 t7 ，

878
00:53:20,180 --> 00:53:23,210
然后这个地区有 t8 ，

879
00:53:23,690 --> 00:53:25,130
然后我们有 t9 ，

880
00:53:25,160 --> 00:53:27,050
我们想要开始，

881
00:53:27,850 --> 00:53:30,010
我们想把 t10 放在这里。

882
00:53:33,120 --> 00:53:33,900
这个。

883
00:53:39,140 --> 00:53:39,530
让我们看看，

884
00:53:39,530 --> 00:53:44,090
首先，我们想开始一个新的事务，把它放在这里。

885
00:53:44,870 --> 00:53:48,720
我们可能要等待 t7

886
00:53:49,740 --> 00:53:54,720
把它的所有块写到原位置上，

887
00:53:54,720 --> 00:53:55,890
这样我们才能释放它。

888
00:53:57,100 --> 00:54:02,920
这可能意味着事务 10 中的东西不得不暂停，

889
00:54:03,480 --> 00:54:07,160
等待日志中的这些空间释放。

890
00:54:08,180 --> 00:54:09,110
这是你说的吗？

891
00:54:09,710 --> 00:54:11,150
是的，这么说吧，

892
00:54:11,840 --> 00:54:13,610
所以一开始可能是这种情况，

893
00:54:13,730 --> 00:54:19,730
我可以把事务 10 的块放在可用空间中，

894
00:54:19,730 --> 00:54:22,400
但是最终，如果日志变得足够大，

895
00:54:22,400 --> 00:54:24,320
它就会耗尽空闲空间，

896
00:54:24,320 --> 00:54:24,770
在这一点上，

897
00:54:24,770 --> 00:54:26,840
它需要等待事务 7 。

898
00:54:27,170 --> 00:54:27,800
是的。

899
00:54:27,860 --> 00:54:28,880
被记录下来，好的。

900
00:54:28,880 --> 00:54:32,120
是的，是的，如果有足够的活动进行，

901
00:54:32,210 --> 00:54:34,220
而日志绕回得足够快，

902
00:54:34,340 --> 00:54:39,500
你可能不得不等待新的新系统调用，

903
00:54:41,080 --> 00:54:43,270
我们甚至可能无法启动系统调用，

904
00:54:43,270 --> 00:54:47,050
在我们释放日志中的空间之前，

905
00:54:47,050 --> 00:54:49,180
为它们修改的块。

906
00:54:49,360 --> 00:54:52,360
如果你关心这件事的细节，

907
00:54:52,360 --> 00:54:55,690
就会发现这里有死锁的可能，

908
00:54:56,510 --> 00:55:02,510
意思是 ext3 最终，

909
00:55:02,720 --> 00:55:06,320
系统调用必须预先声明它们将需要多少块，

910
00:55:06,470 --> 00:55:10,940
这样日志系统能知道需要多少，

911
00:55:11,300 --> 00:55:16,710
你可以推论这个事务是否有足够的空间，

912
00:55:17,010 --> 00:55:19,860
因为我们不想让事务开始，

913
00:55:20,710 --> 00:55:22,780
我们不能提交到日志中。

914
00:55:26,390 --> 00:55:27,020
好的。

915
00:55:27,260 --> 00:55:28,610
假设，

916
00:55:28,610 --> 00:55:32,720
你试图放入的新日志或新事务，

917
00:55:32,720 --> 00:55:35,690
要到事务 8 ，

918
00:55:36,080 --> 00:55:39,170
所以你必须等待 7 和 8 ，对吧，

919
00:55:39,170 --> 00:55:40,700
那么这是怎么运作的？

920
00:55:40,730 --> 00:55:41,660
你的意思是，

921
00:55:42,920 --> 00:55:43,520
好的，

922
00:55:44,720 --> 00:55:47,780
事务 7 ，事务 8 和事务 9 ，

923
00:55:47,780 --> 00:55:49,880
至少在这张图中的都必须完成，

924
00:55:50,000 --> 00:55:52,430
或者所有系统调用都已完成。

925
00:55:53,180 --> 00:55:56,900
这些事务在日志中提交，

926
00:55:56,930 --> 00:55:58,610
因为这些是旧事务。

927
00:55:59,000 --> 00:56:01,470
所以，在这张图中，

928
00:56:01,470 --> 00:56:04,020
我们刚开始事务 10 ，

929
00:56:05,230 --> 00:56:08,560
所以，新的系统调用将写入事务 10 。

930
00:56:11,750 --> 00:56:13,580
是的，但是你说过，

931
00:56:14,460 --> 00:56:17,810
事务 10 太大不能放入那个空间，

932
00:56:17,810 --> 00:56:21,650
所以你需要释放事务 7 ，

933
00:56:21,860 --> 00:56:24,860
你需要等待它提交到磁盘中。

934
00:56:26,200 --> 00:56:27,640
是的。

935
00:56:27,670 --> 00:56:28,870
但是，会发生什么，

936
00:56:28,870 --> 00:56:32,770
如果事务 10 比事务 7 大，

937
00:56:32,770 --> 00:56:34,450
它要到事务 8 。

938
00:56:34,450 --> 00:56:35,740
我们必须等待，

939
00:56:36,970 --> 00:56:38,680
是的，我们必须等待，

940
00:56:38,890 --> 00:56:41,110
不管事务 10 有多大，

941
00:56:41,800 --> 00:56:45,580
我们需要足够的磁盘空间来容纳它，

942
00:56:45,970 --> 00:56:48,250
而不是足够的日志来容纳它，

943
00:56:48,490 --> 00:56:51,940
所以，如果事务 10 很大，

944
00:56:52,300 --> 00:56:55,210
它可能需要强制多个事务，

945
00:56:55,330 --> 00:57:01,280
多个最旧事务写入它们的原位置，

946
00:57:01,580 --> 00:57:02,960
并释放它们自己。

947
00:57:03,110 --> 00:57:05,720
我猜它的代码是怎么工作的，

948
00:57:05,750 --> 00:57:08,540
比如，它是不是查看它有多大，

949
00:57:08,540 --> 00:57:11,480
这里有一个事务，这里也有一个事务，

950
00:57:11,480 --> 00:57:13,310
我必须等待它们两个。

951
00:57:15,300 --> 00:57:22,000
文件系统知道日志中的所有事务有多大，

952
00:57:23,110 --> 00:57:24,460
它记得，

953
00:57:24,460 --> 00:57:26,440
记得我的意思是文件系统记得

954
00:57:26,440 --> 00:57:28,720
相当多关于每个较旧事务的信息，

955
00:57:28,720 --> 00:57:31,630
它知道每一个都是不是可写，

956
00:57:32,530 --> 00:57:35,290
文件系统跟踪所有这些块

957
00:57:35,290 --> 00:57:37,600
在每个旧事务中的（块），

958
00:57:37,600 --> 00:57:40,420
它是否已经把那个块写到原位置，

959
00:57:41,230 --> 00:57:42,490
这样它就可以知道，

960
00:57:42,490 --> 00:57:45,580
哦，我已经写好了，它可以知道是不是。

961
00:57:46,360 --> 00:57:48,040
并识别完成点，

962
00:57:48,040 --> 00:57:50,770
写入所有事务 7 的块或事务 8 的块。

963
00:57:50,770 --> 00:57:52,870
所以这里有相当多的记录，

964
00:57:53,880 --> 00:58:00,410
帮助文件系统了解每个旧事务的状态。

965
00:58:07,420 --> 00:58:07,930
好的。

966
00:58:09,880 --> 00:58:11,140
好的，那么，

967
00:58:11,260 --> 00:58:15,370
这是关于如何重用日志空间的主题，

968
00:58:15,370 --> 00:58:18,640
这里有一个小细节需要说。

969
00:58:18,700 --> 00:58:21,280
如果你记得，一开始的时候。

970
00:58:21,310 --> 00:58:24,400
让我来写一下图表，

971
00:58:24,880 --> 00:58:27,970
是一个超级块，

972
00:58:28,360 --> 00:58:31,420
日志超级块在日志的开头。

973
00:58:32,470 --> 00:58:35,620
所以在任何给定的时间里，

974
00:58:35,620 --> 00:58:37,300
你可能会有日志超级块，

975
00:58:37,330 --> 00:58:41,900
然后是一些事务，

976
00:58:43,410 --> 00:58:47,520
可能事务 4 是最新的事务，

977
00:58:47,520 --> 00:58:53,370
然后是事务 1 ，较旧的事务，

978
00:58:53,370 --> 00:58:54,360
这意味着，

979
00:58:54,510 --> 00:58:56,220
当然，日志是环绕在一起的。

980
00:59:01,200 --> 00:59:02,070
你知道，

981
00:59:03,060 --> 00:59:06,980
我们是否可以重复使用一部分日志的规则，

982
00:59:07,730 --> 00:59:09,890
我已经提到了，再说一遍，

983
00:59:09,950 --> 00:59:11,360
我们可以重用日志，

984
00:59:11,360 --> 00:59:15,140
我们就可以重用日志中事务 2 的这一部分，

985
00:59:15,200 --> 00:59:16,970
如果 t2 已经提交，

986
00:59:17,360 --> 00:59:22,850
并且所有 t2 的块已写入它们在文件系统中的原位置，

987
00:59:23,600 --> 00:59:30,380
这样在崩溃之后就不需要重播这些块了。

988
00:59:31,160 --> 00:59:36,890
并且如果在事务 2 之前的所有事务也被释放。

989
00:59:37,510 --> 00:59:39,250
如果这些条件都是真的，

990
00:59:39,280 --> 00:59:44,890
然后我们可以释放并重用 t2 所在的那部分日志，

991
00:59:45,610 --> 00:59:47,320
所以我们能使用 t2 ，

992
00:59:47,320 --> 00:59:52,000
在 t2 t1 完成提交之后，

993
00:59:52,000 --> 00:59:54,910
并且写入日志块到原位置中，

994
00:59:55,210 --> 00:59:57,880
然后这个超级块，

995
00:59:58,120 --> 01:00:01,750
为了方便崩溃后的恢复软件，

996
01:00:01,960 --> 01:00:03,760
如果我们决定我们可以，

997
01:00:04,180 --> 01:00:05,380
如果文件系统决定

998
01:00:05,380 --> 01:00:09,660
它可以释放和重用日志的特定部分，

999
01:00:09,960 --> 01:00:12,930
它也重写超级块，

1000
01:00:13,380 --> 01:00:19,740
超级块作为第一个事务日志的指针，

1001
01:00:19,770 --> 01:00:22,890
所以，作为释放部分日志的一部分，

1002
01:00:23,160 --> 01:00:25,620
文件系统修改超级块指向

1003
01:00:25,620 --> 01:00:31,350
日志中当前最旧事务的开始。

1004
01:00:32,540 --> 01:00:33,920
然后发生崩溃，

1005
01:00:34,740 --> 01:00:38,550
恢复软件读取超级块，找到开始的日志。

1006
01:00:42,160 --> 01:00:44,800
好的，如果发生崩溃，

1007
01:00:44,950 --> 01:00:52,690
当然崩溃导致 RAM 中的所有东西都消失了，

1008
01:00:52,780 --> 01:00:54,220
所以，所有记录，

1009
01:00:54,220 --> 01:00:58,660
文件系统记录着哪些块已写入原位置，

1010
01:00:58,660 --> 01:01:01,330
如果发生崩溃或停电，这些都会丢失，

1011
01:01:01,360 --> 01:01:04,120
然而，其中一个假设是

1012
01:01:04,120 --> 01:01:05,650
RAM 中没有任何有用的东西，

1013
01:01:05,830 --> 01:01:10,090
在崩溃过程中唯一能保存下来的东西是

1014
01:01:10,090 --> 01:01:11,380
磁盘上的任何东西，

1015
01:01:12,460 --> 01:01:16,270
我们参与了所有这些关于日志的讨论，

1016
01:01:16,330 --> 01:01:19,030
假设盘完全完好无损，

1017
01:01:19,030 --> 01:01:20,710
磁盘没有任何问题。

1018
01:01:22,360 --> 01:01:24,100
所以，也许你们应该考虑的正确模型是，

1019
01:01:24,100 --> 01:01:25,840
出现电源故障，

1020
01:01:25,840 --> 01:01:27,940
所有的东西都在嗡嗡作响，然后停电了，

1021
01:01:27,940 --> 01:01:29,740
系统在某个点上停止了，

1022
01:01:30,040 --> 01:01:33,190
在电源恢复后，

1023
01:01:33,190 --> 01:01:35,080
这上面有所有东西，

1024
01:01:35,320 --> 01:01:37,120
在断电时的（东西）。

1025
01:01:37,620 --> 01:01:40,770
所以我们绝对不会考虑

1026
01:01:40,770 --> 01:01:46,800
磁盘不知何故被崩溃损坏或损坏。

1027
01:01:51,740 --> 01:01:53,930
所以崩溃当然可能会中断，

1028
01:01:55,740 --> 01:01:59,820
是的，事务正在提交或还没有提交，

1029
01:01:59,820 --> 01:02:02,640
或者不管崩溃打断什么，

1030
01:02:03,000 --> 01:02:05,790
无论是事务的提交

1031
01:02:05,820 --> 01:02:10,560
或者写入事务块到它们的原位置。

1032
01:02:11,130 --> 01:02:14,700
所以，这意味着磁盘上的日志，

1033
01:02:14,790 --> 01:02:17,160
当电力恢复，回复运转时，

1034
01:02:17,160 --> 01:02:21,480
它会有一堆旧的完整的事务，

1035
01:02:21,600 --> 01:02:23,160
可能是 t1 和 t2 。

1036
01:02:24,600 --> 01:02:30,060
让我举一个新的例子，用于恢复。

1037
01:02:30,840 --> 01:02:34,470
比如我们有一个超级块，

1038
01:02:37,470 --> 01:02:41,420
而且，也许在崩溃的时候，

1039
01:02:41,420 --> 01:02:48,420
最老的事务是 t6 ，

1040
01:02:48,420 --> 01:02:49,710
然后是 t7 ，

1041
01:02:49,710 --> 01:02:52,830
然后我们绕回来，还在崩溃之前 t8 ，

1042
01:02:54,150 --> 01:02:58,500
而且这里曾经有一个 t5 ，

1043
01:02:59,480 --> 01:03:06,560
但是 t8 已经已经重写了 t5 的第一部分，

1044
01:03:06,590 --> 01:03:10,940
因为我们知道 t5 在崩溃之前已经释放了，

1045
01:03:10,940 --> 01:03:15,140
但是恢复软件不一定知道这一点。

1046
01:03:16,650 --> 01:03:21,210
假设超级块指向 t6 ，

1047
01:03:21,210 --> 01:03:24,960
作为最老的有效事务的开始，

1048
01:03:26,100 --> 01:03:27,930
t5 已经释放。

1049
01:03:28,490 --> 01:03:32,480
我们要重新启动，

1050
01:03:32,480 --> 01:03:34,430
恢复软件读取超级块，

1051
01:03:34,430 --> 01:03:38,000
然后，它知道日志的开始位置，

1052
01:03:38,030 --> 01:03:41,420
然后恢复软件将在日志中向前扫描，

1053
01:03:41,450 --> 01:03:43,700
试图找到日志的末尾。

1054
01:03:44,190 --> 01:03:47,640
我们需要找到解决问题的方法，

1055
01:03:48,600 --> 01:03:52,350
真正弄清楚日志的末尾，

1056
01:03:52,440 --> 01:03:56,100
它做到这一点的方法是，

1057
01:03:56,340 --> 01:04:01,380
我们知道每个事务都包含一个描述符块，

1058
01:04:01,470 --> 01:04:04,890
它指示事务上有多少数据块，

1059
01:04:05,190 --> 01:04:07,830
比如描述符块说有 17 个数据块，

1060
01:04:07,830 --> 01:04:10,710
我们预计会有 17 个数据块最终提交记录。

1061
01:04:11,120 --> 01:04:13,640
然后是另一个描述符记录，

1062
01:04:13,640 --> 01:04:17,330
然后描述符块包含的数据块的数量，

1063
01:04:17,450 --> 01:04:18,920
然后是另一个提交块。

1064
01:04:19,160 --> 01:04:22,640
所以，正向扫描中的日志软件，

1065
01:04:23,200 --> 01:04:25,300
可能 t6 和 t7 都没问题，

1066
01:04:25,300 --> 01:04:28,150
然后它看一下 t8 ， t8 有一些描述符块。

1067
01:04:29,800 --> 01:04:34,420
然后，恢复软件查找

1068
01:04:35,540 --> 01:04:37,820
事务的结尾在哪里，

1069
01:04:37,820 --> 01:04:42,440
并寻找一个提交块。

1070
01:04:42,560 --> 01:04:45,890
所以这里可能发生几件事，

1071
01:04:45,890 --> 01:04:49,800
可能是事务确实提交了，

1072
01:04:49,800 --> 01:04:52,230
恢复软件找到提交块，

1073
01:04:53,040 --> 01:04:56,070
然后它会寻找另一个，

1074
01:04:56,370 --> 01:04:59,880
它不知道事务是最后一个事务，

1075
01:05:00,030 --> 01:05:01,080
需要找出这一点，

1076
01:05:01,080 --> 01:05:03,390
所以，它查找接下来的一个块，

1077
01:05:03,540 --> 01:05:07,570
查看这是否是有效的描述符块，

1078
01:05:08,620 --> 01:05:12,820
我们知道这个块只是一个随机的块，

1079
01:05:12,820 --> 01:05:14,080
在事务 5 中，

1080
01:05:14,080 --> 01:05:15,670
完全不是描述符块，

1081
01:05:15,910 --> 01:05:16,690
那么问题是

1082
01:05:16,690 --> 01:05:20,350
恢复软件如何能够可靠地区分，

1083
01:05:20,350 --> 01:05:23,010
这是一个数据块，

1084
01:05:23,370 --> 01:05:24,810
在旧事务中间，

1085
01:05:24,810 --> 01:05:28,950
或者是事务 9 的描述符块。

1086
01:05:30,850 --> 01:05:33,490
有人知道有什么可靠的方法，可以做到这个吗？

1087
01:05:33,970 --> 01:05:35,530
是魔术数吗？

1088
01:05:36,040 --> 01:05:36,580
是的。

1089
01:05:36,580 --> 01:05:38,290
还是有一个保留位。

1090
01:05:39,110 --> 01:05:39,980
的确，

1091
01:05:39,980 --> 01:05:45,050
每个描述符提交块都以某个魔术数开头，

1092
01:05:45,080 --> 01:05:46,580
只是一个 32 位的值，

1093
01:05:46,580 --> 01:05:48,290
这是恢复软件寻找的，

1094
01:05:48,470 --> 01:05:49,790
我其实不知道是什么。

1095
01:05:49,790 --> 01:05:53,650
所以，游戏肯定是

1096
01:05:53,650 --> 01:05:55,780
我们到了事务 8 的末尾，

1097
01:05:55,780 --> 01:05:58,510
如果下一个块以魔术数开头，

1098
01:05:58,870 --> 01:06:01,810
然后恢复软件会假设，

1099
01:06:01,900 --> 01:06:03,820
哦，这是一个有效的描述符块。

1100
01:06:06,200 --> 01:06:09,110
你能不能，抱歉，有个问题，

1101
01:06:09,350 --> 01:06:11,030
它是不是不可靠的，

1102
01:06:11,030 --> 01:06:17,360
它理解为一个描述符块，

1103
01:06:17,390 --> 01:06:21,170
尝试读取指定它们的数据块的数量，

1104
01:06:21,170 --> 01:06:25,070
比如，查看是否在指定的位置有提交块，

1105
01:06:25,520 --> 01:06:26,720
在一定数量的块之后。

1106
01:06:27,630 --> 01:06:31,230
当然，如果这个日志看起来像一个描述符块，

1107
01:06:31,500 --> 01:06:33,330
那么它会继续，

1108
01:06:33,330 --> 01:06:35,490
并尝试读取对应的提交块，

1109
01:06:35,880 --> 01:06:37,890
如果提交块看起来不是提交块，

1110
01:06:37,890 --> 01:06:38,850
有正确魔术数，

1111
01:06:38,850 --> 01:06:41,010
它不会认为在这个事务中。

1112
01:06:43,760 --> 01:06:48,800
这里剩下的一点细节就是，

1113
01:06:48,920 --> 01:06:52,070
我们查找的块，

1114
01:06:52,070 --> 01:06:54,580
或者恢复软件怀疑的，

1115
01:06:54,580 --> 01:06:56,170
这是否是描述符块，

1116
01:06:56,350 --> 01:07:00,520
这可以是事务 5 中间的块，

1117
01:07:00,520 --> 01:07:03,190
包含任意位模式，

1118
01:07:03,730 --> 01:07:06,190
它可能就是文件中的数据块，

1119
01:07:06,190 --> 01:07:08,830
恰好是从这个神奇的数字开始的。

1120
01:07:10,940 --> 01:07:12,920
所以，作为最后的细节，

1121
01:07:12,920 --> 01:07:15,650
日志记录系统需要能够区分

1122
01:07:15,650 --> 01:07:18,740
以魔术数开头的有效描述符块，

1123
01:07:18,770 --> 01:07:22,910
还是一些以魔术数开头的数据块。

1124
01:07:24,920 --> 01:07:27,470
你可以想象不同的方式来做到这一点，

1125
01:07:27,620 --> 01:07:30,440
在 ext3 所做的是，

1126
01:07:30,500 --> 01:07:32,390
当它要向日志中写入块时，

1127
01:07:32,390 --> 01:07:34,580
这不是一个描述符块或提交块，

1128
01:07:34,640 --> 01:07:38,570
如果块以魔术数开头，它将其替换为零，

1129
01:07:38,840 --> 01:07:44,330
并在该事务描述符块中设置与该块对应的位，

1130
01:07:44,390 --> 01:07:48,290
这个位意味着这个特殊的数据块

1131
01:07:48,980 --> 01:07:51,500
以魔术数开始，我们用零代替它。

1132
01:07:52,130 --> 01:07:56,150
如果恢复软件需要重放那个块，

1133
01:07:56,180 --> 01:07:58,430
我们假设事务 8 有一个这样的块，

1134
01:07:58,430 --> 01:08:00,590
它最初是以魔术数开始的，

1135
01:08:00,590 --> 01:08:02,930
它将设置这个魔术标志位，

1136
01:08:03,600 --> 01:08:07,770
对应描述符块替换魔术数为零，

1137
01:08:07,950 --> 01:08:09,990
如果恢复重放这个块，

1138
01:08:09,990 --> 01:08:11,070
它将看到这个标志，

1139
01:08:11,100 --> 01:08:13,710
在将这个块重放到原位置之前，

1140
01:08:13,770 --> 01:08:16,320
使用魔术数替换零。

1141
01:08:17,350 --> 01:08:22,930
所以，除了描述符或提交块之外，

1142
01:08:22,930 --> 01:08:24,880
没有任何块可能以魔术数开头，

1143
01:08:25,380 --> 01:08:26,850
在这个记录系统中。

1144
01:08:26,850 --> 01:08:28,350
所以我们从来没有模棱两可，

1145
01:08:28,620 --> 01:08:32,100
如果块在提交块之后，并以一个魔术数开头，

1146
01:08:32,100 --> 01:08:35,040
那么它一定是一个描述符块。

1147
01:08:39,320 --> 01:08:41,300
好的，

1148
01:08:41,300 --> 01:08:42,980
我们在做恢复，

1149
01:08:42,980 --> 01:08:46,640
它从块开始，

1150
01:08:46,640 --> 01:08:51,500
从超级块表示最老的事务的块向前扫描，

1151
01:08:51,680 --> 01:08:55,730
它向前扫描，直到，

1152
01:08:56,460 --> 01:08:59,280
查找描述符或其对应的提交块，

1153
01:08:59,400 --> 01:09:01,980
它停止在，

1154
01:09:01,980 --> 01:09:05,730
后面的是提交块，而不是描述符块，

1155
01:09:06,360 --> 01:09:11,340
或者，在提交块之后的块是一个描述符块，

1156
01:09:11,340 --> 01:09:16,620
但是应该有对应的提交块，

1157
01:09:16,620 --> 01:09:19,710
是有效的提交块，没有魔术数。

1158
01:09:19,740 --> 01:09:21,270
所以在这一点上它会停止，

1159
01:09:21,540 --> 01:09:24,990
恢复软件清除日志到结尾，

1160
01:09:25,770 --> 01:09:30,570
在最后一个有效提交块的地方。

1161
01:09:30,980 --> 01:09:31,790
我们会忽略，

1162
01:09:31,790 --> 01:09:34,040
这之后可能会有部分事务，

1163
01:09:34,070 --> 01:09:35,780
开始提交，但没有结束，

1164
01:09:36,530 --> 01:09:39,380
但是恢复软件忽略那部分事务，

1165
01:09:39,380 --> 01:09:41,180
因为它没有所有的写入，

1166
01:09:41,330 --> 01:09:43,130
所以不能自动恢复它，

1167
01:09:43,730 --> 01:09:47,600
然后恢复软件将返回到日志的开头，

1168
01:09:47,660 --> 01:09:52,160
重放每个块，将每个块重写到其原位置，

1169
01:09:52,550 --> 01:09:54,020
一直贯穿日志，

1170
01:09:54,910 --> 01:09:57,730
到最后最后一个有效的提交块。

1171
01:10:00,550 --> 01:10:04,600
然后它可以重启剩下的操作系统，

1172
01:10:04,630 --> 01:10:08,560
启动剩下的操作系统和可以运行的普通程序，

1173
01:10:09,250 --> 01:10:12,670
在恢复完成之前，你不能运行任何程序，

1174
01:10:12,670 --> 01:10:16,980
因为文件系统无效。

1175
01:10:19,780 --> 01:10:21,130
关于恢复，有什么问题吗？

1176
01:10:22,690 --> 01:10:24,310
我有一个简短的问题，

1177
01:10:24,310 --> 01:10:27,010
我想以前提到过这一点，

1178
01:10:27,010 --> 01:10:33,640
但是在 xv6 中缺少这个日志事务方案的哪些部分呢？

1179
01:10:33,700 --> 01:10:37,060
在 xv6 中缺少的主要功能是

1180
01:10:37,060 --> 01:10:39,820
在日志中有多个事务的能力，

1181
01:10:40,330 --> 01:10:44,410
在 xv6 中，日志最多只有一个事务，

1182
01:10:44,860 --> 01:10:49,360
所以你不能在 xv6 中得到这个并发性，

1183
01:10:49,360 --> 01:10:55,180
当我执行来自事务 7 的系统调用时，

1184
01:10:55,650 --> 01:10:57,570
这将并行进入事务 7 ，

1185
01:10:57,600 --> 01:11:03,750
同时， ext3 可以将事务 6 提交到磁盘。

1186
01:11:04,830 --> 01:11:13,430
这个并发性在 xv6 中是不可用的，

1187
01:11:13,640 --> 01:11:17,210
因为日志只保存一个事务，

1188
01:11:17,240 --> 01:11:19,940
所以我们必须完成一个事务的所有工作，

1189
01:11:19,940 --> 01:11:23,630
在我们允许开始下一个事务之前。

1190
01:11:24,690 --> 01:11:25,980
所以它是正确而简单的，

1191
01:11:25,980 --> 01:11:29,760
但是你不会从 xv6 中获得太多的并行性。

1192
01:11:30,730 --> 01:11:31,600
好的，谢谢,

1193
01:11:31,630 --> 01:11:33,130
你是说，

1194
01:11:33,680 --> 01:11:35,840
它仍然可以有多个事务块，

1195
01:11:35,840 --> 01:11:38,540
但是它不能异步执行它们，

1196
01:11:40,540 --> 01:11:41,920
对吗？

1197
01:11:42,390 --> 01:11:43,950
xv6 ？

1198
01:11:43,950 --> 01:11:44,760
xv6 。

1199
01:11:45,000 --> 01:11:48,150
是的，它只有，

1200
01:11:48,820 --> 01:11:50,500
一旦它决定，

1201
01:11:52,730 --> 01:11:54,560
我的意思是图片有点混乱，

1202
01:11:54,560 --> 01:12:00,740
因为 xv6 可以允许一个以上的系统调用进入单个事务，

1203
01:12:00,770 --> 01:12:03,830
所以 xv6 确实有一些并发性，

1204
01:12:04,420 --> 01:12:05,860
还有一些批处理，

1205
01:12:05,950 --> 01:12:09,430
但是一旦 xv6 决定开始提交事务，

1206
01:12:10,360 --> 01:12:13,150
它必须完全完成那个事务，

1207
01:12:13,270 --> 01:12:14,530
提交到磁盘，

1208
01:12:14,530 --> 01:12:18,100
写入块到原位置，

1209
01:12:18,340 --> 01:12:21,640
然后从日志中擦除该事务，

1210
01:12:21,670 --> 01:12:22,810
它必须完成所有这些事情，

1211
01:12:22,810 --> 01:12:25,600
在执行任何新的系统调用之前。

1212
01:12:26,200 --> 01:12:28,810
因为没有什么地方

1213
01:12:28,810 --> 01:12:30,580
可以放置新系统调用的修改，

1214
01:12:30,580 --> 01:12:33,070
直到前一事务完全完成，

1215
01:12:33,700 --> 01:12:35,950
所以， xv6 之间的某种交替，

1216
01:12:35,950 --> 01:12:40,120
可以运行几个系统调用，然后提交事务，

1217
01:12:40,520 --> 01:12:41,750
然后再运行几个系统调用，

1218
01:12:41,750 --> 01:12:43,580
但是它不能重叠这两个。

1219
01:12:44,790 --> 01:12:45,000
好的。

1220
01:12:45,000 --> 01:12:46,290
ext3 可以。

1221
01:12:47,210 --> 01:12:47,870
谢谢。

1222
01:12:57,830 --> 01:13:05,600
好的，这是 ext3 设计中相对简单的部分，

1223
01:13:06,520 --> 01:13:10,510
它还有一堆棘手的细节，

1224
01:13:10,540 --> 01:13:12,070
其中有几点我想谈谈。

1225
01:13:12,520 --> 01:13:17,050
我之前提到过，有一个打开的事务，

1226
01:13:17,410 --> 01:13:21,730
但是当 ext3 决定想要关闭打开的事务时，

1227
01:13:22,660 --> 01:13:26,350
它必须等待所有系统调用完成，

1228
01:13:26,680 --> 01:13:30,800
在任何新的事务可以开始前，

1229
01:13:30,920 --> 01:13:33,110
所以可能有这样一张图片，

1230
01:13:33,530 --> 01:13:39,070
我们有原始的旧事务 t1 ，

1231
01:13:39,400 --> 01:13:44,980
在事务 1 中执行多个系统调用，

1232
01:13:45,070 --> 01:13:47,260
如果我们想要关闭事务 1 ，

1233
01:13:47,260 --> 01:13:49,420
我们必须停止接受新的系统调用，

1234
01:13:49,420 --> 01:13:52,540
因为我们想等现有的调用完成后才能提交，

1235
01:13:52,870 --> 01:13:56,080
但在所有这些系统调用完成之前，

1236
01:13:56,650 --> 01:13:59,860
在ext3 中不允许启动新的系统调用。

1237
01:13:59,980 --> 01:14:02,170
所以如果这里有事务 2 ，

1238
01:14:02,470 --> 01:14:04,750
在事务 2 中不允许发生任何事情，

1239
01:14:05,250 --> 01:14:06,540
任何事情都不允许，

1240
01:14:06,600 --> 01:14:10,350
系统调用允许开始，直到这些系统调用已经完成，

1241
01:14:10,770 --> 01:14:16,080
并且只有在那时，事务 2 才能开始接受系统调用。

1242
01:14:16,500 --> 01:14:19,720
所以，这里有一段时间，

1243
01:14:19,900 --> 01:14:23,500
其中新的系统调用都被阻塞，

1244
01:14:23,920 --> 01:14:25,060
这降低了性能，

1245
01:14:25,060 --> 01:14:27,370
因为它可以执行系统调用，

1246
01:14:27,370 --> 01:14:28,300
但我们不允许这样做，

1247
01:14:28,630 --> 01:14:30,430
那么问题是，

1248
01:14:30,940 --> 01:14:36,850
为什么 ext3 不允许在事务 2 中启动新的系统调用，

1249
01:14:37,030 --> 01:14:40,680
直到事务 1 中的所有系统调用都完成。

1250
01:14:43,330 --> 01:14:45,880
这是一个好问题，因为它限制了性能，

1251
01:14:46,210 --> 01:14:48,040
让我给你们举个例子，

1252
01:14:48,040 --> 01:14:51,160
如果 ext3 没有做到这一点，

1253
01:14:51,160 --> 01:14:54,550
那么可能会出现以下糟糕的情况。

1254
01:14:55,810 --> 01:14:59,290
那么，让我们假设事务 1 说其中有一个系统调用，

1255
01:15:01,040 --> 01:15:05,360
它是 create ，创建文件的系统调用，

1256
01:15:05,360 --> 01:15:06,950
可能是一个名为 x 的文件，

1257
01:15:07,250 --> 01:15:11,000
想法是，在这个 create 完成之前，

1258
01:15:11,060 --> 01:15:14,690
文件系统决定要启动一个新事务，

1259
01:15:14,720 --> 01:15:16,100
打开一个新事务，

1260
01:15:16,100 --> 01:15:18,710
并且它将在 create 之后接受任何系统调用，

1261
01:15:18,710 --> 01:15:21,530
在这个新的事务 t2 中，

1262
01:15:21,950 --> 01:15:25,990
事务 t2 开始，在 t1 结束之前，

1263
01:15:26,140 --> 01:15:29,500
我们现在开始执行事务 2 中的系统调用，

1264
01:15:31,450 --> 01:15:34,870
可能事务 t2 在某个其他文件上调用 unlink ，

1265
01:15:34,870 --> 01:15:40,050
那么 unlink 将释放与 y 相关联的 inode ，

1266
01:15:40,050 --> 01:15:41,730
所以可能，

1267
01:15:42,390 --> 01:15:45,570
在图中，我的时间是这个方向。

1268
01:15:47,550 --> 01:15:52,770
可能在这个时间点，事务 2 标记 inode 空闲，

1269
01:15:52,800 --> 01:15:54,510
标记 y 的 inode 空闲，

1270
01:15:54,750 --> 01:15:57,870
create 当然必须为 x 分配 inode ，

1271
01:15:57,960 --> 01:16:00,390
也许它在这个时间点分配了一个 inode ，

1272
01:16:01,200 --> 01:16:05,400
因为 create 是在 unlink 释放之后分配的，

1273
01:16:05,460 --> 01:16:07,980
它可能重复使用相同的 inode ，

1274
01:16:08,010 --> 01:16:11,790
所以也许 x 会得到与 y 相同的 inode ，

1275
01:16:11,790 --> 01:16:15,160
比如 inode 17 ，

1276
01:16:15,220 --> 01:16:16,000
然后，

1277
01:16:16,660 --> 01:16:19,330
这是可以的，因为 unlink 释放了这个 inode 。

1278
01:16:19,330 --> 01:16:21,540
所以，看起来还不是问题，

1279
01:16:21,810 --> 01:16:23,100
关键是，

1280
01:16:23,100 --> 01:16:24,360
我们在试着关闭事务 1 ，

1281
01:16:24,360 --> 01:16:26,790
所以，当 create 完成时，我们关闭事务 1 ，

1282
01:16:26,940 --> 01:16:28,350
我们要写入，

1283
01:16:28,350 --> 01:16:30,030
假设事务提交，

1284
01:16:30,030 --> 01:16:32,040
我们将其所有修改写入磁盘。

1285
01:16:32,660 --> 01:16:33,620
太棒了，

1286
01:16:33,650 --> 01:16:40,040
不过假设 unlink 需要一段时间，还没有结束，

1287
01:16:40,070 --> 01:16:42,140
假设提交完成后，

1288
01:16:42,170 --> 01:16:45,390
这里发生崩溃。

1289
01:16:47,790 --> 01:16:49,800
当恢复软件运行时，

1290
01:16:49,860 --> 01:16:52,350
它将看到事务 1 已提交，

1291
01:16:53,080 --> 01:16:55,540
而事务 2 没有，

1292
01:16:55,660 --> 01:16:58,540
所以恢复软件会完全忽略事务 2 ，

1293
01:16:58,930 --> 01:17:02,800
所以这意味着 unlink 写入从来没有发生过，

1294
01:17:02,800 --> 01:17:07,990
恢复软件不会执行对磁盘的 unlink 写入，

1295
01:17:08,020 --> 01:17:10,030
所以不会释放 inode ，

1296
01:17:10,630 --> 01:17:12,610
不会删除 y ，

1297
01:17:12,820 --> 01:17:15,430
在崩溃和恢复后 y 仍然存在，

1298
01:17:15,580 --> 01:17:17,620
它仍将使用 inode 17 ，

1299
01:17:17,710 --> 01:17:20,590
但是 create 事务确实完成了，

1300
01:17:20,590 --> 01:17:23,830
所以 x 也将使用 inode 17 ，

1301
01:17:23,830 --> 01:17:26,980
所以，现在我们错误地有两个文件

1302
01:17:27,730 --> 01:17:29,620
恰好使用相同的 inode ，

1303
01:17:30,200 --> 01:17:31,430
这意味着我将共享内容，

1304
01:17:31,430 --> 01:17:36,140
或者向其中一个文件写入，内容会神秘地出现在另一个文件中。

1305
01:17:36,870 --> 01:17:39,350
这完全是错误的，对吧。

1306
01:17:39,350 --> 01:17:41,570
重点是我们想要 unlink y ，

1307
01:17:41,780 --> 01:17:43,610
并使用释放的 inode x ，

1308
01:17:43,610 --> 01:17:45,500
而不是已经在使用的 inode ，

1309
01:17:46,010 --> 01:17:48,440
所以这里出了严重的问题。

1310
01:17:49,970 --> 01:17:52,970
思考这件事的一种方式是，

1311
01:17:52,970 --> 01:17:58,170
unlink 应该在事务 2 ，

1312
01:17:58,170 --> 01:18:00,540
写入一个块，修改一个块，

1313
01:18:01,140 --> 01:18:06,300
本质上，修改后的块被更早的事务使用，

1314
01:18:06,330 --> 01:18:08,580
所以，更晚的事务修改了块，

1315
01:18:08,970 --> 01:18:12,570
而修改后的块被更早的事务看到，

1316
01:18:12,720 --> 01:18:18,630
来自事务 2 的修改信息

1317
01:18:18,660 --> 01:18:20,970
被合并到事务 1 中。

1318
01:18:23,260 --> 01:18:26,350
这意味着我们在这里失去了原子性，

1319
01:18:26,350 --> 01:18:29,170
因为这件事的整个目标是，

1320
01:18:29,170 --> 01:18:32,530
unlink 的所有修改都应该发生，或者一个也不发生，

1321
01:18:33,240 --> 01:18:34,500
不是它们中的一部分，

1322
01:18:34,500 --> 01:18:36,510
但这里本质上发生的是，

1323
01:18:36,570 --> 01:18:40,260
因为事务 1 提交了这个 inode 的空闲，

1324
01:18:40,560 --> 01:18:45,300
这意味着一些修改事务发生了，

1325
01:18:45,570 --> 01:18:47,310
但其他没有发生，

1326
01:18:47,580 --> 01:18:54,500
我们通过在较早的事务中包含较晚事务的写入打破了原子性。

1327
01:18:55,040 --> 01:19:00,410
你可以想象有多种不同的方式来处理这个，

1328
01:19:01,700 --> 01:19:07,470
也许 create 可以注意到 17 是被一个未来的事务释放了的，

1329
01:19:07,470 --> 01:19:09,000
并且不使用这个 inode ，

1330
01:19:09,390 --> 01:19:14,070
事实上， ext3 对此采取了非常简单的方法，

1331
01:19:14,670 --> 01:19:17,340
它不允许启动任何系统调用，

1332
01:19:18,210 --> 01:19:22,380
直到来自前一事务的所有系统调用都已完成，

1333
01:19:22,410 --> 01:19:25,200
所以，这不可能，

1334
01:19:25,410 --> 01:19:28,650
事务的系统调用看到修改，

1335
01:19:28,710 --> 01:19:32,990
看到来自未来事务系统调用的更新。

1336
01:19:33,650 --> 01:19:37,400
本质上， unlink 被阻塞，

1337
01:19:37,400 --> 01:19:40,910
在 t1 提交之前不允许开始。

1338
01:19:42,390 --> 01:19:43,650
对于这个，有什么问题吗？

1339
01:19:46,660 --> 01:19:49,510
所以我有一个问题，

1340
01:19:49,660 --> 01:19:55,870
当你关闭一个打开的事务时，到底会发生什么，

1341
01:19:55,960 --> 01:19:57,430
它是否像快照，

1342
01:19:58,540 --> 01:20:02,560
比如当前状态缓存。

1343
01:20:02,590 --> 01:20:04,720
是的，完全正确，

1344
01:20:04,810 --> 01:20:06,490
所以，当我们关闭这个事务时，

1345
01:20:06,610 --> 01:20:08,050
至少在原则上，

1346
01:20:08,260 --> 01:20:10,780
系统会复制所有的块，

1347
01:20:10,780 --> 01:20:13,390
在这个事务中系统调用所修改的块，

1348
01:20:14,200 --> 01:20:16,750
日志系统将它们复制到缓存中，

1349
01:20:17,230 --> 01:20:21,370
这是一种仅用于事务提交它们的私有副本。

1350
01:20:22,170 --> 01:20:26,580
然后，未来的事务在实际缓存的块上执行某种操作，

1351
01:20:26,700 --> 01:20:30,780
这个事务从其修改的块的私有副本进行提交。

1352
01:20:31,690 --> 01:20:35,410
然后，当它完成提交这些私有数据块复制到磁盘后，

1353
01:20:35,740 --> 01:20:37,420
可以把那些复制扔掉。

1354
01:20:43,150 --> 01:20:43,840
是的。

1355
01:20:46,610 --> 01:20:47,690
好的。

1356
01:20:48,690 --> 01:20:50,880
这个，这是

1357
01:20:50,880 --> 01:20:57,140
大约六个或十几个类似的小的怪事之一，

1358
01:20:57,140 --> 01:20:59,420
ext3 必须解决，

1359
01:20:59,420 --> 01:21:02,450
因为为了支持并发，

1360
01:21:02,540 --> 01:21:07,040
有一大堆类似的排序的琐事，

1361
01:21:07,040 --> 01:21:11,030
这是 ext3 必须正确处理的特殊情况，

1362
01:21:13,370 --> 01:21:15,380
我们没时间讨论这个，

1363
01:21:15,440 --> 01:21:16,850
但是要点，

1364
01:21:16,850 --> 01:21:20,120
我想人们记住的关于日志 ext3 的，

1365
01:21:20,600 --> 01:21:22,610
首先，一般的观点，

1366
01:21:22,940 --> 01:21:27,860
日志是关于使多步磁盘更新成为原子的，

1367
01:21:27,860 --> 01:21:30,080
对于崩溃，全部发生或全部没有，

1368
01:21:30,080 --> 01:21:33,110
这是关于日志最需要记住的一件事，

1369
01:21:34,070 --> 01:21:37,760
日志的正确性取决于预写规则。

1370
01:21:37,850 --> 01:21:39,920
另一件需要记住的重要事情是，

1371
01:21:39,950 --> 01:21:43,430
你会经常听到预写日志和预写规则，

1372
01:21:43,430 --> 01:21:45,980
在崩溃恢复业务中。

1373
01:21:46,450 --> 01:21:48,040
预写规则规定

1374
01:21:48,040 --> 01:21:51,010
你必须提交对日志的所有更改，

1375
01:21:51,040 --> 01:21:55,480
在允许对主位置进行任何修改之前，

1376
01:21:55,690 --> 01:21:56,830
在文件系统中。

1377
01:21:58,780 --> 01:22:01,330
而且恢复也依赖于这条规则，

1378
01:22:01,930 --> 01:22:03,730
很多要点，

1379
01:22:03,730 --> 01:22:05,830
至少对于文件系统，

1380
01:22:05,830 --> 01:22:09,130
日志的要点是简单快速恢复，

1381
01:22:09,790 --> 01:22:11,650
日志中可能有几百个块，

1382
01:22:11,770 --> 01:22:15,490
你可以在不到一秒的时间里重放几百个块，

1383
01:22:15,760 --> 01:22:18,160
然后启动你的文件系统，

1384
01:22:18,220 --> 01:22:21,220
即使是一个非常大的，现在也可以使用了。

1385
01:22:21,880 --> 01:22:25,060
现在，最后关于 ext3 的更详细的一点是，

1386
01:22:25,060 --> 01:22:26,920
它使用批处理和并发

1387
01:22:26,920 --> 01:22:32,020
来获得比 xv6 好得多的性能，

1388
01:22:32,020 --> 01:22:37,330
尽管在很高的复杂性的情况下，

1389
01:22:37,830 --> 01:22:40,380
为了支持比 xv6 更高的并发。

1390
01:22:42,910 --> 01:22:43,990
今天就到这里，

1391
01:22:44,080 --> 01:22:46,450
我很高兴回答大家的问题。

1392
01:22:49,560 --> 01:22:53,850
嗯，嗨，我还有一个问题是关于，

1393
01:22:54,060 --> 01:22:55,110
所以你说，

1394
01:22:55,260 --> 01:22:59,370
靠着有一个文件系统调用，

1395
01:22:59,370 --> 01:23:02,220
文件系统线程来做所有这些事情，

1396
01:23:02,720 --> 01:23:06,290
这些线程中必须只有一个，

1397
01:23:06,290 --> 01:23:11,960
否则它可以完成刚才所说的事情。

1398
01:23:15,400 --> 01:23:17,320
可能确实只有一个，

1399
01:23:17,650 --> 01:23:19,540
我其实不知道有多少个，

1400
01:23:19,720 --> 01:23:22,750
一当然是一个特别有吸引力的数字，

1401
01:23:22,780 --> 01:23:27,820
因为日志是正确的很多基本原理是，

1402
01:23:27,820 --> 01:23:34,040
较旧的事务在较新的事务之前提交，

1403
01:23:34,400 --> 01:23:40,470
我不认为这是只有一个线程的合乎逻辑的必然性，

1404
01:23:40,470 --> 01:23:47,500
你可以想象，旧的事务以重叠的方式提交，

1405
01:23:48,080 --> 01:23:53,200
本质上是使用多个线程，每个事务一个线程。

1406
01:23:54,410 --> 01:23:55,640
好的，我明白了。

1407
01:23:57,450 --> 01:23:58,350
好的，我知道了。

1408
01:23:59,540 --> 01:24:00,410
我有个问题，

1409
01:24:00,470 --> 01:24:03,260
当你谈论崩溃的时候，

1410
01:24:03,260 --> 01:24:07,130
你有一张 t8 重写 t5 的图，

1411
01:24:08,130 --> 01:24:09,330
它正在被释放，

1412
01:24:10,520 --> 01:24:17,480
那么，如果 t8 在崩溃时没有真正被提交，会发生什么，

1413
01:24:17,780 --> 01:24:21,170
因为可能 t5 ，

1414
01:24:21,170 --> 01:24:25,010
如果它因为需要重写而被释放的话，

1415
01:24:25,340 --> 01:24:28,790
那么可能存在来自 t5 的提交块，

1416
01:24:30,690 --> 01:24:34,290
它可能是 t8 预测它存在的位置，

1417
01:24:34,950 --> 01:24:37,500
那么这是不是能准确地表示

1418
01:24:37,500 --> 01:24:39,660
t8 已经被提交了吗？

1419
01:24:40,050 --> 01:24:43,110
好的，让我试着画出出这个场景，

1420
01:24:44,370 --> 01:24:51,940
所以我们有这个古老的事务 t5 ，

1421
01:24:52,990 --> 01:24:56,230
也许这里是 t6 ，

1422
01:24:56,230 --> 01:24:59,230
然后绕回来是 t8 ，

1423
01:24:59,860 --> 01:25:01,870
t8 现在开始在某个地方，

1424
01:25:01,870 --> 01:25:04,600
因为 t5 是空闲的，

1425
01:25:04,600 --> 01:25:07,300
t8 开始增长，

1426
01:25:10,960 --> 01:25:12,490
t5 是，

1427
01:25:13,090 --> 01:25:16,360
t8 的末尾超过 t5 的开始。

1428
01:25:17,330 --> 01:25:19,490
好的，令人担忧的是，

1429
01:25:19,490 --> 01:25:20,990
好的，当然如果 t8 提交了，

1430
01:25:20,990 --> 01:25:22,340
然后它将以提交块结束，

1431
01:25:22,340 --> 01:25:24,770
而且看起来都很合理，

1432
01:25:25,790 --> 01:25:27,080
如果恢复出现崩溃，

1433
01:25:27,260 --> 01:25:30,110
而担心的情况是 t8 没有提交。

1434
01:25:33,590 --> 01:25:33,980
是的。

1435
01:25:33,980 --> 01:25:35,930
是的，好的，

1436
01:25:35,930 --> 01:25:38,210
所以，[]确实如此，

1437
01:25:38,210 --> 01:25:43,840
所以 t8 碰巧会把它的提交块放在

1438
01:25:43,840 --> 01:25:46,780
和 t5 放提交块完全相同的地方，

1439
01:25:46,810 --> 01:25:48,610
但是它没有写入提交块，

1440
01:25:48,610 --> 01:25:50,020
所有都是好的，除了，

1441
01:25:50,350 --> 01:25:53,050
我们有一个完全正确的 t8 ，

1442
01:25:53,050 --> 01:25:54,730
但它是 t5 的提交块。

1443
01:25:55,160 --> 01:25:55,880
嗯。

1444
01:25:56,590 --> 01:25:57,280
你在想，

1445
01:25:57,280 --> 01:25:58,960
天哪，看起来像一个提交块，

1446
01:25:59,230 --> 01:26:00,730
好的，答案是

1447
01:26:00,730 --> 01:26:03,440
描述符块和提交块

1448
01:26:03,440 --> 01:26:06,800
以及其他所有内容都具有事务的序列号，

1449
01:26:06,800 --> 01:26:09,650
所以这个描述符块有一个 8 ，

1450
01:26:10,900 --> 01:26:15,110
但是 t5 的提交描述符，

1451
01:26:15,110 --> 01:26:17,300
但是 t5 提交块中有一个 5 。

1452
01:26:18,070 --> 01:26:19,450
好的，好的。

1453
01:26:19,450 --> 01:26:22,510
是的，它查看 8 像魔术数一样。

1454
01:26:22,660 --> 01:26:23,290
好问题。

1455
01:26:25,440 --> 01:26:27,060
等等，但在这种情况下，

1456
01:26:27,060 --> 01:26:30,420
你也有 t5 的描述符块，

1457
01:26:30,420 --> 01:26:33,210
所以你并不需要这些数字。

1458
01:26:35,290 --> 01:26:37,150
嗯，在这个特殊的案例中，

1459
01:26:37,150 --> 01:26:42,250
t5 过去有一个描述符块，里面有一个 5 ，

1460
01:26:42,280 --> 01:26:44,890
然而， t8 太大，

1461
01:26:44,890 --> 01:26:47,830
t8 重写了描述符块，

1462
01:26:47,830 --> 01:26:50,320
使用它自己的数据块。

1463
01:26:51,140 --> 01:26:54,020
所以 t5 描述符块就没了，

1464
01:26:54,020 --> 01:26:56,420
取而代之的是 t8 的块。

1465
01:26:57,180 --> 01:26:59,730
所以，是的，曾经是事务 5 ，

1466
01:26:59,730 --> 01:27:01,200
但现在它不见了。

1467
01:27:05,100 --> 01:27:09,060
那么，在我们开始之前，我们知道事务 8 的大小吗？

1468
01:27:14,800 --> 01:27:17,350
嗯。

1469
01:27:21,800 --> 01:27:23,180
抱歉，这是个复杂的问题，

1470
01:27:24,230 --> 01:27:27,960
很可能是，

1471
01:27:31,160 --> 01:27:35,560
好的，当 t8 作为活动事务打开时，

1472
01:27:35,560 --> 01:27:37,150
系统调用正在写入，

1473
01:27:37,180 --> 01:27:38,380
在那个时间点上，

1474
01:27:38,380 --> 01:27:41,020
系统不知道 t8 会有多大，

1475
01:27:41,660 --> 01:27:45,020
当系统开始提交 t8 时，

1476
01:27:45,350 --> 01:27:50,890
它确实知道 t8 是多少，

1477
01:27:51,010 --> 01:27:53,290
系统没有开始提交 t8 ，

1478
01:27:53,320 --> 01:27:55,060
在 t8 关闭之后，

1479
01:27:55,060 --> 01:27:56,830
它的所有系统调用都已完成。

1480
01:27:57,880 --> 01:27:59,590
在这一点上，系统知道，

1481
01:27:59,590 --> 01:28:01,570
我的意思是，所有的写入都已完成，

1482
01:28:01,720 --> 01:28:03,610
t8 的所有写入都已完成，

1483
01:28:03,610 --> 01:28:04,690
所有的系统调用都已完成，

1484
01:28:04,690 --> 01:28:06,940
所以系统知道它有多大。

1485
01:28:08,290 --> 01:28:10,030
必须这样做的一个原因是，

1486
01:28:10,150 --> 01:28:15,010
描述符块持有该事务中的完整块列表，

1487
01:28:15,100 --> 01:28:16,780
所以在描述符块写入的时候，

1488
01:28:16,780 --> 01:28:19,570
这是第一次，日志系统知道

1489
01:28:19,570 --> 01:28:22,210
我们将在 t8 中有多少个块。

1490
01:28:24,550 --> 01:28:25,270
是的。

1491
01:28:25,610 --> 01:28:26,900
哦，好的，我知道了，

1492
01:28:27,440 --> 01:28:28,130
谢谢。

1493
01:28:30,260 --> 01:28:32,480
为什么我们不

1494
01:28:32,480 --> 01:28:37,280
把提交信息放到描述符块中来避免这类问题，

1495
01:28:37,640 --> 01:28:39,500
我知道这不太好，

1496
01:28:39,500 --> 01:28:40,670
我们必须回去，

1497
01:28:40,670 --> 01:28:44,890
比如不是按顺序写入的，

1498
01:28:44,890 --> 01:28:46,390
但那会不会有帮助？

1499
01:28:46,660 --> 01:28:48,250
好的，所以建议是，

1500
01:28:48,310 --> 01:28:49,990
与其有一个提交块，

1501
01:28:51,240 --> 01:28:54,360
我们让描述符块当作提交块，

1502
01:28:54,720 --> 01:28:57,630
而且 xv6 与此非常相似。

1503
01:29:00,470 --> 01:29:02,810
你知道你能这样做，

1504
01:29:03,470 --> 01:29:06,710
事实上，我认为你能这样做，

1505
01:29:06,710 --> 01:29:11,360
至少 ext3 不降低效率，

1506
01:29:11,390 --> 01:29:13,280
然而，你必须同样，

1507
01:29:13,280 --> 01:29:16,340
你必须以与 xv6 相同的方式构建它，

1508
01:29:16,340 --> 01:29:20,320
也就是说，

1509
01:29:20,350 --> 01:29:21,490
如果有一个，

1510
01:29:21,730 --> 01:29:23,590
你必须在描述符块中有一些东西，

1511
01:29:23,590 --> 01:29:25,930
表明这是一个提交事务，

1512
01:29:26,410 --> 01:29:29,590
我们不允许设置任何标志，

1513
01:29:29,740 --> 01:29:32,560
在所有数据块写入之前，

1514
01:29:32,770 --> 01:29:34,270
所以顺序是，

1515
01:29:34,330 --> 01:29:36,610
我们不先写提交挡路，

1516
01:29:36,790 --> 01:29:39,820
相反，我们首先写入事务 8 的所有数据块，

1517
01:29:39,970 --> 01:29:44,270
然后我们回去写下提交块和块编号，

1518
01:29:44,810 --> 01:29:47,360
这个描述符块，不管它现在是什么，

1519
01:29:47,390 --> 01:29:52,490
还有某种魔力，这是一个提交的事务。

1520
01:29:52,850 --> 01:29:54,290
所以我们可以写入所有数据块，

1521
01:29:54,290 --> 01:29:56,210
然后返回并写入提交块，

1522
01:29:56,360 --> 01:30:00,090
这个描述符提交块，不管是什么，

1523
01:30:00,150 --> 01:30:01,650
我不知道，

1524
01:30:03,120 --> 01:30:05,580
我不知道为什么这个不能工作。

1525
01:30:07,670 --> 01:30:09,200
我不认为它，

1526
01:30:11,300 --> 01:30:11,900
它没有，

1527
01:30:11,930 --> 01:30:15,500
我认为它没有真正消除我们讨论过的任何问题，

1528
01:30:15,500 --> 01:30:17,330
因为我们还有这个问题，

1529
01:30:17,870 --> 01:30:19,160
最初的问题是，

1530
01:30:19,160 --> 01:30:21,890
天哪，我们如何区分这个提交块，

1531
01:30:21,890 --> 01:30:24,740
这个来自事务 5 的旧提交块，

1532
01:30:24,740 --> 01:30:26,900
来自事务 8 的真实提交块，

1533
01:30:26,930 --> 01:30:28,460
我们在这里也会遇到同样的问题，

1534
01:30:28,790 --> 01:30:31,490
这可能是在这里的东西，

1535
01:30:31,820 --> 01:30:35,960
恰好是事务 5 中的描述符块。

1536
01:30:36,500 --> 01:30:37,910
所以，也许我们继续，

1537
01:30:37,910 --> 01:30:39,710
写入事务的所有数据块，

1538
01:30:39,710 --> 01:30:40,820
然后发生了崩溃，

1539
01:30:40,940 --> 01:30:44,540
恢复软件仍然需要能够区分，

1540
01:30:45,500 --> 01:30:47,240
查看这个描述符块，

1541
01:30:47,240 --> 01:30:48,020
然后等一下，

1542
01:30:49,190 --> 01:30:50,420
这里有些不对劲，

1543
01:30:50,750 --> 01:30:53,090
尽管这看起来是一个有效的描述符块，

1544
01:30:53,090 --> 01:30:53,840
但实际上并非如此。

1545
01:30:54,550 --> 01:30:57,040
所以我们仍然需要魔术数，

1546
01:30:57,040 --> 01:30:59,950
事务号，序列号。

1547
01:31:01,310 --> 01:31:02,840
哦，是的，理解了，

1548
01:31:02,840 --> 01:31:03,740
是的，我只是在想，

1549
01:31:03,740 --> 01:31:04,820
比如我们应该有，

1550
01:31:04,850 --> 01:31:07,730
我们提交描述符块的一部分，

1551
01:31:07,730 --> 01:31:09,380
但很明显，当我们开始 t8 时，

1552
01:31:09,710 --> 01:31:12,080
我们写入描述符块，它是未提交的，

1553
01:31:12,080 --> 01:31:13,250
然后我们写入数据块，

1554
01:31:13,250 --> 01:31:16,520
那么我们现在就说它是一个提交块。

1555
01:31:16,730 --> 01:31:18,770
这里可以节省的是

1556
01:31:18,770 --> 01:31:21,320
等待这些写入的花费，

1557
01:31:21,320 --> 01:31:23,780
然后写入一个提交块，

1558
01:31:23,780 --> 01:31:25,430
等待的花费很高，

1559
01:31:25,430 --> 01:31:27,200
我们不允许开始写入提交块，

1560
01:31:27,200 --> 01:31:29,750
直到数据块位于磁盘上，

1561
01:31:29,960 --> 01:31:32,930
我不认为，

1562
01:31:33,500 --> 01:31:36,230
我们必须有相同的等待，

1563
01:31:36,230 --> 01:31:38,390
在新的单个块方案中，

1564
01:31:38,570 --> 01:31:40,730
我们必须有相同的等待，

1565
01:31:40,790 --> 01:31:43,190
在我们写入这个新的描述符块之前，

1566
01:31:43,370 --> 01:31:44,600
所以它省了一个块，

1567
01:31:44,630 --> 01:31:47,240
但是我不认为它省了时间。

1568
01:31:47,840 --> 01:31:50,330
技巧，

1569
01:31:50,920 --> 01:31:54,460
更高版本的 Linux 文件系统的技巧，

1570
01:31:54,760 --> 01:31:57,130
确实达到了你想要的效果。

1571
01:31:59,000 --> 01:32:00,470
你知道，

1572
01:32:01,100 --> 01:32:05,360
查看 ext4 完成了以下（操作）

1573
01:32:05,420 --> 01:32:07,700
用来更高效地写入提交块。

1574
01:32:09,840 --> 01:32:17,670
ext4 同时写入所有数据块和提交块，

1575
01:32:18,370 --> 01:32:20,470
也就是说，它不等待，

1576
01:32:21,060 --> 01:32:23,730
数据块写入完成，在写入提交块之前，

1577
01:32:23,760 --> 01:32:25,290
所以它不会有这么长的暂停时间，

1578
01:32:25,440 --> 01:32:28,350
但是有一个严重的问题，

1579
01:32:28,350 --> 01:32:29,550
如果磁盘，

1580
01:32:29,610 --> 01:32:31,710
磁盘盘可以自由地进行无序写入，

1581
01:32:32,070 --> 01:32:35,430
如果磁盘首先写入提交块，

1582
01:32:35,430 --> 01:32:38,280
在它执行数据块写入之前，

1583
01:32:38,280 --> 01:32:39,120
然后发生崩溃，

1584
01:32:39,120 --> 01:32:40,200
然后我们有一个提交块，

1585
01:32:40,320 --> 01:32:42,900
而没有写入的数据块，

1586
01:32:43,170 --> 01:32:45,330
而 ext4 解决这个问题的方式，

1587
01:32:48,050 --> 01:32:52,740
它在提交块中有一个校验和，

1588
01:32:53,130 --> 01:32:55,470
对所有数据块进行校验和。

1589
01:32:57,300 --> 01:33:00,960
所以，如果在写入提交块后发生崩溃，

1590
01:33:00,960 --> 01:33:02,280
在写入数据块之前，

1591
01:33:02,280 --> 01:33:03,720
校验和将不起作用。

1592
01:33:04,380 --> 01:33:06,000
恢复软件查看校验和，

1593
01:33:06,000 --> 01:33:09,700
然后它计算日志中数据块的校验和，

1594
01:33:09,700 --> 01:33:10,480
如果它们不相同，

1595
01:33:10,480 --> 01:33:12,040
它就知道出了问题。

1596
01:33:12,630 --> 01:33:14,040
所以，通过这样做，

1597
01:33:14,640 --> 01:33:19,380
ext4 在机械硬盘上，节省了一个旋转，

1598
01:33:21,010 --> 01:33:21,970
它会发生，

1599
01:33:21,970 --> 01:33:25,180
如果必须在提交之前等待数据块。

1600
01:33:27,820 --> 01:33:28,720
好的，谢谢。

1601
01:33:34,800 --> 01:33:36,300
哦，太酷了。

1602
01:33:38,980 --> 01:33:40,450
我喜欢这些东西。

1603
01:33:41,900 --> 01:33:44,300
这太酷了，

1604
01:33:44,450 --> 01:33:46,850
我还想问一下数据块，

1605
01:33:46,850 --> 01:33:49,010
只是内容块。

1606
01:33:49,310 --> 01:33:50,870
所以我想疑问的，

1607
01:33:50,870 --> 01:33:54,140
但是在我们讨论的步骤中，

1608
01:33:54,720 --> 01:33:57,270
在你之前的一块板上，

1609
01:33:57,300 --> 01:33:59,700
那个是在哪里做的？

1610
01:34:01,020 --> 01:34:01,860
在哪里哪个做呢？

1611
01:34:02,340 --> 01:34:07,560
所以，不是元数据块，而是实际的。

1612
01:34:07,560 --> 01:34:08,550
文件内容，

1613
01:34:14,790 --> 01:34:22,000
在 ext3 中有多种模式，

1614
01:34:23,380 --> 01:34:26,680
对于数据块发生的情况，

1615
01:34:26,680 --> 01:34:31,220
我记得有两三个，

1616
01:34:31,840 --> 01:34:39,820
有日志数据和顺序数据，

1617
01:34:40,030 --> 01:34:42,730
当你配置 ext3 文件系统时，

1618
01:34:42,730 --> 01:34:44,770
你告诉 Linux 你想要什么，

1619
01:34:47,240 --> 01:34:50,540
如果你要求日志数据，

1620
01:34:50,630 --> 01:34:52,700
文件内容只是直接写入日志，

1621
01:34:52,700 --> 01:34:53,900
没有什么特别的，

1622
01:34:53,900 --> 01:34:55,880
如果你将数据写入文件，

1623
01:34:56,330 --> 01:34:58,460
引起 inode 更新，

1624
01:34:58,610 --> 01:35:01,490
然后日志将包含你的数据，

1625
01:35:01,490 --> 01:35:03,320
并更新 inode ，

1626
01:35:04,820 --> 01:35:07,310
所有被修改的东西都会记入日志，

1627
01:35:07,760 --> 01:35:09,770
那就是日志数据。

1628
01:35:09,770 --> 01:35:11,030
当然，它很慢，

1629
01:35:11,060 --> 01:35:12,290
或者比你想象的要慢，

1630
01:35:12,290 --> 01:35:15,860
因为，

1631
01:35:16,530 --> 01:35:18,600
如果你写一整串数据，

1632
01:35:18,690 --> 01:35:20,160
它必须写一次到日志，

1633
01:35:20,160 --> 01:35:21,930
然后第二次到原位置，

1634
01:35:21,930 --> 01:35:26,910
所以，日志数据方案简单明了，但速度很慢。

1635
01:35:29,320 --> 01:35:31,090
然后，还有另一种顺序数据方案，

1636
01:35:31,870 --> 01:35:34,540
那就是人们最流行的模式，

1637
01:35:35,970 --> 01:35:38,910
避免，不将数据写入日志，

1638
01:35:39,440 --> 01:35:40,550
在顺序数据方案中，

1639
01:35:40,580 --> 01:35:44,870
只有像 inode 和目录块这样的元数据才会写入日志，

1640
01:35:45,050 --> 01:35:50,120
而文件内容块直接写入文件系统中的原位置，

1641
01:35:51,320 --> 01:35:52,640
所以它的速度要快得多，

1642
01:35:52,640 --> 01:35:55,690
因为你不必写入文件内容两次，

1643
01:35:56,440 --> 01:35:58,000
这确实会导致更复杂的情况，

1644
01:35:58,000 --> 01:36:03,150
因为如果，

1645
01:36:03,150 --> 01:36:06,450
你不能随时写文件数据，

1646
01:36:06,630 --> 01:36:08,610
因为这样会有风险，

1647
01:36:10,360 --> 01:36:13,210
如果你不担心你写 inode 的顺序，

1648
01:36:13,210 --> 01:36:15,160
文件数据存在这样的风险，

1649
01:36:15,160 --> 01:36:18,160
你可能执行写入操作，

1650
01:36:18,160 --> 01:36:21,790
导致为文件分配新的块，

1651
01:36:22,030 --> 01:36:26,920
并将更新后的 inode 写入日志并提交，

1652
01:36:26,980 --> 01:36:28,450
然后发生崩溃，

1653
01:36:28,450 --> 01:36:32,500
在你写入实际文件内容到磁盘之前，

1654
01:36:32,710 --> 01:36:34,030
然后在恢复之后，

1655
01:36:34,510 --> 01:36:35,830
你将看到的是，

1656
01:36:35,860 --> 01:36:39,040
包含新分配的数据块的 inode ，

1657
01:36:39,340 --> 01:36:42,100
但是数据块的旧内容

1658
01:36:42,100 --> 01:36:45,340
来自之前使用该数据块的文件，

1659
01:36:45,890 --> 01:36:50,450
所以，如果你运行的系统有多个用户，比如 Athena ，

1660
01:36:50,660 --> 01:36:53,480
可能是一个用户最终

1661
01:36:53,480 --> 01:36:57,740
拥有的文件包含另一个用户已删除文件的内容。

1662
01:36:58,650 --> 01:37:00,150
如果我们不注意顺序，

1663
01:37:00,150 --> 01:37:04,350
写入数据与 inode 的顺序。

1664
01:37:06,550 --> 01:37:09,310
ext3 顺序数据模式解决这个，

1665
01:37:09,460 --> 01:37:14,050
通过不提交修改的 inode ，

1666
01:37:14,050 --> 01:37:17,800
直到文件内容写入磁盘之后，

1667
01:37:18,040 --> 01:37:20,170
所以，如果你的应用程序写入文件，

1668
01:37:20,710 --> 01:37:23,380
那个写入导致分配新的块，

1669
01:37:23,800 --> 01:37:28,900
文件系统将新文件内容写入新分配的块，

1670
01:37:29,080 --> 01:37:30,520
一旦写入完成，

1671
01:37:30,550 --> 01:37:33,340
它才会提交事务。

1672
01:37:34,860 --> 01:37:38,670
这导致 inode 更新为包含新的块编号，

1673
01:37:38,730 --> 01:37:41,130
这意味着，崩溃，

1674
01:37:41,250 --> 01:37:42,780
如果崩溃发生在，

1675
01:37:42,780 --> 01:37:44,220
写入数据时，

1676
01:37:44,340 --> 01:37:46,650
写入数据之后和写入 inode 之前，

1677
01:37:46,710 --> 01:37:51,630
不会显示别人删除的旧数据块

1678
01:37:52,060 --> 01:37:53,590
给新用户文件。

1679
01:37:56,790 --> 01:37:57,720
好的，我明白了。

1680
01:37:58,630 --> 01:37:59,410
好的，我明白了，

1681
01:37:59,410 --> 01:38:02,500
但是它仍然可以有数据，而没有 inode 。

1682
01:38:03,310 --> 01:38:04,510
是的，你可能分配。

1683
01:38:04,510 --> 01:38:06,970
是的，如果发生崩溃，

1684
01:38:06,970 --> 01:38:09,850
在你写入数据块之后，写入 inode 之前，

1685
01:38:09,850 --> 01:38:12,160
那么你已经更新了数据块，

1686
01:38:12,160 --> 01:38:13,060
但这并不重要，

1687
01:38:13,060 --> 01:38:15,430
因为你不仅没有写 inode ，

1688
01:38:15,430 --> 01:38:20,870
你也没有写更新块，空闲位图块，

1689
01:38:21,290 --> 01:38:24,170
块是空闲的，并且可以分配给其他东西，

1690
01:38:24,200 --> 01:38:25,460
所以一个块都不会丢。

1691
01:38:26,730 --> 01:38:29,010
好的，如果是老块，

1692
01:38:29,010 --> 01:38:31,620
那还是可以的，对吧。

1693
01:38:32,100 --> 01:38:32,490
再说一遍。

1694
01:38:32,910 --> 01:38:33,810
如果只是，

1695
01:38:34,360 --> 01:38:37,900
它是一样的块，写入新的数据，

1696
01:38:37,930 --> 01:38:43,530
但是一样的块，一样的大小，一样的位置，

1697
01:38:44,900 --> 01:38:46,520
但是我们已经写入，

1698
01:38:46,520 --> 01:38:48,770
比如不是我们创建一个新的块，

1699
01:38:48,770 --> 01:38:53,180
而是在旧的块，我们写入一些额外的数据，

1700
01:38:53,180 --> 01:38:54,380
但它有一点，

1701
01:38:54,380 --> 01:38:56,180
所以它不需要创造一个新的。

1702
01:38:57,220 --> 01:38:58,300
是的，我们写入数据，

1703
01:38:58,300 --> 01:39:01,240
我们最终将数据写入块中，

1704
01:39:01,240 --> 01:39:02,920
它没有被任何文件使用，

1705
01:39:03,830 --> 01:39:05,480
它是不可见的。

1706
01:39:06,020 --> 01:39:07,340
好的，我明白了，

1707
01:39:07,340 --> 01:39:09,870
谢谢。再见。

