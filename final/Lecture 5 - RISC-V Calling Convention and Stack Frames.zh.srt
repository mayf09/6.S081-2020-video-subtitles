1
00:00:00,810 --> 00:00:02,640
好的。

2
00:00:05,770 --> 00:00:07,960
嘿，大家能听到我说话吗？

3
00:00:07,960 --> 00:00:10,210
很好，能听到。

4
00:00:11,020 --> 00:00:15,070
好的，我想像上周一样开始，

5
00:00:15,070 --> 00:00:18,400
上周，我们问了一些 util 实验的问题，

6
00:00:18,400 --> 00:00:20,920
我想先问一下 syscall 实验的情况，

7
00:00:20,920 --> 00:00:23,890
因为那是周四到期的。

8
00:00:24,520 --> 00:00:29,200
所以如果有人在实验中发现什么特别有趣的东西

9
00:00:29,200 --> 00:00:31,030
或者发现一个难缠的 bug ，

10
00:00:31,030 --> 00:00:32,920
或者只是犯了一个愚蠢的错误，

11
00:00:32,920 --> 00:00:36,410
关于 syscall 实验，任何你想分享的都可以。

12
00:00:38,450 --> 00:00:45,470
不知道什么原因，我删除了 fork 中需要通过 mask 复制的部分，

13
00:00:45,470 --> 00:00:49,490
我让它工作，然后我修改了其他东西，然后我测试它，

14
00:00:50,200 --> 00:00:51,880
你好像掉线了。

15
00:00:51,880 --> 00:00:54,660
哦，抱歉，你能听到我说话吗？

16
00:00:58,060 --> 00:00:58,750
我听到了。

17
00:00:59,380 --> 00:01:00,280
好的。

18
00:01:00,820 --> 00:01:03,250
我想是的。

19
00:01:03,680 --> 00:01:07,490
基本上我以某种方式删除了 mask 的复制，

20
00:01:07,490 --> 00:01:10,910
然后我的 fork 就不能用了，

21
00:01:11,120 --> 00:01:14,000
所以我想，之前还是好的，现在怎么不能用了，

22
00:01:14,240 --> 00:01:17,580
我花了很多时间去找问题。

23
00:01:17,610 --> 00:01:20,400
我意识到我把那行删除了。

24
00:01:22,820 --> 00:01:25,640
有没有人听不到 Luca ，还是只有我这边。

25
00:01:26,290 --> 00:01:27,370
我想只是你那边。

26
00:01:28,000 --> 00:01:28,900
是的，我这边是好的。

27
00:01:32,290 --> 00:01:33,610
那一定是我这边的问题。

28
00:01:56,320 --> 00:01:57,970
抱歉，现在应该好了。

29
00:02:02,760 --> 00:02:06,330
现在能听到我说话吗？好的。

30
00:02:06,330 --> 00:02:08,550
我还担心我这边。

31
00:02:08,550 --> 00:02:11,130
不，好像是我这边的问题。

32
00:02:11,400 --> 00:02:12,000
好的。

33
00:02:16,870 --> 00:02:21,850
好的，还有人想分享关于 syscall 的任何事情吗？

34
00:02:24,190 --> 00:02:25,990
有什么特别有趣的，

35
00:02:25,990 --> 00:02:28,690
或者实验太难了，

36
00:02:28,690 --> 00:02:32,110
你觉得我们应该把它从课程中删掉，再也不做了。

37
00:02:33,430 --> 00:02:40,480
我有一些东西，概括来说，事情的顺序很重要，

38
00:02:40,780 --> 00:02:48,460
我试着理解 syscall 函数内的代码，

39
00:02:48,980 --> 00:02:52,400
在理解之前，我需要先做 tracing 。

40
00:02:53,100 --> 00:02:59,220
所有系统调用都能正确跟踪，除了 trace call 。

41
00:02:59,560 --> 00:03:02,500
这件事让我心烦意乱，

42
00:03:02,500 --> 00:03:04,480
直到 David 指出，

43
00:03:04,480 --> 00:03:10,040
你知道，应该在 trace 之后进行计算。

44
00:03:10,790 --> 00:03:14,770
好的，很高兴你能找到这一点。

45
00:03:15,220 --> 00:03:17,050
是的，顺序确实很重要，

46
00:03:17,080 --> 00:03:22,120
特别是对页表来说，你们会发现，顺序在那里也很重要，

47
00:03:22,120 --> 00:03:26,220
而且贯穿整个课程，注意事物的顺序很重要。

48
00:03:28,140 --> 00:03:30,360
最好不要覆盖页表中的内容。

49
00:03:31,630 --> 00:03:35,970
我也有一些东西，事实上我现在仍然对此感到困惑。

50
00:03:36,120 --> 00:03:42,000
我在调试内核代码时用了很多 print 语句。

51
00:03:42,870 --> 00:03:47,520
然后我把所有的位都设置好，运行 trace ，

52
00:03:47,610 --> 00:03:50,850
基本上跟踪了所有的系统调用。

53
00:03:51,520 --> 00:03:59,860
我看到了内核中很多 print 语句的跟踪，然后。

54
00:04:00,410 --> 00:04:09,110
然后我假设我的 print 程序读取和写入控制台，

55
00:04:09,140 --> 00:04:11,030
确实会写入控制台，

56
00:04:11,030 --> 00:04:14,840
但我想知道是为什么。

57
00:04:15,110 --> 00:04:19,190
我想，我困惑的是，为什么可以在内核中使用 printf 。

58
00:04:22,670 --> 00:04:26,840
我最近没有看过 printf 的代码，

59
00:04:26,840 --> 00:04:29,860
但是我想有一个 printf.c 文件，

60
00:04:29,860 --> 00:04:31,630
你可以自己看一下。

61
00:04:32,160 --> 00:04:35,990
嗯，这里发生了什么，

62
00:04:35,990 --> 00:04:38,270
我认为 printf 函数是在那里实现的。

63
00:04:41,120 --> 00:04:42,320
至少我们的版本是这样的，

64
00:04:42,530 --> 00:04:48,120
我不知道，或许其他工作人员可能知道是怎么回事。

65
00:04:49,270 --> 00:04:53,530
在跟踪的时候，内核中的 printf 不应该出现，

66
00:04:53,530 --> 00:04:56,530
因为内核中的 printf 不做任何系统调用。

67
00:04:58,000 --> 00:04:59,890
是的，我也是这么想的，

68
00:04:59,890 --> 00:05:03,700
也许 tracing 不是从那里来的。

69
00:05:04,680 --> 00:05:07,080
是的，我不认为它来自内核中的 printf 。

70
00:05:08,240 --> 00:05:08,960
好的。

71
00:05:12,370 --> 00:05:18,490
好的，除非还有人对 syscall 有别的评论，

72
00:05:18,490 --> 00:05:22,810
我想我们可以开始今天的讲座了。

73
00:05:23,290 --> 00:05:32,710
我将谈谈 C 语言转换为汇编语言的过程和处理器，

74
00:05:32,710 --> 00:05:35,380
今天更多是一个实用的讲座，

75
00:05:35,380 --> 00:05:36,640
至少这是我们的目标。

76
00:05:36,640 --> 00:05:43,550
我们的目标是让你们熟悉 RISC-V ，

77
00:05:43,550 --> 00:05:49,340
熟悉它的处理器、汇编语言和调用约定。

78
00:05:49,340 --> 00:05:50,600
这是非常重要的，

79
00:05:50,600 --> 00:05:53,390
虽然对页表来说不是特别重要，

80
00:05:53,390 --> 00:05:58,100
但是对于这周布置的的 traps 实验来说是这样的。

81
00:05:58,100 --> 00:06:01,970
对于调试和实现都是必不可少的，

82
00:06:01,970 --> 00:06:07,160
因为你将直接使用 trap frame 和堆栈之类的东西，

83
00:06:07,490 --> 00:06:09,530
所以这就是今天的目标。

84
00:06:09,530 --> 00:06:12,860
我的第一个目标是，

85
00:06:12,950 --> 00:06:17,030
这是对 6.004 课程的一点回顾，

86
00:06:17,030 --> 00:06:21,950
或者你学过的任何其他计算机体系结构课程。

87
00:06:22,040 --> 00:06:26,240
我只想简单回顾一下，

88
00:06:26,270 --> 00:06:29,570
C 语言是如何转换成汇编语言的，

89
00:06:29,750 --> 00:06:32,420
还有一点处理器相关的知识。

90
00:06:32,420 --> 00:06:36,070
当然，在这节课的整个过程中，

91
00:06:36,070 --> 00:06:39,610
如果你有任何问题，可以随时打断我并提问。

92
00:06:41,050 --> 00:06:45,340
你知道，在 C 程序中，一般都有 main 函数。

93
00:06:45,700 --> 00:06:51,930
它们会做一些事情，也许是打印一些东西，然后退出。

94
00:06:53,680 --> 00:06:56,050
这些看起来都很好，

95
00:06:56,050 --> 00:06:59,410
但正如你们从 6.004 知道的，

96
00:06:59,410 --> 00:07:03,280
处理器实际上并不理解 C 语言，

97
00:07:03,280 --> 00:07:06,520
它们理解的是我们称为汇编的东西，

98
00:07:06,520 --> 00:07:09,880
或者更具体地说，它们理解的是汇编的二进制编码，

99
00:07:10,150 --> 00:07:13,300
这里我在照片中圈出来的

100
00:07:13,300 --> 00:07:16,420
是 SiFive 板上真正的 RISC-V 处理器。

101
00:07:16,510 --> 00:07:20,140
而且当我们说处理器是 RISC-V 时，

102
00:07:20,140 --> 00:07:23,980
意思是它可以理解 RISC-V 指令集，

103
00:07:24,220 --> 00:07:30,460
每个处理器都有关联的 ISA 或指令。

104
00:07:31,010 --> 00:07:33,800
那就是一套指令集。

105
00:07:34,890 --> 00:07:36,870
对处理器来说是可以理解的，

106
00:07:36,870 --> 00:07:41,580
每条指令都有相关的二进制编码或操作码。

107
00:07:42,480 --> 00:07:44,760
当处理器运行时，

108
00:07:44,760 --> 00:07:48,240
会看到一种特殊的编码，然后知道该怎么做。

109
00:07:48,540 --> 00:07:56,150
所以，你知道这块板上的处理器理解 RISC-V 汇编，

110
00:07:56,150 --> 00:07:58,910
汇编从 C 代码编译而来，

111
00:07:58,910 --> 00:08:03,920
所以让 C 代码真正在处理器上运行的一般过程是，

112
00:08:03,920 --> 00:08:06,950
编写 C 代码，然后编程成汇编语言，

113
00:08:06,950 --> 00:08:09,950
这之间还发生了一些链接之类的事情，

114
00:08:09,950 --> 00:08:12,650
不过我们不是一门编译器课程，

115
00:08:12,710 --> 00:08:18,120
然后汇编语言会被翻译成二进制。

116
00:08:18,120 --> 00:08:26,110
这就是我们看到的 obj 或 .o 文件。

117
00:08:26,110 --> 00:08:32,980
如果你在运行 make qemu 之后注意过实验目录中的内容，

118
00:08:32,980 --> 00:08:36,160
你会看到很多 .o 文件散落在各处，

119
00:08:36,250 --> 00:08:40,150
这些就是处理器能够理解的目标文件。

120
00:08:41,030 --> 00:08:43,070
你们也看到了 asm 文件，

121
00:08:43,100 --> 00:08:47,210
你还没有写过任何汇编代码，但是如果你回想 syscall ，

122
00:08:47,210 --> 00:08:51,980
usys.pl 文件被编译成 usys.S ，

123
00:08:52,040 --> 00:08:56,270
而 .S 文件就是汇编，

124
00:08:56,270 --> 00:08:59,570
所以你肯定已经到了一些 RISC-V 汇编

125
00:08:59,570 --> 00:09:00,980
如果你学过 6.004 ，

126
00:09:01,040 --> 00:09:04,610
我相信你也看到过很多汇编代码。

127
00:09:05,480 --> 00:09:10,100
一般来说，汇编看起来比 C 语言的结构化程度要低得多，

128
00:09:10,100 --> 00:09:14,480
你会看到一行接一行的指令，

129
00:09:14,480 --> 00:09:22,200
你会看到一些简单的东西，比如 add mult 等。

130
00:09:22,200 --> 00:09:27,420
它也没有好的控制流，没有循环语句，

131
00:09:27,450 --> 00:09:31,140
有函数，但不是 C 语言那种函数，

132
00:09:31,140 --> 00:09:35,100
我们看到的是标签，而不是真正的函数定义。

133
00:09:36,500 --> 00:09:38,990
汇编语言，是一种低级语言，

134
00:09:38,990 --> 00:09:42,080
还有很多其他语言可以编译成汇编语言，

135
00:09:42,080 --> 00:09:47,600
比如，同样的过程也适用于 C++ 。

136
00:09:47,780 --> 00:09:51,910
嗯，你知道任何一种编译语言，

137
00:09:51,910 --> 00:09:55,120
最终生成相同的汇编语言。

138
00:09:56,700 --> 00:10:01,080
这就是运行的基本过程，

139
00:10:01,080 --> 00:10:06,210
计算机真正理解我们编写的 C 代码，

140
00:10:06,420 --> 00:10:13,380
但要注意，我们指的是 RISC-V 汇编。

141
00:10:13,620 --> 00:10:16,110
在整个课程中，处理器都是 RISC-V ，

142
00:10:16,110 --> 00:10:20,550
这很重要是因为有许多不同类型的汇编，

143
00:10:20,550 --> 00:10:25,360
你可能不会自己使用 RISC-V ，

144
00:10:25,360 --> 00:10:27,670
比如你不会在上面运行 Linux ，

145
00:10:27,760 --> 00:10:36,520
相反，大多数现代计算机在 x86 上运行，或者有时候看到的 x86-64 。

146
00:10:37,720 --> 00:10:42,370
这是一个不同的 ISA ，不同的指令集，

147
00:10:42,370 --> 00:10:44,200
它看起来与 RISC-V 很像，

148
00:10:44,230 --> 00:10:48,340
但这是你经常在个人电脑上看到的。

149
00:10:51,760 --> 00:10:54,820
所以，如果你使用英特尔处理器，

150
00:10:54,820 --> 00:11:01,220
英特尔 CPU 实现了 x86 ，还有 AMD 。

151
00:11:02,090 --> 00:11:07,800
这是两者之间相对重要的区别，

152
00:11:07,800 --> 00:11:11,250
它们并不像看起来那么类似，

153
00:11:11,400 --> 00:11:17,130
这归结于一个事实， RISC-V 是我们所说的 RISC ，

154
00:11:17,130 --> 00:11:21,990
RISC-V 的 RISC 部分指的是精简指令集。

155
00:11:22,710 --> 00:11:30,660
而 x86-64 是所谓的 CISC 或复杂指令集。

156
00:11:34,570 --> 00:11:38,260
这里有几个关键的不同之处，

157
00:11:38,260 --> 00:11:42,640
其中之一就是 x86-64 中存在的指令数量，

158
00:11:42,640 --> 00:11:50,230
事实上，创建 RISC-V 的动机之一就是

159
00:11:50,230 --> 00:11:54,220
我们实际上有多少指令。

160
00:11:54,940 --> 00:12:00,760
在英特尔手册里，有三本完整的书可供参考。

161
00:12:02,150 --> 00:12:06,770
包括 ISA 和一些统计数据，

162
00:12:06,770 --> 00:12:17,560
新的指令仍然以每月三个指令的速度增加。

163
00:12:18,720 --> 00:12:24,030
自从 x86-64 发布，它最早是在七十年代发布的，

164
00:12:24,030 --> 00:12:33,130
大概有 15000 多条指令在 x86-64 中。

165
00:12:34,240 --> 00:12:37,210
而 RISC-V 则相反，

166
00:12:37,570 --> 00:12:41,170
RISC-V 的程序集可以包含在两个文档中。

167
00:12:41,170 --> 00:12:44,320
某种程度上，

168
00:12:44,410 --> 00:12:50,230
在这门课上，我们不需要你们记住 RISC-V 的每一条指令，

169
00:12:50,290 --> 00:12:52,330
但是如果你感兴趣，

170
00:12:52,330 --> 00:12:57,250
或者发现哪条指令自己不清楚，

171
00:12:57,550 --> 00:12:59,710
如果你访问课程网站，

172
00:12:59,950 --> 00:13:02,710
我们可以在 references 菜单下看到，

173
00:13:03,460 --> 00:13:10,060
在 RISC-V 下，我们提供了特权指令和非特权指令集的链接，

174
00:13:10,300 --> 00:13:16,710
这个文档给出了很多关于 ISA 的信息，

175
00:13:16,800 --> 00:13:22,800
但是注意，这个有 240 页，这个有 135 页，

176
00:13:22,800 --> 00:13:28,590
所以它比 x86 指令集小得多，

177
00:13:28,620 --> 00:13:33,060
这是 RISC-V 的优点之一，

178
00:13:33,330 --> 00:13:39,960
因此，在 RISC-V 中，我们的指令更少，

179
00:13:39,960 --> 00:13:43,730
而且指令更简单。

180
00:13:44,340 --> 00:13:47,540
所以，我的意思是，

181
00:13:48,800 --> 00:13:52,580
在 x86-64 中有许多指令，

182
00:13:52,580 --> 00:13:56,450
比如，有 add mul sub 等。

183
00:13:57,020 --> 00:14:01,190
在 x86-64 中，有很多指令不仅做一件事，

184
00:14:01,190 --> 00:14:07,430
它们会执行一些复杂的操作，然后给出结果，

185
00:14:07,430 --> 00:14:13,490
而 RISC-V 则不同，指令的范围往往较小，

186
00:14:13,490 --> 00:14:18,860
比 x86-64 用更小的周期来运行每条指令，

187
00:14:18,950 --> 00:14:23,000
这只是设计者选择的一种权衡。

188
00:14:23,270 --> 00:14:29,640
没有什么规范的理由，

189
00:14:29,640 --> 00:14:36,090
为什么精简指令集比复杂指令集好，

190
00:14:36,090 --> 00:14:40,110
它们各有其用途，

191
00:14:40,110 --> 00:14:46,650
与 x86 相比， RISC-V 还有一个很酷的地方，就是它是开源的，

192
00:14:47,740 --> 00:14:53,620
是市面上仅有的开源指令集之一，

193
00:14:53,620 --> 00:14:56,680
这意味着任何人都可以为 RISC-V 开发电路板，

194
00:14:56,860 --> 00:15:01,570
它来自加州大学伯克利分校的一个研究项目，

195
00:15:01,570 --> 00:15:03,850
这就是 RISC-V 开始的地方，

196
00:15:03,940 --> 00:15:07,810
从那时起，它得到了很多公司的支持，

197
00:15:07,960 --> 00:15:09,640
你可以在网上找到这个列表，

198
00:15:09,640 --> 00:15:14,290
确实有很多大公司对支持开放指令集感兴趣。

199
00:15:14,990 --> 00:15:19,460
事实上，最近 SiFive 开了一场发布会，

200
00:15:19,460 --> 00:15:25,110
他们是 RISC-V 处理器的首屈一指的电路板制造商，

201
00:15:25,260 --> 00:15:30,780
他们将发布一款适用于个人电脑的电路板，

202
00:15:30,780 --> 00:15:35,580
该板将采用 RISC-V 处理器，为了在个人电脑上运行 Linux ，

203
00:15:35,850 --> 00:15:40,230
我记得是在过去一两周开的发布会。

204
00:15:40,530 --> 00:15:43,800
如果你很好奇，如果你发现自己，

205
00:15:43,800 --> 00:15:48,090
你知道，我在完成 6.S081 之后，很想使用 RISC-V ，

206
00:15:48,120 --> 00:15:51,330
希望到那时候有处理器可用，

207
00:15:51,330 --> 00:15:53,520
可以在自己的计算机上运行 Linux 。

208
00:15:55,080 --> 00:15:56,820
但是即使在日常生活中，

209
00:15:56,820 --> 00:16:01,410
你也很可能使用了精简指令集，可能你没有意识到这一点，

210
00:16:01,410 --> 00:16:06,710
所以 ARM 指令集， A R M ，

211
00:16:07,000 --> 00:16:09,850
也是精简指令集。

212
00:16:11,030 --> 00:16:18,790
高通公司实现的 ARM 是骁龙系列处理器。

213
00:16:19,060 --> 00:16:29,430
所以，如果你有一部安卓手机，很可能运行的是精简指令集。

214
00:16:30,200 --> 00:16:35,540
即使你用的是 iOS ，我忘了叫什么，

215
00:16:35,540 --> 00:16:40,320
但是苹果也有一些版本的 ARM ，

216
00:16:40,320 --> 00:16:42,780
他们也在自己的处理器上实现了，

217
00:16:42,810 --> 00:16:47,730
这些处理器运行在 iPad iPhone 和多数苹果的移动设备上，

218
00:16:47,940 --> 00:16:50,880
所以精简指令集随处可见，

219
00:16:50,880 --> 00:16:54,180
如果你在现实世界中寻找 RISC-V ，

220
00:16:54,870 --> 00:16:57,180
你知道，在 QEMU 之外，

221
00:16:58,170 --> 00:17:03,120
你可以在集成设备中找到它。

222
00:17:03,890 --> 00:17:10,070
所以它是存在的，虽然不想 x86-64 那样广泛，

223
00:17:10,130 --> 00:17:11,810
但它是。

224
00:17:12,540 --> 00:17:19,000
是的，就像 Luca 刚才说的，苹果正在将 Mac 转向 ARM 。

225
00:17:19,000 --> 00:17:20,410
我相信情况也是如此，

226
00:17:20,560 --> 00:17:25,360
去年确实有一股精简指令集的热潮。

227
00:17:25,960 --> 00:17:29,530
英特尔指令集为什么这么大？

228
00:17:29,530 --> 00:17:31,930
英特尔指令集这么大的原因是，

229
00:17:31,930 --> 00:17:35,230
因为他们非常关心向后兼容性。

230
00:17:35,230 --> 00:17:36,460
所以如果你写了。

231
00:17:36,870 --> 00:17:41,100
一个现代英特尔处理器

232
00:17:41,130 --> 00:17:45,720
也可以运行三十四年前编写的指令，

233
00:17:45,720 --> 00:17:50,280
他们不弃用任何指令，以保证向后兼容性，

234
00:17:50,400 --> 00:17:53,730
RISC-V 更现代，所以不需要考虑这个。

235
00:17:53,730 --> 00:17:57,000
如果我们回到那些手册，

236
00:17:57,180 --> 00:17:59,820
RISC-V 的独特之处是它的指令是分开的，

237
00:17:59,820 --> 00:18:06,650
所有的 RISC-V 处理器都有基本整型指令集。

238
00:18:07,340 --> 00:18:08,270
如果我们有。

239
00:18:08,270 --> 00:18:09,440
Gabriel 在聊天中问道，

240
00:18:09,440 --> 00:18:13,400
如果有 15000 条指令，几乎不可能有效地使用它们，

241
00:18:13,580 --> 00:18:14,660
那么为什么需要这么多。

242
00:18:15,110 --> 00:18:18,350
就像我说的，需要这么多指令，是出于向后兼容的原因，

243
00:18:18,350 --> 00:18:22,340
这是由你自己决定的，你是否认为这是非常重要的。

244
00:18:22,340 --> 00:18:27,750
但是我想很多指令被简单的指令所[]，

245
00:18:27,750 --> 00:18:30,870
这是它们特有的东西。

246
00:18:31,850 --> 00:18:34,610
我从没见过

247
00:18:34,610 --> 00:18:39,080
英特尔汇编代码能充分利用这 15000 条指令，

248
00:18:39,080 --> 00:18:42,950
这主要是出于向后兼容的需要，并且保持简单。

249
00:18:43,520 --> 00:18:48,530
就像我说的， RISC-V 有一个基本整型指令集，

250
00:18:49,030 --> 00:18:54,340
它包含所有正常的加法、乘法运算，

251
00:18:54,400 --> 00:18:58,630
然后处理器可以选择实现其他模块，

252
00:18:58,630 --> 00:19:00,400
你可以在这边看到，

253
00:19:00,400 --> 00:19:02,980
可能你在屏幕上看不清楚，

254
00:19:02,980 --> 00:19:05,410
举个例子，如果你希望处理器

255
00:19:05,470 --> 00:19:09,280
支持单精度浮点型标准扩展，

256
00:19:09,400 --> 00:19:11,260
你就可以包含 F 模块。

257
00:19:11,960 --> 00:19:16,430
这使得 RISC-V 更容易支持向后兼容，

258
00:19:16,430 --> 00:19:22,010
因为你可以指出包含和支持哪些模块，

259
00:19:22,160 --> 00:19:24,290
而编译器可以选择。

260
00:19:24,290 --> 00:19:29,770
然后，编译器告诉我它支持这些模块，

261
00:19:29,770 --> 00:19:32,110
所以我可以用这些模块编译这段代码。

262
00:19:33,760 --> 00:19:35,560
好的， Bibik 说，

263
00:19:35,590 --> 00:19:39,160
似乎使用 x86 而不是 RISC-V 处理器的唯一优势是

264
00:19:39,160 --> 00:19:40,480
可以获得更好的性能，

265
00:19:40,630 --> 00:19:45,130
然而，这种性能是以巨大的成本、复杂度和潜在的安全性为代价的，

266
00:19:45,190 --> 00:19:47,710
我的问题是为什么我们还在使用 x86 ，

267
00:19:47,710 --> 00:19:49,480
而不是转向 RISC-V 。

268
00:19:49,970 --> 00:19:54,560
好的，一个宽泛的答案是，世界运行在 x86 之上，

269
00:19:54,590 --> 00:19:58,160
我也没有一个更好的答案。

270
00:19:58,370 --> 00:20:00,080
RISC-V 是相当现代的，

271
00:20:00,740 --> 00:20:05,210
世界几乎都运行在 x86 上，

272
00:20:05,210 --> 00:20:11,180
如果突然把处理器转换为 RISC-V ，

273
00:20:11,180 --> 00:20:17,320
你会冒着失去对一些重要事情支持的风险。

274
00:20:17,380 --> 00:20:22,420
另外，英特尔在他们的处理器中也做了一些有趣的事情，

275
00:20:22,510 --> 00:20:27,310
比如在安全方面，有 enclave ，

276
00:20:27,310 --> 00:20:30,430
而且近年来他们一直在做一些事情，

277
00:20:30,430 --> 00:20:33,940
试图提供额外的安全性，

278
00:20:34,150 --> 00:20:37,240
英特尔确实实现了一些指令，

279
00:20:37,240 --> 00:20:42,940
这些指令对某些特定的计算是非常有效的。

280
00:20:43,250 --> 00:20:45,140
所以他们有这么多指令，

281
00:20:45,140 --> 00:20:48,870
你知道，多数情况下，一种情况对应一条指令，

282
00:20:48,870 --> 00:20:53,120
这可能比 RISC-V 更有效。

283
00:20:53,210 --> 00:20:55,220
但一个更实际的答案是，

284
00:20:55,220 --> 00:20:56,630
RISC-V 相对较新，

285
00:20:56,630 --> 00:21:00,350
还没有真正为个人电脑制造的处理器，

286
00:21:00,350 --> 00:21:03,260
SiFive 的发布会是最近举办的，

287
00:21:03,440 --> 00:21:06,650
他们可以说是第一批这样做的人。

288
00:21:06,650 --> 00:21:12,420
所以在实践上，不能运行所有为英特尔设计的软件，

289
00:21:12,930 --> 00:21:14,970
这是我最好的答案。

290
00:21:16,210 --> 00:21:20,710
我们现在讲一下汇编，

291
00:21:20,710 --> 00:21:25,690
我想先看一些实际的汇编代码。

292
00:21:26,600 --> 00:21:31,580
这是一段 C 代码，

293
00:21:31,580 --> 00:21:34,100
有一个简单的函数，一个累加器，

294
00:21:34,190 --> 00:21:36,440
我们从 0 循环到 n ，

295
00:21:36,440 --> 00:21:41,060
然后将 0 到 n 的所有数字加起来，

296
00:21:41,960 --> 00:21:43,550
然后返回这个值。

297
00:21:43,760 --> 00:21:48,140
这是最简单的级别，最简单的汇编代码，

298
00:21:48,140 --> 00:21:50,510
你可以编译这段程序，

299
00:21:50,720 --> 00:21:56,930
如果你真的编写了 C 代码，并编译它，

300
00:21:56,930 --> 00:22:00,470
你可能会得到一些看起来完全不同的东西。

301
00:22:01,420 --> 00:22:03,280
这是正确的，有不同的原因，

302
00:22:03,280 --> 00:22:06,760
我们会看到其中一些原因，还有一些是特定编译器的，

303
00:22:07,090 --> 00:22:11,980
现代编译器进行了大量的优化，

304
00:22:13,510 --> 00:22:16,000
当使用编译器将 C 编译成汇编时，

305
00:22:16,000 --> 00:22:18,160
所以你的汇编指令看起来可能会不同，

306
00:22:18,280 --> 00:22:21,280
例如，当你在 gdb 中调试时，

307
00:22:21,280 --> 00:22:25,750
可能会遇到一些东西告诉你某个变量已经被优化，

308
00:22:26,050 --> 00:22:30,010
意思是编译器决定不需要该变量，

309
00:22:30,010 --> 00:22:33,370
因此，这个变量会从程序中消失。

310
00:22:33,610 --> 00:22:41,230
这是很直接的，我们把 a0 中的值移动到 t0 ，

311
00:22:41,260 --> 00:22:42,940
我们把 a0 设置为 0 ，

312
00:22:42,940 --> 00:22:47,890
然后把 t0 中的内容加到 a0 上，

313
00:22:47,890 --> 00:22:51,340
对循环中的每次迭代，直到 t0 变为 0 。

314
00:22:52,500 --> 00:22:54,060
这就是这段代码的意思。

315
00:22:54,090 --> 00:22:55,410
Amir, 你举手了。

316
00:22:57,460 --> 00:23:01,900
我想知道 .section .text .global 是做什么的。

317
00:23:02,420 --> 00:23:05,810
global 表示你可以从其他文件中包含这个，

318
00:23:06,050 --> 00:23:12,860
如果我们去看，看一下 defs.h 。

319
00:23:14,220 --> 00:23:19,740
这是你后面会非常熟悉的文件，

320
00:23:19,740 --> 00:23:24,480
包含内核中可能使用的所有函数

321
00:23:24,870 --> 00:23:28,470
在这里，我们可以看到，

322
00:23:28,470 --> 00:23:33,210
在我的文件中，已经包含了这些函数的定义，

323
00:23:33,360 --> 00:23:40,950
这样， .global 保证这些函数可以从其他地方调用，

324
00:23:41,220 --> 00:23:43,530
而 .text 表示这是代码。

325
00:23:44,220 --> 00:23:48,720
如果你回想一下书中的图 3.4 ，

326
00:23:49,300 --> 00:23:54,510
我们去看那本书，

327
00:23:56,380 --> 00:24:00,790
我们进入页表进程地址空间，

328
00:24:00,970 --> 00:24:06,640
在这张图中，这和 text 是一样的，表示代码。

329
00:24:09,440 --> 00:24:10,250
这回答了你的问题吗？

330
00:24:10,730 --> 00:24:11,630
谢谢。

331
00:24:14,810 --> 00:24:17,180
如果我们想运行，嗯。

332
00:24:17,670 --> 00:24:19,530
我们有一些汇编代码，

333
00:24:19,590 --> 00:24:24,900
如果你发现自己对内核代码感兴趣，

334
00:24:25,140 --> 00:24:31,830
我们可以进入，编译后你可以查看 kernel/kernel.asm 文件。

335
00:24:32,800 --> 00:24:40,330
这是 xv6 内核的完整汇编代码，

336
00:24:40,330 --> 00:24:44,410
左边的每个数字都是一个标签，

337
00:24:44,410 --> 00:24:48,160
告诉你这个指令在内存中的位置，

338
00:24:48,490 --> 00:24:50,290
这是很有用的。

339
00:24:50,670 --> 00:24:53,820
所以，这就是实际的，

340
00:24:54,840 --> 00:24:59,910
使用实际的汇编代码，你可以看到函数的标签以及声明，

341
00:24:59,910 --> 00:25:04,380
这在我们调试代码时是非常有用的，

342
00:25:04,380 --> 00:25:06,900
稍后我将展示这一点。

343
00:25:07,540 --> 00:25:12,370
但是现在我们回到第一个函数 sum_to ，

344
00:25:12,550 --> 00:25:16,750
我们看看如何在 gdb 中调试，

345
00:25:16,780 --> 00:25:21,460
第一步，这里我有两个窗口，

346
00:25:21,670 --> 00:25:24,670
.asm 和 .S 文件有什么不同？

347
00:25:25,170 --> 00:25:29,310
嗯，我也不是很确定，

348
00:25:29,430 --> 00:25:30,780
它们都是汇编，

349
00:25:30,780 --> 00:25:36,120
我想 .asm 文件包含了许多 .S 文件没有包含的额外注释，

350
00:25:36,390 --> 00:25:40,570
通常情况下，你把 C 代码编译成 .S 时，

351
00:25:40,570 --> 00:25:44,590
你会得到一些不包含行号的汇编代码，

352
00:25:44,590 --> 00:25:47,700
如果你想知道如何获得 .asm 文件，

353
00:25:47,700 --> 00:25:52,530
我想 makefile 会告诉你获得它的准确步骤。

354
00:25:55,960 --> 00:26:00,460
我们回到终端，我们有两个窗口，

355
00:26:00,580 --> 00:26:05,800
首先要做的当然是启动并运行 QEMU 。

356
00:26:06,630 --> 00:26:10,110
在 gdb 模式下启动，

357
00:26:10,110 --> 00:26:13,470
现在我们卡在这里，然后我们启动 gdb 。

358
00:26:15,990 --> 00:26:20,220
就像 Frans 教授上周展示的那样。

359
00:26:20,550 --> 00:26:22,980
我想有些人会很兴奋，

360
00:26:22,980 --> 00:26:26,280
输入 tui enable ，会出现一个窗口，

361
00:26:26,280 --> 00:26:30,150
现在是空的，但在你调试时会很有用，

362
00:26:30,390 --> 00:26:32,010
我们可以设置一个断点，

363
00:26:32,010 --> 00:26:37,170
应该注意到这些代码都在内核中，没有一个在用户空间，

364
00:26:37,440 --> 00:26:40,170
所以我们设置断点时没有什么烦人的问题，

365
00:26:40,410 --> 00:26:45,840
我可以在函数 sum_to 设置一个断点，然后继续运行。

366
00:26:47,300 --> 00:26:55,880
现在运行该函数，你在 tui 中看到的第一个窗口是源码窗口，

367
00:26:57,270 --> 00:27:03,540
是的，像 David 说的， kernel.asm 左边的数字是非常有用的，

368
00:27:03,540 --> 00:27:08,130
当你调试的时候，你得到一个地址，它会告诉你，

369
00:27:08,130 --> 00:27:09,300
所以你可以看到，

370
00:27:09,330 --> 00:27:14,560
我们可以在 gdb 中看到 PC ，即程序计数器，

371
00:27:14,560 --> 00:27:18,220
我们可以看这个地址，以 800 开头的，

372
00:27:18,540 --> 00:27:24,240
如果我们查看 kernel.asm ，并查找那个地址，

373
00:27:24,270 --> 00:27:25,890
我们可以看到它在，

374
00:27:26,860 --> 00:27:29,620
嗯，它出现了两次，因为函数调用，

375
00:27:29,740 --> 00:27:33,970
我们看这里，这就是那个地址，它是 sum_to 的开头。

376
00:27:34,760 --> 00:27:37,580
所以如果你在任何时候看到这些东西，

377
00:27:37,610 --> 00:27:45,180
所有内核地址都是 0x8000 这样的数字。

378
00:27:46,240 --> 00:27:50,290
这些地址你可以直接跳转到 kernel.asm ，

379
00:27:50,290 --> 00:27:54,190
并找到发生问题的那一行，

380
00:27:54,190 --> 00:27:56,050
然后可以在相应地设置断点，

381
00:27:56,410 --> 00:28:00,700
现在 tui 的顶部窗口是源码窗口，

382
00:28:00,700 --> 00:28:07,390
如果我们想要查看汇编，可以在 gdb 中输入 layout asm ，

383
00:28:07,390 --> 00:28:11,920
这会给我们所有的汇编指令，

384
00:28:11,920 --> 00:28:14,830
如果我们输入 layout reg 还可以查看寄存器，

385
00:28:14,830 --> 00:28:17,380
我们得到汇编和寄存器，

386
00:28:17,620 --> 00:28:20,590
如果你要浏览什么东西，

387
00:28:21,410 --> 00:28:24,350
现在我们有三个窗口，需要指定聚焦在哪个窗口，

388
00:28:24,350 --> 00:28:27,260
如果我想查看所有的寄存器，输入 focus reg 。

389
00:28:28,000 --> 00:28:30,220
现在我聚焦在了寄存器窗口，

390
00:28:30,220 --> 00:28:34,960
这时移动箭头键或者滚动，就可以在那个窗口滚动了。

391
00:28:35,660 --> 00:28:38,810
现在，我们聚焦在汇编窗口。

392
00:28:39,580 --> 00:28:41,800
我们到了这里，就可以看到所有的东西，

393
00:28:42,040 --> 00:28:45,940
让我们看看，我们可以在寄存器窗口中看到，

394
00:28:45,940 --> 00:28:48,490
我们可以看到 t0 包含这个值，

395
00:28:48,550 --> 00:28:51,250
可以看到 a0 包含这个值。

396
00:28:51,840 --> 00:28:55,140
当我们单步执行汇编时，可以看到，

397
00:28:55,170 --> 00:29:00,150
t0 刚刚得到了 a0 的值，也就是 5 ，

398
00:29:00,150 --> 00:29:03,060
它也高亮显示了发生改变的寄存器。

399
00:29:03,280 --> 00:29:09,640
这里我们可以，如果按下 enter 键，会得到最近执行的命令，

400
00:29:09,640 --> 00:29:12,880
我们继续，将 a0 设置为 0 ，

401
00:29:13,030 --> 00:29:19,270
现在我们可以看到这个循环和其中一些值，

402
00:29:20,020 --> 00:29:22,840
这就像是一个完整的[]函数。

403
00:29:23,630 --> 00:29:27,050
我们继续，

404
00:29:27,050 --> 00:29:31,700
如果你想知道设置了什么断点，

405
00:29:31,700 --> 00:29:33,800
或者忘记了你在做什么，

406
00:29:33,980 --> 00:29:37,940
输入 info break 或 breakpoints ，

407
00:29:38,060 --> 00:29:41,120
就可以看到代码中设置的所有断点，

408
00:29:41,390 --> 00:29:45,410
你甚至可以看到，这个断点已经命中了一次，

409
00:29:45,620 --> 00:29:48,560
这样你就能得到很多有用的信息。

410
00:29:49,410 --> 00:29:54,390
如果你不想使用寄存器窗口，但需要查看寄存器，

411
00:29:54,510 --> 00:29:58,110
输入 info reg 或 info registers 或 i registers

412
00:29:58,110 --> 00:30:04,130
任何一个都可以调出寄存器窗口。

413
00:30:05,900 --> 00:30:10,400
那么，有关于 gdb 的问题吗？

414
00:30:10,640 --> 00:30:15,320
简单的问题，我知道已经有很多关于它的[]了，

415
00:30:15,320 --> 00:30:18,380
所以现在可以问一些简单的问题。

416
00:30:18,380 --> 00:30:21,890
我会展示更多 gdb 的用法。

417
00:30:22,100 --> 00:30:24,500
你使用什么命令打开多个窗口？

418
00:30:24,500 --> 00:30:25,730
我使用的是 tmux ，

419
00:30:25,820 --> 00:30:27,800
我可以从头开始演示，

420
00:30:27,920 --> 00:30:32,840
在这里，我打开一个新的终端，只有一个空白的终端。

421
00:30:33,730 --> 00:30:36,580
如果你输入 tmux ，在 Athena 上也是可用的。

422
00:30:37,150 --> 00:30:42,000
嗯，我一会再回答下一个问题，

423
00:30:42,180 --> 00:30:46,470
现在我在 tmux ，你可以从底部的绿色状态栏看出来，

424
00:30:46,650 --> 00:30:52,230
在 tmux 中，有几种方式可以创建多个窗口，

425
00:30:52,230 --> 00:30:55,670
你可以输入 control-b c ，

426
00:30:55,670 --> 00:31:00,440
如果你习惯使用 emacs ，对此会很熟悉，

427
00:31:00,440 --> 00:31:03,950
但是对于不使用 emacs 的人，

428
00:31:04,010 --> 00:31:09,260
就是先按下 control 键，然后按下 b ，然后单独按下 c ，

429
00:31:09,320 --> 00:31:11,000
这会打开第二个窗口，

430
00:31:11,000 --> 00:31:14,480
然后，你可以使用 control-b p 或

431
00:31:14,540 --> 00:31:17,750
control-b n 在它们之间切换，

432
00:31:17,810 --> 00:31:20,930
是的， David 刚刚贴出了 tmux 的 cheatsheet ，这很有用，

433
00:31:21,350 --> 00:31:22,850
如果你想拆分窗口，

434
00:31:22,850 --> 00:31:28,800
使用 control-b % 会垂直拆分窗口，

435
00:31:28,800 --> 00:31:35,050
使用 control-b " 会水平拆分窗口，

436
00:31:35,800 --> 00:31:36,820
这就是我如何得到它们的。

437
00:31:36,820 --> 00:31:42,370
如果我们处于这种状态，可以使用 control-b o 在窗口之间切换。

438
00:31:42,940 --> 00:31:45,670
这就是我有多个窗口的方法。

439
00:31:45,670 --> 00:31:47,410
是的，[]。

440
00:31:47,970 --> 00:31:53,610
Ahmed 问，为什么显示汇编地址，而不是 C 行号。

441
00:31:53,670 --> 00:31:56,790
因为函数。

442
00:31:58,010 --> 00:32:00,920
如果我们回到汇编函数，

443
00:32:00,980 --> 00:32:04,220
这完全是由汇编语言实现的，而不是用 C ，

444
00:32:04,340 --> 00:32:07,490
所以没有与此相关的 C 行号。

445
00:32:07,850 --> 00:32:12,410
如果我们要设置断点，

446
00:32:12,560 --> 00:32:15,560
如果你输入 delete ，可以删除所有断点，

447
00:32:15,980 --> 00:32:20,510
我删除旧断点，现在在 demo_1 中设置一个断点，

448
00:32:20,510 --> 00:32:24,680
这是一个 C 断点，然后继续运行，

449
00:32:24,740 --> 00:32:29,300
现在，我输入 layout split ，会得到 C 和汇编窗口。

450
00:32:29,970 --> 00:32:33,990
如果我只想要 C 源码窗口，可以使用 layout source ，然后就只有 C 。

451
00:32:35,440 --> 00:32:37,090
这就是正在发生的事，

452
00:32:37,090 --> 00:32:39,040
基于这个事实，

453
00:32:39,040 --> 00:32:42,580
它没有关联的 C 代码，所以看不到 C 行号。

454
00:32:46,270 --> 00:32:52,720
关于 gdb tmux ，还有别的问题吗？

455
00:32:53,080 --> 00:32:55,360
所以 layout split 用来

456
00:32:59,200 --> 00:33:04,840
是的，如果你使用 layout split ，可以得到源码和汇编窗口，

457
00:33:04,840 --> 00:33:06,730
使用 layout source 只得到源码窗口，

458
00:33:06,730 --> 00:33:08,410
使用 layout asm 则只有汇编窗口。

459
00:33:08,530 --> 00:33:12,160
寄存器是单独的，你可以输入 layout reg ，

460
00:33:12,160 --> 00:33:14,540
是的，这会调出寄存器，

461
00:33:14,540 --> 00:33:17,600
但是，我不知道有什么方法

462
00:33:17,600 --> 00:33:21,780
可以同时调出寄存器、汇编和 C 源码。

463
00:33:21,780 --> 00:33:24,180
除了在 layout split 状态下使用 info reg 。

464
00:33:24,990 --> 00:33:30,150
我有一个问题，当我们在行中设置断点。

465
00:33:30,180 --> 00:33:30,690
嗯，

466
00:33:31,090 --> 00:33:38,290
这种情况下，断点添加到类似 0x80006354 这样的地址，

467
00:33:39,250 --> 00:33:46,900
指令可能有多个， C 中的代码行可能有多个指令，

468
00:33:46,960 --> 00:33:49,090
那么显示的是哪一个？

469
00:33:49,210 --> 00:33:50,320
我想显示的是第一个。

470
00:33:51,510 --> 00:33:56,670
对启动 tui 有问题的人，

471
00:33:56,670 --> 00:34:00,210
我想命令应该是 tui enable 而不是 enable tui ，不好意思。

472
00:34:01,070 --> 00:34:04,580
我想是的。

473
00:34:05,570 --> 00:34:05,630
是的。

474
00:34:08,450 --> 00:34:14,450
是的，再提一下，这里有一些 gdb 和 tmux 的 cheatsheet ，

475
00:34:14,450 --> 00:34:16,370
如果你发现自己不会用，可以看一下。

476
00:34:16,430 --> 00:34:23,400
gdb 还有自己的内置手册，叫做 apropos ，

477
00:34:23,550 --> 00:34:26,490
如果你输入 apropos tui ，

478
00:34:26,520 --> 00:34:31,980
它会显示所有相关的 tui 命令。

479
00:34:33,310 --> 00:34:39,460
是的，这可能非常有用，但也有点令人不知所措。

480
00:34:39,820 --> 00:34:43,780
如果你使用 apropos -v ，它会给你提供更多信息。

481
00:34:44,610 --> 00:34:49,160
嗯，我不记得了，我不经常使用它。

482
00:34:49,160 --> 00:34:53,870
但是如果你要查找或忘记了 gdb 中输入命令的确切方式，

483
00:34:53,870 --> 00:34:54,860
而且你不想使用谷歌，

484
00:34:54,860 --> 00:34:59,300
apropos 能够找到你要找的东西，

485
00:34:59,300 --> 00:35:01,520
还包括很多关联的东西。

486
00:35:04,260 --> 00:35:08,430
是的，所以这是非常有用的， gdb 也有很好的文档。

487
00:35:08,460 --> 00:35:13,980
所以，如果发现自己不会使用，你知道的，谷歌是你的朋友。

488
00:35:16,800 --> 00:35:22,740
现在我们来看汇编和 RISC-V 以及相关的东西，

489
00:35:22,800 --> 00:35:25,500
我想深入讲解一下细节，

490
00:35:25,740 --> 00:35:30,810
你们在随后的实验中会用到，

491
00:35:30,990 --> 00:35:33,900
另外，这也是对文档的一个回顾，

492
00:35:33,900 --> 00:35:41,710
当然，我想勤奋的同学已经读过一遍了。

493
00:35:42,700 --> 00:35:47,860
是的，这张表你们很熟悉，

494
00:35:47,860 --> 00:35:52,270
从 6.004 或你们自己读的资料中，

495
00:35:52,360 --> 00:35:54,670
这是寄存器表，

496
00:35:54,670 --> 00:36:03,630
寄存器是 CPU 上处理器周围预设的很小的位置，

497
00:36:03,630 --> 00:36:07,410
它可以存储值，这很重要，

498
00:36:07,410 --> 00:36:11,340
因为汇编操作，如果你记得汇编代码，

499
00:36:11,490 --> 00:36:15,360
汇编不是在内存上操作，而是在寄存器上操作，

500
00:36:15,360 --> 00:36:20,580
所以我们做加法、减法时，是在寄存器上操作。

501
00:36:21,000 --> 00:36:25,320
所以你经常看到一种编写汇编的模式，

502
00:36:25,320 --> 00:36:32,080
有一个 load ，将一些值加载到寄存器中。

503
00:36:33,030 --> 00:36:37,320
这个值可以来自内存，也可以来自另一个寄存器。

504
00:36:38,340 --> 00:36:43,020
这里泛指加载，而不是 load 指令。

505
00:36:43,420 --> 00:36:49,410
然后我们会操作，在寄存器上执行一些操作，

506
00:36:49,410 --> 00:36:53,100
如果我们关心返回地址之外的操作结果，

507
00:36:53,280 --> 00:37:01,310
我们可以把寄存器的值存储到某个地方，

508
00:37:01,310 --> 00:37:08,000
将寄存器的值存储到内存中某个位置或另一个寄存器。

509
00:37:08,210 --> 00:37:10,580
这就是通常的操作过程，

510
00:37:10,580 --> 00:37:17,300
寄存器是执行任何计算或访问任何值的最快方式，

511
00:37:17,300 --> 00:37:20,540
这就是为什么使用它们很重要，

512
00:37:20,540 --> 00:37:24,590
也是我们更应该使用寄存器而不是内存的原因，

513
00:37:24,590 --> 00:37:28,340
如果你们记得文档中，我们调用函数时，

514
00:37:28,340 --> 00:37:31,490
可以看到，寄存器从 a0 到 a7 。

515
00:37:32,450 --> 00:37:40,610
一般来说，当我们谈到寄存器时，会使用它们的 ABI 名称来指代它们，

516
00:37:40,820 --> 00:37:43,760
不仅减少了混淆，也是一个标准，

517
00:37:43,760 --> 00:37:45,920
也是你编写汇编代码的方式，

518
00:37:45,950 --> 00:37:50,920
这个，这些实际的数字并不是特别重要，

519
00:37:50,980 --> 00:37:58,360
唯一有意义的情况是对于 RISC-V 指令的压缩版本，

520
00:37:58,360 --> 00:38:02,350
如果你想了解更多，可以查看文档，

521
00:38:02,350 --> 00:38:07,230
基本思想是 RISC-V ，普通指令是 64 位，

522
00:38:07,230 --> 00:38:10,650
但是也有一个压缩版本，指令是 16 位，

523
00:38:10,830 --> 00:38:17,220
我们使用的寄存器更少，这种情况下，使用的寄存器是 8 到 15 ，

524
00:38:17,220 --> 00:38:19,050
这些是我们可以使用的寄存器。

525
00:38:19,170 --> 00:38:24,120
有人提问，为什么这个 s1 寄存器 x9 ，

526
00:38:24,120 --> 00:38:27,960
为什么它与其他所有寄存器分开？

527
00:38:28,050 --> 00:38:30,990
我猜是这样，

528
00:38:31,800 --> 00:38:37,050
我们把它与其他分开，因为它在压缩指令模式下是可用的，

529
00:38:37,080 --> 00:38:39,120
而 s2 到 s11 不是。

530
00:38:40,220 --> 00:38:42,470
这是我的想法，它是一个压缩指令寄存器，

531
00:38:42,470 --> 00:38:48,030
但是在寄存器之外，将通过它们的 ABI 名称来引用，

532
00:38:48,060 --> 00:38:51,180
a0 到 a7 用于函数变量，

533
00:38:51,270 --> 00:38:52,650
但是如果有一个函数接受的参数数量，

534
00:38:52,650 --> 00:38:57,030
超过可以访问的寄存器数 8 个，

535
00:38:57,470 --> 00:38:59,000
我们就需要内存，

536
00:38:59,000 --> 00:39:01,370
但这在某种程度上也说明了一个事实，

537
00:39:01,370 --> 00:39:03,920
当我们可以使用寄存器时，就不使用内存。

538
00:39:04,100 --> 00:39:07,490
我们只在必须的时候使用内存。

539
00:39:08,790 --> 00:39:11,490
这一栏， saver 栏，

540
00:39:11,670 --> 00:39:14,070
也是非常重要的，

541
00:39:14,070 --> 00:39:17,400
在我们讨论调用者（caller）和被调用者（callee）保存寄存器时，

542
00:39:17,760 --> 00:39:23,610
这两个属于我也经常混淆，

543
00:39:23,610 --> 00:39:25,950
caller 和 callee 只有一个字母的区别，

544
00:39:26,010 --> 00:39:29,700
记住它们最简单的方法是，

545
00:39:29,700 --> 00:39:40,850
调用者保存寄存器在函数调用期间不会保留，

546
00:39:42,190 --> 00:39:47,850
而被调用者保存寄存器会保留。

547
00:39:49,580 --> 00:39:52,900
我的意思是，

548
00:39:54,500 --> 00:40:01,460
调用者保存寄存器可以被函数重写，

549
00:40:01,460 --> 00:40:04,370
比如我有函数 a 调用函数 b ，

550
00:40:04,700 --> 00:40:08,690
函数 a 使用的任何寄存器都是调用者保存的。

551
00:40:08,880 --> 00:40:12,240
调用函数 b 可以在其被调用时覆盖，

552
00:40:12,420 --> 00:40:16,080
我想返回地址（Return address）就是一个很好的例子。

553
00:40:16,320 --> 00:40:20,100
你可以看到返回地址是调用者保存的。

554
00:40:21,170 --> 00:40:25,640
这一点很重要，因为每个函数都需要使用返回地址，

555
00:40:25,730 --> 00:40:27,590
因此，当 a 调用 b 时，

556
00:40:27,590 --> 00:40:32,480
b 能够覆盖返回地址中的值是很重要的，

557
00:40:32,510 --> 00:40:34,130
这就是为什么它是调用者保存的。

558
00:40:34,340 --> 00:40:39,440
而被调用者保存寄存器只是我们使用的约定，

559
00:40:39,620 --> 00:40:42,800
所以，帧指针（frame pointer, s0/fp）非常重要。

560
00:40:43,030 --> 00:40:46,330
这些寄存器在函数调用之间保留，

561
00:40:46,330 --> 00:40:48,850
所以对于调用者保存寄存器，

562
00:40:49,000 --> 00:40:52,390
进行调用的函数需要考虑这些寄存器，

563
00:40:52,540 --> 00:40:54,070
如果是被调用者保存的，

564
00:40:54,070 --> 00:40:58,930
则被调用的函数需要考虑如何保存这些寄存器的值。

565
00:40:59,830 --> 00:41:03,280
你知道，我经常混淆这两个，

566
00:41:03,280 --> 00:41:10,200
可以回到这张表，看看它们是怎么用的。

567
00:41:11,160 --> 00:41:14,860
如果你记得读过的内容，

568
00:41:14,890 --> 00:41:18,280
所有这些寄存器都是 64 位的，

569
00:41:18,280 --> 00:41:21,100
所以，它们有 64 个位置可以放东西，

570
00:41:21,250 --> 00:41:28,660
基于调用约定，各种类型数据适用于 64 位，

571
00:41:28,660 --> 00:41:30,400
所以如果我们有一个 32 位整数，

572
00:41:30,490 --> 00:41:33,550
根据它是不是扩展的，

573
00:41:33,610 --> 00:41:36,490
我们可以在它前面添加 0 或 1 ，

574
00:41:36,490 --> 00:41:39,760
以便将其设置为 64 位放入这些寄存器。

575
00:41:40,480 --> 00:41:41,860
在我们继续之前，

576
00:41:41,950 --> 00:41:48,010
有没有关于寄存器或相关的问题。

577
00:41:57,950 --> 00:41:59,360
我有一个问题，

578
00:41:59,360 --> 00:42:03,770
能把一个返回值放在 a1 中吗？

579
00:42:04,790 --> 00:42:06,500
是的，这是个好问题。

580
00:42:06,500 --> 00:42:11,090
我想理论上是可以的，

581
00:42:11,120 --> 00:42:14,960
原因是，比如 a0 到 a1 是，

582
00:42:14,960 --> 00:42:18,770
如果函数返回 128 位的长整型，

583
00:42:18,770 --> 00:42:24,560
如果你记得，如果一个函数参数是 100 ，超过一个指针字（pointer-word）长。

584
00:42:24,880 --> 00:42:28,060
当我们说字（word）时，是 64 位，

585
00:42:28,210 --> 00:42:31,390
所以如果我们有两倍于指针字大小的东西，

586
00:42:32,350 --> 00:42:35,170
我们可以把它放入寄存器对中，

587
00:42:35,320 --> 00:42:38,590
因此同样的约定也适用于返回地址，

588
00:42:38,590 --> 00:42:42,490
如果我们有一个指针字两倍大小的东西，

589
00:42:42,520 --> 00:42:46,240
可以把它放在 a0 和 a1 中，并作为返回地址。

590
00:42:46,330 --> 00:42:49,270
我想如果你只往 a1 里写入，可能会遇到问题。

591
00:42:49,880 --> 00:42:51,050
理解了，谢谢。

592
00:42:55,040 --> 00:42:59,510
为什么寄存器不是连续的，

593
00:42:59,510 --> 00:43:03,860
为什么 a0 和 a1 是分开的？

594
00:43:04,680 --> 00:43:06,480
抱歉，这不是一个好例子，

595
00:43:06,480 --> 00:43:09,450
为什么 s1 和 s2 是分开的，

596
00:43:09,450 --> 00:43:12,540
为什么 a 在它们中间，这有什么意义吗？

597
00:43:13,180 --> 00:43:15,910
是的，我之前提到，

598
00:43:15,910 --> 00:43:20,080
这只是一个猜测，我不是很确定，

599
00:43:20,230 --> 00:43:24,760
有一个压缩版本的 RISC-V 指令，

600
00:43:25,000 --> 00:43:28,450
它的大小是 16 位，而不是 64 位。

601
00:43:28,920 --> 00:43:34,170
你可以用它来使代码在内存中占用更少的空间，

602
00:43:34,410 --> 00:43:41,850
当你使用 16 位指令时，只能访问寄存器 8 到 15 位，

603
00:43:42,000 --> 00:43:45,750
所以我认为 s1 与 s2 到 s11 分开，

604
00:43:45,870 --> 00:43:47,790
是因为他们想要明确，

605
00:43:47,790 --> 00:43:53,630
s1 在压缩指令模式下可用，而 s2 到 s11 则不可用。

606
00:43:54,500 --> 00:44:00,120
我不知道他们为什么选择 x ， x8 到 x15 ，

607
00:44:00,240 --> 00:44:03,090
但我相信，只要看一些代码，

608
00:44:03,090 --> 00:44:05,400
就会发现这些是最常用的寄存器。

609
00:44:17,140 --> 00:44:18,310
还有其他问题吗？

610
00:44:20,840 --> 00:44:22,490
我有一个问题。

611
00:44:23,630 --> 00:44:26,960
除了帧指针、栈指针，

612
00:44:27,140 --> 00:44:32,120
我不知道为什么我们需要更多的被调用者保存寄存器。

613
00:44:32,460 --> 00:44:34,590
但我们确实有很多这样的寄存器。

614
00:44:35,420 --> 00:44:40,070
是的， s1 到 s11 只是为了，

615
00:44:40,070 --> 00:44:44,120
我相信只是为了让编译器或程序员有使用它们的自由，

616
00:44:44,360 --> 00:44:47,390
在某些情况下，你可能想要，

617
00:44:47,600 --> 00:44:52,790
想要保证在函数之后仍然有一些东西存在

618
00:44:52,790 --> 00:44:58,220
可以调用编译器选择使用 s1 到 s11 来做。

619
00:44:58,760 --> 00:45:04,450
嗯，我现在没有一个具体的例子来说明，

620
00:45:04,570 --> 00:45:06,640
但是，我肯定它会出现的，

621
00:45:07,330 --> 00:45:09,940
具有被调用者保存值是很重要的。

622
00:45:14,390 --> 00:45:19,220
这些基本上是程序员或编译器选择使用 s1 到 s11 。

623
00:45:22,420 --> 00:45:27,040
我要提醒一下，这些浮点寄存器，浮点算数，

624
00:45:28,480 --> 00:45:31,090
据我所知，你们在这节课上不会看到它们，

625
00:45:31,360 --> 00:45:33,790
所以不需要担心它们。

626
00:45:38,550 --> 00:45:45,140
好的，我们开始讨论一下函数调用，

627
00:45:45,440 --> 00:45:53,820
有了这些，我想开始讨论堆栈。

628
00:45:54,390 --> 00:45:59,420
这就是我们要讨论的堆栈，

629
00:45:59,840 --> 00:46:04,610
堆栈，就像你以前看到的那样，

630
00:46:04,640 --> 00:46:07,730
它之所以重要是因为，

631
00:46:07,850 --> 00:46:13,030
它使函数保持组织和正常运行，

632
00:46:13,060 --> 00:46:18,490
它允许函数工作，允许函数返回，

633
00:46:18,490 --> 00:46:25,150
这也是我们经常编写保存寄存器之类的代码。

634
00:46:26,330 --> 00:46:27,050
嗯。

635
00:46:29,440 --> 00:46:39,310
在这里，我给出了堆栈的一个非常简单的布局，

636
00:46:39,340 --> 00:46:48,100
而且这里的每个框都是我们所说的栈帧。

637
00:46:49,070 --> 00:46:54,860
每次我们得到栈帧，都是由函数调用生成的。

638
00:46:59,890 --> 00:47:03,190
每次我们调用一个函数，

639
00:47:03,220 --> 00:47:07,360
该函数都会为自己创建栈帧，

640
00:47:07,510 --> 00:47:14,350
并通过移动栈指针来使用它，

641
00:47:14,530 --> 00:47:16,330
这个是栈指针，

642
00:47:16,360 --> 00:47:19,630
记住这些是很重要的。

643
00:47:19,780 --> 00:47:29,070
对于栈，我们从高地址开始，然后向下扩展到低地址，

644
00:47:29,070 --> 00:47:31,470
所以栈总是向下扩展。

645
00:47:31,860 --> 00:47:38,370
所以你会看到栈指针的运算通常是通过减法来完成的，

646
00:47:38,370 --> 00:47:41,020
我们要在汇编中创建一个新的栈帧，

647
00:47:41,020 --> 00:47:42,430
栈就向下扩展。

648
00:47:43,380 --> 00:47:48,780
函数栈帧包含寄存器、局部变量，

649
00:47:48,930 --> 00:47:51,030
就像我说的，

650
00:47:51,030 --> 00:47:56,190
如果参数寄存器用完了，额外的参数就会出现在栈上，

651
00:47:56,370 --> 00:47:59,460
栈帧不一定是相同大小，

652
00:47:59,460 --> 00:48:01,980
尽管在这张图中它们是相同的，但事实并非如此，

653
00:48:02,010 --> 00:48:04,920
不同函数具有不同数量的局部变量，

654
00:48:04,920 --> 00:48:07,980
不同的寄存器等，

655
00:48:08,070 --> 00:48:09,900
因此栈帧具有不同的大小，

656
00:48:09,900 --> 00:48:12,570
但是有两件事是可以确定的，

657
00:48:12,820 --> 00:48:17,650
这很重要，返回地址总是在第一个，

658
00:48:17,650 --> 00:48:20,950
并且，帧指针，前一帧帧指针

659
00:48:20,950 --> 00:48:24,700
也会出现在栈中可预测位置，

660
00:48:24,970 --> 00:48:29,330
两个重要的寄存器，这个是 sp ，

661
00:48:29,330 --> 00:48:33,980
正如我们讨论的，这是栈的底部。

662
00:48:35,780 --> 00:48:38,990
或者说是栈所在的位置，

663
00:48:39,200 --> 00:48:49,480
fp 也是重要的寄存器，指向当前帧的顶部。

664
00:48:50,790 --> 00:48:51,780
这一点很重要，

665
00:48:51,780 --> 00:48:56,220
因为这意味着返回地址和前一 fp

666
00:48:56,250 --> 00:49:01,770
将始终位于当前帧指针的固定位置。

667
00:49:02,400 --> 00:49:05,790
这意味着如果我想找到返回地址，

668
00:49:05,790 --> 00:49:07,650
或者想找到上一帧，

669
00:49:07,890 --> 00:49:12,930
我总是可以通过查看当前帧指针来获得这些值，

670
00:49:13,650 --> 00:49:16,800
我们之所以存储前一个帧指针，

671
00:49:16,800 --> 00:49:18,900
是为了可以向后跳转，

672
00:49:18,900 --> 00:49:22,680
一旦这个函数返回，我们可以把它移动到 fp ，

673
00:49:22,710 --> 00:49:23,790
然后，

674
00:49:23,790 --> 00:49:30,090
fp 从指向这个栈帧，到指向这个栈帧。

675
00:49:30,450 --> 00:49:34,050
所以，我们使用帧指针来操作栈帧，

676
00:49:34,050 --> 00:49:40,110
并确保始终指向函数对应的栈帧。

677
00:49:41,040 --> 00:49:43,920
这就是栈的工作方式，

678
00:49:44,040 --> 00:49:50,830
栈的这部分是使用汇编语言实现的，

679
00:49:50,920 --> 00:49:56,230
你读到的调用约定文档中的所有内容，

680
00:49:56,260 --> 00:50:00,850
都是由编译器实施的，

681
00:50:00,850 --> 00:50:06,970
编译器遵循调用约定，生成栈帧，

682
00:50:06,970 --> 00:50:10,900
生成汇编代码，保证栈帧正确，

683
00:50:11,080 --> 00:50:18,570
所以通常在函数的开头，你会看到所谓的函数序言。

684
00:50:21,300 --> 00:50:24,180
然后是函数体，

685
00:50:24,450 --> 00:50:29,410
然后是一个函数尾声。

686
00:50:29,470 --> 00:50:37,240
这就是汇编函数通常看起来的样子，

687
00:50:37,360 --> 00:50:38,920
我们现在来看一下，

688
00:50:39,100 --> 00:50:43,660
这里我有另一个函数 sum_then_double ，

689
00:50:43,660 --> 00:50:49,270
注意， sum_to 没有这些东西，

690
00:50:49,270 --> 00:50:51,940
一个真正的函数应该有的，

691
00:50:52,060 --> 00:50:54,220
它也是可用的，因为足够简单，

692
00:50:54,220 --> 00:50:57,100
它的所有计算都是在 a0 上进行的，

693
00:50:57,100 --> 00:51:01,380
所以是好的，我们把它称为叶子函数，

694
00:51:01,590 --> 00:51:04,350
如果你看到叶子函数这个术语，

695
00:51:04,350 --> 00:51:06,510
它是一个不调用另一个函数的函数，

696
00:51:06,900 --> 00:51:08,910
这种函数的特殊之处是，

697
00:51:08,910 --> 00:51:15,120
它们不需要考虑保存自己的返回地址，

698
00:51:15,120 --> 00:51:18,360
或者保存任何调用者保存寄存器。

699
00:51:18,650 --> 00:51:23,150
因为它们不会进行另一个函数调用，

700
00:51:23,150 --> 00:51:25,160
所以它们不需要那么小心。

701
00:51:25,400 --> 00:51:29,060
另一方面， sum_then_double 不是叶子函数，

702
00:51:29,060 --> 00:51:32,720
你可以在这里看到，它调用了 sum_to 。

703
00:51:33,530 --> 00:51:37,340
所以它需要包含函数序言，

704
00:51:37,340 --> 00:51:42,440
这里我们可以看到，从栈指针减去 16 ，

705
00:51:42,470 --> 00:51:44,780
我们在栈上腾出空间，

706
00:51:44,990 --> 00:51:49,850
我们将 sum_then_double 的返回地址存储在栈中，

707
00:51:49,970 --> 00:51:52,100
然后调用 sum_to ，

708
00:51:52,340 --> 00:51:55,220
在此之后，函数所做的全部工作就是调用 sum_to 。

709
00:51:55,220 --> 00:52:00,420
然后将 sum_to 返回的结果加倍，

710
00:52:00,600 --> 00:52:03,060
这里你可以看到函数尾声，

711
00:52:03,060 --> 00:52:07,970
我们将返回地址加载回 ra ，

712
00:52:08,060 --> 00:52:12,410
并删除栈帧，然后跳出函数。

713
00:52:13,850 --> 00:52:17,690
我们可以运行它来确保达到预期的效果。

714
00:52:20,870 --> 00:52:22,010
在这里。

715
00:52:24,160 --> 00:52:27,910
我们可以运行，如果我们运行 demo1 ，

716
00:52:27,910 --> 00:52:30,280
我们得到了总和为 15 的结果，

717
00:52:30,280 --> 00:52:33,730
我会演示 demo2 ，调用 sum_then_double ，

718
00:52:33,730 --> 00:52:39,580
它就是把 sum_to 返回的结果加倍。

719
00:52:40,600 --> 00:52:44,140
所以我有一个问题，

720
00:52:45,010 --> 00:52:51,130
如果我们删除这个函数序言和函数尾声，会发生什么，

721
00:52:51,250 --> 00:52:55,900
如果我们在 sum_then_double 这样操作，会发生什么。

722
00:52:55,900 --> 00:52:57,460
有人能预测会发生什么吗？

723
00:53:01,590 --> 00:53:07,720
我的意思是， sum_then_double 不知道它应该返回的返回地址，

724
00:53:07,930 --> 00:53:14,170
因此，在调用 sum_to 时，将覆盖 sum_then_double 的返回地址，

725
00:53:14,170 --> 00:53:18,260
在 sum_then_double 的末尾，它不会返回到最初的调用者。

726
00:53:19,330 --> 00:53:23,620
是的，没错。我们可以看看发生了什么。

727
00:53:23,650 --> 00:53:30,400
我们退出这个，退出这个，

728
00:53:31,180 --> 00:53:34,360
我们现在用损坏的函数重新编译。

729
00:53:35,650 --> 00:53:37,810
我们可以看看到底会发生什么，

730
00:53:37,810 --> 00:53:41,650
我们可以在 sum_then_double 设置中断，

731
00:53:45,290 --> 00:53:49,250
设置 tui 并让它继续运行，

732
00:53:49,250 --> 00:53:50,870
现在我们运行 demo2 ，

733
00:53:50,870 --> 00:53:52,760
好的，我们在 sum_then_double 。

734
00:53:53,280 --> 00:53:56,370
同样的，这里只有一个汇编函数，

735
00:53:56,370 --> 00:53:59,490
所以我们在汇编中查看它，

736
00:53:59,610 --> 00:54:03,060
我们输入 layout asm ， layout reg ，

737
00:54:03,060 --> 00:54:05,670
因为这种情况下，寄存器的内容也很重要。

738
00:54:06,620 --> 00:54:09,680
你将看到 gdb 中有很多信息，

739
00:54:09,890 --> 00:54:15,420
我们可以看到，

740
00:54:15,420 --> 00:54:21,000
ra 当前，返回地址指向 demo2 加 18 ，

741
00:54:21,060 --> 00:54:25,010
这表示进入函数 demo2 。

742
00:54:26,180 --> 00:54:28,130
现在我们可以运行，

743
00:54:28,160 --> 00:54:32,210
我们可以单步检查函数，看看会发生什么。

744
00:54:32,900 --> 00:54:35,660
我们调用了 sum_to ，

745
00:54:35,690 --> 00:54:40,880
可以看到返回地址被 sum_to 覆盖，

746
00:54:40,880 --> 00:54:43,160
现在指向 sum_then_double 加 4 ，

747
00:54:43,310 --> 00:54:45,410
这是对的，就是我们期望的。

748
00:54:45,500 --> 00:54:47,060
如果返回我们的代码，

749
00:54:47,060 --> 00:54:51,410
调用 sum_to ， sum_to 应该返回到这里。

750
00:54:52,750 --> 00:54:57,820
现在我们可以单步，

751
00:54:57,850 --> 00:55:01,020
然后我们再回到。

752
00:55:03,550 --> 00:55:07,390
糟糕，出错了。

753
00:55:14,490 --> 00:55:15,720
好的，我们现在在这里，

754
00:55:15,720 --> 00:55:19,950
当 sum_then_double 返回时，就像 Amir 说的，

755
00:55:20,820 --> 00:55:24,090
它没有恢复自己的返回地址，

756
00:55:24,210 --> 00:55:30,250
而是它的返回地址仍然是 sum_to 使用的，

757
00:55:30,310 --> 00:55:33,640
所以我们会进入一个无限循环，

758
00:55:33,670 --> 00:55:37,720
一遍又一遍地重复这个过程，

759
00:55:37,930 --> 00:55:39,370
永远不会结束。

760
00:55:39,900 --> 00:55:42,960
我想这很好地说明了，

761
00:55:42,960 --> 00:55:47,520
为什么跟踪调用者保存和被调用者保存寄存器很重要，

762
00:55:47,730 --> 00:55:49,020
这也展示了

763
00:55:49,020 --> 00:55:55,190
可以使用 gdb 来调试这类问题，

764
00:55:55,190 --> 00:55:57,320
让我们恢复之前的代码。

765
00:55:58,190 --> 00:56:05,690
我将使用其他一些演示代码来讲解。

766
00:56:05,780 --> 00:56:08,750
有人问，我们为什么要减去 16 ？

767
00:56:08,780 --> 00:56:11,660
这是为了给栈帧腾出空间，

768
00:56:11,930 --> 00:56:15,980
所以从栈指针中减去 16 ,

769
00:56:16,010 --> 00:56:18,080
它在内存中向下移动。

770
00:56:18,520 --> 00:56:22,660
将其向下移动，以便我们有空间容纳自己的栈帧，

771
00:56:22,660 --> 00:56:23,830
然后我们就可以把东西放在那里。

772
00:56:24,360 --> 00:56:29,280
因为这时候，我们不想覆盖栈指针上的东西，

773
00:56:29,730 --> 00:56:35,350
为什么不是 4 ，

774
00:56:36,890 --> 00:56:40,550
我们需要 16 ，因为指令是 64 位。

775
00:56:42,560 --> 00:56:48,050
是的，我想实际上不一定需要 16 ，

776
00:56:48,110 --> 00:56:52,740
但通常你会看到，

777
00:56:52,740 --> 00:56:57,750
我想不能使用 4 ，因为需要 8 ，

778
00:56:58,070 --> 00:57:02,930
不能使用 4 ，但我想你可以使用指令大小，

779
00:57:03,320 --> 00:57:05,960
而寄存器大小是 64 位，

780
00:57:06,260 --> 00:57:09,620
那么为什么通常看到 16 是因为，

781
00:57:09,620 --> 00:57:15,140
如果我们回到文档，通常有返回地址和帧指针，

782
00:57:15,140 --> 00:57:21,200
我们在这里不这样做，因为不是非常小心地处理我们的汇编。

783
00:57:22,240 --> 00:57:24,100
所以通常情况下，如果我们看内部，

784
00:57:24,100 --> 00:57:25,810
我肯定，

785
00:57:25,810 --> 00:57:28,030
如果我们看内核，就会明白这一点。

786
00:57:29,010 --> 00:57:33,150
我们查看内核数据，发现它也是 16 ，

787
00:57:33,150 --> 00:57:35,040
这通常是编译器处理后看到的。

788
00:57:37,970 --> 00:57:42,230
好的，现在我们可以。

789
00:57:44,000 --> 00:57:44,960
在这之后。

790
00:57:46,680 --> 00:57:50,490
我们修复函数，现在看一些 C 代码。

791
00:57:54,650 --> 00:57:57,770
好的，现在我们有 demo4 ，

792
00:57:57,770 --> 00:58:02,220
它基本上就是 main 函数的复制，

793
00:58:02,220 --> 00:58:05,220
是对 main 函数的模拟，

794
00:58:05,400 --> 00:58:10,620
我们有 args ，它是一个字符串数组，

795
00:58:10,740 --> 00:58:12,390
我们有 dummymain ，

796
00:58:12,390 --> 00:58:16,800
它接收一些参数和参数字符串，

797
00:58:16,800 --> 00:58:19,470
然后打印出来。

798
00:58:20,130 --> 00:58:24,390
这就是所有的，都很简单，

799
00:58:24,630 --> 00:58:29,010
如果我们在 dummymain 中设置断点，

800
00:58:31,380 --> 00:58:34,170
然后跳过来。

801
00:58:35,620 --> 00:58:40,840
好的，我们继续，运行 demo4 ，

802
00:58:40,960 --> 00:58:44,180
现在我们到了 dummymain 。

803
00:58:45,080 --> 00:58:50,570
有几件重要的事要记住，

804
00:58:51,560 --> 00:58:54,410
你可以使用 gdb 来显示栈帧，

805
00:58:54,590 --> 00:58:58,340
我们输入 i ，也就是 info ，

806
00:58:58,340 --> 00:59:04,640
如果我们输入 i frame ，可以看到很多关于当前栈帧的信息，

807
00:59:04,790 --> 00:59:06,770
可以看到，我们在栈级别 0 ，

808
00:59:06,770 --> 00:59:10,550
级别 0 意味着它[]在调用栈下面，

809
00:59:10,550 --> 00:59:14,750
我们可以转到，而且帧在这个地址。

810
00:59:15,570 --> 00:59:19,140
程序计数器也没问题，一切都很好，

811
00:59:19,200 --> 00:59:21,450
我们也有一个保存的程序计数器，

812
00:59:21,630 --> 00:59:28,680
如果我们使用这个地址跳转到 kernel.asm 。

813
00:59:29,850 --> 00:59:31,410
我们搜索那个地址，

814
00:59:31,470 --> 00:59:40,190
我们可以在 demo4 中找到那个地址，

815
00:59:40,190 --> 00:59:44,420
这正是我们希望程序返回的地址，

816
00:59:44,690 --> 00:59:48,140
它是由这个地址的帧调用的，

817
00:59:48,170 --> 00:59:49,760
源代码 C ，

818
00:59:49,790 --> 00:59:51,740
很高兴知道这一点，

819
00:59:51,740 --> 00:59:56,030
然后我们有参数列表，也是从这个地址开始的，

820
00:59:56,030 --> 01:00:01,070
当然，本例中我们的大部分参数都在寄存器中，

821
01:00:01,190 --> 01:00:04,070
我们甚至可以看到 args 是什么，

822
01:00:04,070 --> 01:00:09,490
argc 是 3 ， argv 是这个地址。

823
01:00:10,440 --> 01:00:13,920
如果我们想要更深入研究一些东西，

824
01:00:13,920 --> 01:00:16,830
可以使用 info args 命令，

825
01:00:17,680 --> 01:00:23,080
它告诉我们有关函数参数的信息，我们可以查看，

826
01:00:23,200 --> 01:00:29,650
但更重要的是，我们可以输入 backtrace 或 bt ，

827
01:00:29,860 --> 01:00:34,660
我们得到了整个栈帧的 backtrace ，

828
01:00:34,690 --> 01:00:38,170
调用栈中的所有栈帧，

829
01:00:38,170 --> 01:00:40,630
你可以在这里看到一些问题，

830
01:00:40,630 --> 01:00:42,460
当我们调用系统调用时，

831
01:00:42,850 --> 01:00:45,640
然后我们到达 usertrap 函数，

832
01:00:45,670 --> 01:00:47,530
然后是 syscall 函数，

833
01:00:47,590 --> 01:00:50,710
然后是 sys_demo ，然后是 demo4 。

834
01:00:51,510 --> 01:00:53,340
然后转到 dummymain ，

835
01:00:54,210 --> 01:00:58,350
如果我们想更深入研究这些栈中的一个，

836
01:00:58,350 --> 01:01:03,240
我们可以使用 frame 再加上一个数字，

837
01:01:03,240 --> 01:01:07,350
比如我想看看当 syscall 调用时栈帧是什么，

838
01:01:07,350 --> 01:01:08,670
我可以查看第 3 帧，

839
01:01:08,940 --> 01:01:12,180
现在，在 gdb 里面，我正在查看栈帧，

840
01:01:12,180 --> 01:01:14,910
我输入 info frame ，可以得到这个。

841
01:01:15,700 --> 01:01:18,640
这里我们得到了更多信息，

842
01:01:18,640 --> 01:01:20,980
有很多保存寄存器。

843
01:01:21,410 --> 01:01:25,070
我们有一些局部变量，

844
01:01:25,070 --> 01:01:27,440
这个函数没有任何参数，

845
01:01:27,530 --> 01:01:31,040
我们可看到程序计数器应该跳回到哪里，

846
01:01:31,160 --> 01:01:32,750
诸如此类的东西，

847
01:01:32,750 --> 01:01:35,780
所以，如果你在调试东西，这是非常有用的。

848
01:01:35,780 --> 01:01:37,130
事实上，它非常有用，

849
01:01:37,160 --> 01:01:43,580
我们让你自己实现的版本，远不如 gdb 告诉你的那样深入。

850
01:01:43,730 --> 01:01:46,820
我们在下一个实验中的练习之一，

851
01:01:46,820 --> 01:01:50,480
是实现你自己的 backtrace helper 函数，

852
01:01:50,480 --> 01:01:53,000
以便在实验内调试时使用。

853
01:01:54,110 --> 01:01:56,690
因此 backtrace 非常有用，

854
01:01:56,780 --> 01:02:00,980
如果我们输入 frame 0 ，就会返回到刚才的位置。

855
01:02:02,900 --> 01:02:04,670
如果我们想要调查，

856
01:02:04,670 --> 01:02:06,890
你可能注意到这不是很有帮助，

857
01:02:06,890 --> 01:02:10,460
argv 是字符串数组形式的字符串，

858
01:02:10,460 --> 01:02:13,700
而且我们只拿到了地址，

859
01:02:13,760 --> 01:02:17,570
如果我们想看看地址里面是什么，

860
01:02:17,570 --> 01:02:19,130
有几种方法可以做到，

861
01:02:19,250 --> 01:02:23,720
最简单的是，输入 print ， p 表示打印，

862
01:02:24,050 --> 01:02:27,920
然后我们间接引用该地址，

863
01:02:27,920 --> 01:02:29,780
我们看看地址那里是什么，

864
01:02:29,930 --> 01:02:32,390
我们这样做，

865
01:02:32,390 --> 01:02:36,820
你知道，正如预期的，我们得到了该数组的第一个元素，

866
01:02:36,820 --> 01:02:39,280
因为当它试图打印字符串时，

867
01:02:39,280 --> 01:02:42,850
就像 C 语言里，它会一直运行，直到遇到空字符，

868
01:02:43,030 --> 01:02:45,190
所以我们得到 foo ，它是数组中的第一个元素，

869
01:02:45,190 --> 01:02:49,060
如果我们想要得到更多，可以加上一个长度，

870
01:02:49,090 --> 01:02:51,150
如果我们输入 @ ，然后一个数字，

871
01:02:51,150 --> 01:02:52,740
它会上升到某个索引，

872
01:02:52,920 --> 01:02:55,410
然后我们可以看到这两个字符串，

873
01:02:55,800 --> 01:02:58,890
同样， gdb 非常聪明，

874
01:02:58,890 --> 01:03:04,320
我们甚至可以用 argc 打印整个参数数组。

875
01:03:05,590 --> 01:03:08,890
所有的信息对你来说都是可用的，

876
01:03:09,130 --> 01:03:13,360
不管你想得到什么， gdb 是很有用的工具。

877
01:03:14,290 --> 01:03:16,780
为什么 gdb ，不好意思，

878
01:03:16,780 --> 01:03:22,360
为什么编译器有时候会优化 argc 和 argv ，

879
01:03:22,360 --> 01:03:23,830
之前发生过这样的事。

880
01:03:24,340 --> 01:03:27,820
这意味着编译器找到了一种更有效的方法，

881
01:03:27,820 --> 01:03:31,570
很可能只是去掉了变量，并进行所有操作，

882
01:03:31,810 --> 01:03:36,490
你知道[]寄存器可能在 a0 上执行所有操作，

883
01:03:36,490 --> 01:03:40,820
比如，它可能只是对返回地址进行所有计算。

884
01:03:41,120 --> 01:03:42,980
这很常见，

885
01:03:42,980 --> 01:03:48,550
如果它是一个非必须的变量。

886
01:03:48,790 --> 01:03:52,480
我们不能控制编译器，

887
01:03:52,480 --> 01:03:54,310
但是如果你在平时发现这个，

888
01:03:54,460 --> 01:03:59,290
你可以尝试将编译器的优化标志设置为零，

889
01:03:59,530 --> 01:04:04,660
但即使这样，编译器仍会做一定程度的优化。

890
01:04:05,550 --> 01:04:07,320
Bibic 你举手了。

891
01:04:08,310 --> 01:04:16,380
是的，在 $1 和 $2 后面的地址是什么，就是在 foo 或 bar 之前的，

892
01:04:16,620 --> 01:04:18,180
美元符号，你说这个吗？

893
01:04:18,870 --> 01:04:23,160
是的，那个地址就是 foo 所在的地址。

894
01:04:23,640 --> 01:04:24,450
可能是吧。

895
01:04:25,990 --> 01:04:30,160
但是，然后 argv 指向其他地址，它们不应该是相同的。

896
01:04:32,080 --> 01:04:34,810
所以 argv 在这个栈上，

897
01:04:35,140 --> 01:04:39,910
如果你看这些地址，

898
01:04:39,910 --> 01:04:44,350
我们可以看到它们在内核中，就在 8000 。

899
01:04:44,760 --> 01:04:48,900
这是有道理的，因为我们静态声明，

900
01:04:48,900 --> 01:04:51,540
所以在示例程序中，如果我走到这里，它们会在这里声明。

901
01:04:52,000 --> 01:04:54,460
所以它们位于内核的某个地方，

902
01:04:54,820 --> 01:05:00,130
它们都是星号标记的， argc 或 argv 是一系列的间接引用，

903
01:05:00,130 --> 01:05:06,870
所以我想每个元素都指向自己的字符串，

904
01:05:07,020 --> 01:05:08,880
它是一个指针数组。

905
01:05:10,420 --> 01:05:10,810
我明白了。

906
01:05:17,060 --> 01:05:18,350
[]

907
01:05:24,700 --> 01:05:26,440
我也有一个问题，

908
01:05:26,470 --> 01:05:31,860
$3 版本的数组具有，

909
01:05:31,860 --> 01:05:33,690
如果看这些地址，

910
01:05:33,930 --> 01:05:36,890
第一个后缀是 38 ，

911
01:05:37,160 --> 01:05:39,500
第二个后缀是 40 ，

912
01:05:39,650 --> 01:05:42,080
第三个是 48 。

913
01:05:42,500 --> 01:05:48,710
这不是统一的，虽然三个参数的长度都是三个，

914
01:05:49,220 --> 01:05:50,900
所以为什么它们是不同的。

915
01:05:51,140 --> 01:05:55,070
嗯，我也不是百分百确定，

916
01:05:55,070 --> 01:05:58,280
我猜是为了对齐数据。

917
01:05:58,700 --> 01:06:04,100
让它们保持合理的位置，

918
01:06:04,610 --> 01:06:07,100
有人指出它们用十六进制表示是对齐的。

919
01:06:08,430 --> 01:06:15,420
好的，理解了，谢谢。

920
01:06:15,870 --> 01:06:19,590
所以有时候你看到东西放在那里很奇怪，

921
01:06:19,650 --> 01:06:22,110
可能是两个东西有不同的偏移量，

922
01:06:22,110 --> 01:06:25,740
因为并不是所有的东西都是相同大小的。

923
01:06:26,300 --> 01:06:29,510
好的，还有其他问题吗？

924
01:06:37,230 --> 01:06:40,620
好的，我们可以跳过第五个 demo 。

925
01:06:41,150 --> 01:06:46,250
gdb 的另一个有用的功能是，

926
01:06:46,460 --> 01:06:51,680
不仅有断点，还有观察点，

927
01:06:51,680 --> 01:06:55,010
并且我们还可以设置有条件的断点。

928
01:06:55,250 --> 01:07:00,200
我简单介绍一下。

929
01:07:02,160 --> 01:07:06,840
运行 demo6 以便我们可以在函数中设置，

930
01:07:06,840 --> 01:07:09,330
我们可以设置观察点，

931
01:07:09,540 --> 01:07:12,720
我想在这里你可以看到。

932
01:07:15,680 --> 01:07:22,460
向 Luke 所说的，一些东西被优化了，

933
01:07:22,670 --> 01:07:25,640
可能是因为它只是零或别的什么。

934
01:07:27,060 --> 01:07:29,280
我们可以看一下这个汇编，

935
01:07:29,280 --> 01:07:32,220
我们可以使用 layout split 。

936
01:07:32,980 --> 01:07:37,830
事实上，可以看到所有都是在栈上完成的，

937
01:07:37,830 --> 01:07:38,760
在我看来。

938
01:07:40,280 --> 01:07:43,190
不，这都是在 s0, s0 1 3 上做的，

939
01:07:43,400 --> 01:07:49,880
在这里你可以看到，编译器使用的是被调用者保存寄存器，

940
01:07:51,410 --> 01:07:57,600
这样我们可以设置，对 i 进行观察。

941
01:07:58,360 --> 01:07:59,980
好的，我们还没有声明 i ，

942
01:07:59,980 --> 01:08:05,040
因为我们不在循环里面，

943
01:08:05,220 --> 01:08:08,350
所以我们单步执行 C 代码，

944
01:08:08,350 --> 01:08:12,400
现在我们对本地变量查看信息，会看到 i ，

945
01:08:12,430 --> 01:08:16,780
我们甚至可以在 sum 设置观察点。

946
01:08:17,640 --> 01:08:23,250
现在任何时候 sum 改变都会收到通知，

947
01:08:23,250 --> 01:08:27,160
我们继续，然后这里有一个删除，

948
01:08:27,160 --> 01:08:31,480
因为有东西被删除了，所以我们不能查看它，

949
01:08:31,600 --> 01:08:37,030
我们甚至可以做一些事情，比如在 sum_to 上设置断点，

950
01:08:37,030 --> 01:08:44,190
这是一个条件断点，如果 i 现在是 1 ，

951
01:08:44,250 --> 01:08:48,720
比如，让循环在 i 是 5 的时候中断，

952
01:08:48,810 --> 01:08:51,630
如果我想专门调试这种情况，

953
01:08:51,660 --> 01:09:01,850
我可以在 sum_to 上设置一个断点，如果 i 等于 5 。

954
01:09:02,850 --> 01:09:06,540
现在我们有了这个断点，如果我们继续

955
01:09:06,570 --> 01:09:13,260
我们得到 sum_to ，可以看到它打印了第一组值，

956
01:09:13,320 --> 01:09:20,090
现在我们只在 i 符合条件时在 sum_to 上中断。

957
01:09:21,280 --> 01:09:26,380
也就是说，如果你要调试代码特定的边界条件，它会很有用，

958
01:09:26,470 --> 01:09:28,450
观察点可能会很有用，

959
01:09:28,870 --> 01:09:33,640
如果你认为某些东西不应该改变，但你怀疑它改变了，

960
01:09:33,670 --> 01:09:38,530
或者你认为每次你改变某个变量都会出问题。

961
01:09:40,000 --> 01:09:42,790
这是它的一种用法。

962
01:09:43,630 --> 01:09:47,590
今天，我最后要说的是结构体（struct），

963
01:09:47,860 --> 01:09:54,670
结构体非常重要，它会经常出现在实验里，

964
01:09:54,910 --> 01:09:56,740
还有。

965
01:09:57,310 --> 01:10:02,590
所以我会简单介绍一下结构体在内存中的布局。

966
01:10:03,750 --> 01:10:08,610
基本上，一个结构体就是一个连续的内存区域，

967
01:10:08,610 --> 01:10:09,810
所以如果我们有一些结构体。

968
01:10:11,510 --> 01:10:15,800
我们有字段一，字段二，字段三。

969
01:10:17,110 --> 01:10:18,220
当我们创建该结构体时，

970
01:10:18,220 --> 01:10:22,770
在内存中，这些字段将挨着排在一起。

971
01:10:22,770 --> 01:10:25,470
你可以把它想象成一个数组，

972
01:10:25,470 --> 01:10:28,110
但是 f1 f2 f3 可以是不同的类型。

973
01:10:28,380 --> 01:10:32,880
而且，我们可以把它们传递给函数，

974
01:10:32,880 --> 01:10:37,620
它们作为参数传递给函数，通常是通过引用，

975
01:10:37,710 --> 01:10:42,420
这里有一个结构体 person ，包含两个整型参数，

976
01:10:42,660 --> 01:10:47,990
我传递一个 person 作为参数，

977
01:10:48,320 --> 01:10:51,710
并打印出其中的一些信息，

978
01:10:52,160 --> 01:10:54,290
如果我们进入 gdb ，

979
01:10:54,290 --> 01:10:56,780
让我们删除所有的断点和观察点，

980
01:10:56,990 --> 01:11:00,980
现在我们在 printPerson 上设置一个断点，

981
01:11:01,680 --> 01:11:06,360
继续，并运行第七个 demo 。

982
01:11:07,640 --> 01:11:10,700
现在可以看到，我们在这里，如果输入 i frame ，

983
01:11:10,940 --> 01:11:14,840
我们可以看到，我们有一个参数 p 。

984
01:11:15,310 --> 01:11:19,630
事实上，如果我们打印 p ，

985
01:11:20,780 --> 01:11:24,710
甚至能辨别出这个地址是 struct person ，

986
01:11:25,910 --> 01:11:28,850
我们可以间接引用它，

987
01:11:30,210 --> 01:11:36,290
gdb 告诉我们 p 的 id 是 1215 ， age 是 22 。

988
01:11:37,660 --> 01:11:41,590
只是展示一下结构提是怎么存放的。

989
01:11:42,060 --> 01:11:47,520
你可以取这个地址，我们可以在这个地址看到，

990
01:11:48,060 --> 01:11:55,110
如果我们看。我记得很清楚。

991
01:11:57,380 --> 01:11:57,920
应该是的。

992
01:12:02,180 --> 01:12:06,860
如果我们再来一次，可以用这个来调试我们的结构体。

993
01:12:07,900 --> 01:12:15,310
在代码中，我们可以看一下结构体是怎么回事，

994
01:12:15,340 --> 01:12:18,100
因此 gdb 是非常强大的工具，

995
01:12:18,100 --> 01:12:20,590
不仅用于单步执行，

996
01:12:20,590 --> 01:12:27,430
还用于检查代码中各种类型的潜在问题。

997
01:12:27,430 --> 01:12:30,520
而且可以查看参数和栈帧，

998
01:12:30,850 --> 01:12:34,510
这在下一个实验中很有用，

999
01:12:35,270 --> 01:12:39,680
当你必须使用栈帧和汇编来编程时。

1000
01:12:40,080 --> 01:12:43,470
这就是我今天想讲的主要内容。

1001
01:12:43,470 --> 01:12:47,910
最后还有 7 分钟，

1002
01:12:47,910 --> 01:12:51,870
你们可以提任何问题。

1003
01:12:59,510 --> 01:13:01,250
我有一个离题的问题，

1004
01:13:01,880 --> 01:13:05,870
谁管理从 C 到各种指令集架构

1005
01:13:05,870 --> 01:13:10,100
的编译器的创建，

1006
01:13:10,100 --> 01:13:14,000
是指令集架构的创建者，或是类似的但三方机构。

1007
01:13:14,500 --> 01:13:19,960
我想不是指令集的创建者，

1008
01:13:19,960 --> 01:13:21,700
通常是第三方，

1009
01:13:22,060 --> 01:13:24,430
你们知道的的两个大的 C 编译器，

1010
01:13:24,430 --> 01:13:29,530
GCC 是由 GNU 基金会维护的，

1011
01:13:29,950 --> 01:13:34,990
Clang llvm 是自己维护的，

1012
01:13:34,990 --> 01:13:39,520
你可以发现， llvm 甚至是开源的，

1013
01:13:39,520 --> 01:13:44,430
这样你就能找到，专门做这件事的代码。

1014
01:13:44,550 --> 01:13:48,630
当一个像 RISC-V 的新指令集发布时，

1015
01:13:48,720 --> 01:13:53,040
调用约定文档以及所有这些指令文档一起发布，

1016
01:13:53,280 --> 01:13:55,050
我猜，

1017
01:13:55,050 --> 01:14:00,840
可能编译器设计者和指令集设计者之间有高级别的合作。

1018
01:14:01,550 --> 01:14:05,720
但简单来说，我相信是第三方维护的，

1019
01:14:05,720 --> 01:14:09,710
很可能与指令集制作人员的大量合作。

1020
01:14:09,770 --> 01:14:16,320
RISC-V 可能是一个例外，因为它来自一个研究项目，

1021
01:14:16,440 --> 01:14:20,770
他们可能也自己编写了编译器。

1022
01:14:21,410 --> 01:14:27,590
我不认为英特尔在 GCC 或 llvm 上有所投入。

1023
01:14:45,530 --> 01:14:46,490
还有其他问题吗？

1024
01:14:54,650 --> 01:14:58,790
好的，感谢收听，

1025
01:14:58,790 --> 01:15:00,890
那样的话，我想我们可以。

1026
01:15:01,790 --> 01:15:03,740
你可以在这里结束，

1027
01:15:03,800 --> 01:15:07,520
还有 5 分钟，好好休息一下。

