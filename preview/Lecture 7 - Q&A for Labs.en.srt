1
00:00:00,480 --> 00:00:03,040
okay uh good afternoon uh wherever you

2
00:00:03,040 --> 00:00:04,160
are

3
00:00:04,160 --> 00:00:06,560
uh can everybody hear me a quick sound

4
00:00:06,560 --> 00:00:09,589
check to make sure

5
00:00:09,599 --> 00:00:12,480
yup you're fine okay good thank you um

6
00:00:12,480 --> 00:00:12,799
so

7
00:00:12,799 --> 00:00:15,679
uh today uh uh we're gonna talk uh i

8
00:00:15,679 --> 00:00:16,400
don't really have

9
00:00:16,400 --> 00:00:18,800
specific agenda but basically the plan

10
00:00:18,800 --> 00:00:19,840
is to

11
00:00:19,840 --> 00:00:22,560
try to answer questions uh uh that you

12
00:00:22,560 --> 00:00:23,119
might have

13
00:00:23,119 --> 00:00:24,800
about this one the last lap or the

14
00:00:24,800 --> 00:00:27,119
previous laps

15
00:00:27,119 --> 00:00:29,359
so the approach i'm going to take uh

16
00:00:29,359 --> 00:00:30,480
today

17
00:00:30,480 --> 00:00:32,880
is i'm going to walk through the staff

18
00:00:32,880 --> 00:00:35,590
solutions

19
00:00:35,600 --> 00:00:38,960
in particular my own solutions and

20
00:00:38,960 --> 00:00:41,040
going to discuss them and hopefully as

21
00:00:41,040 --> 00:00:44,320
we go through staff solutions

22
00:00:44,320 --> 00:00:46,320
you can jump in if i don't answer a

23
00:00:46,320 --> 00:00:48,559
particular question

24
00:00:48,559 --> 00:00:51,440
or wait a little bit because i put all

25
00:00:51,440 --> 00:00:52,320
the questions

26
00:00:52,320 --> 00:00:54,879
that you've asked at least before 11am

27
00:00:54,879 --> 00:00:56,559
this morning

28
00:00:56,559 --> 00:00:58,960
in the lecture notes at the bottom and

29
00:00:58,960 --> 00:01:01,039
we'll try to go through them

30
00:01:01,039 --> 00:01:04,879
um i'm going to start

31
00:01:04,879 --> 00:01:08,400
with the page stable app because most

32
00:01:08,400 --> 00:01:11,760
questions were about the page table lab

33
00:01:11,760 --> 00:01:13,360
and partially because of joomla it was

34
00:01:13,360 --> 00:01:16,469
the the hardest laughs

35
00:01:16,479 --> 00:01:19,360
and so maybe a couple comments before

36
00:01:19,360 --> 00:01:21,439
diving into sort of the technical uh

37
00:01:21,439 --> 00:01:23,759
part of this uh let's talk a little bit

38
00:01:23,759 --> 00:01:24,560
about

39
00:01:24,560 --> 00:01:30,390
uh the page table live in general

40
00:01:30,400 --> 00:01:32,960
and you know as you probably observed

41
00:01:32,960 --> 00:01:38,830
you know there's actually a few lines of

42
00:01:38,840 --> 00:01:41,119
code uh

43
00:01:41,119 --> 00:01:44,320
in terms of the solution but it

44
00:01:44,320 --> 00:01:44,960
unfortunately

45
00:01:44,960 --> 00:01:52,830
has you know hard to debug

46
00:01:52,840 --> 00:01:55,119
problems

47
00:01:55,119 --> 00:01:58,469
and you know there's

48
00:01:58,479 --> 00:02:00,479
one reason is that you know when

49
00:02:00,479 --> 00:02:01,920
actually the block shows up

50
00:02:01,920 --> 00:02:04,560
uh you know the outcomes are uh pretty

51
00:02:04,560 --> 00:02:05,200
extreme

52
00:02:05,200 --> 00:02:07,360
like in the worst case uh probably some

53
00:02:07,360 --> 00:02:08,640
of you observed that

54
00:02:08,640 --> 00:02:11,920
in the worst case um q mu just stops

55
00:02:11,920 --> 00:02:14,160
or xv6 that stops there's no output

56
00:02:14,160 --> 00:02:15,599
being printed anymore

57
00:02:15,599 --> 00:02:18,400
uh and that's it and you know now it's

58
00:02:18,400 --> 00:02:19,280
your job to

59
00:02:19,280 --> 00:02:21,760
figure out actually what went wrong uh

60
00:02:21,760 --> 00:02:22,800
in the best case

61
00:02:22,800 --> 00:02:24,959
you know you get sort of a kernel panic

62
00:02:24,959 --> 00:02:27,200
uh but depending you know maybe just

63
00:02:27,200 --> 00:02:29,360
your starting point or for tracking down

64
00:02:29,360 --> 00:02:30,239
what the actual

65
00:02:30,239 --> 00:02:31,599
source of the problem is you know the

66
00:02:31,599 --> 00:02:33,840
panic itself is probably related to

67
00:02:33,840 --> 00:02:35,360
something else so the invariant in the

68
00:02:35,360 --> 00:02:36,560
kernel got broken

69
00:02:36,560 --> 00:02:38,480
uh but you know somewhere else earlier

70
00:02:38,480 --> 00:02:40,000
probably when you set up the page tables

71
00:02:40,000 --> 00:02:41,360
you know you did something wrong that in

72
00:02:41,360 --> 00:02:42,560
the end caused this

73
00:02:42,560 --> 00:02:44,160
pendant to go off and so you have to

74
00:02:44,160 --> 00:02:47,680
track down uh what's going on

75
00:02:47,680 --> 00:02:49,920
so fewer lines of code hard to do by

76
00:02:49,920 --> 00:02:50,879
problems

77
00:02:50,879 --> 00:02:54,000
uh and you know just a harsh environment

78
00:02:54,000 --> 00:02:57,440
uh to debug in uh if you do in the

79
00:02:57,440 --> 00:02:58,720
kernel debugging or

80
00:02:58,720 --> 00:03:00,400
you know kernel programming you know use

81
00:03:00,400 --> 00:03:01,360
the programming environment the

82
00:03:01,360 --> 00:03:04,080
debugging environment is

83
00:03:04,080 --> 00:03:06,239
unforgivable like as robin mentioned in

84
00:03:06,239 --> 00:03:07,840
the first lecture this is one of the

85
00:03:07,840 --> 00:03:08,959
hard parts

86
00:03:08,959 --> 00:03:11,680
about basically doing kernel programming

87
00:03:11,680 --> 00:03:12,879
um

88
00:03:12,879 --> 00:03:15,840
and and that's a you know just to make

89
00:03:15,840 --> 00:03:17,280
you made me feel better and this is not

90
00:03:17,280 --> 00:03:18,000
just hard for you

91
00:03:18,000 --> 00:03:19,200
you know it's actually a little hard for

92
00:03:19,200 --> 00:03:24,710
the staff

93
00:03:24,720 --> 00:03:26,720
both in terms of helping you and

94
00:03:26,720 --> 00:03:28,239
actually you know when we do these labs

95
00:03:28,239 --> 00:03:29,760
you know we make similar problems and

96
00:03:29,760 --> 00:03:30,319
you know we

97
00:03:30,319 --> 00:03:31,519
probably have more experience in

98
00:03:31,519 --> 00:03:33,599
tracking bugs down uh but you know they

99
00:03:33,599 --> 00:03:34,000
just

100
00:03:34,000 --> 00:03:36,640
they do take time uh if they're helping

101
00:03:36,640 --> 00:03:38,159
you you know the

102
00:03:38,159 --> 00:03:41,680
uh it tends to be hard too because

103
00:03:41,680 --> 00:03:43,440
there's some small fracking of code

104
00:03:43,440 --> 00:03:45,120
there's one detail something probably

105
00:03:45,120 --> 00:03:46,959
wrong and they're figuring out actually

106
00:03:46,959 --> 00:03:47,680
what that little

107
00:03:47,680 --> 00:03:50,400
detail is uh it's not that easy uh of

108
00:03:50,400 --> 00:03:51,760
course you know some of the problems

109
00:03:51,760 --> 00:03:53,360
we've seen before and we recognize you

110
00:03:53,360 --> 00:03:54,720
know for example we didn't make the same

111
00:03:54,720 --> 00:03:56,000
mistake ourselves

112
00:03:56,000 --> 00:03:57,760
uh but other ones you know you

113
00:03:57,760 --> 00:03:59,360
discovered all kinds of different ways

114
00:03:59,360 --> 00:04:01,040
of sort of breaking the kernel

115
00:04:01,040 --> 00:04:04,080
uh that we hadn't seen before

116
00:04:04,080 --> 00:04:06,879
so this is just heart and i think this

117
00:04:06,879 --> 00:04:07,680
is a you know

118
00:04:07,680 --> 00:04:11,439
our in our experience um

119
00:04:11,439 --> 00:04:13,599
this is historically always hard with a

120
00:04:13,599 --> 00:04:19,430
virtual memory

121
00:04:19,440 --> 00:04:22,240
so every time the first virtual memory

122
00:04:22,240 --> 00:04:22,639
lock

123
00:04:22,639 --> 00:04:24,960
you know comes around either in sov1 or

124
00:04:24,960 --> 00:04:27,680
its predecessor in 6828

125
00:04:27,680 --> 00:04:29,280
it has to be the case that you know that

126
00:04:29,280 --> 00:04:31,040
tends to be the hardest lap

127
00:04:31,040 --> 00:04:34,160
uh uh of all the labs and

128
00:04:34,160 --> 00:04:35,759
you know for a number of reasons one you

129
00:04:35,759 --> 00:04:38,160
know the harsh environment you know the

130
00:04:38,160 --> 00:04:42,000
uh the bugs are spectacular and uh

131
00:04:42,000 --> 00:04:43,360
partly because you know you haven't had

132
00:04:43,360 --> 00:04:44,880
that much kernel programming experience

133
00:04:44,880 --> 00:04:46,720
yet and so this is sort of the first lap

134
00:04:46,720 --> 00:04:48,639
with all those things come together

135
00:04:48,639 --> 00:04:50,320
uh this year we tried to make the lab

136
00:04:50,320 --> 00:04:52,400
simpler uh in fact this is a new lab

137
00:04:52,400 --> 00:04:55,600
uh last week we did not have that lab uh

138
00:04:55,600 --> 00:04:57,120
in the hopes to actually make this

139
00:04:57,120 --> 00:04:59,280
introduction or the transition into

140
00:04:59,280 --> 00:05:02,080
virtual memory easier uh in in some ways

141
00:05:02,080 --> 00:05:02,560
i think it's

142
00:05:02,560 --> 00:05:04,080
successful in other ways you know it's

143
00:05:04,080 --> 00:05:05,919
still hard uh and so we don't really

144
00:05:05,919 --> 00:05:07,759
know maybe about the easiest way of

145
00:05:07,759 --> 00:05:08,639
actually

146
00:05:08,639 --> 00:05:10,320
introducing virtual memory programming

147
00:05:10,320 --> 00:05:11,759
is

148
00:05:11,759 --> 00:05:16,000
lab number the lab next week the lazy

149
00:05:16,000 --> 00:05:16,400
lab

150
00:05:16,400 --> 00:05:18,639
is in the lab that used to be the first

151
00:05:18,639 --> 00:05:20,160
virtual memory lab

152
00:05:20,160 --> 00:05:22,160
and my suspicion is that you'll find

153
00:05:22,160 --> 00:05:23,360
that this year

154
00:05:23,360 --> 00:05:25,600
a lot easier than the students founded

155
00:05:25,600 --> 00:05:26,560
last year

156
00:05:26,560 --> 00:05:27,840
because you now have much more

157
00:05:27,840 --> 00:05:32,950
background in virtual memory

158
00:05:32,960 --> 00:05:35,759
okay so that's uh maybe there's a good

159
00:05:35,759 --> 00:05:37,360
point to stock this is like a couple

160
00:05:37,360 --> 00:05:38,720
high level points i wanted to make

161
00:05:38,720 --> 00:05:39,360
before

162
00:05:39,360 --> 00:05:41,840
jumping into uh the more technical uh

163
00:05:41,840 --> 00:05:43,360
more the details so if you have any

164
00:05:43,360 --> 00:05:44,560
questions it's a great

165
00:05:44,560 --> 00:05:51,430
time to ask questions

166
00:05:51,440 --> 00:05:55,199
okay um then let's uh

167
00:05:55,199 --> 00:05:57,199
quickly uh you know some of you asked

168
00:05:57,199 --> 00:05:59,120
for this uh very quick review

169
00:05:59,120 --> 00:06:01,120
exactly what you know where uh you know

170
00:06:01,120 --> 00:06:03,360
what the sort of the setting is

171
00:06:03,360 --> 00:06:07,039
um and so basically the setting is page

172
00:06:07,039 --> 00:06:11,270
tables

173
00:06:11,280 --> 00:06:14,160
and again we have physical memory i will

174
00:06:14,160 --> 00:06:15,520
drive here on the

175
00:06:15,520 --> 00:06:18,400
right side uh we know the physical

176
00:06:18,400 --> 00:06:19,039
memory

177
00:06:19,039 --> 00:06:23,840
uh consists of partly about devices

178
00:06:23,840 --> 00:06:28,720
and they live you know above this ox

179
00:06:28,720 --> 00:06:31,199
you know zero zero and many many more

180
00:06:31,199 --> 00:06:32,400
generals

181
00:06:32,400 --> 00:06:37,749
and then here basically d ram chips

182
00:06:37,759 --> 00:06:40,240
and we know that the qmu actually puts

183
00:06:40,240 --> 00:06:42,000
the kernel the kernel text and data

184
00:06:42,000 --> 00:06:45,759
you know right you know here at the

185
00:06:45,759 --> 00:06:48,720
bot above ox00 so this is where the

186
00:06:48,720 --> 00:06:49,759
kernel lives

187
00:06:49,759 --> 00:06:52,000
and you know one way maybe let me erase

188
00:06:52,000 --> 00:06:52,960
this a little bit

189
00:06:52,960 --> 00:06:55,039
and use the kernel and you know

190
00:06:55,039 --> 00:06:56,400
basically literally what it means you

191
00:06:56,400 --> 00:06:57,840
know what this is what the kernel is and

192
00:06:57,840 --> 00:07:01,189
these are the

193
00:07:01,199 --> 00:07:03,039
and the instructions versions of the

194
00:07:03,039 --> 00:07:04,240
assembly instructions

195
00:07:04,240 --> 00:07:06,639
that you have seen and there's also some

196
00:07:06,639 --> 00:07:07,520
data

197
00:07:07,520 --> 00:07:12,639
structures located at these addresses

198
00:07:12,639 --> 00:07:14,960
okay so that's the memory part of it and

199
00:07:14,960 --> 00:07:16,880
then on the other side

200
00:07:16,880 --> 00:07:19,599
we got our cpu that executes

201
00:07:19,599 --> 00:07:20,400
instructions

202
00:07:20,400 --> 00:07:22,720
and so the cpu has a bunch of internal

203
00:07:22,720 --> 00:07:24,560
state

204
00:07:24,560 --> 00:07:27,280
and has some registers you know whatever

205
00:07:27,280 --> 00:07:28,400
x0 or

206
00:07:28,400 --> 00:07:31,520
r0 blah blah blah blah and you know

207
00:07:31,520 --> 00:07:33,840
maybe the program counter

208
00:07:33,840 --> 00:07:36,319
and you know when xv6 starts you know

209
00:07:36,319 --> 00:07:37,759
the

210
00:07:37,759 --> 00:07:40,199
proven counter contains this value oh

211
00:07:40,199 --> 00:07:41,919
x000

212
00:07:41,919 --> 00:07:45,440
um and um uh

213
00:07:45,440 --> 00:07:47,360
and that's the way you know the cpu

214
00:07:47,360 --> 00:07:48,879
knows that basically you know look at

215
00:07:48,879 --> 00:07:50,000
that address to find

216
00:07:50,000 --> 00:07:51,280
you know the first instruction that

217
00:07:51,280 --> 00:07:52,800
looks at the first instruction decodes

218
00:07:52,800 --> 00:07:53,840
the instruction

219
00:07:53,840 --> 00:07:55,759
and updates whatever cpu state that

220
00:07:55,759 --> 00:07:58,240
needs to be updated

221
00:07:58,240 --> 00:08:00,160
uh you know page tables add sort of a

222
00:08:00,160 --> 00:08:01,360
component to it

223
00:08:01,360 --> 00:08:03,039
uh you know the addresses you know that

224
00:08:03,039 --> 00:08:05,599
the cpu uh

225
00:08:05,599 --> 00:08:08,319
uh others or the instructions or part of

226
00:08:08,319 --> 00:08:09,360
the instructions

227
00:08:09,360 --> 00:08:10,879
like you know jump to some particular

228
00:08:10,879 --> 00:08:13,199
address you know those addresses

229
00:08:13,199 --> 00:08:15,680
are typically or most commonly or there

230
00:08:15,680 --> 00:08:16,319
will be

231
00:08:16,319 --> 00:08:19,360
virtual addresses and those virtual

232
00:08:19,360 --> 00:08:20,000
dresses

233
00:08:20,000 --> 00:08:21,919
go to that proven you know something

234
00:08:21,919 --> 00:08:24,080
typically called the mmu

235
00:08:24,080 --> 00:08:25,840
and then you translate it to physical

236
00:08:25,840 --> 00:08:27,840
addresses

237
00:08:27,840 --> 00:08:31,039
uh and uh that is allows us to index

238
00:08:31,039 --> 00:08:32,000
into

239
00:08:32,000 --> 00:08:34,800
either the i o part of the memory or the

240
00:08:34,800 --> 00:08:37,039
dram part the memory

241
00:08:37,039 --> 00:08:40,719
um the uh to control

242
00:08:40,719 --> 00:08:42,399
how this translation happens you know

243
00:08:42,399 --> 00:08:46,550
there's this satp register

244
00:08:46,560 --> 00:08:50,800
which contains uh the root of the

245
00:08:50,800 --> 00:08:52,720
page table of the current running page

246
00:08:52,720 --> 00:08:55,360
table and if there's zero

247
00:08:55,360 --> 00:08:57,200
then there's basically no translation

248
00:08:57,200 --> 00:08:58,880
going on and

249
00:08:58,880 --> 00:09:00,480
uh the virtual address is literally

250
00:09:00,480 --> 00:09:02,160
directly a physical address so when the

251
00:09:02,160 --> 00:09:04,080
processor actually starts up

252
00:09:04,080 --> 00:09:06,080
there's no value in satp and so when the

253
00:09:06,080 --> 00:09:07,120
program counter

254
00:09:07,120 --> 00:09:09,600
as an ox xox you know basically the

255
00:09:09,600 --> 00:09:11,519
physical address is also integrated

256
00:09:11,519 --> 00:09:13,519
and basically the product the cpu

257
00:09:13,519 --> 00:09:14,720
fetches the instruction

258
00:09:14,720 --> 00:09:17,200
you know from that particular location

259
00:09:17,200 --> 00:09:19,680
as soon as you know the

260
00:09:19,680 --> 00:09:22,160
uh as soon as the satp actually contains

261
00:09:22,160 --> 00:09:24,000
a non-zero value

262
00:09:24,000 --> 00:09:27,040
then uh you know for example maybe

263
00:09:27,040 --> 00:09:29,279
uh so somewhere in here it's like

264
00:09:29,279 --> 00:09:30,399
drawing make something extend the

265
00:09:30,399 --> 00:09:31,760
picture a little bit further

266
00:09:31,760 --> 00:09:34,640
uh we know that the kernel actually has

267
00:09:34,640 --> 00:09:36,000
a maximum of

268
00:09:36,000 --> 00:09:39,279
128 megabytes and so basically this is

269
00:09:39,279 --> 00:09:39,760
all

270
00:09:39,760 --> 00:09:42,959
free memory from here to there

271
00:09:42,959 --> 00:09:46,399
is free memory and free memory is

272
00:09:46,399 --> 00:09:49,360
putting on the list in catalog.c as

273
00:09:49,360 --> 00:09:50,959
you've seen before

274
00:09:50,959 --> 00:09:54,000
and so somewhere in here is also the

275
00:09:54,000 --> 00:09:54,959
root page table

276
00:09:54,959 --> 00:09:57,120
for you know a kernel page table so

277
00:09:57,120 --> 00:09:58,720
maybe here's home page

278
00:09:58,720 --> 00:10:02,069
and that is the root

279
00:10:02,079 --> 00:10:06,240
page table directory

280
00:10:06,240 --> 00:10:08,800
uh and as soon as we load that value you

281
00:10:08,800 --> 00:10:09,680
know the address

282
00:10:09,680 --> 00:10:11,440
of the physical address of that value

283
00:10:11,440 --> 00:10:13,120
into the sap address

284
00:10:13,120 --> 00:10:15,440
and register so let's say this and maybe

285
00:10:15,440 --> 00:10:16,839
this address is

286
00:10:16,839 --> 00:10:20,320
ox 7 you know ff

287
00:10:20,320 --> 00:10:22,640
blah blah blah something just below 120

288
00:10:22,640 --> 00:10:24,640
mega megabytes so in that free space of

289
00:10:24,640 --> 00:10:25,440
memory

290
00:10:25,440 --> 00:10:28,640
reload that address in satp

291
00:10:28,640 --> 00:10:32,000
then at that point

292
00:10:32,000 --> 00:10:35,600
you know the processor or the mmu will

293
00:10:35,600 --> 00:10:37,360
use the root page tables to actually do

294
00:10:37,360 --> 00:10:39,279
the translation you know from virtual to

295
00:10:39,279 --> 00:10:41,600
physical address

296
00:10:41,600 --> 00:10:43,200
um and you can think of this you know

297
00:10:43,200 --> 00:10:45,040
this particular whole thing

298
00:10:45,040 --> 00:10:47,279
sort of being a single sort of box you

299
00:10:47,279 --> 00:10:48,320
know integrated

300
00:10:48,320 --> 00:10:51,680
you know uh together

301
00:10:51,680 --> 00:10:53,040
any sort of questions about this high

302
00:10:53,040 --> 00:10:56,640
level picture before uh

303
00:10:56,640 --> 00:10:58,399
keep them going so one of the key points

304
00:10:58,399 --> 00:11:00,160
that sort of remember here is that the

305
00:11:00,160 --> 00:11:02,160
page statements themselves also live in

306
00:11:02,160 --> 00:11:08,470
memory

307
00:11:08,480 --> 00:11:11,920
okay okay so let's uh

308
00:11:11,920 --> 00:11:15,200
jump down to uh

309
00:11:15,200 --> 00:11:17,680
the first part of the page table app

310
00:11:17,680 --> 00:11:19,519
namely

311
00:11:19,519 --> 00:11:23,120
part one where you have to print uh

312
00:11:23,120 --> 00:11:27,120
the page table for the

313
00:11:27,120 --> 00:11:31,120
init program and

314
00:11:31,120 --> 00:11:33,519
and you know explain it basically in

315
00:11:33,519 --> 00:11:34,480
terms of this

316
00:11:34,480 --> 00:11:36,399
figure three four and the figure three

317
00:11:36,399 --> 00:11:40,230
fours are right here

318
00:11:40,240 --> 00:11:42,880
three four uh and this is figure three

319
00:11:42,880 --> 00:11:44,640
four shows the user address space

320
00:11:44,640 --> 00:11:46,240
so just let's look at the user address

321
00:11:46,240 --> 00:11:48,000
days for a second before we uh go into

322
00:11:48,000 --> 00:11:48,800
detail

323
00:11:48,800 --> 00:11:50,639
uh so we have the text at the bottom so

324
00:11:50,639 --> 00:11:52,079
this is the instructions

325
00:11:52,079 --> 00:11:55,440
uh of the program starting address zero

326
00:11:55,440 --> 00:11:58,079
above the instructions are you know data

327
00:11:58,079 --> 00:11:59,120
global variables

328
00:11:59,120 --> 00:12:01,279
uh live there uh then there is something

329
00:12:01,279 --> 00:12:02,240
called the guard page

330
00:12:02,240 --> 00:12:04,240
we'll talk about and then there's the

331
00:12:04,240 --> 00:12:05,519
stack of the

332
00:12:05,519 --> 00:12:07,680
user program so the kernel has its own

333
00:12:07,680 --> 00:12:09,360
stack uh but the usual or multiple

334
00:12:09,360 --> 00:12:10,079
stacks

335
00:12:10,079 --> 00:12:12,160
uh the user program has its own stack

336
00:12:12,160 --> 00:12:13,680
and above again is basically what's

337
00:12:13,680 --> 00:12:14,320
called heap

338
00:12:14,320 --> 00:12:16,079
memory you know free memory you know

339
00:12:16,079 --> 00:12:18,240
that we can you know get more

340
00:12:18,240 --> 00:12:21,040
uh memory uh using s-brick so s-break

341
00:12:21,040 --> 00:12:22,959
basically points to

342
00:12:22,959 --> 00:12:25,440
the top of the user address space and we

343
00:12:25,440 --> 00:12:26,320
want to grow it

344
00:12:26,320 --> 00:12:28,959
we call the s-break system call to grow

345
00:12:28,959 --> 00:12:29,760
the

346
00:12:29,760 --> 00:12:32,720
uh grow the top of the to grow the

347
00:12:32,720 --> 00:12:34,079
bottom part you know up

348
00:12:34,079 --> 00:12:36,800
uh into the heap we also know that at

349
00:12:36,800 --> 00:12:37,600
the

350
00:12:37,600 --> 00:12:39,519
top there from the last lecture that

351
00:12:39,519 --> 00:12:42,000
there are two pages two special pages

352
00:12:42,000 --> 00:12:44,000
uh the trampoline and the trend frame

353
00:12:44,000 --> 00:12:45,200
track frame page

354
00:12:45,200 --> 00:12:46,399
and the trampoline page you know

355
00:12:46,399 --> 00:12:48,160
contains these instructions to basically

356
00:12:48,160 --> 00:12:49,920
transition in and out of the kernel

357
00:12:49,920 --> 00:12:53,200
and the track frame is uh is a

358
00:12:53,200 --> 00:12:55,440
convenient place you know to

359
00:12:55,440 --> 00:12:57,519
store some state and when we jump into

360
00:12:57,519 --> 00:12:58,800
the uh

361
00:12:58,800 --> 00:13:00,399
kernel because we need the kernel ones

362
00:13:00,399 --> 00:13:01,920
that use the registers we can't use the

363
00:13:01,920 --> 00:13:03,600
registers because the user space program

364
00:13:03,600 --> 00:13:04,320
still has them

365
00:13:04,320 --> 00:13:06,880
in use so i'm not going to talk much

366
00:13:06,880 --> 00:13:08,320
about the trend frame and the trampoline

367
00:13:08,320 --> 00:13:10,320
at all but you know they're there

368
00:13:10,320 --> 00:13:12,880
um okay so here the this picture a

369
00:13:12,880 --> 00:13:13,839
little bit below

370
00:13:13,839 --> 00:13:16,880
uh you know is actually the uh

371
00:13:16,880 --> 00:13:20,320
the printout from uh when i read it

372
00:13:20,320 --> 00:13:23,760
uh from in it like this the first

373
00:13:23,760 --> 00:13:26,880
successful call of exec right so like we

374
00:13:26,880 --> 00:13:28,399
know that in a code make some system

375
00:13:28,399 --> 00:13:29,600
called exec

376
00:13:29,600 --> 00:13:32,000
for the program in it and just at the

377
00:13:32,000 --> 00:13:32,880
end of

378
00:13:32,880 --> 00:13:35,279
exit we're printing out that page table

379
00:13:35,279 --> 00:13:36,560
now so there's a couple things that we

380
00:13:36,560 --> 00:13:37,120
uh

381
00:13:37,120 --> 00:13:39,199
many things we can observe about this

382
00:13:39,199 --> 00:13:41,519
particular page table

383
00:13:41,519 --> 00:13:44,560
so first of all you know we in addition

384
00:13:44,560 --> 00:13:45,199
to

385
00:13:45,199 --> 00:13:46,800
printing out the physical the pte's and

386
00:13:46,800 --> 00:13:48,320
the physical addresses i'm also printing

387
00:13:48,320 --> 00:13:50,079
out the flags

388
00:13:50,079 --> 00:13:52,000
uh and you can see here that here's the

389
00:13:52,000 --> 00:13:53,120
flag is one

390
00:13:53,120 --> 00:13:54,320
and it basically says that this

391
00:13:54,320 --> 00:13:57,920
translation or this uh intermediate page

392
00:13:57,920 --> 00:14:01,440
is about similar here that is an invalid

393
00:14:01,440 --> 00:14:02,880
independent page and they basically

394
00:14:02,880 --> 00:14:04,800
correspond you know to the

395
00:14:04,800 --> 00:14:06,800
level two page and then the second one

396
00:14:06,800 --> 00:14:08,720
for the corresponds to the level

397
00:14:08,720 --> 00:14:11,990
uh

398
00:14:12,000 --> 00:14:13,760
i'm sorry i just screwed the arrows

399
00:14:13,760 --> 00:14:16,800
wrong so that's why it paused 20 seconds

400
00:14:16,800 --> 00:14:19,199
okay so the top this is the top level

401
00:14:19,199 --> 00:14:20,560
page table

402
00:14:20,560 --> 00:14:22,959
uh this kind of points to this

403
00:14:22,959 --> 00:14:24,639
particular page table

404
00:14:24,639 --> 00:14:27,600
and then this points to that particular

405
00:14:27,600 --> 00:14:29,040
page table

406
00:14:29,040 --> 00:14:31,279
or that's the address we're pointing to

407
00:14:31,279 --> 00:14:32,079
sort of a short

408
00:14:32,079 --> 00:14:34,959
hand for saying uh that is the base

409
00:14:34,959 --> 00:14:37,279
address for that particular page

410
00:14:37,279 --> 00:14:39,120
and as you know each of these pages is

411
00:14:39,120 --> 00:14:40,880
496

412
00:14:40,880 --> 00:14:43,839
bytes uh that's the size of page size

413
00:14:43,839 --> 00:14:45,920
and so divided by 64

414
00:14:45,920 --> 00:14:47,519
bits you know you get five in the twelve

415
00:14:47,519 --> 00:14:49,199
entries

416
00:14:49,199 --> 00:14:52,399
um okay so we'll see is that the bottom

417
00:14:52,399 --> 00:14:53,600
part of this

418
00:14:53,600 --> 00:14:56,880
address space for init basically has

419
00:14:56,880 --> 00:15:00,560
actually all this has three pages

420
00:15:00,560 --> 00:15:03,279
only three pages uh and we've got a

421
00:15:03,279 --> 00:15:04,480
couple things that we can

422
00:15:04,480 --> 00:15:07,120
uh discern from the three pages uh we

423
00:15:07,120 --> 00:15:08,240
know that the

424
00:15:08,240 --> 00:15:10,480
so the bottom page which basically

425
00:15:10,480 --> 00:15:12,399
corresponds to virtual address zero

426
00:15:12,399 --> 00:15:14,480
uh lists physical address you know eight

427
00:15:14,480 --> 00:15:15,680
seven six uh

428
00:15:15,680 --> 00:15:18,800
four zero uh and you know we know from

429
00:15:18,800 --> 00:15:21,199
our previous picture that is somewhere

430
00:15:21,199 --> 00:15:22,079
in that

431
00:15:22,079 --> 00:15:25,199
uh free memory uh that the kernel has

432
00:15:25,199 --> 00:15:28,399
available to allocate pages from

433
00:15:28,399 --> 00:15:30,160
and then the final thing you see we see

434
00:15:30,160 --> 00:15:32,399
the flags we see the flags have one

435
00:15:32,399 --> 00:15:34,959
f so it means that the read bit is the

436
00:15:34,959 --> 00:15:36,480
val bit is set to read that is set to

437
00:15:36,480 --> 00:15:37,440
the

438
00:15:37,440 --> 00:15:39,519
w bit is set to execute data set and

439
00:15:39,519 --> 00:15:41,600
ubid is set

440
00:15:41,600 --> 00:15:44,720
so this page can contain both data and

441
00:15:44,720 --> 00:15:45,600
text

442
00:15:45,600 --> 00:15:48,639
and these permissions allow the user

443
00:15:48,639 --> 00:15:49,839
program

444
00:15:49,839 --> 00:15:52,240
to execute instructions from it read the

445
00:15:52,240 --> 00:15:53,680
right memory

446
00:15:53,680 --> 00:15:57,279
and do it from user space okay so then

447
00:15:57,279 --> 00:15:58,560
maybe the most interesting question is

448
00:15:58,560 --> 00:16:00,639
like what's up with page one

449
00:16:00,639 --> 00:16:02,639
and you know as a hint you know we see

450
00:16:02,639 --> 00:16:03,759
that page one

451
00:16:03,759 --> 00:16:06,880
uh only has f and not the u bit set

452
00:16:06,880 --> 00:16:11,749
so uh you know what is the page one

453
00:16:11,759 --> 00:16:15,350
anybody

454
00:16:15,360 --> 00:16:17,519
is it the card page yeah it's the guard

455
00:16:17,519 --> 00:16:19,519
page right

456
00:16:19,519 --> 00:16:21,920
so the guard page uh is mapped because

457
00:16:21,920 --> 00:16:24,560
it has a vmip but it has not the ubit

458
00:16:24,560 --> 00:16:25,680
set so

459
00:16:25,680 --> 00:16:28,160
any user instruction that tries to so if

460
00:16:28,160 --> 00:16:29,279
a user program

461
00:16:29,279 --> 00:16:31,360
runs off its stack so the stack grows

462
00:16:31,360 --> 00:16:33,120
from the top down

463
00:16:33,120 --> 00:16:35,519
so if it actually has more you know the

464
00:16:35,519 --> 00:16:36,959
stack is bigger than 496

465
00:16:36,959 --> 00:16:40,000
completely full and if then uh the user

466
00:16:40,000 --> 00:16:41,600
program you know pushes something on the

467
00:16:41,600 --> 00:16:42,639
stack stack on

468
00:16:42,639 --> 00:16:44,240
the ground it will grow into the guard

469
00:16:44,240 --> 00:16:47,120
page and because the view bit is not set

470
00:16:47,120 --> 00:16:49,440
uh we're going to get a page fault or a

471
00:16:49,440 --> 00:16:51,759
trap into the kernel

472
00:16:51,759 --> 00:16:54,880
because the mmu cannot translate to

473
00:16:54,880 --> 00:16:55,440
address

474
00:16:55,440 --> 00:16:58,480
uh to cannot address cannot

475
00:16:58,480 --> 00:17:00,480
translate any addresses on the guard

476
00:17:00,480 --> 00:17:02,560
page to a physical address

477
00:17:02,560 --> 00:17:05,039
because the met the not having a unit

478
00:17:05,039 --> 00:17:08,470
basically forbids the translation

479
00:17:08,480 --> 00:17:16,829
okay and what is that in page two

480
00:17:16,839 --> 00:17:19,760
any anybody

481
00:17:19,760 --> 00:17:22,720
stack yep that's the stack page and so

482
00:17:22,720 --> 00:17:23,679
again the stack page is

483
00:17:23,679 --> 00:17:26,400
uh four four four four five and 96 bytes

484
00:17:26,400 --> 00:17:26,799
and

485
00:17:26,799 --> 00:17:27,919
you would see that's completely

486
00:17:27,919 --> 00:17:30,240
elaborate in terms of permissions

487
00:17:30,240 --> 00:17:33,280
uh it has you know everything could we

488
00:17:33,280 --> 00:17:38,230
set it up tighter if we wanted to

489
00:17:38,240 --> 00:17:40,679
yeah i think you could disable the

490
00:17:40,679 --> 00:17:42,400
executable bit

491
00:17:42,400 --> 00:17:45,360
yeah you probably could execute the the

492
00:17:45,360 --> 00:17:46,880
xbit

493
00:17:46,880 --> 00:17:48,720
that would forbid having any program

494
00:17:48,720 --> 00:17:50,720
code on the stack

495
00:17:50,720 --> 00:17:52,720
so if you like generate code on the fly

496
00:17:52,720 --> 00:17:53,919
and put it on the stack you know you

497
00:17:53,919 --> 00:17:55,200
wouldn't be able to execute it

498
00:17:55,200 --> 00:17:56,640
you know that's maybe probably a good

499
00:17:56,640 --> 00:17:58,480
thing

500
00:17:58,480 --> 00:17:59,919
and so we could have been a little bit

501
00:17:59,919 --> 00:18:02,320
tighter okay

502
00:18:02,320 --> 00:18:05,200
um so that's the basically the bottom

503
00:18:05,200 --> 00:18:06,080
part of this

504
00:18:06,080 --> 00:18:09,679
uh thing uh of the page table so now

505
00:18:09,679 --> 00:18:10,880
let's look at the

506
00:18:10,880 --> 00:18:13,039
remaining entries so basically only two

507
00:18:13,039 --> 00:18:14,559
remaining entries

508
00:18:14,559 --> 00:18:17,679
um and maybe the flag bits are the most

509
00:18:17,679 --> 00:18:19,200
telling part of this

510
00:18:19,200 --> 00:18:22,960
uh so seven uh you know means you know

511
00:18:22,960 --> 00:18:23,840
read

512
00:18:23,840 --> 00:18:27,440
right and valid

513
00:18:27,440 --> 00:18:30,960
work uh and so

514
00:18:30,960 --> 00:18:34,160
what do we think that one is and maybe

515
00:18:34,160 --> 00:18:35,840
i'll do the other one too

516
00:18:35,840 --> 00:18:39,039
uh so b is i think one zero zero one so

517
00:18:39,039 --> 00:18:39,919
presumably x

518
00:18:39,919 --> 00:18:42,960
invalid so what do we think

519
00:18:42,960 --> 00:18:48,789
511 is

520
00:18:48,799 --> 00:18:54,070
anybody

521
00:18:54,080 --> 00:18:57,360
the trampoline and trap page yeah so the

522
00:18:57,360 --> 00:18:59,120
[ __ ] that's clear that's the trampoline

523
00:18:59,120 --> 00:19:00,960
uh and probably 511 is definitely the

524
00:19:00,960 --> 00:19:02,320
trampoline correct

525
00:19:02,320 --> 00:19:04,799
because it has the xbit set so we must

526
00:19:04,799 --> 00:19:06,320
be executing or we're allowing

527
00:19:06,320 --> 00:19:08,080
instruction to be executed from that

528
00:19:08,080 --> 00:19:10,559
page so that wants me to trampoline

529
00:19:10,559 --> 00:19:12,480
and we're allowing read and write you

530
00:19:12,480 --> 00:19:13,840
know to the

531
00:19:13,840 --> 00:19:16,000
uh to that page so that's probably the

532
00:19:16,000 --> 00:19:17,360
track frame page because that's the one

533
00:19:17,360 --> 00:19:18,640
we use to restore

534
00:19:18,640 --> 00:19:22,160
and uh save registers in

535
00:19:22,160 --> 00:19:24,320
okay one of the probably the thing the

536
00:19:24,320 --> 00:19:25,280
main

537
00:19:25,280 --> 00:19:26,720
the most important thing to notice is

538
00:19:26,720 --> 00:19:29,120
there's no ubit

539
00:19:29,120 --> 00:19:30,640
right there so that what does that mean

540
00:19:30,640 --> 00:19:32,160
that means that the user program can

541
00:19:32,160 --> 00:19:34,400
actually not execute the instructions

542
00:19:34,400 --> 00:19:36,880
uh that are actually at 510 and if at

543
00:19:36,880 --> 00:19:37,440
the

544
00:19:37,440 --> 00:19:40,000
trampoline page and can't be the right

545
00:19:40,000 --> 00:19:41,280
to that page

546
00:19:41,280 --> 00:19:43,039
so only the kernel can execute

547
00:19:43,039 --> 00:19:44,799
instructions from there and it can only

548
00:19:44,799 --> 00:19:47,430
read it right

549
00:19:47,440 --> 00:19:49,280
so basically like the kernel is going to

550
00:19:49,280 --> 00:19:51,120
be doing this before

551
00:19:51,120 --> 00:19:53,360
the while still using the user page

552
00:19:53,360 --> 00:19:55,120
table right that's kind of the point

553
00:19:55,120 --> 00:19:57,120
yeah exactly as you know robert

554
00:19:57,120 --> 00:19:58,320
explained in the last lecture

555
00:19:58,320 --> 00:20:00,000
this is like just for the transition

556
00:20:00,000 --> 00:20:01,760
from user to kernel and before we jump

557
00:20:01,760 --> 00:20:02,320
to

558
00:20:02,320 --> 00:20:04,880
before we load to the kernel page table

559
00:20:04,880 --> 00:20:05,600
in the satp

560
00:20:05,600 --> 00:20:07,360
register we need a little bit of you

561
00:20:07,360 --> 00:20:08,960
know the kernel needs a little bit of

562
00:20:08,960 --> 00:20:12,000
memory to actually do his job

563
00:20:12,000 --> 00:20:14,640
okay so a couple other things that may

564
00:20:14,640 --> 00:20:16,000
be interesting of this picture

565
00:20:16,000 --> 00:20:18,400
um so we all you know all these

566
00:20:18,400 --> 00:20:21,149
addresses right

567
00:20:22,310 --> 00:20:22,320
87630862471

568
00:20:22,320 --> 00:20:25,120
these are all pages or memory in that

569
00:20:25,120 --> 00:20:26,559
range

570
00:20:26,559 --> 00:20:29,039
of the kernel memory that is not you

571
00:20:29,039 --> 00:20:30,240
know that's basically free

572
00:20:30,240 --> 00:20:41,909
right are these addresses contiguous

573
00:20:41,919 --> 00:20:47,029
in physical memory

574
00:20:47,039 --> 00:20:51,520
anybody uh no they don't have to be

575
00:20:51,520 --> 00:20:53,039
no they don't have to be and they aren't

576
00:20:53,039 --> 00:20:54,799
correct you know look at this you know

577
00:20:54,799 --> 00:20:57,039
seven six four zero zero it reconfigures

578
00:20:57,039 --> 00:20:58,320
then the next address would have been

579
00:20:58,320 --> 00:20:58,720
eight

580
00:20:58,720 --> 00:21:01,360
seven six you know six five zero correct

581
00:21:01,360 --> 00:21:02,640
and it isn't

582
00:21:02,640 --> 00:21:05,280
uh so there's no one of the cool things

583
00:21:05,280 --> 00:21:06,799
about page tables is

584
00:21:06,799 --> 00:21:08,640
that even though maybe the virtual

585
00:21:08,640 --> 00:21:10,559
address space is contiguous

586
00:21:10,559 --> 00:21:12,320
the physical address space or the

587
00:21:12,320 --> 00:21:14,320
physical pages that go along with the

588
00:21:14,320 --> 00:21:16,400
contiguous virtual addresses are not

589
00:21:16,400 --> 00:21:17,760
don't have to be continuous

590
00:21:17,760 --> 00:21:18,960
and so this gives the kernel a lot of

591
00:21:18,960 --> 00:21:20,960
flexibility in terms of you know

592
00:21:20,960 --> 00:21:21,840
allocation

593
00:21:21,840 --> 00:21:25,039
and uh three pages

594
00:21:25,039 --> 00:21:28,080
okay any questions about

595
00:21:28,080 --> 00:21:32,400
this part one i had a question yeah um

596
00:21:32,400 --> 00:21:35,679
could you explain the sbr k a little um

597
00:21:35,679 --> 00:21:37,440
also if we are going to cover it in a

598
00:21:37,440 --> 00:21:39,440
future lecture then maybe we can

599
00:21:39,440 --> 00:21:42,480
like just a small yeah actually let me

600
00:21:42,480 --> 00:21:44,240
i'm going to talk about it on wednesday

601
00:21:44,240 --> 00:21:45,919
and it actually will be the topic of the

602
00:21:45,919 --> 00:21:47,280
lazy lab

603
00:21:47,280 --> 00:21:49,760
uh so let me maybe respond that question

604
00:21:49,760 --> 00:21:50,640
a little bit to wednesday

605
00:21:50,640 --> 00:21:52,799
uh and then that's not clear enough

606
00:21:52,799 --> 00:21:54,480
please ask it again

607
00:21:54,480 --> 00:21:57,510
sounds good thank

608
00:21:57,520 --> 00:22:01,280
uh you also had a question

609
00:22:01,280 --> 00:22:04,720
so uh i remember that

610
00:22:04,720 --> 00:22:06,559
the book said the trampoline and the

611
00:22:06,559 --> 00:22:08,559
trap frame were at the top of the

612
00:22:08,559 --> 00:22:09,520
address space

613
00:22:09,520 --> 00:22:12,960
yeah uh but here

614
00:22:12,960 --> 00:22:16,320
it stops at like the first the root page

615
00:22:16,320 --> 00:22:18,000
table it indexes at two five

616
00:22:18,000 --> 00:22:20,640
five not five one one yeah brilliant

617
00:22:20,640 --> 00:22:22,400
question very good i'm glad you asked it

618
00:22:22,400 --> 00:22:23,919
uh i saw it in here in

619
00:22:23,919 --> 00:22:25,760
the q a questions and i was planning to

620
00:22:25,760 --> 00:22:27,520
talk about it but of course i forgot

621
00:22:27,520 --> 00:22:29,520
so yeah what's going on here you know

622
00:22:29,520 --> 00:22:33,120
why is two five five not five eleven

623
00:22:33,120 --> 00:22:35,600
yeah you know we you know we always say

624
00:22:35,600 --> 00:22:36,880
the trampoline lives at the top of the

625
00:22:36,880 --> 00:22:38,159
address space well

626
00:22:38,159 --> 00:22:40,720
the top of the address space correct is

627
00:22:40,720 --> 00:22:41,520
you know point

628
00:22:41,520 --> 00:22:44,240
is actually entry 511 of the to the top

629
00:22:44,240 --> 00:22:45,600
level directory

630
00:22:45,600 --> 00:22:49,350
and it is only 255.

631
00:22:49,360 --> 00:22:52,559
anybody any ideas why this is the case

632
00:22:52,559 --> 00:22:55,200
we said that one bit that we said we

633
00:22:55,200 --> 00:22:56,799
were going to use we actually aren't

634
00:22:56,799 --> 00:22:59,039
using because of sign extension problems

635
00:22:59,039 --> 00:23:00,559
because it just makes it easier and we

636
00:23:00,559 --> 00:23:03,360
also don't need that memory yeah so uh

637
00:23:03,360 --> 00:23:03,840
so that's

638
00:23:03,840 --> 00:23:05,440
exactly the right answer so this is

639
00:23:05,440 --> 00:23:06,960
basically stupid

640
00:23:06,960 --> 00:23:10,480
technicality um so the virtual addresses

641
00:23:10,480 --> 00:23:13,600
are in principle uh i think 39 bits

642
00:23:13,600 --> 00:23:18,159
right and but we actually in xv6 only

643
00:23:18,159 --> 00:23:20,640
use 38 of them

644
00:23:20,640 --> 00:23:23,039
and as a result you know the top of the

645
00:23:23,039 --> 00:23:23,919
max va

646
00:23:23,919 --> 00:23:28,000
for us is basically the 255 entry

647
00:23:28,000 --> 00:23:29,919
and the reason we don't use the 39 bit

648
00:23:29,919 --> 00:23:31,840
is for no particular

649
00:23:31,840 --> 00:23:34,640
uh good reason other than that basically

650
00:23:34,640 --> 00:23:37,200
if you have the 39th bit set

651
00:23:37,200 --> 00:23:39,840
then all the remaining uh bits in the

652
00:23:39,840 --> 00:23:42,799
64-bit address have to be once

653
00:23:42,799 --> 00:23:44,320
and so we just didn't want to deal with

654
00:23:44,320 --> 00:23:45,679
this problem that if we ever set the

655
00:23:45,679 --> 00:23:48,080
39-bit we also have to set the 40 41st

656
00:23:48,080 --> 00:23:50,000
42nd to 43rd etcetera until

657
00:23:50,000 --> 00:23:55,029
the 64. um

658
00:23:55,039 --> 00:23:56,799
so that's the excavation does that make

659
00:23:56,799 --> 00:23:58,320
sense yes

660
00:23:58,320 --> 00:24:01,679
yep that's a very good very good

661
00:24:01,679 --> 00:24:04,480
application though

662
00:24:04,480 --> 00:24:06,960
so i also had a question about why is

663
00:24:06,960 --> 00:24:09,679
the text and the data on the same page

664
00:24:09,679 --> 00:24:12,000
ah very good question also uh that seems

665
00:24:12,000 --> 00:24:13,760
stupid right i mean you know why not put

666
00:24:13,760 --> 00:24:15,120
them in separate pages so that you can

667
00:24:15,120 --> 00:24:16,320
actually set the permission bits

668
00:24:16,320 --> 00:24:19,440
uh more carefully the

669
00:24:19,440 --> 00:24:22,080
main reason we're not doing that is for

670
00:24:22,080 --> 00:24:23,360
simplicity

671
00:24:23,360 --> 00:24:25,600
just makes exec more complicated and we

672
00:24:25,600 --> 00:24:29,120
wanted the simplest exact possible

673
00:24:29,120 --> 00:24:30,559
so a real operating system would you

674
00:24:30,559 --> 00:24:33,360
know not have data and text in the same

675
00:24:33,360 --> 00:24:36,880
uh page in fact we have to specify

676
00:24:36,880 --> 00:24:39,200
you know if you look at the loader flag

677
00:24:39,200 --> 00:24:40,799
uh in the make file you'll see that it

678
00:24:40,799 --> 00:24:42,400
has the desktan

679
00:24:42,400 --> 00:24:44,240
option and that forces is actually data

680
00:24:44,240 --> 00:24:46,000
and text to be in the contiguous

681
00:24:46,000 --> 00:24:53,430
and not in separate pages

682
00:24:53,440 --> 00:24:56,000
any more questions about this i had a

683
00:24:56,000 --> 00:24:58,159
follow-up question regarding the number

684
00:24:58,159 --> 00:24:58,400
of

685
00:24:58,400 --> 00:25:01,360
bits we are using um so you said we're

686
00:25:01,360 --> 00:25:03,440
using just 38 bits

687
00:25:03,440 --> 00:25:05,600
is it is like the hardware still

688
00:25:05,600 --> 00:25:07,440
provides for us to use

689
00:25:07,440 --> 00:25:10,000
39 bits but we are designing our

690
00:25:10,000 --> 00:25:11,279
operating system

691
00:25:11,279 --> 00:25:14,400
such as that we're using 38 yeah so we

692
00:25:14,400 --> 00:25:16,799
basically if the machine had more

693
00:25:16,799 --> 00:25:20,240
uh ram than two to 38

694
00:25:20,240 --> 00:25:23,360
we would not be able to use that ram now

695
00:25:23,360 --> 00:25:24,559
we're already running with we're

696
00:25:24,559 --> 00:25:26,960
assuming basically much less memory

697
00:25:26,960 --> 00:25:29,360
than 2 to 38 so it's not a big deal for

698
00:25:29,360 --> 00:25:30,480
us

699
00:25:30,480 --> 00:25:32,400
but the real operating system would have

700
00:25:32,400 --> 00:25:36,230
done better

701
00:25:36,240 --> 00:25:39,200
so just pure for simplicity we want to

702
00:25:39,200 --> 00:25:40,320
make it as easy as you

703
00:25:40,320 --> 00:25:42,159
for you as possible by reading the few

704
00:25:42,159 --> 00:25:46,870
lines of code possible

705
00:25:46,880 --> 00:25:50,720
okay yeah makes sense

706
00:25:50,720 --> 00:25:53,919
okay so now uh let's uh switch to uh

707
00:25:53,919 --> 00:25:57,120
part two and so let's

708
00:25:57,120 --> 00:25:58,880
bring up you know a picture you probably

709
00:25:58,880 --> 00:26:00,320
have looked at a lot

710
00:26:00,320 --> 00:26:03,039
uh the kernel dress space correct on the

711
00:26:03,039 --> 00:26:03,440
left

712
00:26:03,440 --> 00:26:05,760
is the virtual dress space on the right

713
00:26:05,760 --> 00:26:07,440
is physical memory

714
00:26:07,440 --> 00:26:11,039
uh you know here are your i o devices

715
00:26:11,039 --> 00:26:16,149
and then from here on is you know dram

716
00:26:16,159 --> 00:26:18,480
and you know and basically running until

717
00:26:18,480 --> 00:26:19,600
what actually uh

718
00:26:19,600 --> 00:26:24,320
120 28 megabytes um

719
00:26:24,320 --> 00:26:25,919
for us because we just assume that

720
00:26:25,919 --> 00:26:27,520
there's no more than 250

721
00:26:27,520 --> 00:26:30,400
to fix 128 megabytes of memory and so

722
00:26:30,400 --> 00:26:31,840
this part of the physical memory is the

723
00:26:31,840 --> 00:26:33,840
free memory

724
00:26:33,840 --> 00:26:36,880
and that from now is where the kernel uh

725
00:26:36,880 --> 00:26:39,600
whoops i drew it a little bit wrong let

726
00:26:39,600 --> 00:26:41,440
me be a little bit more careful

727
00:26:41,440 --> 00:26:45,520
uh so here we basically have you know

728
00:26:45,520 --> 00:26:46,159
kernel

729
00:26:46,159 --> 00:26:49,039
text and data and then you know this

730
00:26:49,039 --> 00:26:50,720
memory above you know it's basically

731
00:26:50,720 --> 00:26:53,279
a memory that the kernel allocator has

732
00:26:53,279 --> 00:26:54,000
and from there

733
00:26:54,000 --> 00:26:56,080
we allocate memory for user programs we

734
00:26:56,080 --> 00:26:58,159
allocate them for page tables etc

735
00:26:58,159 --> 00:26:59,360
the kernel allocates everything from

736
00:26:59,360 --> 00:27:02,000
there until it runs out of memory when

737
00:27:02,000 --> 00:27:04,000
it runs out it gets to 128

738
00:27:04,000 --> 00:27:05,919
megabytes and then it starts returning

739
00:27:05,919 --> 00:27:08,640
errors or system calls

740
00:27:08,640 --> 00:27:12,320
okay good uh so let me

741
00:27:12,320 --> 00:27:16,640
pull up my uh first part correct in some

742
00:27:16,640 --> 00:27:18,559
sense of this assignment again it was

743
00:27:18,559 --> 00:27:20,799
the part two of the assignment was just

744
00:27:20,799 --> 00:27:23,110
to

745
00:27:23,120 --> 00:27:26,880
run with or copy the kernel page table

746
00:27:26,880 --> 00:27:29,200
so that every process

747
00:27:29,200 --> 00:27:34,000
has its own kernel page tables

748
00:27:34,000 --> 00:27:36,159
and that was the basically that's the

749
00:27:36,159 --> 00:27:37,679
the assignment here so let me

750
00:27:37,679 --> 00:27:39,039
before jumping into the code let me

751
00:27:39,039 --> 00:27:41,039
actually say a couple things uh

752
00:27:41,039 --> 00:27:44,399
more general things about it uh so

753
00:27:44,399 --> 00:27:48,880
part two

754
00:27:48,880 --> 00:27:52,480
um uh

755
00:27:52,480 --> 00:27:53,760
and you know maybe the first question

756
00:27:53,760 --> 00:27:55,600
really that uh sort of getting get your

757
00:27:55,600 --> 00:27:56,880
head around is like in

758
00:27:56,880 --> 00:27:58,240
some way it's gonna do something trivial

759
00:27:58,240 --> 00:27:59,600
right we already have a kernel page

760
00:27:59,600 --> 00:28:01,679
table we just have to make end copies of

761
00:28:01,679 --> 00:28:03,200
it you know for one copy for each

762
00:28:03,200 --> 00:28:04,720
particular process

763
00:28:04,720 --> 00:28:07,120
um and you might say well you know how

764
00:28:07,120 --> 00:28:08,000
hard can it be

765
00:28:08,000 --> 00:28:09,120
uh and it turns out i think it was a

766
00:28:09,120 --> 00:28:11,440
little bit harder for a couple reasons

767
00:28:11,440 --> 00:28:14,880
some good ones some less good ones uh

768
00:28:14,880 --> 00:28:20,470
hardening seams

769
00:28:20,480 --> 00:28:23,360
and you know one reason is that uh you

770
00:28:23,360 --> 00:28:26,870
know the xv6 code

771
00:28:26,880 --> 00:28:29,360
is sort of specialized for one kernel

772
00:28:29,360 --> 00:28:38,789
page table

773
00:28:38,799 --> 00:28:42,840
and you know you saw that in kvm init

774
00:28:42,840 --> 00:28:45,200
uh and so that makes it a

775
00:28:45,200 --> 00:28:48,080
little bit uh uh you know generalizing

776
00:28:48,080 --> 00:28:48,559
you know

777
00:28:48,559 --> 00:28:49,679
actually a little bit of work because

778
00:28:49,679 --> 00:28:52,480
you actually have to modify the xv6 code

779
00:28:52,480 --> 00:28:56,399
um kvm in it as you also saw

780
00:28:56,399 --> 00:28:58,880
is not the full story you know for

781
00:28:58,880 --> 00:29:00,000
building the

782
00:29:00,000 --> 00:29:02,320
uh page table uh for the kernel you know

783
00:29:02,320 --> 00:29:04,640
there's also stuff in prop unit

784
00:29:04,640 --> 00:29:06,480
that actually adds mappings to the

785
00:29:06,480 --> 00:29:07,919
kernel page table

786
00:29:07,919 --> 00:29:10,000
and there's even something in uh virgi

787
00:29:10,000 --> 00:29:12,000
io disk

788
00:29:12,000 --> 00:29:13,520
that actually interacts you know with

789
00:29:13,520 --> 00:29:16,159
the kernel page table

790
00:29:16,159 --> 00:29:18,240
so basically there's no one single place

791
00:29:18,240 --> 00:29:20,000
in the kernel where actually the kernel

792
00:29:20,000 --> 00:29:22,799
page table actually is built

793
00:29:22,799 --> 00:29:24,880
then the third reason why you know this

794
00:29:24,880 --> 00:29:26,240
is slightly complicated is because you

795
00:29:26,240 --> 00:29:29,120
also have to deal with cleanup

796
00:29:29,120 --> 00:29:31,679
uh so there's the aspect of actually

797
00:29:31,679 --> 00:29:33,039
creating these copies

798
00:29:33,039 --> 00:29:36,080
but whenever time a user process exit we

799
00:29:36,080 --> 00:29:37,440
also have to clean up

800
00:29:37,440 --> 00:29:40,159
those uh page samples that were in use

801
00:29:40,159 --> 00:29:42,240
because we want to return them to the

802
00:29:42,240 --> 00:29:44,000
pool of free memory so that we can use

803
00:29:44,000 --> 00:29:45,840
them later uh so that we can keep on

804
00:29:45,840 --> 00:29:48,159
running processes

805
00:29:48,159 --> 00:29:51,679
and so that is the and that makes

806
00:29:51,679 --> 00:29:52,880
things a little bit complicated because

807
00:29:52,880 --> 00:29:54,080
you know we got to be a little bit

808
00:29:54,080 --> 00:29:55,600
careful in actually

809
00:29:55,600 --> 00:29:57,840
freeing the kernel page table or a copy

810
00:29:57,840 --> 00:29:59,120
of the kernel page table

811
00:29:59,120 --> 00:30:00,559
but you certainly don't want to you know

812
00:30:00,559 --> 00:30:03,039
free uh memory that's actually still in

813
00:30:03,039 --> 00:30:04,720
use or page table entries that's still

814
00:30:04,720 --> 00:30:06,880
in use by other page tables

815
00:30:06,880 --> 00:30:08,880
so we've got to be careful there and

816
00:30:08,880 --> 00:30:10,080
then uh

817
00:30:10,080 --> 00:30:12,080
you know basically it's easy to make a

818
00:30:12,080 --> 00:30:14,240
small error

819
00:30:14,240 --> 00:30:15,919
in your page table when you copy those

820
00:30:15,919 --> 00:30:17,279
page tables

821
00:30:17,279 --> 00:30:19,679
uh you know if you get a little thing uh

822
00:30:19,679 --> 00:30:21,200
you know visually you get a hard

823
00:30:21,200 --> 00:30:24,230
hard buck

824
00:30:24,240 --> 00:30:26,480
and and one of the problems here is i

825
00:30:26,480 --> 00:30:27,919
said a little bit earlier is

826
00:30:27,919 --> 00:30:29,919
uh the hard part shows up and much much

827
00:30:29,919 --> 00:30:31,760
much later right you built the kernel

828
00:30:31,760 --> 00:30:33,200
page table so you built a copy of the

829
00:30:33,200 --> 00:30:33,760
kernel

830
00:30:33,760 --> 00:30:36,720
page table all looks fine you look

831
00:30:36,720 --> 00:30:38,399
loaded in satp

832
00:30:38,399 --> 00:30:40,240
then even maybe the kernel runs for a

833
00:30:40,240 --> 00:30:42,480
little while and then it panics

834
00:30:42,480 --> 00:30:44,159
and it turns out you know the reason it

835
00:30:44,159 --> 00:30:45,679
panics is because you know you made some

836
00:30:45,679 --> 00:30:46,559
small mistake

837
00:30:46,559 --> 00:30:49,919
in the page table a long long time ago

838
00:30:49,919 --> 00:30:50,720
and so this is

839
00:30:50,720 --> 00:30:53,440
one reason why it makes uh makes life

840
00:30:53,440 --> 00:30:54,000
difficult

841
00:30:54,000 --> 00:30:57,039
uh for kernel programming

842
00:30:57,039 --> 00:30:58,480
and you know and basically you know

843
00:30:58,480 --> 00:30:59,919
these hard debugs basically are just

844
00:30:59,919 --> 00:31:01,279
time consuming

845
00:31:01,279 --> 00:31:11,509
to track down

846
00:31:11,519 --> 00:31:12,880
because at the point that the bug no it

847
00:31:12,880 --> 00:31:15,039
happens uh that's actually not the real

848
00:31:15,039 --> 00:31:15,760
cause

849
00:31:15,760 --> 00:31:17,760
uh of the bug but about you know the

850
00:31:17,760 --> 00:31:19,440
real cost is you know someone was way

851
00:31:19,440 --> 00:31:20,720
earlier when you set up

852
00:31:20,720 --> 00:31:23,750
the page tables

853
00:31:23,760 --> 00:31:27,440
okay uh so it turns out

854
00:31:27,440 --> 00:31:30,559
uh there's two approaches to go about it

855
00:31:30,559 --> 00:31:34,080
now to this lap which is sort of uh

856
00:31:34,080 --> 00:31:38,789
two solution approaches

857
00:31:38,799 --> 00:31:40,320
in fact some of you have probably used a

858
00:31:40,320 --> 00:31:42,000
mixture of them uh

859
00:31:42,000 --> 00:31:44,399
but one you know approach what i'll call

860
00:31:44,399 --> 00:31:47,519
the copy approach

861
00:31:47,519 --> 00:31:48,960
and the copy approach basically

862
00:31:48,960 --> 00:31:50,640
literally makes a copy to the kernel

863
00:31:50,640 --> 00:31:51,519
page table

864
00:31:51,519 --> 00:31:54,640
uh so every time you uh

865
00:31:54,640 --> 00:31:56,880
you can do a kernel page table you

866
00:31:56,880 --> 00:31:58,720
allocate pages for the page table

867
00:31:58,720 --> 00:32:02,880
you fill them in et cetera et cetera

868
00:32:02,880 --> 00:32:05,919
and there's a that's one approach the

869
00:32:05,919 --> 00:32:08,320
second approach

870
00:32:08,320 --> 00:32:14,000
is basically to share

871
00:32:14,000 --> 00:32:16,880
uh the kernel page table and in this

872
00:32:16,880 --> 00:32:17,840
case what you do

873
00:32:17,840 --> 00:32:19,600
is like instead of trying to make a

874
00:32:19,600 --> 00:32:21,679
literally nice clean copy of the kernel

875
00:32:21,679 --> 00:32:22,720
page tables

876
00:32:22,720 --> 00:32:24,159
you share all the entries that are

877
00:32:24,159 --> 00:32:27,279
basically uh are going to be unmodified

878
00:32:27,279 --> 00:32:29,039
uh you know from the assignment that

879
00:32:29,039 --> 00:32:30,720
basically anything above

880
00:32:30,720 --> 00:32:32,720
uh claimed or the click address is

881
00:32:32,720 --> 00:32:34,559
actually going to be unchanged or

882
00:32:34,559 --> 00:32:36,000
unmodified you know there's nothing you

883
00:32:36,000 --> 00:32:37,279
have to load there

884
00:32:37,279 --> 00:32:39,600
uh in part three so you know what

885
00:32:39,600 --> 00:32:40,399
basically

886
00:32:40,399 --> 00:32:42,720
all the entries from above zero are

887
00:32:42,720 --> 00:32:44,799
probably identical and so you can share

888
00:32:44,799 --> 00:32:46,960
those entries if you will

889
00:32:46,960 --> 00:32:49,760
um so both approaches are i think

890
00:32:49,760 --> 00:32:51,039
perfectly fine

891
00:32:51,039 --> 00:32:54,080
uh it's not abundantly clear which one

892
00:32:54,080 --> 00:32:55,519
is the better one

893
00:32:55,519 --> 00:32:58,880
my solutions take this approach uh

894
00:32:58,880 --> 00:33:01,600
and um i don't really have a great

895
00:33:01,600 --> 00:33:02,720
justification for it

896
00:33:02,720 --> 00:33:06,320
other than maybe uh you know partially

897
00:33:06,320 --> 00:33:07,279
laziness

898
00:33:07,279 --> 00:33:08,960
i didn't want to think too hard what's

899
00:33:08,960 --> 00:33:10,399
in the kernel page table and

900
00:33:10,399 --> 00:33:11,840
so i figured all the things that are

901
00:33:11,840 --> 00:33:13,600
going to stay the same why do you just

902
00:33:13,600 --> 00:33:14,640
i'm copying them over

903
00:33:14,640 --> 00:33:17,760
or you know copy the ptes over

904
00:33:17,760 --> 00:33:19,279
and then i have to think too hard what

905
00:33:19,279 --> 00:33:20,640
actually isn't that part of the kernel

906
00:33:20,640 --> 00:33:23,430
address space

907
00:33:23,440 --> 00:33:25,600
and you know leads to short codes but

908
00:33:25,600 --> 00:33:26,799
you know i'm not sure it actually is

909
00:33:26,799 --> 00:33:28,399
shorter than for example the copy

910
00:33:28,399 --> 00:33:29,519
solution

911
00:33:29,519 --> 00:33:30,720
but it's important to realize that

912
00:33:30,720 --> 00:33:32,559
basically there are two different ways

913
00:33:32,559 --> 00:33:34,159
of going about this particular

914
00:33:34,159 --> 00:33:38,399
uh problem in either case uh

915
00:33:38,399 --> 00:33:40,320
you know whatever approach you use you

916
00:33:40,320 --> 00:33:41,440
know there's sort of an implementation

917
00:33:41,440 --> 00:33:42,799
strategy to it

918
00:33:42,799 --> 00:33:44,559
and you know the implementation strategy

919
00:33:44,559 --> 00:33:46,000
that i use for almost any

920
00:33:46,000 --> 00:33:49,200
uh kernel program is to do everything in

921
00:33:49,200 --> 00:33:53,039
baby steps

922
00:33:53,039 --> 00:33:55,440
so i might have sort of a general plan

923
00:33:55,440 --> 00:33:57,360
in my head about how i go over the whole

924
00:33:57,360 --> 00:33:59,279
uh you know all the changes i want to

925
00:33:59,279 --> 00:34:01,360
make uh but once i start making those

926
00:34:01,360 --> 00:34:02,000
changes

927
00:34:02,000 --> 00:34:04,880
i do like one or two and then make sure

928
00:34:04,880 --> 00:34:07,360
that those work first and then

929
00:34:07,360 --> 00:34:10,480
uh you know keep going and the other

930
00:34:10,480 --> 00:34:12,159
thing i do is mostly here's as a

931
00:34:12,159 --> 00:34:18,629
strategy is keep the existing code

932
00:34:18,639 --> 00:34:20,560
don't really modify it certainly not

933
00:34:20,560 --> 00:34:22,800
initially i just add code

934
00:34:22,800 --> 00:34:25,919
and switch to this new code and then the

935
00:34:25,919 --> 00:34:27,200
little baby steps and the reason i'm

936
00:34:27,200 --> 00:34:29,280
doing that is that i can easily compare

937
00:34:29,280 --> 00:34:32,079
all the new code and i always have a

938
00:34:32,079 --> 00:34:33,919
working old solution that i can just

939
00:34:33,919 --> 00:34:34,960
roll back to

940
00:34:34,960 --> 00:34:36,480
uh so in case of some strange bugs

941
00:34:36,480 --> 00:34:38,079
happens then i can go back maybe one

942
00:34:38,079 --> 00:34:39,040
step

943
00:34:39,040 --> 00:34:41,679
uh and then try again and see figure out

944
00:34:41,679 --> 00:34:43,119
like actually where my reasoning was

945
00:34:43,119 --> 00:34:44,480
wrong

946
00:34:44,480 --> 00:34:47,679
uh but basically you know baby steps

947
00:34:47,679 --> 00:34:49,119
what partly because these blocks are so

948
00:34:49,119 --> 00:34:52,950
hard to track down

949
00:34:52,960 --> 00:34:57,040
okay let me switch to

950
00:34:57,040 --> 00:35:00,160
like code um so

951
00:35:00,160 --> 00:35:03,760
maybe start in vm dot cd uh so

952
00:35:03,760 --> 00:35:08,320
the here's the uh existing kvm in it

953
00:35:08,320 --> 00:35:10,960
uh and actually uh can everybody see the

954
00:35:10,960 --> 00:35:12,480
code

955
00:35:12,480 --> 00:35:16,079
okay okay uh

956
00:35:16,079 --> 00:35:19,280
and um the

957
00:35:19,280 --> 00:35:21,040
assignment that we are asked for correct

958
00:35:21,040 --> 00:35:23,040
is to make a copy of it

959
00:35:23,040 --> 00:35:26,320
and the way i do that is

960
00:35:26,320 --> 00:35:39,670
let me see where that is

961
00:35:39,680 --> 00:35:42,560
so here's my uvm create that was the

962
00:35:42,560 --> 00:35:44,400
boring part that's basically creating

963
00:35:44,400 --> 00:35:46,640
uh allocating to the top level page

964
00:35:46,640 --> 00:35:48,320
directory for the l2

965
00:35:48,320 --> 00:35:51,520
page directory and then uh

966
00:35:51,520 --> 00:35:54,160
here's my kvm the sort of equivalent of

967
00:35:54,160 --> 00:35:56,079
kvm init

968
00:35:56,079 --> 00:35:57,839
so i get the top level page directory

969
00:35:57,839 --> 00:35:59,520
here uh

970
00:35:59,520 --> 00:36:02,960
in this site then basically i copy

971
00:36:02,960 --> 00:36:06,079
the top 511 entries

972
00:36:06,079 --> 00:36:07,839
from the kernel page table that was

973
00:36:07,839 --> 00:36:09,599
already set up by

974
00:36:09,599 --> 00:36:13,359
kvm in it and so that gives me most

975
00:36:13,359 --> 00:36:16,560
of the kernel page table and then uh

976
00:36:16,560 --> 00:36:19,599
i just have to map in all the devices

977
00:36:19,599 --> 00:36:20,860
that live

978
00:36:20,860 --> 00:36:23,359
[Music]

979
00:36:23,359 --> 00:36:26,160
in the zero entry uh because the zero

980
00:36:26,160 --> 00:36:27,119
entries the entry that we're going to

981
00:36:27,119 --> 00:36:28,800
modify later or we're going to map the

982
00:36:28,800 --> 00:36:30,720
user pages into the bottom

983
00:36:30,720 --> 00:36:32,640
um and there's a couple devices that

984
00:36:32,640 --> 00:36:34,320
live in that in the zero of entry and

985
00:36:34,320 --> 00:36:36,160
those you know devices need to be added

986
00:36:36,160 --> 00:36:38,400
you know to the uh

987
00:36:38,400 --> 00:36:42,079
to this poor process page table kernel

988
00:36:42,079 --> 00:36:44,000
page table

989
00:36:44,000 --> 00:36:46,560
and so maybe if i come back to this

990
00:36:46,560 --> 00:36:51,190
picture earlier

991
00:36:51,200 --> 00:36:54,160
so let me pull up the kernel page table

992
00:36:54,160 --> 00:36:56,790
again

993
00:36:56,800 --> 00:37:00,160
uh yeah maybe this picture is good

994
00:37:00,160 --> 00:37:02,720
as any uh so if you think about my

995
00:37:02,720 --> 00:37:03,599
solution

996
00:37:03,599 --> 00:37:06,960
uh basically these entries

997
00:37:06,960 --> 00:37:10,240
i just share with the existing kernel

998
00:37:10,240 --> 00:37:11,119
page table

999
00:37:11,119 --> 00:37:14,000
so i don't have to allocate any l1 or l2

1000
00:37:14,000 --> 00:37:16,079
or l0 levels

1001
00:37:16,079 --> 00:37:18,240
they already exist and the only thing i

1002
00:37:18,240 --> 00:37:19,680
do is basically literally

1003
00:37:19,680 --> 00:37:22,960
copy that ptd entry and so only

1004
00:37:22,960 --> 00:37:26,000
the bottom part or the bottom

1005
00:37:26,000 --> 00:37:28,160
entry that's the piece i need to

1006
00:37:28,160 --> 00:37:29,599
actually rebuild

1007
00:37:29,599 --> 00:37:31,680
or copy explicitly instead of copying

1008
00:37:31,680 --> 00:37:32,800
ptes

1009
00:37:32,800 --> 00:37:35,760
and that covers you know the bottom one

1010
00:37:35,760 --> 00:37:36,720
gigabyte

1011
00:37:36,720 --> 00:37:40,400
right the address space it's a one page

1012
00:37:40,400 --> 00:37:45,910
coverage in a 496.

1013
00:37:45,920 --> 00:37:49,040
uh and so this you know this entry you

1014
00:37:49,040 --> 00:37:50,960
know covers five into twelve

1015
00:37:50,960 --> 00:37:54,240
but this is the two megabyte

1016
00:37:54,240 --> 00:37:57,040
and this is one gigabyte and basically

1017
00:37:57,040 --> 00:37:58,720
only one of these entries i need to fill

1018
00:37:58,720 --> 00:38:01,589
in

1019
00:38:01,599 --> 00:38:05,280
does that make sense

1020
00:38:05,280 --> 00:38:09,040
so returning to my code here basically

1021
00:38:09,040 --> 00:38:13,190
that's all i do in kvm create

1022
00:38:13,200 --> 00:38:16,400
and in case my kvm 3 is maybe no

1023
00:38:16,400 --> 00:38:18,960
they're not maybe clean the solution but

1024
00:38:18,960 --> 00:38:20,800
i take full advantage of the knowledge

1025
00:38:20,800 --> 00:38:21,440
that

1026
00:38:21,440 --> 00:38:23,359
uh i don't have to do anything from the

1027
00:38:23,359 --> 00:38:25,119
entries one to five and eleven in the

1028
00:38:25,119 --> 00:38:26,640
top eight level directory

1029
00:38:26,640 --> 00:38:28,640
the only entry i can do anything about

1030
00:38:28,640 --> 00:38:29,680
is the

1031
00:38:29,680 --> 00:38:32,320
uh bottom entry of the kernel of the the

1032
00:38:32,320 --> 00:38:33,839
top level directory

1033
00:38:33,839 --> 00:38:36,880
that points to one l1 uh entry in the

1034
00:38:36,880 --> 00:38:37,760
dot one l

1035
00:38:37,760 --> 00:38:39,920
and one tree i just need to go through

1036
00:38:39,920 --> 00:38:40,880
and

1037
00:38:40,880 --> 00:38:44,960
uh freehold the l2 or l0 entries

1038
00:38:44,960 --> 00:38:46,800
and then the end you know free l1 and

1039
00:38:46,800 --> 00:38:49,359
then the kernel page table

1040
00:38:49,359 --> 00:38:52,720
and so that's my key kvm 3 and my kvm

1041
00:38:52,720 --> 00:38:55,359
create so that allows me to create a

1042
00:38:55,359 --> 00:38:57,200
kernel page table per process

1043
00:38:57,200 --> 00:39:00,560
and then free freeze one is uh when

1044
00:39:00,560 --> 00:39:02,320
we're done

1045
00:39:02,320 --> 00:39:04,800
sorry quick question could you explain

1046
00:39:04,800 --> 00:39:06,800
again the reasoning for

1047
00:39:06,800 --> 00:39:09,040
uh only using one to five twelve and not

1048
00:39:09,040 --> 00:39:10,400
zero

1049
00:39:10,400 --> 00:39:14,880
yes uh okay so uh maybe the easy thing

1050
00:39:14,880 --> 00:39:16,560
to do actually let me go back to the

1051
00:39:16,560 --> 00:39:19,829
picture here

1052
00:39:19,839 --> 00:39:21,920
uh so we have our kernel dress space

1053
00:39:21,920 --> 00:39:26,230
correct

1054
00:39:26,240 --> 00:39:31,119
uh and you know this is ox8000

1055
00:39:31,119 --> 00:39:34,240
blah blah blah in uh

1056
00:39:34,240 --> 00:39:36,960
what entry does ox00 fall into in the

1057
00:39:36,960 --> 00:39:46,069
for the top level page directory

1058
00:39:46,079 --> 00:39:49,270
it's like the uh

1059
00:39:49,280 --> 00:39:51,920
zeroth entry no not the zero of entry

1060
00:39:51,920 --> 00:39:53,359
correct

1061
00:39:53,359 --> 00:39:56,000
so what do we know so the zero entry

1062
00:39:56,000 --> 00:39:57,520
like this entry how much does it

1063
00:39:57,520 --> 00:40:02,310
cover this entry

1064
00:40:02,320 --> 00:40:04,640
how much address space does the bottom

1065
00:40:04,640 --> 00:40:06,480
entry of the zero entry of the top-level

1066
00:40:06,480 --> 00:40:10,160
page directory cover

1067
00:40:10,160 --> 00:40:13,839
i think clint is uh it's free between

1068
00:40:13,839 --> 00:40:17,760
zero and zero x two zero zero zero

1069
00:40:17,760 --> 00:40:20,000
yes okay so maybe i think you're

1070
00:40:20,000 --> 00:40:21,359
absolutely in the right direction so

1071
00:40:21,359 --> 00:40:23,359
the bottom entry cover is one gigabyte

1072
00:40:23,359 --> 00:40:24,800
correct

1073
00:40:24,800 --> 00:40:30,550
and we know yeah like maybe i can

1074
00:40:30,560 --> 00:40:32,960
we so the bottom entry is one gigabyte

1075
00:40:32,960 --> 00:40:33,680
uh

1076
00:40:33,680 --> 00:40:36,790
which

1077
00:40:36,800 --> 00:40:38,560
in that one gigabyte is the cleaned and

1078
00:40:38,560 --> 00:40:40,240
the click correct

1079
00:40:40,240 --> 00:40:44,480
the uart and uh virtio disk i believe

1080
00:40:44,480 --> 00:40:47,280
um and then current base actually

1081
00:40:47,280 --> 00:40:48,160
already sets up

1082
00:40:48,160 --> 00:40:51,440
in a higher uh entry right and we could

1083
00:40:51,440 --> 00:40:53,040
compute it if we wanted to we could take

1084
00:40:53,040 --> 00:40:53,520
ox

1085
00:40:53,520 --> 00:40:56,720
8880 correct shift it uh 12

1086
00:40:56,720 --> 00:41:00,000
shift at nine shift at nine and i i

1087
00:41:00,000 --> 00:41:01,920
think i don't remember at the top we had

1088
00:41:01,920 --> 00:41:03,040
what it is

1089
00:41:03,040 --> 00:41:05,280
but we could try to figure it out we

1090
00:41:05,280 --> 00:41:06,079
want to actually

1091
00:41:06,079 --> 00:41:08,960
maybe we'll try this is always very

1092
00:41:08,960 --> 00:41:09,920
risky to do in

1093
00:41:09,920 --> 00:41:14,079
lecture but uh it's a gtb

1094
00:41:14,079 --> 00:41:19,349
uh i need to so let's go to

1095
00:41:19,359 --> 00:41:29,349
layout here's current base

1096
00:41:29,359 --> 00:41:32,720
uh so we could print

1097
00:41:32,720 --> 00:41:36,309
so shift is 12.

1098
00:41:36,319 --> 00:41:46,069
that gives us the uh that offsets oops

1099
00:41:46,079 --> 00:41:50,000
okay this is that so then we'll

1100
00:41:50,000 --> 00:41:54,800
shift that guy i think you can say this

1101
00:41:54,800 --> 00:41:59,040
nine right now this is the next entry

1102
00:41:59,040 --> 00:42:03,680
one more so this is entry two

1103
00:42:03,680 --> 00:42:07,680
does that make sense so we go back to

1104
00:42:07,680 --> 00:42:11,280
our picture here uh

1105
00:42:11,280 --> 00:42:15,760
basically current base is entry to

1106
00:42:15,760 --> 00:42:19,040
in the top level page directory right so

1107
00:42:19,040 --> 00:42:22,000
and we know from the third part of the

1108
00:42:22,000 --> 00:42:23,280
assignment that basically we don't

1109
00:42:23,280 --> 00:42:24,560
really have to worry about

1110
00:42:24,560 --> 00:42:28,480
anything above click

1111
00:42:28,480 --> 00:42:30,880
and you know all that stuff uh falls

1112
00:42:30,880 --> 00:42:34,390
actually in entry zero

1113
00:42:34,400 --> 00:42:39,599
okay so that answer the earlier question

1114
00:42:39,599 --> 00:42:42,710
yes thank you

1115
00:42:42,720 --> 00:42:44,480
okay so now we the only thing we have

1116
00:42:44,480 --> 00:42:46,880
left to do is you know uh

1117
00:42:46,880 --> 00:42:49,200
double check where we are going to call

1118
00:42:49,200 --> 00:42:50,400
uh this function

1119
00:42:50,400 --> 00:42:54,160
uh kvm create and

1120
00:42:54,160 --> 00:42:58,640
uh and you know that's going to be in

1121
00:42:58,640 --> 00:43:01,760
alloc proc uh

1122
00:43:01,760 --> 00:43:10,829
so and

1123
00:43:10,839 --> 00:43:12,160
that's

1124
00:43:12,160 --> 00:43:13,760
so here where's the new process

1125
00:43:13,760 --> 00:43:15,520
initialized and you know

1126
00:43:15,520 --> 00:43:17,040
i'm sure all of you do this exactly the

1127
00:43:17,040 --> 00:43:18,560
same way you know you enter

1128
00:43:18,560 --> 00:43:20,880
you allocate we declare field in the

1129
00:43:20,880 --> 00:43:22,079
proc structure

1130
00:43:22,079 --> 00:43:23,520
and basically the result of it is

1131
00:43:23,520 --> 00:43:24,560
actually what we stick in the kernel

1132
00:43:24,560 --> 00:43:26,960
page table

1133
00:43:26,960 --> 00:43:28,160
okay and then the only other thing that

1134
00:43:28,160 --> 00:43:29,359
we have to worry about is of course we

1135
00:43:29,359 --> 00:43:31,760
need to use the page table

1136
00:43:31,760 --> 00:43:34,480
and so we need to look at the scheduler

1137
00:43:34,480 --> 00:43:35,920
and basically the assignment

1138
00:43:35,920 --> 00:43:38,160
more or less told you what to do which

1139
00:43:38,160 --> 00:43:40,079
is before you switch

1140
00:43:40,079 --> 00:43:42,079
to that user process you need to switch

1141
00:43:42,079 --> 00:43:43,599
to kernel page tables

1142
00:43:43,599 --> 00:43:45,440
which basically means loading you know

1143
00:43:45,440 --> 00:43:47,599
the disk process kernel page table in

1144
00:43:47,599 --> 00:43:48,960
satp

1145
00:43:48,960 --> 00:43:52,720
and then when you're done uh switching

1146
00:43:52,720 --> 00:43:54,079
and running the other processing you

1147
00:43:54,079 --> 00:43:55,680
come back from running the other process

1148
00:43:55,680 --> 00:43:56,880
and you're going to go back and run the

1149
00:43:56,880 --> 00:43:57,680
scheduler

1150
00:43:57,680 --> 00:43:59,440
you got to switch back to the main

1151
00:43:59,440 --> 00:44:00,960
kernel page table

1152
00:44:00,960 --> 00:44:03,280
the the kernel page table because that's

1153
00:44:03,280 --> 00:44:07,109
the one that actually used by scheduler

1154
00:44:07,119 --> 00:44:09,119
and why do we need to do this switch why

1155
00:44:09,119 --> 00:44:16,710
is this important

1156
00:44:16,720 --> 00:44:19,829
anybody

1157
00:44:19,839 --> 00:44:22,400
so it picks the right kernel page table

1158
00:44:22,400 --> 00:44:23,839
uh because the sat

1159
00:44:23,839 --> 00:44:26,079
when you go to the page table entries it

1160
00:44:26,079 --> 00:44:27,599
picks the right

1161
00:44:27,599 --> 00:44:29,680
it picks the right page table to pick

1162
00:44:29,680 --> 00:44:30,720
from

1163
00:44:30,720 --> 00:44:34,720
yeah hold on

1164
00:44:34,720 --> 00:44:38,630
hold on

1165
00:44:38,640 --> 00:44:42,480
uh yeah so okay so

1166
00:44:42,480 --> 00:44:44,880
when we're stopped okay maybe another

1167
00:44:44,880 --> 00:44:46,720
way to ask this question

1168
00:44:46,720 --> 00:44:51,910
when is this kernel page table freed

1169
00:44:51,920 --> 00:44:54,240
when the user process is done so if we

1170
00:44:54,240 --> 00:44:56,960
didn't switch that would mean that

1171
00:44:56,960 --> 00:44:58,720
we could be using a page table of a

1172
00:44:58,720 --> 00:45:01,040
process that was being freed so the

1173
00:45:01,040 --> 00:45:02,960
page table was freed so we don't want to

1174
00:45:02,960 --> 00:45:04,560
be dependent on the process we're not

1175
00:45:04,560 --> 00:45:06,640
running right now yeah exactly correct

1176
00:45:06,640 --> 00:45:08,240
we can never free the page table of a

1177
00:45:08,240 --> 00:45:10,480
process that's currently running

1178
00:45:10,480 --> 00:45:12,560
uh so we have to have some plan you know

1179
00:45:12,560 --> 00:45:14,160
to actually free processes

1180
00:45:14,160 --> 00:45:15,680
uh at the point that they're not running

1181
00:45:15,680 --> 00:45:17,200
anymore and

1182
00:45:17,200 --> 00:45:19,119
your the weight system call is our way

1183
00:45:19,119 --> 00:45:20,960
out basically the way it calls

1184
00:45:20,960 --> 00:45:22,640
looks if there's any children that are

1185
00:45:22,640 --> 00:45:24,000
uh not living you know

1186
00:45:24,000 --> 00:45:25,680
that can be cleaned up and then it

1187
00:45:25,680 --> 00:45:27,200
cleans them up

1188
00:45:27,200 --> 00:45:30,720
uh and but that means that basically uh

1189
00:45:30,720 --> 00:45:32,480
when the you know payment process from

1190
00:45:32,480 --> 00:45:33,520
the police officer process we've got to

1191
00:45:33,520 --> 00:45:35,520
make absolutely sure that you know that

1192
00:45:35,520 --> 00:45:38,480
uh the page table that is loaded in the

1193
00:45:38,480 --> 00:45:39,200
satp

1194
00:45:39,200 --> 00:45:42,480
register uh is not you know one of the

1195
00:45:42,480 --> 00:45:44,400
it's not that process you know page

1196
00:45:44,400 --> 00:45:45,760
table or actually currently

1197
00:45:45,760 --> 00:45:48,319
free now it could be the case there's no

1198
00:45:48,319 --> 00:45:49,280
process running at all

1199
00:45:49,280 --> 00:45:51,280
correct and so the scheduler basically

1200
00:45:51,280 --> 00:45:52,720
has his own page table

1201
00:45:52,720 --> 00:45:54,319
uh so that you know all processes can

1202
00:45:54,319 --> 00:45:59,190
actually be cleaned up

1203
00:45:59,200 --> 00:46:05,750
does that make sense

1204
00:46:05,760 --> 00:46:09,119
uh sorry i had a question um is it

1205
00:46:09,119 --> 00:46:12,960
that you are mapping the cl int

1206
00:46:12,960 --> 00:46:16,079
into the new process kernel page tables

1207
00:46:16,079 --> 00:46:18,079
yeah i do

1208
00:46:18,079 --> 00:46:21,280
why um because i think the assignment

1209
00:46:21,280 --> 00:46:22,720
said like i only have to

1210
00:46:22,720 --> 00:46:25,839
uh user processing will not be bigger

1211
00:46:25,839 --> 00:46:26,370
than the

1212
00:46:26,370 --> 00:46:27,599
[Music]

1213
00:46:27,599 --> 00:46:30,640
clint was that it when i met i'm not

1214
00:46:30,640 --> 00:46:32,720
both the click and the clint

1215
00:46:32,720 --> 00:46:34,560
right and so but i think the assignment

1216
00:46:34,560 --> 00:46:35,920
told us that

1217
00:46:35,920 --> 00:46:40,069
so which is the lowest one i think the

1218
00:46:40,079 --> 00:46:42,000
click is the lowest one and basically

1219
00:46:42,000 --> 00:46:43,680
the sign told us that the user process

1220
00:46:43,680 --> 00:46:47,119
will not be bigger than the click

1221
00:46:47,119 --> 00:46:50,950
address okay

1222
00:46:50,960 --> 00:46:52,319
just to make it easy you know we could

1223
00:46:52,319 --> 00:46:54,160
have then uh we wanted to make it as

1224
00:46:54,160 --> 00:46:55,599
easy as possible for you clear and you

1225
00:46:55,599 --> 00:46:56,720
could have done

1226
00:46:56,720 --> 00:47:00,230
better if you wanted to

1227
00:47:00,240 --> 00:47:02,079
but you know that was the simplest thing

1228
00:47:02,079 --> 00:47:03,359
to do

1229
00:47:03,359 --> 00:47:04,400
so you have to make diffuse

1230
00:47:04,400 --> 00:47:11,520
modifications to get it to work

1231
00:47:11,520 --> 00:47:14,240
any further questions uh i have a

1232
00:47:14,240 --> 00:47:15,040
question

1233
00:47:15,040 --> 00:47:18,079
um is it possible that you can

1234
00:47:18,079 --> 00:47:21,760
copy 0 to 512 and then every time you

1235
00:47:21,760 --> 00:47:23,680
switch so you're still using like the

1236
00:47:23,680 --> 00:47:24,640
global

1237
00:47:24,640 --> 00:47:27,440
root page table except you only copy the

1238
00:47:27,440 --> 00:47:27,839
first

1239
00:47:27,839 --> 00:47:30,640
root page table and every time you

1240
00:47:30,640 --> 00:47:31,760
switch a process

1241
00:47:31,760 --> 00:47:35,119
you copy over the um users addresses

1242
00:47:35,119 --> 00:47:35,520
over

1243
00:47:35,520 --> 00:47:38,960
to yeah is that possible to do

1244
00:47:38,960 --> 00:47:40,079
in principle i think you could do

1245
00:47:40,079 --> 00:47:41,280
something like that so instead of

1246
00:47:41,280 --> 00:47:42,079
basically

1247
00:47:42,079 --> 00:47:43,599
doing when you allocate a process and

1248
00:47:43,599 --> 00:47:44,880
free it you could do it sort of

1249
00:47:44,880 --> 00:47:45,839
dynamically

1250
00:47:45,839 --> 00:47:49,760
during the scheduler switch uh

1251
00:47:49,760 --> 00:47:52,010
it seems complicated

1252
00:47:52,010 --> 00:47:53,920
[Music]

1253
00:47:53,920 --> 00:47:55,440
that might be more costly because that

1254
00:47:55,440 --> 00:47:57,119
means that every time

1255
00:47:57,119 --> 00:47:59,359
you switch between two processes you may

1256
00:47:59,359 --> 00:48:01,200
have to make a copy of parts of the

1257
00:48:01,200 --> 00:48:05,760
kernel page table and so that might be

1258
00:48:05,760 --> 00:48:08,000
perform is not an ideal thing the

1259
00:48:08,000 --> 00:48:09,520
assignment didn't really say anything

1260
00:48:09,520 --> 00:48:10,480
about it

1261
00:48:10,480 --> 00:48:12,720
uh you might have timed out in user

1262
00:48:12,720 --> 00:48:18,230
tests if you did that

1263
00:48:18,240 --> 00:48:19,520
okay i was just wondering because i

1264
00:48:19,520 --> 00:48:21,280
tried that approaching it was

1265
00:48:21,280 --> 00:48:23,280
a bad experience i was wondering if that

1266
00:48:23,280 --> 00:48:25,520
was passive i can imagine uh but

1267
00:48:25,520 --> 00:48:27,359
i i think it's in principle possible you

1268
00:48:27,359 --> 00:48:28,720
know you could just allocate a new page

1269
00:48:28,720 --> 00:48:29,760
table correctly and switch

1270
00:48:29,760 --> 00:48:32,720
any every time and upgrade when you

1271
00:48:32,720 --> 00:48:36,069
switch out

1272
00:48:36,079 --> 00:48:39,920
um i don't think it's the simplest but

1273
00:48:39,920 --> 00:48:40,240
you know

1274
00:48:40,240 --> 00:48:43,280
your principle it's possible i think

1275
00:48:43,280 --> 00:48:44,640
perhaps there's some other modifications

1276
00:48:44,640 --> 00:48:48,640
to xv6 but you know

1277
00:48:48,640 --> 00:48:56,549
any other questions

1278
00:48:56,559 --> 00:48:57,839
because the only other change that you

1279
00:48:57,839 --> 00:48:58,960
of course have to make is you use your

1280
00:48:58,960 --> 00:48:59,920
trap red

1281
00:48:59,920 --> 00:49:01,920
you got to make sure that actually you

1282
00:49:01,920 --> 00:49:03,760
run with

1283
00:49:03,760 --> 00:49:07,349
the processes kernel page table

1284
00:49:07,359 --> 00:49:11,359
okay okay so let's switch then to

1285
00:49:11,359 --> 00:49:13,230
i guess part three

1286
00:49:13,230 --> 00:49:15,359
[Music]

1287
00:49:15,359 --> 00:49:18,400
so um switch back to actually

1288
00:49:18,400 --> 00:49:24,470
uh here um

1289
00:49:24,480 --> 00:49:27,200
okay so uh actually that's maybe not a

1290
00:49:27,200 --> 00:49:28,240
helpful picture

1291
00:49:28,240 --> 00:49:37,030
let me see i okay so part three

1292
00:49:37,040 --> 00:49:40,000
uh so basically what our plan is is we

1293
00:49:40,000 --> 00:49:42,319
have our kernel page table

1294
00:49:42,319 --> 00:49:45,760
as before and uh you know we have the

1295
00:49:45,760 --> 00:49:48,400
click entries sitting somewhere

1296
00:49:48,400 --> 00:49:50,079
and what we're going to do is we're

1297
00:49:50,079 --> 00:49:52,880
going to use you know everything below

1298
00:49:52,880 --> 00:49:53,520
click

1299
00:49:53,520 --> 00:49:57,680
to actually store the user uh

1300
00:49:57,680 --> 00:49:59,200
page table where we're gonna map the

1301
00:49:59,200 --> 00:50:01,599
user page table into all the user pro or

1302
00:50:01,599 --> 00:50:03,280
the user program actually in the kernel

1303
00:50:03,280 --> 00:50:05,200
page table

1304
00:50:05,200 --> 00:50:09,190
in the bottom

1305
00:50:09,200 --> 00:50:11,520
uh and that's the goal and it was the

1306
00:50:11,520 --> 00:50:12,559
first question to ask

1307
00:50:12,559 --> 00:50:15,839
you know why the heck do that um

1308
00:50:15,839 --> 00:50:17,440
you know is there any you know any

1309
00:50:17,440 --> 00:50:19,119
advantage of it and

1310
00:50:19,119 --> 00:50:20,480
uh you know i think there may be the

1311
00:50:20,480 --> 00:50:24,160
middle easy way to

1312
00:50:24,160 --> 00:50:26,400
see why it might be interesting is to

1313
00:50:26,400 --> 00:50:28,960
core compare the copy ends

1314
00:50:28,960 --> 00:50:32,800
uh the new copying and the old copy in

1315
00:50:32,800 --> 00:50:36,800
so uh if you know so what happens in

1316
00:50:36,800 --> 00:50:40,000
copying correctly copy in copies data

1317
00:50:40,000 --> 00:50:41,920
from the user space into the kernel

1318
00:50:41,920 --> 00:50:44,710
address space

1319
00:50:44,720 --> 00:50:47,760
and but you know

1320
00:50:47,760 --> 00:50:50,079
if the kernel does not have the user

1321
00:50:50,079 --> 00:50:52,480
address space mapped

1322
00:50:52,480 --> 00:50:55,200
basically the kernel has to do this uh

1323
00:50:55,200 --> 00:50:57,119
page at the time

1324
00:50:57,119 --> 00:50:58,559
correct because the pages in virtual

1325
00:50:58,559 --> 00:51:00,559
address space might be continuous but in

1326
00:51:00,559 --> 00:51:01,760
physical address space they're not

1327
00:51:01,760 --> 00:51:02,880
continuous

1328
00:51:02,880 --> 00:51:04,160
and basically what the kernel does in

1329
00:51:04,160 --> 00:51:06,559
copy in it basically translates the

1330
00:51:06,559 --> 00:51:08,400
virtual user address

1331
00:51:08,400 --> 00:51:11,440
into a physical address

1332
00:51:11,440 --> 00:51:13,680
since the kernel has all physically

1333
00:51:13,680 --> 00:51:16,319
memory mapped with an identity mapping

1334
00:51:16,319 --> 00:51:18,559
the physical dress is also a valid

1335
00:51:18,559 --> 00:51:20,160
kernel

1336
00:51:20,160 --> 00:51:22,079
virtual dress and then it basically

1337
00:51:22,079 --> 00:51:24,160
moves whatever part of that page

1338
00:51:24,160 --> 00:51:25,680
physical page that needs to be copied

1339
00:51:25,680 --> 00:51:27,920
that actually copies it

1340
00:51:27,920 --> 00:51:30,000
and so if a data structure for example

1341
00:51:30,000 --> 00:51:32,160
spans you know to

1342
00:51:32,160 --> 00:51:34,160
a page boundary like for example this is

1343
00:51:34,160 --> 00:51:36,640
infostruct that you used in lab2 maybe

1344
00:51:36,640 --> 00:51:37,680
it spans

1345
00:51:37,680 --> 00:51:40,240
a page table boundary it will copy like

1346
00:51:40,240 --> 00:51:40,720
maybe

1347
00:51:40,720 --> 00:51:42,640
you know some bytes from the first

1348
00:51:42,640 --> 00:51:45,040
physical page and then some bytes from

1349
00:51:45,040 --> 00:51:48,839
a second physical page does that make

1350
00:51:48,839 --> 00:51:51,990
sense

1351
00:51:52,000 --> 00:51:53,920
so that's what the current copying does

1352
00:51:53,920 --> 00:51:55,680
and the goal was basically to get into a

1353
00:51:55,680 --> 00:51:57,760
new copy in

1354
00:51:57,760 --> 00:51:59,200
where the kernel program doesn't really

1355
00:51:59,200 --> 00:52:01,599
have to worry about

1356
00:52:01,599 --> 00:52:05,599
uh the physical layout basically off

1357
00:52:05,599 --> 00:52:08,079
the user address space uh and then in

1358
00:52:08,079 --> 00:52:09,920
this new copy and you know we see we

1359
00:52:09,920 --> 00:52:11,520
basically do nothing literally nothing

1360
00:52:11,520 --> 00:52:12,319
else then just

1361
00:52:12,319 --> 00:52:16,480
copy uh the from the user addresses

1362
00:52:16,480 --> 00:52:18,960
straight into the kernel uh and we don't

1363
00:52:18,960 --> 00:52:20,880
really have to call walk anymore

1364
00:52:20,880 --> 00:52:23,040
uh because we can rely on the we set up

1365
00:52:23,040 --> 00:52:24,480
the page tables correctly you know the

1366
00:52:24,480 --> 00:52:26,240
page table hardware will do the walk for

1367
00:52:26,240 --> 00:52:27,280
us

1368
00:52:27,280 --> 00:52:30,960
right and so that was the the goal

1369
00:52:30,960 --> 00:52:33,680
um and so it makes life for kernel

1370
00:52:33,680 --> 00:52:35,200
programmers a little bit easier

1371
00:52:35,200 --> 00:52:37,119
are there any other advantages to this

1372
00:52:37,119 --> 00:52:45,030
approach

1373
00:52:45,040 --> 00:52:47,440
is it also more performant because the

1374
00:52:47,440 --> 00:52:48,720
hardware is going to do

1375
00:52:48,720 --> 00:52:51,599
the walking and not software yeah well

1376
00:52:51,599 --> 00:52:52,559
one way to

1377
00:52:52,559 --> 00:52:53,359
i think there are performance

1378
00:52:53,359 --> 00:52:55,599
implications for sure uh one way to

1379
00:52:55,599 --> 00:52:57,200
think about this is that

1380
00:52:57,200 --> 00:52:59,599
in copying correct if the kernel data

1381
00:52:59,599 --> 00:53:00,240
structure

1382
00:53:00,240 --> 00:53:02,160
or the data data that we copied from

1383
00:53:02,160 --> 00:53:03,839
user space to

1384
00:53:03,839 --> 00:53:07,040
uh kernel space is big uh we have to do

1385
00:53:07,040 --> 00:53:08,960
that you know page at a time

1386
00:53:08,960 --> 00:53:10,880
right in every page we have to call this

1387
00:53:10,880 --> 00:53:12,720
function walk adder and then then does

1388
00:53:12,720 --> 00:53:14,559
the internal walking

1389
00:53:14,559 --> 00:53:17,440
and so this might actually be reasonable

1390
00:53:17,440 --> 00:53:18,079
expenses

1391
00:53:18,079 --> 00:53:20,880
expensive what examples are there

1392
00:53:20,880 --> 00:53:22,240
examples of where

1393
00:53:22,240 --> 00:53:24,960
the kernel copies a lot of data from

1394
00:53:24,960 --> 00:53:33,270
user space

1395
00:53:33,280 --> 00:53:35,599
which system call might copy a ton of

1396
00:53:35,599 --> 00:53:38,559
data from user space

1397
00:53:38,559 --> 00:53:41,200
right yeah right right you write you can

1398
00:53:41,200 --> 00:53:42,160
give an arbitrary

1399
00:53:42,160 --> 00:53:46,000
number an arbitrary buffer

1400
00:53:46,000 --> 00:53:48,640
of an arbitrary size and you know the

1401
00:53:48,640 --> 00:53:50,319
kernel wall may have to copy this you

1402
00:53:50,319 --> 00:53:51,119
know into

1403
00:53:51,119 --> 00:53:53,599
for example the file system or into a

1404
00:53:53,599 --> 00:53:54,800
pipe

1405
00:53:54,800 --> 00:53:56,480
uh and that could be you know reasonably

1406
00:53:56,480 --> 00:54:00,069
expensive

1407
00:54:00,079 --> 00:54:01,440
the other thing what is another

1408
00:54:01,440 --> 00:54:03,599
advantage i think if the user

1409
00:54:03,599 --> 00:54:05,760
uh we didn't explore that in this

1410
00:54:05,760 --> 00:54:07,359
assignment you know we assume we could

1411
00:54:07,359 --> 00:54:08,079
have

1412
00:54:08,079 --> 00:54:12,950
uh what is another advantage

1413
00:54:12,960 --> 00:54:14,960
so if you think about you know some of

1414
00:54:14,960 --> 00:54:16,800
these this code here correct when it you

1415
00:54:16,800 --> 00:54:19,040
know takes a structure out of user space

1416
00:54:19,040 --> 00:54:21,119
it copies the whole structure into

1417
00:54:21,119 --> 00:54:22,880
kernel space

1418
00:54:22,880 --> 00:54:25,040
if user space is mapped into the kernel

1419
00:54:25,040 --> 00:54:31,510
page table do we have to do that

1420
00:54:31,520 --> 00:54:33,040
for example if we have to update one

1421
00:54:33,040 --> 00:54:46,710
field of the structure

1422
00:54:46,720 --> 00:54:49,599
so with if the data structure is just

1423
00:54:49,599 --> 00:54:51,119
mapped into the kernel address case

1424
00:54:51,119 --> 00:54:52,799
right then we can just like

1425
00:54:52,799 --> 00:54:54,400
read and write you know with story

1426
00:54:54,400 --> 00:54:55,760
instructions to that particular data

1427
00:54:55,760 --> 00:54:57,200
structure and we can just update one

1428
00:54:57,200 --> 00:54:58,400
field

1429
00:54:58,400 --> 00:54:59,599
unlike what the kernel now does

1430
00:54:59,599 --> 00:55:02,799
basically it copies the structure from

1431
00:55:02,799 --> 00:55:04,319
kernel space to user space and then

1432
00:55:04,319 --> 00:55:06,000
maybe back out using copy

1433
00:55:06,000 --> 00:55:09,200
out right so if we map the user space

1434
00:55:09,200 --> 00:55:09,680
into

1435
00:55:09,680 --> 00:55:11,200
the user program into the kernel address

1436
00:55:11,200 --> 00:55:12,880
space we can just manipulate it much

1437
00:55:12,880 --> 00:55:13,599
more

1438
00:55:13,599 --> 00:55:18,549
freely than uh the way we do it now

1439
00:55:18,559 --> 00:55:19,760
does that make sense in terms of

1440
00:55:19,760 --> 00:55:22,640
motivation why many kernels actually

1441
00:55:22,640 --> 00:55:24,000
have this particular structure where

1442
00:55:24,000 --> 00:55:27,190
they map the

1443
00:55:27,200 --> 00:55:29,839
bottom part of the user uh or where to

1444
00:55:29,839 --> 00:55:31,280
map the user programming to the bottom

1445
00:55:31,280 --> 00:55:39,190
part of the kernel address space

1446
00:55:39,200 --> 00:55:44,710
okay

1447
00:55:44,720 --> 00:55:47,599
okay so so let's see little look at my

1448
00:55:47,599 --> 00:55:49,280
code

1449
00:55:49,280 --> 00:55:53,910
and so you understand what actually uh

1450
00:55:53,920 --> 00:55:56,079
i did so there's basically one function

1451
00:55:56,079 --> 00:55:57,280
that is the key correct

1452
00:55:57,280 --> 00:55:59,200
uh you know assuming we're building

1453
00:55:59,200 --> 00:56:00,640
somewhere a valid

1454
00:56:00,640 --> 00:56:02,400
user page table and then we just have to

1455
00:56:02,400 --> 00:56:04,000
map uh

1456
00:56:04,000 --> 00:56:06,079
the entries from the user page table

1457
00:56:06,079 --> 00:56:07,920
into the kernel page table

1458
00:56:07,920 --> 00:56:10,720
uh or the processes kernel page table so

1459
00:56:10,720 --> 00:56:12,720
a function kvnet map user that exactly

1460
00:56:12,720 --> 00:56:14,799
does this

1461
00:56:14,799 --> 00:56:17,599
and it's pretty boring um but the main

1462
00:56:17,599 --> 00:56:19,520
couple interesting points to point out

1463
00:56:19,520 --> 00:56:22,640
uh and work you know uh it has the same

1464
00:56:22,640 --> 00:56:23,040
sort of

1465
00:56:23,040 --> 00:56:26,400
uh interfaces uh

1466
00:56:26,400 --> 00:56:29,760
uh uv analog or whatever or basically if

1467
00:56:29,760 --> 00:56:31,280
you know you go from the old size

1468
00:56:31,280 --> 00:56:35,190
up to the new size page at a time

1469
00:56:35,200 --> 00:56:38,319
you find the uh

1470
00:56:38,319 --> 00:56:41,920
upte you know the pointer

1471
00:56:41,920 --> 00:56:45,359
to the pte for that particular virtual

1472
00:56:45,359 --> 00:56:47,920
address in the user page table

1473
00:56:47,920 --> 00:56:51,839
right so if we look at the uh

1474
00:56:51,839 --> 00:56:53,839
if we look at the picture that we had a

1475
00:56:53,839 --> 00:56:56,000
little while back you know look at the

1476
00:56:56,000 --> 00:56:58,400
this picture basically what this is

1477
00:56:58,400 --> 00:56:59,920
going to return correct is

1478
00:56:59,920 --> 00:57:01,599
we're going to walk the user page table

1479
00:57:01,599 --> 00:57:03,760
and we'll find for example the

1480
00:57:03,760 --> 00:57:06,240
pte that maps you know that particular

1481
00:57:06,240 --> 00:57:07,920
virtual address and we get a basically

1482
00:57:07,920 --> 00:57:10,839
pointer to that entry into the page

1483
00:57:10,839 --> 00:57:12,480
table

1484
00:57:12,480 --> 00:57:16,480
um so that's what block does

1485
00:57:16,480 --> 00:57:20,400
and so if the uh thing is mapped if it's

1486
00:57:20,400 --> 00:57:22,160
not zero that must mean you know it is

1487
00:57:22,160 --> 00:57:23,440
there so this is just a

1488
00:57:23,440 --> 00:57:24,960
check to double check that actually the

1489
00:57:24,960 --> 00:57:26,480
mapping is there

1490
00:57:26,480 --> 00:57:29,520
um we check this valid just like there's

1491
00:57:29,520 --> 00:57:30,240
debugging

1492
00:57:30,240 --> 00:57:32,240
help in some sense you know it should be

1493
00:57:32,240 --> 00:57:34,000
the case that it is valid

1494
00:57:34,000 --> 00:57:35,599
uh and then i do the same thing in the

1495
00:57:35,599 --> 00:57:38,079
kernel page table i look up that virtual

1496
00:57:38,079 --> 00:57:39,280
address also in the

1497
00:57:39,280 --> 00:57:41,680
processors kernel page table but i call

1498
00:57:41,680 --> 00:57:42,799
this time

1499
00:57:42,799 --> 00:57:45,200
block with one so it actually allocates

1500
00:57:45,200 --> 00:57:48,400
intermediate pages if necessary

1501
00:57:48,400 --> 00:57:51,119
uh then once i got the pointer to the

1502
00:57:51,119 --> 00:57:52,480
kernel pt

1503
00:57:52,480 --> 00:57:54,640
i just copied the user pt into the

1504
00:57:54,640 --> 00:57:56,720
kernel pt

1505
00:57:56,720 --> 00:57:59,599
uh so probably a lot of you called map

1506
00:57:59,599 --> 00:58:00,640
pages

1507
00:58:00,640 --> 00:58:03,680
uh but i just copied directly the pte

1508
00:58:03,680 --> 00:58:05,040
into the kernel ptd

1509
00:58:05,040 --> 00:58:06,400
and of course you know i got to disable

1510
00:58:06,400 --> 00:58:08,160
some bits which we'll talk about in a

1511
00:58:08,160 --> 00:58:08,960
second

1512
00:58:08,960 --> 00:58:12,960
uh but um the essence of it is i just

1513
00:58:12,960 --> 00:58:14,240
want to copy the kernel page

1514
00:58:14,240 --> 00:58:17,599
the pte entries and so that means that

1515
00:58:17,599 --> 00:58:20,240
for example the physical memory for the

1516
00:58:20,240 --> 00:58:22,079
user program is just shared

1517
00:58:22,079 --> 00:58:28,150
between the kernel space and user space

1518
00:58:28,160 --> 00:58:33,910
okay does that make sense

1519
00:58:33,920 --> 00:58:35,359
okay so then in terms of switching up

1520
00:58:35,359 --> 00:58:37,040
some bits uh i'm

1521
00:58:37,040 --> 00:58:40,000
a little bit uh more than necessary but

1522
00:58:40,000 --> 00:58:41,359
i switch off the execute bit

1523
00:58:41,359 --> 00:58:44,400
i switch up the right bit this copy in

1524
00:58:44,400 --> 00:58:44,880
only

1525
00:58:44,880 --> 00:58:47,599
needs to read uh never writes to it or

1526
00:58:47,599 --> 00:58:49,119
copy out does that

1527
00:58:49,119 --> 00:58:51,680
and then uh you have to switch up the

1528
00:58:51,680 --> 00:58:53,359
ubit

1529
00:58:53,359 --> 00:58:56,960
and that is a sort of risk 5 specific

1530
00:58:56,960 --> 00:58:57,520
thing

1531
00:58:57,520 --> 00:59:00,400
that if you're running in kernel mode uh

1532
00:59:00,400 --> 00:59:00,880
and

1533
00:59:00,880 --> 00:59:03,760
the u-bit is set in the ptv entry the

1534
00:59:03,760 --> 00:59:05,359
kernel can actually not

1535
00:59:05,359 --> 00:59:09,030
access that particular page

1536
00:59:09,040 --> 00:59:12,960
in fact you can this is almost a choice

1537
00:59:12,960 --> 00:59:14,720
you can also actually program the risk 5

1538
00:59:14,720 --> 00:59:17,200
hardware but basically in kernel mode

1539
00:59:17,200 --> 00:59:20,870
it ignores the u-bit

1540
00:59:20,880 --> 00:59:25,040
and but xv6 doesn't do that

1541
00:59:25,040 --> 00:59:30,789
and so you have to switch up the u-bit

1542
00:59:30,799 --> 00:59:32,240
any questions about the ubit because the

1543
00:59:32,240 --> 00:59:33,920
required number of you are asked about

1544
00:59:33,920 --> 00:59:40,470
it

1545
00:59:40,480 --> 00:59:43,599
so is this done just to make sure that

1546
00:59:43,599 --> 00:59:46,079
the kernel doesn't do anything bad to

1547
00:59:46,079 --> 00:59:47,040
user

1548
00:59:47,040 --> 00:59:49,359
memory yeah so why is this the case

1549
00:59:49,359 --> 00:59:50,799
right is this you know

1550
00:59:50,799 --> 00:59:52,079
so the question is like is this for

1551
00:59:52,079 --> 00:59:53,760
debugging reasons or is there sort of an

1552
00:59:53,760 --> 00:59:55,839
isolation reason to do so

1553
00:59:55,839 --> 00:59:58,000
and uh i think this is mostly for

1554
00:59:58,000 --> 00:59:59,440
debugging reasons

1555
00:59:59,440 --> 01:00:01,280
uh because the kernel is in full control

1556
01:00:01,280 --> 01:00:03,440
anyway right the kernel can

1557
01:00:03,440 --> 01:00:05,440
change to the satp register it will it

1558
01:00:05,440 --> 01:00:07,599
can disable paging as it wants to

1559
01:00:07,599 --> 01:00:09,760
uh so it's not like you know the user

1560
01:00:09,760 --> 01:00:10,960
space is protected

1561
01:00:10,960 --> 01:00:13,040
from the kernel i think it's mostly to

1562
01:00:13,040 --> 01:00:15,200
basically uh help kernel developers so

1563
01:00:15,200 --> 01:00:16,960
for example in xv6 case correct

1564
01:00:16,960 --> 01:00:20,079
unmodified xv6 should never dereference

1565
01:00:20,079 --> 01:00:22,160
your user page period

1566
01:00:22,160 --> 01:00:26,160
uh and uh and and so that you know

1567
01:00:26,160 --> 01:00:28,319
and basically this just just helps you

1568
01:00:28,319 --> 01:00:29,359
know if you

1569
01:00:29,359 --> 01:00:31,280
happen to do that by accident anyway you

1570
01:00:31,280 --> 01:00:32,480
know you would get immediately a page

1571
01:00:32,480 --> 01:00:33,359
fault and uh

1572
01:00:33,359 --> 01:00:35,040
you know or kernel panic and it will

1573
01:00:35,040 --> 01:00:36,480
help the kernel debugger

1574
01:00:36,480 --> 01:00:41,270
or developer to debug the the kernel

1575
01:00:41,280 --> 01:00:44,950
does that make sense

1576
01:00:44,960 --> 01:00:48,880
yeah thank you i have a follow-up

1577
01:00:48,880 --> 01:00:51,040
question to that

1578
01:00:51,040 --> 01:00:53,040
uh i think the part about the user bit

1579
01:00:53,040 --> 01:00:54,079
makes sense

1580
01:00:54,079 --> 01:00:56,400
but what about the write and execute

1581
01:00:56,400 --> 01:00:57,440
bits

1582
01:00:57,440 --> 01:01:01,119
yeah uh so does the execute did have to

1583
01:01:01,119 --> 01:01:06,950
be on

1584
01:01:06,960 --> 01:01:11,910
what does the kernel do at this page

1585
01:01:11,920 --> 01:01:13,599
it only reads from it right the only

1586
01:01:13,599 --> 01:01:14,720
thing the only instruction that

1587
01:01:14,720 --> 01:01:15,680
basically

1588
01:01:15,680 --> 01:01:17,119
grabs data from this page is this

1589
01:01:17,119 --> 01:01:20,559
manmove instruction and copy in

1590
01:01:20,559 --> 01:01:22,319
so it only you know does execute load

1591
01:01:22,319 --> 01:01:24,559
instructions from it or

1592
01:01:24,559 --> 01:01:26,480
load values you know from that

1593
01:01:26,480 --> 01:01:27,920
particular page

1594
01:01:27,920 --> 01:01:30,319
and the page should only contain data so

1595
01:01:30,319 --> 01:01:31,280
there's no reason

1596
01:01:31,280 --> 01:01:32,720
that the kernel should be right into

1597
01:01:32,720 --> 01:01:35,839
that page and so just to be conservative

1598
01:01:35,839 --> 01:01:38,079
i disable the right bit and there should

1599
01:01:38,079 --> 01:01:39,839
be should never execute instructions

1600
01:01:39,839 --> 01:01:40,720
from that page

1601
01:01:40,720 --> 01:01:43,839
so i disable the execute bit too again

1602
01:01:43,839 --> 01:01:44,799
this is mostly

1603
01:01:44,799 --> 01:01:47,440
i think for debugging reasons uh not you

1604
01:01:47,440 --> 01:01:52,079
know for isolation reasons

1605
01:01:52,079 --> 01:01:57,349
okay make sense thanks

1606
01:01:57,359 --> 01:02:00,710
um

1607
01:02:00,720 --> 01:02:03,359
okay uh so now the only thing we need to

1608
01:02:03,359 --> 01:02:04,400
do is basically there's a bunch of

1609
01:02:04,400 --> 01:02:05,280
places where

1610
01:02:05,280 --> 01:02:06,880
this code is being where this function

1611
01:02:06,880 --> 01:02:09,119
is being called and we need to

1612
01:02:09,119 --> 01:02:11,520
look at these uh places where it's uh

1613
01:02:11,520 --> 01:02:13,760
called to understand what's going on

1614
01:02:13,760 --> 01:02:15,359
uh or how it should be used and i think

1615
01:02:15,359 --> 01:02:17,039
maybe the one of the interesting ones

1616
01:02:17,039 --> 01:02:17,440
that

1617
01:02:17,440 --> 01:02:22,319
a number of you asked about is fork

1618
01:02:22,319 --> 01:02:23,839
and exactly we'll talk about both of

1619
01:02:23,839 --> 01:02:27,430
them

1620
01:02:27,440 --> 01:02:34,079
the first fork

1621
01:02:34,079 --> 01:02:38,240
uh so here is uh the call to fork

1622
01:02:38,240 --> 01:02:42,079
or to call 2k kvm map user in fork

1623
01:02:42,079 --> 01:02:45,520
uh and it takes the end so the main

1624
01:02:45,520 --> 01:02:46,880
main interesting question i think a lot

1625
01:02:46,880 --> 01:02:48,960
of you asked is

1626
01:02:48,960 --> 01:02:51,440
why does it have to be the new process

1627
01:02:51,440 --> 01:02:52,960
kernel page table

1628
01:02:52,960 --> 01:02:55,119
why does it have to copy from the new

1629
01:02:55,119 --> 01:02:56,319
process

1630
01:02:56,319 --> 01:02:59,520
page table instead of from maybe the

1631
01:02:59,520 --> 01:03:01,280
current process page table because it's

1632
01:03:01,280 --> 01:03:03,359
anyway an identical right going forward

1633
01:03:03,359 --> 01:03:04,960
but basically does it just replicates

1634
01:03:04,960 --> 01:03:06,960
the

1635
01:03:06,960 --> 01:03:09,200
user part of the page table and so why

1636
01:03:09,200 --> 01:03:10,079
can't we use the

1637
01:03:10,079 --> 01:03:16,400
current uh page table for doing that

1638
01:03:16,400 --> 01:03:18,319
and why and actually turns out the case

1639
01:03:18,319 --> 01:03:19,839
you actually have to use the

1640
01:03:19,839 --> 01:03:22,640
new you know the child's user

1641
01:03:22,640 --> 01:03:23,599
participation

1642
01:03:23,599 --> 01:03:26,319
the child's user page table and why is

1643
01:03:26,319 --> 01:03:36,390
that the case

1644
01:03:36,400 --> 01:03:44,160
move you notice what what bug do you get

1645
01:03:44,160 --> 01:03:47,119
wouldn't you get a remap error you could

1646
01:03:47,119 --> 01:03:47,839
um

1647
01:03:47,839 --> 01:03:50,000
maybe not remap error uh well the thing

1648
01:03:50,000 --> 01:03:51,520
maybe not too but again the bug i'm

1649
01:03:51,520 --> 01:03:56,150
thinking of is not the remap one

1650
01:03:56,160 --> 01:03:58,079
remember if you tried it out what was

1651
01:03:58,079 --> 01:04:06,710
your personal experience

1652
01:04:06,720 --> 01:04:10,480
anybody on the call who tried this out

1653
01:04:10,480 --> 01:04:13,119
and remember about the resulting

1654
01:04:13,119 --> 01:04:16,309
experiences

1655
01:04:16,319 --> 01:04:18,880
i think the resulting i i i did not have

1656
01:04:18,880 --> 01:04:19,680
this but like

1657
01:04:19,680 --> 01:04:21,280
i think the resulting experience is that

1658
01:04:21,280 --> 01:04:22,880
somewhere in user test

1659
01:04:22,880 --> 01:04:24,640
uh particularly usage has to do a lot of

1660
01:04:24,640 --> 01:04:26,079
forking and exiting

1661
01:04:26,079 --> 01:04:28,720
you're going to get a problem and you

1662
01:04:28,720 --> 01:04:31,029
get a

1663
01:04:31,039 --> 01:04:34,079
an error and the area

1664
01:04:34,079 --> 01:04:37,839
the thing that goes wrong is that

1665
01:04:37,839 --> 01:04:40,559
if you copy from the parent process if

1666
01:04:40,559 --> 01:04:41,520
the parent process

1667
01:04:41,520 --> 01:04:45,280
exits before the child processes us then

1668
01:04:45,280 --> 01:04:47,680
the parent process page table will be

1669
01:04:47,680 --> 01:04:49,680
completely

1670
01:04:49,680 --> 01:04:52,480
cleaned up right as we saw before and

1671
01:04:52,480 --> 01:04:54,319
but then the child still has

1672
01:04:54,319 --> 01:04:58,000
pointers to the parent process

1673
01:04:58,000 --> 01:05:01,760
uh page table and so

1674
01:05:01,760 --> 01:05:04,960
basically you're gonna be basically

1675
01:05:04,960 --> 01:05:08,160
pages in this child's process

1676
01:05:08,160 --> 01:05:11,039
page table have been treated and they're

1677
01:05:11,039 --> 01:05:12,559
still in use and so that results in all

1678
01:05:12,559 --> 01:05:14,400
kinds of bad behavior because

1679
01:05:14,400 --> 01:05:16,559
the kernel one that frees a page

1680
01:05:16,559 --> 01:05:17,920
actually writes ones in it

1681
01:05:17,920 --> 01:05:20,880
everywhere for debugging reasons and so

1682
01:05:20,880 --> 01:05:22,000
now basically you have

1683
01:05:22,000 --> 01:05:25,280
invalid you know ptes sitting in your

1684
01:05:25,280 --> 01:05:28,950
kernel page table

1685
01:05:28,960 --> 01:05:37,839
does that make sense

1686
01:05:37,839 --> 01:05:41,520
okay one more thing to

1687
01:05:41,520 --> 01:05:46,079
look at is exact.c uh in my solutions

1688
01:05:46,079 --> 01:05:49,039
uh are pretty straightforward always

1689
01:05:49,039 --> 01:05:51,359
made no modifications to exec

1690
01:05:51,359 --> 01:05:53,680
uh the only medication await is of

1691
01:05:53,680 --> 01:05:55,440
course you know the first thing for

1692
01:05:55,440 --> 01:05:57,680
you know part one and then here for part

1693
01:05:57,680 --> 01:05:59,599
three it's just basically

1694
01:05:59,599 --> 01:06:03,119
mapping the new user page table

1695
01:06:03,119 --> 01:06:05,119
into the kernel page table and exit

1696
01:06:05,119 --> 01:06:06,400
basically what it does is

1697
01:06:06,400 --> 01:06:08,960
basically builds a new user address

1698
01:06:08,960 --> 01:06:09,680
space

1699
01:06:09,680 --> 01:06:11,440
and you know this one line copies that

1700
01:06:11,440 --> 01:06:13,039
new user address space into the kernel

1701
01:06:13,039 --> 01:06:15,440
page table

1702
01:06:15,440 --> 01:06:21,190
and that's it

1703
01:06:21,200 --> 01:06:27,029
any questions

1704
01:06:27,039 --> 01:06:29,520
so i hope in the meantime uh i've

1705
01:06:29,520 --> 01:06:30,960
answered many of the questions that

1706
01:06:30,960 --> 01:06:34,640
you uh submitted

1707
01:06:34,640 --> 01:06:37,359
we can look and see which ones uh there

1708
01:06:37,359 --> 01:06:38,720
were a couple more questions that i

1709
01:06:38,720 --> 01:06:40,640
haven't talked about yet

1710
01:06:40,640 --> 01:06:42,799
so maybe we can look at those or unless

1711
01:06:42,799 --> 01:06:46,960
you have questions right away

1712
01:06:46,960 --> 01:06:50,079
um don't we modify

1713
01:06:50,079 --> 01:06:52,799
the grow proc as well yes yeah the

1714
01:06:52,799 --> 01:06:54,720
couple more changes that necessary

1715
01:06:54,720 --> 01:06:58,079
uh uh you know in s-break

1716
01:06:58,079 --> 01:07:02,630
or group rock there's a

1717
01:07:02,640 --> 01:07:06,079
i added a line right here a very similar

1718
01:07:06,079 --> 01:07:07,119
style

1719
01:07:07,119 --> 01:07:09,520
and there's presumably a similar change

1720
01:07:09,520 --> 01:07:11,680
in

1721
01:07:11,680 --> 01:07:12,960
i think that might be it actually or

1722
01:07:12,960 --> 01:07:15,359
usually in it of course probably has a

1723
01:07:15,359 --> 01:07:17,599
change

1724
01:07:17,599 --> 01:07:19,680
because you have to map that one page

1725
01:07:19,680 --> 01:07:22,000
from the init code into

1726
01:07:22,000 --> 01:07:24,240
the your the kernel page table for you

1727
01:07:24,240 --> 01:07:26,640
that process

1728
01:07:26,640 --> 01:07:35,510
because the first process is special

1729
01:07:35,520 --> 01:07:37,520
okay so uh i'm going to walk through

1730
01:07:37,520 --> 01:07:39,039
some of the questions here that i put

1731
01:07:39,039 --> 01:07:39,839
them on the

1732
01:07:39,839 --> 01:07:41,920
screen so you can hopefully see them so

1733
01:07:41,920 --> 01:07:43,039
that i don't have to feel

1734
01:07:43,039 --> 01:07:45,920
uh read them out completely i think the

1735
01:07:45,920 --> 01:07:47,119
first question is a question that

1736
01:07:47,119 --> 01:07:48,640
actually came up quite a bit

1737
01:07:48,640 --> 01:07:51,920
about the pteu bit uh flag uh i think

1738
01:07:51,920 --> 01:07:52,319
we've

1739
01:07:52,319 --> 01:07:55,599
covered this we also cover the fact that

1740
01:07:55,599 --> 01:07:57,200
it's not malicious but it's mostly for

1741
01:07:57,200 --> 01:07:58,880
debugging reasons

1742
01:07:58,880 --> 01:08:02,799
uh similar question about like

1743
01:08:02,799 --> 01:08:04,480
well if you're in supervisor mode can

1744
01:08:04,480 --> 01:08:06,160
you do anything uh because you can

1745
01:08:06,160 --> 01:08:07,039
switch the

1746
01:08:07,039 --> 01:08:11,039
satp you can uh and the answer is yes

1747
01:08:11,039 --> 01:08:13,520
it's all possible so really you know

1748
01:08:13,520 --> 01:08:14,160
this ubis

1749
01:08:14,160 --> 01:08:17,040
is not about the user program being

1750
01:08:17,040 --> 01:08:19,120
protected from the kernel it really

1751
01:08:19,120 --> 01:08:21,920
has a flag to help the kernel developer

1752
01:08:21,920 --> 01:08:24,400
and build the kernel

1753
01:08:24,400 --> 01:08:26,799
uh one other specific sort of risk five

1754
01:08:26,799 --> 01:08:27,520
question

1755
01:08:27,520 --> 01:08:29,520
which is why are the entrepreneuring

1756
01:08:29,520 --> 01:08:31,279
property dates why in the register sort

1757
01:08:31,279 --> 01:08:32,319
of in a

1758
01:08:32,319 --> 01:08:35,359
uh in a strange order uh and

1759
01:08:35,359 --> 01:08:38,560
the reason that is uh i think we

1760
01:08:38,560 --> 01:08:39,759
mentioned this a little while ago in the

1761
01:08:39,759 --> 01:08:41,040
previous lecture that

1762
01:08:41,040 --> 01:08:43,279
uh there's basically there's something

1763
01:08:43,279 --> 01:08:45,040
what's called the risk five compressed

1764
01:08:45,040 --> 01:08:47,040
instruction set and that has a set of

1765
01:08:47,040 --> 01:08:48,400
fewer registers

1766
01:08:48,400 --> 01:08:51,679
and uh something you have to have a more

1767
01:08:51,679 --> 01:08:53,920
compact encoding of the instructions

1768
01:08:53,920 --> 01:08:57,279
uh and uh this strange ordering reflects

1769
01:08:57,279 --> 01:08:59,040
the fact that they're basically two

1770
01:08:59,040 --> 01:09:01,279
there's the compressed version which is

1771
01:09:01,279 --> 01:09:02,880
some set of registers and then sort of

1772
01:09:02,880 --> 01:09:04,319
the uncompressed version which is what

1773
01:09:04,319 --> 01:09:05,040
we're using

1774
01:09:05,040 --> 01:09:07,279
that has the complete set of registers

1775
01:09:07,279 --> 01:09:08,960
and the compression

1776
01:09:08,960 --> 01:09:13,120
version the example has s1 and s0

1777
01:09:13,120 --> 01:09:17,279
as 0 and s1 but not s2 from s11

1778
01:09:17,279 --> 01:09:25,570
so that's the main reason uh

1779
01:09:25,580 --> 01:09:26,880
[Music]

1780
01:09:26,880 --> 01:09:28,640
i think it went through most of these

1781
01:09:28,640 --> 01:09:30,480
questions but if you see a question that

1782
01:09:30,480 --> 01:09:32,159
i should have covered and i didn't

1783
01:09:32,159 --> 01:09:34,319
please interrupt me where if you ask a

1784
01:09:34,319 --> 01:09:38,870
question that i haven't covered yet

1785
01:09:38,880 --> 01:09:41,679
please ask these questions are basically

1786
01:09:41,679 --> 01:09:43,199
in order that you submitted them so

1787
01:09:43,199 --> 01:09:48,239
these were

1788
01:09:48,239 --> 01:09:51,359
okay here may be uh so here's our

1789
01:09:51,359 --> 01:09:52,400
question through operating systems

1790
01:09:52,400 --> 01:09:53,839
usually article called page tables have

1791
01:09:53,839 --> 01:09:55,360
to set up the page table pages so that

1792
01:09:55,360 --> 01:09:56,880
the lower parts of the hierarchy are at

1793
01:09:56,880 --> 01:09:58,480
least partly shared

1794
01:09:58,480 --> 01:10:00,320
and uh you know you're clearly starting

1795
01:10:00,320 --> 01:10:02,480
my solution correct i share

1796
01:10:02,480 --> 01:10:05,199
the entries 1 to 5 11. and so this is a

1797
01:10:05,199 --> 01:10:06,320
standard trick

1798
01:10:06,320 --> 01:10:17,760
and lots of operating systems do that

1799
01:10:17,760 --> 01:10:19,280
i think we talked a little bit about

1800
01:10:19,280 --> 01:10:20,719
this particular issue that's important

1801
01:10:20,719 --> 01:10:21,440
that you switch

1802
01:10:21,440 --> 01:10:23,440
you know to this main kernel page table

1803
01:10:23,440 --> 01:10:25,440
because the scheduler

1804
01:10:25,440 --> 01:10:27,840
uh there might be no user processors to

1805
01:10:27,840 --> 01:10:29,600
run at all anymore

1806
01:10:29,600 --> 01:10:30,960
and the schedule of course still needs a

1807
01:10:30,960 --> 01:10:32,960
page table and so it runs with the main

1808
01:10:32,960 --> 01:10:36,310
kernel page table

1809
01:10:36,320 --> 01:10:38,800
we have a question in the chat yeah go

1810
01:10:38,800 --> 01:10:40,400
ahead what is that when you

1811
01:10:40,400 --> 01:10:55,030
pull up the chat

1812
01:10:55,040 --> 01:10:57,120
i can read it yeah yeah i got it so i

1813
01:10:57,120 --> 01:10:58,800
think you know uh okay so the question

1814
01:10:58,800 --> 01:11:00,640
is doesn't the risk uh privilege specs

1815
01:11:00,640 --> 01:11:02,159
say that part of the separation is to

1816
01:11:02,159 --> 01:11:03,760
prevent bugs that allow the user program

1817
01:11:03,760 --> 01:11:05,520
to make the kernel jump to arbitrary

1818
01:11:05,520 --> 01:11:07,120
coding user space

1819
01:11:07,120 --> 01:11:10,640
uh yes uh that's a good point uh

1820
01:11:10,640 --> 01:11:13,440
uh and so you know you can debate here

1821
01:11:13,440 --> 01:11:15,199
whether this is an isolation property or

1822
01:11:15,199 --> 01:11:17,040
a kernel debugging property

1823
01:11:17,040 --> 01:11:18,719
clearly the kernel should never jump

1824
01:11:18,719 --> 01:11:20,560
into any uh part of the address

1825
01:11:20,560 --> 01:11:23,920
in the user address space uh directly uh

1826
01:11:23,920 --> 01:11:28,000
and so uh you know i view this as a

1827
01:11:28,000 --> 01:11:30,320
tool to help the kernel debugger catch

1828
01:11:30,320 --> 01:11:32,960
those kinds of bugs

1829
01:11:32,960 --> 01:11:34,880
and in some reason that's why in xv6 we

1830
01:11:34,880 --> 01:11:36,560
also uh

1831
01:11:36,560 --> 01:11:39,840
disable or you know set the view bit and

1832
01:11:39,840 --> 01:11:41,760
don't allow the kernel to refer to any

1833
01:11:41,760 --> 01:11:44,229
pages

1834
01:11:44,239 --> 01:11:46,239
that protects you know us you know if we

1835
01:11:46,239 --> 01:11:47,760
did reference every

1836
01:11:47,760 --> 01:11:50,239
user address that the kernel would

1837
01:11:50,239 --> 01:11:59,110
actually default

1838
01:11:59,120 --> 01:12:02,390
um

1839
01:12:02,400 --> 01:12:05,120
i think i've covered the scheduler point

1840
01:12:05,120 --> 01:12:05,800
uh

1841
01:12:05,800 --> 01:12:12,470
two uh

1842
01:12:12,480 --> 01:12:14,640
uh so here's a question how are pipes

1843
01:12:14,640 --> 01:12:16,400
implemented in xv6 and shoot the changes

1844
01:12:16,400 --> 01:12:18,239
to page table implemented in the phablet

1845
01:12:18,239 --> 01:12:19,920
effective implementation

1846
01:12:19,920 --> 01:12:22,880
um so pegs are basically a buffering

1847
01:12:22,880 --> 01:12:24,640
memory in the kernel

1848
01:12:24,640 --> 01:12:27,120
and uh right when you write to your pipe

1849
01:12:27,120 --> 01:12:28,800
basically calls copy in

1850
01:12:28,800 --> 01:12:30,880
and copy in or copies the bytes you know

1851
01:12:30,880 --> 01:12:32,880
from user space into the pipe

1852
01:12:32,880 --> 01:12:34,800
and in some ways you know the whole part

1853
01:12:34,800 --> 01:12:36,159
of this pageant blob which they

1854
01:12:36,159 --> 01:12:36,800
basically

1855
01:12:36,800 --> 01:12:40,400
streamline that code so that you don't

1856
01:12:40,400 --> 01:12:40,960
have to do

1857
01:12:40,960 --> 01:12:43,440
many walks when you actually write from

1858
01:12:43,440 --> 01:12:45,120
user space into the

1859
01:12:45,120 --> 01:12:49,030
pipe

1860
01:12:49,040 --> 01:12:50,080
uh this is an interesting question i

1861
01:12:50,080 --> 01:12:51,520
think a lot of people ask you like why

1862
01:12:51,520 --> 01:12:52,880
does uvm three and free walker

1863
01:12:52,880 --> 01:12:54,719
originally panic at the leaf

1864
01:12:54,719 --> 01:12:58,560
uh and the reason is that you know the

1865
01:12:58,560 --> 01:13:00,000
we put that panic in there because it

1866
01:13:00,000 --> 01:13:02,480
broke uh that was an indication that the

1867
01:13:02,480 --> 01:13:04,719
variant in xv6 would be broken and

1868
01:13:04,719 --> 01:13:07,840
that's an invariant for unmodified xc6

1869
01:13:07,840 --> 01:13:10,800
in this particular case uh that is not

1870
01:13:10,800 --> 01:13:11,280
true

1871
01:13:11,280 --> 01:13:13,440
and so you had to basically get rid of

1872
01:13:13,440 --> 01:13:15,840
the panic and realize that it was not

1873
01:13:15,840 --> 01:13:17,520
important to panic there you should not

1874
01:13:17,520 --> 01:13:21,669
get it there

1875
01:13:21,679 --> 01:13:23,679
i think we talked quite a bit about like

1876
01:13:23,679 --> 01:13:25,440
why vm copy news

1877
01:13:25,440 --> 01:13:27,120
you know why the new vm company is a

1878
01:13:27,120 --> 01:13:32,080
good one uh

1879
01:13:32,080 --> 01:13:35,679
uh okay here's another question

1880
01:13:35,679 --> 01:13:38,080
um let's say and this is maybe an

1881
01:13:38,080 --> 01:13:40,080
interesting uh

1882
01:13:40,080 --> 01:13:41,600
one question i was asked if sort of more

1883
01:13:41,600 --> 01:13:43,840
design question uh and

1884
01:13:43,840 --> 01:13:47,120
it helps have a picture we look at the

1885
01:13:47,120 --> 01:13:48,320
kernel address space

1886
01:13:48,320 --> 01:13:51,199
or we eliminate let's see if i can find

1887
01:13:51,199 --> 01:13:52,239
my pen

1888
01:13:52,239 --> 01:13:54,880
we limited user address user programs

1889
01:13:54,880 --> 01:13:56,640
can be bigger we said basically user

1890
01:13:56,640 --> 01:13:58,080
programs can grow to the clean address

1891
01:13:58,080 --> 01:14:00,880
no further

1892
01:14:00,880 --> 01:14:02,480
let's say we actually wanted to grow

1893
01:14:02,480 --> 01:14:04,640
like all the way to here

1894
01:14:04,640 --> 01:14:06,880
how could we do that and what what how

1895
01:14:06,880 --> 01:14:08,560
should we change the design

1896
01:14:08,560 --> 01:14:18,229
that would allow that

1897
01:14:18,239 --> 01:14:23,350
anybody

1898
01:14:23,360 --> 01:14:26,400
uh could we remap the the stuff

1899
01:14:26,400 --> 01:14:31,280
uh like clint and plic and you are

1900
01:14:31,280 --> 01:14:33,360
yeah where would you mark up so where if

1901
01:14:33,360 --> 01:14:34,480
you wanted to

1902
01:14:34,480 --> 01:14:35,840
free up basically that part of the

1903
01:14:35,840 --> 01:14:39,280
address space what could you do

1904
01:14:39,280 --> 01:14:42,480
map it to like a custom thing before

1905
01:14:42,480 --> 01:14:43,920
current base and after

1906
01:14:43,920 --> 01:14:46,640
like before physical stop and after

1907
01:14:46,640 --> 01:14:48,080
current base

1908
01:14:48,080 --> 01:14:50,000
yeah or uh it may be actually better to

1909
01:14:50,000 --> 01:14:51,280
after fish stock

1910
01:14:51,280 --> 01:14:53,520
here's a huge amount of free space like

1911
01:14:53,520 --> 01:14:55,199
address space is unused like this from

1912
01:14:55,199 --> 01:14:56,320
here to there is basically used for

1913
01:14:56,320 --> 01:14:57,440
physical memory

1914
01:14:57,440 --> 01:14:58,960
and we basically could set up mappings

1915
01:14:58,960 --> 01:15:00,320
here right for example we could put the

1916
01:15:00,320 --> 01:15:01,199
uart

1917
01:15:01,199 --> 01:15:04,880
here like you are zero we could put

1918
01:15:04,880 --> 01:15:06,480
just above this page and basically set

1919
01:15:06,480 --> 01:15:08,320
up a mapping that

1920
01:15:08,320 --> 01:15:10,960
maps to that particular physical address

1921
01:15:10,960 --> 01:15:12,960
right and then that will free up this

1922
01:15:12,960 --> 01:15:14,960
mapping and we could use it for user

1923
01:15:14,960 --> 01:15:16,719
space and so similarly we could do that

1924
01:15:16,719 --> 01:15:18,960
for ui zero or converge io disk you know

1925
01:15:18,960 --> 01:15:21,280
for click and click

1926
01:15:21,280 --> 01:15:24,560
and real kernels do that

1927
01:15:24,560 --> 01:15:36,950
does that make sense

1928
01:15:36,960 --> 01:15:38,880
is it isn't that problematic though

1929
01:15:38,880 --> 01:15:40,080
because we would

1930
01:15:40,080 --> 01:15:42,880
we want the same same mapping as the

1931
01:15:42,880 --> 01:15:44,239
original

1932
01:15:44,239 --> 01:15:48,159
uh kernel page table has

1933
01:15:48,159 --> 01:15:51,040
uh well we have to do it in every every

1934
01:15:51,040 --> 01:15:52,400
kernel page table correct if we had

1935
01:15:52,400 --> 01:15:53,679
copies we have to map it

1936
01:15:53,679 --> 01:16:00,310
everywhere at that particular location

1937
01:16:00,320 --> 01:16:02,159
i'm not sure that is a i'm not sure that

1938
01:16:02,159 --> 01:16:03,920
answers your question but

1939
01:16:03,920 --> 01:16:06,320
i don't think that's a problem i see so

1940
01:16:06,320 --> 01:16:08,000
you you do that mapping

1941
01:16:08,000 --> 01:16:10,719
also in the original yeah yeah we would

1942
01:16:10,719 --> 01:16:15,590
have to do it also in the original one

1943
01:16:15,600 --> 01:16:17,360
and that's easier like if the whole

1944
01:16:17,360 --> 01:16:19,360
kernel uniformly thinks about

1945
01:16:19,360 --> 01:16:28,709
you are zero sitting on the top

1946
01:16:28,719 --> 01:16:30,159
you know a number of people ask this

1947
01:16:30,159 --> 01:16:32,080
like why do we map the kernel stacks

1948
01:16:32,080 --> 01:16:37,110
high up

1949
01:16:37,120 --> 01:16:38,480
what is the reason for that like so we

1950
01:16:38,480 --> 01:16:40,480
can proc in it correct we

1951
01:16:40,480 --> 01:16:43,280
uh map these uh kernel stacks high up

1952
01:16:43,280 --> 01:16:44,800
and if you did the copy approach you

1953
01:16:44,800 --> 01:16:46,880
know you actually have to modify cop

1954
01:16:46,880 --> 01:16:49,600
proc in it to actually copy over that

1955
01:16:49,600 --> 01:16:51,520
mapping

1956
01:16:51,520 --> 01:16:53,600
and why setting it up high in the

1957
01:16:53,600 --> 01:17:00,830
virtual address space

1958
01:17:00,840 --> 01:17:09,270
anybody

1959
01:17:09,280 --> 01:17:11,840
is it specifically because the uh the

1960
01:17:11,840 --> 01:17:13,280
stacks in risk five grow

1961
01:17:13,280 --> 01:17:14,719
downwards and so you place it high in

1962
01:17:14,719 --> 01:17:16,400
the address space so that it has space

1963
01:17:16,400 --> 01:17:17,840
to grow downwards

1964
01:17:17,840 --> 01:17:19,520
how much is it the right direction how

1965
01:17:19,520 --> 01:17:20,640
much phase does it have to grow

1966
01:17:20,640 --> 01:17:25,750
downwards

1967
01:17:25,760 --> 01:17:27,040
that shouldn't matter because it's just

1968
01:17:27,040 --> 01:17:28,960
one page right yeah it's only one page

1969
01:17:28,960 --> 01:17:30,960
so what happens if you go beyond

1970
01:17:30,960 --> 01:17:37,110
one page

1971
01:17:37,120 --> 01:17:40,560
you run into the cart page correct

1972
01:17:40,560 --> 01:17:43,040
and the guard page is not mapped and so

1973
01:17:43,040 --> 01:17:44,400
the kernel will panic

1974
01:17:44,400 --> 01:17:45,920
which is better than actually writing

1975
01:17:45,920 --> 01:17:48,800
over its data structures

1976
01:17:48,800 --> 01:17:50,560
and so the reason it's high up is uh

1977
01:17:50,560 --> 01:17:52,400
because we put a guard page below it

1978
01:17:52,400 --> 01:17:53,920
is there actually any physical memory

1979
01:17:53,920 --> 01:17:59,360
associated with that guard page

1980
01:17:59,360 --> 01:18:01,360
no no there's no physical memory

1981
01:18:01,360 --> 01:18:02,800
associated with the guard page right so

1982
01:18:02,800 --> 01:18:04,159
that's one of the cool things about

1983
01:18:04,159 --> 01:18:05,440
putting it high

1984
01:18:05,440 --> 01:18:07,199
is that we can put a guard page below it

1985
01:18:07,199 --> 01:18:08,880
that actually doesn't consume any

1986
01:18:08,880 --> 01:18:12,719
physical memory

1987
01:18:12,719 --> 01:18:17,110
okay does that make sense

1988
01:18:17,120 --> 01:18:20,000
oh so basically the cornell stuff page

1989
01:18:20,000 --> 01:18:21,600
will be

1990
01:18:21,600 --> 01:18:23,600
physical somewhere but the card page

1991
01:18:23,600 --> 01:18:26,719
won't exactly

1992
01:18:26,719 --> 01:18:28,159
again one of the cool things you can do

1993
01:18:28,159 --> 01:18:30,080
with virtual member

1994
01:18:30,080 --> 01:18:32,080
is it possible to overshoot the guard

1995
01:18:32,080 --> 01:18:33,199
page yeah

1996
01:18:33,199 --> 01:18:35,440
that's a great question you know what

1997
01:18:35,440 --> 01:18:36,640
one for example if you know you

1998
01:18:36,640 --> 01:18:37,760
allocated the guard uh

1999
01:18:37,760 --> 01:18:41,360
a buffer on the stack that actually uh

2000
01:18:41,360 --> 01:18:43,360
is you know way bigger than the guard

2001
01:18:43,360 --> 01:18:44,560
page correct and sort of

2002
01:18:44,560 --> 01:18:48,000
goes into the next kernel stack page

2003
01:18:48,000 --> 01:18:50,480
uh and yeah you would have a serious bug

2004
01:18:50,480 --> 01:18:52,320
uh most likely you will run into that

2005
01:18:52,320 --> 01:18:52,800
anyway

2006
01:18:52,800 --> 01:18:54,000
right because you presumably would use

2007
01:18:54,000 --> 01:18:56,080
the first entries of that buffer

2008
01:18:56,080 --> 01:19:00,470
and then you would get the page fault

2009
01:19:00,480 --> 01:19:03,600
but you could get unlocking so this this

2010
01:19:03,600 --> 01:19:04,480
is not a

2011
01:19:04,480 --> 01:19:06,960
bulletproof kernel debugging technique

2012
01:19:06,960 --> 01:19:09,199
but it has proven to be

2013
01:19:09,199 --> 01:19:13,030
extremely effective

2014
01:19:13,040 --> 01:19:18,870
great question

2015
01:19:18,880 --> 01:19:21,920
any more questions we'll go back to the

2016
01:19:21,920 --> 01:19:23,360
list

2017
01:19:23,360 --> 01:19:24,719
you see we have a couple more minutes

2018
01:19:24,719 --> 01:19:27,120
and then actually one more minute

2019
01:19:27,120 --> 01:19:31,040
um i have a question so once we have

2020
01:19:31,040 --> 01:19:34,159
our kernel page tables for the processes

2021
01:19:34,159 --> 01:19:37,199
does that mean that in the um

2022
01:19:37,199 --> 01:19:40,400
trap code we don't need to

2023
01:19:40,400 --> 01:19:44,560
switch page tables i think that's a

2024
01:19:44,560 --> 01:19:45,760
great question it's a good design

2025
01:19:45,760 --> 01:19:47,760
question uh and the answer is yes

2026
01:19:47,760 --> 01:19:51,280
you don't need it right because uh

2027
01:19:51,280 --> 01:19:53,840
the main reason that the kernel or in

2028
01:19:53,840 --> 01:19:55,199
the trampoline code we go for all this

2029
01:19:55,199 --> 01:19:56,880
trouble is because we have to copy the

2030
01:19:56,880 --> 01:19:57,840
user

2031
01:19:57,840 --> 01:19:59,520
uh we have to switch from the kernel

2032
01:19:59,520 --> 01:20:01,120
page table to the user page table in the

2033
01:20:01,120 --> 01:20:02,320
user page table

2034
01:20:02,320 --> 01:20:04,159
or a page table doesn't have the rest of

2035
01:20:04,159 --> 01:20:05,679
the kernel mapped

2036
01:20:05,679 --> 01:20:09,760
uh and so uh the downside

2037
01:20:09,760 --> 01:20:12,239
wait i'm not sure if that's true because

2038
01:20:12,239 --> 01:20:14,800
the cornell needs to have the user black

2039
01:20:14,800 --> 01:20:18,000
uh user flag on set yeah yeah okay so

2040
01:20:18,000 --> 01:20:18,960
there's a couple of points i wanted to

2041
01:20:18,960 --> 01:20:20,719
make

2042
01:20:20,719 --> 01:20:23,360
so in principle uh you could simplify

2043
01:20:23,360 --> 01:20:23,920
the

2044
01:20:23,920 --> 01:20:26,080
uh trend let me put it this way you can

2045
01:20:26,080 --> 01:20:27,679
simplify entry and exit

2046
01:20:27,679 --> 01:20:29,600
uh if you have a single page table that

2047
01:20:29,600 --> 01:20:31,040
maps the user and the kernel

2048
01:20:31,040 --> 01:20:32,560
in a single page table because then you

2049
01:20:32,560 --> 01:20:34,560
don't have to switch you will have to

2050
01:20:34,560 --> 01:20:36,719
make a couple more modifications to xp6

2051
01:20:36,719 --> 01:20:38,239
to make that happen

2052
01:20:38,239 --> 01:20:39,760
uh but in principle you could and in

2053
01:20:39,760 --> 01:20:41,360
fact linux

2054
01:20:41,360 --> 01:20:44,159
until very recently used you know this

2055
01:20:44,159 --> 01:20:44,639
sort of

2056
01:20:44,639 --> 01:20:47,920
strategy of where the kernel and

2057
01:20:47,920 --> 01:20:51,120
the user code are sitting in a single

2058
01:20:51,120 --> 01:20:52,400
page table

2059
01:20:52,400 --> 01:20:54,800
uh and relying on basically the ubit you

2060
01:20:54,800 --> 01:20:56,560
know to make sure that the

2061
01:20:56,560 --> 01:21:01,040
uh the user program couldn't actually

2062
01:21:01,040 --> 01:21:02,800
modify any kernel pages

2063
01:21:02,800 --> 01:21:04,880
and the entry exit code in that case is

2064
01:21:04,880 --> 01:21:05,920
slightly simpler

2065
01:21:05,920 --> 01:21:07,199
because you don't have to switch page

2066
01:21:07,199 --> 01:21:08,639
tables when you enter or release the

2067
01:21:08,639 --> 01:21:10,000
kernel

2068
01:21:10,000 --> 01:21:12,800
uh one thing that happened with for

2069
01:21:12,800 --> 01:21:14,080
example the meltdown attack

2070
01:21:14,080 --> 01:21:17,120
if you might have heard it off

2071
01:21:17,120 --> 01:21:20,239
this side channel attack uh in response

2072
01:21:20,239 --> 01:21:22,159
to the actually side channel attack

2073
01:21:22,159 --> 01:21:24,719
uh linux switch or has an other mode of

2074
01:21:24,719 --> 01:21:25,920
running there are two modes of running

2075
01:21:25,920 --> 01:21:28,080
one is called the kpti mode

2076
01:21:28,080 --> 01:21:30,239
and in that mode basically that reflects

2077
01:21:30,239 --> 01:21:32,000
basically what xv6 does

2078
01:21:32,000 --> 01:21:33,679
you know having a separate page table

2079
01:21:33,679 --> 01:21:35,280
for the kernel and a separate

2080
01:21:35,280 --> 01:21:40,790
page table for user space

2081
01:21:40,800 --> 01:21:42,400
right so i still don't understand why

2082
01:21:42,400 --> 01:21:44,239
does that work so let's say the

2083
01:21:44,239 --> 01:21:47,600
user process and the kernel uh use the

2084
01:21:47,600 --> 01:21:49,199
same page table

2085
01:21:49,199 --> 01:21:51,840
if the user memory has to have the user

2086
01:21:51,840 --> 01:21:52,800
bit set

2087
01:21:52,800 --> 01:21:54,639
the cornell will not be able to access

2088
01:21:54,639 --> 01:21:56,000
that user memory right

2089
01:21:56,000 --> 01:21:59,280
ah okay the uh on

2090
01:21:59,280 --> 01:22:02,239
so there's a this is uh okay on intel

2091
01:22:02,239 --> 01:22:04,159
processors that is not the rule

2092
01:22:04,159 --> 01:22:05,760
so for example in intel processors if

2093
01:22:05,760 --> 01:22:07,120
your bid is set the kernel can still

2094
01:22:07,120 --> 01:22:08,960
write and read that page

2095
01:22:08,960 --> 01:22:11,360
oh that's just a risk five thing ah and

2096
01:22:11,360 --> 01:22:13,520
even on the risk five you can change it

2097
01:22:13,520 --> 01:22:15,120
uh there's a bit in the s status

2098
01:22:15,120 --> 01:22:16,719
register that you can set

2099
01:22:16,719 --> 01:22:18,960
the take to some bit and if you set it

2100
01:22:18,960 --> 01:22:20,000
then basically

2101
01:22:20,000 --> 01:22:23,199
in kernel mode the view bit is ignored

2102
01:22:23,199 --> 01:22:24,800
okay so you're telling me that there's

2103
01:22:24,800 --> 01:22:26,560
just one bit in this

2104
01:22:26,560 --> 01:22:28,560
cmu processor that made me stay up four

2105
01:22:28,560 --> 01:22:31,199
hours later yes

2106
01:22:31,199 --> 01:22:32,960
i'm very sorry about that i should have

2107
01:22:32,960 --> 01:22:35,520
realized no no no it's okay it was it

2108
01:22:35,520 --> 01:22:37,440
was a fun realization

2109
01:22:37,440 --> 01:22:39,440
when you reported it uh it reminded me

2110
01:22:39,440 --> 01:22:41,199
of a bug that i actually have during the

2111
01:22:41,199 --> 01:22:43,520
summer and it was exactly that book

2112
01:22:43,520 --> 01:22:46,800
but i forgot about it

2113
01:22:46,800 --> 01:22:49,360
so my apologies for that no no it's okay

2114
01:22:49,360 --> 01:22:49,920
it was

2115
01:22:49,920 --> 01:22:52,080
it was fun figuring it out for sure but

2116
01:22:52,080 --> 01:22:53,840
i i at some point i was just like okay

2117
01:22:53,840 --> 01:22:56,000
like either i'm crazy or something's

2118
01:22:56,000 --> 01:22:57,520
completely wrong so i'm just going to go

2119
01:22:57,520 --> 01:22:59,199
to sleep and submit this piazza post and

2120
01:22:59,199 --> 01:23:00,719
hopefully when i wake up someone will

2121
01:23:00,719 --> 01:23:01,679
answer and

2122
01:23:01,679 --> 01:23:03,360
fortunately that was the case so i was

2123
01:23:03,360 --> 01:23:05,360
able to just continue right off when i

2124
01:23:05,360 --> 01:23:09,679
when i did okay so i think we

2125
01:23:09,679 --> 01:23:11,920
ran over time a little bit uh and

2126
01:23:11,920 --> 01:23:13,679
hopefully uh this was helpful

2127
01:23:13,679 --> 01:23:15,840
and reaffirms you know things with

2128
01:23:15,840 --> 01:23:16,880
virtual memory

2129
01:23:16,880 --> 01:23:18,400
i think it was important to do because

2130
01:23:18,400 --> 01:23:20,320
we're gonna get three more labs

2131
01:23:20,320 --> 01:23:23,440
involving virtual memory and my hope is

2132
01:23:23,440 --> 01:23:24,480
that after this one

2133
01:23:24,480 --> 01:23:26,000
you know those are going to be easier

2134
01:23:26,000 --> 01:23:29,360
than uh this experience

2135
01:23:29,360 --> 01:23:32,800
can i ask something very quick yeah so

2136
01:23:32,800 --> 01:23:34,719
i'm staying on so everybody wants to

2137
01:23:34,719 --> 01:23:36,159
stay on and ask more questions

2138
01:23:36,159 --> 01:23:37,840
please feel free to do so if you need to

2139
01:23:37,840 --> 01:23:40,639
go to the next class please go

2140
01:23:40,639 --> 01:23:43,440
so basically uh in all the labs like

2141
01:23:43,440 --> 01:23:45,040
there's a lot of mention of like oh

2142
01:23:45,040 --> 01:23:47,199
we this might be useful in future labs

2143
01:23:47,199 --> 01:23:48,880
but we never actually use any of the

2144
01:23:48,880 --> 01:23:50,000
code that we

2145
01:23:50,000 --> 01:23:52,960
write like what's what's the plan on

2146
01:23:52,960 --> 01:23:54,880
that like should we just import our code

2147
01:23:54,880 --> 01:23:56,320
from a previous lab or

2148
01:23:56,320 --> 01:23:57,760
like i don't want to because what if

2149
01:23:57,760 --> 01:23:59,040
it's buggy i don't want to you know

2150
01:23:59,040 --> 01:24:00,560
impact the next lab

2151
01:24:00,560 --> 01:24:02,080
yeah so the one reason we don't do it

2152
01:24:02,080 --> 01:24:04,080
you know why the build labs don't build

2153
01:24:04,080 --> 01:24:05,679
on each other even though they could

2154
01:24:05,679 --> 01:24:07,679
uh is to avoid basically dependencies

2155
01:24:07,679 --> 01:24:09,280
like if you had a bug in an earlier lab

2156
01:24:09,280 --> 01:24:10,960
that you know was not exposed by user

2157
01:24:10,960 --> 01:24:11,600
tests

2158
01:24:11,600 --> 01:24:13,679
or any of our tests and but would be

2159
01:24:13,679 --> 01:24:15,520
exposed to that new lab then you know be

2160
01:24:15,520 --> 01:24:16,639
painful

2161
01:24:16,639 --> 01:24:20,080
um the reason i'm mentioning that is

2162
01:24:20,080 --> 01:24:21,120
that basically

2163
01:24:21,120 --> 01:24:22,560
the real thing what's going on is we're

2164
01:24:22,560 --> 01:24:26,239
going to do more stuff with page tables

2165
01:24:26,239 --> 01:24:28,080
so for example this lab looks at

2166
01:24:28,080 --> 01:24:29,920
simplifying copy in uh

2167
01:24:29,920 --> 01:24:32,800
later labs gonna look at exchange to

2168
01:24:32,800 --> 01:24:33,520
s-break

2169
01:24:33,520 --> 01:24:35,920
they're basically orthogonal to the

2170
01:24:35,920 --> 01:24:37,360
changes you made to the kernel

2171
01:24:37,360 --> 01:24:40,400
for this lab but you know the fact that

2172
01:24:40,400 --> 01:24:41,600
you've been thinking about kernel page

2173
01:24:41,600 --> 01:24:43,600
table user pages tables so much

2174
01:24:43,600 --> 01:24:46,800
will help you plus really what helps you

2175
01:24:46,800 --> 01:24:48,320
is of the experience debugging these

2176
01:24:48,320 --> 01:24:49,679
kinds of problems

2177
01:24:49,679 --> 01:24:52,800
due to incorrect page tables

2178
01:24:52,800 --> 01:24:54,239
okay i just wanted to make sure that

2179
01:24:54,239 --> 01:24:55,920
it's not like i'm missing out because i

2180
01:24:55,920 --> 01:24:58,480
didn't copy over my x arch code from lab

2181
01:24:58,480 --> 01:24:59,040
one

2182
01:24:59,040 --> 01:25:00,800
or something it decided on purpose that

2183
01:25:00,800 --> 01:25:04,470
the labs are not dependent on each other

2184
01:25:04,480 --> 01:25:12,400
okay thanks i'll see you on wednesday

2185
01:25:12,400 --> 01:25:15,840
i had a follow-up on my question about

2186
01:25:15,840 --> 01:25:18,880
mapping mapping uh using the

2187
01:25:18,880 --> 01:25:21,440
modification from the page table app um

2188
01:25:21,440 --> 01:25:22,800
would it be then

2189
01:25:22,800 --> 01:25:26,480
needed to have the trampoline

2190
01:25:26,480 --> 01:25:30,800
mapped in the user page tables

2191
01:25:30,800 --> 01:25:32,480
uh okay so i haven't really fought this

2192
01:25:32,480 --> 01:25:34,800
through uh

2193
01:25:34,800 --> 01:25:36,560
so if you the kernels let's say the

2194
01:25:36,560 --> 01:25:38,400
kernel exit so let's say we have a joint

2195
01:25:38,400 --> 01:25:40,239
one single page table that's the one

2196
01:25:40,239 --> 01:25:43,600
year shown correct and we're jumping out

2197
01:25:43,600 --> 01:25:44,800
of the kernel

2198
01:25:44,800 --> 01:25:49,679
uh through useret uh and our goal is to

2199
01:25:49,679 --> 01:25:51,360
uh we're still running in kernel mode so

2200
01:25:51,360 --> 01:25:53,360
this page certainly accessible correct

2201
01:25:53,360 --> 01:25:55,679
in the by the kernel the guard page

2202
01:25:55,679 --> 01:25:57,360
i'll show you not the card page what i'm

2203
01:25:57,360 --> 01:26:01,040
saying the trampoline page is there

2204
01:26:01,040 --> 01:26:05,120
and presumably uh somewhere

2205
01:26:05,120 --> 01:26:08,239
we need to map maybe

2206
01:26:08,239 --> 01:26:11,669
the

2207
01:26:11,679 --> 01:26:14,880
uh well the user trap train we don't

2208
01:26:14,880 --> 01:26:15,360
really

2209
01:26:15,360 --> 01:26:17,440
uh we have access to anyway right

2210
01:26:17,440 --> 01:26:18,880
because we're running kernel mode we

2211
01:26:18,880 --> 01:26:20,560
know where it sits in the proc structure

2212
01:26:20,560 --> 01:26:20,880
or

2213
01:26:20,880 --> 01:26:23,840
we can get it so i think we can just

2214
01:26:23,840 --> 01:26:25,840
exit

2215
01:26:25,840 --> 01:26:28,960
and when we return uh

2216
01:26:28,960 --> 01:26:30,719
then the user code can just run you know

2217
01:26:30,719 --> 01:26:36,480
we of course the ubit is a bit of a

2218
01:26:36,480 --> 01:26:38,320
well the ubit is only set on pages that

2219
01:26:38,320 --> 01:26:40,239
actually sit in the user space so that's

2220
01:26:40,239 --> 01:26:41,199
fine too

2221
01:26:41,199 --> 01:26:43,360
so when we enter the color back in you

2222
01:26:43,360 --> 01:26:44,880
know we're still with this page table

2223
01:26:44,880 --> 01:26:46,880
that page table already has

2224
01:26:46,880 --> 01:26:48,880
all the kernel now mapped and we could

2225
01:26:48,880 --> 01:26:50,080
just you know copy

2226
01:26:50,080 --> 01:26:51,360
you know the registers that we need to

2227
01:26:51,360 --> 01:26:54,239
save into the proc structure directly

2228
01:26:54,239 --> 01:26:57,360
instead of having to go through the uh

2229
01:26:57,360 --> 01:26:58,560
have a separate page with the proc

2230
01:26:58,560 --> 01:27:01,280
struct in it so i believe the change

2231
01:27:01,280 --> 01:27:02,400
would be

2232
01:27:02,400 --> 01:27:05,600
pretty straightforward okay

2233
01:27:05,600 --> 01:27:09,120
i see thank you but of course

2234
01:27:09,120 --> 01:27:12,239
i could be wrong oh yeah i'm

2235
01:27:12,239 --> 01:27:16,080
i'm now gonna try it now to

