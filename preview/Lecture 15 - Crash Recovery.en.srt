1
00:00:00,240 --> 00:00:03,760
and can everybody see my uh screen

2
00:00:03,760 --> 00:00:06,960
or the whiteboard that i shared yeah

3
00:00:06,960 --> 00:00:10,719
okay good yeah how are people doing with

4
00:00:10,719 --> 00:00:11,040
the

5
00:00:11,040 --> 00:00:13,840
log lab let me start there and just ask

6
00:00:13,840 --> 00:00:15,759
if

7
00:00:15,759 --> 00:00:18,800
how progress is and whether it's more

8
00:00:18,800 --> 00:00:19,600
difficult or

9
00:00:19,600 --> 00:00:22,720
it's looking okay anybody who want to

10
00:00:22,720 --> 00:00:28,830
sort of report in their experience so

11
00:00:28,840 --> 00:00:30,400
far

12
00:00:30,400 --> 00:00:37,030
i hope lots of people have started

13
00:00:37,040 --> 00:00:40,160
are you welcome yeah go ahead

14
00:00:40,160 --> 00:00:45,200
oh sorry go ahead okay oh okay cool

15
00:00:45,200 --> 00:00:48,640
i'll go i'll go um the lock lab

16
00:00:48,640 --> 00:00:52,790
i think the first part the um

17
00:00:52,800 --> 00:00:56,320
the k lock was

18
00:00:56,320 --> 00:00:59,600
not as bad well and then the second part

19
00:00:59,600 --> 00:01:00,559
um

20
00:01:00,559 --> 00:01:02,719
was a bit harder well it's a lot harder

21
00:01:02,719 --> 00:01:03,600
in my opinion

22
00:01:03,600 --> 00:01:10,830
yep um you just have to figure out

23
00:01:10,840 --> 00:01:14,400
a i guess the hard part was

24
00:01:14,400 --> 00:01:17,680
thinking of a solution that um it's like

25
00:01:17,680 --> 00:01:19,759
hey this doesn't cause deadlock but then

26
00:01:19,759 --> 00:01:20,799
um

27
00:01:20,799 --> 00:01:24,320
if you think there are cases where like

28
00:01:24,320 --> 00:01:28,080
deadlock could happen if you acquire

29
00:01:28,080 --> 00:01:30,320
a bucket slot again and all that stuff

30
00:01:30,320 --> 00:01:32,240
but

31
00:01:32,240 --> 00:01:34,240
yeah just have to think you have to

32
00:01:34,240 --> 00:01:35,280
think like

33
00:01:35,280 --> 00:01:37,600
about extra cases and all that stuff and

34
00:01:37,600 --> 00:01:39,439
after that it shouldn't be that bad

35
00:01:39,439 --> 00:01:41,280
okay anybody else who want to share

36
00:01:41,280 --> 00:01:43,200
their experience

37
00:01:43,200 --> 00:01:46,399
so far i wanted to ask uh are we allowed

38
00:01:46,399 --> 00:01:48,240
to do any part of the lab like

39
00:01:48,240 --> 00:01:50,720
lock free because i know like their

40
00:01:50,720 --> 00:01:52,720
first part for example is pretty

41
00:01:52,720 --> 00:01:54,799
the instructions said pretty clearly

42
00:01:54,799 --> 00:01:57,840
like make apparel memory allocator but

43
00:01:57,840 --> 00:02:00,719
uh can we do it just lock free and a

44
00:02:00,719 --> 00:02:01,360
sing

45
00:02:01,360 --> 00:02:03,840
you know just leave it as it is yeah

46
00:02:03,840 --> 00:02:04,640
you're free to do

47
00:02:04,640 --> 00:02:07,680
uh any solution that passes make great

48
00:02:07,680 --> 00:02:11,760
uh is fine lock free

49
00:02:11,760 --> 00:02:13,680
i would be you could certainly free to

50
00:02:13,680 --> 00:02:14,800
do it

51
00:02:14,800 --> 00:02:16,879
i'd be hesitant to start there if i were

52
00:02:16,879 --> 00:02:18,879
you i would start first with

53
00:02:18,879 --> 00:02:21,040
a more fine-grained lock implementation

54
00:02:21,040 --> 00:02:22,480
and then move to a lock free

55
00:02:22,480 --> 00:02:24,959
implementation

56
00:02:24,959 --> 00:02:26,800
so the re the reason i started with a

57
00:02:26,800 --> 00:02:28,800
lock free is because if you go to a fine

58
00:02:28,800 --> 00:02:30,319
grained you need to do all of the

59
00:02:30,319 --> 00:02:31,920
parallel stuff but if you just go

60
00:02:31,920 --> 00:02:33,680
directly to a lot free one then you can

61
00:02:33,680 --> 00:02:34,319
keep it

62
00:02:34,319 --> 00:02:36,640
on a single free list and you just need

63
00:02:36,640 --> 00:02:38,239
to you just need to

64
00:02:38,239 --> 00:02:41,519
uh uh autonomous size the

65
00:02:41,519 --> 00:02:43,200
free and allocate operations so it

66
00:02:43,200 --> 00:02:45,120
actually isn't that bad

67
00:02:45,120 --> 00:02:47,280
yeah i think maybe in if there's a

68
00:02:47,280 --> 00:02:48,959
single list in the case of the k alert

69
00:02:48,959 --> 00:02:50,400
that might be the case i think you know

70
00:02:50,400 --> 00:02:51,280
the uh

71
00:02:51,280 --> 00:02:52,959
lock free b alec is going to be a little

72
00:02:52,959 --> 00:02:54,319
bit more complicated

73
00:02:54,319 --> 00:02:57,440
yeah that that i'm scared to do but

74
00:02:57,440 --> 00:03:01,589
that's the right reaction to have

75
00:03:01,599 --> 00:03:04,959
anybody else

76
00:03:04,959 --> 00:03:07,840
i found it a bit hard to debug those

77
00:03:07,840 --> 00:03:09,280
problems because it's not

78
00:03:09,280 --> 00:03:11,120
immediately clear what is happening so

79
00:03:11,120 --> 00:03:12,319
you have to

80
00:03:12,319 --> 00:03:15,440
go and sit with gdb and

81
00:03:15,440 --> 00:03:18,959
break break break and yeah

82
00:03:18,959 --> 00:03:21,680
yeah i think the the the one reason i'm

83
00:03:21,680 --> 00:03:23,360
always scared to get these lock laps uh

84
00:03:23,360 --> 00:03:23,760
so the

85
00:03:23,760 --> 00:03:25,680
laps is you know they're harder to debug

86
00:03:25,680 --> 00:03:27,360
and uh

87
00:03:27,360 --> 00:03:29,920
and you know the bug may not show up in

88
00:03:29,920 --> 00:03:31,200
every run

89
00:03:31,200 --> 00:03:34,400
and uh but hopefully it is very

90
00:03:34,400 --> 00:03:35,360
educational because

91
00:03:35,360 --> 00:03:37,360
like learning a lot of programming walks

92
00:03:37,360 --> 00:03:39,280
inside of a kernel is a real thing

93
00:03:39,280 --> 00:03:42,400
and uh but it is definitely a core

94
00:03:42,400 --> 00:03:44,159
challenge

95
00:03:44,159 --> 00:03:46,239
one one thing about uh maybe this is a

96
00:03:46,239 --> 00:03:48,480
node for the the

97
00:03:48,480 --> 00:03:50,400
encouraging node the next lab actually

98
00:03:50,400 --> 00:03:51,920
doesn't involve basically any

99
00:03:51,920 --> 00:03:53,040
concurrency

100
00:03:53,040 --> 00:03:55,200
uh and so hopefully that will be much

101
00:03:55,200 --> 00:04:00,080
much much more straightforward um

102
00:04:00,080 --> 00:04:03,200
i get i guess how do you how do you

103
00:04:03,200 --> 00:04:04,080
efficiently

104
00:04:04,080 --> 00:04:07,360
or effectively debug concurrent programs

105
00:04:07,360 --> 00:04:09,280
like with all those multiple threads

106
00:04:09,280 --> 00:04:13,120
using gdp i i use very basic stuff

107
00:04:13,120 --> 00:04:16,880
i have i use print statements

108
00:04:16,880 --> 00:04:19,359
but the main thing i rely on is i sort

109
00:04:19,359 --> 00:04:21,680
of try to write down or assertions for

110
00:04:21,680 --> 00:04:23,919
invariants that i think should be true

111
00:04:23,919 --> 00:04:25,520
at every point

112
00:04:25,520 --> 00:04:27,919
and if the insertion goes off then i

113
00:04:27,919 --> 00:04:29,120
know that you know there was something

114
00:04:29,120 --> 00:04:30,320
wrong in my thinking or

115
00:04:30,320 --> 00:04:33,280
the assertion was wrong and then i think

116
00:04:33,280 --> 00:04:34,080
for a while

117
00:04:34,080 --> 00:04:36,800
and i tried to decide what it is and

118
00:04:36,800 --> 00:04:37,360
then

119
00:04:37,360 --> 00:04:41,280
go from there the

120
00:04:41,280 --> 00:04:44,320
normal um for many other uh

121
00:04:44,320 --> 00:04:47,120
settings there are race detectors that

122
00:04:47,120 --> 00:04:47,919
can help you

123
00:04:47,919 --> 00:04:51,919
um uh and again you know basically flag

124
00:04:51,919 --> 00:04:52,800
code that may

125
00:04:52,800 --> 00:04:55,440
looks like it might be having problems

126
00:04:55,440 --> 00:04:56,240
or is

127
00:04:56,240 --> 00:04:59,680
prone to race conditions um but that's a

128
00:04:59,680 --> 00:05:00,960
whole set of other tools

129
00:05:00,960 --> 00:05:04,320
uh that we're you know not using uh

130
00:05:04,320 --> 00:05:07,199
and it's not that good but there's a

131
00:05:07,199 --> 00:05:08,720
little bit of a big step to actually

132
00:05:08,720 --> 00:05:11,600
get that all up and going and running so

133
00:05:11,600 --> 00:05:12,720
that's the other

134
00:05:12,720 --> 00:05:16,790
mechanism that people use race detectors

135
00:05:16,800 --> 00:05:18,639
and basically flag any any shared

136
00:05:18,639 --> 00:05:19,919
variable that is

137
00:05:19,919 --> 00:05:21,759
updated or red without actually holding

138
00:05:21,759 --> 00:05:24,320
a lock

139
00:05:24,320 --> 00:05:26,000
no that doesn't help you with dead locks

140
00:05:26,000 --> 00:05:27,600
like example in this lab in

141
00:05:27,600 --> 00:05:30,240
uh be cash lock you know the you get

142
00:05:30,240 --> 00:05:31,120
dead locks

143
00:05:31,120 --> 00:05:32,880
deadlocks are tend to be easier to debug

144
00:05:32,880 --> 00:05:34,639
correct because you can uh

145
00:05:34,639 --> 00:05:36,160
you get the panic and then you can look

146
00:05:36,160 --> 00:05:38,160
at the gdb you know the back trace and

147
00:05:38,160 --> 00:05:38,960
see actually what

148
00:05:38,960 --> 00:05:44,469
was involved in the deadlock

149
00:05:44,479 --> 00:05:49,990
does that make sense thank you

150
00:05:50,000 --> 00:05:52,400
okay another suggestion actually

151
00:05:52,400 --> 00:05:54,320
somebody uh posted on the feedback

152
00:05:54,320 --> 00:05:56,800
uh is you know the class is uh the

153
00:05:56,800 --> 00:05:57,919
tenant is getting a little bit

154
00:05:57,919 --> 00:05:58,960
lower than in the beginning of the

155
00:05:58,960 --> 00:06:00,479
semester and i think we might be small

156
00:06:00,479 --> 00:06:01,199
enough or

157
00:06:01,199 --> 00:06:03,600
uh on the size that it may be perfectly

158
00:06:03,600 --> 00:06:06,240
fine to actually have cameras on

159
00:06:06,240 --> 00:06:08,160
and so maybe i want to encourage you to

160
00:06:08,160 --> 00:06:09,680
if you ask a question to turn on your

161
00:06:09,680 --> 00:06:10,240
camera

162
00:06:10,240 --> 00:06:13,759
and you know it will hopefully improve

163
00:06:13,759 --> 00:06:15,520
you know our experience as if it's in

164
00:06:15,520 --> 00:06:17,280
the classroom as opposed to in a virtual

165
00:06:17,280 --> 00:06:19,039
meeting

166
00:06:19,039 --> 00:06:22,639
um and you don't have to look at me

167
00:06:22,639 --> 00:06:25,919
okay um so

168
00:06:25,919 --> 00:06:28,639
uh okay today's lecture uh so today's

169
00:06:28,639 --> 00:06:29,840
lecture is going to be about crash

170
00:06:29,840 --> 00:06:30,560
safety

171
00:06:30,560 --> 00:06:32,960
uh crash safety and file systems and

172
00:06:32,960 --> 00:06:34,560
this is not crest safety in in

173
00:06:34,560 --> 00:06:36,160
the most general forum i'm actually

174
00:06:36,160 --> 00:06:39,440
really focusing on a particular problem

175
00:06:39,440 --> 00:06:43,520
um or a specific problem

176
00:06:43,520 --> 00:06:47,440
namely that a crash or a power failure

177
00:06:47,440 --> 00:06:52,150
can lead

178
00:06:52,160 --> 00:06:56,950
the on-disk file system

179
00:06:56,960 --> 00:06:59,360
to be in an inconsistent state or an

180
00:06:59,360 --> 00:07:03,990
incorrect state

181
00:07:04,000 --> 00:07:05,520
and what i mean with an incorrect state

182
00:07:05,520 --> 00:07:07,440
is you know for example a data block

183
00:07:07,440 --> 00:07:08,800
belongs to two files

184
00:07:08,800 --> 00:07:12,560
or an inode is allocated to two

185
00:07:12,560 --> 00:07:14,880
different files

186
00:07:14,880 --> 00:07:17,120
and so the scenario where this problem

187
00:07:17,120 --> 00:07:18,639
might sort of appear

188
00:07:18,639 --> 00:07:20,880
is let's say you know you're running a

189
00:07:20,880 --> 00:07:21,840
make

190
00:07:21,840 --> 00:07:24,080
uh make a pretty file system you know

191
00:07:24,080 --> 00:07:25,680
interacts with the file system

192
00:07:25,680 --> 00:07:28,080
region writes files and somewhere you

193
00:07:28,080 --> 00:07:28,880
know during

194
00:07:28,880 --> 00:07:30,720
you know that thing a power philly

195
00:07:30,720 --> 00:07:33,830
happens

196
00:07:33,840 --> 00:07:35,440
you know maybe your laptop runs out of

197
00:07:35,440 --> 00:07:36,880
battery you know maybe

198
00:07:36,880 --> 00:07:40,400
the power just dropped or to your house

199
00:07:40,400 --> 00:07:45,440
uh and uh and you know you reboot

200
00:07:45,440 --> 00:07:47,520
the your power comes back on at some

201
00:07:47,520 --> 00:07:49,919
point you reboot the machine

202
00:07:49,919 --> 00:07:52,960
or machine comes back up and then you

203
00:07:52,960 --> 00:07:54,160
know hopefully you get a prompt again

204
00:07:54,160 --> 00:07:55,680
you run ls

205
00:07:55,680 --> 00:07:57,199
and you hope basically that your file

206
00:07:57,199 --> 00:07:59,440
system is in a good state

207
00:07:59,440 --> 00:08:00,879
in the state it actually can still use

208
00:08:00,879 --> 00:08:03,039
it and so the particular

209
00:08:03,039 --> 00:08:04,639
failures or crashes that we're concerned

210
00:08:04,639 --> 00:08:06,560
about are basically power failures

211
00:08:06,560 --> 00:08:08,639
during file system operations

212
00:08:08,639 --> 00:08:12,160
or the kernel panics you know

213
00:08:12,160 --> 00:08:13,919
while running some file system operation

214
00:08:13,919 --> 00:08:15,759
you know xv6 is panics most kernels are

215
00:08:15,759 --> 00:08:17,599
panics you know maybe there's some

216
00:08:17,599 --> 00:08:19,840
kernel bug that causes a panic and now

217
00:08:19,840 --> 00:08:20,800
suddenly your system

218
00:08:20,800 --> 00:08:23,199
just fails and what you like to be the

219
00:08:23,199 --> 00:08:24,560
case is that after reboot you know you

220
00:08:24,560 --> 00:08:26,560
can actually do something

221
00:08:26,560 --> 00:08:28,720
or you can still use the file system and

222
00:08:28,720 --> 00:08:29,919
this might be something when you're

223
00:08:29,919 --> 00:08:30,560
thinking well

224
00:08:30,560 --> 00:08:32,240
how could that not be right because the

225
00:08:32,240 --> 00:08:34,240
file system you know stored on a

226
00:08:34,240 --> 00:08:35,599
persistent storage medium

227
00:08:35,599 --> 00:08:38,479
and so if the power fails you know the

228
00:08:38,479 --> 00:08:40,080
medium should be good and so when the

229
00:08:40,080 --> 00:08:41,519
machine comes back up you know all the

230
00:08:41,519 --> 00:08:42,719
blocks that you've written should be

231
00:08:42,719 --> 00:08:43,680
there

232
00:08:43,680 --> 00:08:45,519
and we'll see that the tricky case is

233
00:08:45,519 --> 00:08:49,120
that many file system operations have

234
00:08:49,120 --> 00:08:53,200
multi-step operations and really what is

235
00:08:53,200 --> 00:08:55,360
important in those mold and if we if we

236
00:08:55,360 --> 00:08:56,320
crash just

237
00:08:56,320 --> 00:08:58,720
in the wrong place in these multi-step

238
00:08:58,720 --> 00:08:59,519
operations

239
00:08:59,519 --> 00:09:01,279
the file system actually may end up

240
00:09:01,279 --> 00:09:03,120
being on disk inconsistent for

241
00:09:03,120 --> 00:09:04,959
that short period of time and if the

242
00:09:04,959 --> 00:09:06,720
power flow just happened there

243
00:09:06,720 --> 00:09:08,800
you know something bad could happen and

244
00:09:08,800 --> 00:09:10,480
so that is sort of the problem that

245
00:09:10,480 --> 00:09:12,080
we're uh

246
00:09:12,080 --> 00:09:14,640
focusing on uh today and so this is

247
00:09:14,640 --> 00:09:15,920
different from the problem that for

248
00:09:15,920 --> 00:09:17,279
example whatever you know there's a

249
00:09:17,279 --> 00:09:19,120
power failure and your disc you know

250
00:09:19,120 --> 00:09:19,920
caught fire

251
00:09:19,920 --> 00:09:22,240
and so there's nothing there anymore and

252
00:09:22,240 --> 00:09:23,279
so you need to

253
00:09:23,279 --> 00:09:25,279
in that case you know you need to you

254
00:09:25,279 --> 00:09:26,480
need there's a completely different

255
00:09:26,480 --> 00:09:27,920
problem that has different solutions

256
00:09:27,920 --> 00:09:29,680
you know for example you have to go back

257
00:09:29,680 --> 00:09:31,040
to a backup

258
00:09:31,040 --> 00:09:32,800
of your file system you know reinstall

259
00:09:32,800 --> 00:09:35,200
your file system etc etc

260
00:09:35,200 --> 00:09:36,560
so that's the problem we're not worried

261
00:09:36,560 --> 00:09:38,080
about we're really worried about the

262
00:09:38,080 --> 00:09:40,000
specific problem of

263
00:09:40,000 --> 00:09:43,040
failure happening right during a

264
00:09:43,040 --> 00:09:46,310
multi-step operation

265
00:09:46,320 --> 00:09:48,880
okay and the solution for that specific

266
00:09:48,880 --> 00:09:51,040
problem that we're going to be exploring

267
00:09:51,040 --> 00:09:53,440
is something that is called logging and

268
00:09:53,440 --> 00:09:55,120
this is a very popular

269
00:09:55,120 --> 00:09:59,440
uh solution uh originally uh

270
00:09:59,440 --> 00:10:01,440
coming out of the database world but a

271
00:10:01,440 --> 00:10:02,720
lot of file systems

272
00:10:02,720 --> 00:10:05,920
use logging these days

273
00:10:05,920 --> 00:10:07,920
we're going to it's a very one reason

274
00:10:07,920 --> 00:10:09,440
it's popular because it's a very

275
00:10:09,440 --> 00:10:12,160
principled solution

276
00:10:12,160 --> 00:10:14,160
and we're going to see the instantiation

277
00:10:14,160 --> 00:10:15,200
of logging

278
00:10:15,200 --> 00:10:18,240
in xc6 and of course xp6 has a very

279
00:10:18,240 --> 00:10:19,920
simple implementation like a bare

280
00:10:19,920 --> 00:10:20,640
minimal

281
00:10:20,640 --> 00:10:22,959
uh implementation of logging just to

282
00:10:22,959 --> 00:10:25,200
demonstrate you know the key ideas

283
00:10:25,200 --> 00:10:28,399
um and even that sort of uh very bare

284
00:10:28,399 --> 00:10:30,160
bone uh log implementation actually has

285
00:10:30,160 --> 00:10:31,360
some subtle issues that we're going to

286
00:10:31,360 --> 00:10:32,000
be

287
00:10:32,000 --> 00:10:33,920
talking about and that's why it's worth

288
00:10:33,920 --> 00:10:36,079
kind of studying it

289
00:10:36,079 --> 00:10:38,160
one downside to this we'll see if the

290
00:10:38,160 --> 00:10:40,079
xv6 solution is because of simplicity

291
00:10:40,079 --> 00:10:40,959
its performance

292
00:10:40,959 --> 00:10:43,760
is also not so great even though locking

293
00:10:43,760 --> 00:10:45,200
systems in principle can get good

294
00:10:45,200 --> 00:10:46,240
performance

295
00:10:46,240 --> 00:10:49,040
and so what we'll do next week is

296
00:10:49,040 --> 00:10:49,920
actually look

297
00:10:49,920 --> 00:10:52,480
uh how to implement a high performance

298
00:10:52,480 --> 00:10:53,600
logging system

299
00:10:53,600 --> 00:10:56,480
by studying the logging system that the

300
00:10:56,480 --> 00:10:59,440
linux ext3 file system uses

301
00:10:59,440 --> 00:11:03,200
uh but that's next week another

302
00:11:03,200 --> 00:11:05,519
maybe small point one i want to make

303
00:11:05,519 --> 00:11:07,440
today is that this is our last

304
00:11:07,440 --> 00:11:10,560
xv6 lecture uh and from now on we're

305
00:11:10,560 --> 00:11:12,399
going to be switching to

306
00:11:12,399 --> 00:11:15,360
uh papers because in some ways what

307
00:11:15,360 --> 00:11:17,040
we've done is we sort of covered you

308
00:11:17,040 --> 00:11:18,640
know the basic concepts

309
00:11:18,640 --> 00:11:20,000
and we can start looking at more

310
00:11:20,000 --> 00:11:22,720
advanced uh operating system ids by

311
00:11:22,720 --> 00:11:23,440
reading

312
00:11:23,440 --> 00:11:27,040
papers okay

313
00:11:27,040 --> 00:11:34,470
any questions so far

314
00:11:34,480 --> 00:11:37,990
we're all good

315
00:11:38,000 --> 00:11:41,440
okay um so let me go back a little bit

316
00:11:41,440 --> 00:11:43,279
about like the scenario that we really

317
00:11:43,279 --> 00:11:46,560
uh that we're focusing about uh in this

318
00:11:46,560 --> 00:11:47,600
lecture

319
00:11:47,600 --> 00:11:50,399
so uh file systems or file system

320
00:11:50,399 --> 00:11:52,320
operations

321
00:11:52,320 --> 00:11:55,839
like creating a file writing a file are

322
00:11:55,839 --> 00:11:57,040
multi-step

323
00:11:57,040 --> 00:12:07,430
disk operations

324
00:12:07,440 --> 00:12:09,440
and you know we saw that last week or

325
00:12:09,440 --> 00:12:10,800
monday we talked about how

326
00:12:10,800 --> 00:12:12,240
create is implemented like creating a

327
00:12:12,240 --> 00:12:14,320
file or writing to a file we often see

328
00:12:14,320 --> 00:12:15,200
that you know the

329
00:12:15,200 --> 00:12:16,720
sequence of events is or something of

330
00:12:16,720 --> 00:12:18,399
the sequence of steps are you know

331
00:12:18,399 --> 00:12:20,320
allocate an inode or mark the inode

332
00:12:20,320 --> 00:12:21,600
allocated on disk

333
00:12:21,600 --> 00:12:23,519
then you know write the directory block

334
00:12:23,519 --> 00:12:25,120
that contains that inode and so those

335
00:12:25,120 --> 00:12:26,480
are the multi steps that i'm talking

336
00:12:26,480 --> 00:12:27,360
about

337
00:12:27,360 --> 00:12:30,160
and if we get a crash between two of

338
00:12:30,160 --> 00:12:31,120
these steps

339
00:12:31,120 --> 00:12:35,430
that can that crash can leave

340
00:12:35,440 --> 00:12:38,320
may leave the may leave the file system

341
00:12:38,320 --> 00:12:41,030
in variance

342
00:12:41,040 --> 00:12:45,350
violated

343
00:12:45,360 --> 00:12:48,399
and the viola the invariants i'm talking

344
00:12:48,399 --> 00:12:50,240
about are invariants of the form

345
00:12:50,240 --> 00:12:53,360
you know every uh block is either free

346
00:12:53,360 --> 00:12:56,320
or allocated to one file and not to two

347
00:12:56,320 --> 00:12:57,360
files

348
00:12:57,360 --> 00:12:59,200
uh and you know we might want to make

349
00:12:59,200 --> 00:13:01,200
sure that this happens despite you know

350
00:13:01,200 --> 00:13:01,680
these

351
00:13:01,680 --> 00:13:04,839
failures uh right between uh these uh

352
00:13:04,839 --> 00:13:06,800
operations

353
00:13:06,800 --> 00:13:09,839
um and the risk is if

354
00:13:09,839 --> 00:13:12,399
if the violence if if these invariants

355
00:13:12,399 --> 00:13:13,839
are violated

356
00:13:13,839 --> 00:13:15,600
the you know bad things can happen after

357
00:13:15,600 --> 00:13:17,600
reboot

358
00:13:17,600 --> 00:13:20,240
uh you know the you might crash again

359
00:13:20,240 --> 00:13:21,839
immediately

360
00:13:21,839 --> 00:13:23,040
because you know there's some data

361
00:13:23,040 --> 00:13:25,040
structure the file system now now in the

362
00:13:25,040 --> 00:13:26,240
state that the file system actually

363
00:13:26,240 --> 00:13:28,000
can't really deal with you know on this

364
00:13:28,000 --> 00:13:29,839
data structures there's in such a

365
00:13:29,839 --> 00:13:31,519
shape that the file system really can't

366
00:13:31,519 --> 00:13:33,360
uh process them anymore

367
00:13:33,360 --> 00:13:36,800
or more likely you not crash

368
00:13:36,800 --> 00:13:41,279
no crash but you know data may get lost

369
00:13:41,279 --> 00:13:52,710
or you read or write incorrect data

370
00:13:52,720 --> 00:13:54,480
uh and we'll see a couple of examples

371
00:13:54,480 --> 00:13:56,079
you know to make that more clear

372
00:13:56,079 --> 00:13:58,480
uh but so basically the risks that we're

373
00:13:58,480 --> 00:14:02,000
worried about

374
00:14:02,000 --> 00:14:03,519
don't know if anybody actually ever in

375
00:14:03,519 --> 00:14:05,760
personal life or like when in your

376
00:14:05,760 --> 00:14:07,760
daily life uh using computers actually

377
00:14:07,760 --> 00:14:09,120
has experienced this problem where

378
00:14:09,120 --> 00:14:10,000
basically

379
00:14:10,000 --> 00:14:13,279
uh you had a failure in the file system

380
00:14:13,279 --> 00:14:13,680
or

381
00:14:13,680 --> 00:14:14,880
you had a failure you had a power

382
00:14:14,880 --> 00:14:16,480
failure you know your machine rebooted

383
00:14:16,480 --> 00:14:17,199
or your phone

384
00:14:17,199 --> 00:14:20,639
restart it and uh that basically was

385
00:14:20,639 --> 00:14:21,920
unusable afterwards

386
00:14:21,920 --> 00:14:24,880
and uh the one reason that might be

387
00:14:24,880 --> 00:14:26,079
unusual because

388
00:14:26,079 --> 00:14:28,839
the file system just didn't recover

389
00:14:28,839 --> 00:14:37,350
correctly

390
00:14:37,360 --> 00:14:39,839
okay so to make it more clear let's just

391
00:14:39,839 --> 00:14:41,199
let's look at an example

392
00:14:41,199 --> 00:14:43,920
in the context of actually like to make

393
00:14:43,920 --> 00:14:44,240
this

394
00:14:44,240 --> 00:14:45,920
risk a little bit more concrete let's

395
00:14:45,920 --> 00:14:48,720
look at an example in the context of xv6

396
00:14:48,720 --> 00:14:52,079
and to see what actually could go wrong

397
00:14:52,079 --> 00:14:56,639
so remember the uh for monday that the

398
00:14:56,639 --> 00:14:58,639
xv6 file system very simple file system

399
00:14:58,639 --> 00:15:00,480
it has a simple disk layout

400
00:15:00,480 --> 00:15:03,519
uh you know the super block uh

401
00:15:03,519 --> 00:15:05,040
there's the super block there's the log

402
00:15:05,040 --> 00:15:06,160
that we're going to be talking about a

403
00:15:06,160 --> 00:15:07,519
lot today that we didn't talk about on

404
00:15:07,519 --> 00:15:08,160
monday

405
00:15:08,160 --> 00:15:09,600
there are inodes you know it's a set of

406
00:15:09,600 --> 00:15:11,600
blocks that actually contain each and

407
00:15:11,600 --> 00:15:13,600
each block may contain multiple inodes

408
00:15:13,600 --> 00:15:15,199
there's a bitmap block you know to

409
00:15:15,199 --> 00:15:16,639
record which blocks are free

410
00:15:16,639 --> 00:15:18,880
and which are not free and then the data

411
00:15:18,880 --> 00:15:20,320
blocks that actually

412
00:15:20,320 --> 00:15:21,839
you know contain the actual data of the

413
00:15:21,839 --> 00:15:23,760
file system

414
00:15:23,760 --> 00:15:26,320
and remember from monday's lecture i

415
00:15:26,320 --> 00:15:28,000
reproduced the trace here you know we

416
00:15:28,000 --> 00:15:28,480
looked at

417
00:15:28,480 --> 00:15:31,600
actually how a file is created and you

418
00:15:31,600 --> 00:15:32,480
know we

419
00:15:32,480 --> 00:15:35,360
see that the creation of a single file

420
00:15:35,360 --> 00:15:36,399
uh

421
00:15:36,399 --> 00:15:41,440
second uh

422
00:15:41,440 --> 00:15:44,240
uh the the creation of a single file uh

423
00:15:44,240 --> 00:15:45,519
consists of multiple

424
00:15:45,519 --> 00:15:47,440
operations so for example like in this

425
00:15:47,440 --> 00:15:50,639
particular scenario that i have here on

426
00:15:50,639 --> 00:15:54,240
on the slide uh we see that uh

427
00:15:54,240 --> 00:15:57,680
uh you know an internet is allocated

428
00:15:57,680 --> 00:15:59,519
uh and you know we know this because

429
00:15:59,519 --> 00:16:01,519
this block 33 is being written

430
00:16:01,519 --> 00:16:04,720
um and do we see that the audio is being

431
00:16:04,720 --> 00:16:06,160
initialized and then written again to

432
00:16:06,160 --> 00:16:09,360
block 33 then we see the block 46

433
00:16:09,360 --> 00:16:11,519
is written and that reason is written is

434
00:16:11,519 --> 00:16:13,440
predominantly because you know the

435
00:16:13,440 --> 00:16:16,079
directory block that actually contains x

436
00:16:16,079 --> 00:16:16,480
and

437
00:16:16,480 --> 00:16:18,320
the i know number for x is written to

438
00:16:18,320 --> 00:16:20,240
the disk then the inode

439
00:16:20,240 --> 00:16:22,560
root i node is updated to reflect that

440
00:16:22,560 --> 00:16:25,120
the directory has grown in size

441
00:16:25,120 --> 00:16:28,720
to contain this particular uh file x

442
00:16:28,720 --> 00:16:31,519
and then you know the inode is updated

443
00:16:31,519 --> 00:16:32,560
and so

444
00:16:32,560 --> 00:16:35,040
uh what we want to now understand is

445
00:16:35,040 --> 00:16:36,560
like what happens like what could

446
00:16:36,560 --> 00:16:37,839
possibly go wrong

447
00:16:37,839 --> 00:16:41,759
right and so let's say you know we

448
00:16:41,759 --> 00:16:45,040
uh have a power failure like right here

449
00:16:45,040 --> 00:16:48,839
so here is a power failure or kernel

450
00:16:48,839 --> 00:16:50,560
crash

451
00:16:50,560 --> 00:16:53,279
and so what happens after the power

452
00:16:53,279 --> 00:16:55,440
failure correct all the in-memory state

453
00:16:55,440 --> 00:16:58,160
is lost right because that in-memory

454
00:16:58,160 --> 00:16:58,639
state or

455
00:16:58,639 --> 00:17:00,800
the data that's actually in ram like all

456
00:17:00,800 --> 00:17:01,759
the processes

457
00:17:01,759 --> 00:17:04,640
all the file descriptors all the

458
00:17:04,640 --> 00:17:05,760
in-memory

459
00:17:05,760 --> 00:17:08,480
caches are gone because you know memory

460
00:17:08,480 --> 00:17:09,520
is not persistent

461
00:17:09,520 --> 00:17:11,199
and the only thing that we have left

462
00:17:11,199 --> 00:17:13,600
right is what actually is on the disk

463
00:17:13,600 --> 00:17:17,199
so only the data structures and

464
00:17:17,199 --> 00:17:18,319
the bits and bytes that are actually

465
00:17:18,319 --> 00:17:20,640
sitting on the disk are uh

466
00:17:20,640 --> 00:17:23,120
survive the power failure because that

467
00:17:23,120 --> 00:17:25,839
actually medium is you know persistence

468
00:17:25,839 --> 00:17:28,799
or has durability and so we want to know

469
00:17:28,799 --> 00:17:30,320
like we understand

470
00:17:30,320 --> 00:17:33,039
so if we crash here and we have no

471
00:17:33,039 --> 00:17:34,480
additional mechanisms

472
00:17:34,480 --> 00:17:36,720
uh or we have no logging as having that

473
00:17:36,720 --> 00:17:37,919
we're going to be talking about but

474
00:17:37,919 --> 00:17:40,400
we have no additional mechanisms uh how

475
00:17:40,400 --> 00:17:42,880
bad is it

476
00:17:42,880 --> 00:17:53,669
what what risk are we running here

477
00:17:53,679 --> 00:17:57,590
anybody

478
00:17:57,600 --> 00:17:59,919
so basically you know we've written uh

479
00:17:59,919 --> 00:18:01,440
block 33

480
00:18:01,440 --> 00:18:02,880
to record that the inode has been

481
00:18:02,880 --> 00:18:04,559
allocated then we had a power failure

482
00:18:04,559 --> 00:18:12,470
and then we come back up

483
00:18:12,480 --> 00:18:14,720
go ahead brandon this does that mean we

484
00:18:14,720 --> 00:18:15,919
lose the

485
00:18:15,919 --> 00:18:19,600
um lose this block it's like it seems

486
00:18:19,600 --> 00:18:21,440
like it's populated but it's actually

487
00:18:21,440 --> 00:18:22,320
not

488
00:18:22,320 --> 00:18:24,880
yeah i think we're losing the we're not

489
00:18:24,880 --> 00:18:26,400
really the whole block but we use the

490
00:18:26,400 --> 00:18:27,280
inode x

491
00:18:27,280 --> 00:18:30,160
right the inode x or the i note 4 x that

492
00:18:30,160 --> 00:18:31,600
was allocated or this marked as

493
00:18:31,600 --> 00:18:32,799
allocated

494
00:18:32,799 --> 00:18:35,520
is allocated on disk but we have not put

495
00:18:35,520 --> 00:18:36,559
it in any

496
00:18:36,559 --> 00:18:39,039
uh we've not succeeded correct in

497
00:18:39,039 --> 00:18:41,039
putting it in any directory

498
00:18:41,039 --> 00:18:42,640
so basically on the disk you know

499
00:18:42,640 --> 00:18:44,000
there's an eye node allocated but it

500
00:18:44,000 --> 00:18:46,000
doesn't appear in any directory

501
00:18:46,000 --> 00:18:49,120
so we can't even remove it right and so

502
00:18:49,120 --> 00:18:50,080
basically what

503
00:18:50,080 --> 00:18:51,919
will this cause is to happen is we lost

504
00:18:51,919 --> 00:18:57,039
we lose an inode

505
00:18:57,039 --> 00:19:01,110
does that make sense

506
00:19:01,120 --> 00:19:02,799
so you might think well maybe what i

507
00:19:02,799 --> 00:19:04,400
should do is like maybe i should reorder

508
00:19:04,400 --> 00:19:05,840
the right

509
00:19:05,840 --> 00:19:08,000
and in a way you know that hopefully you

510
00:19:08,000 --> 00:19:09,360
know this you know we don't lose the i

511
00:19:09,360 --> 00:19:10,640
know so for example another thing we

512
00:19:10,640 --> 00:19:12,320
could try doing is say well what we'll

513
00:19:12,320 --> 00:19:13,120
do is

514
00:19:13,120 --> 00:19:16,960
we'll uh write 46

515
00:19:16,960 --> 00:19:19,840
first basically update the i know update

516
00:19:19,840 --> 00:19:20,960
the directory

517
00:19:20,960 --> 00:19:24,559
write the directory inode

518
00:19:24,559 --> 00:19:26,480
we're going to write 32 and then we'll

519
00:19:26,480 --> 00:19:28,640
actually mark the inode as allocated

520
00:19:28,640 --> 00:19:32,470
on disk

521
00:19:32,480 --> 00:19:35,200
to mark it as indicate that the market

522
00:19:35,200 --> 00:19:36,480
is allocated

523
00:19:36,480 --> 00:19:38,400
so we do the same a set of operations in

524
00:19:38,400 --> 00:19:40,000
a slightly different order

525
00:19:40,000 --> 00:19:42,720
uh in the hope that we should uh avoid

526
00:19:42,720 --> 00:19:44,080
this losing of the inode

527
00:19:44,080 --> 00:19:50,870
problem and would this work

528
00:19:50,880 --> 00:19:52,400
well the thing that we should do ask

529
00:19:52,400 --> 00:19:54,160
ourselves like you know let's

530
00:19:54,160 --> 00:19:56,240
think about this point in time let's say

531
00:19:56,240 --> 00:19:58,320
a crash happens like right here or power

532
00:19:58,320 --> 00:19:59,440
failure happens right

533
00:19:59,440 --> 00:20:02,080
between uh updating the directory

534
00:20:02,080 --> 00:20:02,640
basically

535
00:20:02,640 --> 00:20:04,799
but before we allocated the inode on

536
00:20:04,799 --> 00:20:06,480
disk and now you know we

537
00:20:06,480 --> 00:20:09,120
power fails machine comes back up and we

538
00:20:09,120 --> 00:20:10,240
look at the file system

539
00:20:10,240 --> 00:20:11,760
you know what what state will the file

540
00:20:11,760 --> 00:20:15,029
system be in

541
00:20:15,039 --> 00:20:19,280
you'll still think it's a free inode and

542
00:20:19,280 --> 00:20:21,360
yeah what would happen if for example we

543
00:20:21,360 --> 00:20:22,799
read you know the file x in the

544
00:20:22,799 --> 00:20:23,600
directory

545
00:20:23,600 --> 00:20:24,960
in the root directory because it is the

546
00:20:24,960 --> 00:20:29,990
in there now correcting this data block

547
00:20:30,000 --> 00:20:31,360
we're going to be reading the inode that

548
00:20:31,360 --> 00:20:32,799
actually is not even allocated correct

549
00:20:32,799 --> 00:20:35,440
there's more only allocated

550
00:20:35,440 --> 00:20:37,600
and worse what could happen is correct

551
00:20:37,600 --> 00:20:39,440
that it might be allocated again

552
00:20:39,440 --> 00:20:41,760
or might actually really be allocated uh

553
00:20:41,760 --> 00:20:43,600
because it's a mark is unallocated to

554
00:20:43,600 --> 00:20:46,000
actually in fact a different file

555
00:20:46,000 --> 00:20:48,880
correct and so now we have two files

556
00:20:48,880 --> 00:20:50,080
that might actually

557
00:20:50,080 --> 00:20:52,400
uh the two files that actually share

558
00:20:52,400 --> 00:20:53,440
even though they're completely different

559
00:20:53,440 --> 00:20:55,039
they share the same inode

560
00:20:55,039 --> 00:20:56,799
and so for example if one you know file

561
00:20:56,799 --> 00:20:58,400
would be owned by user one and one by

562
00:20:58,400 --> 00:21:00,000
user two then basically user two could

563
00:21:00,000 --> 00:21:01,120
read user one's file

564
00:21:01,120 --> 00:21:04,720
a data right so this is no good either

565
00:21:04,720 --> 00:21:11,110
right

566
00:21:11,120 --> 00:21:14,559
does that make sense so basically

567
00:21:14,559 --> 00:21:16,080
switching you know the order you know is

568
00:21:16,080 --> 00:21:18,480
not really going to solve our problem

569
00:21:18,480 --> 00:21:20,400
uh we just basically get a different

570
00:21:20,400 --> 00:21:23,520
problem that we had before

571
00:21:23,520 --> 00:21:26,480
okay let's look at one more example uh

572
00:21:26,480 --> 00:21:27,360
here's the

573
00:21:27,360 --> 00:21:31,200
uh example of writing

574
00:21:31,200 --> 00:21:35,029
to file x

575
00:21:35,039 --> 00:21:36,559
so once we have the files allocated

576
00:21:36,559 --> 00:21:38,080
let's say that all succeeded and now

577
00:21:38,080 --> 00:21:40,000
we're executing the right system call

578
00:21:40,000 --> 00:21:41,919
and the right system call also does uh

579
00:21:41,919 --> 00:21:43,679
multiple writes operations which we saw

580
00:21:43,679 --> 00:21:44,559
in one day

581
00:21:44,559 --> 00:21:46,159
you know example it will allocate a

582
00:21:46,159 --> 00:21:49,120
block in this case to block 45

583
00:21:49,120 --> 00:21:52,480
so it sets a bit in the free map

584
00:21:52,480 --> 00:21:55,679
the block 45 is the bitmap block

585
00:21:55,679 --> 00:21:57,919
so it allocates a block in the bitmap it

586
00:21:57,919 --> 00:22:00,080
allocates a bit in the bitmap block to

587
00:22:00,080 --> 00:22:02,480
indicate that that block has now be

588
00:22:02,480 --> 00:22:03,440
allocated

589
00:22:03,440 --> 00:22:06,640
uh that block turns out to be 595.

590
00:22:06,640 --> 00:22:08,640
and then we write you know uh the

591
00:22:08,640 --> 00:22:10,000
character h you know to

592
00:22:10,000 --> 00:22:12,000
595 and then the character i and then we

593
00:22:12,000 --> 00:22:13,919
update the i dot

594
00:22:13,919 --> 00:22:15,440
right now we can ask ourselves the same

595
00:22:15,440 --> 00:22:17,760
question like you know what will happen

596
00:22:17,760 --> 00:22:20,799
uh uh if

597
00:22:20,799 --> 00:22:23,120
we crash so for example let's say we

598
00:22:23,120 --> 00:22:24,000
allo crash

599
00:22:24,000 --> 00:22:27,200
like right here between you know writing

600
00:22:27,200 --> 00:22:30,960
the bitmap block but before we allocate

601
00:22:30,960 --> 00:22:33,760
uh before we actually write the i note

602
00:22:33,760 --> 00:22:40,000
so crash here

603
00:22:40,000 --> 00:22:41,919
and so we reboot you know we come back

604
00:22:41,919 --> 00:22:44,240
up and the disk is in a particular state

605
00:22:44,240 --> 00:22:50,149
and you know what what is the risk

606
00:22:50,159 --> 00:22:53,679
um we use a data block but we lose it

607
00:22:53,679 --> 00:22:55,120
yeah we lose it again correct because

608
00:22:55,120 --> 00:22:56,880
the block is allocated but it doesn't

609
00:22:56,880 --> 00:22:59,200
show up in any file

610
00:22:59,200 --> 00:23:01,440
because it hasn't been written into any

611
00:23:01,440 --> 00:23:08,559
inode so we lose a data block

612
00:23:08,559 --> 00:23:10,080
so you might think okay well maybe you

613
00:23:10,080 --> 00:23:11,520
know just because we wrote them in the

614
00:23:11,520 --> 00:23:13,039
wrong order what we should have done

615
00:23:13,039 --> 00:23:15,919
is uh what we should have done is at

616
00:23:15,919 --> 00:23:17,600
first write it in the inode

617
00:23:17,600 --> 00:23:20,799
so first write 33 with the

618
00:23:20,799 --> 00:23:24,559
you know with 595 as in the uh

619
00:23:24,559 --> 00:23:26,400
either as an indirect block or a direct

620
00:23:26,400 --> 00:23:28,320
block and then

621
00:23:28,320 --> 00:23:30,880
you know actually we will mark the i

622
00:23:30,880 --> 00:23:31,520
know this

623
00:23:31,520 --> 00:23:33,360
the block is allocated so then we'll

624
00:23:33,360 --> 00:23:36,720
write you know 45.

625
00:23:36,720 --> 00:23:38,240
right so we change the order because we

626
00:23:38,240 --> 00:23:39,760
want to avoid this lost data block and

627
00:23:39,760 --> 00:23:42,950
we change the order in this way

628
00:23:42,960 --> 00:23:44,640
and now let's consider the case if

629
00:23:44,640 --> 00:23:50,320
there's a failure right here

630
00:23:50,320 --> 00:23:56,870
what is the risk

631
00:23:56,880 --> 00:23:59,279
um the size of the file is not

632
00:23:59,279 --> 00:24:00,400
compatible with

633
00:24:00,400 --> 00:24:03,120
uh actually how many data blocks are

634
00:24:03,120 --> 00:24:04,640
allocated

635
00:24:04,640 --> 00:24:05,840
that might be although i think at the

636
00:24:05,840 --> 00:24:07,679
right of 33 actually update both the

637
00:24:07,679 --> 00:24:09,279
size and you know the

638
00:24:09,279 --> 00:24:13,279
uh the block number correct oh yeah

639
00:24:13,279 --> 00:24:16,640
so that might be might work out okay

640
00:24:16,640 --> 00:24:18,320
if there were two separate rights that

641
00:24:18,320 --> 00:24:20,799
would be a problem

642
00:24:20,799 --> 00:24:27,350
but there's some bigger problem here

643
00:24:27,360 --> 00:24:31,440
it's that the so the file

644
00:24:31,440 --> 00:24:35,120
has a so thinks that

645
00:24:35,120 --> 00:24:38,000
it has the data block but the data block

646
00:24:38,000 --> 00:24:38,960
is marked as

647
00:24:38,960 --> 00:24:42,799
uh unallocated and other

648
00:24:42,799 --> 00:24:46,000
um files can also use it yeah right now

649
00:24:46,000 --> 00:24:47,679
that's the real big problem here is that

650
00:24:47,679 --> 00:24:48,799
you know the

651
00:24:48,799 --> 00:24:51,279
the inode things the 590 from the block

652
00:24:51,279 --> 00:24:52,720
595 belong to

653
00:24:52,720 --> 00:24:54,799
belongs to that file but actually on

654
00:24:54,799 --> 00:24:56,000
disk it's still marked

655
00:24:56,000 --> 00:24:59,120
as unallocated and so

656
00:24:59,120 --> 00:25:01,120
when later another file was created you

657
00:25:01,120 --> 00:25:03,200
know that block actually might be

658
00:25:03,200 --> 00:25:05,679
used for that other file and so now

659
00:25:05,679 --> 00:25:06,400
certainly

660
00:25:06,400 --> 00:25:09,600
uh one file thinks it owns 595 but

661
00:25:09,600 --> 00:25:11,120
actually other file does and in fact

662
00:25:11,120 --> 00:25:13,120
both files will have 595

663
00:25:13,120 --> 00:25:16,400
in their uh block numbers for their

664
00:25:16,400 --> 00:25:17,360
inode

665
00:25:17,360 --> 00:25:20,480
and um and basically

666
00:25:20,480 --> 00:25:22,559
you know if one user owns that file the

667
00:25:22,559 --> 00:25:23,679
other usually on the other file the

668
00:25:23,679 --> 00:25:24,880
connection reader writes

669
00:25:24,880 --> 00:25:27,120
each other's data right it's clearly not

670
00:25:27,120 --> 00:25:28,240
what we want

671
00:25:28,240 --> 00:25:29,520
you know the file system should

672
00:25:29,520 --> 00:25:31,440
guarantee that every block

673
00:25:31,440 --> 00:25:33,840
only belongs in one file and no other

674
00:25:33,840 --> 00:25:34,720
file or

675
00:25:34,720 --> 00:25:38,720
is free okay

676
00:25:38,720 --> 00:25:41,200
so this could lead to security problems

677
00:25:41,200 --> 00:25:46,870
but basically block is shared

678
00:25:46,880 --> 00:25:50,080
among multiple files and that's

679
00:25:50,080 --> 00:25:55,269
definitely wrong

680
00:25:55,279 --> 00:25:57,600
does that make uh sense in terms of the

681
00:25:57,600 --> 00:25:59,200
problems that can appear

682
00:25:59,200 --> 00:26:01,679
and again you know this the real issue

683
00:26:01,679 --> 00:26:02,559
here is not to watch

684
00:26:02,559 --> 00:26:04,480
the ordering of the rights uh but the

685
00:26:04,480 --> 00:26:05,919
real underlying problem here is that

686
00:26:05,919 --> 00:26:07,360
we're just doing multiple writes and

687
00:26:07,360 --> 00:26:09,120
then basically have to sort of show up

688
00:26:09,120 --> 00:26:10,080
on disk

689
00:26:10,080 --> 00:26:18,870
as an atomic operation

690
00:26:18,880 --> 00:26:23,919
okay so the solution that we're gonna

691
00:26:23,919 --> 00:26:24,559
explore

692
00:26:24,559 --> 00:26:28,240
in this lecture is you know logging

693
00:26:28,240 --> 00:26:31,990
and as i said before this is a

694
00:26:32,000 --> 00:26:34,000
a common solution used in file systems

695
00:26:34,000 --> 00:26:35,120
and

696
00:26:35,120 --> 00:26:36,960
originating actually out of the database

697
00:26:36,960 --> 00:26:38,880
literature and it actually has a couple

698
00:26:38,880 --> 00:26:40,000
good properties

699
00:26:40,000 --> 00:26:42,320
one it's going to make basically system

700
00:26:42,320 --> 00:26:47,510
calls or file system calls atomic

701
00:26:47,520 --> 00:26:50,720
with that i mean so if a create file or

702
00:26:50,720 --> 00:26:51,279
you know

703
00:26:51,279 --> 00:26:53,039
you call create or you call write

704
00:26:53,039 --> 00:26:54,640
basically all the effects

705
00:26:54,640 --> 00:26:56,799
of the that system call just all appear

706
00:26:56,799 --> 00:26:58,400
altogether or none of them

707
00:26:58,400 --> 00:27:01,919
so that avoids this sort of problem of

708
00:27:01,919 --> 00:27:04,000
only some subset of the rights actually

709
00:27:04,000 --> 00:27:07,360
showing up on disk

710
00:27:07,360 --> 00:27:09,440
the second good property it has it

711
00:27:09,440 --> 00:27:12,789
allows for fast recovery

712
00:27:12,799 --> 00:27:15,600
so after reboot it turns out we don't

713
00:27:15,600 --> 00:27:17,039
actually have to do a lot of work to

714
00:27:17,039 --> 00:27:18,240
repair the file system

715
00:27:18,240 --> 00:27:21,120
actually a very minimal amount of work

716
00:27:21,120 --> 00:27:22,399
and this is in contrast to

717
00:27:22,399 --> 00:27:24,399
some other solution that i'm not talking

718
00:27:24,399 --> 00:27:25,600
about which is basically

719
00:27:25,600 --> 00:27:27,840
you go and inspect the file system and

720
00:27:27,840 --> 00:27:29,039
maybe you read all the blocks of the

721
00:27:29,039 --> 00:27:31,120
file system or read all the inode blocks

722
00:27:31,120 --> 00:27:33,840
read all the bitmap blocks and so check

723
00:27:33,840 --> 00:27:35,440
out whether the file system is still in

724
00:27:35,440 --> 00:27:36,880
the correct shape and maybe repair

725
00:27:36,880 --> 00:27:38,799
things

726
00:27:38,799 --> 00:27:40,640
logging has this nice property that

727
00:27:40,640 --> 00:27:42,880
actually the recovery is fast

728
00:27:42,880 --> 00:27:45,440
and then finally it is in principle it

729
00:27:45,440 --> 00:27:47,520
can be actually very high performance

730
00:27:47,520 --> 00:27:50,080
although the one you know the one we're

731
00:27:50,080 --> 00:27:51,200
going to be looking in the context of

732
00:27:51,200 --> 00:27:52,960
xv6 is not high performance

733
00:27:52,960 --> 00:27:55,039
so we're going to look at that next week

734
00:27:55,039 --> 00:27:56,240
we'll see actually how to build a

735
00:27:56,240 --> 00:27:57,520
logging system that

736
00:27:57,520 --> 00:27:59,760
has atomic file system calls fast

737
00:27:59,760 --> 00:28:01,600
recovery and high performance today

738
00:28:01,600 --> 00:28:02,720
we're going to be just focusing on the

739
00:28:02,720 --> 00:28:05,590
first two

740
00:28:05,600 --> 00:28:08,960
okay the basic idea of logging

741
00:28:08,960 --> 00:28:12,240
is actually straightforward

742
00:28:12,240 --> 00:28:13,679
and so basically what you do is you

743
00:28:13,679 --> 00:28:16,480
divide the disk in sort of two pieces

744
00:28:16,480 --> 00:28:20,399
it runs the log one is the file system

745
00:28:20,399 --> 00:28:21,919
and the file system might be much bigger

746
00:28:21,919 --> 00:28:24,080
than the log

747
00:28:24,080 --> 00:28:27,679
and when uh you need to update the file

748
00:28:27,679 --> 00:28:28,799
system so update

749
00:28:28,799 --> 00:28:32,320
let's say block 33 or update the bitmap

750
00:28:32,320 --> 00:28:33,279
block

751
00:28:33,279 --> 00:28:34,960
we're actually not going to update you

752
00:28:34,960 --> 00:28:36,799
know the file system blocks so

753
00:28:36,799 --> 00:28:38,240
we're not going to update the bitmap

754
00:28:38,240 --> 00:28:40,080
block directly instead the only thing

755
00:28:40,080 --> 00:28:41,679
we're going to do on the right

756
00:28:41,679 --> 00:28:44,559
is so here's our you know memory we have

757
00:28:44,559 --> 00:28:45,840
a block in memory

758
00:28:45,840 --> 00:28:48,399
this is say the bitmap block like it's

759
00:28:48,399 --> 00:28:49,520
45

760
00:28:49,520 --> 00:28:51,679
and instead of writing it to 45 what we

761
00:28:51,679 --> 00:28:52,960
normally would have done

762
00:28:52,960 --> 00:28:54,000
what we're going to do is actually going

763
00:28:54,000 --> 00:28:56,000
to write it into the log so we're going

764
00:28:56,000 --> 00:28:57,039
to stick it here

765
00:28:57,039 --> 00:28:58,960
and remember that actually should go to

766
00:28:58,960 --> 00:29:00,960
45

767
00:29:00,960 --> 00:29:03,120
but we don't put it there and we do that

768
00:29:03,120 --> 00:29:04,480
with all the other rights too so for

769
00:29:04,480 --> 00:29:06,080
example we'll put our

770
00:29:06,080 --> 00:29:09,120
inode block there you know that was like

771
00:29:09,120 --> 00:29:10,960
maybe 33 i think

772
00:29:10,960 --> 00:29:13,039
if i remember correctly and we'll stick

773
00:29:13,039 --> 00:29:14,320
it in there and

774
00:29:14,320 --> 00:29:15,840
you know remember that it actually has

775
00:29:15,840 --> 00:29:18,720
to go to 33.

776
00:29:18,720 --> 00:29:20,960
so basically what we do any right is

777
00:29:20,960 --> 00:29:24,549
first walked

778
00:29:24,559 --> 00:29:26,240
and so we don't write directly to the

779
00:29:26,240 --> 00:29:28,159
home location of the block but we just

780
00:29:28,159 --> 00:29:31,120
put it always in the in the log then at

781
00:29:31,120 --> 00:29:32,799
some point you know when the file system

782
00:29:32,799 --> 00:29:34,799
operation is done you know for example

783
00:29:34,799 --> 00:29:36,320
it has you know these four or five

784
00:29:36,320 --> 00:29:37,679
rights that we saw in the previous

785
00:29:37,679 --> 00:29:38,640
slides

786
00:29:38,640 --> 00:29:44,950
are in the log we commit the operation

787
00:29:44,960 --> 00:29:46,399
basically what it means is somewhere in

788
00:29:46,399 --> 00:29:48,159
the log we just record

789
00:29:48,159 --> 00:29:50,320
a record you know in a fixed location

790
00:29:50,320 --> 00:29:52,080
that basically says okay well

791
00:29:52,080 --> 00:29:54,720
you know there are like five blocks in

792
00:29:54,720 --> 00:29:55,600
the log

793
00:29:55,600 --> 00:29:58,640
and that is you know the the the launch

794
00:29:58,640 --> 00:30:01,600
set of locked rights

795
00:30:01,600 --> 00:30:04,159
and then you know when we have all the

796
00:30:04,159 --> 00:30:04,640
rights

797
00:30:04,640 --> 00:30:06,640
stably on disk uh we can actually

798
00:30:06,640 --> 00:30:08,159
install them so this is called the

799
00:30:08,159 --> 00:30:10,399
installation phase

800
00:30:10,399 --> 00:30:12,080
and really what that means is we're

801
00:30:12,080 --> 00:30:14,320
gonna move you know these logs from the

802
00:30:14,320 --> 00:30:16,000
lock to their home location so we know

803
00:30:16,000 --> 00:30:17,919
this one has to go to 45 so we'll put it

804
00:30:17,919 --> 00:30:20,080
at 45. this one has to go to 33

805
00:30:20,080 --> 00:30:21,840
you know report it 33 et cetera et

806
00:30:21,840 --> 00:30:23,360
cetera

807
00:30:23,360 --> 00:30:25,120
and once we're done you know basically

808
00:30:25,120 --> 00:30:26,559
we can clean the log

809
00:30:26,559 --> 00:30:29,750
and cleaning the log

810
00:30:29,760 --> 00:30:31,360
is basically your rewriting you know

811
00:30:31,360 --> 00:30:34,399
basically setting this 5 to 0.

812
00:30:34,399 --> 00:30:38,559
and that is a the basic plan

813
00:30:38,559 --> 00:30:40,480
and why is this plan good well let's

814
00:30:40,480 --> 00:30:41,840
think about it

815
00:30:41,840 --> 00:30:45,919
let's say we crash before here

816
00:30:45,919 --> 00:30:50,799
what would happen

817
00:30:50,799 --> 00:30:53,039
so let me hold that question let me

818
00:30:53,039 --> 00:30:55,279
actually talk about one thing before

819
00:30:55,279 --> 00:30:58,720
asking that question let's say we

820
00:30:58,720 --> 00:31:02,480
crash uh and so we reboot

821
00:31:02,480 --> 00:31:05,039
and on the reboot there's basically you

822
00:31:05,039 --> 00:31:07,200
what the file system does

823
00:31:07,200 --> 00:31:10,159
it looks like the commit record sees

824
00:31:10,159 --> 00:31:12,240
what the value of the commit record is

825
00:31:12,240 --> 00:31:15,679
if it is zero you know do nothing

826
00:31:15,679 --> 00:31:19,519
in our simple scheme and if it's

827
00:31:19,519 --> 00:31:20,960
bigger to zero we know that there are

828
00:31:20,960 --> 00:31:22,640
basically blocks in the log that

829
00:31:22,640 --> 00:31:25,039
need to be actually installed and we

830
00:31:25,039 --> 00:31:26,159
apparently didn't finish the

831
00:31:26,159 --> 00:31:27,039
installation

832
00:31:27,039 --> 00:31:29,039
now we crashed you know after the commit

833
00:31:29,039 --> 00:31:30,640
but before cleaning the log

834
00:31:30,640 --> 00:31:37,430
so basically we reinstall

835
00:31:37,440 --> 00:31:44,070
and after we reinstall we clean the lock

836
00:31:44,080 --> 00:31:47,919
okay and this scheme is good

837
00:31:47,919 --> 00:31:50,320
uh because it actually ensures that no

838
00:31:50,320 --> 00:31:51,840
matter where a crash happens

839
00:31:51,840 --> 00:31:54,000
we either install all the blocks of the

840
00:31:54,000 --> 00:31:55,840
rights or we install none of them

841
00:31:55,840 --> 00:31:58,399
but we're never in this uh we'll never

842
00:31:58,399 --> 00:32:00,480
end up in a situation where we installed

843
00:32:00,480 --> 00:32:01,519
some of the rights

844
00:32:01,519 --> 00:32:03,919
but not all of them and just to see why

845
00:32:03,919 --> 00:32:05,279
this is true let's consider a couple

846
00:32:05,279 --> 00:32:07,840
cases where things could crash

847
00:32:07,840 --> 00:32:09,760
so things could crash between one and

848
00:32:09,760 --> 00:32:16,630
two what will happen

849
00:32:16,640 --> 00:32:22,870
in what situation do we end up

850
00:32:22,880 --> 00:32:25,360
the situation in which on recovery we do

851
00:32:25,360 --> 00:32:26,000
nothing

852
00:32:26,000 --> 00:32:29,279
and that's okay because um nothing has

853
00:32:29,279 --> 00:32:31,679
been written to the file system yet yeah

854
00:32:31,679 --> 00:32:33,760
no no exactly so this is the case where

855
00:32:33,760 --> 00:32:34,720
basically

856
00:32:34,720 --> 00:32:37,279
uh we just do nothing you know as if the

857
00:32:37,279 --> 00:32:37,840
system called

858
00:32:37,840 --> 00:32:39,440
basically never executed right because

859
00:32:39,440 --> 00:32:41,120
as if the failure happened slightly

860
00:32:41,120 --> 00:32:42,799
earlier right before the file system

861
00:32:42,799 --> 00:32:44,080
call started

862
00:32:44,080 --> 00:32:45,600
and so that's perfectly okay that's

863
00:32:45,600 --> 00:32:48,000
acceptable okay what happens

864
00:32:48,000 --> 00:32:51,360
uh if we crash

865
00:32:51,360 --> 00:32:54,480
okay between after committing

866
00:32:54,480 --> 00:32:58,230
before we installed

867
00:32:58,240 --> 00:33:00,159
then you'll just redo all the installs

868
00:33:00,159 --> 00:33:01,840
so you'll kind of restore the correct

869
00:33:01,840 --> 00:33:02,880
state

870
00:33:02,880 --> 00:33:05,039
yeah so exactly so at that point correct

871
00:33:05,039 --> 00:33:06,799
all we have we know they're uh

872
00:33:06,799 --> 00:33:09,600
all the blocks are in the log they're be

873
00:33:09,600 --> 00:33:11,440
all written because we committed so it

874
00:33:11,440 --> 00:33:12,720
must be the case that the whole file

875
00:33:12,720 --> 00:33:14,399
system operation finished

876
00:33:14,399 --> 00:33:16,000
and so we can basically you know put

877
00:33:16,000 --> 00:33:17,360
them in their location where they should

878
00:33:17,360 --> 00:33:18,720
be

879
00:33:18,720 --> 00:33:20,559
and then we're all in good shape and so

880
00:33:20,559 --> 00:33:22,240
in this case now all the file you know

881
00:33:22,240 --> 00:33:24,720
in this case what will end up is as if

882
00:33:24,720 --> 00:33:27,919
the it is if the file system call

883
00:33:27,919 --> 00:33:29,039
actually completely

884
00:33:29,039 --> 00:33:30,799
just before the crash there's like no

885
00:33:30,799 --> 00:33:32,320
difference

886
00:33:32,320 --> 00:33:35,519
okay so what happens if we crash

887
00:33:35,519 --> 00:33:37,760
during reinstall or like install or

888
00:33:37,760 --> 00:33:39,679
during install before re-cleaning

889
00:33:39,679 --> 00:33:42,880
so crash here in this case in this case

890
00:33:42,880 --> 00:33:44,480
and now we'll do the third case

891
00:33:44,480 --> 00:33:46,559
we'll install during installation or

892
00:33:46,559 --> 00:33:48,000
just before

893
00:33:48,000 --> 00:33:50,240
install after installing but before

894
00:33:50,240 --> 00:33:51,600
cleaning

895
00:33:51,600 --> 00:33:58,070
what what what happened then

896
00:33:58,080 --> 00:34:01,120
oh sorry uh on the next restart uh

897
00:34:01,120 --> 00:34:03,600
nothing has really changed in terms of

898
00:34:03,600 --> 00:34:05,120
the recovery process

899
00:34:05,120 --> 00:34:07,600
and so we're just going to redo the log

900
00:34:07,600 --> 00:34:08,879
yeah we're going to redo the log again

901
00:34:08,879 --> 00:34:10,480
and we're going to copy basically the

902
00:34:10,480 --> 00:34:11,200
content

903
00:34:11,200 --> 00:34:13,280
again you know to the locations correct

904
00:34:13,280 --> 00:34:14,879
maybe in fact we might do it multiple

905
00:34:14,879 --> 00:34:15,919
times

906
00:34:15,919 --> 00:34:23,990
is that okay

907
00:34:24,000 --> 00:34:28,480
um yes because those are just rights

908
00:34:28,480 --> 00:34:31,599
and it's they are to a specific location

909
00:34:31,599 --> 00:34:32,079
that we

910
00:34:32,079 --> 00:34:34,639
don't change like it's written in the

911
00:34:34,639 --> 00:34:36,079
log so we know

912
00:34:36,079 --> 00:34:38,800
where we should write every time yeah

913
00:34:38,800 --> 00:34:40,079
basically every time we'll do the same

914
00:34:40,079 --> 00:34:41,520
right correct so let's say

915
00:34:41,520 --> 00:34:43,440
in block 45 you know there's the value

916
00:34:43,440 --> 00:34:45,919
10 and we're going to write 10 you know

917
00:34:45,919 --> 00:34:48,240
to location 45 every time and that's

918
00:34:48,240 --> 00:34:49,280
exactly what it should be

919
00:34:49,280 --> 00:34:50,639
and like and repeating that right

920
00:34:50,639 --> 00:34:52,320
multiple times doesn't really do any

921
00:34:52,320 --> 00:34:52,720
harm

922
00:34:52,720 --> 00:34:55,119
right because we're writing the same

923
00:34:55,119 --> 00:34:56,480
value that actually should be there

924
00:34:56,480 --> 00:34:57,599
anyway

925
00:34:57,599 --> 00:34:59,200
and so it's perfectly fine you know for

926
00:34:59,200 --> 00:35:03,359
us to do reinstallation multiple times

927
00:35:03,359 --> 00:35:04,800
of course we shouldn't serve any other

928
00:35:04,800 --> 00:35:06,000
file system calls at this particular

929
00:35:06,000 --> 00:35:07,599
point of time we should do this before

930
00:35:07,599 --> 00:35:10,480
we restart the file system but the while

931
00:35:10,480 --> 00:35:11,920
you know the

932
00:35:11,920 --> 00:35:13,599
during reboot or during recovery you

933
00:35:13,599 --> 00:35:16,240
know we can just do this right another

934
00:35:16,240 --> 00:35:17,839
way of saying that is that installation

935
00:35:17,839 --> 00:35:18,480
is basically

936
00:35:18,480 --> 00:35:20,240
item potent you can just execute it many

937
00:35:20,240 --> 00:35:22,640
many many times and will have the same

938
00:35:22,640 --> 00:35:25,750
effect at the end

939
00:35:25,760 --> 00:35:29,589
a question about that yeah

940
00:35:29,599 --> 00:35:31,680
because the interface is just read and

941
00:35:31,680 --> 00:35:33,520
write if we had an append

942
00:35:33,520 --> 00:35:36,960
it this would not be safe right

943
00:35:36,960 --> 00:35:39,839
yeah yeah the there's you can make a pen

944
00:35:39,839 --> 00:35:40,800
safe too

945
00:35:40,800 --> 00:35:42,800
ignore fancy logging schemes but for

946
00:35:42,800 --> 00:35:44,000
this particular logging scheme

947
00:35:44,000 --> 00:35:45,119
you know we don't have to worry about

948
00:35:45,119 --> 00:35:47,760
that in fact like in some sense the

949
00:35:47,760 --> 00:35:49,760
append is a file system level operation

950
00:35:49,760 --> 00:35:52,720
and at that level we can make it uh

951
00:35:52,720 --> 00:35:53,359
atomic

952
00:35:53,359 --> 00:35:56,839
using the logging scheme that we have

953
00:35:56,839 --> 00:35:58,160
here

954
00:35:58,160 --> 00:36:01,040
i see thank you i also have a question

955
00:36:01,040 --> 00:36:01,440
yep

956
00:36:01,440 --> 00:36:03,040
go ahead what would happen if the file

957
00:36:03,040 --> 00:36:05,280
system crashed while you were committing

958
00:36:05,280 --> 00:36:06,320
so you want to like

959
00:36:06,320 --> 00:36:08,480
execute multiple rights and then you

960
00:36:08,480 --> 00:36:11,440
only commit like half of them

961
00:36:11,440 --> 00:36:12,800
yeah okay so can you speak up a little

962
00:36:12,800 --> 00:36:14,560
bit more because your volume is low

963
00:36:14,560 --> 00:36:17,920
oh yes sorry so if you wanted to

964
00:36:17,920 --> 00:36:20,880
like commit multiple rights at once like

965
00:36:20,880 --> 00:36:22,240
in an atomic way

966
00:36:22,240 --> 00:36:25,119
but your system crashes in the middle of

967
00:36:25,119 --> 00:36:26,000
committing so you

968
00:36:26,000 --> 00:36:28,240
are only able to commit like half of the

969
00:36:28,240 --> 00:36:29,280
rights

970
00:36:29,280 --> 00:36:31,200
uh what would happen in that instance uh

971
00:36:31,200 --> 00:36:33,040
okay so this is a very important point

972
00:36:33,040 --> 00:36:34,720
i'm glad you asked the question so first

973
00:36:34,720 --> 00:36:36,720
of all the the

974
00:36:36,720 --> 00:36:39,359
the you commit in writing this commit

975
00:36:39,359 --> 00:36:40,000
operation here

976
00:36:40,000 --> 00:36:42,240
correct this you know step two you only

977
00:36:42,240 --> 00:36:43,839
execute that commit operation

978
00:36:43,839 --> 00:36:45,680
after you already logged all the rights

979
00:36:45,680 --> 00:36:47,280
that you were planning to execute

980
00:36:47,280 --> 00:36:50,400
right so at the point you do to commit

981
00:36:50,400 --> 00:36:54,560
all the writes are in the log and so

982
00:36:54,560 --> 00:36:56,400
the commit operation itself you know

983
00:36:56,400 --> 00:36:57,599
it's an interesting question like what

984
00:36:57,599 --> 00:36:58,560
happens there

985
00:36:58,560 --> 00:37:01,359
so uh the way the the way i sort of

986
00:37:01,359 --> 00:37:02,960
indicated this on this like the commit

987
00:37:02,960 --> 00:37:05,119
operation writes a single block

988
00:37:05,119 --> 00:37:07,680
like the single sector on the disk and

989
00:37:07,680 --> 00:37:09,280
the standard assumption that file

990
00:37:09,280 --> 00:37:10,560
systems make

991
00:37:10,560 --> 00:37:13,599
is that a single block write

992
00:37:13,599 --> 00:37:15,680
or single sector write is an atomic

993
00:37:15,680 --> 00:37:17,280
operation

994
00:37:17,280 --> 00:37:19,440
meaning that if you write it the whole

995
00:37:19,440 --> 00:37:20,480
sector will be written

996
00:37:20,480 --> 00:37:22,079
or none of the sector will be written so

997
00:37:22,079 --> 00:37:23,359
the sector will never be written

998
00:37:23,359 --> 00:37:24,800
partially

999
00:37:24,800 --> 00:37:26,640
and so there's always you know clearly

1000
00:37:26,640 --> 00:37:28,240
you know valid data in that particular

1001
00:37:28,240 --> 00:37:28,960
sector

1002
00:37:28,960 --> 00:37:31,119
and so basically this operation that

1003
00:37:31,119 --> 00:37:33,520
commit operation writing the log header

1004
00:37:33,520 --> 00:37:35,520
uh is the writing the commit record is

1005
00:37:35,520 --> 00:37:37,119
the the real commit operation

1006
00:37:37,119 --> 00:37:39,440
like if that succeeds and there's

1007
00:37:39,440 --> 00:37:40,160
basically a

1008
00:37:40,160 --> 00:37:42,320
say a five in the commit header you know

1009
00:37:42,320 --> 00:37:43,680
we know that there are five

1010
00:37:43,680 --> 00:37:45,760
blocks in the log and we have to

1011
00:37:45,760 --> 00:37:48,640
reinstall those five blocks

1012
00:37:48,640 --> 00:37:50,640
if the commit header didn't make it to

1013
00:37:50,640 --> 00:37:53,839
disk then the value would still be zero

1014
00:37:53,839 --> 00:37:55,119
and we'll just treat it as if the

1015
00:37:55,119 --> 00:37:58,950
transaction never happened

1016
00:37:58,960 --> 00:38:02,000
thank you and the key rule

1017
00:38:02,000 --> 00:38:03,920
that you're sort of hinting at that

1018
00:38:03,920 --> 00:38:06,000
actually has to be true

1019
00:38:06,000 --> 00:38:06,960
is something that's called the right

1020
00:38:06,960 --> 00:38:09,359
ahead rule which means that

1021
00:38:09,359 --> 00:38:12,160
a logging system cannot install rights

1022
00:38:12,160 --> 00:38:12,960
until

1023
00:38:12,960 --> 00:38:15,119
all the rights are into the rn are in

1024
00:38:15,119 --> 00:38:19,910
the log

1025
00:38:19,920 --> 00:38:21,520
any more questions about this sort of

1026
00:38:21,520 --> 00:38:30,829
basic plan

1027
00:38:30,839 --> 00:38:33,359
okay good

1028
00:38:33,359 --> 00:38:36,470
um

1029
00:38:36,480 --> 00:38:42,230
let's see

1030
00:38:42,240 --> 00:38:45,359
so what i what i'm gonna there's many

1031
00:38:45,359 --> 00:38:47,359
many uh different versions of logging

1032
00:38:47,359 --> 00:38:49,520
schemes and i sketched out here a very

1033
00:38:49,520 --> 00:38:50,640
simple one

1034
00:38:50,640 --> 00:38:52,560
uh you know it's perfectly fine you know

1035
00:38:52,560 --> 00:38:54,240
they're schemes where basically the law

1036
00:38:54,240 --> 00:38:56,720
the cleaning of the log is postponed uh

1037
00:38:56,720 --> 00:38:59,359
installation is postponed until later

1038
00:38:59,359 --> 00:39:00,880
but i'm just going to run sort of with

1039
00:39:00,880 --> 00:39:02,880
this very simple scheme

1040
00:39:02,880 --> 00:39:04,640
and then on next week we'll see more

1041
00:39:04,640 --> 00:39:07,359
sophisticated logging protocols

1042
00:39:07,359 --> 00:39:08,880
but all those logging protocols follow

1043
00:39:08,880 --> 00:39:10,400
this right ahead rule that

1044
00:39:10,400 --> 00:39:11,680
you know before you write the commit

1045
00:39:11,680 --> 00:39:13,599
record you have to make sure that all

1046
00:39:13,599 --> 00:39:14,720
the rights

1047
00:39:14,720 --> 00:39:18,870
are in the log

1048
00:39:18,880 --> 00:39:20,720
but then there's a lot within that still

1049
00:39:20,720 --> 00:39:22,480
there's a ton of flexibility in

1050
00:39:22,480 --> 00:39:25,040
designing a particular logging protocol

1051
00:39:25,040 --> 00:39:25,520
as they're

1052
00:39:25,520 --> 00:39:28,480
typically called okay i'm going to look

1053
00:39:28,480 --> 00:39:29,520
a little bit uh

1054
00:39:29,520 --> 00:39:32,640
how this then is manifest itself in xv6

1055
00:39:32,640 --> 00:39:34,000
you know as a sort of a case study and

1056
00:39:34,000 --> 00:39:37,589
to make things really concrete

1057
00:39:37,599 --> 00:39:41,280
um okay so in xv6

1058
00:39:41,280 --> 00:39:43,359
they're sort of uh we're going to look

1059
00:39:43,359 --> 00:39:44,880
at two sort of pieces of state if you

1060
00:39:44,880 --> 00:39:45,440
will

1061
00:39:45,440 --> 00:39:48,079
the stuff that is actually on disk and

1062
00:39:48,079 --> 00:39:48,640
that is

1063
00:39:48,640 --> 00:39:52,550
um you know things that are in memory

1064
00:39:52,560 --> 00:39:57,119
and in-memory contents will disappear

1065
00:39:57,119 --> 00:39:58,640
on or the way we should think about it

1066
00:39:58,640 --> 00:39:59,839
is that the in-memory contents will

1067
00:39:59,839 --> 00:40:00,800
disappear on

1068
00:40:00,800 --> 00:40:04,640
on a crash or a power failure um

1069
00:40:04,640 --> 00:40:08,800
and the structure of the xv6 log

1070
00:40:08,800 --> 00:40:12,560
as always is extremely simple

1071
00:40:12,560 --> 00:40:15,599
uh there's actually we have one block at

1072
00:40:15,599 --> 00:40:16,319
the beginning

1073
00:40:16,319 --> 00:40:18,400
that's the header block and that is

1074
00:40:18,400 --> 00:40:19,920
basically our commit record you know it

1075
00:40:19,920 --> 00:40:21,280
contains

1076
00:40:21,280 --> 00:40:23,200
the number n which is like the number of

1077
00:40:23,200 --> 00:40:24,480
blocks in the log

1078
00:40:24,480 --> 00:40:28,240
and then for each block the

1079
00:40:28,240 --> 00:40:30,160
the block number the home location of

1080
00:40:30,160 --> 00:40:32,319
that block

1081
00:40:32,319 --> 00:40:33,440
blah blah blah blah so they're going to

1082
00:40:33,440 --> 00:40:38,000
be end of those

1083
00:40:38,000 --> 00:40:40,880
so then in the log itself r basically is

1084
00:40:40,880 --> 00:40:41,839
the data for that

1085
00:40:41,839 --> 00:40:43,760
you know it belongs to that so here's

1086
00:40:43,760 --> 00:40:45,119
the data of

1087
00:40:45,119 --> 00:40:50,160
bn0 here's the data of bn1 etc

1088
00:40:50,160 --> 00:40:54,319
to and b n minus one

1089
00:40:54,319 --> 00:40:56,800
so that's what's in the log uh and

1090
00:40:56,800 --> 00:40:58,000
actually does the only thing that's sort

1091
00:40:58,000 --> 00:41:00,560
of in the log there's nothing more to it

1092
00:41:00,560 --> 00:41:02,240
then in memory when a while the file

1093
00:41:02,240 --> 00:41:05,839
system is running uh there's an in copy

1094
00:41:05,839 --> 00:41:09,440
or in-memory version of the header

1095
00:41:09,440 --> 00:41:12,160
and it basically has the n and it has

1096
00:41:12,160 --> 00:41:17,670
array of block numbers

1097
00:41:17,680 --> 00:41:20,720
etc uh and then

1098
00:41:20,720 --> 00:41:23,839
you know these block numbers uh refer to

1099
00:41:23,839 --> 00:41:26,079
uh blocks that are sitting in the data

1100
00:41:26,079 --> 00:41:27,520
that actually

1101
00:41:27,520 --> 00:41:29,040
corresponds to the block numbers that

1102
00:41:29,040 --> 00:41:30,400
are sort of sitting in this in-memory

1103
00:41:30,400 --> 00:41:31,280
data structure

1104
00:41:31,280 --> 00:41:34,240
they live in the block cache which you

1105
00:41:34,240 --> 00:41:34,480
know

1106
00:41:34,480 --> 00:41:37,200
by now you're well familiar with and so

1107
00:41:37,200 --> 00:41:38,720
maybe this is like block 10

1108
00:41:38,720 --> 00:41:42,240
is the first block in the log or maybe

1109
00:41:42,240 --> 00:41:44,319
let me take a more concrete example from

1110
00:41:44,319 --> 00:41:46,400
that lines up with our previous thing so

1111
00:41:46,400 --> 00:41:49,359
maybe this is like 45

1112
00:41:49,359 --> 00:41:51,200
and basically you know somewhere in the

1113
00:41:51,200 --> 00:41:53,040
in cash in the broadcast

1114
00:41:53,040 --> 00:41:55,599
of course you know whatever block for 45

1115
00:41:55,599 --> 00:41:56,960
and here's his data

1116
00:41:56,960 --> 00:42:00,000
okay and that's one of the structures uh

1117
00:42:00,000 --> 00:42:03,119
that uh

1118
00:42:03,119 --> 00:42:06,400
the on disk uh the in-memory file system

1119
00:42:06,400 --> 00:42:07,040
has and

1120
00:42:07,040 --> 00:42:08,640
on this file system has so the unless

1121
00:42:08,640 --> 00:42:10,319
file system just has the log

1122
00:42:10,319 --> 00:42:12,079
the in-memory has these data structures

1123
00:42:12,079 --> 00:42:13,359
to orchestrate

1124
00:42:13,359 --> 00:42:15,040
uh these multi-write operations that

1125
00:42:15,040 --> 00:42:17,119
we're going to be doing

1126
00:42:17,119 --> 00:42:20,230
okay

1127
00:42:20,240 --> 00:42:23,040
so to make this a little more concrete

1128
00:42:23,040 --> 00:42:25,760
just let's look at some code

1129
00:42:25,760 --> 00:42:28,960
and that will help us understand

1130
00:42:28,960 --> 00:42:33,430
how everything works

1131
00:42:33,440 --> 00:42:36,720
so let me pull up

1132
00:42:36,720 --> 00:42:41,119
some code and let me put this next to it

1133
00:42:41,119 --> 00:42:43,920
keep that picture so that we can look at

1134
00:42:43,920 --> 00:42:44,880
it if we

1135
00:42:44,880 --> 00:42:48,309
want to or i can point to it

1136
00:42:48,319 --> 00:42:53,589
can everybody see my code

1137
00:42:53,599 --> 00:42:55,440
yeah somebody has to confirm that

1138
00:42:55,440 --> 00:42:56,880
they've seen the

1139
00:42:56,880 --> 00:42:59,359
emacs window yeah we can see it good

1140
00:42:59,359 --> 00:43:00,240
good

1141
00:43:00,240 --> 00:43:03,990
is it big enough

1142
00:43:04,000 --> 00:43:06,960
i think it's good okay it looks good

1143
00:43:06,960 --> 00:43:08,400
okay thank you

1144
00:43:08,400 --> 00:43:11,520
okay so let's start with the you know

1145
00:43:11,520 --> 00:43:14,160
i i talked about transactions right um

1146
00:43:14,160 --> 00:43:15,599
uh you know the fact that

1147
00:43:15,599 --> 00:43:18,880
you know the we should not commit until

1148
00:43:18,880 --> 00:43:19,920
you know we should not write a commit

1149
00:43:19,920 --> 00:43:22,400
writer until all the rights have done

1150
00:43:22,400 --> 00:43:24,720
and uh so that means that the file

1151
00:43:24,720 --> 00:43:26,240
system operations

1152
00:43:26,240 --> 00:43:27,839
must indicate sort of what the beginning

1153
00:43:27,839 --> 00:43:29,440
of transaction is and particularly what

1154
00:43:29,440 --> 00:43:31,359
the end of the transaction is

1155
00:43:31,359 --> 00:43:34,000
and the way that happens in xv6 is that

1156
00:43:34,000 --> 00:43:36,240
every file system call

1157
00:43:36,240 --> 00:43:38,640
you know here's open the corresponds to

1158
00:43:38,640 --> 00:43:40,880
create basically starts with begin up

1159
00:43:40,880 --> 00:43:41,200
and

1160
00:43:41,200 --> 00:43:42,800
you know basically indicates like okay i

1161
00:43:42,800 --> 00:43:44,720
want to start a transaction and i want

1162
00:43:44,720 --> 00:43:46,000
all the block rights that i've been

1163
00:43:46,000 --> 00:43:47,520
doing between begin up

1164
00:43:47,520 --> 00:43:49,200
and end up which is basically at the end

1165
00:43:49,200 --> 00:43:51,520
of the transaction to be atomic

1166
00:43:51,520 --> 00:43:52,800
meaning you know they should be all

1167
00:43:52,800 --> 00:43:54,880
applied to none of them should replied

1168
00:43:54,880 --> 00:43:57,920
okay and so every file system call in

1169
00:43:57,920 --> 00:44:01,359
uh xv6 has that structure and that

1170
00:44:01,359 --> 00:44:02,240
basically has begin

1171
00:44:02,240 --> 00:44:04,079
up then the code that implements the

1172
00:44:04,079 --> 00:44:07,040
file system call and then end up

1173
00:44:07,040 --> 00:44:08,400
and at end up is basically where the

1174
00:44:08,400 --> 00:44:10,400
commit operation happens

1175
00:44:10,400 --> 00:44:12,800
uh so basically between beginner and end

1176
00:44:12,800 --> 00:44:13,680
up

1177
00:44:13,680 --> 00:44:15,520
the on disk or the in-memory data

1178
00:44:15,520 --> 00:44:16,720
structure should be updated you know

1179
00:44:16,720 --> 00:44:17,440
whatever the

1180
00:44:17,440 --> 00:44:19,280
memory log may be updated the block

1181
00:44:19,280 --> 00:44:20,960
cache might be updated

1182
00:44:20,960 --> 00:44:24,160
but nothing really happens until end up

1183
00:44:24,160 --> 00:44:25,839
and at end of time we're basically going

1184
00:44:25,839 --> 00:44:28,079
to put things into the log

1185
00:44:28,079 --> 00:44:30,640
and then if we uh done with putting

1186
00:44:30,640 --> 00:44:31,680
everything in the log

1187
00:44:31,680 --> 00:44:33,040
we'll actually you know write the commit

1188
00:44:33,040 --> 00:44:36,000
record or the log header

1189
00:44:36,000 --> 00:44:39,200
okay so let's uh

1190
00:44:39,200 --> 00:44:40,560
so what is interesting of course then

1191
00:44:40,560 --> 00:44:42,319
what happens is every write correctly

1192
00:44:42,319 --> 00:44:44,160
whenever one of these file system calls

1193
00:44:44,160 --> 00:44:44,560
does

1194
00:44:44,560 --> 00:44:48,079
a disk write um the you know something

1195
00:44:48,079 --> 00:44:48,640
must happen

1196
00:44:48,640 --> 00:44:52,720
so if we go back for example to fs.c

1197
00:44:52,720 --> 00:44:55,760
you know look at ialoc uh i alec

1198
00:44:55,760 --> 00:44:58,079
basically what it calls it doesn't call

1199
00:44:58,079 --> 00:45:01,520
b write directly but it actually calls

1200
00:45:01,520 --> 00:45:02,839
[Music]

1201
00:45:02,839 --> 00:45:05,359
logarite and so we're going to see what

1202
00:45:05,359 --> 00:45:06,720
log right does and

1203
00:45:06,720 --> 00:45:08,800
log right is basically the function

1204
00:45:08,800 --> 00:45:10,560
implemented by the logging system

1205
00:45:10,560 --> 00:45:12,480
and every rate that basically a file

1206
00:45:12,480 --> 00:45:14,240
system called us between begin up and

1207
00:45:14,240 --> 00:45:14,960
end up

1208
00:45:14,960 --> 00:45:23,270
always goes to log right

1209
00:45:23,280 --> 00:45:25,040
so here's log right and log right

1210
00:45:25,040 --> 00:45:26,480
actually is reasonable

1211
00:45:26,480 --> 00:45:29,920
uh you know straightforward um

1212
00:45:29,920 --> 00:45:32,880
the you know we've written the block uh

1213
00:45:32,880 --> 00:45:33,760
in the

1214
00:45:33,760 --> 00:45:35,760
block cache so somewhere basically

1215
00:45:35,760 --> 00:45:37,520
you're 45 maybe this is like the right

1216
00:45:37,520 --> 00:45:38,720
to 45.

1217
00:45:38,720 --> 00:45:41,760
we've updated you know 45 in

1218
00:45:41,760 --> 00:45:43,599
the block cache and now we're basically

1219
00:45:43,599 --> 00:45:45,839
record in the in-memory data structures

1220
00:45:45,839 --> 00:45:46,240
that

1221
00:45:46,240 --> 00:45:48,400
to some point later at commit point we

1222
00:45:48,400 --> 00:45:50,319
need to write this block into the

1223
00:45:50,319 --> 00:45:53,280
log and so you know basically you know

1224
00:45:53,280 --> 00:45:54,240
the code is

1225
00:45:54,240 --> 00:45:56,160
oops the code is reasonable

1226
00:45:56,160 --> 00:45:57,359
straightforward

1227
00:45:57,359 --> 00:46:00,880
uh acquires a lock on the header

1228
00:46:00,880 --> 00:46:04,160
and and basically updates the header

1229
00:46:04,160 --> 00:46:06,160
uh and in particular what it does you

1230
00:46:06,160 --> 00:46:07,200
know it goes through

1231
00:46:07,200 --> 00:46:10,640
you know the uh it updates n or actually

1232
00:46:10,640 --> 00:46:12,480
the first thing it does it actually sees

1233
00:46:12,480 --> 00:46:14,640
if there's already a copy of 45

1234
00:46:14,640 --> 00:46:18,400
in the if 45 is already recorded as

1235
00:46:18,400 --> 00:46:19,680
being having to write to

1236
00:46:19,680 --> 00:46:21,440
written to and if that's the case

1237
00:46:21,440 --> 00:46:23,119
nothing else has to be done because 45

1238
00:46:23,119 --> 00:46:24,720
will be written to

1239
00:46:24,720 --> 00:46:26,720
uh and so we're done and this sometimes

1240
00:46:26,720 --> 00:46:28,960
it's called lock absorption

1241
00:46:28,960 --> 00:46:32,079
um if you know

1242
00:46:32,079 --> 00:46:35,520
block 45 is not in the array yet or not

1243
00:46:35,520 --> 00:46:37,280
in the

1244
00:46:37,280 --> 00:46:38,640
the list of blocks or the array of

1245
00:46:38,640 --> 00:46:40,720
blocks that needs to be written to disk

1246
00:46:40,720 --> 00:46:42,640
then basically you know the only thing

1247
00:46:42,640 --> 00:46:44,480
this particular piece of code does

1248
00:46:44,480 --> 00:46:46,800
is basically bump up and and stick you

1249
00:46:46,800 --> 00:46:48,240
know that block number that needs to be

1250
00:46:48,240 --> 00:46:48,720
written

1251
00:46:48,720 --> 00:46:53,119
into the next entry or into that entry

1252
00:46:53,119 --> 00:46:54,480
then the only other thing it does and

1253
00:46:54,480 --> 00:46:57,200
i'll talk about this later it will pin

1254
00:46:57,200 --> 00:47:00,240
the block in the buffer cache

1255
00:47:00,240 --> 00:47:03,119
and uh let me postpone why for a little

1256
00:47:03,119 --> 00:47:03,839
while

1257
00:47:03,839 --> 00:47:06,560
but i will come back to that later and

1258
00:47:06,560 --> 00:47:07,920
that's actually all what log right there

1259
00:47:07,920 --> 00:47:08,400
is doing

1260
00:47:08,400 --> 00:47:10,800
so every file system call that you know

1261
00:47:10,800 --> 00:47:11,839
needs to update

1262
00:47:11,839 --> 00:47:13,280
a block you know updates the block in

1263
00:47:13,280 --> 00:47:14,960
the block cache and then basically

1264
00:47:14,960 --> 00:47:16,079
appends it

1265
00:47:16,079 --> 00:47:19,040
uh to this in-memory data structure uh

1266
00:47:19,040 --> 00:47:21,040
unless you know it's already there

1267
00:47:21,040 --> 00:47:22,839
in which case you know it just absorbs

1268
00:47:22,839 --> 00:47:24,480
it

1269
00:47:24,480 --> 00:47:29,190
does that make sense

1270
00:47:29,200 --> 00:47:31,200
so does that mean that b right shouldn't

1271
00:47:31,200 --> 00:47:33,200
be used by itself

1272
00:47:33,200 --> 00:47:36,880
at all so you get b write shouldn't be

1273
00:47:36,880 --> 00:47:37,599
used

1274
00:47:37,599 --> 00:47:40,720
by itself only as yes

1275
00:47:40,720 --> 00:47:42,880
that's just correct yeah basically all

1276
00:47:42,880 --> 00:47:44,079
the one way to think about it is that

1277
00:47:44,079 --> 00:47:44,480
every b

1278
00:47:44,480 --> 00:47:46,720
write in the file system is uh replaced

1279
00:47:46,720 --> 00:47:53,839
by log right

1280
00:47:53,839 --> 00:47:56,960
okay um so now let's see what actually

1281
00:47:56,960 --> 00:47:57,440
happens

1282
00:47:57,440 --> 00:47:59,760
at end op correct because that's where

1283
00:47:59,760 --> 00:48:02,160
the exciting part happens

1284
00:48:02,160 --> 00:48:04,720
uh and i'm gonna there's a couple things

1285
00:48:04,720 --> 00:48:07,200
cases that i just want to

1286
00:48:07,200 --> 00:48:09,440
avoid talking about a little bit later

1287
00:48:09,440 --> 00:48:10,240
because they

1288
00:48:10,240 --> 00:48:12,160
you know even this simple logging system

1289
00:48:12,160 --> 00:48:13,920
actually has some subtle complexities

1290
00:48:13,920 --> 00:48:14,480
and

1291
00:48:14,480 --> 00:48:15,920
most of the beginning of this code deals

1292
00:48:15,920 --> 00:48:18,000
with these subtle complexities

1293
00:48:18,000 --> 00:48:20,160
uh but i just want to like at the normal

1294
00:48:20,160 --> 00:48:21,119
case you know there's

1295
00:48:21,119 --> 00:48:23,440
or there's the simple case where no

1296
00:48:23,440 --> 00:48:25,200
other file system operations are in

1297
00:48:25,200 --> 00:48:26,160
progress

1298
00:48:26,160 --> 00:48:28,720
uh we execute you know create file and

1299
00:48:28,720 --> 00:48:30,240
basically we're getting to the point

1300
00:48:30,240 --> 00:48:31,839
where we want to commit it

1301
00:48:31,839 --> 00:48:33,760
and so the code is pretty

1302
00:48:33,760 --> 00:48:35,040
straightforward

1303
00:48:35,040 --> 00:48:37,520
and calls commit and so let's look at

1304
00:48:37,520 --> 00:48:41,510
commit

1305
00:48:41,520 --> 00:48:44,160
so here's commit i miss a commit does

1306
00:48:44,160 --> 00:48:45,280
two basically

1307
00:48:45,280 --> 00:48:48,160
steps and basically writes the log and

1308
00:48:48,160 --> 00:48:49,359
that's basically writing

1309
00:48:49,359 --> 00:48:52,559
all these all these block numbers that

1310
00:48:52,559 --> 00:48:53,200
are sitting

1311
00:48:53,200 --> 00:48:55,920
you know in the in-memory uh header and

1312
00:48:55,920 --> 00:48:57,359
writes them basically all to the

1313
00:48:57,359 --> 00:48:59,599
the header on disk including you know

1314
00:48:59,599 --> 00:49:02,319
this number n

1315
00:49:02,319 --> 00:49:05,359
right and so let's see uh that is that's

1316
00:49:05,359 --> 00:49:06,319
what right head does

1317
00:49:06,319 --> 00:49:09,040
sorry uh a write log basically writes

1318
00:49:09,040 --> 00:49:09,680
you know the

1319
00:49:09,680 --> 00:49:12,880
blocks from the buffer cache into their

1320
00:49:12,880 --> 00:49:16,160
uh respective into the log itself

1321
00:49:16,160 --> 00:49:18,319
so let's see what red log is right above

1322
00:49:18,319 --> 00:49:19,599
here

1323
00:49:19,599 --> 00:49:21,680
and you can see what it does you know it

1324
00:49:21,680 --> 00:49:23,359
goes through you know this array

1325
00:49:23,359 --> 00:49:26,880
you know one at a time and basically uh

1326
00:49:26,880 --> 00:49:30,000
right down to the lock position

1327
00:49:30,000 --> 00:49:32,720
in the log okay so it reads you know the

1328
00:49:32,720 --> 00:49:33,200
log

1329
00:49:33,200 --> 00:49:36,319
block then sticks it in there

1330
00:49:36,319 --> 00:49:37,920
by copying it and then writing it

1331
00:49:37,920 --> 00:49:40,720
actually out to the disk

1332
00:49:40,720 --> 00:49:42,960
so this basically ensures like walk 45

1333
00:49:42,960 --> 00:49:44,559
land up here you know it's let's say

1334
00:49:44,559 --> 00:49:45,599
this is 32

1335
00:49:45,599 --> 00:49:47,040
that will end up there et cetera et

1336
00:49:47,040 --> 00:49:48,960
cetera

1337
00:49:48,960 --> 00:49:50,880
then in the end so at this point we have

1338
00:49:50,880 --> 00:49:52,559
not committed yet right the only thing

1339
00:49:52,559 --> 00:49:54,240
we've done is basically putting blocks

1340
00:49:54,240 --> 00:49:55,359
into the log

1341
00:49:55,359 --> 00:49:57,040
and if we were crash at this particular

1342
00:49:57,040 --> 00:49:58,880
point in time you know before

1343
00:49:58,880 --> 00:50:00,800
you know calling right ahead before

1344
00:50:00,800 --> 00:50:02,000
right hack succeeded

1345
00:50:02,000 --> 00:50:04,400
and basically as if uh the transaction

1346
00:50:04,400 --> 00:50:07,200
didn't execute at all

1347
00:50:07,200 --> 00:50:09,760
so let's look at right head so that

1348
00:50:09,760 --> 00:50:11,119
right head is you know what i called

1349
00:50:11,119 --> 00:50:13,760
earlier basically the commit point

1350
00:50:13,760 --> 00:50:16,079
and the commit point basically you know

1351
00:50:16,079 --> 00:50:17,599
basically it's straightforward

1352
00:50:17,599 --> 00:50:21,040
and reads the header block

1353
00:50:21,040 --> 00:50:22,480
from disk which is probably sitting in

1354
00:50:22,480 --> 00:50:24,559
the buffer cache uh

1355
00:50:24,559 --> 00:50:27,760
it you know puts the copies the n

1356
00:50:27,760 --> 00:50:30,880
you know this end into that block

1357
00:50:30,880 --> 00:50:32,640
puts all the block numbers into that

1358
00:50:32,640 --> 00:50:34,000
array into that block

1359
00:50:34,000 --> 00:50:35,599
and then basically writes that

1360
00:50:35,599 --> 00:50:37,280
particular block so

1361
00:50:37,280 --> 00:50:39,760
this is the this b rate what is that is

1362
00:50:39,760 --> 00:50:45,270
that the commit point

1363
00:50:45,280 --> 00:50:46,960
if a crash happens before this b write

1364
00:50:46,960 --> 00:50:57,190
what happens then

1365
00:50:57,200 --> 00:51:00,800
anybody if the crash happens

1366
00:51:00,800 --> 00:51:02,800
before be right isn't the only

1367
00:51:02,800 --> 00:51:04,160
modification that we've made

1368
00:51:04,160 --> 00:51:08,079
to the in-memory uh hb data structure

1369
00:51:08,079 --> 00:51:10,720
so it's not it's going to be fine yeah

1370
00:51:10,720 --> 00:51:11,839
it's going to be fine right because

1371
00:51:11,839 --> 00:51:14,720
basically we may have written db10dbn

1372
00:51:14,720 --> 00:51:16,559
or whatever to the log but we have not

1373
00:51:16,559 --> 00:51:18,960
succeeded in writing the log header

1374
00:51:18,960 --> 00:51:20,960
and so we'll we'll do on recovery

1375
00:51:20,960 --> 00:51:22,880
nothing will happen

1376
00:51:22,880 --> 00:51:24,240
and what happens if there's a crash

1377
00:51:24,240 --> 00:51:26,000
right after the b right so like a crash

1378
00:51:26,000 --> 00:51:32,069
here

1379
00:51:32,079 --> 00:51:34,160
and it's no longer zero so the log

1380
00:51:34,160 --> 00:51:35,760
header is correctly read and it's

1381
00:51:35,760 --> 00:51:36,800
recovered

1382
00:51:36,800 --> 00:51:38,559
yeah it will be recovered correct well

1383
00:51:38,559 --> 00:51:40,000
at some point hopefully during recovery

1384
00:51:40,000 --> 00:51:41,760
as we inspect that you know we

1385
00:51:41,760 --> 00:51:43,680
expect that recovery will actually read

1386
00:51:43,680 --> 00:51:45,839
the log header see that there is a five

1387
00:51:45,839 --> 00:51:46,960
in there for example

1388
00:51:46,960 --> 00:51:48,720
and then copy the first five blocks to

1389
00:51:48,720 --> 00:51:50,400
their home location

1390
00:51:50,400 --> 00:51:52,720
so this is really this this this one

1391
00:51:52,720 --> 00:51:53,839
line

1392
00:51:53,839 --> 00:51:55,680
is one disk right this one sector right

1393
00:51:55,680 --> 00:51:58,319
is really the commit point

1394
00:51:58,319 --> 00:52:03,270
correct

1395
00:52:03,280 --> 00:52:04,640
you know before the commitment point the

1396
00:52:04,640 --> 00:52:06,400
transaction is it is the transaction

1397
00:52:06,400 --> 00:52:07,520
didn't happen and after the

1398
00:52:07,520 --> 00:52:09,040
commit point the transaction will

1399
00:52:09,040 --> 00:52:11,440
definitely be finished

1400
00:52:11,440 --> 00:52:18,160
assuming recovery is correct

1401
00:52:18,160 --> 00:52:21,440
okay so let's you know uh

1402
00:52:21,440 --> 00:52:24,950
go back to commit

1403
00:52:24,960 --> 00:52:27,200
so commit after is committed it actually

1404
00:52:27,200 --> 00:52:28,800
installs the transactions

1405
00:52:28,800 --> 00:52:29,920
and you know that's pretty

1406
00:52:29,920 --> 00:52:31,119
straightforward basically you know it

1407
00:52:31,119 --> 00:52:33,280
takes the blocks looks at the header

1408
00:52:33,280 --> 00:52:34,559
where the blocks belongs and then

1409
00:52:34,559 --> 00:52:35,839
basically writes it to that particular

1410
00:52:35,839 --> 00:52:38,470
location

1411
00:52:38,480 --> 00:52:39,839
and so we can actually look at the

1412
00:52:39,839 --> 00:52:41,839
install trends

1413
00:52:41,839 --> 00:52:43,280
and see that actually that's what it

1414
00:52:43,280 --> 00:52:44,960
does

1415
00:52:44,960 --> 00:52:47,280
you know it has a copy of the log header

1416
00:52:47,280 --> 00:52:48,559
and it just

1417
00:52:48,559 --> 00:52:51,839
reads log header uh it reads the

1418
00:52:51,839 --> 00:52:54,240
destination block the home location

1419
00:52:54,240 --> 00:52:56,160
copies the data from the log

1420
00:52:56,160 --> 00:52:59,359
block into the destination

1421
00:52:59,359 --> 00:53:00,640
and then writes the buffer to the

1422
00:53:00,640 --> 00:53:03,200
destination

1423
00:53:03,200 --> 00:53:06,000
okay so basically effectively what this

1424
00:53:06,000 --> 00:53:07,520
does is basically you know you go back

1425
00:53:07,520 --> 00:53:09,280
to this previous slide here it copies

1426
00:53:09,280 --> 00:53:09,839
you know

1427
00:53:09,839 --> 00:53:12,240
it just does these copies from the log

1428
00:53:12,240 --> 00:53:13,520
into the home location

1429
00:53:13,520 --> 00:53:17,030
actually in the file system

1430
00:53:17,040 --> 00:53:18,240
and of course you know we might get a

1431
00:53:18,240 --> 00:53:20,240
failure somewhere in you know this code

1432
00:53:20,240 --> 00:53:21,920
or while we're doing this

1433
00:53:21,920 --> 00:53:23,520
but you know that should be okay because

1434
00:53:23,520 --> 00:53:25,040
hopefully on recovery we'll just start

1435
00:53:25,040 --> 00:53:29,119
over from the beginning

1436
00:53:29,119 --> 00:53:33,119
so let's look at so that was install

1437
00:53:33,119 --> 00:53:36,400
so once install is done then

1438
00:53:36,400 --> 00:53:39,839
uh basically it sets you know the in

1439
00:53:39,839 --> 00:53:43,040
memory header n back to zero

1440
00:53:43,040 --> 00:53:45,760
and then writes that log header and

1441
00:53:45,760 --> 00:53:47,119
effectively that

1442
00:53:47,119 --> 00:53:50,800
causes to uh

1443
00:53:50,800 --> 00:53:52,319
cleans the log because basically there's

1444
00:53:52,319 --> 00:53:54,839
now zero in it

1445
00:53:54,839 --> 00:53:58,000
question uh so

1446
00:53:58,000 --> 00:54:01,680
you uh the function you're in just

1447
00:54:01,680 --> 00:54:02,720
before

1448
00:54:02,720 --> 00:54:06,240
like whereas does the from two or two

1449
00:54:06,240 --> 00:54:09,280
from getting so that puts the um

1450
00:54:09,280 --> 00:54:11,520
the block that you're going to like

1451
00:54:11,520 --> 00:54:12,400
update

1452
00:54:12,400 --> 00:54:14,319
uh the log block that you're going to

1453
00:54:14,319 --> 00:54:16,319
update into the buffer

1454
00:54:16,319 --> 00:54:20,400
cache um could you make it faster by

1455
00:54:20,400 --> 00:54:22,000
not putting it into the buffer cache and

1456
00:54:22,000 --> 00:54:24,480
just directly writing it to

1457
00:54:24,480 --> 00:54:27,680
the device instead uh

1458
00:54:27,680 --> 00:54:30,079
let me uh which function we're talking

1459
00:54:30,079 --> 00:54:31,680
about

1460
00:54:31,680 --> 00:54:34,960
i forget its name it's it's the one

1461
00:54:34,960 --> 00:54:36,079
where you uh

1462
00:54:36,079 --> 00:54:38,960
copy you know everything into the log

1463
00:54:38,960 --> 00:54:40,319
okay install

1464
00:54:40,319 --> 00:54:44,160
install trends uh i think so

1465
00:54:44,160 --> 00:54:47,359
yeah no no

1466
00:54:47,359 --> 00:54:50,400
or maybe it was this one so

1467
00:54:50,400 --> 00:54:52,400
i was thinking probably of right head

1468
00:54:52,400 --> 00:54:54,160
but it's the same thing

1469
00:54:54,160 --> 00:54:57,599
okay they're the uh

1470
00:54:57,599 --> 00:55:01,040
the only reason yeah uh the only reason

1471
00:55:01,040 --> 00:55:02,480
to this you know basically our interface

1472
00:55:02,480 --> 00:55:03,760
is not particularly good you could just

1473
00:55:03,760 --> 00:55:05,839
wreck straight you know the you're

1474
00:55:05,839 --> 00:55:07,920
wondering why you are doing the read

1475
00:55:07,920 --> 00:55:09,520
uh there's no reason to do the read

1476
00:55:09,520 --> 00:55:11,200
because we're going to write anyway

1477
00:55:11,200 --> 00:55:14,960
uh is that the question

1478
00:55:14,960 --> 00:55:17,680
uh yeah that and you're also uh doing

1479
00:55:17,680 --> 00:55:19,040
the men move

1480
00:55:19,040 --> 00:55:20,960
right and you didn't move yeah so this

1481
00:55:20,960 --> 00:55:22,240
actually the sequence of code can

1482
00:55:22,240 --> 00:55:23,440
definitely be optimized

1483
00:55:23,440 --> 00:55:25,680
uh you can save you know one or two disk

1484
00:55:25,680 --> 00:55:26,799
writes

1485
00:55:26,799 --> 00:55:29,359
just for simplicity we don't do any of

1486
00:55:29,359 --> 00:55:30,240
that

1487
00:55:30,240 --> 00:55:35,200
okay thank you

1488
00:55:35,200 --> 00:55:38,640
okay uh so i think we're an over

1489
00:55:38,640 --> 00:55:42,799
uh commit just let's just go back

1490
00:55:42,799 --> 00:55:45,680
and double check uh so we did the right

1491
00:55:45,680 --> 00:55:47,119
log we did the right head

1492
00:55:47,119 --> 00:55:48,960
and basically this this is the cleaning

1493
00:55:48,960 --> 00:55:50,559
operation

1494
00:55:50,559 --> 00:55:52,720
uh we erased you know transaction by

1495
00:55:52,720 --> 00:55:54,160
sending it to zero

1496
00:55:54,160 --> 00:55:57,359
okay so the only thing to sort of

1497
00:55:57,359 --> 00:55:59,119
further inspect is like what how how

1498
00:55:59,119 --> 00:56:01,040
does recovery work and

1499
00:56:01,040 --> 00:56:04,640
so recovery uh happens when

1500
00:56:04,640 --> 00:56:07,760
you know when xv6 starts uh so no we had

1501
00:56:07,760 --> 00:56:10,000
a crash correct so the system failed

1502
00:56:10,000 --> 00:56:13,520
uh we rebooted um and

1503
00:56:13,520 --> 00:56:16,559
uh the and one of the first things

1504
00:56:16,559 --> 00:56:18,559
the x-rays or one of the things that xv6

1505
00:56:18,559 --> 00:56:20,160
does during uh

1506
00:56:20,160 --> 00:56:22,160
initialization it actually calls into

1507
00:56:22,160 --> 00:56:23,359
log

1508
00:56:23,359 --> 00:56:25,520
uh and in a log basically calls this

1509
00:56:25,520 --> 00:56:27,119
function recover from log

1510
00:56:27,119 --> 00:56:30,799
and so let's see what that does and

1511
00:56:30,799 --> 00:56:33,599
basically recover log you know calls

1512
00:56:33,599 --> 00:56:35,280
read ahead

1513
00:56:35,280 --> 00:56:39,280
to basically extract or read the

1514
00:56:39,280 --> 00:56:41,440
the let me see if i can scroll down here

1515
00:56:41,440 --> 00:56:45,440
a little bit

1516
00:56:45,440 --> 00:56:46,799
yeah basically reads the header from

1517
00:56:46,799 --> 00:56:49,839
disk and sees if n

1518
00:56:49,839 --> 00:56:52,160
uh well it doesn't really see if n zero

1519
00:56:52,160 --> 00:56:52,880
or not but

1520
00:56:52,880 --> 00:56:55,200
it just calls install trans and you know

1521
00:56:55,200 --> 00:56:56,880
this is exactly the same install trends

1522
00:56:56,880 --> 00:56:58,000
that we just looked for

1523
00:56:58,000 --> 00:57:00,000
for looked and looked at a little while

1524
00:57:00,000 --> 00:57:01,839
ago and basically you know it looks at

1525
00:57:01,839 --> 00:57:02,400
this end

1526
00:57:02,400 --> 00:57:04,480
and installs all the blocks from zero to

1527
00:57:04,480 --> 00:57:06,000
n out of the log

1528
00:57:06,000 --> 00:57:08,319
into their home location and if it's

1529
00:57:08,319 --> 00:57:10,319
done once it succeeds you know then

1530
00:57:10,319 --> 00:57:11,119
actually

1531
00:57:11,119 --> 00:57:14,720
it calls clear log as before

1532
00:57:14,720 --> 00:57:16,160
and so that's actually all what the

1533
00:57:16,160 --> 00:57:17,760
recovery does you know recovery is

1534
00:57:17,760 --> 00:57:18,319
basically

1535
00:57:18,319 --> 00:57:21,359
always call dusty installation and if we

1536
00:57:21,359 --> 00:57:22,240
crash

1537
00:57:22,240 --> 00:57:24,720
during installation here no particular

1538
00:57:24,720 --> 00:57:26,079
problem again correct because we'll

1539
00:57:26,079 --> 00:57:26,640
crash

1540
00:57:26,640 --> 00:57:29,520
we'll boot uh xp6 during booting we'll

1541
00:57:29,520 --> 00:57:30,079
call

1542
00:57:30,079 --> 00:57:32,799
uh log in it which we'll call recovery

1543
00:57:32,799 --> 00:57:33,280
log

1544
00:57:33,280 --> 00:57:35,119
and it will basically reinstall or

1545
00:57:35,119 --> 00:57:37,280
replay the lock as sometimes it's called

1546
00:57:37,280 --> 00:57:40,480
again and this might have this might end

1547
00:57:40,480 --> 00:57:42,640
uh if we crash every time or you know

1548
00:57:42,640 --> 00:57:43,920
many many times

1549
00:57:43,920 --> 00:57:46,079
you know it will reinstall replay the

1550
00:57:46,079 --> 00:57:47,359
log many many many times

1551
00:57:47,359 --> 00:57:48,799
until hopefully at some point it

1552
00:57:48,799 --> 00:57:51,040
succeeds and actually you know gets the

1553
00:57:51,040 --> 00:57:51,520
whole

1554
00:57:51,520 --> 00:57:54,240
log written uh or gets the whole log

1555
00:57:54,240 --> 00:57:56,720
installed you know to the

1556
00:57:56,720 --> 00:57:59,680
to the home locations does that make

1557
00:57:59,680 --> 00:58:03,750
sense

1558
00:58:03,760 --> 00:58:07,359
i had a question about so if a process

1559
00:58:07,359 --> 00:58:10,640
just runs normally it writes some data

1560
00:58:10,640 --> 00:58:12,880
to disk and then at some point after

1561
00:58:12,880 --> 00:58:13,760
that

1562
00:58:13,760 --> 00:58:16,160
before it commits and installs the

1563
00:58:16,160 --> 00:58:17,599
changes

1564
00:58:17,599 --> 00:58:21,119
there is a failure the process

1565
00:58:21,119 --> 00:58:23,440
the from the process point of view

1566
00:58:23,440 --> 00:58:24,319
nothing happened

1567
00:58:24,319 --> 00:58:27,520
but something like i guess the failure

1568
00:58:27,520 --> 00:58:28,720
happened after the

1569
00:58:28,720 --> 00:58:33,040
process ended um what it was doing

1570
00:58:33,040 --> 00:58:36,079
so is there anything bad about that

1571
00:58:36,079 --> 00:58:37,920
i'm not 100 you're really getting it but

1572
00:58:37,920 --> 00:58:39,920
the uh

1573
00:58:39,920 --> 00:58:41,359
the short answer is there's nothing bad

1574
00:58:41,359 --> 00:58:43,040
right because the disc won't be updated

1575
00:58:43,040 --> 00:58:43,440
at all

1576
00:58:43,440 --> 00:58:46,079
so just as if you know that file system

1577
00:58:46,079 --> 00:58:48,079
operation didn't happen

1578
00:58:48,079 --> 00:58:51,200
uh right or i guess i'm saying

1579
00:58:51,200 --> 00:58:53,920
the process disappears too but you know

1580
00:58:53,920 --> 00:58:55,520
we don't expect the process to survive

1581
00:58:55,520 --> 00:58:58,160
failures anyway

1582
00:58:58,160 --> 00:59:01,760
right or i guess okay

1583
00:59:01,760 --> 00:59:03,280
i i think that answered my question

1584
00:59:03,280 --> 00:59:05,599
thank you

1585
00:59:05,599 --> 00:59:07,359
yeah it's important to remember that

1586
00:59:07,359 --> 00:59:08,880
basically uh

1587
00:59:08,880 --> 00:59:10,559
the only thing that really survives

1588
00:59:10,559 --> 00:59:12,480
failures or that's persistent across

1589
00:59:12,480 --> 00:59:14,319
failures is the disc or the state on the

1590
00:59:14,319 --> 00:59:14,880
disk

1591
00:59:14,880 --> 00:59:19,599
nothing else right

1592
00:59:19,599 --> 00:59:21,440
okay so uh just to make this all

1593
00:59:21,440 --> 00:59:23,599
concrete one a little bit more too

1594
00:59:23,599 --> 00:59:27,280
let's um i put a

1595
00:59:27,280 --> 00:59:30,000
statement in uh be right so actually the

1596
00:59:30,000 --> 00:59:31,839
thing that actually does right to disk

1597
00:59:31,839 --> 00:59:32,559
like in the

1598
00:59:32,559 --> 00:59:34,880
block cache and we're just going to see

1599
00:59:34,880 --> 00:59:35,760
what the

1600
00:59:35,760 --> 00:59:39,040
trace of actual disk rights are because

1601
00:59:39,040 --> 00:59:40,079
basically on monday

1602
00:59:40,079 --> 00:59:43,750
i sort of

1603
00:59:43,760 --> 00:59:45,599
i didn't tell the full truth because

1604
00:59:45,599 --> 00:59:47,200
basically i put the print statement in

1605
00:59:47,200 --> 00:59:47,920
log right

1606
00:59:47,920 --> 00:59:50,559
and not in b write and so now i put it

1607
00:59:50,559 --> 00:59:51,119
in the b

1608
00:59:51,119 --> 00:59:52,720
right and so we can actually see all the

1609
00:59:52,720 --> 00:59:54,319
blocks that are being written

1610
00:59:54,319 --> 00:59:55,920
so we'll do the same thing as before you

1611
00:59:55,920 --> 00:59:57,520
know echo high x

1612
00:59:57,520 --> 00:59:59,200
and just look at actually the actual

1613
00:59:59,200 --> 01:00:01,119
disk rights

1614
01:00:01,119 --> 01:00:02,880
and see if they make sense so the first

1615
01:00:02,880 --> 01:00:04,319
thing to note correct is that this trace

1616
01:00:04,319 --> 01:00:05,760
is way longer

1617
01:00:05,760 --> 01:00:07,119
than the trace that we looked at last

1618
01:00:07,119 --> 01:00:08,960
time in fact that we looked at uh

1619
01:00:08,960 --> 01:00:11,680
slides a couple slides ago right because

1620
01:00:11,680 --> 01:00:12,400
if we looked in

1621
01:00:12,400 --> 01:00:15,520
fact just to demonstrate this

1622
01:00:15,520 --> 01:00:18,720
uh here was that same

1623
01:00:18,720 --> 01:00:22,240
echo high right and what we see there is

1624
01:00:22,240 --> 01:00:23,440
like only

1625
01:00:23,440 --> 01:00:26,799
it's five log right operations but it

1626
01:00:26,799 --> 01:00:28,480
turns into

1627
01:00:28,480 --> 01:00:31,599
many disk operations

1628
01:00:31,599 --> 01:00:34,720
correct so let's look at it

1629
01:00:34,720 --> 01:00:37,920
uh so what we think be right three four

1630
01:00:37,920 --> 01:00:38,880
and five are

1631
01:00:38,880 --> 01:00:48,630
and what is b right two

1632
01:00:48,640 --> 01:00:52,240
anybody what's that writing to the log

1633
01:00:52,240 --> 01:00:57,589
and then the super block not

1634
01:00:57,599 --> 01:00:59,920
yeah so just to look at the uh you've

1635
01:00:59,920 --> 01:01:01,200
got it right you know there's looking at

1636
01:01:01,200 --> 01:01:02,559
this picture again correct

1637
01:01:02,559 --> 01:01:04,960
the logs that's a two so uh that's

1638
01:01:04,960 --> 01:01:06,160
probably the header block

1639
01:01:06,160 --> 01:01:08,160
click the commit record if you will and

1640
01:01:08,160 --> 01:01:09,839
then three is the first data block

1641
01:01:09,839 --> 01:01:11,359
fourth the second data block files is

1642
01:01:11,359 --> 01:01:12,640
the third data block

1643
01:01:12,640 --> 01:01:15,839
right so going back you know this is

1644
01:01:15,839 --> 01:01:18,960
the first right the second right the

1645
01:01:18,960 --> 01:01:20,079
third right

1646
01:01:20,079 --> 01:01:23,040
they're all going into the log and

1647
01:01:23,040 --> 01:01:24,799
they're written to disk

1648
01:01:24,799 --> 01:01:27,200
uh in the lock lock part of the disk and

1649
01:01:27,200 --> 01:01:28,480
then this is the

1650
01:01:28,480 --> 01:01:31,040
commit record you know the header and

1651
01:01:31,040 --> 01:01:41,670
then presumably what is this face

1652
01:01:41,680 --> 01:01:44,559
what is this part is that the bitmap

1653
01:01:44,559 --> 01:01:46,000
setting

1654
01:01:46,000 --> 01:01:48,400
no so what do we think actually stored

1655
01:01:48,400 --> 01:01:52,720
in this be right free okay here aren't

1656
01:01:52,720 --> 01:01:53,359
you

1657
01:01:53,359 --> 01:01:57,440
creating the file that the inode for x

1658
01:01:57,440 --> 01:02:01,200
updating the directory and then also

1659
01:02:01,200 --> 01:02:04,480
actually making the file itself yeah so

1660
01:02:04,480 --> 01:02:06,160
and we didn't do it here correct because

1661
01:02:06,160 --> 01:02:08,720
in these b rights that didn't happen

1662
01:02:08,720 --> 01:02:12,000
but now we're doing it so what what

1663
01:02:12,000 --> 01:02:16,230
what phase is this of the transaction

1664
01:02:16,240 --> 01:02:18,240
installing the changes yeah it's

1665
01:02:18,240 --> 01:02:19,599
installing the changes correct what we

1666
01:02:19,599 --> 01:02:21,520
did here is

1667
01:02:21,520 --> 01:02:24,559
we logged the writes

1668
01:02:24,559 --> 01:02:26,960
then we committed the file system

1669
01:02:26,960 --> 01:02:28,559
operation to create operation and now

1670
01:02:28,559 --> 01:02:30,319
we're installing it

1671
01:02:30,319 --> 01:02:31,599
so now we're putting the blocks in their

1672
01:02:31,599 --> 01:02:34,319
home location

1673
01:02:34,319 --> 01:02:36,880
and now and what does this be right to

1674
01:02:36,880 --> 01:02:44,390
you then

1675
01:02:44,400 --> 01:02:46,319
it's clearing the log yeah it's clear to

1676
01:02:46,319 --> 01:02:47,680
lock exactly

1677
01:02:47,680 --> 01:02:50,960
so basically this this this the system

1678
01:02:50,960 --> 01:02:53,760
call was writing 33 46 of 32

1679
01:02:53,760 --> 01:02:55,359
and to actually do that using the

1680
01:02:55,359 --> 01:02:57,119
logging system that basically turns into

1681
01:02:57,119 --> 01:02:59,280
this set of

1682
01:02:59,280 --> 01:03:02,400
uh disk writes right where the first

1683
01:03:02,400 --> 01:03:04,079
part is the installing the law

1684
01:03:04,079 --> 01:03:05,599
if the first party is actually logging

1685
01:03:05,599 --> 01:03:06,880
the rights and the second part is

1686
01:03:06,880 --> 01:03:09,750
installing the log

1687
01:03:09,760 --> 01:03:10,960
and these are the two rights to the

1688
01:03:10,960 --> 01:03:14,870
commit records

1689
01:03:14,880 --> 01:03:16,640
does that make sense is it possible to

1690
01:03:16,640 --> 01:03:18,319
infer where begin

1691
01:03:18,319 --> 01:03:21,760
up and and up would run from this trace

1692
01:03:21,760 --> 01:03:24,799
uh well so we sort of know correct so

1693
01:03:24,799 --> 01:03:25,359
where did

1694
01:03:25,359 --> 01:03:27,119
uh we don't really know where begin off

1695
01:03:27,119 --> 01:03:28,400
start but this is at the beginning

1696
01:03:28,400 --> 01:03:30,319
any file system call starts with a begin

1697
01:03:30,319 --> 01:03:31,440
up

1698
01:03:31,440 --> 01:03:34,319
and it must be the case that the commit

1699
01:03:34,319 --> 01:03:35,920
record correct is

1700
01:03:35,920 --> 01:03:39,039
written in end up so

1701
01:03:39,039 --> 01:03:42,559
we know that this is the end op

1702
01:03:42,559 --> 01:03:47,829
of some file system operation

1703
01:03:47,839 --> 01:03:53,109
does that all make sense

1704
01:03:53,119 --> 01:03:56,160
okay so that was basically xv6 logging

1705
01:03:56,160 --> 01:03:59,760
and logging in action um and i want to

1706
01:03:59,760 --> 01:04:01,680
talk about a couple complications

1707
01:04:01,680 --> 01:04:05,839
uh and even this dirt simple

1708
01:04:05,839 --> 01:04:08,880
naive logging scheme actually has

1709
01:04:08,880 --> 01:04:11,760
complications one thing to immediately

1710
01:04:11,760 --> 01:04:13,039
note of course is

1711
01:04:13,039 --> 01:04:16,640
uh you know is this a very performant

1712
01:04:16,640 --> 01:04:18,559
implementation

1713
01:04:18,559 --> 01:04:27,039
just by looking at this trace

1714
01:04:27,039 --> 01:04:30,240
no yeah why not it just

1715
01:04:30,240 --> 01:04:32,079
i know this is a basically too simple

1716
01:04:32,079 --> 01:04:33,599
question but

1717
01:04:33,599 --> 01:04:36,630
that's important to ask

1718
01:04:36,640 --> 01:04:40,799
like you're writing the stuff twice

1719
01:04:40,799 --> 01:04:41,440
right

1720
01:04:41,440 --> 01:04:42,799
yeah you're writing your stuff twice so

1721
01:04:42,799 --> 01:04:44,319
whenever i write a file f over a big

1722
01:04:44,319 --> 01:04:44,880
file f

1723
01:04:44,880 --> 01:04:47,920
i'm going to write that big file f twice

1724
01:04:47,920 --> 01:04:50,319
and so uh certainly not particularly

1725
01:04:50,319 --> 01:04:51,680
high performance where i mean basically

1726
01:04:51,680 --> 01:04:52,640
we're cutting the performance

1727
01:04:52,640 --> 01:04:55,680
immediately by factor two

1728
01:04:55,680 --> 01:04:58,640
just to get crest safety um and so we'll

1729
01:04:58,640 --> 01:04:59,280
see you on

1730
01:04:59,280 --> 01:05:02,559
on you know when you're reading the uh

1731
01:05:02,559 --> 01:05:05,920
xt xd3 paper for a monday you know one

1732
01:05:05,920 --> 01:05:07,200
thing you should keep in your head is

1733
01:05:07,200 --> 01:05:09,520
while reading is just get how

1734
01:05:09,520 --> 01:05:11,599
how do i get around sort of this factor

1735
01:05:11,599 --> 01:05:15,109
of two

1736
01:05:15,119 --> 01:05:18,160
okay sorry is it the case that you write

1737
01:05:18,160 --> 01:05:18,559
the

1738
01:05:18,559 --> 01:05:22,240
h and the i separately

1739
01:05:22,240 --> 01:05:25,839
yeah i think so okay

1740
01:05:25,839 --> 01:05:28,720
i'll show you in a second why uh what is

1741
01:05:28,720 --> 01:05:31,670
happening there

1742
01:05:31,680 --> 01:05:34,789
or maybe

1743
01:05:34,799 --> 01:05:36,319
well let me not commit too much for that

1744
01:05:36,319 --> 01:05:38,319
answer uh but we'll

1745
01:05:38,319 --> 01:05:40,799
i'll i'll come back to it uh i'm sorry

1746
01:05:40,799 --> 01:05:41,599
am i having the

1747
01:05:41,599 --> 01:05:44,720
empty line not the h9i but yeah

1748
01:05:44,720 --> 01:05:46,799
the new line is a separate right h and i

1749
01:05:46,799 --> 01:05:48,880
just one right and yeah a new line is a

1750
01:05:48,880 --> 01:05:50,160
separate right okay

1751
01:05:50,160 --> 01:05:54,000
thank you you're welcome um

1752
01:05:54,000 --> 01:05:57,119
okay uh there's a complications and i

1753
01:05:57,119 --> 01:05:58,319
want to talk a little bit about these

1754
01:05:58,319 --> 01:06:02,829
complications

1755
01:06:02,839 --> 01:06:07,200
uh so okay here's our basic scheme and

1756
01:06:07,200 --> 01:06:08,880
basic data structures

1757
01:06:08,880 --> 01:06:10,960
and uh there's a free complication that

1758
01:06:10,960 --> 01:06:12,640
i want to talk about

1759
01:06:12,640 --> 01:06:16,480
um or maybe i'll call them challenges

1760
01:06:16,480 --> 01:06:21,349
whatever you want to call them

1761
01:06:21,359 --> 01:06:29,109
the first is eviction

1762
01:06:29,119 --> 01:06:31,440
and the issue is as follows let's say we

1763
01:06:31,440 --> 01:06:33,920
go back to this picture here

1764
01:06:33,920 --> 01:06:37,990
and the whole b cache is full

1765
01:06:38,000 --> 01:06:41,280
and um and so the transaction is in

1766
01:06:41,280 --> 01:06:42,000
progress

1767
01:06:42,000 --> 01:06:45,839
uh let's say we just just updated 45

1768
01:06:45,839 --> 01:06:47,599
it's now done with block 45 so it's

1769
01:06:47,599 --> 01:06:49,520
going to write the next block

1770
01:06:49,520 --> 01:06:53,520
and the cache is full and

1771
01:06:53,520 --> 01:06:57,920
the and

1772
01:06:57,920 --> 01:07:00,000
let's say you know we don't we don't

1773
01:07:00,000 --> 01:07:01,440
have a solution for this yet

1774
01:07:01,440 --> 01:07:03,760
uh but the cache decides uh it is it

1775
01:07:03,760 --> 01:07:06,640
wants to evict 45.

1776
01:07:06,640 --> 01:07:09,039
correct and if it wants to invict 45 but

1777
01:07:09,039 --> 01:07:10,400
it will mean that will mean we have to

1778
01:07:10,400 --> 01:07:13,839
write it you know to its home location

1779
01:07:13,839 --> 01:07:16,160
how bad would it be to write the block

1780
01:07:16,160 --> 01:07:17,520
you know

1781
01:07:17,520 --> 01:07:21,029
you know evict 45

1782
01:07:21,039 --> 01:07:28,559
and write 45 to home location

1783
01:07:28,559 --> 01:07:44,230
is that good or bad

1784
01:07:44,240 --> 01:07:47,359
would any rule be broken if we did that

1785
01:07:47,359 --> 01:07:50,480
i guess that is

1786
01:07:50,480 --> 01:07:53,359
if a crash happens before the other

1787
01:07:53,359 --> 01:07:55,599
rights in the same transaction

1788
01:07:55,599 --> 01:07:58,559
occurs then basically atomicity is

1789
01:07:58,559 --> 01:07:59,520
broken

1790
01:07:59,520 --> 01:08:02,960
yeah so this is bad correct

1791
01:08:02,960 --> 01:08:04,720
that this basically violates this right

1792
01:08:04,720 --> 01:08:07,520
ahead rule that i talked about

1793
01:08:07,520 --> 01:08:09,280
you have to write all the blocks to the

1794
01:08:09,280 --> 01:08:11,599
log before you write any block to its

1795
01:08:11,599 --> 01:08:25,679
home location

1796
01:08:25,679 --> 01:08:27,120
so it has to be the case correct that

1797
01:08:27,120 --> 01:08:29,520
the cache does not evict

1798
01:08:29,520 --> 01:08:32,799
any block that sits in the log does that

1799
01:08:32,799 --> 01:08:34,640
make sense

1800
01:08:34,640 --> 01:08:40,789
so the solution is don't evict

1801
01:08:40,799 --> 01:08:49,269
blocks those are in the lock

1802
01:08:49,279 --> 01:08:51,600
and this is exactly you know what you

1803
01:08:51,600 --> 01:08:53,120
were showing a little bit earlier and

1804
01:08:53,120 --> 01:08:55,440
said i didn't want to talk about

1805
01:08:55,440 --> 01:08:58,400
so if you go to log right again just to

1806
01:08:58,400 --> 01:08:58,719
see

1807
01:08:58,719 --> 01:09:02,480
for a second there you know log right

1808
01:09:02,480 --> 01:09:04,159
here's log right again

1809
01:09:04,159 --> 01:09:07,440
and here we see this call to bpin

1810
01:09:07,440 --> 01:09:11,430
and what do you think bpin does

1811
01:09:11,440 --> 01:09:16,550
name sort of indicates it

1812
01:09:16,560 --> 01:09:20,640
it pins the block in the

1813
01:09:20,640 --> 01:09:23,520
in the cache yeah and how does it do it

1814
01:09:23,520 --> 01:09:24,880
since you've been looking at this for

1815
01:09:24,880 --> 01:09:25,279
your

1816
01:09:25,279 --> 01:09:28,799
current lab extensively

1817
01:09:28,799 --> 01:09:31,520
what do you think it does so without you

1818
01:09:31,520 --> 01:09:32,560
know we could look up the implementation

1819
01:09:32,560 --> 01:09:34,080
with b pin but we can also guess

1820
01:09:34,080 --> 01:09:39,910
what it does

1821
01:09:39,920 --> 01:09:41,920
doesn't it essentially just make it so

1822
01:09:41,920 --> 01:09:43,199
that it doesn't get evicted

1823
01:09:43,199 --> 01:09:45,279
by increasing the ref count yeah exactly

1824
01:09:45,279 --> 01:09:46,319
this is all living a dash

1825
01:09:46,319 --> 01:09:47,839
deep interest increases the ref count

1826
01:09:47,839 --> 01:09:49,520
and we know from the b cache code

1827
01:09:49,520 --> 01:09:50,480
correct that

1828
01:09:50,480 --> 01:09:53,279
uh evict won't evict any blocks we have

1829
01:09:53,279 --> 01:09:56,320
a recount higher than zero

1830
01:09:56,320 --> 01:09:59,120
and so presumably somewhere later in uh

1831
01:09:59,120 --> 01:10:00,400
logging code you know when

1832
01:10:00,400 --> 01:10:02,320
once actually everything is logged you

1833
01:10:02,320 --> 01:10:04,159
know we can actually unpin

1834
01:10:04,159 --> 01:10:07,199
the block right okay so that's one

1835
01:10:07,199 --> 01:10:08,719
complication so we have this pinning and

1836
01:10:08,719 --> 01:10:11,280
unpinning going on

1837
01:10:11,280 --> 01:10:15,440
um let's look at the other complication

1838
01:10:15,440 --> 01:10:29,910
uh

1839
01:10:29,920 --> 01:10:33,360
and the file system operations must fit

1840
01:10:33,360 --> 01:10:41,270
in log

1841
01:10:41,280 --> 01:10:42,800
you know if you see if we go back to our

1842
01:10:42,800 --> 01:10:44,640
picture here or actually maybe this is

1843
01:10:44,640 --> 01:10:46,159
the better picture

1844
01:10:46,159 --> 01:10:53,430
how big is the log in xv6

1845
01:10:57,110 --> 01:10:57,120
30 blocks yeah 30 blocks 42-2

1846
01:10:57,120 --> 01:11:00,719
so you know the max size max log size is

1847
01:11:00,719 --> 01:11:03,830
30.

1848
01:11:03,840 --> 01:11:05,679
of course we could bump it up and you

1849
01:11:05,679 --> 01:11:07,520
know real file system runs with a much

1850
01:11:07,520 --> 01:11:08,239
bigger log

1851
01:11:08,239 --> 01:11:10,080
but it doesn't really matter no matter

1852
01:11:10,080 --> 01:11:12,080
what it has to be the case correct that

1853
01:11:12,080 --> 01:11:14,480
the file system operation must fit in 30

1854
01:11:14,480 --> 01:11:16,880
blocks because if a file system

1855
01:11:16,880 --> 01:11:18,480
operation would try to write more to 30

1856
01:11:18,480 --> 01:11:19,280
blocks

1857
01:11:19,280 --> 01:11:20,719
that means we would have to spill

1858
01:11:20,719 --> 01:11:22,400
something to the on disk location and

1859
01:11:22,400 --> 01:11:23,600
we're not allowed to do that right

1860
01:11:23,600 --> 01:11:24,719
because that would violate the right

1861
01:11:24,719 --> 01:11:26,159
ahead rule again

1862
01:11:26,159 --> 01:11:27,760
so it has to be the case that every file

1863
01:11:27,760 --> 01:11:31,199
system operation fits into the log

1864
01:11:31,199 --> 01:11:34,870
does that make sense

1865
01:11:34,880 --> 01:11:36,800
and in fact you know how do you think we

1866
01:11:36,800 --> 01:11:38,320
got to 32

1867
01:11:38,320 --> 01:11:50,550
or 30.

1868
01:11:50,560 --> 01:11:52,080
does it have to do anything with how

1869
01:11:52,080 --> 01:11:54,960
many blocks actually fit

1870
01:11:54,960 --> 01:11:55,920
you know we're another way to find

1871
01:11:55,920 --> 01:11:58,080
because basically

1872
01:11:58,080 --> 01:12:00,560
how many blocks does what is the maximum

1873
01:12:00,560 --> 01:12:01,760
number of blocks correct that the file

1874
01:12:01,760 --> 01:12:04,159
system operation could write

1875
01:12:04,159 --> 01:12:06,159
and that is really what the this number

1876
01:12:06,159 --> 01:12:08,800
30 has to be definitely bigger

1877
01:12:08,800 --> 01:12:11,280
than any you know the max number of

1878
01:12:11,280 --> 01:12:14,790
blocks

1879
01:12:14,800 --> 01:12:20,830
the file system operation

1880
01:12:20,840 --> 01:12:26,470
right

1881
01:12:26,480 --> 01:12:28,560
and so in fact we know robert and i did

1882
01:12:28,560 --> 01:12:29,679
because we went through all the file

1883
01:12:29,679 --> 01:12:31,440
system operations looked at them and you

1884
01:12:31,440 --> 01:12:32,719
know decided whether

1885
01:12:32,719 --> 01:12:34,400
uh what sort of the maximum number is

1886
01:12:34,400 --> 01:12:35,679
and it turns out the action number is

1887
01:12:35,679 --> 01:12:37,360
much lower than the 30

1888
01:12:37,360 --> 01:12:39,120
uh but you know there we'll see in a

1889
01:12:39,120 --> 01:12:40,320
second there's a couple interesting

1890
01:12:40,320 --> 01:12:41,600
complications

1891
01:12:41,600 --> 01:12:43,920
um like for example the operation that

1892
01:12:43,920 --> 01:12:45,600
we look so far like creating a file

1893
01:12:45,600 --> 01:12:47,199
correct is only a handful of blocks

1894
01:12:47,199 --> 01:12:48,640
you know the file system operation is

1895
01:12:48,640 --> 01:12:51,360
like five blocks in fact most

1896
01:12:51,360 --> 01:12:53,440
operations are you know a handful of

1897
01:12:53,440 --> 01:12:54,719
blocks not that many

1898
01:12:54,719 --> 01:12:56,159
can you think of any operations that

1899
01:12:56,159 --> 01:13:13,830
might write many many many blocks

1900
01:13:13,840 --> 01:13:16,239
right on a huge file yeah write a huge

1901
01:13:16,239 --> 01:13:18,960
file right so uh what what if we

1902
01:13:18,960 --> 01:13:21,120
you know uh called the right system call

1903
01:13:21,120 --> 01:13:22,719
and we pass it to buffer with like a

1904
01:13:22,719 --> 01:13:24,800
megabyte of data

1905
01:13:24,800 --> 01:13:27,360
like a thousand blocks it seems like

1906
01:13:27,360 --> 01:13:29,040
we're being serious trouble right

1907
01:13:29,040 --> 01:13:31,040
it would violate you know this maximum

1908
01:13:31,040 --> 01:13:33,440
rule and so

1909
01:13:33,440 --> 01:13:43,430
let's look at right

1910
01:13:43,440 --> 01:13:47,910
it's just right

1911
01:13:47,920 --> 01:13:50,400
this is right it calls file right so

1912
01:13:50,400 --> 01:13:52,239
let's see it's a file right

1913
01:13:52,239 --> 01:13:55,679
so here's file right um okay so here's a

1914
01:13:55,679 --> 01:13:57,360
there's an eye node a file descriptor i

1915
01:13:57,360 --> 01:13:58,960
note everything you see my code

1916
01:13:58,960 --> 01:14:01,120
or the code that i have on the display

1917
01:14:01,120 --> 01:14:02,320
and

1918
01:14:02,320 --> 01:14:09,270
notice that what does this code do

1919
01:14:09,280 --> 01:14:10,800
now you can read the comment right on

1920
01:14:10,800 --> 01:14:12,560
top you know here and that basically

1921
01:14:12,560 --> 01:14:13,840
explains it but this is what happens

1922
01:14:13,840 --> 01:14:15,600
because the right is split

1923
01:14:15,600 --> 01:14:18,960
in many number smaller rights

1924
01:14:18,960 --> 01:14:21,440
so what really is going on here correct

1925
01:14:21,440 --> 01:14:25,110
is we're ensuring that the

1926
01:14:25,120 --> 01:14:28,080
whole right as a whole is not uh atomic

1927
01:14:28,080 --> 01:14:28,880
but that's okay

1928
01:14:28,880 --> 01:14:30,480
you know the right unix system called

1929
01:14:30,480 --> 01:14:32,560
semantics don't require that actually

1930
01:14:32,560 --> 01:14:33,600
all the

1931
01:14:33,600 --> 01:14:35,440
thousand blocks you know of our megabyte

1932
01:14:35,440 --> 01:14:37,199
are actually written atomically

1933
01:14:37,199 --> 01:14:39,120
and this requires that we don't corrupt

1934
01:14:39,120 --> 01:14:40,960
the file system you know between

1935
01:14:40,960 --> 01:14:43,120
uh don't corrupt the file system while

1936
01:14:43,120 --> 01:14:44,080
doing it

1937
01:14:44,080 --> 01:14:47,120
and so basically we uh you know xv6

1938
01:14:47,120 --> 01:14:49,120
uh splits a big write in a number of

1939
01:14:49,120 --> 01:14:50,640
smaller writes and writes them as

1940
01:14:50,640 --> 01:14:53,040
individual transactions

1941
01:14:53,040 --> 01:14:54,480
and this one basically ensures that in

1942
01:14:54,480 --> 01:14:56,000
our example if a transaction allocates

1943
01:14:56,000 --> 01:14:57,679
an a block number because

1944
01:14:57,679 --> 01:14:58,880
we need a new block for us an

1945
01:14:58,880 --> 01:15:00,480
intermediate block or because we need a

1946
01:15:00,480 --> 01:15:01,600
new block because we're going to write

1947
01:15:01,600 --> 01:15:02,320
to it

1948
01:15:02,320 --> 01:15:04,239
at least that part is completely atomic

1949
01:15:04,239 --> 01:15:06,080
and the file system will be never left

1950
01:15:06,080 --> 01:15:08,320
in an incorrect state violating any of

1951
01:15:08,320 --> 01:15:10,400
the file system invariants

1952
01:15:10,400 --> 01:15:11,840
and so the right is to split in many

1953
01:15:11,840 --> 01:15:15,040
many uh

1954
01:15:15,040 --> 01:15:17,120
many systems in many smaller rights or

1955
01:15:17,120 --> 01:15:19,440
many transactions

1956
01:15:19,440 --> 01:15:22,000
okay in fact that's the main one that

1957
01:15:22,000 --> 01:15:26,070
actually is

1958
01:15:26,080 --> 01:15:29,920
right fs split in many

1959
01:15:29,920 --> 01:15:37,350
many transactions

1960
01:15:37,360 --> 01:15:43,510
any questions about this

1961
01:15:43,520 --> 01:15:45,360
and note because you know things are

1962
01:15:45,360 --> 01:15:47,040
pinned correct in cash that means also

1963
01:15:47,040 --> 01:15:48,080
that the

1964
01:15:48,080 --> 01:15:51,280
block cache was me bigger than

1965
01:15:51,280 --> 01:15:57,910
bigger reader to the lock size

1966
01:15:57,920 --> 01:16:01,440
okay uh so now the final challenge that

1967
01:16:01,440 --> 01:16:03,920
i want to talk about

1968
01:16:03,920 --> 01:16:07,600
is concurrent

1969
01:16:07,600 --> 01:16:18,070
file system calls

1970
01:16:18,080 --> 01:16:20,159
and the issue is as follows you know let

1971
01:16:20,159 --> 01:16:21,600
me first try to explain what the problem

1972
01:16:21,600 --> 01:16:21,920
is

1973
01:16:21,920 --> 01:16:24,560
and then we'll see what the solution is

1974
01:16:24,560 --> 01:16:25,679
um

1975
01:16:25,679 --> 01:16:29,280
so let's say we have our log

1976
01:16:29,280 --> 01:16:32,640
and uh and we're writing and maybe there

1977
01:16:32,640 --> 01:16:33,679
are two transactions

1978
01:16:33,679 --> 01:16:36,719
executing concurrently and

1979
01:16:36,719 --> 01:16:38,320
you just imagine for a second that you

1980
01:16:38,320 --> 01:16:40,560
know they uh

1981
01:16:40,560 --> 01:16:42,719
they uh write a lot of blocks so

1982
01:16:42,719 --> 01:16:44,080
basically t zero

1983
01:16:44,080 --> 01:16:46,239
is executing t zero is executing you

1984
01:16:46,239 --> 01:16:47,520
know they're all false so here's the

1985
01:16:47,520 --> 01:16:49,520
beginning of the log here's the

1986
01:16:49,520 --> 01:16:53,199
uh end of the log and uh

1987
01:16:53,199 --> 01:16:55,120
you know t one executes signals and

1988
01:16:55,120 --> 01:16:56,560
blocks and etc

1989
01:16:56,560 --> 01:16:58,719
etc and by the time we run to the end of

1990
01:16:58,719 --> 01:17:00,880
the log neither one is complete yet you

1991
01:17:00,880 --> 01:17:01,360
know so

1992
01:17:01,360 --> 01:17:04,640
both have still more rights to do

1993
01:17:04,640 --> 01:17:08,239
and uh at this point

1994
01:17:08,239 --> 01:17:10,080
can we commit any of the two

1995
01:17:10,080 --> 01:17:14,790
transactions

1996
01:17:14,800 --> 01:17:16,800
no we can't correct because if we would

1997
01:17:16,800 --> 01:17:17,920
uh commit

1998
01:17:17,920 --> 01:17:20,719
a transaction that is partially done

1999
01:17:20,719 --> 01:17:21,360
then

2000
01:17:21,360 --> 01:17:24,400
we uh violate the right ahead rule again

2001
01:17:24,400 --> 01:17:26,480
and you know the whole purpose of action

2002
01:17:26,480 --> 01:17:28,400
login doesn't work out

2003
01:17:28,400 --> 01:17:30,960
uh so it has to be the case that

2004
01:17:30,960 --> 01:17:31,520
basically

2005
01:17:31,520 --> 01:17:34,239
a number of concurrent transactions must

2006
01:17:34,239 --> 01:17:34,800
fit

2007
01:17:34,800 --> 01:17:38,000
in the lock in fact all concurrent

2008
01:17:38,000 --> 01:17:54,870
operations

2009
01:17:54,880 --> 01:17:58,400
was fit and so in the way

2010
01:17:58,400 --> 01:18:01,280
um so this is sort of a challenge

2011
01:18:01,280 --> 01:18:02,800
correct we have you know a file system

2012
01:18:02,800 --> 01:18:04,320
called starting and

2013
01:18:04,320 --> 01:18:06,239
uh you know we gotta sort of arrange

2014
01:18:06,239 --> 01:18:07,760
that basically the

2015
01:18:07,760 --> 01:18:11,440
uh that we that we basically do a sort

2016
01:18:11,440 --> 01:18:12,640
of a

2017
01:18:12,640 --> 01:18:14,400
an entrance you know check you know

2018
01:18:14,400 --> 01:18:16,560
before we actually let the file system

2019
01:18:16,560 --> 01:18:18,719
operation go we must check whether it

2020
01:18:18,719 --> 01:18:20,239
actually is not blocked still

2021
01:18:20,239 --> 01:18:22,239
you know if we have like end file system

2022
01:18:22,239 --> 01:18:23,679
operations already in progress

2023
01:18:23,679 --> 01:18:25,760
we have to make sure that if we add like

2024
01:18:25,760 --> 01:18:27,600
allow one more guy to start

2025
01:18:27,600 --> 01:18:29,360
that actually the total number of blocks

2026
01:18:29,360 --> 01:18:30,880
that right they could write together

2027
01:18:30,880 --> 01:18:32,960
actually fits in the log

2028
01:18:32,960 --> 01:18:35,120
and the way you know basically xc6 sort

2029
01:18:35,120 --> 01:18:36,480
of gets around this

2030
01:18:36,480 --> 01:18:38,239
is it basically limits the number of

2031
01:18:38,239 --> 01:18:49,270
concurrent file system calls

2032
01:18:49,280 --> 01:18:54,480
and the way it basically works is that

2033
01:18:54,480 --> 01:18:56,800
uh in begin op you know we just see how

2034
01:18:56,800 --> 01:18:57,760
many outstanding

2035
01:18:57,760 --> 01:18:59,679
uh concurrent file system operations are

2036
01:18:59,679 --> 01:19:01,760
in progress if there are too many

2037
01:19:01,760 --> 01:19:03,840
in progress we just stop the current

2038
01:19:03,840 --> 01:19:05,920
file system operation it goes to sleep

2039
01:19:05,920 --> 01:19:07,760
and it will wait until all the other

2040
01:19:07,760 --> 01:19:11,040
guys are done and have committed

2041
01:19:11,040 --> 01:19:12,400
and all the other guys will commit

2042
01:19:12,400 --> 01:19:14,000
together in fact like you know at some

2043
01:19:14,000 --> 01:19:16,320
point that t122 they're basically done

2044
01:19:16,320 --> 01:19:18,560
you know maybe t3 is in the two they

2045
01:19:18,560 --> 01:19:19,920
finish and then basically

2046
01:19:19,920 --> 01:19:22,560
in all these transactions and in a

2047
01:19:22,560 --> 01:19:24,080
single time in a single or

2048
01:19:24,080 --> 01:19:27,830
basically are committed together

2049
01:19:27,840 --> 01:19:30,000
this is sometimes called group commit

2050
01:19:30,000 --> 01:19:31,280
because you're committing multiple

2051
01:19:31,280 --> 01:19:32,239
system calls

2052
01:19:32,239 --> 01:19:33,199
you know all the ones that were

2053
01:19:33,199 --> 01:19:35,360
concurrent in action uh

2054
01:19:35,360 --> 01:19:36,880
you committed this together as a sort of

2055
01:19:36,880 --> 01:19:39,040
a single big transaction so that all

2056
01:19:39,040 --> 01:19:40,320
their updates are

2057
01:19:40,320 --> 01:19:43,199
visible so that all their updates all

2058
01:19:43,199 --> 01:19:44,000
place all the

2059
01:19:44,000 --> 01:19:47,280
uh so that all their updates all

2060
01:19:47,280 --> 01:19:50,400
take place or none of them take place

2061
01:19:50,400 --> 01:19:55,040
okay uh and we can

2062
01:19:55,040 --> 01:19:56,960
see that you know if we go to a quick

2063
01:19:56,960 --> 01:19:58,719
question

2064
01:19:58,719 --> 01:20:02,080
uh is that is the group commit um

2065
01:20:02,080 --> 01:20:05,120
is grouping the commits necessary

2066
01:20:05,120 --> 01:20:08,080
like could you um say if one system

2067
01:20:08,080 --> 01:20:09,360
calls finish first just

2068
01:20:09,360 --> 01:20:12,800
commit its trade it's um transaction and

2069
01:20:12,800 --> 01:20:13,199
then

2070
01:20:13,199 --> 01:20:14,800
commit the other ones later or is it

2071
01:20:14,800 --> 01:20:17,040
like a necessary property ah

2072
01:20:17,040 --> 01:20:18,880
you got to be very very careful because

2073
01:20:18,880 --> 01:20:20,400
you remember one thing i didn't really

2074
01:20:20,400 --> 01:20:22,159
state this explicitly as a goal early on

2075
01:20:22,159 --> 01:20:23,840
is that we basically execute the system

2076
01:20:23,840 --> 01:20:25,920
called still in the right order

2077
01:20:25,920 --> 01:20:28,960
right if uh the

2078
01:20:28,960 --> 01:20:31,600
if a write or if a read observes a write

2079
01:20:31,600 --> 01:20:32,880
and then does it right

2080
01:20:32,880 --> 01:20:34,239
then it has to be the case that that

2081
01:20:34,239 --> 01:20:35,679
second right happens later than the

2082
01:20:35,679 --> 01:20:37,040
first right

2083
01:20:37,040 --> 01:20:39,280
and the reason that this is a log

2084
01:20:39,280 --> 01:20:40,480
correct is because that basically

2085
01:20:40,480 --> 01:20:42,159
reflects the order in which the rights

2086
01:20:42,159 --> 01:20:44,080
haven't happened

2087
01:20:44,080 --> 01:20:47,600
and so you can't really uh really nearly

2088
01:20:47,600 --> 01:20:49,199
change the order of the writes in the

2089
01:20:49,199 --> 01:20:49,840
log

2090
01:20:49,840 --> 01:20:52,000
because that may actually result into

2091
01:20:52,000 --> 01:20:53,679
bizarre uh

2092
01:20:53,679 --> 01:20:56,320
bizarre behavior observable by user

2093
01:20:56,320 --> 01:20:58,000
programs

2094
01:20:58,000 --> 01:20:59,040
and so it has to be the case that

2095
01:20:59,040 --> 01:21:01,440
basically you commit you know the

2096
01:21:01,440 --> 01:21:03,040
operations transactions in the order

2097
01:21:03,040 --> 01:21:05,040
they happened

2098
01:21:05,040 --> 01:21:06,480
and also performed their rights in the

2099
01:21:06,480 --> 01:21:09,199
order they happened

2100
01:21:09,199 --> 01:21:13,510
and so in general you know

2101
01:21:13,520 --> 01:21:15,280
it's safe you know it's safe to

2102
01:21:15,280 --> 01:21:16,560
basically commit them all together

2103
01:21:16,560 --> 01:21:19,760
you're always in a good shape okay

2104
01:21:19,760 --> 01:21:23,750
good question though

2105
01:21:23,760 --> 01:21:26,800
um okay i just want to go back to one

2106
01:21:26,800 --> 01:21:27,679
more thing

2107
01:21:27,679 --> 01:21:29,920
and look at the beginner up i talked a

2108
01:21:29,920 --> 01:21:31,120
little bit because i said like oh

2109
01:21:31,120 --> 01:21:32,239
nothing i don't really want to talk

2110
01:21:32,239 --> 01:21:35,830
about it right now

2111
01:21:35,840 --> 01:21:40,950
but there we can see

2112
01:21:40,960 --> 01:21:44,639
so here's the game up uh first of all

2113
01:21:44,639 --> 01:21:46,960
if we're already in committing the log

2114
01:21:46,960 --> 01:21:48,239
we're just going to wait until the log

2115
01:21:48,239 --> 01:21:48,960
has committed

2116
01:21:48,960 --> 01:21:51,120
because you know we can't write to the

2117
01:21:51,120 --> 01:21:52,560
log while the log actually being

2118
01:21:52,560 --> 01:21:53,920
installed

2119
01:21:53,920 --> 01:21:57,840
um if uh we're the

2120
01:21:57,840 --> 01:22:00,320
end concurrent operation that basically

2121
01:22:00,320 --> 01:22:02,480
makes us go across that lock size we

2122
01:22:02,480 --> 01:22:05,120
could just go to sleep

2123
01:22:05,120 --> 01:22:07,679
and wait until basically all the

2124
01:22:07,679 --> 01:22:09,199
preceding concurrent transactions are

2125
01:22:09,199 --> 01:22:10,480
done

2126
01:22:10,480 --> 01:22:12,880
and if we're allowed to proceed you know

2127
01:22:12,880 --> 01:22:14,400
basically our entrance

2128
01:22:14,400 --> 01:22:16,400
is allowed you know we increase lockout

2129
01:22:16,400 --> 01:22:17,600
standing by one

2130
01:22:17,600 --> 01:22:19,120
because that reflect our thing and then

2131
01:22:19,120 --> 01:22:20,560
we basically proceed and start doing

2132
01:22:20,560 --> 01:22:22,800
file system operations

2133
01:22:22,800 --> 01:22:26,560
and if you look at and off again just to

2134
01:22:26,560 --> 01:22:28,400
see you see that end up basically

2135
01:22:28,400 --> 01:22:30,320
decreases lock outstanding by one

2136
01:22:30,320 --> 01:22:32,560
because one transaction has finished

2137
01:22:32,560 --> 01:22:35,440
uh it certainly would be an error if we

2138
01:22:35,440 --> 01:22:37,040
were in creating states we panic in that

2139
01:22:37,040 --> 01:22:37,679
case

2140
01:22:37,679 --> 01:22:39,760
and we actually are the last one from

2141
01:22:39,760 --> 01:22:41,840
that set of concurrent transactions

2142
01:22:41,840 --> 01:22:43,840
then actually uh and lockouts and it

2143
01:22:43,840 --> 01:22:45,120
goes to zero we immediately start

2144
01:22:45,120 --> 01:22:46,800
committing

2145
01:22:46,800 --> 01:22:49,920
and then when we're done uh or when

2146
01:22:49,920 --> 01:22:52,960
actually uh uh if we're not the lie uh

2147
01:22:52,960 --> 01:22:56,159
yeah um

2148
01:22:56,159 --> 01:22:59,510
yeah we commit

2149
01:22:59,520 --> 01:23:02,000
uh and if there's space you know uh left

2150
01:23:02,000 --> 01:23:03,520
you know we wake up a guy so that they

2151
01:23:03,520 --> 01:23:06,320
can actually start running

2152
01:23:06,320 --> 01:23:09,280
okay so even though this dirt simple

2153
01:23:09,280 --> 01:23:10,639
file system that uh

2154
01:23:10,639 --> 01:23:12,480
or this very simple logging system that

2155
01:23:12,480 --> 01:23:14,320
xv6 actually has a bunch of

2156
01:23:14,320 --> 01:23:18,070
complications

2157
01:23:18,080 --> 01:23:20,000
so i'm starting to run out of time so

2158
01:23:20,000 --> 01:23:22,239
let me wrap up here

2159
01:23:22,239 --> 01:23:25,830
so in summary

2160
01:23:25,840 --> 01:23:28,239
you know what we uh what we talked about

2161
01:23:28,239 --> 01:23:30,560
is basically logging

2162
01:23:30,560 --> 01:23:35,840
as a solution for for crash safety

2163
01:23:35,840 --> 01:23:39,669
or really for multi-step

2164
01:23:39,679 --> 01:23:43,669
file system operations

2165
01:23:43,679 --> 01:23:46,320
and you know what have you seen so far

2166
01:23:46,320 --> 01:23:48,159
you know it works great for crash safety

2167
01:23:48,159 --> 01:23:51,600
but you know performance and

2168
01:23:51,600 --> 01:23:53,360
that's going to be the topic for monday

2169
01:23:53,360 --> 01:23:55,120
and as you read

2170
01:23:55,120 --> 01:23:58,080
that hd3 file system paper for monday

2171
01:23:58,080 --> 01:23:59,360
you know that's the thing you should be

2172
01:23:59,360 --> 01:24:02,080
thinking about

2173
01:24:02,080 --> 01:24:04,320
any more final questions and in fact

2174
01:24:04,320 --> 01:24:05,920
anybody who has to leave you know please

2175
01:24:05,920 --> 01:24:07,679
you know feel free to leave but if you

2176
01:24:07,679 --> 01:24:08,239
uh

2177
01:24:08,239 --> 01:24:09,520
i want to hang around and ask more

2178
01:24:09,520 --> 01:24:14,470
questions uh you know please do so

2179
01:24:14,480 --> 01:24:17,600
oh i have a question regarding um cache

2180
01:24:17,600 --> 01:24:18,080
size

2181
01:24:18,080 --> 01:24:21,120
and the log size so you said that the

2182
01:24:21,120 --> 01:24:23,199
cache size has to be at least as big as

2183
01:24:23,199 --> 01:24:25,840
the log size but they seem to be the

2184
01:24:25,840 --> 01:24:27,199
same size for

2185
01:24:27,199 --> 01:24:30,159
this case so would that mean that if the

2186
01:24:30,159 --> 01:24:30,800
log

2187
01:24:30,800 --> 01:24:34,639
pins 30 um

2188
01:24:34,639 --> 01:24:37,600
buffers and then some other operation

2189
01:24:37,600 --> 01:24:39,679
tries to do something

2190
01:24:39,679 --> 01:24:43,600
it just fails because it it runs out of

2191
01:24:43,600 --> 01:24:47,440
free spots in the buffer

2192
01:24:47,440 --> 01:24:50,639
no maybe let's let's

2193
01:24:50,639 --> 01:24:56,470
look at the uh okay so

2194
01:24:56,480 --> 01:25:02,470
let me first actually check one thing uh

2195
01:25:02,480 --> 01:25:07,189
okay let's go through bio

2196
01:25:07,199 --> 01:25:10,400
uh okay let's

2197
01:25:10,400 --> 01:25:12,000
actually first check if and buff is

2198
01:25:12,000 --> 01:25:15,110
bigger than

2199
01:25:15,120 --> 01:25:16,960
okay let's set some matchbox excited to

2200
01:25:16,960 --> 01:25:18,800
the block cache okay so it's set up to

2201
01:25:18,800 --> 01:25:20,560
something big

2202
01:25:20,560 --> 01:25:23,040
uh so what happens actually if we can't

2203
01:25:23,040 --> 01:25:25,520
find bkt and find a buffer

2204
01:25:25,520 --> 01:25:28,790
and actually use panics

2205
01:25:28,800 --> 01:25:32,070
and

2206
01:25:32,080 --> 01:25:34,719
so we if there's no free slot in the

2207
01:25:34,719 --> 01:25:36,719
buffer cache you know xv6 panic so it's

2208
01:25:36,719 --> 01:25:37,840
not particularly ideal

2209
01:25:37,840 --> 01:25:40,800
in fact to be it's terrible uh and so

2210
01:25:40,800 --> 01:25:42,159
you hope never to be in this situation

2211
01:25:42,159 --> 01:25:43,199
and hopefully we picked our numbers

2212
01:25:43,199 --> 01:25:44,320
correctly that basically this is

2213
01:25:44,320 --> 01:25:46,000
unlikely to happen

2214
01:25:46,000 --> 01:25:49,360
uh but why can't we return an error

2215
01:25:49,360 --> 01:25:50,560
because that seems like the obvious

2216
01:25:50,560 --> 01:26:05,510
thing to do like you know

2217
01:26:05,520 --> 01:26:07,120
you just return an error to the the

2218
01:26:07,120 --> 01:26:08,639
caller and then the caller

2219
01:26:08,639 --> 01:26:10,560
maybe returns uh back up to the file

2220
01:26:10,560 --> 01:26:12,400
system interface and just returns minus

2221
01:26:12,400 --> 01:26:15,280
one saying like oh this operation failed

2222
01:26:15,280 --> 01:26:20,950
why is that a problem

2223
01:26:20,960 --> 01:26:22,800
so ready to think about this is that you

2224
01:26:22,800 --> 01:26:24,800
know many file system operations are

2225
01:26:24,800 --> 01:26:26,960
multi-step operations correct

2226
01:26:26,960 --> 01:26:29,280
uh as we have seen now uh in this

2227
01:26:29,280 --> 01:26:30,080
lecture

2228
01:26:30,080 --> 01:26:32,560
and in the previous lecture and let's

2229
01:26:32,560 --> 01:26:33,520
say

2230
01:26:33,520 --> 01:26:36,560
uh we did two writes and then the third

2231
01:26:36,560 --> 01:26:39,520
right we run into this case where we

2232
01:26:39,520 --> 01:26:40,880
can't actually do the right because you

2233
01:26:40,880 --> 01:26:44,400
know there's no place in the block cache

2234
01:26:44,400 --> 01:26:47,520
we have done two rights right can we

2235
01:26:47,520 --> 01:26:53,830
just bail out of the file system call

2236
01:26:53,840 --> 01:26:56,320
okay i see right we cannot correct

2237
01:26:56,320 --> 01:26:58,080
because we might have updated in

2238
01:26:58,080 --> 01:27:00,480
the in the the directory you know a

2239
01:27:00,480 --> 01:27:02,400
directory block of some

2240
01:27:02,400 --> 01:27:05,040
uh file for we might have to update the

2241
01:27:05,040 --> 01:27:06,960
directory block of some directory and

2242
01:27:06,960 --> 01:27:09,280
if we wanted to make this work you know

2243
01:27:09,280 --> 01:27:10,719
what we would have to do is basically

2244
01:27:10,719 --> 01:27:11,840
undo those changes

2245
01:27:11,840 --> 01:27:14,560
right like any uh rights that we did

2246
01:27:14,560 --> 01:27:15,199
before

2247
01:27:15,199 --> 01:27:16,840
as part of that system call we have to

2248
01:27:16,840 --> 01:27:18,719
undo

2249
01:27:18,719 --> 01:27:22,080
right and you know that is painful

2250
01:27:22,080 --> 01:27:24,560
right so we don't do it does that make

2251
01:27:24,560 --> 01:27:25,679
sense

2252
01:27:25,679 --> 01:27:29,120
okay so it's not a problem if they

2253
01:27:29,120 --> 01:27:32,880
log the the log pins everything

2254
01:27:32,880 --> 01:27:34,800
and there's no more space for cash but

2255
01:27:34,800 --> 01:27:36,159
it will just pat it

2256
01:27:36,159 --> 01:27:38,960
okay yeah yeah of course this banner

2257
01:27:38,960 --> 01:27:39,920
should never really happen

2258
01:27:39,920 --> 01:27:41,840
right like there's an only off corner

2259
01:27:41,840 --> 01:27:43,920
cases where that hopefully happens

2260
01:27:43,920 --> 01:27:47,600
right i guess if you just okay yeah

2261
01:27:47,600 --> 01:27:50,239
that makes sense okay thank you you're

2262
01:27:50,239 --> 01:27:51,840
welcome

2263
01:27:51,840 --> 01:27:54,960
any more questions uh i have a question

2264
01:27:54,960 --> 01:27:55,440
about

2265
01:27:55,440 --> 01:27:57,440
um i guess following up on my earlier

2266
01:27:57,440 --> 01:27:59,520
one about uh

2267
01:27:59,520 --> 01:28:02,560
the group commits um i was

2268
01:28:02,560 --> 01:28:04,960
trying to think of like i think i kind

2269
01:28:04,960 --> 01:28:06,159
of understand it at a high level what i

2270
01:28:06,159 --> 01:28:06,960
was trying to make sure like i

2271
01:28:06,960 --> 01:28:07,920
understand like a

2272
01:28:07,920 --> 01:28:10,560
concrete example why group commits is is

2273
01:28:10,560 --> 01:28:11,120
important

2274
01:28:11,120 --> 01:28:14,560
and uh is this an example that kind of

2275
01:28:14,560 --> 01:28:16,639
demonstrates it it's like i guess i was

2276
01:28:16,639 --> 01:28:18,239
thinking of like a situation where you

2277
01:28:18,239 --> 01:28:19,120
have

2278
01:28:19,120 --> 01:28:22,719
um say like this might be convoluted

2279
01:28:22,719 --> 01:28:23,760
like one process

2280
01:28:23,760 --> 01:28:26,400
generating a stream of like numbers like

2281
01:28:26,400 --> 01:28:27,600
one through n

2282
01:28:27,600 --> 01:28:31,040
and then two processes consuming

2283
01:28:31,040 --> 01:28:32,480
uh that maybe they're listening on the

2284
01:28:32,480 --> 01:28:34,480
same pipe um

2285
01:28:34,480 --> 01:28:37,440
and say like n like stops on an even

2286
01:28:37,440 --> 01:28:38,000
number

2287
01:28:38,000 --> 01:28:40,639
um one process is print consuming and

2288
01:28:40,639 --> 01:28:42,639
printing out the odd numbers one process

2289
01:28:42,639 --> 01:28:44,000
is consuming

2290
01:28:44,000 --> 01:28:47,280
the even numbers um and if you didn't

2291
01:28:47,280 --> 01:28:48,159
have group commits

2292
01:28:48,159 --> 01:28:50,400
so like that the correct behavior is and

2293
01:28:50,400 --> 01:28:51,679
say they're they're printing

2294
01:28:51,679 --> 01:28:53,360
or like they're they're writing these to

2295
01:28:53,360 --> 01:28:54,840
the same file

2296
01:28:54,840 --> 01:28:57,840
um and so the correct behavior would be

2297
01:28:57,840 --> 01:29:00,000
at the end of at the end of all this you

2298
01:29:00,000 --> 01:29:01,199
would expect the file to have

2299
01:29:01,199 --> 01:29:03,520
like an even number like the last number

2300
01:29:03,520 --> 01:29:04,480
um

2301
01:29:04,480 --> 01:29:06,400
but if you didn't have group commits

2302
01:29:06,400 --> 01:29:07,679
it's possible that

2303
01:29:07,679 --> 01:29:11,120
um the the second to last process

2304
01:29:11,120 --> 01:29:13,360
actually gets committed after the last

2305
01:29:13,360 --> 01:29:14,639
one and so you actually see

2306
01:29:14,639 --> 01:29:16,960
nine is this like a correct example of

2307
01:29:16,960 --> 01:29:18,719
why this is important i think

2308
01:29:18,719 --> 01:29:19,840
i have to think a little bit more

2309
01:29:19,840 --> 01:29:21,440
carefully about it uh but that is

2310
01:29:21,440 --> 01:29:22,560
definitely the flavor

2311
01:29:22,560 --> 01:29:24,960
uh of the problem that you might run

2312
01:29:24,960 --> 01:29:28,320
into if you reorder system calls

2313
01:29:28,320 --> 01:29:31,679
okay okay uh i have a

2314
01:29:31,679 --> 01:29:35,280
concrete example in the lecture notes uh

2315
01:29:35,280 --> 01:29:36,480
let you know it's you know of a shell

2316
01:29:36,480 --> 01:29:38,560
command that really you know behaves

2317
01:29:38,560 --> 01:29:41,040
weirdly if you didn't commit this is not

2318
01:29:41,040 --> 01:29:42,239
really an issue in some sense from group

2319
01:29:42,239 --> 01:29:43,440
committee that is really an issue that

2320
01:29:43,440 --> 01:29:44,159
like

2321
01:29:44,159 --> 01:29:45,440
transactions need to be committed in

2322
01:29:45,440 --> 01:29:47,520
order

2323
01:29:47,520 --> 01:29:50,719
um i see and grew and if you didn't have

2324
01:29:50,719 --> 01:29:52,080
group commit then

2325
01:29:52,080 --> 01:29:53,679
yeah that just might not be some people

2326
01:29:53,679 --> 01:29:55,040
might think like well what i would i

2327
01:29:55,040 --> 01:29:56,639
should if i uh if you didn't have group

2328
01:29:56,639 --> 01:29:57,360
commit then

2329
01:29:57,360 --> 01:29:58,880
there's a temptation to basically you

2330
01:29:58,880 --> 01:30:00,320
know commit some later transaction

2331
01:30:00,320 --> 01:30:01,600
because it's already finished but the

2332
01:30:01,600 --> 01:30:03,440
first one isn't finished yet

2333
01:30:03,440 --> 01:30:05,360
uh to create space but that's not a

2334
01:30:05,360 --> 01:30:07,520
solution

2335
01:30:07,520 --> 01:30:10,320
okay that makes sense uh where where in

2336
01:30:10,320 --> 01:30:12,000
the lecture notes was this example i

2337
01:30:12,000 --> 01:30:13,840
think you have a shell command

2338
01:30:13,840 --> 01:30:15,360
where it sort of illustrates that like

2339
01:30:15,360 --> 01:30:17,280
ordering is important

2340
01:30:17,280 --> 01:30:20,480
okay it doesn't tie it directly to

2341
01:30:20,480 --> 01:30:22,560
uh group commit but you basically makes

2342
01:30:22,560 --> 01:30:24,239
the point that ordering system calls is

2343
01:30:24,239 --> 01:30:25,760
important

2344
01:30:25,760 --> 01:30:28,320
i see is this in the the like um the

2345
01:30:28,320 --> 01:30:31,600
text functions

