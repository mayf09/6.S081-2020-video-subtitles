1
00:00:07,600 --> 00:00:09,920
all right

2
00:00:09,920 --> 00:00:13,270
you guys hear me

3
00:00:13,280 --> 00:00:16,240
yes excellent thank you all right today

4
00:00:16,240 --> 00:00:17,840
i want to talk about talk mostly about

5
00:00:17,840 --> 00:00:18,720
microkernels

6
00:00:18,720 --> 00:00:22,000
um but but first a little bit of uh

7
00:00:22,000 --> 00:00:25,519
context to um sort of help explain why

8
00:00:25,519 --> 00:00:26,320
people

9
00:00:26,320 --> 00:00:28,480
explored microkernels in the first place

10
00:00:28,480 --> 00:00:29,840
um

11
00:00:29,840 --> 00:00:32,719
this uh the p people got the

12
00:00:32,719 --> 00:00:35,200
microkernels by trying to think about

13
00:00:35,200 --> 00:00:37,360
uh a little more broadly about what

14
00:00:37,360 --> 00:00:38,879
kernels should actually do

15
00:00:38,879 --> 00:00:42,079
like we you know with xv6 is sort of

16
00:00:42,079 --> 00:00:43,760
does the things that unix does and we

17
00:00:43,760 --> 00:00:45,280
kind of take

18
00:00:45,280 --> 00:00:47,520
um that set of abstractions and system

19
00:00:47,520 --> 00:00:48,399
calls and

20
00:00:48,399 --> 00:00:50,399
uh keep sort of facilities inside the

21
00:00:50,399 --> 00:00:51,680
kernel is kind of

22
00:00:51,680 --> 00:00:54,160
for granted as the target of what we're

23
00:00:54,160 --> 00:00:56,640
trying to design but

24
00:00:56,640 --> 00:00:58,879
it's totally worth wondering gosh what

25
00:00:58,879 --> 00:01:00,320
should a kernel do in the first place

26
00:01:00,320 --> 00:01:01,520
maybe

27
00:01:01,520 --> 00:01:02,960
maybe the particular kind of stuff that

28
00:01:02,960 --> 00:01:04,879
xv6 or linux does

29
00:01:04,879 --> 00:01:07,119
um is not really the best answer or

30
00:01:07,119 --> 00:01:08,400
maybe it is

31
00:01:08,400 --> 00:01:10,799
um and of course you know we're on

32
00:01:10,799 --> 00:01:12,799
somewhat treacherous ground here because

33
00:01:12,799 --> 00:01:14,960
now we're you know where what kernels

34
00:01:14,960 --> 00:01:16,960
are is kind of a development platform

35
00:01:16,960 --> 00:01:18,240
for programmers

36
00:01:18,240 --> 00:01:20,080
as we know programmers different people

37
00:01:20,080 --> 00:01:22,240
have like very different

38
00:01:22,240 --> 00:01:25,840
um sort of subjective preferences about

39
00:01:25,840 --> 00:01:27,439
what kind of infrastructure they like to

40
00:01:27,439 --> 00:01:28,880
program on so we

41
00:01:28,880 --> 00:01:30,960
can't necessarily expect a single best

42
00:01:30,960 --> 00:01:33,280
answer

43
00:01:33,280 --> 00:01:34,880
but we can expect to maybe learn

44
00:01:34,880 --> 00:01:37,119
something and maybe make some progress

45
00:01:37,119 --> 00:01:37,840
by

46
00:01:37,840 --> 00:01:39,200
trying to think about what answers might

47
00:01:39,200 --> 00:01:41,759
be so first of all

48
00:01:41,759 --> 00:01:44,000
let me try to kind of crystallize what

49
00:01:44,000 --> 00:01:45,520
the traditional

50
00:01:45,520 --> 00:01:48,880
approach is to what kind of kernel

51
00:01:48,880 --> 00:01:49,680
interfaces

52
00:01:49,680 --> 00:01:53,280
we ought to be using and linux and unix

53
00:01:53,280 --> 00:01:54,000
and xv6

54
00:01:54,000 --> 00:01:57,600
are all examples of of what i personally

55
00:01:57,600 --> 00:01:58,719
call the

56
00:01:58,719 --> 00:02:01,200
a traditional design approach but

57
00:02:01,200 --> 00:02:02,719
another word for it that kind of

58
00:02:02,719 --> 00:02:04,000
summarizes

59
00:02:04,000 --> 00:02:06,399
uh what this approach has ended up like

60
00:02:06,399 --> 00:02:13,430
is monolithic

61
00:02:13,440 --> 00:02:17,440
monolithic and what that means is that

62
00:02:17,440 --> 00:02:20,000
the kernel is a single big program that

63
00:02:20,000 --> 00:02:22,640
does all kinds of things all within the

64
00:02:22,640 --> 00:02:25,430
same program

65
00:02:25,440 --> 00:02:28,080
and indeed this really reflects the way

66
00:02:28,080 --> 00:02:29,599
people thought about

67
00:02:29,599 --> 00:02:31,599
what kernels ought to be doing a real

68
00:02:31,599 --> 00:02:33,519
hallmark of

69
00:02:33,519 --> 00:02:36,800
kernels like linux is that they have

70
00:02:36,800 --> 00:02:40,480
they provide powerful abstractions

71
00:02:40,480 --> 00:02:42,640
you know they choose things like file

72
00:02:42,640 --> 00:02:43,599
systems

73
00:02:43,599 --> 00:02:47,040
and which is really a complicated item

74
00:02:47,040 --> 00:02:48,879
and they present file systems and files

75
00:02:48,879 --> 00:02:51,280
and directories and file descriptors

76
00:02:51,280 --> 00:02:53,120
as their interface rather than for

77
00:02:53,120 --> 00:02:55,200
example presenting

78
00:02:55,200 --> 00:02:57,360
disk hardware as their interface to

79
00:02:57,360 --> 00:02:58,400
applications

80
00:02:58,400 --> 00:03:01,760
so um and using

81
00:03:01,760 --> 00:03:03,440
presenting powerful abstractions instead

82
00:03:03,440 --> 00:03:04,959
of very low level abstractions have some

83
00:03:04,959 --> 00:03:06,159
big advantages

84
00:03:06,159 --> 00:03:08,319
um so these monolithic kernels often

85
00:03:08,319 --> 00:03:09,360
have sort of

86
00:03:09,360 --> 00:03:17,110
big abstractions

87
00:03:17,120 --> 00:03:21,040
like file the file system

88
00:03:21,040 --> 00:03:22,560
one advantage of big abstractions is

89
00:03:22,560 --> 00:03:24,400
that they're often portable

90
00:03:24,400 --> 00:03:27,040
um of files and directories you can

91
00:03:27,040 --> 00:03:28,640
implement files and directories on all

92
00:03:28,640 --> 00:03:30,239
kinds of storage

93
00:03:30,239 --> 00:03:32,959
um and it the file you know you can use

94
00:03:32,959 --> 00:03:34,159
files and directories that have

95
00:03:34,159 --> 00:03:36,400
having to worry about what brand of disk

96
00:03:36,400 --> 00:03:37,680
drive it's running on or

97
00:03:37,680 --> 00:03:39,440
maybe it's an ssd instead of a hard

98
00:03:39,440 --> 00:03:40,959
drive or maybe it's a network file

99
00:03:40,959 --> 00:03:42,400
system at all it's the same interface

100
00:03:42,400 --> 00:03:43,360
because

101
00:03:43,360 --> 00:03:44,959
the file system interface is pretty high

102
00:03:44,959 --> 00:03:47,040
level pretty abstract

103
00:03:47,040 --> 00:03:50,159
so an advantage of this is that the

104
00:03:50,159 --> 00:03:52,480
it's a way to get portability you can

105
00:03:52,480 --> 00:03:54,799
write an application and have it run on

106
00:03:54,799 --> 00:03:56,159
all kinds of different hardware without

107
00:03:56,159 --> 00:03:58,840
having to modify the

108
00:03:58,840 --> 00:04:01,200
application another example of this is

109
00:04:01,200 --> 00:04:02,879
that

110
00:04:02,879 --> 00:04:05,519
you know unix linux provides an address

111
00:04:05,519 --> 00:04:06,640
space

112
00:04:06,640 --> 00:04:08,720
abstraction rather than providing

113
00:04:08,720 --> 00:04:10,080
something that's like

114
00:04:10,080 --> 00:04:11,680
rather than providing direct access to

115
00:04:11,680 --> 00:04:14,080
the mmu hardware

116
00:04:14,080 --> 00:04:16,720
and that's useful to for portability and

117
00:04:16,720 --> 00:04:18,000
to sort of hide complexity from

118
00:04:18,000 --> 00:04:20,560
applications

119
00:04:20,560 --> 00:04:23,680
so so another big advantage here these

120
00:04:23,680 --> 00:04:25,280
powerful abstractions is that they tend

121
00:04:25,280 --> 00:04:30,310
to hide complexity from applications

122
00:04:30,320 --> 00:04:33,919
the so for example the file descriptor

123
00:04:33,919 --> 00:04:36,400
interface that xv6 provides it's very

124
00:04:36,400 --> 00:04:37,919
simple interface but

125
00:04:37,919 --> 00:04:39,199
you know just read and write on file

126
00:04:39,199 --> 00:04:41,280
descriptors can get much simpler

127
00:04:41,280 --> 00:04:43,040
but behind it is some very complicated

128
00:04:43,040 --> 00:04:46,080
code for actually reading and writing

129
00:04:46,080 --> 00:04:50,550
the disk the file system on disk

130
00:04:50,560 --> 00:04:52,000
and so it's nice for programmers but it

131
00:04:52,000 --> 00:04:54,880
makes for a big complex kernel

132
00:04:54,880 --> 00:04:56,800
these big abstractions also help the

133
00:04:56,800 --> 00:04:59,360
kernel manage and share resources we

134
00:04:59,360 --> 00:05:00,800
sort of delegated to the kernel

135
00:05:00,800 --> 00:05:02,880
things like memory management the kernel

136
00:05:02,880 --> 00:05:04,800
keeps track of what memory is free

137
00:05:04,800 --> 00:05:07,759
we similarly the kernel keeps track of

138
00:05:07,759 --> 00:05:09,440
what parts of the disk are free and what

139
00:05:09,440 --> 00:05:11,120
parts of the disk are in current use

140
00:05:11,120 --> 00:05:14,080
so programs don't get to think about it

141
00:05:14,080 --> 00:05:15,759
and that again it simplifies programs it

142
00:05:15,759 --> 00:05:17,919
also helps with robustness and security

143
00:05:17,919 --> 00:05:19,199
even

144
00:05:19,199 --> 00:05:20,960
because if programs are allowed to

145
00:05:20,960 --> 00:05:22,560
decide what parts of the disk are free

146
00:05:22,560 --> 00:05:23,039
or not

147
00:05:23,039 --> 00:05:26,080
then maybe one program could use

148
00:05:26,080 --> 00:05:27,199
part of the disk that's already being

149
00:05:27,199 --> 00:05:30,320
used by another program

150
00:05:30,320 --> 00:05:33,120
so the fact that the kernel is in charge

151
00:05:33,120 --> 00:05:37,029
of resource management

152
00:05:37,039 --> 00:05:38,479
helps with sharing it helps with

153
00:05:38,479 --> 00:05:40,560
security um but again it

154
00:05:40,560 --> 00:05:44,080
it's a force that um sort of

155
00:05:44,080 --> 00:05:49,350
causes the kernel to be big um

156
00:05:49,360 --> 00:05:51,280
so anyway so so having the kernel be in

157
00:05:51,280 --> 00:05:52,479
charge of all these

158
00:05:52,479 --> 00:05:56,319
sort of juicy abstractions that

159
00:05:56,319 --> 00:05:58,400
even if they have simple interfaces have

160
00:05:58,400 --> 00:05:59,759
a lot of complexity inside

161
00:05:59,759 --> 00:06:03,430
have led kernels to be big

162
00:06:03,440 --> 00:06:07,120
and complex items and another aspect of

163
00:06:07,120 --> 00:06:07,680
this

164
00:06:07,680 --> 00:06:09,919
monolithic design approach is that

165
00:06:09,919 --> 00:06:11,919
because it's all one program

166
00:06:11,919 --> 00:06:13,600
all the different kernel substances like

167
00:06:13,600 --> 00:06:15,280
the file system and the memory allocator

168
00:06:15,280 --> 00:06:16,960
and the scheduler and the virtual memory

169
00:06:16,960 --> 00:06:18,319
system they're all part of one big

170
00:06:18,319 --> 00:06:19,600
integrated program

171
00:06:19,600 --> 00:06:21,120
it means that they can peer into each

172
00:06:21,120 --> 00:06:23,600
other's data structures and so

173
00:06:23,600 --> 00:06:25,600
that's just tended to make it much

174
00:06:25,600 --> 00:06:27,520
easier to implement

175
00:06:27,520 --> 00:06:29,759
facilities that are sort of parts of

176
00:06:29,759 --> 00:06:31,680
more than one

177
00:06:31,680 --> 00:06:33,199
or what you might think of as more than

178
00:06:33,199 --> 00:06:35,759
one kind of modular subsystem so for

179
00:06:35,759 --> 00:06:37,199
example

180
00:06:37,199 --> 00:06:40,319
a system called like exec exec has his

181
00:06:40,319 --> 00:06:41,919
fingers deeply into the file system

182
00:06:41,919 --> 00:06:44,000
because it's reading binary images off

183
00:06:44,000 --> 00:06:44,479
the

184
00:06:44,479 --> 00:06:46,400
disk in order to load them into memory

185
00:06:46,400 --> 00:06:48,479
it also has his fingers into the

186
00:06:48,479 --> 00:06:50,639
memory allocation and virtual memory

187
00:06:50,639 --> 00:06:51,680
paging system

188
00:06:51,680 --> 00:06:53,039
because it needs to set up the address

189
00:06:53,039 --> 00:06:54,960
space of the new process but it's really

190
00:06:54,960 --> 00:06:56,160
easy there's no

191
00:06:56,160 --> 00:06:58,240
problem with doing that in xv6 or linux

192
00:06:58,240 --> 00:07:00,240
because you know both all the file

193
00:07:00,240 --> 00:07:01,680
system is right there

194
00:07:01,680 --> 00:07:03,120
in the same kernel program and the

195
00:07:03,120 --> 00:07:04,479
virtual memory system is also right

196
00:07:04,479 --> 00:07:06,319
there as part of the same program

197
00:07:06,319 --> 00:07:09,039
um and if you know somehow there was a

198
00:07:09,039 --> 00:07:10,240
rigid

199
00:07:10,240 --> 00:07:11,759
split between the file system and the

200
00:07:11,759 --> 00:07:13,280
virtual memory system it'd be much

201
00:07:13,280 --> 00:07:15,120
harder to implement something like exec

202
00:07:15,120 --> 00:07:17,039
that has sort of fingers in both of

203
00:07:17,039 --> 00:07:18,479
these pies

204
00:07:18,479 --> 00:07:20,240
but in a monolithic system just one big

205
00:07:20,240 --> 00:07:22,080
program

206
00:07:22,080 --> 00:07:25,440
it's much easier another thing that

207
00:07:25,440 --> 00:07:27,199
makes

208
00:07:27,199 --> 00:07:28,479
implementing software inside a

209
00:07:28,479 --> 00:07:30,880
monolithic kernel like xv6 or linux easy

210
00:07:30,880 --> 00:07:31,520
is that

211
00:07:31,520 --> 00:07:34,560
all the code runs with full uh

212
00:07:34,560 --> 00:07:37,280
hardware privileges all of xc6 runs in

213
00:07:37,280 --> 00:07:39,520
supervisor mode for example

214
00:07:39,520 --> 00:07:41,599
which means there's no limits there's no

215
00:07:41,599 --> 00:07:42,800
irritating

216
00:07:42,800 --> 00:07:44,800
oh you can't you know redirect that

217
00:07:44,800 --> 00:07:45,919
memory here because you don't have

218
00:07:45,919 --> 00:07:47,039
enough privilege

219
00:07:47,039 --> 00:07:49,680
um all the kernel code runs with sort of

220
00:07:49,680 --> 00:07:52,560
maximum privilege

221
00:07:52,560 --> 00:07:54,879
and you know the same is true of

222
00:07:54,879 --> 00:07:57,759
operating systems like linux

223
00:07:57,759 --> 00:08:01,599
so this design

224
00:08:01,599 --> 00:08:04,160
strategy is very convenient for kernel

225
00:08:04,160 --> 00:08:05,520
developers

226
00:08:05,520 --> 00:08:08,080
and it's made it easy to build these big

227
00:08:08,080 --> 00:08:09,280
abstractions which are

228
00:08:09,280 --> 00:08:13,599
convenient for application developers

229
00:08:13,599 --> 00:08:16,080
however there's also a certain amount to

230
00:08:16,080 --> 00:08:16,960
criticize

231
00:08:16,960 --> 00:08:19,280
with the monolithic the traditional

232
00:08:19,280 --> 00:08:23,189
monolithic approach

233
00:08:23,199 --> 00:08:24,879
and this is starting to be part of the

234
00:08:24,879 --> 00:08:27,680
motivation for

235
00:08:27,680 --> 00:08:30,879
looking at other architectures

236
00:08:30,879 --> 00:08:33,440
like microkernels so you might ask why

237
00:08:33,440 --> 00:08:35,750
not

238
00:08:35,760 --> 00:08:43,430
monolithic kernels

239
00:08:43,440 --> 00:08:46,720
so one is just that they're big and

240
00:08:46,720 --> 00:08:47,839
complex

241
00:08:47,839 --> 00:08:50,959
so anything that's linux is

242
00:08:50,959 --> 00:08:53,200
depending on how you count linux is

243
00:08:53,200 --> 00:08:54,640
somewhere between many hundreds of

244
00:08:54,640 --> 00:08:57,120
thousands and a few million

245
00:08:57,120 --> 00:09:00,240
lines of code and people really do take

246
00:09:00,240 --> 00:09:02,399
advantage of the fact that one part of

247
00:09:02,399 --> 00:09:04,000
linux can sort of look at the data of

248
00:09:04,000 --> 00:09:05,600
another and that makes the programming

249
00:09:05,600 --> 00:09:07,760
easier but it also make there be a lot

250
00:09:07,760 --> 00:09:09,920
of sort of interconnections

251
00:09:09,920 --> 00:09:11,839
and interrelationships between code and

252
00:09:11,839 --> 00:09:13,200
so it can be

253
00:09:13,200 --> 00:09:15,040
a bit challenging sometimes to look at

254
00:09:15,040 --> 00:09:16,320
linux kernel code and figure out what

255
00:09:16,320 --> 00:09:19,350
it's up to

256
00:09:19,360 --> 00:09:21,279
and anytime you get big programs

257
00:09:21,279 --> 00:09:23,120
especially ones that are

258
00:09:23,120 --> 00:09:27,190
complex structure you get bugs

259
00:09:27,200 --> 00:09:29,440
and operating system kernels are no

260
00:09:29,440 --> 00:09:30,480
exceptions and

261
00:09:30,480 --> 00:09:31,760
over the years they've had all kinds of

262
00:09:31,760 --> 00:09:35,120
bugs including bugs that

263
00:09:35,120 --> 00:09:40,070
are exploitable for security

264
00:09:40,080 --> 00:09:44,150
so

265
00:09:44,160 --> 00:09:46,640
so this is sort of a troubling set of

266
00:09:46,640 --> 00:09:47,600
relationships

267
00:09:47,600 --> 00:09:49,360
if you allow a big model of the kernel

268
00:09:49,360 --> 00:09:50,720
you're most certainly

269
00:09:50,720 --> 00:09:53,440
can't avoid bugs and exploitable

270
00:09:53,440 --> 00:09:54,880
security problems

271
00:09:54,880 --> 00:09:57,360
and that's a real i mean there really is

272
00:09:57,360 --> 00:10:00,389
a problem

273
00:10:00,399 --> 00:10:03,760
another reason why people are

274
00:10:03,760 --> 00:10:05,600
maybe not entirely happy with monolithic

275
00:10:05,600 --> 00:10:06,880
kernels is that

276
00:10:06,880 --> 00:10:10,160
they tend to just grow with

277
00:10:10,160 --> 00:10:13,680
all desirable features over time and so

278
00:10:13,680 --> 00:10:15,200
you know linux is used for all kinds of

279
00:10:15,200 --> 00:10:17,120
different things from telephone handsets

280
00:10:17,120 --> 00:10:21,440
to desktop workstations and laptops to

281
00:10:21,440 --> 00:10:23,839
tablets to servers on the internet to

282
00:10:23,839 --> 00:10:24,959
routers

283
00:10:24,959 --> 00:10:27,600
um and that's caused the next it's

284
00:10:27,600 --> 00:10:29,200
fantastic that linux can support all

285
00:10:29,200 --> 00:10:30,160
those things

286
00:10:30,160 --> 00:10:31,920
but it has caused it to be very general

287
00:10:31,920 --> 00:10:34,079
so it has support in there for many many

288
00:10:34,079 --> 00:10:35,120
different things

289
00:10:35,120 --> 00:10:37,440
and any one application like me running

290
00:10:37,440 --> 00:10:40,000
my web server is unlikely to need

291
00:10:40,000 --> 00:10:41,600
uh for example linux's very

292
00:10:41,600 --> 00:10:44,000
sophisticated sound card support

293
00:10:44,000 --> 00:10:45,920
so there's just a huge amount of stuff

294
00:10:45,920 --> 00:10:47,760
that's there for

295
00:10:47,760 --> 00:10:50,959
to allow linux to be general purpose um

296
00:10:50,959 --> 00:10:54,560
which is good but there's a worry

297
00:10:54,560 --> 00:10:57,600
that uh general purpose is gonna tend to

298
00:10:57,600 --> 00:10:58,880
mean slow

299
00:10:58,880 --> 00:11:01,040
that you know it may be good for all

300
00:11:01,040 --> 00:11:02,240
kinds of different things but

301
00:11:02,240 --> 00:11:04,720
maybe not optimum for anything in

302
00:11:04,720 --> 00:11:06,640
particular

303
00:11:06,640 --> 00:11:08,959
so it's very hard to you know when

304
00:11:08,959 --> 00:11:10,000
you're trying to make something run

305
00:11:10,000 --> 00:11:10,720
really fast

306
00:11:10,720 --> 00:11:13,120
it's great to have it just only do one

307
00:11:13,120 --> 00:11:14,720
or two things so you can focus on

308
00:11:14,720 --> 00:11:17,279
optimizing a single code path

309
00:11:17,279 --> 00:11:19,360
but if your software needs to do any one

310
00:11:19,360 --> 00:11:20,720
of a thousand different things it's much

311
00:11:20,720 --> 00:11:25,190
harder to have focused optimization

312
00:11:25,200 --> 00:11:27,519
so this is linux is not necessarily slow

313
00:11:27,519 --> 00:11:29,040
but it's you know you you might wonder

314
00:11:29,040 --> 00:11:30,399
if it's really as fast as

315
00:11:30,399 --> 00:11:32,880
um it could possibly be for any given

316
00:11:32,880 --> 00:11:34,320
situation

317
00:11:34,320 --> 00:11:36,560
um and so if you think about i mean all

318
00:11:36,560 --> 00:11:37,440
you you think

319
00:11:37,440 --> 00:11:39,680
if you think about almost anything in

320
00:11:39,680 --> 00:11:41,760
linux or xb6

321
00:11:41,760 --> 00:11:42,959
you know you may wonder whether it

322
00:11:42,959 --> 00:11:44,560
really needs to do everything it does so

323
00:11:44,560 --> 00:11:46,640
for example if you write a single byte

324
00:11:46,640 --> 00:11:47,600
over a pipe

325
00:11:47,600 --> 00:11:49,839
from one process to another boy there's

326
00:11:49,839 --> 00:11:51,920
a lot of instructions that get executed

327
00:11:51,920 --> 00:11:54,480
even in xv6 which is a simple kernel

328
00:11:54,480 --> 00:11:55,360
right there's

329
00:11:55,360 --> 00:11:58,160
buffering you know there's locking

330
00:11:58,160 --> 00:12:00,320
there's could be a sleep and a wake up

331
00:12:00,320 --> 00:12:01,760
during a pipe read and write there's

332
00:12:01,760 --> 00:12:03,440
maybe a scheduling may

333
00:12:03,440 --> 00:12:05,680
call to the scheduler or contact switch

334
00:12:05,680 --> 00:12:07,519
that's a lot of stuff that's

335
00:12:07,519 --> 00:12:10,880
maybe not necessarily

336
00:12:10,880 --> 00:12:12,160
the absolute minimum that would be

337
00:12:12,160 --> 00:12:14,000
required to move a byte from

338
00:12:14,000 --> 00:12:17,829
one process to another

339
00:12:17,839 --> 00:12:19,440
another potential problem with these big

340
00:12:19,440 --> 00:12:21,440
kernels is that

341
00:12:21,440 --> 00:12:23,839
they because they're so big and they

342
00:12:23,839 --> 00:12:25,680
sort of intentionally

343
00:12:25,680 --> 00:12:28,639
bite off some very sophisticated

344
00:12:28,639 --> 00:12:29,680
abstractions

345
00:12:29,680 --> 00:12:30,880
they tend to have a lot of design

346
00:12:30,880 --> 00:12:33,360
decisions kind of baked into the kernel

347
00:12:33,360 --> 00:12:37,839
um so you know in ways that you can't

348
00:12:37,839 --> 00:12:39,200
even if you disagree with them you can't

349
00:12:39,200 --> 00:12:39,680
really

350
00:12:39,680 --> 00:12:41,360
you know tough luck like applications

351
00:12:41,360 --> 00:12:43,040
just have to have to live with it

352
00:12:43,040 --> 00:12:47,509
so

353
00:12:47,519 --> 00:12:49,120
you know as a as opposed to you men in

354
00:12:49,120 --> 00:12:50,240
some fantasy world maybe the

355
00:12:50,240 --> 00:12:51,519
applications could

356
00:12:51,519 --> 00:12:53,600
make a lot more of the decisions so you

357
00:12:53,600 --> 00:12:57,829
know some examples of things where

358
00:12:57,839 --> 00:13:02,079
you may just you may be bummed out by

359
00:13:02,079 --> 00:13:05,279
the way the api is designed for example

360
00:13:05,279 --> 00:13:08,079
in uh in unix you can wait for a process

361
00:13:08,079 --> 00:13:09,519
your own children you know if you fork

362
00:13:09,519 --> 00:13:10,639
you can then wait for your children but

363
00:13:10,639 --> 00:13:12,160
you can't wait for some other process

364
00:13:12,160 --> 00:13:13,519
and you know maybe you want to wait for

365
00:13:13,519 --> 00:13:15,839
a grandchild or an unrelated process but

366
00:13:15,839 --> 00:13:17,040
that's just not an option

367
00:13:17,040 --> 00:13:19,120
just not the way things work even if it

368
00:13:19,120 --> 00:13:21,680
would be convenient for you

369
00:13:21,680 --> 00:13:24,560
maybe you want to change the way another

370
00:13:24,560 --> 00:13:26,560
processes address space is set up you

371
00:13:26,560 --> 00:13:27,040
know maybe

372
00:13:27,040 --> 00:13:29,920
call a map on behalf of another process

373
00:13:29,920 --> 00:13:31,200
that you're controlling but

374
00:13:31,200 --> 00:13:34,000
again that's just not an option you can

375
00:13:34,000 --> 00:13:34,480
map

376
00:13:34,480 --> 00:13:35,920
change your own address space but not

377
00:13:35,920 --> 00:13:37,760
change other other processes address

378
00:13:37,760 --> 00:13:38,320
space

379
00:13:38,320 --> 00:13:40,399
maybe you're a database and you know you

380
00:13:40,399 --> 00:13:43,519
have b tree indexes on the disk

381
00:13:43,519 --> 00:13:45,199
and you may know a lot about it the

382
00:13:45,199 --> 00:13:46,639
fastest way to layout a b

383
00:13:46,639 --> 00:13:48,720
tree on a disk but if you're reading and

384
00:13:48,720 --> 00:13:50,320
writing files with the file system

385
00:13:50,320 --> 00:13:52,639
the file system has no idea that you're

386
00:13:52,639 --> 00:13:54,560
actually writing a b tree or

387
00:13:54,560 --> 00:13:56,240
how a b tree ought to be laid out on a

388
00:13:56,240 --> 00:13:59,040
disk for fastest access

389
00:13:59,040 --> 00:14:00,240
and so if you're a database you're going

390
00:14:00,240 --> 00:14:02,000
to be kind of bummed you know maybe

391
00:14:02,000 --> 00:14:03,120
you're happy that you have this file

392
00:14:03,120 --> 00:14:04,560
system at your disposal

393
00:14:04,560 --> 00:14:05,920
but it doesn't really do what you want

394
00:14:05,920 --> 00:14:07,760
it to do um

395
00:14:07,760 --> 00:14:09,920
and that's the sense in which uh design

396
00:14:09,920 --> 00:14:11,440
decisions are often baked into big

397
00:14:11,440 --> 00:14:13,199
kernels

398
00:14:13,199 --> 00:14:16,560
and finally a specific uh

399
00:14:16,560 --> 00:14:20,880
sort of issue that um

400
00:14:20,880 --> 00:14:23,519
sort of came up in a big way in the

401
00:14:23,519 --> 00:14:24,959
1990s probably

402
00:14:24,959 --> 00:14:30,240
um it's a notion of extensibility uh

403
00:14:30,240 --> 00:14:31,920
that it might be desirable for programs

404
00:14:31,920 --> 00:14:33,440
to be able to change the kernel on the

405
00:14:33,440 --> 00:14:35,199
fly like to be able to download new code

406
00:14:35,199 --> 00:14:36,399
into the kernel or change the way it

407
00:14:36,399 --> 00:14:37,839
operates or something

408
00:14:37,839 --> 00:14:40,160
um in order to do things like have

409
00:14:40,160 --> 00:14:42,399
databases be able to control the

410
00:14:42,399 --> 00:14:45,920
layout of data on the disk um

411
00:14:45,920 --> 00:14:48,959
and uh at least

412
00:14:48,959 --> 00:14:51,360
in in decades past monolithic kernels

413
00:14:51,360 --> 00:14:53,120
tended not

414
00:14:53,120 --> 00:14:55,040
to have any particular features that

415
00:14:55,040 --> 00:14:56,720
helped with this kind of extensibility

416
00:14:56,720 --> 00:14:57,440
you're just

417
00:14:57,440 --> 00:15:01,430
stuck with whatever the kernel did

418
00:15:01,440 --> 00:15:05,199
okay so these were sort of

419
00:15:05,199 --> 00:15:07,199
problems in the back of people's minds

420
00:15:07,199 --> 00:15:08,880
that

421
00:15:08,880 --> 00:15:11,199
led them to think about other kinds of

422
00:15:11,199 --> 00:15:12,800
other ways of designing

423
00:15:12,800 --> 00:15:14,160
other architectures for operating

424
00:15:14,160 --> 00:15:16,720
systems um and there were another number

425
00:15:16,720 --> 00:15:17,680
of

426
00:15:17,680 --> 00:15:19,360
a number of ideas some quite radically

427
00:15:19,360 --> 00:15:21,040
different that people pursued

428
00:15:21,040 --> 00:15:23,279
we're going to talk about one of them a

429
00:15:23,279 --> 00:15:24,480
particularly

430
00:15:24,480 --> 00:15:26,480
popular one today and that's the idea of

431
00:15:26,480 --> 00:15:31,509
microkernels

432
00:15:31,519 --> 00:15:33,519
microkernels although the many of the

433
00:15:33,519 --> 00:15:34,720
ideas are

434
00:15:34,720 --> 00:15:37,600
go back to the beginning of computer

435
00:15:37,600 --> 00:15:39,600
history

436
00:15:39,600 --> 00:15:43,199
they became a sort of hot research topic

437
00:15:43,199 --> 00:15:48,069
starting in maybe the mid to late 1980s

438
00:15:48,079 --> 00:15:52,629
and the big idea

439
00:15:52,639 --> 00:15:55,920
so a micro kernel this this word uh by

440
00:15:55,920 --> 00:15:57,440
the way refers to a sort of general

441
00:15:57,440 --> 00:15:58,720
approach or concept

442
00:15:58,720 --> 00:16:00,320
it doesn't refer to any specific

443
00:16:00,320 --> 00:16:01,839
artifact there were many

444
00:16:01,839 --> 00:16:04,480
uh people who who designed and built

445
00:16:04,480 --> 00:16:05,839
operating systems that

446
00:16:05,839 --> 00:16:08,320
followed the general sort of plan for

447
00:16:08,320 --> 00:16:09,920
micro kernels but you know each of these

448
00:16:09,920 --> 00:16:10,720
projects

449
00:16:10,720 --> 00:16:12,240
ended up designing an operating system

450
00:16:12,240 --> 00:16:13,440
was maybe quite different from the

451
00:16:13,440 --> 00:16:14,000
others

452
00:16:14,000 --> 00:16:17,680
so the key idea was the

453
00:16:17,680 --> 00:16:22,480
tiny kernel um

454
00:16:22,480 --> 00:16:26,240
that supported just ipc

455
00:16:26,240 --> 00:16:29,519
or inter-process communication

456
00:16:29,519 --> 00:16:32,560
and some sort of notion of

457
00:16:32,560 --> 00:16:36,399
threads or tasks um so you have a kernel

458
00:16:36,399 --> 00:16:37,120
that that

459
00:16:37,120 --> 00:16:39,120
you know provides you a notion of sort

460
00:16:39,120 --> 00:16:40,880
of process-like abstraction and a way

461
00:16:40,880 --> 00:16:42,480
for processes to communicate with each

462
00:16:42,480 --> 00:16:43,440
other with this

463
00:16:43,440 --> 00:16:45,839
inner process communication and nothing

464
00:16:45,839 --> 00:16:46,959
else and

465
00:16:46,959 --> 00:16:48,079
everything else you might want to do

466
00:16:48,079 --> 00:16:50,399
like have a file system you'd implement

467
00:16:50,399 --> 00:16:52,880
as a process as a task as a user level

468
00:16:52,880 --> 00:16:53,440
code

469
00:16:53,440 --> 00:16:56,240
not in the kernel at all and so a

470
00:16:56,240 --> 00:17:01,030
picture for that

471
00:17:01,040 --> 00:17:04,000
might be now we're going to use mu for

472
00:17:04,000 --> 00:17:05,919
microkernel we've got the microkernel

473
00:17:05,919 --> 00:17:07,199
down here and we got

474
00:17:07,199 --> 00:17:09,520
user space processes up here and we

475
00:17:09,520 --> 00:17:10,880
might have all the kind of usual

476
00:17:10,880 --> 00:17:13,039
processes run maybe

477
00:17:13,039 --> 00:17:15,839
we're going to run vi my favorite text

478
00:17:15,839 --> 00:17:19,839
editor and my compiler

479
00:17:19,839 --> 00:17:25,350
my windows system

480
00:17:25,360 --> 00:17:27,360
but also up here as user level processes

481
00:17:27,360 --> 00:17:29,600
we're going to have the file system

482
00:17:29,600 --> 00:17:32,480
just as a server process in user space

483
00:17:32,480 --> 00:17:34,160
maybe we're going to have a

484
00:17:34,160 --> 00:17:37,120
disk driver that knows how to talk to my

485
00:17:37,120 --> 00:17:38,320
disk hardware

486
00:17:38,320 --> 00:17:42,950
maybe we'll have a network stack that

487
00:17:42,960 --> 00:17:46,240
knows how to talk talk tcp to my

488
00:17:46,240 --> 00:17:49,280
network interface card maybe we'll have

489
00:17:49,280 --> 00:17:52,000
a user level process that's in charge of

490
00:17:52,000 --> 00:17:52,720
doing

491
00:17:52,720 --> 00:17:56,320
fancy paging tricks like memory mapped

492
00:17:56,320 --> 00:17:57,440
files or

493
00:17:57,440 --> 00:17:59,440
maybe implements copy on right fork or

494
00:17:59,440 --> 00:18:01,520
something

495
00:18:01,520 --> 00:18:04,799
and when my text editor needs to read a

496
00:18:04,799 --> 00:18:05,679
file

497
00:18:05,679 --> 00:18:07,280
it needs to talk to the file system and

498
00:18:07,280 --> 00:18:08,799
so

499
00:18:08,799 --> 00:18:13,350
it's going to send a

500
00:18:13,360 --> 00:18:16,880
um a message via ipc

501
00:18:16,880 --> 00:18:20,000
in our process communication um to the

502
00:18:20,000 --> 00:18:21,600
file system server

503
00:18:21,600 --> 00:18:23,200
which has all the file system code in it

504
00:18:23,200 --> 00:18:24,640
knows about files and directories the

505
00:18:24,640 --> 00:18:26,799
file system of server code may need to

506
00:18:26,799 --> 00:18:28,400
you know talk to the disk so it might

507
00:18:28,400 --> 00:18:30,320
send another sort of disk

508
00:18:30,320 --> 00:18:33,520
reader right to the another ipc to the

509
00:18:33,520 --> 00:18:35,200
disk driver which somehow talks to this

510
00:18:35,200 --> 00:18:36,240
hardware

511
00:18:36,240 --> 00:18:39,200
and this driver may return you know a

512
00:18:39,200 --> 00:18:41,200
disk block to the file server

513
00:18:41,200 --> 00:18:42,720
after it does its thing maybe the file

514
00:18:42,720 --> 00:18:44,240
server finally returns the data you

515
00:18:44,240 --> 00:18:45,840
asked for again by inner process

516
00:18:45,840 --> 00:18:48,080
communication messages

517
00:18:48,080 --> 00:18:51,840
back to my text editor but you know the

518
00:18:51,840 --> 00:18:53,520
the critical thing to notice here is

519
00:18:53,520 --> 00:18:55,919
that the only stuff going down here in

520
00:18:55,919 --> 00:18:57,120
the kernel is support

521
00:18:57,120 --> 00:19:00,559
for these these processes or tasks or

522
00:19:00,559 --> 00:19:02,000
threads or

523
00:19:02,000 --> 00:19:05,039
whatever they might be and um support

524
00:19:05,039 --> 00:19:06,720
for the inner process communication

525
00:19:06,720 --> 00:19:07,679
message passing

526
00:19:07,679 --> 00:19:09,280
and nothing else there's no file system

527
00:19:09,280 --> 00:19:10,720
down here there's no

528
00:19:10,720 --> 00:19:12,720
device drivers necessarily down here in

529
00:19:12,720 --> 00:19:14,240
the kernel there's no

530
00:19:14,240 --> 00:19:16,960
network stack all that stuff is up here

531
00:19:16,960 --> 00:19:17,760
is

532
00:19:17,760 --> 00:19:20,160
more or less ordinary user level

533
00:19:20,160 --> 00:19:23,350
processes

534
00:19:23,360 --> 00:19:26,160
and so they lead you to a very small

535
00:19:26,160 --> 00:19:27,360
kernel with

536
00:19:27,360 --> 00:19:30,880
uh relatively little code optimize like

537
00:19:30,880 --> 00:19:32,480
you can optimize ipc and there's not

538
00:19:32,480 --> 00:19:34,880
much else going on

539
00:19:34,880 --> 00:19:37,679
um and so this this is the kind of

540
00:19:37,679 --> 00:19:38,960
picture we're going to talk about for

541
00:19:38,960 --> 00:19:40,559
the rest of the lecture and

542
00:19:40,559 --> 00:19:41,600
just to give you a taste of kind of

543
00:19:41,600 --> 00:19:43,679
where this ended up um

544
00:19:43,679 --> 00:19:46,480
there are actually still uh microkernels

545
00:19:46,480 --> 00:19:47,280
in use today

546
00:19:47,280 --> 00:19:49,280
and indeed the l4 microkernel which is

547
00:19:49,280 --> 00:19:51,440
the topic of today's paper

548
00:19:51,440 --> 00:19:54,320
turns out to be used um there's many

549
00:19:54,320 --> 00:19:56,400
instances many many instances of l4

550
00:19:56,400 --> 00:19:57,360
running because

551
00:19:57,360 --> 00:19:59,520
it's used in a lot of cell phones to in

552
00:19:59,520 --> 00:20:01,200
the little microcontrollers that control

553
00:20:01,200 --> 00:20:03,280
the cell phone radios

554
00:20:03,280 --> 00:20:05,760
and it's also apparently used in recent

555
00:20:05,760 --> 00:20:06,880
iphones

556
00:20:06,880 --> 00:20:09,600
as the operating system that runs on the

557
00:20:09,600 --> 00:20:10,640
special

558
00:20:10,640 --> 00:20:13,120
dedicated enclave processor in the

559
00:20:13,120 --> 00:20:14,320
iphone that hides

560
00:20:14,320 --> 00:20:17,440
the secret cryptographic keys so there's

561
00:20:17,440 --> 00:20:19,280
a bunch of embedded

562
00:20:19,280 --> 00:20:21,360
where these microkernels have won out is

563
00:20:21,360 --> 00:20:23,520
in little embedded specialized

564
00:20:23,520 --> 00:20:25,679
computer systems you know not not

565
00:20:25,679 --> 00:20:27,039
laptops but

566
00:20:27,039 --> 00:20:30,799
um computers are dedicated to

567
00:20:30,799 --> 00:20:33,039
single specialized tasks where you may

568
00:20:33,039 --> 00:20:34,000
not need the complexity

569
00:20:34,000 --> 00:20:35,840
of linux but you do need some operating

570
00:20:35,840 --> 00:20:37,679
system

571
00:20:37,679 --> 00:20:40,240
and the other thing that's uh the other

572
00:20:40,240 --> 00:20:42,000
sort of final result

573
00:20:42,000 --> 00:20:44,159
from microkernels is that the idea of

574
00:20:44,159 --> 00:20:46,000
user level services with

575
00:20:46,000 --> 00:20:48,320
i with other programs talking to them

576
00:20:48,320 --> 00:20:49,840
from with ipc

577
00:20:49,840 --> 00:20:52,159
that also has made its way into a lot of

578
00:20:52,159 --> 00:20:54,000
operating systems like mac os which i'm

579
00:20:54,000 --> 00:20:56,559
running right now to talk to you um you

580
00:20:56,559 --> 00:20:57,440
know it's a

581
00:20:57,440 --> 00:20:59,039
sort of as well as being a kind of

582
00:20:59,039 --> 00:21:00,880
ordinary monolithic kernel

583
00:21:00,880 --> 00:21:04,480
it also has good support for user level

584
00:21:04,480 --> 00:21:05,200
services

585
00:21:05,200 --> 00:21:08,640
and ipc between unix processes to talk

586
00:21:08,640 --> 00:21:10,480
to these services so

587
00:21:10,480 --> 00:21:14,549
that idea also

588
00:21:14,559 --> 00:21:17,600
was a successful idea and widely adopted

589
00:21:17,600 --> 00:21:19,280
okay so uh this is the basic

590
00:21:19,280 --> 00:21:21,280
architecture um

591
00:21:21,280 --> 00:21:23,120
i'm gonna uh go on and sort of talk

592
00:21:23,120 --> 00:21:24,640
about some ways and

593
00:21:24,640 --> 00:21:26,720
uh reasons why this might be attractive

594
00:21:26,720 --> 00:21:27,840
but first are there any just

595
00:21:27,840 --> 00:21:31,600
kind of high level questions about

596
00:21:31,600 --> 00:21:38,950
what it is i mean by microkernel

597
00:21:38,960 --> 00:21:42,830
okay

598
00:21:42,840 --> 00:21:46,320
so what is it that people were hoping

599
00:21:46,320 --> 00:21:47,280
for

600
00:21:47,280 --> 00:21:50,470
um

601
00:21:50,480 --> 00:21:53,840
when they uh started building like

602
00:21:53,840 --> 00:21:57,600
microkernels so one big motivation

603
00:21:57,600 --> 00:21:58,960
although you wouldn't necessarily see it

604
00:21:58,960 --> 00:22:00,320
written down much is just a sense of

605
00:22:00,320 --> 00:22:01,440
aesthetics

606
00:22:01,440 --> 00:22:03,679
right i think just a lot of people feel

607
00:22:03,679 --> 00:22:05,840
that huge complicated

608
00:22:05,840 --> 00:22:08,960
uh single programs like like a linux

609
00:22:08,960 --> 00:22:09,679
kernel

610
00:22:09,679 --> 00:22:12,320
um are just not very elegant that surely

611
00:22:12,320 --> 00:22:14,400
we can build something that's

612
00:22:14,400 --> 00:22:17,600
much more much much smaller but it's a

613
00:22:17,600 --> 00:22:18,799
much more focused design

614
00:22:18,799 --> 00:22:22,000
isn't such a huge grab bag of uh random

615
00:22:22,000 --> 00:22:23,280
different features

616
00:22:23,280 --> 00:22:26,559
um so i think there was a strong sort of

617
00:22:26,559 --> 00:22:29,360
aesthetic feeling that surely we can do

618
00:22:29,360 --> 00:22:32,870
better than big kernels

619
00:22:32,880 --> 00:22:34,400
but other sort of more specific things

620
00:22:34,400 --> 00:22:36,240
that you might be able to quantify

621
00:22:36,240 --> 00:22:41,280
are something a kernel that's small

622
00:22:41,280 --> 00:22:44,789
might be more secure

623
00:22:44,799 --> 00:22:47,200
all right a few lines of code you have

624
00:22:47,200 --> 00:22:49,280
probably fewer bugs you have

625
00:22:49,280 --> 00:22:51,520
less chance of somebody to be able to

626
00:22:51,520 --> 00:22:53,200
exploit one of those bugs to

627
00:22:53,200 --> 00:22:57,039
break security and in the uh

628
00:22:57,039 --> 00:23:01,120
extreme of that you could imagine an

629
00:23:01,120 --> 00:23:02,640
operating system that's actually

630
00:23:02,640 --> 00:23:07,029
provable provably correct

631
00:23:07,039 --> 00:23:08,480
where somebody can sit down and write a

632
00:23:08,480 --> 00:23:10,480
proof that it the operating system has

633
00:23:10,480 --> 00:23:11,840
no bugs or does exactly what it's

634
00:23:11,840 --> 00:23:13,760
supposed to do and nothing else

635
00:23:13,760 --> 00:23:17,919
and indeed there is a at least one

636
00:23:17,919 --> 00:23:21,280
verified proved correct proved secure

637
00:23:21,280 --> 00:23:24,000
operating system named sel4 which is a

638
00:23:24,000 --> 00:23:26,559
one of the many descendants of the l4

639
00:23:26,559 --> 00:23:30,630
microkernel that um

640
00:23:30,640 --> 00:23:32,880
today's paper but you really you know

641
00:23:32,880 --> 00:23:34,240
people know how to verify

642
00:23:34,240 --> 00:23:36,320
sort of small the medium-sized program

643
00:23:36,320 --> 00:23:37,679
so they don't know how to verify huge

644
00:23:37,679 --> 00:23:38,799
programs unless the fact that

645
00:23:38,799 --> 00:23:40,240
microkernels are small

646
00:23:40,240 --> 00:23:42,159
is sort of a critical ingredient and be

647
00:23:42,159 --> 00:23:45,430
able to prove they're correct

648
00:23:45,440 --> 00:23:47,120
another reason why you might like small

649
00:23:47,120 --> 00:23:49,679
is that a small amount of code is

650
00:23:49,679 --> 00:23:54,470
often a lot easier to optimize than

651
00:23:54,480 --> 00:23:57,679
than a huge program

652
00:23:57,679 --> 00:23:59,600
another reason why small might result in

653
00:23:59,600 --> 00:24:03,120
fast is that you don't have to pay for

654
00:24:03,120 --> 00:24:04,799
a lot of features that you don't use if

655
00:24:04,799 --> 00:24:06,320
your microkernel does hardly anything

656
00:24:06,320 --> 00:24:07,279
then

657
00:24:07,279 --> 00:24:08,480
you're not paying for a lot of features

658
00:24:08,480 --> 00:24:11,510
you're not using

659
00:24:11,520 --> 00:24:15,039
another reason for small is that a small

660
00:24:15,039 --> 00:24:16,320
kernel probably bakes in

661
00:24:16,320 --> 00:24:19,200
far fewer design decisions forces fewer

662
00:24:19,200 --> 00:24:22,480
design decisions on application writers

663
00:24:22,480 --> 00:24:24,159
and so it leaves them more maybe leaves

664
00:24:24,159 --> 00:24:26,159
them more flexible flexibility to make

665
00:24:26,159 --> 00:24:30,549
their own design decisions

666
00:24:30,559 --> 00:24:32,240
so by the way these are all these are

667
00:24:32,240 --> 00:24:34,320
not uh

668
00:24:34,320 --> 00:24:35,760
necessary consequences of the

669
00:24:35,760 --> 00:24:37,440
microkernel approach these are things

670
00:24:37,440 --> 00:24:38,880
that people hoped for and tried to

671
00:24:38,880 --> 00:24:39,520
achieve

672
00:24:39,520 --> 00:24:42,880
by using microkernels another set of

673
00:24:42,880 --> 00:24:44,320
reasons why microkernels seemed

674
00:24:44,320 --> 00:24:46,000
attractive has to do with the fact that

675
00:24:46,000 --> 00:24:49,120
a lot of the code was at user level

676
00:24:49,120 --> 00:24:51,840
um that is a lot of features and

677
00:24:51,840 --> 00:24:52,960
functions that we

678
00:24:52,960 --> 00:24:54,960
sort of have grown used to being inside

679
00:24:54,960 --> 00:24:56,559
the kernel where actually user level

680
00:24:56,559 --> 00:24:57,440
services

681
00:24:57,440 --> 00:25:00,240
so they hope that by sort of breaking

682
00:25:00,240 --> 00:25:01,360
the kernel apart and running the

683
00:25:01,360 --> 00:25:02,720
different parts like

684
00:25:02,720 --> 00:25:05,200
in user-level services like a file

685
00:25:05,200 --> 00:25:06,000
service

686
00:25:06,000 --> 00:25:09,279
pro fires file service server

687
00:25:09,279 --> 00:25:12,640
it might cause the uh

688
00:25:12,640 --> 00:25:15,600
the code to be more modular might sort

689
00:25:15,600 --> 00:25:16,400
of

690
00:25:16,400 --> 00:25:18,320
encourage operating system designers to

691
00:25:18,320 --> 00:25:20,559
split up all these functions into

692
00:25:20,559 --> 00:25:24,240
many separate services and that might

693
00:25:24,240 --> 00:25:27,269
that might be a good thing

694
00:25:27,279 --> 00:25:30,480
user level code is also possibly easier

695
00:25:30,480 --> 00:25:32,240
to modify if steps at user level it's

696
00:25:32,240 --> 00:25:33,360
usually easier to

697
00:25:33,360 --> 00:25:36,640
tweak it or replace it or modify it than

698
00:25:36,640 --> 00:25:38,480
doing the same stuff in the kernel so

699
00:25:38,480 --> 00:25:43,600
maybe it's easier to customize

700
00:25:43,600 --> 00:25:47,039
um putting the uh operating systems at

701
00:25:47,039 --> 00:25:48,640
user level also might make them more

702
00:25:48,640 --> 00:25:50,240
robust

703
00:25:50,240 --> 00:25:52,240
you can we can if the kernel something

704
00:25:52,240 --> 00:25:53,679
goes wrong with the kernel

705
00:25:53,679 --> 00:25:57,360
um you know usually you have to panic

706
00:25:57,360 --> 00:25:58,960
and reboot because

707
00:25:58,960 --> 00:26:01,760
um you know you can't necessarily trust

708
00:26:01,760 --> 00:26:03,279
what's in the kernel anymore if it's had

709
00:26:03,279 --> 00:26:04,640
some bug that maybe causes it to

710
00:26:04,640 --> 00:26:05,760
overwrite

711
00:26:05,760 --> 00:26:08,640
a random part of its data whereas if you

712
00:26:08,640 --> 00:26:10,159
have a bunch of user level services and

713
00:26:10,159 --> 00:26:11,760
one of them malfunctions and

714
00:26:11,760 --> 00:26:14,720
devise by xero or d references a wild

715
00:26:14,720 --> 00:26:15,360
pointer

716
00:26:15,360 --> 00:26:17,360
maybe only that one server will crash

717
00:26:17,360 --> 00:26:18,640
and leaving the rest of the operating

718
00:26:18,640 --> 00:26:19,279
system

719
00:26:19,279 --> 00:26:21,520
intact and maybe you can restart it just

720
00:26:21,520 --> 00:26:23,440
that one server so maybe

721
00:26:23,440 --> 00:26:27,440
user level moving os functionality

722
00:26:27,440 --> 00:26:29,039
to user level processors it might lead

723
00:26:29,039 --> 00:26:31,760
to more robustness this is probably

724
00:26:31,760 --> 00:26:34,960
particularly evident for drivers most

725
00:26:34,960 --> 00:26:38,080
bugs in the kernel are actually hardware

726
00:26:38,080 --> 00:26:39,279
device drivers

727
00:26:39,279 --> 00:26:40,559
if we can manage to move the device

728
00:26:40,559 --> 00:26:42,480
drivers out of the kernel then we might

729
00:26:42,480 --> 00:26:43,760
have many fewer

730
00:26:43,760 --> 00:26:46,960
bugs and crashes in the kernel and a

731
00:26:46,960 --> 00:26:48,400
final advantage that people were

732
00:26:48,400 --> 00:26:50,159
thinking about back then is that

733
00:26:50,159 --> 00:26:52,080
you could emulate or run multiple

734
00:26:52,080 --> 00:26:54,080
operating system personalities on top of

735
00:26:54,080 --> 00:26:55,120
a microkernel

736
00:26:55,120 --> 00:26:56,799
so even though the microkernel does does

737
00:26:56,799 --> 00:26:58,400
hardly anything for you directly

738
00:26:58,400 --> 00:27:00,080
you might be able to run a unix server

739
00:27:00,080 --> 00:27:02,080
or something on top of it

740
00:27:02,080 --> 00:27:05,360
maybe more than one on the same

741
00:27:05,360 --> 00:27:08,710
machine

742
00:27:08,720 --> 00:27:10,159
of course that's what today's paper is

743
00:27:10,159 --> 00:27:13,039
about running a unix

744
00:27:13,039 --> 00:27:15,360
running linux as a service on a

745
00:27:15,360 --> 00:27:16,480
microkernel

746
00:27:16,480 --> 00:27:19,520
these were all the set of things that

747
00:27:19,520 --> 00:27:21,360
people were hoping to be able to

748
00:27:21,360 --> 00:27:24,640
get some traction on by uh looking into

749
00:27:24,640 --> 00:27:27,279
microkernel signs

750
00:27:27,279 --> 00:27:30,559
of course there's some um sort of

751
00:27:30,559 --> 00:27:33,200
puzzles you have to think through some

752
00:27:33,200 --> 00:27:37,669
challenges

753
00:27:37,679 --> 00:27:40,640
uh one challenge if you want to design

754
00:27:40,640 --> 00:27:42,159
your own micro kernel is

755
00:27:42,159 --> 00:27:44,080
actually figuring out you want the api

756
00:27:44,080 --> 00:27:45,840
you want the micro kernel system call

757
00:27:45,840 --> 00:27:46,880
interface to be as

758
00:27:46,880 --> 00:27:48,640
simple as possible because the whole

759
00:27:48,640 --> 00:27:50,159
point was to keep it small

760
00:27:50,159 --> 00:27:52,640
now what is the actual smallest set of

761
00:27:52,640 --> 00:27:53,760
useful

762
00:27:53,760 --> 00:27:56,880
system calls you can get away with um

763
00:27:56,880 --> 00:27:59,360
you know what does it look like so

764
00:27:59,360 --> 00:27:59,919
that's not

765
00:27:59,919 --> 00:28:03,120
particularly clear so we're looking at

766
00:28:03,120 --> 00:28:03,760
the minimum

767
00:28:03,760 --> 00:28:07,669
system call

768
00:28:07,679 --> 00:28:12,230
api

769
00:28:12,240 --> 00:28:14,240
you need these this minimum system call

770
00:28:14,240 --> 00:28:16,320
api it's great if it's simple but you

771
00:28:16,320 --> 00:28:18,000
actually have to be able to build

772
00:28:18,000 --> 00:28:20,240
some pretty sophisticated features out

773
00:28:20,240 --> 00:28:22,960
of your minimum system call api because

774
00:28:22,960 --> 00:28:24,480
even if the kernel doesn't do much you

775
00:28:24,480 --> 00:28:25,840
know in the end you got to be able to

776
00:28:25,840 --> 00:28:26,159
run

777
00:28:26,159 --> 00:28:28,080
programs you got to maybe you're trying

778
00:28:28,080 --> 00:28:30,399
to run unix on top of a micro chrome you

779
00:28:30,399 --> 00:28:31,919
got to be able to do things like fork

780
00:28:31,919 --> 00:28:34,000
and map

781
00:28:34,000 --> 00:28:37,200
so as part of the system call interface

782
00:28:37,200 --> 00:28:40,320
simple low-level system call interface

783
00:28:40,320 --> 00:28:45,750
it has to be powerful enough to support

784
00:28:45,760 --> 00:28:47,600
all the stuff people need to do like

785
00:28:47,600 --> 00:28:49,360
exec

786
00:28:49,360 --> 00:28:52,480
and fork and heck maybe even

787
00:28:52,480 --> 00:28:56,000
copy on right fork or memory mapping

788
00:28:56,000 --> 00:28:58,480
on disk files but all in a kernel that

789
00:28:58,480 --> 00:29:00,720
has no idea about files or a file system

790
00:29:00,720 --> 00:29:01,200
right

791
00:29:01,200 --> 00:29:02,880
it needs to support exec but with a

792
00:29:02,880 --> 00:29:06,480
kernel that knows nothing about files

793
00:29:06,480 --> 00:29:11,029
um we need the rest of the

794
00:29:11,039 --> 00:29:12,799
of the operating system somehow you know

795
00:29:12,799 --> 00:29:15,039
sure the micro kernel may be

796
00:29:15,039 --> 00:29:17,120
very simple but you know now we're sort

797
00:29:17,120 --> 00:29:19,600
of requiring the development of

798
00:29:19,600 --> 00:29:22,159
some set of user level servers that

799
00:29:22,159 --> 00:29:23,360
implement the rest of the operating

800
00:29:23,360 --> 00:29:24,240
system

801
00:29:24,240 --> 00:29:26,320
so we need to that has to get done at

802
00:29:26,320 --> 00:29:27,760
least and may require some

803
00:29:27,760 --> 00:29:30,960
uh just solving design puzzles um

804
00:29:30,960 --> 00:29:33,279
and finally the you know this

805
00:29:33,279 --> 00:29:35,200
arrangement requires a lot of chit chat

806
00:29:35,200 --> 00:29:35,840
over

807
00:29:35,840 --> 00:29:39,279
interprocessor communication over ipc um

808
00:29:39,279 --> 00:29:41,760
so there's going to be great pressure to

809
00:29:41,760 --> 00:29:43,520
make the

810
00:29:43,520 --> 00:29:47,279
you know ipc very fast

811
00:29:47,279 --> 00:29:50,880
so we're going to wonder whether ipc can

812
00:29:50,880 --> 00:29:54,080
be made fast enough uh

813
00:29:54,080 --> 00:29:57,669
to keep microkernels competitive

814
00:29:57,679 --> 00:30:00,159
all right um and just in general

815
00:30:00,159 --> 00:30:01,200
actually the

816
00:30:01,200 --> 00:30:04,720
not just ipc speed but in general the

817
00:30:04,720 --> 00:30:06,159
um there's a lot of reason to believe

818
00:30:06,159 --> 00:30:08,080
that monolithic kernels derive

819
00:30:08,080 --> 00:30:10,159
some performance out of the fact that

820
00:30:10,159 --> 00:30:11,679
they're integrated that the file system

821
00:30:11,679 --> 00:30:12,480
code can

822
00:30:12,480 --> 00:30:14,080
talk to the virtual memory code in the

823
00:30:14,080 --> 00:30:15,679
memory allocation code and

824
00:30:15,679 --> 00:30:17,600
it's all sort of one big happy giant

825
00:30:17,600 --> 00:30:19,600
program

826
00:30:19,600 --> 00:30:21,919
and if you require all those things to

827
00:30:21,919 --> 00:30:23,679
be split out into separate servers or

828
00:30:23,679 --> 00:30:25,120
maybe split between a kernel

829
00:30:25,120 --> 00:30:27,279
and user level there may be fewer

830
00:30:27,279 --> 00:30:29,679
opportunities for optimization by way of

831
00:30:29,679 --> 00:30:32,799
integration and that may or may not

832
00:30:32,799 --> 00:30:37,200
end up hurting performance

833
00:30:37,200 --> 00:30:40,720
all right um so these are sort of

834
00:30:40,720 --> 00:30:41,520
cross-cutting

835
00:30:41,520 --> 00:30:44,799
and hoped-for wins and

836
00:30:44,799 --> 00:30:47,760
sort of challenges that all the many

837
00:30:47,760 --> 00:30:52,950
micro-kernel projects faced

838
00:30:52,960 --> 00:30:55,919
because of today's paper i'm going to

839
00:30:55,919 --> 00:30:56,880
tell you a bunch about

840
00:30:56,880 --> 00:31:00,320
l4 specifically which is

841
00:31:00,320 --> 00:31:03,600
the microkernel that the authors of

842
00:31:03,600 --> 00:31:06,080
today's paper developed and used

843
00:31:06,080 --> 00:31:09,600
um l4 is not

844
00:31:09,600 --> 00:31:12,000
um it's certainly not the earliest

845
00:31:12,000 --> 00:31:13,760
microkernel ever made but it's

846
00:31:13,760 --> 00:31:16,000
one of the sort of early microkernels

847
00:31:16,000 --> 00:31:18,000
that came out of all the work in this

848
00:31:18,000 --> 00:31:20,960
uh starting in the 1980s and it's fairly

849
00:31:20,960 --> 00:31:22,399
representative as far as

850
00:31:22,399 --> 00:31:26,559
uh how it works there's been

851
00:31:26,559 --> 00:31:28,640
it's it's a bit of a moving target it

852
00:31:28,640 --> 00:31:29,600
was the

853
00:31:29,600 --> 00:31:31,200
subject of intense development and

854
00:31:31,200 --> 00:31:33,200
evolution for many years and it's still

855
00:31:33,200 --> 00:31:34,559
going strong

856
00:31:34,559 --> 00:31:36,080
if you look at up on wikipedia you'll

857
00:31:36,080 --> 00:31:38,480
see that there's maybe 15 or 20

858
00:31:38,480 --> 00:31:40,080
different variants of l4 that have kind

859
00:31:40,080 --> 00:31:42,880
of come and gone and some are still here

860
00:31:42,880 --> 00:31:46,159
starting i think in the late 1980s and

861
00:31:46,159 --> 00:31:48,480
i know what i'm going to try to explain

862
00:31:48,480 --> 00:31:50,559
to you is my understanding of how l4

863
00:31:50,559 --> 00:31:51,200
worked

864
00:31:51,200 --> 00:31:54,240
at about the time that today's paper

865
00:31:54,240 --> 00:31:58,950
came out

866
00:31:58,960 --> 00:32:02,399
all right so um

867
00:32:02,399 --> 00:32:05,840
just at a a it's a high level um

868
00:32:05,840 --> 00:32:08,799
the l4 was certainly micro in the sense

869
00:32:08,799 --> 00:32:10,399
that it was actually

870
00:32:10,399 --> 00:32:14,000
is a a small kernel it has only seven

871
00:32:14,000 --> 00:32:16,320
system calls some of them are a little

872
00:32:16,320 --> 00:32:18,080
bit complex but still it only has seven

873
00:32:18,080 --> 00:32:19,039
system calls

874
00:32:19,039 --> 00:32:20,640
whereas today's linux the last time i

875
00:32:20,640 --> 00:32:23,760
counted had in the mid 300s

876
00:32:23,760 --> 00:32:25,679
and even xv6 which is an extremely

877
00:32:25,679 --> 00:32:27,679
simple kernel even xc6 has 21

878
00:32:27,679 --> 00:32:33,350
system calls so l4

879
00:32:33,360 --> 00:32:36,080
is only 7. so by that metric it's simple

880
00:32:36,080 --> 00:32:38,399
it's also not very big

881
00:32:38,399 --> 00:32:41,279
i think as of the time this paper was

882
00:32:41,279 --> 00:32:42,559
written at about

883
00:32:42,559 --> 00:32:45,600
13 000 lines of code um

884
00:32:45,600 --> 00:32:47,760
which is not too much uh xv6 is smaller

885
00:32:47,760 --> 00:32:49,760
than that um

886
00:32:49,760 --> 00:32:51,440
i think xv6 is maybe six or seven

887
00:32:51,440 --> 00:32:52,960
thousand lines of code in the kernel

888
00:32:52,960 --> 00:32:55,039
but still xp6 is very simple as kernels

889
00:32:55,039 --> 00:32:56,880
go it's a l4 not much

890
00:32:56,880 --> 00:32:58,320
more complex than that and this is you

891
00:32:58,320 --> 00:33:00,000
know a tenth or

892
00:33:00,000 --> 00:33:03,120
a 20th or a 30th as big as uh as linux

893
00:33:03,120 --> 00:33:03,519
is

894
00:33:03,519 --> 00:33:07,600
this is pretty small it had only a few

895
00:33:07,600 --> 00:33:10,950
basic abstractions

896
00:33:10,960 --> 00:33:15,120
it had a notion of

897
00:33:15,120 --> 00:33:20,399
what they called tasks or address spaces

898
00:33:20,399 --> 00:33:23,519
um and these more or less correspond to

899
00:33:23,519 --> 00:33:25,679
what we would call a process in unix

900
00:33:25,679 --> 00:33:27,200
it's a

901
00:33:27,200 --> 00:33:29,519
bunch of memories um maps starting at

902
00:33:29,519 --> 00:33:31,200
zero and

903
00:33:31,200 --> 00:33:34,559
um and you're able to execute in here

904
00:33:34,559 --> 00:33:36,960
uh just like in a process one difference

905
00:33:36,960 --> 00:33:38,000
from

906
00:33:38,000 --> 00:33:40,559
xv6 is that there can be multiple

907
00:33:40,559 --> 00:33:42,720
threads

908
00:33:42,720 --> 00:33:48,559
per task and l4 was in charge of

909
00:33:48,559 --> 00:33:50,240
scheduling the multiple threads of

910
00:33:50,240 --> 00:33:54,389
execution within each task

911
00:33:54,399 --> 00:33:56,559
and part of the reason for this is just

912
00:33:56,559 --> 00:33:57,919
that it's very convenient to have

913
00:33:57,919 --> 00:33:59,840
threads as a programming structuring

914
00:33:59,840 --> 00:34:01,760
program structuring tool

915
00:34:01,760 --> 00:34:04,789
and it was also

916
00:34:04,799 --> 00:34:06,320
i don't know if they actually supported

917
00:34:06,320 --> 00:34:08,480
multi-core or multi-processor machines

918
00:34:08,480 --> 00:34:10,320
at the time the paper was written but it

919
00:34:10,320 --> 00:34:12,240
um they may well have

920
00:34:12,240 --> 00:34:14,480
and uh threads are of course just what

921
00:34:14,480 --> 00:34:16,159
you need to be able to harness

922
00:34:16,159 --> 00:34:18,399
multiple cores you know executing in the

923
00:34:18,399 --> 00:34:19,280
same program

924
00:34:19,280 --> 00:34:20,720
so whether there were threads supported

925
00:34:20,720 --> 00:34:22,399
by it by

926
00:34:22,399 --> 00:34:26,629
the l4 kernel

927
00:34:26,639 --> 00:34:29,679
so so l source l4 supported tasks

928
00:34:29,679 --> 00:34:32,800
it knew about tasks i knew about threads

929
00:34:32,800 --> 00:34:36,159
and it also knew about address spaces in

930
00:34:36,159 --> 00:34:37,760
the sense that you could

931
00:34:37,760 --> 00:34:39,919
you could ask tell l4 look here's you

932
00:34:39,919 --> 00:34:41,280
know how i want pages mapped in my

933
00:34:41,280 --> 00:34:43,119
address space

934
00:34:43,119 --> 00:34:46,240
um and the other main thing that l4 knew

935
00:34:46,240 --> 00:34:47,440
about

936
00:34:47,440 --> 00:34:50,480
uh process communication so

937
00:34:50,480 --> 00:34:53,440
that was every thread had an identifier

938
00:34:53,440 --> 00:34:54,879
and one thread could say look i want to

939
00:34:54,879 --> 00:34:56,399
send a message

940
00:34:56,399 --> 00:34:59,599
just some bytes to another thread and

941
00:34:59,599 --> 00:35:03,440
here's this identifier please

942
00:35:03,440 --> 00:35:05,040
please send a message to that other

943
00:35:05,040 --> 00:35:07,750
thread

944
00:35:07,760 --> 00:35:12,230
so these are really the only

945
00:35:12,240 --> 00:35:15,440
task threads address spaces and ipc were

946
00:35:15,440 --> 00:35:16,960
really the only abstractions

947
00:35:16,960 --> 00:35:20,480
the system calls i don't know if i can

948
00:35:20,480 --> 00:35:26,069
be able to list them all but

949
00:35:26,079 --> 00:35:30,240
the system calls were there was a thread

950
00:35:30,240 --> 00:35:34,880
create system call which also

951
00:35:34,880 --> 00:35:37,920
you gave it a address space id and a ask

952
00:35:37,920 --> 00:35:39,520
to create a new thread and

953
00:35:39,520 --> 00:35:40,960
if the address space or task didn't

954
00:35:40,960 --> 00:35:42,720
already exist it would create a new task

955
00:35:42,720 --> 00:35:43,200
for you

956
00:35:43,200 --> 00:35:45,200
so to sort of combine thread and task

957
00:35:45,200 --> 00:35:48,150
creation

958
00:35:48,160 --> 00:35:53,200
there's send and receive

959
00:35:53,200 --> 00:35:56,160
various flavors of send and receive ipc

960
00:35:56,160 --> 00:35:59,760
system calls um

961
00:35:59,760 --> 00:36:03,359
there's a way to map pages into your or

962
00:36:03,359 --> 00:36:07,839
other address spaces so um

963
00:36:07,839 --> 00:36:09,920
you could ask the l4 to change the way

964
00:36:09,920 --> 00:36:11,359
your address space was set up the way

965
00:36:11,359 --> 00:36:12,079
your

966
00:36:12,079 --> 00:36:13,760
page table mappings were set up but you

967
00:36:13,760 --> 00:36:16,800
could also ask lford if you had

968
00:36:16,800 --> 00:36:18,079
the right permissions to go and change

969
00:36:18,079 --> 00:36:20,079
the way another tasks

970
00:36:20,079 --> 00:36:23,440
address space was set up so

971
00:36:23,440 --> 00:36:27,440
and um

972
00:36:27,440 --> 00:36:28,880
this was actually done through the ipc

973
00:36:28,880 --> 00:36:30,720
with spent through the ipc interface you

974
00:36:30,720 --> 00:36:33,119
would send a kind of special ipc message

975
00:36:33,119 --> 00:36:35,359
that the kernel knew about to the target

976
00:36:35,359 --> 00:36:37,680
thread and the kernel would

977
00:36:37,680 --> 00:36:41,359
modify the target threads address space

978
00:36:41,359 --> 00:36:42,720
and this is if you were creating a new

979
00:36:42,720 --> 00:36:44,079
thread this is actually new threads are

980
00:36:44,079 --> 00:36:46,640
created with no memory at all

981
00:36:46,640 --> 00:36:47,760
so if you want to create a thread you

982
00:36:47,760 --> 00:36:49,680
first call the thread create system call

983
00:36:49,680 --> 00:36:51,839
to create the new thread and a task an

984
00:36:51,839 --> 00:36:52,960
address space

985
00:36:52,960 --> 00:36:55,200
and then you send it you make one of

986
00:36:55,200 --> 00:36:57,119
these magic ipc's to send it some of

987
00:36:57,119 --> 00:36:58,720
your own memory

988
00:36:58,720 --> 00:37:00,160
to map some of your own memory that

989
00:37:00,160 --> 00:37:01,760
you've prepared with instructions or

990
00:37:01,760 --> 00:37:02,720
data

991
00:37:02,720 --> 00:37:05,839
to map that memory into the new uh into

992
00:37:05,839 --> 00:37:06,240
the

993
00:37:06,240 --> 00:37:08,480
new task address space and then you send

994
00:37:08,480 --> 00:37:10,240
a special start ipc

995
00:37:10,240 --> 00:37:12,160
to this new task with the program

996
00:37:12,160 --> 00:37:13,520
counter and the stack pointer you want

997
00:37:13,520 --> 00:37:15,040
it to start executing with

998
00:37:15,040 --> 00:37:16,560
it'll start executing and that memory

999
00:37:16,560 --> 00:37:18,480
you've set up at the program calendar

1000
00:37:18,480 --> 00:37:20,839
that you asked it to start at

1001
00:37:20,839 --> 00:37:23,440
um there's a way not through system

1002
00:37:23,440 --> 00:37:24,240
calls

1003
00:37:24,240 --> 00:37:26,240
in fact i don't know how it worked but

1004
00:37:26,240 --> 00:37:27,359
um

1005
00:37:27,359 --> 00:37:29,839
privileged tasks could map device

1006
00:37:29,839 --> 00:37:31,680
hardware

1007
00:37:31,680 --> 00:37:35,119
um you know device control registers

1008
00:37:35,119 --> 00:37:36,000
into their own address

1009
00:37:36,000 --> 00:37:39,910
spaces

1010
00:37:39,920 --> 00:37:41,520
so l4 didn't really know much about

1011
00:37:41,520 --> 00:37:43,520
devices like disks or network interface

1012
00:37:43,520 --> 00:37:44,800
cards but

1013
00:37:44,800 --> 00:37:48,839
user level software could get directly

1014
00:37:48,839 --> 00:37:51,040
at

1015
00:37:51,040 --> 00:37:52,160
you use a level software that

1016
00:37:52,160 --> 00:37:53,680
implemented device drivers that user

1017
00:37:53,680 --> 00:37:55,280
level could get directly at device

1018
00:37:55,280 --> 00:37:57,440
hardware

1019
00:37:57,440 --> 00:38:01,680
there was a way to you could tell l4

1020
00:38:01,680 --> 00:38:05,760
to turn and interrupt um

1021
00:38:05,760 --> 00:38:07,680
any interrupt from any device l4 didn't

1022
00:38:07,680 --> 00:38:10,320
really know which device just turned

1023
00:38:10,320 --> 00:38:14,000
a given interrupt into an ipc message

1024
00:38:14,000 --> 00:38:18,640
so a device driver tasks could

1025
00:38:18,640 --> 00:38:19,760
not just read and write the device

1026
00:38:19,760 --> 00:38:21,599
harder but also tell l4 well anytime

1027
00:38:21,599 --> 00:38:22,720
that device interrupts

1028
00:38:22,720 --> 00:38:25,760
please send me an ipc message to notify

1029
00:38:25,760 --> 00:38:28,630
me at the interrupt

1030
00:38:28,640 --> 00:38:31,680
and finally one task could tell the

1031
00:38:31,680 --> 00:38:32,400
kernel

1032
00:38:32,400 --> 00:38:36,320
to give it notifications of another task

1033
00:38:36,320 --> 00:38:38,480
page faults

1034
00:38:38,480 --> 00:38:42,160
so if this task page faults l4 would

1035
00:38:42,160 --> 00:38:45,680
turn that into a ipc message

1036
00:38:45,680 --> 00:38:48,320
and send it to another designated pager

1037
00:38:48,320 --> 00:38:49,520
task

1038
00:38:49,520 --> 00:38:51,359
uh send the notification the page fault

1039
00:38:51,359 --> 00:38:54,000
to a designated pager task so every task

1040
00:38:54,000 --> 00:38:56,000
had an associated pager task that

1041
00:38:56,000 --> 00:38:57,359
handled its page faults

1042
00:38:57,359 --> 00:38:59,839
and that's the way you know you get

1043
00:38:59,839 --> 00:39:01,040
hooks into the

1044
00:39:01,040 --> 00:39:02,560
page faults in order to implement things

1045
00:39:02,560 --> 00:39:04,880
like copy on write fork or lazy

1046
00:39:04,880 --> 00:39:08,950
allocation

1047
00:39:08,960 --> 00:39:10,480
and that's it for the kernel there's no

1048
00:39:10,480 --> 00:39:12,160
nothing else in l4 there's no file

1049
00:39:12,160 --> 00:39:13,200
system

1050
00:39:13,200 --> 00:39:15,040
l4 didn't itself have support for things

1051
00:39:15,040 --> 00:39:16,800
like fork or exec

1052
00:39:16,800 --> 00:39:19,119
um it didn't have any communication

1053
00:39:19,119 --> 00:39:21,280
beyond these very simple ipc

1054
00:39:21,280 --> 00:39:23,920
like did not pipes enough device drivers

1055
00:39:23,920 --> 00:39:26,400
no networking support nothing

1056
00:39:26,400 --> 00:39:28,560
everything else if you wanted it you

1057
00:39:28,560 --> 00:39:30,560
need to supply as

1058
00:39:30,560 --> 00:39:37,030
user level services

1059
00:39:37,040 --> 00:39:41,599
okay so one thing that uh

1060
00:39:41,599 --> 00:39:45,440
l4 does supply is switching among

1061
00:39:45,440 --> 00:39:48,720
threads l4 would actually do the

1062
00:39:48,720 --> 00:39:51,760
scheduling and context switches in order

1063
00:39:51,760 --> 00:39:54,000
to multiplex a single cpu among multiple

1064
00:39:54,000 --> 00:39:54,640
threads

1065
00:39:54,640 --> 00:39:56,400
and the way it did it you would find

1066
00:39:56,400 --> 00:39:58,800
completely unsurprising

1067
00:39:58,800 --> 00:40:01,839
l4 basically had saved registers

1068
00:40:01,839 --> 00:40:05,119
for every task for every thread when it

1069
00:40:05,119 --> 00:40:06,800
executed a thread the executed

1070
00:40:06,800 --> 00:40:08,640
thread you know would jump into user

1071
00:40:08,640 --> 00:40:10,240
space and switch page tables to that

1072
00:40:10,240 --> 00:40:11,839
thread and that thread will execute for

1073
00:40:11,839 --> 00:40:12,960
a while in user space

1074
00:40:12,960 --> 00:40:14,960
then maybe the timer interrupt would go

1075
00:40:14,960 --> 00:40:16,319
off and that was actually a device

1076
00:40:16,319 --> 00:40:18,640
l4 knew about the timer internet might

1077
00:40:18,640 --> 00:40:20,160
go off after a while

1078
00:40:20,160 --> 00:40:22,400
interrupt into l4 l4 would save this

1079
00:40:22,400 --> 00:40:24,640
tasks user registers in a

1080
00:40:24,640 --> 00:40:28,079
per task an array of like tasks

1081
00:40:28,079 --> 00:40:30,319
or thread structures would save this

1082
00:40:30,319 --> 00:40:31,760
threads

1083
00:40:31,760 --> 00:40:34,720
registers away pick a new task to run in

1084
00:40:34,720 --> 00:40:35,200
a loop

1085
00:40:35,200 --> 00:40:38,079
much like the scheduling loop in xv6

1086
00:40:38,079 --> 00:40:39,520
restore

1087
00:40:39,520 --> 00:40:42,240
this task's registers out from its

1088
00:40:42,240 --> 00:40:44,160
previously saved registers

1089
00:40:44,160 --> 00:40:46,240
switch page tables and then jump into

1090
00:40:46,240 --> 00:40:48,800
this task and execute it for a while

1091
00:40:48,800 --> 00:40:50,880
until the timer interrupt went off or

1092
00:40:50,880 --> 00:40:53,200
until this

1093
00:40:53,200 --> 00:40:55,599
task either yielded i think there's also

1094
00:40:55,599 --> 00:40:57,359
probably a yield system call or

1095
00:40:57,359 --> 00:40:59,440
something like it

1096
00:40:59,440 --> 00:41:02,720
a task could yield a cpu or a task could

1097
00:41:02,720 --> 00:41:06,079
wait to receive an ipc in that case

1098
00:41:06,079 --> 00:41:08,400
l4 would jump back into l4 and alpha

1099
00:41:08,400 --> 00:41:10,079
would save us registers

1100
00:41:10,079 --> 00:41:12,560
switch to a new task and run that task

1101
00:41:12,560 --> 00:41:13,200
so that

1102
00:41:13,200 --> 00:41:18,069
thread switching part of l4 is very um

1103
00:41:18,079 --> 00:41:25,349
be very familiar um

1104
00:41:25,359 --> 00:41:30,470
the um

1105
00:41:30,480 --> 00:41:32,319
i mentioned this before but i just i

1106
00:41:32,319 --> 00:41:34,880
want to uh because it comes up

1107
00:41:34,880 --> 00:41:39,829
i want to um just write here

1108
00:41:39,839 --> 00:41:44,720
this notion of a pager um the uh

1109
00:41:44,720 --> 00:41:48,640
repeat if a process takes a page fault

1110
00:41:48,640 --> 00:41:50,240
traps into the kernel and the kernel

1111
00:41:50,240 --> 00:41:51,920
turns that page fault into an ipc

1112
00:41:51,920 --> 00:41:52,800
message to

1113
00:41:52,800 --> 00:41:55,440
a designated pager task and tells it the

1114
00:41:55,440 --> 00:41:56,480
address

1115
00:41:56,480 --> 00:41:58,960
you know that tells it tells this pager

1116
00:41:58,960 --> 00:42:00,560
task

1117
00:42:00,560 --> 00:42:02,720
which thread faulted and the address it

1118
00:42:02,720 --> 00:42:03,839
faulted on

1119
00:42:03,839 --> 00:42:06,800
um and then the pager task if it wants

1120
00:42:06,800 --> 00:42:08,000
to say implement

1121
00:42:08,000 --> 00:42:10,160
lazy allocation you know maybe this

1122
00:42:10,160 --> 00:42:11,119
thread

1123
00:42:11,119 --> 00:42:12,640
wrote read or write some memory that

1124
00:42:12,640 --> 00:42:14,240
wasn't allocated yet but it

1125
00:42:14,240 --> 00:42:16,560
think that it sort of has to be lazily

1126
00:42:16,560 --> 00:42:17,440
allocated

1127
00:42:17,440 --> 00:42:19,280
its pager task would then be in charge

1128
00:42:19,280 --> 00:42:20,960
of allocating some memory from

1129
00:42:20,960 --> 00:42:24,640
l4 um sending one of these special

1130
00:42:24,640 --> 00:42:28,000
ipc's uh the cause

1131
00:42:28,000 --> 00:42:31,119
mem that caused the memory to be mapped

1132
00:42:31,119 --> 00:42:32,800
into this task and then

1133
00:42:32,800 --> 00:42:35,599
sending an ipc to resume execution

1134
00:42:35,599 --> 00:42:37,200
inside this thread

1135
00:42:37,200 --> 00:42:39,680
um so there was this notion of page or

1136
00:42:39,680 --> 00:42:40,960
task to implement all this

1137
00:42:40,960 --> 00:42:43,280
all the stuff that xv6 or linux

1138
00:42:43,280 --> 00:42:44,000
implements in

1139
00:42:44,000 --> 00:42:45,839
page fault handlers like you could

1140
00:42:45,839 --> 00:42:47,599
implement copy on the right fork with

1141
00:42:47,599 --> 00:42:48,000
this

1142
00:42:48,000 --> 00:42:52,079
if you liked or memory mapped files all

1143
00:42:52,079 --> 00:42:53,680
using one of these pager tags so they

1144
00:42:53,680 --> 00:42:56,079
were sort of

1145
00:42:56,079 --> 00:42:59,200
powerful user level way to

1146
00:42:59,200 --> 00:43:01,839
play tricks with uh driven by page

1147
00:43:01,839 --> 00:43:03,599
faults

1148
00:43:03,599 --> 00:43:05,440
and so this is an example and one of

1149
00:43:05,440 --> 00:43:07,200
many examples in which

1150
00:43:07,200 --> 00:43:09,280
a micro kernel like l4 might have been

1151
00:43:09,280 --> 00:43:10,480
quite a bit more

1152
00:43:10,480 --> 00:43:12,319
flexible for user programs than a

1153
00:43:12,319 --> 00:43:14,240
conventional kernel like if you just

1154
00:43:14,240 --> 00:43:15,680
if you think linux ought to do some

1155
00:43:15,680 --> 00:43:18,400
extra thing like maybe

1156
00:43:18,400 --> 00:43:20,880
you know some you know if linux didn't

1157
00:43:20,880 --> 00:43:22,560
already have copy on right fork and you

1158
00:43:22,560 --> 00:43:24,480
wanted to have copy on right fork

1159
00:43:24,480 --> 00:43:25,920
you know you really can't implement that

1160
00:43:25,920 --> 00:43:28,079
in linux without modifying the kernel

1161
00:43:28,079 --> 00:43:30,079
there's no way to write portable code

1162
00:43:30,079 --> 00:43:31,839
portable user level code

1163
00:43:31,839 --> 00:43:33,599
for linux that could implement something

1164
00:43:33,599 --> 00:43:36,000
like copy on right fork

1165
00:43:36,000 --> 00:43:38,880
um so i'm not that's not quite true but

1166
00:43:38,880 --> 00:43:40,960
it will be very difficult whereas

1167
00:43:40,960 --> 00:43:43,280
um in l4 it's relatively straightforward

1168
00:43:43,280 --> 00:43:45,280
l4 is like completely set up for you to

1169
00:43:45,280 --> 00:43:46,960
be able to write user level code

1170
00:43:46,960 --> 00:43:48,800
that gets the page faults that are

1171
00:43:48,800 --> 00:43:50,160
required to drive

1172
00:43:50,160 --> 00:43:53,280
copy on right fork all in user space

1173
00:43:53,280 --> 00:43:54,319
without having to

1174
00:43:54,319 --> 00:43:58,069
mess with the kernel

1175
00:43:58,079 --> 00:44:02,480
okay so any questions so far about

1176
00:44:02,480 --> 00:44:05,510
how l4 works

1177
00:44:05,520 --> 00:44:07,200
oh sorry can you just clarify the

1178
00:44:07,200 --> 00:44:10,079
difference between a thread and a task

1179
00:44:10,079 --> 00:44:14,640
um yes a a a task

1180
00:44:14,640 --> 00:44:17,760
corresponds to a it's like a process

1181
00:44:17,760 --> 00:44:20,560
in xv6 it has a bunch of memory and an

1182
00:44:20,560 --> 00:44:21,839
address space

1183
00:44:21,839 --> 00:44:26,800
and you can execute user code in it xv6

1184
00:44:26,800 --> 00:44:28,720
if you have a process in xv6 it can only

1185
00:44:28,720 --> 00:44:30,800
there can only be one thread of control

1186
00:44:30,800 --> 00:44:32,880
on a single on you know executing inside

1187
00:44:32,880 --> 00:44:34,319
a process

1188
00:44:34,319 --> 00:44:37,520
in xv6 but in modern operating systems

1189
00:44:37,520 --> 00:44:40,000
and in l4

1190
00:44:40,000 --> 00:44:42,000
in a single process in a single address

1191
00:44:42,000 --> 00:44:43,280
space you could have mult

1192
00:44:43,280 --> 00:44:46,000
if you have multiple cores you can have

1193
00:44:46,000 --> 00:44:47,040
multiple cores

1194
00:44:47,040 --> 00:44:51,680
executing in a single task

1195
00:44:51,680 --> 00:44:54,160
each you know typically always each set

1196
00:44:54,160 --> 00:44:55,440
up with its own stack

1197
00:44:55,440 --> 00:44:58,800
inside that tasks address space and so

1198
00:44:58,800 --> 00:44:59,280
if you

1199
00:44:59,280 --> 00:45:00,640
that means you can for example write a

1200
00:45:00,640 --> 00:45:02,960
single program that can get

1201
00:45:02,960 --> 00:45:05,760
parallel speed up improved performance

1202
00:45:05,760 --> 00:45:08,160
from multi-core hardware by running

1203
00:45:08,160 --> 00:45:10,480
one thread on having multiple threads

1204
00:45:10,480 --> 00:45:11,920
each running on a different core

1205
00:45:11,920 --> 00:45:15,270
thereby getting more work done

1206
00:45:15,280 --> 00:45:21,910
okay i see thank you yes

1207
00:45:21,920 --> 00:45:25,520
okay um so as you can see this is a

1208
00:45:25,520 --> 00:45:27,599
design that relies heavily on

1209
00:45:27,599 --> 00:45:30,640
on ipc because you're going to want to

1210
00:45:30,640 --> 00:45:32,240
talk to your file server the file server

1211
00:45:32,240 --> 00:45:33,599
is going to want to talk to the device

1212
00:45:33,599 --> 00:45:34,079
driver

1213
00:45:34,079 --> 00:45:36,160
server and you're going to have ipc

1214
00:45:36,160 --> 00:45:37,760
messages flying back and forth

1215
00:45:37,760 --> 00:45:39,839
for every system call for every page

1216
00:45:39,839 --> 00:45:41,440
fault for every device interrupt

1217
00:45:41,440 --> 00:45:44,839
the ibc system just has to be fast

1218
00:45:44,839 --> 00:45:47,200
however

1219
00:45:47,200 --> 00:45:50,390
and now we're starting to

1220
00:45:50,400 --> 00:45:52,960
sort of talk about a serious potential

1221
00:45:52,960 --> 00:45:54,720
defect in the

1222
00:45:54,720 --> 00:46:04,630
microkernel story

1223
00:46:04,640 --> 00:46:07,599
so first let me show you um a

1224
00:46:07,599 --> 00:46:10,960
straightforward but very slow design

1225
00:46:10,960 --> 00:46:14,319
for ipc patterned off of

1226
00:46:14,319 --> 00:46:16,160
unix pipes and i'm bringing this up

1227
00:46:16,160 --> 00:46:20,470
because some early microkernels

1228
00:46:20,480 --> 00:46:22,079
worked in sort of a similar way to what

1229
00:46:22,079 --> 00:46:23,599
i'm about to show you which turned out

1230
00:46:23,599 --> 00:46:25,359
to be slow

1231
00:46:25,359 --> 00:46:29,920
okay so um let's suppose you have

1232
00:46:29,920 --> 00:46:32,640
uh you know you have two processes we

1233
00:46:32,640 --> 00:46:34,640
got p1

1234
00:46:34,640 --> 00:46:39,910
p1 wants to send a message to p2

1235
00:46:39,920 --> 00:46:41,680
so how should that actually work well

1236
00:46:41,680 --> 00:46:43,599
one possibility is to have

1237
00:46:43,599 --> 00:46:47,040
a send system call and you give send

1238
00:46:47,040 --> 00:46:48,480
system call the id

1239
00:46:48,480 --> 00:46:50,640
of the thread you want to send the

1240
00:46:50,640 --> 00:46:52,720
message to and

1241
00:46:52,720 --> 00:46:56,480
a pointer to the message to the bytes

1242
00:46:56,480 --> 00:46:57,520
maybe

1243
00:46:57,520 --> 00:46:58,880
that you actually want to send to that

1244
00:46:58,880 --> 00:47:00,560
process so this is a system call so

1245
00:47:00,560 --> 00:47:02,240
you're going to jump into the kernel

1246
00:47:02,240 --> 00:47:04,480
um you know maybe we designed this

1247
00:47:04,480 --> 00:47:05,839
patterned after uh

1248
00:47:05,839 --> 00:47:08,079
pipes and xv6 and so you can imagine

1249
00:47:08,079 --> 00:47:09,280
there being a

1250
00:47:09,280 --> 00:47:11,599
buffer of messages waiting you know

1251
00:47:11,599 --> 00:47:13,280
maybe p2 is doing something else right

1252
00:47:13,280 --> 00:47:13,920
now

1253
00:47:13,920 --> 00:47:15,119
maybe it's a server it's serving

1254
00:47:15,119 --> 00:47:16,720
somebody else's request so it's not

1255
00:47:16,720 --> 00:47:18,880
ready to handle your request

1256
00:47:18,880 --> 00:47:20,559
you can imagine maybe a buffer of

1257
00:47:20,559 --> 00:47:23,200
waiting messages

1258
00:47:23,200 --> 00:47:25,119
in the kernel like a pipe buffer and

1259
00:47:25,119 --> 00:47:27,280
when you call send

1260
00:47:27,280 --> 00:47:30,079
it appends your message to this buffer

1261
00:47:30,079 --> 00:47:32,079
waiting for pdu to receive it

1262
00:47:32,079 --> 00:47:35,990
now in fact almost always

1263
00:47:36,000 --> 00:47:38,559
in these systems you rarely just wanted

1264
00:47:38,559 --> 00:47:39,760
to send a message

1265
00:47:39,760 --> 00:47:41,040
you almost always wanted to get a

1266
00:47:41,040 --> 00:47:43,520
response to you wanted an rpc or remote

1267
00:47:43,520 --> 00:47:45,440
procedure call

1268
00:47:45,440 --> 00:47:47,760
operation so in fact p1 would probably

1269
00:47:47,760 --> 00:47:49,839
follow this immediately by a receive to

1270
00:47:49,839 --> 00:47:52,160
try to get the response back

1271
00:47:52,160 --> 00:47:54,720
but in general let's just imagine we're

1272
00:47:54,720 --> 00:47:56,559
doing a one-way ipc for the moment so

1273
00:47:56,559 --> 00:47:57,440
send would

1274
00:47:57,440 --> 00:48:00,640
append your message uh to the in kernel

1275
00:48:00,640 --> 00:48:01,839
buffer

1276
00:48:01,839 --> 00:48:04,160
we would have to copy the message bytes

1277
00:48:04,160 --> 00:48:06,160
from user space into this buffer

1278
00:48:06,160 --> 00:48:08,160
and then return and process one can do

1279
00:48:08,160 --> 00:48:09,599
something else like

1280
00:48:09,599 --> 00:48:12,640
maybe prepare to receive the response

1281
00:48:12,640 --> 00:48:16,069
after a while p2

1282
00:48:16,079 --> 00:48:17,599
is going to want to receive the next

1283
00:48:17,599 --> 00:48:19,200
message just going to make the receive

1284
00:48:19,200 --> 00:48:22,390
system call

1285
00:48:22,400 --> 00:48:25,440
and that's going to return the id of the

1286
00:48:25,440 --> 00:48:27,119
sender

1287
00:48:27,119 --> 00:48:31,200
and copy the message into p2's memory

1288
00:48:31,200 --> 00:48:32,800
that's going to take the front message

1289
00:48:32,800 --> 00:48:36,480
off the queue copying the p2's memory

1290
00:48:36,480 --> 00:48:40,790
and then return

1291
00:48:40,800 --> 00:48:46,950
so um

1292
00:48:46,960 --> 00:48:50,150
this is called uh

1293
00:48:50,160 --> 00:48:52,800
there's some words for this uh whose

1294
00:48:52,800 --> 00:48:54,319
opposites you'll see and

1295
00:48:54,319 --> 00:48:56,160
you saw in today's paper this is called

1296
00:48:56,160 --> 00:48:58,800
an asynchronous

1297
00:48:58,800 --> 00:49:02,000
scheme because

1298
00:49:02,000 --> 00:49:03,599
p1 sends a message without having to

1299
00:49:03,599 --> 00:49:04,960
wait for anything it just appends to

1300
00:49:04,960 --> 00:49:07,200
this queue and returns

1301
00:49:07,200 --> 00:49:12,549
and it's called a buffered system

1302
00:49:12,559 --> 00:49:16,079
because the kernel copies each message

1303
00:49:16,079 --> 00:49:18,160
into the buffer into its internal buffer

1304
00:49:18,160 --> 00:49:20,319
on ascend and then later when the

1305
00:49:20,319 --> 00:49:21,839
receive happens it copies the message

1306
00:49:21,839 --> 00:49:22,640
out of the buffer

1307
00:49:22,640 --> 00:49:24,640
into the target so this is asynchronous

1308
00:49:24,640 --> 00:49:27,040
and buffered

1309
00:49:27,040 --> 00:49:29,200
if you're doing a full request response

1310
00:49:29,200 --> 00:49:31,440
pair then p1 is going to call send sends

1311
00:49:31,440 --> 00:49:32,319
going to return

1312
00:49:32,319 --> 00:49:34,800
p1 is then immediately let's assume

1313
00:49:34,800 --> 00:49:35,599
we're going to assume that there's

1314
00:49:35,599 --> 00:49:36,000
really

1315
00:49:36,000 --> 00:49:37,839
sort of two sets of buffers one for each

1316
00:49:37,839 --> 00:49:40,000
direction p1 is immediately going to

1317
00:49:40,000 --> 00:49:42,800
call receive

1318
00:49:42,800 --> 00:49:44,960
um receives gonna wait gonna need to

1319
00:49:44,960 --> 00:49:46,559
wait for something to appear in the

1320
00:49:46,559 --> 00:49:47,839
reply

1321
00:49:47,839 --> 00:49:49,839
buffer so it's gonna have to yield the

1322
00:49:49,839 --> 00:49:51,359
cpu it's gonna have to do something i

1323
00:49:51,359 --> 00:49:54,319
call sleep in xv6 to yield the cpu

1324
00:49:54,319 --> 00:49:56,880
um and on a single cpu system it may

1325
00:49:56,880 --> 00:49:58,720
maybe only at this point

1326
00:49:58,720 --> 00:50:01,599
that p1 gives up the cpu and now p2 can

1327
00:50:01,599 --> 00:50:02,559
run

1328
00:50:02,559 --> 00:50:04,880
and indeed um the hardware in this era

1329
00:50:04,880 --> 00:50:05,920
was almost always

1330
00:50:05,920 --> 00:50:09,680
single core certainly this paper

1331
00:50:09,680 --> 00:50:12,240
is running on single core hardware so p1

1332
00:50:12,240 --> 00:50:12,800
is going to

1333
00:50:12,800 --> 00:50:14,800
it's going to be v1 executing and p1 not

1334
00:50:14,800 --> 00:50:16,880
executing until p1 finally gives up the

1335
00:50:16,880 --> 00:50:18,480
cpu and receive

1336
00:50:18,480 --> 00:50:20,640
waiting for a message to appear here and

1337
00:50:20,640 --> 00:50:22,559
only then will p2 be scheduled maybe

1338
00:50:22,559 --> 00:50:24,160
it'll call receive

1339
00:50:24,160 --> 00:50:26,319
there's people copy the message and then

1340
00:50:26,319 --> 00:50:27,280
p2

1341
00:50:27,280 --> 00:50:31,190
will make its call to send

1342
00:50:31,200 --> 00:50:34,800
um to append its reply

1343
00:50:34,800 --> 00:50:37,599
um and then the send system call would

1344
00:50:37,599 --> 00:50:39,280
return to p2 and at some point

1345
00:50:39,280 --> 00:50:41,119
presumably p2 will give up the cpu

1346
00:50:41,119 --> 00:50:44,079
maybe the timer will go off then p1 1

1347
00:50:44,079 --> 00:50:46,480
will resume execution in the kernel

1348
00:50:46,480 --> 00:50:47,760
see that there's a message there and

1349
00:50:47,760 --> 00:50:50,319
return it back to user space

1350
00:50:50,319 --> 00:50:52,880
and so that means that in this design

1351
00:50:52,880 --> 00:50:55,359
this slow design

1352
00:50:55,359 --> 00:50:57,920
there's in order to have a request and a

1353
00:50:57,920 --> 00:51:01,910
response

1354
00:51:01,920 --> 00:51:05,359
there's four system calls two sends

1355
00:51:05,359 --> 00:51:08,079
and two receives and you know eight user

1356
00:51:08,079 --> 00:51:09,680
kernel crossings each one of which is

1357
00:51:09,680 --> 00:51:12,319
like reasonably expensive

1358
00:51:12,319 --> 00:51:14,880
there's a need to sleep this receive has

1359
00:51:14,880 --> 00:51:15,599
to

1360
00:51:15,599 --> 00:51:18,880
sleep waiting for data to appear

1361
00:51:18,880 --> 00:51:20,720
and there's a full call to the scheduler

1362
00:51:20,720 --> 00:51:22,640
loop and a context switch from

1363
00:51:22,640 --> 00:51:25,760
p1 to p2 i'm in order to make this and

1364
00:51:25,760 --> 00:51:27,599
you know each of these kernel crossings

1365
00:51:27,599 --> 00:51:29,200
and context switches is potentially

1366
00:51:29,200 --> 00:51:30,400
expensive because

1367
00:51:30,400 --> 00:51:32,079
you know every time you cross the kernel

1368
00:51:32,079 --> 00:51:35,200
user boundary you switch page tables

1369
00:51:35,200 --> 00:51:40,559
and that is a has a near certainty of um

1370
00:51:40,559 --> 00:51:43,599
disturbing the cpu caches like changing

1371
00:51:43,599 --> 00:51:44,480
the page table

1372
00:51:44,480 --> 00:51:47,680
probably flushes the ver the tlb

1373
00:51:47,680 --> 00:51:49,440
the virtual memory lookup cache which is

1374
00:51:49,440 --> 00:51:52,319
going to slow things down

1375
00:51:52,319 --> 00:51:56,000
so this is a pretty slow way to go

1376
00:51:56,000 --> 00:51:58,400
it involves a lot of kernel crossings

1377
00:51:58,400 --> 00:52:00,480
message copying of messages between user

1378
00:52:00,480 --> 00:52:01,119
and kernel

1379
00:52:01,119 --> 00:52:04,960
maybe allocation of buffers etc

1380
00:52:04,960 --> 00:52:07,520
but it turns out that for the for this

1381
00:52:07,520 --> 00:52:09,200
stylized case in which you're sending a

1382
00:52:09,200 --> 00:52:10,800
request and you want to get a response

1383
00:52:10,800 --> 00:52:13,040
back

1384
00:52:13,040 --> 00:52:15,119
you can strip this down to a

1385
00:52:15,119 --> 00:52:16,079
considerably

1386
00:52:16,079 --> 00:52:19,119
simpler design i mean in fact this is

1387
00:52:19,119 --> 00:52:21,839
the way l4 worked

1388
00:52:21,839 --> 00:52:25,200
and this was laid out in a famous paper

1389
00:52:25,200 --> 00:52:28,000
called improving ipc by kernel design

1390
00:52:28,000 --> 00:52:30,839
published a few years before today's

1391
00:52:30,839 --> 00:52:34,790
paper

1392
00:52:34,800 --> 00:52:37,040
so it does a couple things differently

1393
00:52:37,040 --> 00:52:39,200
for one thing

1394
00:52:39,200 --> 00:52:42,390
it's synchronous

1395
00:52:42,400 --> 00:52:46,480
that is um

1396
00:52:46,480 --> 00:52:50,150
there's none of this there's no uh

1397
00:52:50,160 --> 00:52:52,000
dropping something off and returning and

1398
00:52:52,000 --> 00:52:54,400
waiting letting the other guy

1399
00:52:54,400 --> 00:52:55,760
letting the other process pick up the

1400
00:52:55,760 --> 00:52:59,040
data uh when it feels like it instead

1401
00:52:59,040 --> 00:53:02,160
send waits for receive and receive waits

1402
00:53:02,160 --> 00:53:04,400
for sand so

1403
00:53:04,400 --> 00:53:06,000
if i'm process one and i want to send

1404
00:53:06,000 --> 00:53:11,190
and i call send

1405
00:53:11,200 --> 00:53:14,079
it it doesn't copy my message into a

1406
00:53:14,079 --> 00:53:14,559
buffer

1407
00:53:14,559 --> 00:53:19,440
it actually p1 will now immediately if

1408
00:53:19,440 --> 00:53:22,640
the p1 send in the l4 kernel waits for

1409
00:53:22,640 --> 00:53:24,480
p2 to call receive

1410
00:53:24,480 --> 00:53:26,880
and if p2 is already in the kernel

1411
00:53:26,880 --> 00:53:28,559
waiting on a call to receive

1412
00:53:28,559 --> 00:53:32,240
well p2 is either already in the kernel

1413
00:53:32,240 --> 00:53:35,920
waiting on a call to receive or

1414
00:53:35,920 --> 00:53:38,480
p1 send wait for it waits for p2's next

1415
00:53:38,480 --> 00:53:39,920
call to receive

1416
00:53:39,920 --> 00:53:44,880
when both have arrived here when p1 is

1417
00:53:44,880 --> 00:53:46,079
in the kernel and it's called the send

1418
00:53:46,079 --> 00:53:47,520
and p2's in the kernel is called to

1419
00:53:47,520 --> 00:53:48,160
receive

1420
00:53:48,160 --> 00:53:52,640
only then does anything happen and

1421
00:53:52,640 --> 00:53:55,680
one reason this is fast is that

1422
00:53:55,680 --> 00:54:00,000
if p2 is already in receive then p1

1423
00:54:00,000 --> 00:54:02,000
when it's executing send in the kernel

1424
00:54:02,000 --> 00:54:03,359
can just

1425
00:54:03,359 --> 00:54:06,559
without a context switch or a general

1426
00:54:06,559 --> 00:54:07,680
purpose scheduling

1427
00:54:07,680 --> 00:54:10,960
can just jump back into user space into

1428
00:54:10,960 --> 00:54:12,000
p2

1429
00:54:12,000 --> 00:54:14,960
as if it was returning from this receive

1430
00:54:14,960 --> 00:54:16,800
right and that's a much faster path to

1431
00:54:16,800 --> 00:54:18,000
the kernel

1432
00:54:18,000 --> 00:54:20,559
than you know saving registers giving up

1433
00:54:20,559 --> 00:54:21,280
the cpu

1434
00:54:21,280 --> 00:54:24,319
calling the scheduler and finding a new

1435
00:54:24,319 --> 00:54:25,200
process to run

1436
00:54:25,200 --> 00:54:28,640
instead p1 send knows that there's a

1437
00:54:28,640 --> 00:54:30,480
waiting receive

1438
00:54:30,480 --> 00:54:34,160
and just sort of immediately

1439
00:54:34,160 --> 00:54:36,799
jumps into p2 as if it was returning

1440
00:54:36,799 --> 00:54:40,789
from receive

1441
00:54:40,799 --> 00:54:42,640
the scheme that they developed is also

1442
00:54:42,640 --> 00:54:47,510
unbuffered

1443
00:54:47,520 --> 00:54:49,119
and it can do that partially because

1444
00:54:49,119 --> 00:54:52,160
it's synchronous

1445
00:54:52,160 --> 00:54:54,400
when both the send and the receive are

1446
00:54:54,400 --> 00:54:56,079
in the kernel

1447
00:54:56,079 --> 00:54:58,559
the message can be you know send is

1448
00:54:58,559 --> 00:55:00,640
sending some message

1449
00:55:00,640 --> 00:55:02,480
the kernel can directly copy the message

1450
00:55:02,480 --> 00:55:03,920
from user space

1451
00:55:03,920 --> 00:55:05,839
to user space without having to first

1452
00:55:05,839 --> 00:55:07,440
copy it into the kernel and then back

1453
00:55:07,440 --> 00:55:08,480
out of the kernel

1454
00:55:08,480 --> 00:55:11,119
because because since you know both

1455
00:55:11,119 --> 00:55:12,400
sides wait for the other

1456
00:55:12,400 --> 00:55:15,359
system call to happen that means that

1457
00:55:15,359 --> 00:55:16,640
they've waited for both

1458
00:55:16,640 --> 00:55:19,040
pointers to be known receive specifies

1459
00:55:19,040 --> 00:55:20,640
where it wants the

1460
00:55:20,640 --> 00:55:23,359
message to be deposited so at this point

1461
00:55:23,359 --> 00:55:24,880
we know both addresses then colonel can

1462
00:55:24,880 --> 00:55:26,240
just do the copy directly

1463
00:55:26,240 --> 00:55:31,030
instead of through the kernel

1464
00:55:31,040 --> 00:55:34,720
for and if the message is

1465
00:55:34,720 --> 00:55:36,640
super small like maybe only a few dozen

1466
00:55:36,640 --> 00:55:38,559
bytes then

1467
00:55:38,559 --> 00:55:40,880
uh it can be passed in registers without

1468
00:55:40,880 --> 00:55:43,359
any copy at all

1469
00:55:43,359 --> 00:55:49,910
um what you might call zero copy

1470
00:55:49,920 --> 00:55:52,799
remember the send only proceeds if p2 is

1471
00:55:52,799 --> 00:55:54,480
already in receive and it

1472
00:55:54,480 --> 00:55:56,799
the send basically jumps directly to p2

1473
00:55:56,799 --> 00:55:59,520
well this code path through the kernel

1474
00:55:59,520 --> 00:56:02,559
takes care to not disturb a bunch of the

1475
00:56:02,559 --> 00:56:04,160
registers

1476
00:56:04,160 --> 00:56:05,680
and that means that p1 can put its

1477
00:56:05,680 --> 00:56:07,520
system call if it's if the message is

1478
00:56:07,520 --> 00:56:08,000
short

1479
00:56:08,000 --> 00:56:10,400
it can put the message in certain

1480
00:56:10,400 --> 00:56:12,000
designated registers the kernel

1481
00:56:12,000 --> 00:56:14,960
guarantees to preserve those registers

1482
00:56:14,960 --> 00:56:18,400
on its way up to p2 and that means that

1483
00:56:18,400 --> 00:56:21,119
when the kernel returns from the receive

1484
00:56:21,119 --> 00:56:22,240
system call but

1485
00:56:22,240 --> 00:56:24,480
as a result of send the contents of

1486
00:56:24,480 --> 00:56:25,280
those

1487
00:56:25,280 --> 00:56:28,559
designated registers hold the message

1488
00:56:28,559 --> 00:56:30,160
and therefore never had to be copied at

1489
00:56:30,160 --> 00:56:31,839
all from memory to memory

1490
00:56:31,839 --> 00:56:33,280
um never had to be moved at all they're

1491
00:56:33,280 --> 00:56:34,559
just sitting right in the registers

1492
00:56:34,559 --> 00:56:35,599
where they can be accessed

1493
00:56:35,599 --> 00:56:39,040
very quickly um

1494
00:56:39,040 --> 00:56:40,079
and this you know of course this only

1495
00:56:40,079 --> 00:56:42,559
works for small messages

1496
00:56:42,559 --> 00:56:45,680
for very large messages l4

1497
00:56:45,680 --> 00:56:48,640
could carry a page mapping in an ipc

1498
00:56:48,640 --> 00:56:49,599
message so for

1499
00:56:49,599 --> 00:56:53,520
for huge messages um

1500
00:56:53,520 --> 00:56:54,960
you know like the result of reading a

1501
00:56:54,960 --> 00:56:56,839
block from a file or something

1502
00:56:56,839 --> 00:57:00,640
um you could just

1503
00:57:00,640 --> 00:57:02,160
send the page and it'll be mapped into

1504
00:57:02,160 --> 00:57:04,160
the target's address space again

1505
00:57:04,160 --> 00:57:08,079
without any copy so this is done through

1506
00:57:08,079 --> 00:57:11,440
page mapping give away the page

1507
00:57:11,440 --> 00:57:14,640
or access to a copy to

1508
00:57:14,640 --> 00:57:18,240
access to permission to share the page

1509
00:57:18,240 --> 00:57:20,799
and so if small messages are fast uh

1510
00:57:20,799 --> 00:57:22,480
huge messages are pretty fast you know

1511
00:57:22,480 --> 00:57:23,839
you still have to adjust the page table

1512
00:57:23,839 --> 00:57:24,880
of the target but

1513
00:57:24,880 --> 00:57:27,359
that's much faster than copying and a

1514
00:57:27,359 --> 00:57:28,400
final trick that

1515
00:57:28,400 --> 00:57:32,480
l4 played was noticing that

1516
00:57:32,480 --> 00:57:34,079
if you're doing an rpc with a request

1517
00:57:34,079 --> 00:57:36,240
and a response there's a very stylized

1518
00:57:36,240 --> 00:57:37,119
pairs

1519
00:57:37,119 --> 00:57:40,319
of um

1520
00:57:40,319 --> 00:57:42,960
uh system calls and you may as well

1521
00:57:42,960 --> 00:57:43,839
combine

1522
00:57:43,839 --> 00:57:45,920
system calls send and receive system

1523
00:57:45,920 --> 00:57:47,359
calls in order to

1524
00:57:47,359 --> 00:57:50,079
reduce kernel crossings so um for the

1525
00:57:50,079 --> 00:57:52,240
special case of rpc which is

1526
00:57:52,240 --> 00:57:55,520
almost always what people are doing

1527
00:57:55,520 --> 00:57:57,760
when they're using ipc there was a call

1528
00:57:57,760 --> 00:58:00,710
system call

1529
00:58:00,720 --> 00:58:05,119
and a call was basically a combined send

1530
00:58:05,119 --> 00:58:08,480
plus receive

1531
00:58:08,480 --> 00:58:10,000
you know but without the return to user

1532
00:58:10,000 --> 00:58:11,760
space and then

1533
00:58:11,760 --> 00:58:13,680
re-entry into kernel space that a pair

1534
00:58:13,680 --> 00:58:15,680
of system

1535
00:58:15,680 --> 00:58:18,640
calls would take um and on the server

1536
00:58:18,640 --> 00:58:21,440
side there was a um

1537
00:58:21,440 --> 00:58:24,480
a single call that would send the reply

1538
00:58:24,480 --> 00:58:28,400
um from one system call and then

1539
00:58:28,400 --> 00:58:31,839
wait for uh the request message

1540
00:58:31,839 --> 00:58:34,720
from anyone for the next system call and

1541
00:58:34,720 --> 00:58:36,640
this is basically ascend of

1542
00:58:36,640 --> 00:58:39,440
one response plus a wait to receive the

1543
00:58:39,440 --> 00:58:40,559
next request

1544
00:58:40,559 --> 00:58:42,160
and this again cut in half the number of

1545
00:58:42,160 --> 00:58:44,559
kernel crossings

1546
00:58:44,559 --> 00:58:47,280
and it turned out that uh the sum of all

1547
00:58:47,280 --> 00:58:48,839
of these

1548
00:58:48,839 --> 00:58:51,680
optimizations now for the kind of short

1549
00:58:51,680 --> 00:58:55,030
rpcs which

1550
00:58:55,040 --> 00:58:57,680
are you know one typical workload all

1551
00:58:57,680 --> 00:59:00,880
this led to a

1552
00:59:00,880 --> 00:59:04,160
20x speed up this is what their paper

1553
00:59:04,160 --> 00:59:05,760
reported 20 x speed up over their

1554
00:59:05,760 --> 00:59:07,599
previous system which was

1555
00:59:07,599 --> 00:59:09,040
presumably a little bit more like what i

1556
00:59:09,040 --> 00:59:12,720
showed in the previous design

1557
00:59:12,720 --> 00:59:16,150
and so this was an impressive

1558
00:59:16,160 --> 00:59:18,000
this paper came out a few years before

1559
00:59:18,000 --> 00:59:19,839
the by the some of the same authors

1560
00:59:19,839 --> 00:59:21,119
but a few years before the people were

1561
00:59:21,119 --> 00:59:23,520
reading and this caused people to

1562
00:59:23,520 --> 00:59:26,319
um view microkernels a little bit more

1563
00:59:26,319 --> 00:59:27,839
favorably

1564
00:59:27,839 --> 00:59:29,359
that the ipc could actually be made

1565
00:59:29,359 --> 00:59:32,079
quite fast

1566
00:59:32,079 --> 00:59:35,680
any questions about um these ipc tricks

1567
00:59:35,680 --> 00:59:36,400
that

1568
00:59:36,400 --> 00:59:39,839
l4 plays yeah i

1569
00:59:39,839 --> 00:59:42,160
i think i missed this but um when is the

1570
00:59:42,160 --> 00:59:42,960
process

1571
00:59:42,960 --> 00:59:45,839
uh sending the or like receiving uh

1572
00:59:45,839 --> 00:59:46,799
messages

1573
00:59:46,799 --> 00:59:50,160
like when is it using that system call

1574
00:59:50,160 --> 00:59:52,880
okay actually so for rpcs for request

1575
00:59:52,880 --> 00:59:54,000
response

1576
00:59:54,000 --> 00:59:57,680
in fact in fact the the

1577
00:59:57,680 --> 01:00:00,880
processes use this pair of of system

1578
01:00:00,880 --> 01:00:01,440
calls

1579
01:00:01,440 --> 01:00:04,720
rather than send and receive so yeah

1580
01:00:04,720 --> 01:00:06,160
call

1581
01:00:06,160 --> 01:00:07,280
you really give it two arguments a

1582
01:00:07,280 --> 01:00:09,680
message you want to send and a place to

1583
01:00:09,680 --> 01:00:11,200
put the response

1584
01:00:11,200 --> 01:00:12,880
and inside the kernel it just combines

1585
01:00:12,880 --> 01:00:14,720
these two now you could view this as a

1586
01:00:14,720 --> 01:00:15,359
bit of a hack

1587
01:00:15,359 --> 01:00:19,920
but um because ipc is so frequent

1588
01:00:19,920 --> 01:00:22,240
it's worth a little bit of hackery in

1589
01:00:22,240 --> 01:00:23,520
order

1590
01:00:23,520 --> 01:00:26,880
to make it be fast and in the diagram um

1591
01:00:26,880 --> 01:00:29,599
up there in the box where um you have p2

1592
01:00:29,599 --> 01:00:30,720
sending that or like

1593
01:00:30,720 --> 01:00:33,760
running the receive system call why what

1594
01:00:33,760 --> 01:00:37,599
what prompted p2 to okay

1595
01:00:37,599 --> 01:00:40,880
in in uh in my rbc world uh we got a we

1596
01:00:40,880 --> 01:00:43,760
have clients

1597
01:00:43,760 --> 01:00:47,520
and they're sending requests to servers

1598
01:00:47,520 --> 01:00:50,960
um and the server is gonna do something

1599
01:00:50,960 --> 01:00:52,480
and reply so

1600
01:00:52,480 --> 01:00:54,799
since p2 is a server we imagine that p2

1601
01:00:54,799 --> 01:00:56,160
is sitting on a while loop

1602
01:00:56,160 --> 01:00:57,920
in which it in which it's going to

1603
01:00:57,920 --> 01:01:00,000
receive the next message from any client

1604
01:01:00,000 --> 01:01:01,440
do a little bit of work to process it

1605
01:01:01,440 --> 01:01:02,960
you know look up some data in a database

1606
01:01:02,960 --> 01:01:04,400
or something and then send a reply

1607
01:01:04,400 --> 01:01:05,839
and go back to the top of the loop and

1608
01:01:05,839 --> 01:01:08,640
wait again so to a first approximation

1609
01:01:08,640 --> 01:01:12,240
we expect p2 to spend all its time

1610
01:01:12,240 --> 01:01:15,040
uh waiting for the next message from

1611
01:01:15,040 --> 01:01:15,760
anyone

1612
01:01:15,760 --> 01:01:19,040
next request from anyone

1613
01:01:19,040 --> 01:01:22,240
and this design really

1614
01:01:22,240 --> 01:01:26,319
um it does kind of rely on p2 always

1615
01:01:26,319 --> 01:01:28,240
at when it's at rest basically sitting

1616
01:01:28,240 --> 01:01:30,880
in the kernel in a receive system call

1617
01:01:30,880 --> 01:01:33,760
waiting for the next request so that the

1618
01:01:33,760 --> 01:01:35,359
next request

1619
01:01:35,359 --> 01:01:39,200
can directly basically return from that

1620
01:01:39,200 --> 01:01:40,400
system call

1621
01:01:40,400 --> 01:01:42,880
right and that's the fast path that's

1622
01:01:42,880 --> 01:01:43,760
super efficient

1623
01:01:43,760 --> 01:01:48,470
in this design cool thank you

1624
01:01:48,480 --> 01:01:50,720
sorry just to follow up on that that

1625
01:01:50,720 --> 01:01:52,160
means that um

1626
01:01:52,160 --> 01:01:54,079
you said that it goes from p1 it like

1627
01:01:54,079 --> 01:01:55,920
returns to p2

1628
01:01:55,920 --> 01:01:58,319
so like to come back you would need to

1629
01:01:58,319 --> 01:01:59,760
send the response

1630
01:01:59,760 --> 01:02:03,119
so that's right we expect p2 to

1631
01:02:03,119 --> 01:02:06,640
um send a response and and that sending

1632
01:02:06,640 --> 01:02:07,599
of the response actually

1633
01:02:07,599 --> 01:02:09,680
follows basically the same code path in

1634
01:02:09,680 --> 01:02:12,480
reverse so that when p2 sends a response

1635
01:02:12,480 --> 01:02:16,240
um that that effectively causes p1 to

1636
01:02:16,240 --> 01:02:16,960
return

1637
01:02:16,960 --> 01:02:20,000
from i mean p1 is actually making this

1638
01:02:20,000 --> 01:02:23,119
call system call so the delivery of p2's

1639
01:02:23,119 --> 01:02:24,480
response

1640
01:02:24,480 --> 01:02:26,640
causes the call the return from this

1641
01:02:26,640 --> 01:02:29,520
from this system call back into p1

1642
01:02:29,520 --> 01:02:32,720
okay i see thank you you know this is a

1643
01:02:32,720 --> 01:02:33,839
little bit different from the usual

1644
01:02:33,839 --> 01:02:35,039
setup where you think of

1645
01:02:35,039 --> 01:02:36,799
you know you jump into the kernel on a

1646
01:02:36,799 --> 01:02:38,240
system call and you execute that system

1647
01:02:38,240 --> 01:02:39,440
call and it returns

1648
01:02:39,440 --> 01:02:41,440
sort of all working on behalf of p1

1649
01:02:41,440 --> 01:02:42,480
which is the way pipe

1650
01:02:42,480 --> 01:02:45,039
read and write work here you know p1 is

1651
01:02:45,039 --> 01:02:46,319
entering the kernel

1652
01:02:46,319 --> 01:02:49,599
you know it's p1 entering the kernel

1653
01:02:49,599 --> 01:02:51,680
you know but the return goes to p2 so

1654
01:02:51,680 --> 01:02:53,599
it's

1655
01:02:53,599 --> 01:03:02,559
kind of odd but very fast

1656
01:03:02,559 --> 01:03:06,319
okay um so this was a big

1657
01:03:06,319 --> 01:03:10,079
uh big sort of uh contribution to people

1658
01:03:10,079 --> 01:03:13,670
uh taking microkernels um

1659
01:03:13,680 --> 01:03:14,720
people's willingness to take

1660
01:03:14,720 --> 01:03:17,280
microkernels seriously as potentially a

1661
01:03:17,280 --> 01:03:18,960
replacement for uh

1662
01:03:18,960 --> 01:03:21,920
monolithic kernels um however you know

1663
01:03:21,920 --> 01:03:22,960
you still have to

1664
01:03:22,960 --> 01:03:24,559
still leave open the question even if

1665
01:03:24,559 --> 01:03:26,319
rpc's fast like where do you get the

1666
01:03:26,319 --> 01:03:27,680
rest of the operating system

1667
01:03:27,680 --> 01:03:29,680
right you know this kernel only has like

1668
01:03:29,680 --> 01:03:31,839
a few percent of all the stuff like file

1669
01:03:31,839 --> 01:03:33,440
systems and network stacks we expect to

1670
01:03:33,440 --> 01:03:34,000
be

1671
01:03:34,000 --> 01:03:36,079
in a full operating system what do we do

1672
01:03:36,079 --> 01:03:37,200
about the rest

1673
01:03:37,200 --> 01:03:39,119
um and this question is usually being

1674
01:03:39,119 --> 01:03:41,200
asked in the context of some

1675
01:03:41,200 --> 01:03:42,799
university research project with

1676
01:03:42,799 --> 01:03:46,870
relatively limited resources

1677
01:03:46,880 --> 01:03:49,520
we need to get all those user level

1678
01:03:49,520 --> 01:03:52,000
services from somewhere

1679
01:03:52,000 --> 01:03:54,160
now actually there are specialized

1680
01:03:54,160 --> 01:03:55,599
applications for which that's not too

1681
01:03:55,599 --> 01:03:57,200
much of a problem if we're

1682
01:03:57,200 --> 01:03:59,680
you know running a you know some sort of

1683
01:03:59,680 --> 01:04:01,119
device you know controller

1684
01:04:01,119 --> 01:04:04,319
maybe the you know ignition

1685
01:04:04,319 --> 01:04:07,280
control system for your car that is you

1686
01:04:07,280 --> 01:04:08,640
know only running a few thousand lines

1687
01:04:08,640 --> 01:04:10,400
of code anyway maybe doesn't need a file

1688
01:04:10,400 --> 01:04:12,240
system

1689
01:04:12,240 --> 01:04:13,599
then we can get away with like very

1690
01:04:13,599 --> 01:04:15,119
little stuff at user level and

1691
01:04:15,119 --> 01:04:16,480
microkernels

1692
01:04:16,480 --> 01:04:17,920
totally make sense for that kind of

1693
01:04:17,920 --> 01:04:20,000
application um but the

1694
01:04:20,000 --> 01:04:22,319
people you know in these projects really

1695
01:04:22,319 --> 01:04:24,079
they had ambitions that oh gosh

1696
01:04:24,079 --> 01:04:26,400
we can totally replace existing

1697
01:04:26,400 --> 01:04:27,760
operating systems and

1698
01:04:27,760 --> 01:04:28,960
they hoped that they could build

1699
01:04:28,960 --> 01:04:30,319
something that people would want to run

1700
01:04:30,319 --> 01:04:30,880
on their

1701
01:04:30,880 --> 01:04:32,799
on their workstations and run on their

1702
01:04:32,799 --> 01:04:34,400
servers and everywhere and just

1703
01:04:34,400 --> 01:04:36,160
replace big monolithic kernels all

1704
01:04:36,160 --> 01:04:38,559
together i'm but for that you know you

1705
01:04:38,559 --> 01:04:40,240
need a real you need all the stuff that

1706
01:04:40,240 --> 01:04:42,160
an operating system does

1707
01:04:42,160 --> 01:04:45,359
um one possibility the most maybe

1708
01:04:45,359 --> 01:04:48,799
sort of philosophically consistent

1709
01:04:48,799 --> 01:04:51,440
possibility would be to you know

1710
01:04:51,440 --> 01:04:52,400
reimplement

1711
01:04:52,400 --> 01:04:54,480
everything you need but in a sort of

1712
01:04:54,480 --> 01:04:55,839
microkernel

1713
01:04:55,839 --> 01:04:58,000
way as lots and lots of different user

1714
01:04:58,000 --> 01:04:59,359
level processes

1715
01:04:59,359 --> 01:05:03,039
um but that's just actually people

1716
01:05:03,039 --> 01:05:04,640
you know there were projects that did

1717
01:05:04,640 --> 01:05:07,760
that but it's a vast amount of work

1718
01:05:07,760 --> 01:05:10,559
and more specifically people really want

1719
01:05:10,559 --> 01:05:11,119
to run

1720
01:05:11,119 --> 01:05:13,520
you know in order for me to use a laptop

1721
01:05:13,520 --> 01:05:14,640
it just has to run

1722
01:05:14,640 --> 01:05:17,280
emacs right and it has to run my

1723
01:05:17,280 --> 01:05:18,400
favorite c compiler

1724
01:05:18,400 --> 01:05:20,079
otherwise i'm just definitely not going

1725
01:05:20,079 --> 01:05:22,559
to switch to your operating system

1726
01:05:22,559 --> 01:05:24,480
and what that meant is that microkernels

1727
01:05:24,480 --> 01:05:25,920
in order for to gain any kind of

1728
01:05:25,920 --> 01:05:27,760
adoption they had to be able to support

1729
01:05:27,760 --> 01:05:29,520
existing applications

1730
01:05:29,520 --> 01:05:31,280
they had to be able to be compatible

1731
01:05:31,280 --> 01:05:33,599
provide an identical

1732
01:05:33,599 --> 01:05:36,160
at least at the system called at the

1733
01:05:36,160 --> 01:05:37,680
higher level

1734
01:05:37,680 --> 01:05:40,960
service api level they had to be totally

1735
01:05:40,960 --> 01:05:42,640
compatible with some exist on operating

1736
01:05:42,640 --> 01:05:44,559
system like unix like linux

1737
01:05:44,559 --> 01:05:46,480
in order for anybody to be willing to

1738
01:05:46,480 --> 01:05:48,480
switch

1739
01:05:48,480 --> 01:05:50,880
so these projects faced a more specific

1740
01:05:50,880 --> 01:05:52,880
problem of how they were going to get

1741
01:05:52,880 --> 01:05:54,480
uh how are they going to attain

1742
01:05:54,480 --> 01:05:56,559
compatibility with

1743
01:05:56,559 --> 01:05:58,079
you know existing applications written

1744
01:05:58,079 --> 01:05:59,680
for linux or maybe windows or

1745
01:05:59,680 --> 01:06:02,839
something but for this project it was

1746
01:06:02,839 --> 01:06:04,319
linux

1747
01:06:04,319 --> 01:06:07,359
and rather than write their own totally

1748
01:06:07,359 --> 01:06:09,119
new set of user level servers that mimic

1749
01:06:09,119 --> 01:06:09,839
linux

1750
01:06:09,839 --> 01:06:12,480
they decided to take the far easier path

1751
01:06:12,480 --> 01:06:14,000
and many projects did this of

1752
01:06:14,000 --> 01:06:18,160
simply directly running an existing

1753
01:06:18,160 --> 01:06:21,280
monolithic kernel as

1754
01:06:21,280 --> 01:06:24,319
on top of their microkernel instead of

1755
01:06:24,319 --> 01:06:25,839
re-implementing some new thing

1756
01:06:25,839 --> 01:06:27,359
and so that's that's exactly what

1757
01:06:27,359 --> 01:06:31,349
today's paper is about

1758
01:06:31,359 --> 01:06:35,430
it has uh

1759
01:06:35,440 --> 01:06:37,760
indeed you know l4 microkernel down at

1760
01:06:37,760 --> 01:06:39,039
the bottom

1761
01:06:39,039 --> 01:06:42,789
um

1762
01:06:42,799 --> 01:06:46,559
but also as like a pretty big server

1763
01:06:46,559 --> 01:06:49,839
they run a pretty full

1764
01:06:49,839 --> 01:06:54,799
linux kernel as a user level process

1765
01:06:54,799 --> 01:06:56,720
and so they may sound a little

1766
01:06:56,720 --> 01:06:58,400
surprising the kernels not use a level

1767
01:06:58,400 --> 01:07:01,119
process right the kernel's the kernel

1768
01:07:01,119 --> 01:07:02,160
you think of it as running on the

1769
01:07:02,160 --> 01:07:04,640
hardware but in fact you know linux

1770
01:07:04,640 --> 01:07:05,359
kernel

1771
01:07:05,359 --> 01:07:08,640
as you can see from running xv6 and qmu

1772
01:07:08,640 --> 01:07:09,039
which is

1773
01:07:09,039 --> 01:07:11,920
running in user space after all a kernel

1774
01:07:11,920 --> 01:07:12,880
is just a program

1775
01:07:12,880 --> 01:07:15,359
and so with some modifications it can be

1776
01:07:15,359 --> 01:07:16,720
made to run

1777
01:07:16,720 --> 01:07:20,079
um at user level and so they had to

1778
01:07:20,079 --> 01:07:21,599
modify linux and

1779
01:07:21,599 --> 01:07:23,920
they took a lot of the low-level stuff

1780
01:07:23,920 --> 01:07:25,839
in linux for example the code in linux

1781
01:07:25,839 --> 01:07:27,200
that expects to be able to directly

1782
01:07:27,200 --> 01:07:28,079
modify page

1783
01:07:28,079 --> 01:07:30,400
tables or read and write processor

1784
01:07:30,400 --> 01:07:31,680
registers

1785
01:07:31,680 --> 01:07:33,039
there was some low-level stuff they had

1786
01:07:33,039 --> 01:07:35,280
to modify so some parts of linux i had

1787
01:07:35,280 --> 01:07:37,760
to change

1788
01:07:37,760 --> 01:07:40,079
in order to convert them to basically

1789
01:07:40,079 --> 01:07:42,480
make system calls or send ipc messages

1790
01:07:42,480 --> 01:07:45,039
through l4 instead of directly get at

1791
01:07:45,039 --> 01:07:47,520
hardware but for the most part they were

1792
01:07:47,520 --> 01:07:49,920
able to directly run without change

1793
01:07:49,920 --> 01:07:51,760
almost all of linux so that means they

1794
01:07:51,760 --> 01:07:53,359
got as part of linux

1795
01:07:53,359 --> 01:07:55,920
you know a file system and a network

1796
01:07:55,920 --> 01:07:57,599
support and all kinds of

1797
01:07:57,599 --> 01:08:00,799
device drivers and

1798
01:08:00,799 --> 01:08:03,359
who knows what that comes with linux

1799
01:08:03,359 --> 01:08:04,799
without having to

1800
01:08:04,799 --> 01:08:08,400
write their own version of this um

1801
01:08:08,400 --> 01:08:11,359
now um in fact the way this was set up

1802
01:08:11,359 --> 01:08:12,319
was that

1803
01:08:12,319 --> 01:08:15,839
linux the linux kernel ran as one

1804
01:08:15,839 --> 01:08:18,960
l4 task and but

1805
01:08:18,960 --> 01:08:22,080
each linux process ran as a separate

1806
01:08:22,080 --> 01:08:25,279
l4 task so when you log into this linux

1807
01:08:25,279 --> 01:08:26,319
and you ask it to run

1808
01:08:26,319 --> 01:08:28,159
a shell for you a terminal window or

1809
01:08:28,159 --> 01:08:29,920
something it's going to fire up an

1810
01:08:29,920 --> 01:08:33,679
l4 task that's going to run that linux

1811
01:08:33,679 --> 01:08:34,560
program

1812
01:08:34,560 --> 01:08:37,920
at user level so there were one task for

1813
01:08:37,920 --> 01:08:39,199
linux and one task

1814
01:08:39,199 --> 01:08:43,199
for each linux process that you fire up

1815
01:08:43,199 --> 01:08:46,400
um under linux and linux and instead of

1816
01:08:46,400 --> 01:08:48,239
directly you know modifying the

1817
01:08:48,239 --> 01:08:52,000
page table that uh that vi

1818
01:08:52,000 --> 01:08:54,319
that the vi process uses linux is going

1819
01:08:54,319 --> 01:08:55,040
to ask

1820
01:08:55,040 --> 01:08:58,239
i'll send the right ipc's to l4 to cause

1821
01:08:58,239 --> 01:08:59,440
l4 to

1822
01:08:59,440 --> 01:09:05,189
change vi's page table

1823
01:09:05,199 --> 01:09:08,239
any questions about the about the basic

1824
01:09:08,239 --> 01:09:14,149
scheme here

1825
01:09:14,159 --> 01:09:17,199
um another thing to uh another thing

1826
01:09:17,199 --> 01:09:18,799
that was changed

1827
01:09:18,799 --> 01:09:22,239
many small things were changed but um a

1828
01:09:22,239 --> 01:09:24,080
specific thing of interest is that

1829
01:09:24,080 --> 01:09:26,880
when vi wants to make a system call so

1830
01:09:26,880 --> 01:09:31,669
if vi doesn't know it's running on l4

1831
01:09:31,679 --> 01:09:34,159
in this scheme it's it's really all

1832
01:09:34,159 --> 01:09:35,679
these programs just think of themselves

1833
01:09:35,679 --> 01:09:36,799
as running on linux

1834
01:09:36,799 --> 01:09:39,600
when vi wants to make a system call um

1835
01:09:39,600 --> 01:09:41,279
you know l4 does not

1836
01:09:41,279 --> 01:09:44,400
support it it's not making an l4 system

1837
01:09:44,400 --> 01:09:46,000
called it's making a linux system call

1838
01:09:46,000 --> 01:09:48,799
so vi system calls like fork there's a

1839
01:09:48,799 --> 01:09:50,239
little library

1840
01:09:50,239 --> 01:09:56,550
basically that was linked into these

1841
01:09:56,560 --> 01:09:59,600
linux processes that would turn calls to

1842
01:09:59,600 --> 01:10:01,280
things like fork or exec

1843
01:10:01,280 --> 01:10:03,920
or pipe or read or write into ipc

1844
01:10:03,920 --> 01:10:05,520
messages

1845
01:10:05,520 --> 01:10:09,840
that it would send to the linux task

1846
01:10:09,840 --> 01:10:11,679
and wait for the response to linux task

1847
01:10:11,679 --> 01:10:13,040
and then return as if

1848
01:10:13,040 --> 01:10:16,159
the system call it returned so

1849
01:10:16,159 --> 01:10:17,520
so these little libraries would turn

1850
01:10:17,520 --> 01:10:20,239
system calls into

1851
01:10:20,239 --> 01:10:22,400
ipc messages to linux and what that

1852
01:10:22,400 --> 01:10:24,400
meant is that if the linux kernel task

1853
01:10:24,400 --> 01:10:25,600
doesn't do anything it

1854
01:10:25,600 --> 01:10:27,840
isn't doing anything else it's sitting

1855
01:10:27,840 --> 01:10:29,360
on a call to receive waiting for the

1856
01:10:29,360 --> 01:10:31,040
next system call request

1857
01:10:31,040 --> 01:10:38,950
ipc from any one of these processes

1858
01:10:38,960 --> 01:10:42,800
and that led to a that leads to a

1859
01:10:42,800 --> 01:10:46,000
significant difference between how this

1860
01:10:46,000 --> 01:10:48,800
linux works and how ordinary linux works

1861
01:10:48,800 --> 01:10:49,199
um

1862
01:10:49,199 --> 01:10:51,280
in ordinary linux just like xv6 there's

1863
01:10:51,280 --> 01:10:52,640
a basically a

1864
01:10:52,640 --> 01:10:55,520
kernel thread that corresponds to every

1865
01:10:55,520 --> 01:10:57,120
user-level process and

1866
01:10:57,120 --> 01:11:00,159
when a program makes a system call it

1867
01:11:00,159 --> 01:11:02,239
the kernel runs a thread on behalf of

1868
01:11:02,239 --> 01:11:04,719
that system call

1869
01:11:04,719 --> 01:11:07,760
and when in ordinary linux when linux

1870
01:11:07,760 --> 01:11:09,360
switches between

1871
01:11:09,360 --> 01:11:12,159
kernel threads that basically implies a

1872
01:11:12,159 --> 01:11:14,960
switch from one process to another

1873
01:11:14,960 --> 01:11:16,000
so there's kind of one-to-one

1874
01:11:16,000 --> 01:11:19,669
correspondence between

1875
01:11:19,679 --> 01:11:21,280
what kernel thread linux kernel is

1876
01:11:21,280 --> 01:11:23,760
running and what process is going to run

1877
01:11:23,760 --> 01:11:25,280
when linux is done

1878
01:11:25,280 --> 01:11:26,960
here that connection's broken they were

1879
01:11:26,960 --> 01:11:28,560
indeed

1880
01:11:28,560 --> 01:11:31,440
in this linux server a kernel thread

1881
01:11:31,440 --> 01:11:34,159
corresponding to each

1882
01:11:34,159 --> 01:11:37,360
i'm sorry let me start again the

1883
01:11:37,360 --> 01:11:40,239
linux kernel server was running in a

1884
01:11:40,239 --> 01:11:41,679
single l4 thread

1885
01:11:41,679 --> 01:11:44,560
so there was only a single sort of

1886
01:11:44,560 --> 01:11:46,640
thread of control executing in linux

1887
01:11:46,640 --> 01:11:52,480
at a time however just as an xv6

1888
01:11:52,480 --> 01:11:55,360
this one thread of control would switch

1889
01:11:55,360 --> 01:11:56,800
you know using a technique very much

1890
01:11:56,800 --> 01:11:58,159
like

1891
01:11:58,159 --> 01:12:01,520
uh xp6's context switch

1892
01:12:01,520 --> 01:12:05,120
could switch between um a kernel thread

1893
01:12:05,120 --> 01:12:07,280
corresponding to each user process

1894
01:12:07,280 --> 01:12:08,560
however

1895
01:12:08,560 --> 01:12:11,600
now which of these these

1896
01:12:11,600 --> 01:12:13,040
kernel threads were implemented purely

1897
01:12:13,040 --> 01:12:15,120
within linux and nothing to do with l4

1898
01:12:15,120 --> 01:12:15,679
threads

1899
01:12:15,679 --> 01:12:18,719
there's only one l4 thread here

1900
01:12:18,719 --> 01:12:20,960
but which user process was running was

1901
01:12:20,960 --> 01:12:23,040
determined by l4

1902
01:12:23,040 --> 01:12:26,080
so in this setup uh linux might be

1903
01:12:26,080 --> 01:12:27,280
serving a request

1904
01:12:27,280 --> 01:12:31,440
from executing the kernel thread for vi

1905
01:12:31,440 --> 01:12:33,920
serving a vi system call at the same

1906
01:12:33,920 --> 01:12:36,080
time that l4 is causing this shell to

1907
01:12:36,080 --> 01:12:37,920
run in user space

1908
01:12:37,920 --> 01:12:41,199
which is very unlike what happens in xv6

1909
01:12:41,199 --> 01:12:42,800
or linux where

1910
01:12:42,800 --> 01:12:45,280
there's a direct correspondence between

1911
01:12:45,280 --> 01:12:46,480
the sort of active

1912
01:12:46,480 --> 01:12:49,600
kernel thread and the corresponding

1913
01:12:49,600 --> 01:12:51,360
use a level thread here l4 is off

1914
01:12:51,360 --> 01:12:53,440
running whatever it feels like

1915
01:12:53,440 --> 01:12:55,280
and these threads in the linux kernel

1916
01:12:55,280 --> 01:12:56,960
are really much more private and are

1917
01:12:56,960 --> 01:12:57,920
just about

1918
01:12:57,920 --> 01:13:00,320
linux being able to um concurrently

1919
01:13:00,320 --> 01:13:01,040
execute

1920
01:13:01,040 --> 01:13:02,800
system calls in different stages of

1921
01:13:02,800 --> 01:13:04,960
execution where maybe

1922
01:13:04,960 --> 01:13:07,040
one process is waiting for the disk it

1923
01:13:07,040 --> 01:13:08,560
needs thread

1924
01:13:08,560 --> 01:13:11,280
linux can run a different processes

1925
01:13:11,280 --> 01:13:12,400
kernel thread to

1926
01:13:12,400 --> 01:13:20,550
serve that process system call um

1927
01:13:20,560 --> 01:13:23,679
so you might wonder uh why

1928
01:13:23,679 --> 01:13:26,080
the this design didn't directly use l4

1929
01:13:26,080 --> 01:13:27,120
threads

1930
01:13:27,120 --> 01:13:30,840
uh to implement the various different

1931
01:13:30,840 --> 01:13:35,040
um uh kernel threads inside linux

1932
01:13:35,040 --> 01:13:37,040
why you know why did linux implement its

1933
01:13:37,040 --> 01:13:39,120
own sort of internal threads package

1934
01:13:39,120 --> 01:13:40,800
instead of using l4 threads

1935
01:13:40,800 --> 01:13:43,920
and the answer was that in those days um

1936
01:13:43,920 --> 01:13:46,719
a they didn't have access to multi-core

1937
01:13:46,719 --> 01:13:48,239
hardware they were using

1938
01:13:48,239 --> 01:13:49,840
single core hardware so there would no

1939
01:13:49,840 --> 01:13:51,840
performance advantage

1940
01:13:51,840 --> 01:13:54,400
um to be able to execute multiple

1941
01:13:54,400 --> 01:13:56,000
threads in the kernel at the same time

1942
01:13:56,000 --> 01:13:58,400
because it was only one core

1943
01:13:58,400 --> 01:14:00,400
so a second thread couldn't be executing

1944
01:14:00,400 --> 01:14:01,840
only one thread could execute it at a

1945
01:14:01,840 --> 01:14:03,760
time due to the hardware

1946
01:14:03,760 --> 01:14:05,600
and the other maybe even more powerful

1947
01:14:05,600 --> 01:14:07,440
reason is that in those days

1948
01:14:07,440 --> 01:14:10,400
the version of linux they were using did

1949
01:14:10,400 --> 01:14:10,719
not

1950
01:14:10,719 --> 01:14:13,600
did not have the support that's required

1951
01:14:13,600 --> 01:14:14,239
to have

1952
01:14:14,239 --> 01:14:16,080
multiple threads multiple cores

1953
01:14:16,080 --> 01:14:17,840
executing inside the kernel at the same

1954
01:14:17,840 --> 01:14:18,480
time

1955
01:14:18,480 --> 01:14:21,280
they were using a uniprocessor linux

1956
01:14:21,280 --> 01:14:23,360
said old enough linux that

1957
01:14:23,360 --> 01:14:25,040
expected only one core in the kernel at

1958
01:14:25,040 --> 01:14:27,360
a time

1959
01:14:27,360 --> 01:14:28,880
it didn't have things like the spin

1960
01:14:28,880 --> 01:14:30,719
locks that xv6 has

1961
01:14:30,719 --> 01:14:34,239
that would allow it to correctly

1962
01:14:34,239 --> 01:14:36,400
execute multiple multiple cores inside

1963
01:14:36,400 --> 01:14:37,760
the kernel so there would have been no

1964
01:14:37,760 --> 01:14:40,080
performance advantage

1965
01:14:40,080 --> 01:14:42,480
in having multiple l4 threads active

1966
01:14:42,480 --> 01:14:43,760
inside the kernel

1967
01:14:43,760 --> 01:14:47,440
um but it would have required adding in

1968
01:14:47,440 --> 01:14:49,840
you know for no performance when adding

1969
01:14:49,840 --> 01:14:50,480
in all the

1970
01:14:50,480 --> 01:14:52,159
spin locks and other stuff is required

1971
01:14:52,159 --> 01:14:53,920
to support concurrency

1972
01:14:53,920 --> 01:14:57,990
so they didn't do it

1973
01:14:58,000 --> 01:15:01,199
a drawback of this arrangement is that

1974
01:15:01,199 --> 01:15:03,679
um in ordinary linux in native linux

1975
01:15:03,679 --> 01:15:05,040
like you would run directly on your

1976
01:15:05,040 --> 01:15:05,760
laptop

1977
01:15:05,760 --> 01:15:08,000
linux has a lot of sophisticated

1978
01:15:08,000 --> 01:15:08,960
scheduling

1979
01:15:08,960 --> 01:15:11,280
machinery that can do things like impose

1980
01:15:11,280 --> 01:15:13,120
priorities on different processes or

1981
01:15:13,120 --> 01:15:13,760
ensure

1982
01:15:13,760 --> 01:15:17,040
various kinds of fairness um

1983
01:15:17,040 --> 01:15:19,280
and that works fine because in a on your

1984
01:15:19,280 --> 01:15:20,480
laptop because linux is

1985
01:15:20,480 --> 01:15:23,760
in control of what process is running on

1986
01:15:23,760 --> 01:15:24,000
each

1987
01:15:24,000 --> 01:15:25,840
core but in this setup linux is not

1988
01:15:25,840 --> 01:15:27,280
controlling that at all

1989
01:15:27,280 --> 01:15:30,320
linux has no control over what what

1990
01:15:30,320 --> 01:15:31,840
process is running

1991
01:15:31,840 --> 01:15:33,679
because it's l4 that does this

1992
01:15:33,679 --> 01:15:35,600
scheduling not linux

1993
01:15:35,600 --> 01:15:37,840
these processes are scheduled by l4 so

1994
01:15:37,840 --> 01:15:39,920
they kind of lost the ability to

1995
01:15:39,920 --> 01:15:43,280
have linux be in charge of uh scheduling

1996
01:15:43,280 --> 01:15:45,760
um you know that's a bit of a defect of

1997
01:15:45,760 --> 01:15:46,880
this the

1998
01:15:46,880 --> 01:15:50,159
although i'm sure later versions of l4

1999
01:15:50,159 --> 01:15:53,679
had some way for linux or something like

2000
01:15:53,679 --> 01:15:55,280
it to be able to tell the l4 scheduler

2001
01:15:55,280 --> 01:15:57,440
oh look please

2002
01:15:57,440 --> 01:15:59,040
give this process higher priority or

2003
01:15:59,040 --> 01:16:00,560
whatever

2004
01:16:00,560 --> 01:16:06,880
so it's a bit awkward

2005
01:16:06,880 --> 01:16:11,510
all right um

2006
01:16:11,520 --> 01:16:14,800
so so they went to all this work

2007
01:16:14,800 --> 01:16:19,120
um to get this going and

2008
01:16:19,120 --> 01:16:21,600
um you should ask yourself you know what

2009
01:16:21,600 --> 01:16:22,159
is the

2010
01:16:22,159 --> 01:16:24,320
what's the takeaway lesson from from

2011
01:16:24,320 --> 01:16:25,760
this paper

2012
01:16:25,760 --> 01:16:30,159
about microkernels um

2013
01:16:30,159 --> 01:16:32,080
now one thing this so for us you know

2014
01:16:32,080 --> 01:16:33,360
this paper has a lot of

2015
01:16:33,360 --> 01:16:34,880
interesting tidbits about how micro

2016
01:16:34,880 --> 01:16:36,560
kernels work and about how linux works

2017
01:16:36,560 --> 01:16:37,360
and how

2018
01:16:37,360 --> 01:16:39,280
you know you set up how you can design a

2019
01:16:39,280 --> 01:16:40,800
system like this which

2020
01:16:40,800 --> 01:16:44,000
may be interesting but um

2021
01:16:44,000 --> 01:16:45,440
in the larger world you know people want

2022
01:16:45,440 --> 01:16:47,840
to want to draw some lessons

2023
01:16:47,840 --> 01:16:50,239
they need to be able to present some

2024
01:16:50,239 --> 01:16:53,270
lessons in this paper

2025
01:16:53,280 --> 01:16:55,280
the paper is not really answering the

2026
01:16:55,280 --> 01:16:58,000
question are microkernels a good idea

2027
01:16:58,000 --> 01:17:00,640
that's not really what's going on here

2028
01:17:00,640 --> 01:17:01,600
the paper

2029
01:17:01,600 --> 01:17:03,840
what the paper is is part of a argument

2030
01:17:03,840 --> 01:17:04,960
about whether

2031
01:17:04,960 --> 01:17:08,000
microkernels have enough performance

2032
01:17:08,000 --> 01:17:11,840
to um to be worth using

2033
01:17:11,840 --> 01:17:15,199
and the reason is that in

2034
01:17:15,199 --> 01:17:17,199
maybe sort of five years or five or ten

2035
01:17:17,199 --> 01:17:18,960
years before this paper came out

2036
01:17:18,960 --> 01:17:20,560
um there was a famous set of

2037
01:17:20,560 --> 01:17:22,159
measurements on one of the predecessor

2038
01:17:22,159 --> 01:17:23,679
microkernels an earlier microkernel

2039
01:17:23,679 --> 01:17:25,040
called mock

2040
01:17:25,040 --> 01:17:27,520
basically running in very much this uh

2041
01:17:27,520 --> 01:17:29,040
configuration

2042
01:17:29,040 --> 01:17:30,800
but a different you know totally

2043
01:17:30,800 --> 01:17:32,719
different design internally but

2044
01:17:32,719 --> 01:17:35,760
kind of the same architecture um this

2045
01:17:35,760 --> 01:17:38,719
um the name of this earlier micro kernel

2046
01:17:38,719 --> 01:17:40,560
project is mock

2047
01:17:40,560 --> 01:17:41,920
there was measurements on mach that

2048
01:17:41,920 --> 01:17:43,600
showed that mach was

2049
01:17:43,600 --> 01:17:46,320
dramatically slower than just ordinary

2050
01:17:46,320 --> 01:17:47,600
unix

2051
01:17:47,600 --> 01:17:49,760
when it was run in this configuration

2052
01:17:49,760 --> 01:17:50,719
and

2053
01:17:50,719 --> 01:17:52,320
you know there are a lot of reasons for

2054
01:17:52,320 --> 01:17:54,880
that having to do with the ipc system

2055
01:17:54,880 --> 01:17:57,120
not being as optimized as you might hope

2056
01:17:57,120 --> 01:17:59,120
there being just sort of more context

2057
01:17:59,120 --> 01:18:00,960
switches and

2058
01:18:00,960 --> 01:18:04,320
um you know user kernel crossings and

2059
01:18:04,320 --> 01:18:05,600
cache misses and whatever you know

2060
01:18:05,600 --> 01:18:07,600
there's a whole lot of reasons why mock

2061
01:18:07,600 --> 01:18:10,719
uh was slow but many people saw those

2062
01:18:10,719 --> 01:18:12,159
benchmark results showing that mock was

2063
01:18:12,159 --> 01:18:13,280
much slower than

2064
01:18:13,280 --> 01:18:14,880
native operating systems and decided

2065
01:18:14,880 --> 01:18:16,719
that microkernels were just

2066
01:18:16,719 --> 01:18:19,280
uh hopeless hopelessly inefficient were

2067
01:18:19,280 --> 01:18:20,960
unlikely ever to be fast enough to be

2068
01:18:20,960 --> 01:18:22,400
competitive and

2069
01:18:22,400 --> 01:18:24,320
you know we should just all use

2070
01:18:24,320 --> 01:18:26,480
monolithic kernels

2071
01:18:26,480 --> 01:18:29,360
today's paper is like an answer

2072
01:18:29,360 --> 01:18:30,239
basically

2073
01:18:30,239 --> 01:18:33,199
um to that argument it's sort of the

2074
01:18:33,199 --> 01:18:34,480
rebuttal to that argument

2075
01:18:34,480 --> 01:18:36,159
and the point of this paper is to show

2076
01:18:36,159 --> 01:18:38,400
that you can build this architecture

2077
01:18:38,400 --> 01:18:40,239
and if you pay enough attention to

2078
01:18:40,239 --> 01:18:41,679
optimizing performance

2079
01:18:41,679 --> 01:18:45,360
you can get competitive performance with

2080
01:18:45,360 --> 01:18:47,199
native operating systems so it's just

2081
01:18:47,199 --> 01:18:48,960
directly running unix

2082
01:18:48,960 --> 01:18:51,600
and therefore you can't dismiss

2083
01:18:51,600 --> 01:18:53,280
microkernels simply on the basis of

2084
01:18:53,280 --> 01:18:54,400
performance

2085
01:18:54,400 --> 01:18:55,679
you know you may not want them for other

2086
01:18:55,679 --> 01:18:59,120
reasons but you can't use performance

2087
01:18:59,120 --> 01:19:02,400
as the reason to reject them

2088
01:19:02,400 --> 01:19:03,760
part of the a huge part of the

2089
01:19:03,760 --> 01:19:06,239
ingredient in

2090
01:19:06,239 --> 01:19:07,520
making that argument is that they made

2091
01:19:07,520 --> 01:19:09,440
the ibc much faster with the techniques

2092
01:19:09,440 --> 01:19:11,440
that i outlined a few minutes ago

2093
01:19:11,440 --> 01:19:14,480
and you can see this i think in um

2094
01:19:14,480 --> 01:19:17,120
in a very simple benchmark in table two

2095
01:19:17,120 --> 01:19:19,040
if you have a copy of the paper with you

2096
01:19:19,040 --> 01:19:22,560
um table two has measurements of

2097
01:19:22,560 --> 01:19:24,239
just native linux running in the

2098
01:19:24,239 --> 01:19:26,000
ordinary way on hardware

2099
01:19:26,000 --> 01:19:28,560
um and on native linux they show that uh

2100
01:19:28,560 --> 01:19:29,760
you know on their hardware and their

2101
01:19:29,760 --> 01:19:30,960
version of linux

2102
01:19:30,960 --> 01:19:33,679
that um a single simple system called

2103
01:19:33,679 --> 01:19:34,560
get pid

2104
01:19:34,560 --> 01:19:38,480
took 1.7 microseconds

2105
01:19:38,480 --> 01:19:41,760
and they also show that the

2106
01:19:41,760 --> 01:19:44,480
sort of equivalent thing in their in l4

2107
01:19:44,480 --> 01:19:45,120
setup

2108
01:19:45,120 --> 01:19:46,800
where you have to send an ipc request

2109
01:19:46,800 --> 01:19:48,239
and get an ipc response

2110
01:19:48,239 --> 01:19:51,120
just for this get process id system call

2111
01:19:51,120 --> 01:19:54,070
that that

2112
01:19:54,080 --> 01:19:57,760
that took uh four microseconds under l4

2113
01:19:57,760 --> 01:20:00,239
linux which is to say twice as long but

2114
01:20:00,239 --> 01:20:02,400
there's sort of twice as much work going

2115
01:20:02,400 --> 01:20:03,600
on because you're doing

2116
01:20:03,600 --> 01:20:05,679
two sets of user kernel crossings

2117
01:20:05,679 --> 01:20:06,800
instead of

2118
01:20:06,800 --> 01:20:10,320
just a single simple system call that is

2119
01:20:10,320 --> 01:20:11,679
they could claim that they had paired

2120
01:20:11,679 --> 01:20:14,639
the expense of these ipc based system

2121
01:20:14,639 --> 01:20:15,120
calls

2122
01:20:15,120 --> 01:20:17,520
down to basically the minimum that is

2123
01:20:17,520 --> 01:20:19,520
twice the cost of a

2124
01:20:19,520 --> 01:20:21,520
system called native linux and therefore

2125
01:20:21,520 --> 01:20:22,960
they were doing roughly as good as

2126
01:20:22,960 --> 01:20:26,390
as you could possibly expect

2127
01:20:26,400 --> 01:20:28,800
now of course that's still their system

2128
01:20:28,800 --> 01:20:30,320
goals are still half as fast as native

2129
01:20:30,320 --> 01:20:33,189
linux

2130
01:20:33,199 --> 01:20:35,600
and you know it's not clear unless you

2131
01:20:35,600 --> 01:20:37,199
did some measurements whether

2132
01:20:37,199 --> 01:20:39,120
system calls taking twice or simple

2133
01:20:39,120 --> 01:20:40,639
system calls taking twice as long as a

2134
01:20:40,639 --> 01:20:41,840
disaster or

2135
01:20:41,840 --> 01:20:44,560
not a problem and in order to show that

2136
01:20:44,560 --> 01:20:46,080
and you know it might be a disaster

2137
01:20:46,080 --> 01:20:47,760
if you do a lot of system calls or might

2138
01:20:47,760 --> 01:20:49,840
be not a problem if

2139
01:20:49,840 --> 01:20:51,920
uh you do relatively few system calls or

2140
01:20:51,920 --> 01:20:53,280
there's a lot of work

2141
01:20:53,280 --> 01:20:55,360
per system call because maybe your

2142
01:20:55,360 --> 01:20:56,719
system calls it more complicated than

2143
01:20:56,719 --> 01:20:59,040
get pid

2144
01:20:59,040 --> 01:21:01,440
and their answer to that in the paper is

2145
01:21:01,440 --> 01:21:02,639
the figure eight

2146
01:21:02,639 --> 01:21:05,520
benchmark using this benchmark called

2147
01:21:05,520 --> 01:21:06,719
aim

2148
01:21:06,719 --> 01:21:08,960
which is just a more it's a benchmark

2149
01:21:08,960 --> 01:21:10,560
that does all kinds of different system

2150
01:21:10,560 --> 01:21:12,000
calls it reads and writes files and

2151
01:21:12,000 --> 01:21:13,520
creates processes or it does all the

2152
01:21:13,520 --> 01:21:15,360
things with the kernel that

2153
01:21:15,360 --> 01:21:17,840
processes do and they basically showed

2154
01:21:17,840 --> 01:21:18,639
in figure eight

2155
01:21:18,639 --> 01:21:21,679
that their setup running a much more

2156
01:21:21,679 --> 01:21:23,760
full application that does

2157
01:21:23,760 --> 01:21:26,480
you know much more than just get pid

2158
01:21:26,480 --> 01:21:26,880
runs

2159
01:21:26,880 --> 01:21:28,960
only a few percent slower than native

2160
01:21:28,960 --> 01:21:29,920
linux

2161
01:21:29,920 --> 01:21:31,760
um and that therefore hopefully you

2162
01:21:31,760 --> 01:21:33,280
could expect that whatever it is you

2163
01:21:33,280 --> 01:21:34,800
wanted to run on a computer

2164
01:21:34,800 --> 01:21:37,679
would run almost as fast under l4 plus

2165
01:21:37,679 --> 01:21:39,440
linux as it does under

2166
01:21:39,440 --> 01:21:41,520
a straight operating system under native

2167
01:21:41,520 --> 01:21:42,480
operating system

2168
01:21:42,480 --> 01:21:44,800
now therefore you know they were

2169
01:21:44,800 --> 01:21:46,800
basically to a first approximation as

2170
01:21:46,800 --> 01:21:49,040
fast

2171
01:21:49,040 --> 01:21:52,080
as just running straight linux and

2172
01:21:52,080 --> 01:21:55,590
therefore you should take them seriously

2173
01:21:55,600 --> 01:21:57,679
okay so that was an impressive result by

2174
01:21:57,679 --> 01:21:58,880
the way this is

2175
01:21:58,880 --> 01:22:01,760
like like somewhat unexpected and um

2176
01:22:01,760 --> 01:22:03,199
cool

2177
01:22:03,199 --> 01:22:06,880
just fast forwarding 20 years um

2178
01:22:06,880 --> 01:22:08,239
where this ended up as i mentioned

2179
01:22:08,239 --> 01:22:10,880
before people actually use l4

2180
01:22:10,880 --> 01:22:12,400
in a bunch of embedded situations

2181
01:22:12,400 --> 01:22:14,159
particularly it's used a lot

2182
01:22:14,159 --> 01:22:17,040
there's many instances of l4 running in

2183
01:22:17,040 --> 01:22:18,560
in smartphones

2184
01:22:18,560 --> 01:22:22,000
um hidden from view but nevertheless

2185
01:22:22,000 --> 01:22:23,600
and all running various kinds of custom

2186
01:22:23,600 --> 01:22:25,360
software not not running

2187
01:22:25,360 --> 01:22:26,480
you know they don't have to have

2188
01:22:26,480 --> 01:22:29,199
compatibility with unix

2189
01:22:29,199 --> 01:22:32,080
in these situations microkernels in

2190
01:22:32,080 --> 01:22:32,480
other

2191
01:22:32,480 --> 01:22:33,760
more general situations like

2192
01:22:33,760 --> 01:22:36,080
workstations or servers never

2193
01:22:36,080 --> 01:22:38,320
really caught on and it's not because

2194
01:22:38,320 --> 01:22:39,920
there's necessarily anything wrong with

2195
01:22:39,920 --> 01:22:40,960
that design

2196
01:22:40,960 --> 01:22:42,800
it's just they would have in order to

2197
01:22:42,800 --> 01:22:45,120
displace some existing

2198
01:22:45,120 --> 01:22:47,840
software your new thing has to be you

2199
01:22:47,840 --> 01:22:48,480
know like

2200
01:22:48,480 --> 01:22:50,320
better so people will be motivated to

2201
01:22:50,320 --> 01:22:52,560
switch and these micro kernels were

2202
01:22:52,560 --> 01:22:53,920
perfectly good

2203
01:22:53,920 --> 01:22:56,960
not certainly elegant um but it was hard

2204
01:22:56,960 --> 01:22:58,560
to put for people to put their finger on

2205
01:22:58,560 --> 01:22:59,360
why it was

2206
01:22:59,360 --> 01:23:00,880
so much better that they should like go

2207
01:23:00,880 --> 01:23:03,120
to the trouble of switching from linux

2208
01:23:03,120 --> 01:23:05,520
or whatever they were running

2209
01:23:05,520 --> 01:23:08,159
this and so it never really caught on

2210
01:23:08,159 --> 01:23:09,760
not necessarily for good reasons

2211
01:23:09,760 --> 01:23:11,920
but because they weren't like

2212
01:23:11,920 --> 01:23:13,600
dramatically better

2213
01:23:13,600 --> 01:23:15,760
on the other hand many ideas from this

2214
01:23:15,760 --> 01:23:16,880
architecture

2215
01:23:16,880 --> 01:23:20,400
had a lasting impact um the

2216
01:23:20,400 --> 01:23:23,520
the people had to work out much more

2217
01:23:23,520 --> 01:23:25,600
interesting and flexible ways of using

2218
01:23:25,600 --> 01:23:28,239
virtual memory in order to support

2219
01:23:28,239 --> 01:23:30,719
operating systems on their microkernels

2220
01:23:30,719 --> 01:23:33,199
and those more sophisticated interfaces

2221
01:23:33,199 --> 01:23:36,080
made their way through things like mmap

2222
01:23:36,080 --> 01:23:37,920
into mainstream operating systems like

2223
01:23:37,920 --> 01:23:39,840
linux

2224
01:23:39,840 --> 01:23:41,760
this idea of running an operating system

2225
01:23:41,760 --> 01:23:43,520
kind of on top

2226
01:23:43,520 --> 01:23:46,719
as a as a server on top of a

2227
01:23:46,719 --> 01:23:48,560
lower level operating system is

2228
01:23:48,560 --> 01:23:50,960
extremely popular today in the form of

2229
01:23:50,960 --> 01:23:53,120
virtual machine monitors which use all

2230
01:23:53,120 --> 01:23:54,320
over the place in

2231
01:23:54,320 --> 01:23:57,520
sort of cloud hosting services

2232
01:23:57,520 --> 01:24:00,840
the desire for extensibility you could

2233
01:24:00,840 --> 01:24:02,480
modify

2234
01:24:02,480 --> 01:24:05,040
a user level service the way that played

2235
01:24:05,040 --> 01:24:05,679
out in

2236
01:24:05,679 --> 01:24:07,520
things like linux was loadable kernel

2237
01:24:07,520 --> 01:24:09,199
modules which allow you to

2238
01:24:09,199 --> 01:24:11,440
load you know modify the way the linux

2239
01:24:11,440 --> 01:24:13,280
kernel works on the fly

2240
01:24:13,280 --> 01:24:15,840
um and of course the sort of client

2241
01:24:15,840 --> 01:24:17,520
server good support for this client

2242
01:24:17,520 --> 01:24:19,120
server architecture

2243
01:24:19,120 --> 01:24:20,800
also made its way into kernels like mac

2244
01:24:20,800 --> 01:24:23,120
os which has good ipc and

2245
01:24:23,120 --> 01:24:26,159
good client server and that's all i have

2246
01:24:26,159 --> 01:24:27,360
to say for this lecture

2247
01:24:27,360 --> 01:24:30,239
um and i'm happy to stick around for

2248
01:24:30,239 --> 01:24:31,280
questions

2249
01:24:31,280 --> 01:24:36,629
thank you

2250
01:24:36,639 --> 01:24:40,159
thank you you're welcome

2251
01:24:40,159 --> 01:24:42,480
oh i wanted to ask so the paper was

2252
01:24:42,480 --> 01:24:43,440
talking

2253
01:24:43,440 --> 01:24:48,000
about virtual about page tables

2254
01:24:48,000 --> 01:24:51,120
at i think 4.2 um

2255
01:24:51,120 --> 01:24:54,950
and it was seeing how

2256
01:24:54,960 --> 01:24:56,719
i think it was kind of what we what you

2257
01:24:56,719 --> 01:24:58,080
mentioned before

2258
01:24:58,080 --> 01:25:01,440
where you said that there is a wrong way

2259
01:25:01,440 --> 01:25:02,639
to do that

2260
01:25:02,639 --> 01:25:05,520
i think might be kind of similar to that

2261
01:25:05,520 --> 01:25:06,000
but

2262
01:25:06,000 --> 01:25:09,440
um if you do this this

2263
01:25:09,440 --> 01:25:12,719
thing that you explain in this in your

2264
01:25:12,719 --> 01:25:14,400
picture now

2265
01:25:14,400 --> 01:25:18,000
uh would it be i guess how how would the

2266
01:25:18,000 --> 01:25:22,159
page tables work in this case well

2267
01:25:22,159 --> 01:25:23,920
are you uh you may be referring to

2268
01:25:23,920 --> 01:25:26,400
section 4.3 the dual space mistake oh

2269
01:25:26,400 --> 01:25:28,639
yes sorry 4.3

2270
01:25:28,639 --> 01:25:30,560
yeah that's a bit of a complicated story

2271
01:25:30,560 --> 01:25:33,040
but the um

2272
01:25:33,040 --> 01:25:36,159
uh let's see the the part of the

2273
01:25:36,159 --> 01:25:38,080
background is the way that linux worked

2274
01:25:38,080 --> 01:25:40,800
in those days and indeed until recently

2275
01:25:40,800 --> 01:25:43,920
is that the when you're running at user

2276
01:25:43,920 --> 01:25:44,880
level

2277
01:25:44,880 --> 01:25:47,360
um the page table that's active has both

2278
01:25:47,360 --> 01:25:48,560
the processes pages

2279
01:25:48,560 --> 01:25:50,560
user level pages mapped in and all of

2280
01:25:50,560 --> 01:25:52,159
the kernel mapped into that one page

2281
01:25:52,159 --> 01:25:53,440
table

2282
01:25:53,440 --> 01:25:56,400
on the x86 anyway so when you made a

2283
01:25:56,400 --> 01:25:58,159
system call

2284
01:25:58,159 --> 01:26:00,560
and jumped into the kernel the kernel

2285
01:26:00,560 --> 01:26:02,639
was already mapped into the page table

2286
01:26:02,639 --> 01:26:04,400
and therefore no page table switch was

2287
01:26:04,400 --> 01:26:06,560
required so when you make a system call

2288
01:26:06,560 --> 01:26:06,960
it's

2289
01:26:06,960 --> 01:26:08,320
that much more expensive and much more

2290
01:26:08,320 --> 01:26:10,480
cheaper because there was no page table

2291
01:26:10,480 --> 01:26:11,920
switch if you're calling xv6

2292
01:26:11,920 --> 01:26:13,440
you know the trampoline code switches

2293
01:26:13,440 --> 01:26:15,840
page tables which

2294
01:26:15,840 --> 01:26:18,000
is an expensive thing to do because it

2295
01:26:18,000 --> 01:26:19,679
flushes the tlb

2296
01:26:19,679 --> 01:26:22,719
cache of virtual to physical mappings

2297
01:26:22,719 --> 01:26:25,360
anyway so for efficiency linux used to

2298
01:26:25,360 --> 01:26:26,960
map kernel and user space in the same

2299
01:26:26,960 --> 01:26:28,000
page table and

2300
01:26:28,000 --> 01:26:32,470
had fast system calls as a result

2301
01:26:32,480 --> 01:26:36,800
so they um for reasons that aren't very

2302
01:26:36,800 --> 01:26:38,400
clear decided to

2303
01:26:38,400 --> 01:26:40,719
do this same thing to set up the

2304
01:26:40,719 --> 01:26:44,000
mappings in the unix server

2305
01:26:44,000 --> 01:26:48,080
well what they wanted was that when

2306
01:26:48,080 --> 01:26:50,560
vi when a process sent a system call

2307
01:26:50,560 --> 01:26:51,440
over here

2308
01:26:51,440 --> 01:26:53,120
they wanted to have the page table that

2309
01:26:53,120 --> 01:26:54,800
was active while

2310
01:26:54,800 --> 01:26:57,600
in the linux server while processing

2311
01:26:57,600 --> 01:26:58,639
that system call

2312
01:26:58,639 --> 01:27:01,360
include all the virtual memory mappings

2313
01:27:01,360 --> 01:27:02,800
mappings for the

2314
01:27:02,800 --> 01:27:06,870
process that sent the system call

2315
01:27:06,880 --> 01:27:09,760
and that at least would make it simpler

2316
01:27:09,760 --> 01:27:10,800
to look up

2317
01:27:10,800 --> 01:27:13,280
virtual addresses passed as system call

2318
01:27:13,280 --> 01:27:14,080
arguments like

2319
01:27:14,080 --> 01:27:17,199
past or bead the reason why this

2320
01:27:17,199 --> 01:27:18,639
worked out poorly there were a bunch of

2321
01:27:18,639 --> 01:27:20,400
reasons one is that

2322
01:27:20,400 --> 01:27:24,000
um l4 which doesn't know anything about

2323
01:27:24,000 --> 01:27:25,120
any of this stuff

2324
01:27:25,120 --> 01:27:27,520
l4 just knows there's two processes and

2325
01:27:27,520 --> 01:27:28,560
so when you

2326
01:27:28,560 --> 01:27:30,480
send an ipc from one press to another l4

2327
01:27:30,480 --> 01:27:32,320
just switches page tables

2328
01:27:32,320 --> 01:27:33,840
it always just switches page tables this

2329
01:27:33,840 --> 01:27:36,800
guy had a page the vi at a page table

2330
01:27:36,800 --> 01:27:38,719
l4 associates a page table with a linux

2331
01:27:38,719 --> 01:27:40,159
kernel it just always switches page

2332
01:27:40,159 --> 01:27:40,719
tables

2333
01:27:40,719 --> 01:27:44,320
so you couldn't even due to l4 due to

2334
01:27:44,320 --> 01:27:45,440
the different way system calls were

2335
01:27:45,440 --> 01:27:47,600
implemented and the fact that l4 was

2336
01:27:47,600 --> 01:27:48,159
involved

2337
01:27:48,159 --> 01:27:50,000
there was no way to preserve the page

2338
01:27:50,000 --> 01:27:52,080
table during a system call

2339
01:27:52,080 --> 01:27:54,880
that just wasn't possible because it o4

2340
01:27:54,880 --> 01:27:56,800
always switched page tables

2341
01:27:56,800 --> 01:27:58,239
when it switched from one process to

2342
01:27:58,239 --> 01:27:59,840
another so they were never going to get

2343
01:27:59,840 --> 01:28:01,120
the efficiency win

2344
01:28:01,120 --> 01:28:04,400
of not having to switch page tables when

2345
01:28:04,400 --> 01:28:06,320
uh did when sort of crossing from

2346
01:28:06,320 --> 01:28:07,600
process from user to

2347
01:28:07,600 --> 01:28:11,120
kernel but i think they

2348
01:28:11,120 --> 01:28:13,280
wanted the convenience of being able to

2349
01:28:13,280 --> 01:28:15,120
directly use

2350
01:28:15,120 --> 01:28:17,920
users applied virtual addresses but that

2351
01:28:17,920 --> 01:28:19,280
meant that

2352
01:28:19,280 --> 01:28:21,840
the mappings they needed to be active

2353
01:28:21,840 --> 01:28:23,040
depended on which

2354
01:28:23,040 --> 01:28:25,920
process they were executing a a system

2355
01:28:25,920 --> 01:28:27,040
call on behalf of

2356
01:28:27,040 --> 01:28:29,040
so there couldn't be any one page table

2357
01:28:29,040 --> 01:28:30,560
for linux

2358
01:28:30,560 --> 01:28:31,679
they would have you know the page table

2359
01:28:31,679 --> 01:28:33,360
linux server wanted to use depend on

2360
01:28:33,360 --> 01:28:34,080
what process

2361
01:28:34,080 --> 01:28:38,159
sent the system call rpc but l4

2362
01:28:38,159 --> 01:28:40,159
did not know how to play that game l4

2363
01:28:40,159 --> 01:28:41,440
associated a single

2364
01:28:41,440 --> 01:28:43,840
page table with each process with each

2365
01:28:43,840 --> 01:28:44,719
task

2366
01:28:44,719 --> 01:28:47,120
and so in order and it would just switch

2367
01:28:47,120 --> 01:28:48,639
to that page table so tough luck

2368
01:28:48,639 --> 01:28:51,840
linux didn't have any way to cause the

2369
01:28:51,840 --> 01:28:53,440
page table to differ depending on who

2370
01:28:53,440 --> 01:28:54,320
had sent

2371
01:28:54,320 --> 01:28:57,040
the system call in order to deal with

2372
01:28:57,040 --> 01:28:57,840
that

2373
01:28:57,840 --> 01:29:00,960
apparently they made a bunch of

2374
01:29:00,960 --> 01:29:04,719
shared memory copies of the kernel one

2375
01:29:04,719 --> 01:29:07,040
for each process and so each of these

2376
01:29:07,040 --> 01:29:09,360
shared memory copies of the kernel

2377
01:29:09,360 --> 01:29:12,000
had exact had all of the kernel memory

2378
01:29:12,000 --> 01:29:14,080
mapped into it so they were all

2379
01:29:14,080 --> 01:29:16,639
the same kernel data structures but each

2380
01:29:16,639 --> 01:29:17,440
process

2381
01:29:17,440 --> 01:29:21,120
had a dedicated uh

2382
01:29:21,120 --> 01:29:22,840
kernel task associated with it and

2383
01:29:22,840 --> 01:29:24,960
therefore that basically

2384
01:29:24,960 --> 01:29:26,639
allowed them to trick l4 and to switch

2385
01:29:26,639 --> 01:29:28,239
into the appropriate page table that

2386
01:29:28,239 --> 01:29:29,040
included

2387
01:29:29,040 --> 01:29:31,600
that process plus the kernel you know

2388
01:29:31,600 --> 01:29:32,960
depending on which process sent the

2389
01:29:32,960 --> 01:29:34,719
system call request

2390
01:29:34,719 --> 01:29:37,679
and you know i think that kind of worked

2391
01:29:37,679 --> 01:29:38,480
but

2392
01:29:38,480 --> 01:29:39,760
or i don't forget what they said that

2393
01:29:39,760 --> 01:29:42,320
worked but it was slow or something

2394
01:29:42,320 --> 01:29:45,040
because it had there were a lot of tasks

2395
01:29:45,040 --> 01:29:46,719
um

2396
01:29:46,719 --> 01:29:48,320
anyway it's like a complicated story and

2397
01:29:48,320 --> 01:29:49,520
i think it didn't work out very well for

2398
01:29:49,520 --> 01:29:50,800
them

2399
01:29:50,800 --> 01:29:53,360
okay okay i see i think i think that

2400
01:29:53,360 --> 01:29:54,159
explains

2401
01:29:54,159 --> 01:29:57,199
oh well why this thing is harder to do

2402
01:29:57,199 --> 01:29:58,080
than

2403
01:29:58,080 --> 01:30:01,440
oh what we do in xv6 okay yeah yeah this

2404
01:30:01,440 --> 01:30:01,840
would be

2405
01:30:01,840 --> 01:30:04,159
because there's not yet this picture in

2406
01:30:04,159 --> 01:30:06,000
xv6 or even standard linux is

2407
01:30:06,000 --> 01:30:07,760
much simpler than this because you're

2408
01:30:07,760 --> 01:30:09,679
just jumping directly

2409
01:30:09,679 --> 01:30:11,120
into the kernel and the kernel has

2410
01:30:11,120 --> 01:30:13,040
control over direct control over all the

2411
01:30:13,040 --> 01:30:14,080
paging hardware

2412
01:30:14,080 --> 01:30:16,000
which it doesn't have when it runs that

2413
01:30:16,000 --> 01:30:17,600
note right

2414
01:30:17,600 --> 01:30:21,120
okay i see thank you thank you

2415
01:30:21,120 --> 01:30:24,719
we're going to ask um why um

2416
01:30:24,719 --> 01:30:27,600
it seems like um some some tasks are

2417
01:30:27,600 --> 01:30:29,120
more appropriate to be

2418
01:30:29,120 --> 01:30:31,600
put outside the kernel than others but

2419
01:30:31,600 --> 01:30:32,320
this

2420
01:30:32,320 --> 01:30:34,480
elf like the approach with micro kernels

2421
01:30:34,480 --> 01:30:36,320
always seems to be either everything or

2422
01:30:36,320 --> 01:30:37,920
nothing or like either

2423
01:30:37,920 --> 01:30:39,760
you have a monolithic kernel doing

2424
01:30:39,760 --> 01:30:41,280
everything or nothing

2425
01:30:41,280 --> 01:30:44,320
just like i feel like paging and some

2426
01:30:44,320 --> 01:30:46,080
other things could be very efficient

2427
01:30:46,080 --> 01:30:47,600
inside the kernel and then

2428
01:30:47,600 --> 01:30:49,679
maybe like file systems that things that

2429
01:30:49,679 --> 01:30:52,400
need to be swappable could be outside

2430
01:30:52,400 --> 01:30:54,480
uh and then even like you could maybe

2431
01:30:54,480 --> 01:30:56,000
even have a kernel that has some

2432
01:30:56,000 --> 01:30:57,760
functionality but you can opt

2433
01:30:57,760 --> 01:31:00,639
to not use it and provide your own is

2434
01:31:00,639 --> 01:31:02,719
there any everything you say

2435
01:31:02,719 --> 01:31:05,920
is absolutely well taken and

2436
01:31:05,920 --> 01:31:08,400
indeed there were a lot of micro kernel

2437
01:31:08,400 --> 01:31:10,400
or micro kernel related projects

2438
01:31:10,400 --> 01:31:13,120
um and many of them built various kinds

2439
01:31:13,120 --> 01:31:14,080
of hybrids

2440
01:31:14,080 --> 01:31:15,600
um like there were actually a couple

2441
01:31:15,600 --> 01:31:17,199
different versions of mock and some of

2442
01:31:17,199 --> 01:31:18,480
them

2443
01:31:18,480 --> 01:31:20,000
were sort of hybrid kernels in which

2444
01:31:20,000 --> 01:31:21,280
yeah there was this micro kernel that

2445
01:31:21,280 --> 01:31:21,840
knew about

2446
01:31:21,840 --> 01:31:24,880
ipc but also in the kernel was a

2447
01:31:24,880 --> 01:31:26,639
complete

2448
01:31:26,639 --> 01:31:30,400
unix so for instance mach 2.5

2449
01:31:30,400 --> 01:31:33,440
was this hybrid with it

2450
01:31:33,440 --> 01:31:35,600
but microkernel and unix all sort of in

2451
01:31:35,600 --> 01:31:36,960
the same kernel

2452
01:31:36,960 --> 01:31:38,639
and you could make system calls either

2453
01:31:38,639 --> 01:31:40,719
and some stuff was built in

2454
01:31:40,719 --> 01:31:42,880
the sort of microkernel way but some

2455
01:31:42,880 --> 01:31:44,400
things really they would just use

2456
01:31:44,400 --> 01:31:46,400
the kernel that was in mock that was

2457
01:31:46,400 --> 01:31:48,560
built into the mock kernel the unix

2458
01:31:48,560 --> 01:31:50,320
kernel was built into the mock kernel

2459
01:31:50,320 --> 01:31:53,360
um and modern you know mac os also

2460
01:31:53,360 --> 01:31:55,600
is built in a way that like the way you

2461
01:31:55,600 --> 01:31:56,400
describe you know

2462
01:31:56,400 --> 01:31:59,440
mac os that has a

2463
01:31:59,440 --> 01:32:00,560
all right it's a complete operating

2464
01:32:00,560 --> 01:32:01,920
system with a file system and everything

2465
01:32:01,920 --> 01:32:03,679
inside it but it also has good support

2466
01:32:03,679 --> 01:32:04,480
for

2467
01:32:04,480 --> 01:32:07,280
ipc and sort of mic threads or all the

2468
01:32:07,280 --> 01:32:08,719
stuff you would want to

2469
01:32:08,719 --> 01:32:13,440
build micro kernel style services

2470
01:32:13,440 --> 01:32:15,760
i think google's fuchsia i'm aware of

2471
01:32:15,760 --> 01:32:17,440
also implement some of these ideas now

2472
01:32:17,440 --> 01:32:18,400
as well

2473
01:32:18,400 --> 01:32:22,070
oh i'll bet yeah

2474
01:32:22,080 --> 01:32:24,719
so anyway you know there's no one way

2475
01:32:24,719 --> 01:32:26,080
there were people who were sort of

2476
01:32:26,080 --> 01:32:30,800
hoping that a pure a very pure

2477
01:32:30,800 --> 01:32:35,510
scheme could be made to work

2478
01:32:35,520 --> 01:32:38,840
but was not the only possible way

2479
01:32:38,840 --> 01:32:41,120
forward

2480
01:32:41,120 --> 01:32:42,960
all right thanks uh got around to my

2481
01:32:42,960 --> 01:32:44,239
next lecture but

2482
01:32:44,239 --> 01:32:48,629
i'll see you guys see you later

2483
01:32:48,639 --> 01:32:52,470
thank you you're welcome

2484
01:32:52,480 --> 01:32:54,560
oh i i didn't have a i haven't just a

2485
01:32:54,560 --> 01:32:55,840
remark i

2486
01:32:55,840 --> 01:32:58,639
i think it's fascinating that it it's

2487
01:32:58,639 --> 01:32:59,679
like

2488
01:32:59,679 --> 01:33:01,520
five percent slower but it does so much

2489
01:33:01,520 --> 01:33:03,600
more work yeah i was fascinating with

2490
01:33:03,600 --> 01:33:06,070
that

2491
01:33:06,080 --> 01:33:07,120
you mean that even though it's doing

2492
01:33:07,120 --> 01:33:08,719
much more work it's only slightly slower

2493
01:33:08,719 --> 01:33:10,080
yeah

2494
01:33:10,080 --> 01:33:13,920
well they really sweat blood over the

2495
01:33:13,920 --> 01:33:17,040
ipc performance and it's another thing

2496
01:33:17,040 --> 01:33:17,679
to remember

2497
01:33:17,679 --> 01:33:20,560
of course is that if you start doing if

2498
01:33:20,560 --> 01:33:21,840
you're doing a

2499
01:33:21,840 --> 01:33:23,920
significant amount of work per system

2500
01:33:23,920 --> 01:33:24,960
call

2501
01:33:24,960 --> 01:33:26,960
like you know looking at files and

2502
01:33:26,960 --> 01:33:28,719
directories or something

2503
01:33:28,719 --> 01:33:30,400
then the cost of the system called the

2504
01:33:30,400 --> 01:33:33,040
ipc itself starts to be less

2505
01:33:33,040 --> 01:33:36,159
important so the combination of faster

2506
01:33:36,159 --> 01:33:38,159
system calls plus real programs do

2507
01:33:38,159 --> 01:33:39,440
things other than

2508
01:33:39,440 --> 01:33:42,560
making system calls but it would also

2509
01:33:42,560 --> 01:33:43,760
like switch

2510
01:33:43,760 --> 01:33:47,280
page tables and oh yeah the others

2511
01:33:47,280 --> 01:33:49,040
yeah although the paper i did not talk

2512
01:33:49,040 --> 01:33:50,800
about it but the paper had some clever

2513
01:33:50,800 --> 01:33:52,080
tricks for

2514
01:33:52,080 --> 01:33:54,400
avoiding the cost of switching page

2515
01:33:54,400 --> 01:33:55,120
tables

2516
01:33:55,120 --> 01:33:58,400
i don't know if you remember for some

2517
01:33:58,400 --> 01:34:00,000
booths like on page six we're talking

2518
01:34:00,000 --> 01:34:01,679
about supporting tag

2519
01:34:01,679 --> 01:34:04,159
tobs or small spaces they had some

2520
01:34:04,159 --> 01:34:05,440
clever ideas for

2521
01:34:05,440 --> 01:34:08,639
not which page tables

2522
01:34:08,639 --> 01:34:10,239
which i had not heard of before i read

2523
01:34:10,239 --> 01:34:12,239
this paper so

2524
01:34:12,239 --> 01:34:14,800
this is pretty cool thank you so much

2525
01:34:14,800 --> 01:34:16,840
bye

2526
01:34:16,840 --> 01:34:19,840
bye

