1
00:00:06,960 --> 00:00:07,440
uh

2
00:00:07,440 --> 00:00:10,639
good afternoon uh quick sound check can

3
00:00:10,639 --> 00:00:14,000
people hear me yes

4
00:00:14,000 --> 00:00:18,400
thanks okay so uh i guess uh today

5
00:00:18,400 --> 00:00:21,680
you know so far it's the last lecture or

6
00:00:21,680 --> 00:00:25,519
so 81 this semester and

7
00:00:25,519 --> 00:00:29,199
we don't really have a formal uh

8
00:00:29,199 --> 00:00:31,840
topic uh you know there's a q a lecture

9
00:00:31,840 --> 00:00:33,120
uh so feel free

10
00:00:33,120 --> 00:00:36,239
to ask questions uh about anything uh

11
00:00:36,239 --> 00:00:38,800
this is i guess last uh your last chance

12
00:00:38,800 --> 00:00:41,280
at least this semester for this class

13
00:00:41,280 --> 00:00:44,800
um by default my plan was to uh

14
00:00:44,800 --> 00:00:47,440
go over a couple topics uh based on the

15
00:00:47,440 --> 00:00:49,200
questions uh over email

16
00:00:49,200 --> 00:00:50,399
one i was gonna talk a little bit about

17
00:00:50,399 --> 00:00:53,840
the network lab the solutions

18
00:00:53,840 --> 00:00:56,399
uh the it's possible also a little bit

19
00:00:56,399 --> 00:00:57,120
of

20
00:00:57,120 --> 00:01:00,719
time about the ml lab and again talking

21
00:01:00,719 --> 00:01:02,239
about those solutions

22
00:01:02,239 --> 00:01:03,440
and then there were a lot of questions

23
00:01:03,440 --> 00:01:05,840
about the follow-on classes

24
00:01:05,840 --> 00:01:07,840
and the fact that i think i'll cover

25
00:01:07,840 --> 00:01:11,109
that first

26
00:01:11,119 --> 00:01:14,320
uh but before diving in uh in any of

27
00:01:14,320 --> 00:01:16,479
these three topics uh let me remind you

28
00:01:16,479 --> 00:01:22,080
uh there's a subject evaluation

29
00:01:22,080 --> 00:01:25,840
uh outgoing ongoing and uh we repeat

30
00:01:25,840 --> 00:01:28,640
as a staff of so81 we appreciate if you

31
00:01:28,640 --> 00:01:29,520
uh

32
00:01:29,520 --> 00:01:33,119
you know give your feedback on so 81 and

33
00:01:33,119 --> 00:01:34,960
hopefully it's positive and you know we

34
00:01:34,960 --> 00:01:36,479
get a chance to teach you again

35
00:01:36,479 --> 00:01:40,240
uh next year and maybe this is also

36
00:01:40,240 --> 00:01:42,560
a good time to you know uh actually

37
00:01:42,560 --> 00:01:43,680
thank you for attending

38
00:01:43,680 --> 00:01:45,280
today's lecture even though there's not

39
00:01:45,280 --> 00:01:47,280
a sort of very formal program but i also

40
00:01:47,280 --> 00:01:47,680
uh

41
00:01:47,680 --> 00:01:48,960
appreciate the fact that with the staff

42
00:01:48,960 --> 00:01:50,720
and generally appreciate the fact that

43
00:01:50,720 --> 00:01:52,720
uh you know you're you've been very

44
00:01:52,720 --> 00:01:54,240
engaged and uh

45
00:01:54,240 --> 00:01:55,520
you know particularly with the papers

46
00:01:55,520 --> 00:01:57,119
that are not directly to the labs you

47
00:01:57,119 --> 00:01:57,680
know

48
00:01:57,680 --> 00:01:59,920
it's clear that many of you dove into

49
00:01:59,920 --> 00:02:01,600
the papers and try to really understand

50
00:02:01,600 --> 00:02:02,079
them and

51
00:02:02,079 --> 00:02:04,719
ask great great questions uh over email

52
00:02:04,719 --> 00:02:05,680
so

53
00:02:05,680 --> 00:02:10,800
we very much appreciate the engagement

54
00:02:10,800 --> 00:02:14,000
any questions before i

55
00:02:14,000 --> 00:02:21,430
go over this set of topics

56
00:02:21,440 --> 00:02:23,840
okay let me uh start them with the

57
00:02:23,840 --> 00:02:25,200
question that probably came up most in

58
00:02:25,200 --> 00:02:26,160
email

59
00:02:26,160 --> 00:02:30,319
what next um there's a quite a number of

60
00:02:30,319 --> 00:02:31,040
classes

61
00:02:31,040 --> 00:02:34,160
uh that uh you know systems oriented

62
00:02:34,160 --> 00:02:36,319
focused

63
00:02:36,319 --> 00:02:38,800
and i'm sure i missed a number of

64
00:02:38,800 --> 00:02:39,519
classes

65
00:02:39,519 --> 00:02:42,160
uh that i should have listed here uh you

66
00:02:42,160 --> 00:02:43,360
know immediately sort of straightly

67
00:02:43,360 --> 00:02:44,879
related to operating systems you know

68
00:02:44,879 --> 00:02:46,879
clearly you know if you haven't taken o3

69
00:02:46,879 --> 00:02:48,239
yet you know it's a great class to take

70
00:02:48,239 --> 00:02:49,440
and particularly

71
00:02:49,440 --> 00:02:52,879
read read or learn how to read papers

72
00:02:52,879 --> 00:02:56,160
uh 6828 was the

73
00:02:56,160 --> 00:02:58,640
the original and the only os class uh

74
00:02:58,640 --> 00:02:59,200
that

75
00:02:59,200 --> 00:03:01,680
we offered uh you know these this year

76
00:03:01,680 --> 00:03:03,760
uh where this is the second year where

77
00:03:03,760 --> 00:03:04,879
this year is the year first year that

78
00:03:04,879 --> 00:03:07,599
we're offering both uh so soa one is

79
00:03:07,599 --> 00:03:10,640
the undergrad os and sa2a the

80
00:03:10,640 --> 00:03:13,840
of h28 as the grad level os class

81
00:03:13,840 --> 00:03:16,879
um and you know the basically 808

82
00:03:16,879 --> 00:03:18,959
assumes you have taken oath one

83
00:03:18,959 --> 00:03:21,760
or undergrad os and you know goes off in

84
00:03:21,760 --> 00:03:24,000
doing projects and

85
00:03:24,000 --> 00:03:27,440
building interesting os artifacts and

86
00:03:27,440 --> 00:03:29,120
reading more papers from the literature

87
00:03:29,120 --> 00:03:32,720
more of the modern research literature

88
00:03:32,720 --> 00:03:35,200
then maybe you're more you know the the

89
00:03:35,200 --> 00:03:36,720
os sort of you know does a lot of

90
00:03:36,720 --> 00:03:37,840
interfacing with the hardware

91
00:03:37,840 --> 00:03:40,159
a little bit more of the hardware side

92
00:03:40,159 --> 00:03:41,680
of systems you know the computer

93
00:03:41,680 --> 00:03:43,280
architecture class a23 which i

94
00:03:43,280 --> 00:03:45,280
believe is offered to the coming spring

95
00:03:45,280 --> 00:03:46,799
and of course the 611

96
00:03:46,799 --> 00:03:48,720
you know sort of the you know building

97
00:03:48,720 --> 00:03:49,920
something uh

98
00:03:49,920 --> 00:03:53,280
hardware devices uh on the

99
00:03:53,280 --> 00:03:54,480
sort of performance sites and the

100
00:03:54,480 --> 00:03:56,879
compiler sites 6172 and 6035

101
00:03:56,879 --> 00:03:58,480
are good places i think the number of

102
00:03:58,480 --> 00:04:00,239
you are taking 6172

103
00:04:00,239 --> 00:04:03,439
in parallel with s081 so but if you

104
00:04:03,439 --> 00:04:04,560
haven't taken for example the compile

105
00:04:04,560 --> 00:04:06,640
class or v5 or the dynamic

106
00:04:06,640 --> 00:04:08,319
you know compiler class you know both of

107
00:04:08,319 --> 00:04:11,519
them are also great classes

108
00:04:11,519 --> 00:04:14,640
uh systems is a broad topic uh so like

109
00:04:14,640 --> 00:04:15,040
there's

110
00:04:15,040 --> 00:04:17,199
uh networking and there's a whole branch

111
00:04:17,199 --> 00:04:19,040
of classes and a whole stream of classes

112
00:04:19,040 --> 00:04:20,160
around networking

113
00:04:20,160 --> 00:04:22,320
there's a whole stream of class around

114
00:04:22,320 --> 00:04:23,919
databases

115
00:04:23,919 --> 00:04:27,040
which are all good and

116
00:04:27,040 --> 00:04:29,759
important and uh aspects that you've

117
00:04:29,759 --> 00:04:30,400
seen

118
00:04:30,400 --> 00:04:32,880
in so 81 will show up in much more

119
00:04:32,880 --> 00:04:34,400
prominent ways

120
00:04:34,400 --> 00:04:37,600
uh in those classes um so for example

121
00:04:37,600 --> 00:04:39,759
networking clearly is a great topic of

122
00:04:39,759 --> 00:04:42,080
829 and so you'll see a lot more about

123
00:04:42,080 --> 00:04:43,440
networking there

124
00:04:43,440 --> 00:04:46,320
than you've seen in so 81 uh 6830 you

125
00:04:46,320 --> 00:04:47,759
know we talked about file systems you

126
00:04:47,759 --> 00:04:48,080
know

127
00:04:48,080 --> 00:04:50,080
clearly another important class of uh

128
00:04:50,080 --> 00:04:51,440
storage systems uh

129
00:04:51,440 --> 00:04:53,440
and probably in some ways more important

130
00:04:53,440 --> 00:04:55,520
for many applications is databases and

131
00:04:55,520 --> 00:04:56,000
so

132
00:04:56,000 --> 00:04:58,400
630 is a great topic class to learn a

133
00:04:58,400 --> 00:05:00,880
lot more about databases

134
00:05:00,880 --> 00:05:02,720
in terms of like classes that are sort

135
00:05:02,720 --> 00:05:04,800
of uh you know sometimes called whatever

136
00:05:04,800 --> 00:05:06,160
the pdos classes

137
00:05:06,160 --> 00:05:09,680
um there's a number of them uh

138
00:05:09,680 --> 00:05:10,800
eight through four the distributed

139
00:05:10,800 --> 00:05:13,039
systems class uh we'll be offering that

140
00:05:13,039 --> 00:05:14,080
uh

141
00:05:14,080 --> 00:05:16,800
uh coming semester spring semester and

142
00:05:16,800 --> 00:05:17,120
uh

143
00:05:17,120 --> 00:05:21,120
a a section of the number of the

144
00:05:21,120 --> 00:05:23,120
staff involved this semester in nassau

145
00:05:23,120 --> 00:05:25,360
will be involved in a24

146
00:05:25,360 --> 00:05:28,560
uh there's a 858 which is the computer

147
00:05:28,560 --> 00:05:30,080
security class

148
00:05:30,080 --> 00:05:32,479
we won't be offering that coming this

149
00:05:32,479 --> 00:05:33,360
spring

150
00:05:33,360 --> 00:05:35,120
but you know we hope to offer it the

151
00:05:35,120 --> 00:05:36,800
next academic year

152
00:05:36,800 --> 00:05:39,840
and there's uh 826 which is the

153
00:05:39,840 --> 00:05:41,680
principles of computer systems so if a

154
00:05:41,680 --> 00:05:43,440
number of people ask about verification

155
00:05:43,440 --> 00:05:44,639
and system software

156
00:05:44,639 --> 00:05:46,479
uh this is the class to take if you're

157
00:05:46,479 --> 00:05:48,720
interested in that topic

158
00:05:48,720 --> 00:05:52,160
uh more broadly speaking a lot of people

159
00:05:52,160 --> 00:05:52,880
wondering like

160
00:05:52,880 --> 00:05:54,320
what is actually going on in research if

161
00:05:54,320 --> 00:05:55,919
you're interested you know the

162
00:05:55,919 --> 00:05:57,919
almost all the papers in the systems

163
00:05:57,919 --> 00:05:59,919
literature are publicly available even

164
00:05:59,919 --> 00:06:01,120
the ones at the recent

165
00:06:01,120 --> 00:06:03,680
conferences so example the oci

166
00:06:03,680 --> 00:06:06,240
conference happened a couple weeks ago

167
00:06:06,240 --> 00:06:08,400
and you can just look at them and see

168
00:06:08,400 --> 00:06:10,160
what kind of topics are covered and

169
00:06:10,160 --> 00:06:11,280
read the papers that you find

170
00:06:11,280 --> 00:06:13,520
interesting all the talks are published

171
00:06:13,520 --> 00:06:14,880
one of the advantages of i guess you

172
00:06:14,880 --> 00:06:17,280
know the covert period is that all these

173
00:06:17,280 --> 00:06:18,319
companies are virtual

174
00:06:18,319 --> 00:06:21,520
and so all the conferences are recorded

175
00:06:21,520 --> 00:06:23,199
and you can just watch them and

176
00:06:23,199 --> 00:06:25,520
see what's going on if you're interested

177
00:06:25,520 --> 00:06:27,360
in the sort of two parts you know just

178
00:06:27,360 --> 00:06:28,960
the research part

179
00:06:28,960 --> 00:06:30,160
then of course you know there's what's

180
00:06:30,160 --> 00:06:31,759
going on in practice and you know if

181
00:06:31,759 --> 00:06:32,880
you're interested in

182
00:06:32,880 --> 00:06:34,319
keeping track of what's happening with

183
00:06:34,319 --> 00:06:36,000
linux and how that's

184
00:06:36,000 --> 00:06:39,919
uh how it's evolving uh lwn.net actually

185
00:06:39,919 --> 00:06:40,880
publishes a

186
00:06:40,880 --> 00:06:42,720
at a very regular page and a very very

187
00:06:42,720 --> 00:06:44,000
interesting articles about like sort of

188
00:06:44,000 --> 00:06:45,520
big changes

189
00:06:45,520 --> 00:06:47,600
or topics that are around the linux

190
00:06:47,600 --> 00:06:49,440
kernel

191
00:06:49,440 --> 00:06:52,240
uh finally you know uh if you're just

192
00:06:52,240 --> 00:06:53,199
excited about like

193
00:06:53,199 --> 00:06:55,039
doing the labs you know just keep keep

194
00:06:55,039 --> 00:06:56,960
hacking i think you

195
00:06:56,960 --> 00:06:58,880
you can use easily to cook up projects

196
00:06:58,880 --> 00:07:01,199
uh either by doing

197
00:07:01,199 --> 00:07:03,120
extensions of labs or just trying things

198
00:07:03,120 --> 00:07:04,800
out on your own and

199
00:07:04,800 --> 00:07:08,080
it's a great way to really learn and

200
00:07:08,080 --> 00:07:10,400
appreciate how things work you probably

201
00:07:10,400 --> 00:07:11,680
have gotten a good sense of that during

202
00:07:11,680 --> 00:07:13,280
the labs

203
00:07:13,280 --> 00:07:14,800
we're sort of big fans of learning by

204
00:07:14,800 --> 00:07:17,440
doing and

205
00:07:17,440 --> 00:07:19,440
you you can a lot of that you can do it

206
00:07:19,440 --> 00:07:22,950
on your own

207
00:07:22,960 --> 00:07:26,790
any questions about

208
00:07:26,800 --> 00:07:41,430
what next after actually one

209
00:07:41,440 --> 00:07:45,759
okay well let's talk about the uh

210
00:07:45,759 --> 00:07:49,599
net lap uh and then that was julia like

211
00:07:49,599 --> 00:07:50,000
i said

212
00:07:50,000 --> 00:07:56,070
yesterday um

213
00:07:56,080 --> 00:07:58,319
and so uh there's a couple things so

214
00:07:58,319 --> 00:07:59,759
maybe i'll start it uh

215
00:07:59,759 --> 00:08:01,919
we'll dive in sort of slowly and start a

216
00:08:01,919 --> 00:08:03,280
little bit at the top

217
00:08:03,280 --> 00:08:05,599
um and let me talk a little bit in

218
00:08:05,599 --> 00:08:08,240
generic uh terms about

219
00:08:08,240 --> 00:08:13,280
the lab

220
00:08:13,280 --> 00:08:14,960
uh there's a couple things i first i

221
00:08:14,960 --> 00:08:16,319
want to talk a little bit about just

222
00:08:16,319 --> 00:08:19,840
sort of structural things uh that sort

223
00:08:19,840 --> 00:08:20,720
of influenced

224
00:08:20,720 --> 00:08:22,720
the design of the lab or you know the

225
00:08:22,720 --> 00:08:23,919
coding of the lab

226
00:08:23,919 --> 00:08:26,000
and those are four different things

227
00:08:26,000 --> 00:08:27,520
aspects one is i just want to talk a

228
00:08:27,520 --> 00:08:29,039
little bit about hardware

229
00:08:29,039 --> 00:08:30,720
uh you know this is one of the labs

230
00:08:30,720 --> 00:08:32,479
where we uh

231
00:08:32,479 --> 00:08:33,680
there's a lot of interaction between the

232
00:08:33,680 --> 00:08:34,880
software and hardware in fact the

233
00:08:34,880 --> 00:08:36,959
hardware determines for a great part

234
00:08:36,959 --> 00:08:38,080
like how the

235
00:08:38,080 --> 00:08:41,039
the structure of the software um known a

236
00:08:41,039 --> 00:08:43,120
little bit about software structure

237
00:08:43,120 --> 00:08:44,959
uh and just come sort of back to this

238
00:08:44,959 --> 00:08:46,720
general topic that we covered in uh sort

239
00:08:46,720 --> 00:08:47,040
of

240
00:08:47,040 --> 00:08:48,399
like somewhere in the middle of the term

241
00:08:48,399 --> 00:08:50,000
about you know the organization of

242
00:08:50,000 --> 00:08:51,440
drivers relative to the rest of the

243
00:08:51,440 --> 00:08:52,880
operating system kernel

244
00:08:52,880 --> 00:08:54,399
then talk a little bit more specific

245
00:08:54,399 --> 00:08:56,080
about hardware structures you know the

246
00:08:56,080 --> 00:09:02,710
rings uh and you know the descriptors

247
00:09:02,720 --> 00:09:04,160
are the two primary sort of hardware

248
00:09:04,160 --> 00:09:05,760
structures that the

249
00:09:05,760 --> 00:09:08,720
driver deals with or it must deal with

250
00:09:08,720 --> 00:09:09,279
and then

251
00:09:09,279 --> 00:09:11,040
uh i'll talk a little bit talk about the

252
00:09:11,040 --> 00:09:13,200
code and particularly the solutions

253
00:09:13,200 --> 00:09:15,760
uh and sort of focusing on a little bit

254
00:09:15,760 --> 00:09:18,560
about the role of m-buffs

255
00:09:18,560 --> 00:09:21,680
uh you know walking a lot of questions

256
00:09:21,680 --> 00:09:23,200
uh over email about

257
00:09:23,200 --> 00:09:25,600
you know why not a lock in receive lock

258
00:09:25,600 --> 00:09:26,320
would receive

259
00:09:26,320 --> 00:09:28,640
uh in the receive function uh why the

260
00:09:28,640 --> 00:09:31,120
loop in the receive handler

261
00:09:31,120 --> 00:09:33,920
and uh you know what exactly you know do

262
00:09:33,920 --> 00:09:34,560
the

263
00:09:34,560 --> 00:09:37,760
flags mean in the command command

264
00:09:37,760 --> 00:09:40,560
field of the structure of the descriptor

265
00:09:40,560 --> 00:09:41,200
and so

266
00:09:41,200 --> 00:09:42,640
we'll get to those issues if we as we

267
00:09:42,640 --> 00:09:45,279
look at the top as we look at the code

268
00:09:45,279 --> 00:09:48,640
the just before we drive in like it may

269
00:09:48,640 --> 00:09:50,320
be worthwhile so reminding ourselves

270
00:09:50,320 --> 00:09:50,959
here what the

271
00:09:50,959 --> 00:09:53,120
challenges are although they're probably

272
00:09:53,120 --> 00:09:54,080
fresh in your head

273
00:09:54,080 --> 00:09:56,080
but like from a high level like what are

274
00:09:56,080 --> 00:09:57,920
the sort of core talent challenges that

275
00:09:57,920 --> 00:09:59,279
you know you have to deal with in this

276
00:09:59,279 --> 00:10:01,509
lab

277
00:10:01,519 --> 00:10:04,079
if you'll jump in now to add any ones

278
00:10:04,079 --> 00:10:05,839
that i might have missed and you

279
00:10:05,839 --> 00:10:08,079
struggled with so first of all you know

280
00:10:08,079 --> 00:10:10,079
there's the hardware specification

281
00:10:10,079 --> 00:10:13,200
uh this is a you know it's a

282
00:10:13,200 --> 00:10:16,399
pdf is a pretty serious document uh

283
00:10:16,399 --> 00:10:20,079
and this network card uh the 1000 um

284
00:10:20,079 --> 00:10:21,760
even though it's a reasonable simple

285
00:10:21,760 --> 00:10:23,279
network card is still a very

286
00:10:23,279 --> 00:10:25,360
sophisticated uh piece of hardware

287
00:10:25,360 --> 00:10:26,640
uh that offers a lot of different

288
00:10:26,640 --> 00:10:29,120
features and ways you can

289
00:10:29,120 --> 00:10:31,360
program and as you're just getting on

290
00:10:31,360 --> 00:10:32,720
top of actually what the

291
00:10:32,720 --> 00:10:35,120
you know the card does and how do you

292
00:10:35,120 --> 00:10:36,000
program it

293
00:10:36,000 --> 00:10:38,160
uh you know just internalizing all that

294
00:10:38,160 --> 00:10:40,000
uh is is difficult

295
00:10:40,000 --> 00:10:46,480
and uh poses a challenge um

296
00:10:46,480 --> 00:10:48,560
the second i think you know major

297
00:10:48,560 --> 00:10:49,519
challenge is the

298
00:10:49,519 --> 00:10:52,560
concurrency side of things

299
00:10:52,560 --> 00:10:54,560
and there's sort of two parts of the

300
00:10:54,560 --> 00:10:56,320
concurrency that makes this a lot

301
00:10:56,320 --> 00:10:58,399
uh challenging one is just the

302
00:10:58,399 --> 00:10:59,760
concurrency between the hardware and the

303
00:10:59,760 --> 00:11:00,959
software

304
00:11:00,959 --> 00:11:02,959
right like the network card is just

305
00:11:02,959 --> 00:11:04,560
doing things like sending packets

306
00:11:04,560 --> 00:11:06,240
receiving packets at the same time

307
00:11:06,240 --> 00:11:07,839
you know the os kernel is running and

308
00:11:07,839 --> 00:11:09,760
the driver is running and so there has

309
00:11:09,760 --> 00:11:11,760
to be some coordination plan

310
00:11:11,760 --> 00:11:12,959
you know between the hardware and

311
00:11:12,959 --> 00:11:14,399
software you know to actually make sure

312
00:11:14,399 --> 00:11:15,920
that everything works out

313
00:11:15,920 --> 00:11:19,279
and uh and a large part of the driver uh

314
00:11:19,279 --> 00:11:22,079
is you know dealing with that you know

315
00:11:22,079 --> 00:11:23,839
coordination

316
00:11:23,839 --> 00:11:25,760
uh there's also the software chakra

317
00:11:25,760 --> 00:11:27,279
convert

318
00:11:27,279 --> 00:11:29,839
coordination you know the driver

319
00:11:29,839 --> 00:11:31,440
multiple threats or multiple kernel

320
00:11:31,440 --> 00:11:32,880
threats might be ending or

321
00:11:32,880 --> 00:11:36,000
handler run inside of the driver uh

322
00:11:36,000 --> 00:11:37,600
and we've got to make sure that they

323
00:11:37,600 --> 00:11:40,079
don't step on each other's toes

324
00:11:40,079 --> 00:11:42,240
nothing else happens and this comes a

325
00:11:42,240 --> 00:11:43,519
lot to like you know the

326
00:11:43,519 --> 00:11:47,120
locking uh topic

327
00:11:47,120 --> 00:11:49,040
even the even in this driver you know

328
00:11:49,040 --> 00:11:50,639
things are reasonable uh

329
00:11:50,639 --> 00:11:52,639
straightforward in terms of the

330
00:11:52,639 --> 00:11:53,680
concurrency for

331
00:11:53,680 --> 00:11:55,279
the software concurrency but

332
00:11:55,279 --> 00:11:56,240
nevertheless you know it's something

333
00:11:56,240 --> 00:11:57,920
that requires attention and a little bit

334
00:11:57,920 --> 00:11:59,120
of thinking

335
00:11:59,120 --> 00:12:01,279
and then finally i guess the as you

336
00:12:01,279 --> 00:12:02,880
that's probably on the top of your list

337
00:12:02,880 --> 00:12:04,399
or many of your list is you know just

338
00:12:04,399 --> 00:12:05,279
debugging

339
00:12:05,279 --> 00:12:08,480
this is a little bit hard a little bit

340
00:12:08,480 --> 00:12:09,920
sometimes more challenging of pure

341
00:12:09,920 --> 00:12:11,440
software debugging because

342
00:12:11,440 --> 00:12:13,120
you can't set you know break points

343
00:12:13,120 --> 00:12:14,480
inside of the network card

344
00:12:14,480 --> 00:12:17,279
you know you can program the registers

345
00:12:17,279 --> 00:12:18,959
and then this will give the card a kick

346
00:12:18,959 --> 00:12:20,079
and say like you know please do your

347
00:12:20,079 --> 00:12:20,880
work

348
00:12:20,880 --> 00:12:22,320
uh and then if the card doesn't do

349
00:12:22,320 --> 00:12:23,600
anything or you don't see your packet

350
00:12:23,600 --> 00:12:24,880
coming out on the other side

351
00:12:24,880 --> 00:12:28,560
you know in the log you know of

352
00:12:28,560 --> 00:12:31,440
the packet trace then you know you

353
00:12:31,440 --> 00:12:32,880
basically have to scratch your head and

354
00:12:32,880 --> 00:12:34,399
sort of start thinking about like what

355
00:12:34,399 --> 00:12:36,240
what you what might have gone wrong or

356
00:12:36,240 --> 00:12:38,000
what it might you have missed in the

357
00:12:38,000 --> 00:12:41,279
hardware specification and so you have

358
00:12:41,279 --> 00:12:42,800
to go circle back and forth and

359
00:12:42,800 --> 00:12:45,680
there's no sort of easy way uh or you

360
00:12:45,680 --> 00:12:47,279
can just can't not single step

361
00:12:47,279 --> 00:12:52,399
you know through the the network card

362
00:12:52,399 --> 00:12:53,680
does that make sense in terms of

363
00:12:53,680 --> 00:12:55,680
challenges you know does that line up

364
00:12:55,680 --> 00:12:57,920
with your own experience or am i missing

365
00:12:57,920 --> 00:12:59,680
some of the

366
00:12:59,680 --> 00:13:01,120
missing one of the core challenges that

367
00:13:01,120 --> 00:13:18,230
you dealt with

368
00:13:18,240 --> 00:13:21,279
okay oh uh

369
00:13:21,279 --> 00:13:22,880
let's talk to them uh let's start with

370
00:13:22,880 --> 00:13:24,399
the hardware side of things

371
00:13:24,399 --> 00:13:27,600
uh and uh and the reason i want to start

372
00:13:27,600 --> 00:13:28,320
there because

373
00:13:28,320 --> 00:13:30,639
uh you know it's easy to keep or lose

374
00:13:30,639 --> 00:13:31,839
track of the fact that you know actually

375
00:13:31,839 --> 00:13:33,360
we're dealing with hardware here

376
00:13:33,360 --> 00:13:35,279
uh you know even though you know it's

377
00:13:35,279 --> 00:13:36,880
sort of virtualized where it is

378
00:13:36,880 --> 00:13:39,760
emulated by qmu and you're just running

379
00:13:39,760 --> 00:13:41,040
it on your

380
00:13:41,040 --> 00:13:43,760
on athena or on your laptop uh the

381
00:13:43,760 --> 00:13:45,760
actual thing that's implemented by qmu

382
00:13:45,760 --> 00:13:47,120
is hardware and so it's usually

383
00:13:47,120 --> 00:13:48,480
reminding you again

384
00:13:48,480 --> 00:13:50,880
you've seen this picture before uh you

385
00:13:50,880 --> 00:13:52,560
know the way to think about it is that

386
00:13:52,560 --> 00:13:53,519
you know qmu

387
00:13:53,519 --> 00:13:57,040
emulates a complete board of

388
00:13:57,040 --> 00:14:00,240
devices and the processor

389
00:14:00,240 --> 00:14:04,230
and um

390
00:14:04,240 --> 00:14:06,240
um and so you know if we don't know i'll

391
00:14:06,240 --> 00:14:07,680
talk a little bit before about it like

392
00:14:07,680 --> 00:14:08,639
the process actually is

393
00:14:08,639 --> 00:14:11,199
like almost like a small piece of the

394
00:14:11,199 --> 00:14:12,560
whole

395
00:14:12,560 --> 00:14:14,240
uh board you know it's the thing that

396
00:14:14,240 --> 00:14:16,240
sits under the fan here uh

397
00:14:16,240 --> 00:14:18,160
but then you know there's a range of

398
00:14:18,160 --> 00:14:19,839
devices you know that are

399
00:14:19,839 --> 00:14:21,519
you know connected or can be connected

400
00:14:21,519 --> 00:14:24,240
to this board and then interact you know

401
00:14:24,240 --> 00:14:25,440
with the

402
00:14:25,440 --> 00:14:27,199
code running on the processor you know

403
00:14:27,199 --> 00:14:29,040
here you know for this particular

404
00:14:29,040 --> 00:14:30,399
you know what it's really interesting

405
00:14:30,399 --> 00:14:32,079
sort of is the actual

406
00:14:32,079 --> 00:14:33,839
event jack you know where you can plug

407
00:14:33,839 --> 00:14:35,519
in your ethernet cable and then that is

408
00:14:35,519 --> 00:14:37,199
actually the thing that the network card

409
00:14:37,199 --> 00:14:40,399
you know sends its package over

410
00:14:40,399 --> 00:14:43,760
um now pbu doesn't emulate exactly this

411
00:14:43,760 --> 00:14:44,320
board

412
00:14:44,320 --> 00:14:45,760
so things are slightly differently but

413
00:14:45,760 --> 00:14:47,760
again you know at least conceptually

414
00:14:47,760 --> 00:14:49,120
this is like a picture you should have

415
00:14:49,120 --> 00:14:49,600
in your

416
00:14:49,600 --> 00:14:51,680
in your head right and so when you know

417
00:14:51,680 --> 00:14:52,639
the process really

418
00:14:52,639 --> 00:14:54,160
you know writing you know registers you

419
00:14:54,160 --> 00:14:55,680
know of the device driver

420
00:14:55,680 --> 00:14:57,600
that cost some stuff to happen that

421
00:14:57,600 --> 00:14:59,040
actually in the end some packet comes

422
00:14:59,040 --> 00:15:00,399
out of this cable

423
00:15:00,399 --> 00:15:02,880
that's connected to the ethernet

424
00:15:02,880 --> 00:15:04,639
connector

425
00:15:04,639 --> 00:15:08,639
um you know in a slightly more

426
00:15:08,639 --> 00:15:12,639
uh you know

427
00:15:12,639 --> 00:15:15,680
uh in a slightly more in a in a

428
00:15:15,680 --> 00:15:17,760
schematic diagram you know this is the

429
00:15:17,760 --> 00:15:19,600
same picture basically in here you know

430
00:15:19,600 --> 00:15:20,240
we're seeing

431
00:15:20,240 --> 00:15:22,880
here's our processor uh board that has

432
00:15:22,880 --> 00:15:23,279
four

433
00:15:23,279 --> 00:15:26,079
cores on it uh it has one of the l1 and

434
00:15:26,079 --> 00:15:28,320
l2 caches and then it has like a link

435
00:15:28,320 --> 00:15:29,440
you know going to memory

436
00:15:29,440 --> 00:15:32,000
so here's the memory and the ram random

437
00:15:32,000 --> 00:15:33,680
access memory and as we'll see

438
00:15:33,680 --> 00:15:35,360
in a second you know that plays actually

439
00:15:35,360 --> 00:15:37,040
a big role and then here

440
00:15:37,040 --> 00:15:38,800
like intersection the link you know to

441
00:15:38,800 --> 00:15:41,120
the or here actually it's linked to the

442
00:15:41,120 --> 00:15:41,759
gigabit

443
00:15:41,759 --> 00:15:45,120
uh even a controller now

444
00:15:45,120 --> 00:15:47,839
uh it's a little bit messy you know so

445
00:15:47,839 --> 00:15:48,880
to think about the

446
00:15:48,880 --> 00:15:51,279
this level of detail uh what exactly is

447
00:15:51,279 --> 00:15:52,720
going on and so like for the rest of the

448
00:15:52,720 --> 00:15:54,000
lecture you're a little bit more

449
00:15:54,000 --> 00:15:57,040
simpler uh sp picture

450
00:15:57,040 --> 00:16:00,240
uh and the picture guys you really you

451
00:16:00,240 --> 00:16:02,639
should you're in your head

452
00:16:02,639 --> 00:16:04,480
and you probably developed uh while

453
00:16:04,480 --> 00:16:08,639
doing the lab is as follows

454
00:16:08,639 --> 00:16:13,279
basically have our risk four processors

455
00:16:13,279 --> 00:16:19,110
for the course so here's our risk five

456
00:16:19,120 --> 00:16:22,079
and you know there is this five uh

457
00:16:22,079 --> 00:16:23,759
courses execute the instructions

458
00:16:23,759 --> 00:16:26,160
uh that you know you're you're writing

459
00:16:26,160 --> 00:16:27,440
and you can just think about them

460
00:16:27,440 --> 00:16:28,160
they're sort of

461
00:16:28,160 --> 00:16:29,920
all connected to a boss and there's a

462
00:16:29,920 --> 00:16:32,160
little bit of a simplification but like

463
00:16:32,160 --> 00:16:33,519
it makes it easier to

464
00:16:33,519 --> 00:16:36,079
explain things and so like on the boss

465
00:16:36,079 --> 00:16:37,279
you know there's the random access

466
00:16:37,279 --> 00:16:40,069
memory

467
00:16:40,079 --> 00:16:42,079
where all the data you know the kernel

468
00:16:42,079 --> 00:16:43,199
actually uses is

469
00:16:43,199 --> 00:16:44,720
historic you know the kernel taxes

470
00:16:44,720 --> 00:16:46,240
itself is stored you know we've looked

471
00:16:46,240 --> 00:16:46,880
at there's a

472
00:16:46,880 --> 00:16:47,920
great amount of detail in the beginning

473
00:16:47,920 --> 00:16:49,680
of the semester and then in this you

474
00:16:49,680 --> 00:16:51,040
know for this particular lab the thing

475
00:16:51,040 --> 00:16:53,600
that's interesting is that on the bus

476
00:16:53,600 --> 00:16:57,199
uh is actually uh the network cart

477
00:16:57,199 --> 00:17:01,910
you know the e15 that you want thousand

478
00:17:01,920 --> 00:17:04,720
and you know the the ram is generally

479
00:17:04,720 --> 00:17:06,640
more connected to the risk fly processor

480
00:17:06,640 --> 00:17:08,400
directly with some private bus

481
00:17:08,400 --> 00:17:11,199
uh and network the devices intentionally

482
00:17:11,199 --> 00:17:12,480
tend to be on a slower

483
00:17:12,480 --> 00:17:14,240
type of bus and in particular the bus

484
00:17:14,240 --> 00:17:16,079
that uh in the lab you know there's a

485
00:17:16,079 --> 00:17:17,039
pci a

486
00:17:17,039 --> 00:17:20,400
pcie bus that actually connects

487
00:17:20,400 --> 00:17:23,280
the processor part you know with the

488
00:17:23,280 --> 00:17:27,990
network card

489
00:17:28,000 --> 00:17:29,280
now to get the network card to do

490
00:17:29,280 --> 00:17:31,919
something the network card you know has

491
00:17:31,919 --> 00:17:33,600
a controller inside of it

492
00:17:33,600 --> 00:17:35,120
and you know these controllers has

493
00:17:35,120 --> 00:17:37,679
registers

494
00:17:37,679 --> 00:17:40,799
and you can one of the cool aspects of

495
00:17:40,799 --> 00:17:41,679
you know these

496
00:17:41,679 --> 00:17:43,840
registers they're called like memory

497
00:17:43,840 --> 00:17:44,880
mapped

498
00:17:44,880 --> 00:17:47,520
io registers and so you could just write

499
00:17:47,520 --> 00:17:49,679
them with you know whatever star

500
00:17:49,679 --> 00:17:52,799
you know ox and whatever the value is

501
00:17:52,799 --> 00:17:54,559
you know for in the physical memory

502
00:17:54,559 --> 00:17:56,400
space what the value is for that

503
00:17:56,400 --> 00:17:57,600
particular reticent

504
00:17:57,600 --> 00:17:58,960
you know it's like we might have our

505
00:17:58,960 --> 00:18:02,240
head our tail register

506
00:18:02,240 --> 00:18:04,880
and you know we can the driver can you

507
00:18:04,880 --> 00:18:07,039
know write those by executing you know a

508
00:18:07,039 --> 00:18:08,640
load or restore instruction

509
00:18:08,640 --> 00:18:10,559
you know to the address you know that

510
00:18:10,559 --> 00:18:12,559
corresponds you know in the physical

511
00:18:12,559 --> 00:18:13,520
address space

512
00:18:13,520 --> 00:18:16,160
to the location of that register and the

513
00:18:16,160 --> 00:18:17,200
hardware will ensure

514
00:18:17,200 --> 00:18:19,280
when we do load the store you know that

515
00:18:19,280 --> 00:18:20,960
that store will either go you know we'll

516
00:18:20,960 --> 00:18:22,640
go to the uh

517
00:18:22,640 --> 00:18:24,400
if it is now to one of the controllers

518
00:18:24,400 --> 00:18:25,840
it will go to the control registers

519
00:18:25,840 --> 00:18:28,160
if it goes to you know one address is in

520
00:18:28,160 --> 00:18:31,120
ram we can all go to the ram

521
00:18:31,120 --> 00:18:32,480
and so you can just manipulate or

522
00:18:32,480 --> 00:18:34,320
program uh the

523
00:18:34,320 --> 00:18:36,640
network card by loading you know reading

524
00:18:36,640 --> 00:18:37,360
and writing

525
00:18:37,360 --> 00:18:39,039
these controller editors and basically

526
00:18:39,039 --> 00:18:40,720
the bits in these controller registers

527
00:18:40,720 --> 00:18:43,520
have special meaning as you have seen

528
00:18:43,520 --> 00:18:46,559
um now for this particular card you know

529
00:18:46,559 --> 00:18:46,880
the

530
00:18:46,880 --> 00:18:48,480
network card needs to send of course

531
00:18:48,480 --> 00:18:49,919
packets across the network

532
00:18:49,919 --> 00:18:51,280
and you know and it needs to get the

533
00:18:51,280 --> 00:18:52,960
packet somewhere

534
00:18:52,960 --> 00:18:55,840
and so uh the packets actually live you

535
00:18:55,840 --> 00:18:56,080
know

536
00:18:56,080 --> 00:18:58,320
are allocated as we'll see in a second

537
00:18:58,320 --> 00:18:59,360
you know they just live somewhere in

538
00:18:59,360 --> 00:19:02,789
memory

539
00:19:02,799 --> 00:19:05,760
and and what we do is and in fact in

540
00:19:05,760 --> 00:19:07,200
addition to these packets you know there

541
00:19:07,200 --> 00:19:08,000
are sort of two

542
00:19:08,000 --> 00:19:09,440
ring structures that also leave in

543
00:19:09,440 --> 00:19:14,390
memory

544
00:19:14,400 --> 00:19:19,190
and uh

545
00:19:19,200 --> 00:19:22,080
and we can you know program uh and we

546
00:19:22,080 --> 00:19:23,760
can tell the cart you know the card also

547
00:19:23,760 --> 00:19:25,440
knows where these ring structures are

548
00:19:25,440 --> 00:19:26,240
you know it has an

549
00:19:26,240 --> 00:19:28,559
address for where the you know tx ring

550
00:19:28,559 --> 00:19:30,320
is you know it has an address for where

551
00:19:30,320 --> 00:19:31,280
the

552
00:19:31,280 --> 00:19:34,480
rx ring is and you know the hardware

553
00:19:34,480 --> 00:19:34,960
card

554
00:19:34,960 --> 00:19:37,679
you know looks at those addresses to

555
00:19:37,679 --> 00:19:39,280
actually see which packets need to be

556
00:19:39,280 --> 00:19:39,679
sent

557
00:19:39,679 --> 00:19:41,919
and so here we might have a queue of you

558
00:19:41,919 --> 00:19:43,679
know packets that need to be transmitted

559
00:19:43,679 --> 00:19:45,039
or a few packets that needs to be

560
00:19:45,039 --> 00:19:48,870
received

561
00:19:48,880 --> 00:19:54,160
and uh you know the e1000 you know

562
00:19:54,160 --> 00:19:57,039
uh dmas you know if for example like you

563
00:19:57,039 --> 00:19:57,679
know there's

564
00:19:57,679 --> 00:19:59,919
it's gonna work on uh like the first

565
00:19:59,919 --> 00:20:01,760
factor two cents you know it will dma

566
00:20:01,760 --> 00:20:02,960
basically you know those

567
00:20:02,960 --> 00:20:05,200
packets you know the data associated

568
00:20:05,200 --> 00:20:06,400
with the packets

569
00:20:06,400 --> 00:20:08,640
you know straight from ram to the

570
00:20:08,640 --> 00:20:09,919
network

571
00:20:09,919 --> 00:20:11,520
without actually having the processor

572
00:20:11,520 --> 00:20:13,360
involved at all so this is what i call

573
00:20:13,360 --> 00:20:19,270
dma direct memory access

574
00:20:19,280 --> 00:20:23,039
okay does this make sense

575
00:20:23,039 --> 00:20:25,840
in terms of a more abstract picture uh

576
00:20:25,840 --> 00:20:26,799
for the

577
00:20:26,799 --> 00:20:30,159
organization of the risk 5

578
00:20:30,159 --> 00:20:33,919
ram and the e1000 any questions about

579
00:20:33,919 --> 00:20:41,430
this

580
00:20:41,440 --> 00:20:43,039
so one thing in the talking about sort

581
00:20:43,039 --> 00:20:44,480
of this hardware hardware and hardware

582
00:20:44,480 --> 00:20:45,600
software concurrency

583
00:20:45,600 --> 00:20:48,640
clearly you know the e1000 and

584
00:20:48,640 --> 00:20:50,640
you know the processor are both

585
00:20:50,640 --> 00:20:51,679
manipulating these

586
00:20:51,679 --> 00:20:55,520
transmission and reception cues or

587
00:20:55,520 --> 00:20:57,919
uh rings and so there has to be some

588
00:20:57,919 --> 00:20:58,720
protocol

589
00:20:58,720 --> 00:21:00,480
sort of given taken give and take

590
00:21:00,480 --> 00:21:01,760
protocol where

591
00:21:01,760 --> 00:21:03,760
you know at some point particular parts

592
00:21:03,760 --> 00:21:04,799
of the ring are

593
00:21:04,799 --> 00:21:07,200
operated through are owned or operated

594
00:21:07,200 --> 00:21:07,840
by the

595
00:21:07,840 --> 00:21:09,760
net network card and that are parts that

596
00:21:09,760 --> 00:21:11,679
are maybe under control of the software

597
00:21:11,679 --> 00:21:13,520
or the os or the kernel

598
00:21:13,520 --> 00:21:14,720
and you know we'll see in a second how

599
00:21:14,720 --> 00:21:17,039
that is arranged but you know we got a

600
00:21:17,039 --> 00:21:18,640
little bit careful and again that the

601
00:21:18,640 --> 00:21:18,960
car

602
00:21:18,960 --> 00:21:22,240
doesn't triple over uh or trip over

603
00:21:22,240 --> 00:21:23,600
the operating system or the other way

604
00:21:23,600 --> 00:21:28,470
around

605
00:21:28,480 --> 00:21:31,360
a quick question so is there um a

606
00:21:31,360 --> 00:21:31,840
separate

607
00:21:31,840 --> 00:21:34,480
like transmit ring and and receiver in

608
00:21:34,480 --> 00:21:35,120
the ram

609
00:21:35,120 --> 00:21:38,320
and then in uh also in the e100

610
00:21:38,320 --> 00:21:41,280
or e1000 uh driver yeah well the one

611
00:21:41,280 --> 00:21:42,799
weight thing okay so there's two things

612
00:21:42,799 --> 00:21:44,480
going on and we'll look at the code in a

613
00:21:44,480 --> 00:21:45,120
second

614
00:21:45,120 --> 00:21:48,720
uh the the the transmission ring

615
00:21:48,720 --> 00:21:50,720
and the receiver ring basically live in

616
00:21:50,720 --> 00:21:52,640
ram and both

617
00:21:52,640 --> 00:21:56,000
the e1000 and the risc-5 manipulate

618
00:21:56,000 --> 00:21:57,919
you know the ring that actually stored

619
00:21:57,919 --> 00:22:00,080
in ram

620
00:22:00,080 --> 00:22:03,280
um and those those are the the rings

621
00:22:03,280 --> 00:22:04,159
that you saw in the hardware

622
00:22:04,159 --> 00:22:05,520
documentation

623
00:22:05,520 --> 00:22:07,679
it happens to be the case that xv6 also

624
00:22:07,679 --> 00:22:10,559
has a you know the driver maintains a

625
00:22:10,559 --> 00:22:13,840
a sort of a ring of m buffs separately

626
00:22:13,840 --> 00:22:16,400
of the transmit ring and the rx

627
00:22:16,400 --> 00:22:18,080
range so like there's something like tx

628
00:22:18,080 --> 00:22:21,350
in boss

629
00:22:21,360 --> 00:22:23,039
and that's you know that is a data

630
00:22:23,039 --> 00:22:24,480
structure that only the operating system

631
00:22:24,480 --> 00:22:25,760
really knows about you know

632
00:22:25,760 --> 00:22:27,679
the the network card doesn't really know

633
00:22:27,679 --> 00:22:30,559
about it network card only knows about

634
00:22:30,559 --> 00:22:34,159
uh the the tx ring and rx rim

635
00:22:34,159 --> 00:22:35,600
because those are the values that were

636
00:22:35,600 --> 00:22:37,679
programmed into the registers

637
00:22:37,679 --> 00:22:39,360
saying like here's where you can find

638
00:22:39,360 --> 00:22:40,720
here's the address where you can find

639
00:22:40,720 --> 00:22:41,440
the transmitter

640
00:22:41,440 --> 00:22:42,640
here's the address where you can find

641
00:22:42,640 --> 00:22:44,480
the receiver okay

642
00:22:44,480 --> 00:22:46,400
yeah that makes sense that makes sense

643
00:22:46,400 --> 00:22:49,750
yeah

644
00:22:49,760 --> 00:22:51,360
okay so that's sort of the hardware

645
00:22:51,360 --> 00:22:54,240
picture in a more schematic

646
00:22:54,240 --> 00:22:56,799
version uh actually let's talk a little

647
00:22:56,799 --> 00:22:59,520
bit about the software structure

648
00:22:59,520 --> 00:23:01,039
and it's a bit confusing actually in

649
00:23:01,039 --> 00:23:03,520
this uh in in this lab

650
00:23:03,520 --> 00:23:10,710
so software structure

651
00:23:10,720 --> 00:23:13,760
um so you know let's just

652
00:23:13,760 --> 00:23:15,360
draw you know the thing that we most

653
00:23:15,360 --> 00:23:16,720
care about of course is here now the

654
00:23:16,720 --> 00:23:17,280
driver

655
00:23:17,280 --> 00:23:20,400
so here's our driver uh

656
00:23:20,400 --> 00:23:26,149
the e1000 driver

657
00:23:26,159 --> 00:23:28,159
and you know it basically has only two

658
00:23:28,159 --> 00:23:29,919
functions it has the

659
00:23:29,919 --> 00:23:35,190
transmit function

660
00:23:35,200 --> 00:23:40,950
and it has the receive function

661
00:23:40,960 --> 00:23:43,120
and the receive function runs in

662
00:23:43,120 --> 00:23:45,039
response to interrupts

663
00:23:45,039 --> 00:23:48,559
so an interrupt happens

664
00:23:48,559 --> 00:23:51,360
then you know xv6 you know we'll use the

665
00:23:51,360 --> 00:23:52,640
with the usual

666
00:23:52,640 --> 00:23:54,480
interrupt mechanism you know a trap will

667
00:23:54,480 --> 00:23:56,640
happen the trap will look you know to

668
00:23:56,640 --> 00:23:57,760
see if there's an interrupt from the

669
00:23:57,760 --> 00:23:59,440
network card if there's an interrupt in

670
00:23:59,440 --> 00:24:00,480
the network card it will call the

671
00:24:00,480 --> 00:24:02,559
receive function

672
00:24:02,559 --> 00:24:04,480
and as you remember you know we used to

673
00:24:04,480 --> 00:24:06,320
you know in one of the previous lectures

674
00:24:06,320 --> 00:24:07,520
about device drivers

675
00:24:07,520 --> 00:24:08,960
you know it's often helpful to think of

676
00:24:08,960 --> 00:24:10,720
the device drivers are split in two

677
00:24:10,720 --> 00:24:11,600
parts

678
00:24:11,600 --> 00:24:14,320
you know the the bottom half which runs

679
00:24:14,320 --> 00:24:17,840
in the context of an interrupt handler

680
00:24:17,840 --> 00:24:19,760
the typical name for you used in the top

681
00:24:19,760 --> 00:24:22,789
half

682
00:24:22,799 --> 00:24:25,679
which generally runs in the context of

683
00:24:25,679 --> 00:24:26,320
uh

684
00:24:26,320 --> 00:24:28,400
a you know kernel process or like a

685
00:24:28,400 --> 00:24:29,919
usual of a process so for example if

686
00:24:29,919 --> 00:24:30,880
you're thinking about

687
00:24:30,880 --> 00:24:32,880
you know things that sit on top of here

688
00:24:32,880 --> 00:24:34,320
uh there's a

689
00:24:34,320 --> 00:24:36,159
the network stack you know the code that

690
00:24:36,159 --> 00:24:38,159
actually implements you know ip

691
00:24:38,159 --> 00:24:41,440
uh udp et cetera sits sort of above this

692
00:24:41,440 --> 00:24:44,000
and then you know there's you know our

693
00:24:44,000 --> 00:24:44,799
usual

694
00:24:44,799 --> 00:24:47,840
you know sort of line of you know kernel

695
00:24:47,840 --> 00:24:49,679
space blow user space what

696
00:24:49,679 --> 00:24:52,799
up and this is a very os view of the

697
00:24:52,799 --> 00:24:53,279
world

698
00:24:53,279 --> 00:24:55,600
where like use space is not particularly

699
00:24:55,600 --> 00:24:57,200
that big or important

700
00:24:57,200 --> 00:25:00,480
and uh you know example our t whatever

701
00:25:00,480 --> 00:25:01,120
net test

702
00:25:01,120 --> 00:25:02,640
you can use a lot of program correct

703
00:25:02,640 --> 00:25:04,799
that runs user space

704
00:25:04,799 --> 00:25:07,039
and it makes system calls the system

705
00:25:07,039 --> 00:25:09,120
goals go to the

706
00:25:09,120 --> 00:25:12,400
uh the network stack uh and example

707
00:25:12,400 --> 00:25:16,559
i give you the calls to write

708
00:25:16,559 --> 00:25:19,520
system call with a file descriptor the

709
00:25:19,520 --> 00:25:20,320
kernel knows

710
00:25:20,320 --> 00:25:21,919
you know for that file descriptor if you

711
00:25:21,919 --> 00:25:23,760
do it right then you know the right

712
00:25:23,760 --> 00:25:25,520
should go to the network stack

713
00:25:25,520 --> 00:25:27,600
the network stack builds up the packets

714
00:25:27,600 --> 00:25:30,799
and then it calls transmit

715
00:25:30,799 --> 00:25:32,400
and then transmit you know whatever

716
00:25:32,400 --> 00:25:34,240
manipulates the uh

717
00:25:34,240 --> 00:25:36,799
transmission queue the tx cue or ring

718
00:25:36,799 --> 00:25:38,720
and you know that actually gets packets

719
00:25:38,720 --> 00:25:40,080
you know off the network you know at

720
00:25:40,080 --> 00:25:41,440
some point their response might come

721
00:25:41,440 --> 00:25:42,000
with that

722
00:25:42,000 --> 00:25:43,520
come back you know that will generate an

723
00:25:43,520 --> 00:25:45,360
interrupt and then the receive function

724
00:25:45,360 --> 00:25:47,440
will run and inspect you know the

725
00:25:47,440 --> 00:25:50,720
uh receive ring right

726
00:25:50,720 --> 00:25:52,240
so there's a couple things that you know

727
00:25:52,240 --> 00:25:53,760
you want to

728
00:25:53,760 --> 00:25:55,520
i want to point out you know in terms of

729
00:25:55,520 --> 00:25:58,720
concurrency uh

730
00:25:58,720 --> 00:25:59,919
so first of all like you know the

731
00:25:59,919 --> 00:26:01,919
interrupt handler basically can run

732
00:26:01,919 --> 00:26:04,159
at any instant in time right uh you know

733
00:26:04,159 --> 00:26:05,600
we might be in user space and if the

734
00:26:05,600 --> 00:26:06,400
interrupt comes in

735
00:26:06,400 --> 00:26:08,640
you know the interrupt mechanism will

736
00:26:08,640 --> 00:26:10,000
cost you know the

737
00:26:10,000 --> 00:26:11,919
current the user program to switch to

738
00:26:11,919 --> 00:26:13,600
the kernel mode you know the trap

739
00:26:13,600 --> 00:26:15,440
functionality uh code that we've seen

740
00:26:15,440 --> 00:26:16,640
before runs and

741
00:26:16,640 --> 00:26:18,240
it will all receive so we might be in

742
00:26:18,240 --> 00:26:19,840
the middle of some usual

743
00:26:19,840 --> 00:26:21,200
process and boom you know we get an

744
00:26:21,200 --> 00:26:22,320
interrupt and suddenly we're in the

745
00:26:22,320 --> 00:26:24,799
receive function and even in the kernel

746
00:26:24,799 --> 00:26:25,600
like if we're

747
00:26:25,600 --> 00:26:27,279
not holding locks you know watch turn

748
00:26:27,279 --> 00:26:28,559
the interrupts off but if we were not

749
00:26:28,559 --> 00:26:30,000
holding locks you know we could get an

750
00:26:30,000 --> 00:26:30,559
interrupt

751
00:26:30,559 --> 00:26:34,080
and the kernel may change the program

752
00:26:34,080 --> 00:26:35,840
counter basically to the

753
00:26:35,840 --> 00:26:38,320
interrupt handler and run the receive

754
00:26:38,320 --> 00:26:39,440
function

755
00:26:39,440 --> 00:26:41,200
so this code sort of runs you know the

756
00:26:41,200 --> 00:26:42,640
things that in the bottom half you know

757
00:26:42,640 --> 00:26:43,279
can basically

758
00:26:43,279 --> 00:26:46,320
run instantly almost any time

759
00:26:46,320 --> 00:26:48,799
and the code that in the top half it

760
00:26:48,799 --> 00:26:50,480
really operates on behalf

761
00:26:50,480 --> 00:26:52,880
of usual level processes or kernel

762
00:26:52,880 --> 00:26:54,240
threads that actually make

763
00:26:54,240 --> 00:26:57,840
calls into the uh the top half and

764
00:26:57,840 --> 00:26:59,360
you know easily it could have been the

765
00:26:59,360 --> 00:27:01,120
case correctly in fact this is the case

766
00:27:01,120 --> 00:27:02,559
even in that test you know we might

767
00:27:02,559 --> 00:27:03,360
actually have

768
00:27:03,360 --> 00:27:05,840
um net text actually a forks you know a

769
00:27:05,840 --> 00:27:07,360
whole bunch of processes

770
00:27:07,360 --> 00:27:09,279
so we have actually many instances in

771
00:27:09,279 --> 00:27:10,880
one of the tests we have many many

772
00:27:10,880 --> 00:27:14,630
instances of net tests running

773
00:27:14,640 --> 00:27:16,400
and they all jump into you know the

774
00:27:16,400 --> 00:27:17,760
network stack and they all

775
00:27:17,760 --> 00:27:21,039
you know then called transmit right so

776
00:27:21,039 --> 00:27:22,480
that is the case so we're looking at

777
00:27:22,480 --> 00:27:24,399
this from the perspective concurrency

778
00:27:24,399 --> 00:27:27,200
uh multiple zenders uh can be actually

779
00:27:27,200 --> 00:27:28,799
in the context that can be in the top

780
00:27:28,799 --> 00:27:29,200
half

781
00:27:29,200 --> 00:27:30,640
and so it's pretty clear that you know

782
00:27:30,640 --> 00:27:32,720
we need some locking scheme

783
00:27:32,720 --> 00:27:35,520
or discipline to at least you know make

784
00:27:35,520 --> 00:27:36,320
sure that the

785
00:27:36,320 --> 00:27:38,159
different senders don't uh trip over

786
00:27:38,159 --> 00:27:39,520
each other

787
00:27:39,520 --> 00:27:42,720
okay then on the bottom half there's

788
00:27:42,720 --> 00:27:43,600
only one

789
00:27:43,600 --> 00:27:45,360
interrupt handler correct if there's

790
00:27:45,360 --> 00:27:46,799
never the case that receive is going to

791
00:27:46,799 --> 00:27:47,679
be called by

792
00:27:47,679 --> 00:27:49,679
multiple there are multiple receives

793
00:27:49,679 --> 00:27:51,360
running at the same time

794
00:27:51,360 --> 00:27:52,880
in parallel in different course you know

795
00:27:52,880 --> 00:27:55,360
the interrupt handler uh

796
00:27:55,360 --> 00:27:58,240
when an interrupt happens uh the process

797
00:27:58,240 --> 00:27:59,520
is alerted

798
00:27:59,520 --> 00:28:02,159
um and if future interrupts happen

799
00:28:02,159 --> 00:28:03,200
they're actually

800
00:28:03,200 --> 00:28:05,600
blocked until the current interrupt

801
00:28:05,600 --> 00:28:06,720
actually is dealt with

802
00:28:06,720 --> 00:28:09,760
and so in fact uh

803
00:28:09,760 --> 00:28:12,240
the when the receive function runs uh

804
00:28:12,240 --> 00:28:14,080
there's actually only one

805
00:28:14,080 --> 00:28:17,200
interruption running uh at the time that

806
00:28:17,200 --> 00:28:18,720
calls receive

807
00:28:18,720 --> 00:28:21,360
and so there's no real immediately

808
00:28:21,360 --> 00:28:22,480
concurrency

809
00:28:22,480 --> 00:28:25,760
uh in receive itself although uh of

810
00:28:25,760 --> 00:28:26,880
course the

811
00:28:26,880 --> 00:28:29,600
the transmit you know threats can run in

812
00:28:29,600 --> 00:28:31,279
currently with the interrupt handler for

813
00:28:31,279 --> 00:28:32,960
example we might have one core running

814
00:28:32,960 --> 00:28:34,240
in the interrupt handler

815
00:28:34,240 --> 00:28:35,840
and we may have another core again it

816
00:28:35,840 --> 00:28:39,760
actually is about to transmit

817
00:28:39,760 --> 00:28:45,909
is this any questions about this

818
00:28:45,919 --> 00:28:49,590
it's sort of important to have

819
00:28:49,600 --> 00:28:52,240
to understand it's a bit of review but

820
00:28:52,240 --> 00:29:00,310
you know that's important too

821
00:29:00,320 --> 00:29:03,039
okay so i guess i have a general

822
00:29:03,039 --> 00:29:03,919
question

823
00:29:03,919 --> 00:29:06,960
how do we know what is supposed to be

824
00:29:06,960 --> 00:29:08,480
classified as a bottom

825
00:29:08,480 --> 00:29:11,919
half and a top half ah so yeah uh i

826
00:29:11,919 --> 00:29:13,120
think the way to think about it is that

827
00:29:13,120 --> 00:29:14,559
anything that runs in the context of an

828
00:29:14,559 --> 00:29:17,279
interrupt handler that's the bottom half

829
00:29:17,279 --> 00:29:18,799
and in this case it's basically just

830
00:29:18,799 --> 00:29:20,640
receive

831
00:29:20,640 --> 00:29:22,640
and anything that runs in the context of

832
00:29:22,640 --> 00:29:24,799
a regular process

833
00:29:24,799 --> 00:29:26,880
or fret or kernel fret you know that's

834
00:29:26,880 --> 00:29:32,149
the top half

835
00:29:32,159 --> 00:29:34,960
okay um so if you look at this picture

836
00:29:34,960 --> 00:29:36,799
uh

837
00:29:36,799 --> 00:29:39,039
a little bit more since we're you know

838
00:29:39,039 --> 00:29:40,640
actually let me make a

839
00:29:40,640 --> 00:29:42,559
high level statement here a lot of

840
00:29:42,559 --> 00:29:43,760
people ask you know

841
00:29:43,760 --> 00:29:47,200
why no lock and receive and

842
00:29:47,200 --> 00:29:50,559
uh where is a lock needed and

843
00:29:50,559 --> 00:29:53,600
so the first glance uh

844
00:29:53,600 --> 00:29:55,520
it might not be necessary that lock is

845
00:29:55,520 --> 00:29:56,799
necessary correct because there's only

846
00:29:56,799 --> 00:29:57,200
one

847
00:29:57,200 --> 00:30:00,000
instance of receive running so there's

848
00:30:00,000 --> 00:30:01,440
not multiple instances of procedure

849
00:30:01,440 --> 00:30:02,720
running at the same time

850
00:30:02,720 --> 00:30:04,559
and so these receives since there's only

851
00:30:04,559 --> 00:30:05,919
one receive you know it doesn't share

852
00:30:05,919 --> 00:30:07,360
data structures with any other receive

853
00:30:07,360 --> 00:30:08,000
because there's only

854
00:30:08,000 --> 00:30:10,320
one of them right now of course it could

855
00:30:10,320 --> 00:30:11,679
be the case that the receive and the

856
00:30:11,679 --> 00:30:12,480
transmitter

857
00:30:12,480 --> 00:30:14,480
share data structures but as we see in a

858
00:30:14,480 --> 00:30:17,200
second that actually is not the case

859
00:30:17,200 --> 00:30:19,279
basically the mission part of the driver

860
00:30:19,279 --> 00:30:21,919
is completely separate from the

861
00:30:21,919 --> 00:30:23,919
reception part of the driver or the

862
00:30:23,919 --> 00:30:26,240
receiving packets and so as a result

863
00:30:26,240 --> 00:30:27,919
this machine doesn't really

864
00:30:27,919 --> 00:30:29,760
doesn't need actual blocks you know it's

865
00:30:29,760 --> 00:30:31,279
really not sharing data data structures

866
00:30:31,279 --> 00:30:35,190
with any other concurrent activity

867
00:30:35,200 --> 00:30:36,799
the weird part is that you know some of

868
00:30:36,799 --> 00:30:39,679
you if i found out if you do use a lock

869
00:30:39,679 --> 00:30:42,880
uh you actually get a panic and so let

870
00:30:42,880 --> 00:30:43,360
me

871
00:30:43,360 --> 00:30:46,399
say a little bit about that because the

872
00:30:46,399 --> 00:30:46,799
reason

873
00:30:46,799 --> 00:30:48,080
you know that panic happens is a little

874
00:30:48,080 --> 00:30:49,919
bit because there's a this

875
00:30:49,919 --> 00:30:51,679
the software structure actually in the

876
00:30:51,679 --> 00:30:54,399
e1 in the xv6 kernel slightly

877
00:30:54,399 --> 00:30:57,840
uh uh slightly more complicated

878
00:30:57,840 --> 00:31:00,240
than you might think and and the reason

879
00:31:00,240 --> 00:31:01,519
is that basically the

880
00:31:01,519 --> 00:31:03,679
receive uh interrupt hand election does

881
00:31:03,679 --> 00:31:05,200
quite a bit of work

882
00:31:05,200 --> 00:31:07,360
or can do quite a bit of work so let me

883
00:31:07,360 --> 00:31:09,600
talk a little bit about it

884
00:31:09,600 --> 00:31:11,039
and the particular case that actually

885
00:31:11,039 --> 00:31:12,880
where does quite a bit of work is for

886
00:31:12,880 --> 00:31:16,830
example arp

887
00:31:16,840 --> 00:31:19,440
requests

888
00:31:19,440 --> 00:31:21,360
okay so arp is one of those packet types

889
00:31:21,360 --> 00:31:22,960
that uh robert talked about a little

890
00:31:22,960 --> 00:31:23,919
while ago

891
00:31:23,919 --> 00:31:25,679
uh but basically what happens like like

892
00:31:25,679 --> 00:31:27,440
an interrupt comes in

893
00:31:27,440 --> 00:31:30,799
so an arp request you know for

894
00:31:30,799 --> 00:31:32,559
the discover but the ethernet address is

895
00:31:32,559 --> 00:31:34,080
where uh an

896
00:31:34,080 --> 00:31:36,880
ip address you know comes in you know uh

897
00:31:36,880 --> 00:31:37,760
that will call

898
00:31:37,760 --> 00:31:43,990
you know e1000 receive

899
00:31:44,000 --> 00:31:46,640
and you know we'll call whatever net rx

900
00:31:46,640 --> 00:31:47,679
so that will go

901
00:31:47,679 --> 00:31:50,080
call into the network stack on the

902
00:31:50,080 --> 00:31:51,039
previous

903
00:31:51,039 --> 00:31:54,000
picture so that receive calls calls into

904
00:31:54,000 --> 00:31:56,399
this code over here

905
00:31:56,399 --> 00:32:03,669
um that receive you know calls oops

906
00:32:03,679 --> 00:32:07,039
receive calls uh net

907
00:32:07,039 --> 00:32:12,630
rx arf

908
00:32:12,640 --> 00:32:15,120
and it uh and you know it looks you can

909
00:32:15,120 --> 00:32:16,480
see how there's an art packet

910
00:32:16,480 --> 00:32:18,320
and basically it sends back you know the

911
00:32:18,320 --> 00:32:19,760
ethernet address runner for this

912
00:32:19,760 --> 00:32:20,880
particular

913
00:32:20,880 --> 00:32:24,240
uh for uh for for xc6

914
00:32:24,240 --> 00:32:26,080
and and the way he does that of course

915
00:32:26,080 --> 00:32:27,279
you know to send the packet

916
00:32:27,279 --> 00:32:31,750
it will call you know e1000

917
00:32:31,760 --> 00:32:36,389
transmit

918
00:32:36,399 --> 00:32:38,480
right and you know we know that we'll

919
00:32:38,480 --> 00:32:42,000
actually need to acquire a lock

920
00:32:42,000 --> 00:32:43,679
all of you did that you know whatever

921
00:32:43,679 --> 00:32:45,039
there's the e1000

922
00:32:45,039 --> 00:32:50,389
lock

923
00:32:50,399 --> 00:32:52,080
and the reason that actually has to

924
00:32:52,080 --> 00:32:53,519
acquire your lock is because there might

925
00:32:53,519 --> 00:32:54,399
be multiple

926
00:32:54,399 --> 00:32:56,080
senders and you know the sender should

927
00:32:56,080 --> 00:32:57,760
not trip over uh

928
00:32:57,760 --> 00:33:01,200
over and trip over each other um

929
00:33:01,200 --> 00:33:02,640
so that's sort of the picture so what we

930
00:33:02,640 --> 00:33:04,159
basically in terms of this previous

931
00:33:04,159 --> 00:33:06,559
picture what we're seeing here is that

932
00:33:06,559 --> 00:33:09,590
the bottom half

933
00:33:09,600 --> 00:33:11,919
may end up you know calling code in the

934
00:33:11,919 --> 00:33:12,880
top half

935
00:33:12,880 --> 00:33:14,880
and then come back into the driver

936
00:33:14,880 --> 00:33:17,360
through the top half

937
00:33:17,360 --> 00:33:20,159
and a number of you know you run into

938
00:33:20,159 --> 00:33:21,600
trouble with that because

939
00:33:21,600 --> 00:33:24,799
you know the uh you know it's not 100

940
00:33:24,799 --> 00:33:26,080
clear that you didn't need

941
00:33:26,080 --> 00:33:29,120
uh locks in the receiving thing uh

942
00:33:29,120 --> 00:33:31,120
part and so quite a number you ran into

943
00:33:31,120 --> 00:33:32,480
this particular bug where

944
00:33:32,480 --> 00:33:37,269
you know you actually acquired

945
00:33:37,279 --> 00:33:42,710
the you know e1000 lock

946
00:33:42,720 --> 00:33:46,320
in receive and that worked all fine

947
00:33:46,320 --> 00:33:47,519
correctly except that once in a while

948
00:33:47,519 --> 00:33:49,600
you got to panic

949
00:33:49,600 --> 00:33:52,399
and why do you get the panic hopefully

950
00:33:52,399 --> 00:33:53,679
with this picture that's pretty clear

951
00:33:53,679 --> 00:33:59,269
but

952
00:33:59,279 --> 00:34:01,200
i mean isn't it going to be the same

953
00:34:01,200 --> 00:34:03,760
lock that e1000 transmit is going to try

954
00:34:03,760 --> 00:34:04,559
to acquire

955
00:34:04,559 --> 00:34:06,640
down the stock yeah exactly correct so

956
00:34:06,640 --> 00:34:09,040
the the e1500 here at this point now

957
00:34:09,040 --> 00:34:10,240
owns the walk

958
00:34:10,240 --> 00:34:13,359
holds it calls netrx calls net rxr email

959
00:34:13,359 --> 00:34:14,960
files to transmit then it calls the car

960
00:34:14,960 --> 00:34:15,679
again

961
00:34:15,679 --> 00:34:17,280
and as you might remember from previous

962
00:34:17,280 --> 00:34:18,960
laps if require

963
00:34:18,960 --> 00:34:22,000
uh is called and is already held uh

964
00:34:22,000 --> 00:34:22,960
that's a deadlock

965
00:34:22,960 --> 00:34:25,040
right and so you know the xv6 girdle

966
00:34:25,040 --> 00:34:28,069
panics

967
00:34:28,079 --> 00:34:30,399
got a question let's let's assume we had

968
00:34:30,399 --> 00:34:32,240
a slightly different implementation of

969
00:34:32,240 --> 00:34:34,000
locks such as those spendings are not

970
00:34:34,000 --> 00:34:35,440
occurring

971
00:34:35,440 --> 00:34:38,240
like they would let's assume like if i

972
00:34:38,240 --> 00:34:39,599
wanted to acquire a lot that i already

973
00:34:39,599 --> 00:34:41,119
held nothing happened

974
00:34:41,119 --> 00:34:44,000
yeah so uh these are these were called

975
00:34:44,000 --> 00:34:47,589
recursive logs

976
00:34:47,599 --> 00:34:50,000
or re-entering locks is another wave

977
00:34:50,000 --> 00:34:51,520
name for them

978
00:34:51,520 --> 00:34:53,520
and so if you have the recursive locks

979
00:34:53,520 --> 00:34:55,280
or re-entrant blocks then you know you

980
00:34:55,280 --> 00:34:55,760
could just

981
00:34:55,760 --> 00:34:57,040
freely do this and it would be no

982
00:34:57,040 --> 00:34:58,880
problem and

983
00:34:58,880 --> 00:35:01,200
i think one of you over email uh

984
00:35:01,200 --> 00:35:02,640
mentioned to me that actually

985
00:35:02,640 --> 00:35:04,240
they implemented recursive logs to

986
00:35:04,240 --> 00:35:05,520
exactly deal with this particular

987
00:35:05,520 --> 00:35:06,560
problem

988
00:35:06,560 --> 00:35:08,560
and so they did they required the locks

989
00:35:08,560 --> 00:35:11,359
in the uh e1000 received function

990
00:35:11,359 --> 00:35:13,920
uh and uh you know after the panic

991
00:35:13,920 --> 00:35:15,680
basically fixed you know acquiring lease

992
00:35:15,680 --> 00:35:16,079
in

993
00:35:16,079 --> 00:35:20,630
xv6 direction support uh recursive locks

994
00:35:20,640 --> 00:35:24,000
and i'll review solution uh the simple

995
00:35:24,000 --> 00:35:25,839
solution is a fine solution

996
00:35:25,839 --> 00:35:30,079
uh the solution that we intended and the

997
00:35:30,079 --> 00:35:32,320
the staff solution has is that basically

998
00:35:32,320 --> 00:35:33,680
it just doesn't require locks in

999
00:35:33,680 --> 00:35:34,640
retrieve

1000
00:35:34,640 --> 00:35:36,079
at all because it's actually turned out

1001
00:35:36,079 --> 00:35:39,910
not to be necessary

1002
00:35:39,920 --> 00:35:42,079
sorry can you say again why there could

1003
00:35:42,079 --> 00:35:43,119
be two

1004
00:35:43,119 --> 00:35:46,480
threads in receive

1005
00:35:46,480 --> 00:35:48,079
there's only one thread they receive the

1006
00:35:48,079 --> 00:35:49,760
interrupt handler runs

1007
00:35:49,760 --> 00:35:51,359
there's only one receive function ever

1008
00:35:51,359 --> 00:35:54,079
running at the time on any core

1009
00:35:54,079 --> 00:35:57,440
that actually calls into the top half

1010
00:35:57,440 --> 00:35:59,839
of the you know the top half of the

1011
00:35:59,839 --> 00:36:01,040
operating system

1012
00:36:01,040 --> 00:36:03,760
and that goes back out into the bottom

1013
00:36:03,760 --> 00:36:04,880
half

1014
00:36:04,880 --> 00:36:06,720
sorry not in the bottom that calls back

1015
00:36:06,720 --> 00:36:08,560
into e transmit and transmit

1016
00:36:08,560 --> 00:36:10,640
definitely needs to acquire a lock so

1017
00:36:10,640 --> 00:36:13,280
you want to receive e1500 receive

1018
00:36:13,280 --> 00:36:16,240
uh while holding the lock calls e1000

1019
00:36:16,240 --> 00:36:16,880
transmit

1020
00:36:16,880 --> 00:36:18,560
which tries to acquire the same lock

1021
00:36:18,560 --> 00:36:20,160
that the interrupt handler already

1022
00:36:20,160 --> 00:36:24,160
holds if you have if you're locked in

1023
00:36:24,160 --> 00:36:27,680
the receive handler i see

1024
00:36:27,680 --> 00:36:30,800
so so it is the case and

1025
00:36:30,800 --> 00:36:34,240
like one interrupt can go off and then

1026
00:36:34,240 --> 00:36:37,200
while it's still running another

1027
00:36:37,200 --> 00:36:39,440
interrupt could go off as well

1028
00:36:39,440 --> 00:36:41,200
no no no no no no no the the bigger

1029
00:36:41,200 --> 00:36:42,400
question maybe they'll go back to this

1030
00:36:42,400 --> 00:36:43,040
picture

1031
00:36:43,040 --> 00:36:45,359
so interrupt happens that calls the

1032
00:36:45,359 --> 00:36:46,640
receive function

1033
00:36:46,640 --> 00:36:48,000
there's only one receive function

1034
00:36:48,000 --> 00:36:50,480
running that receive function calls

1035
00:36:50,480 --> 00:36:53,920
you know rx net receive that calls rx

1036
00:36:53,920 --> 00:36:54,720
network c

1037
00:36:54,720 --> 00:36:57,359
arc and then that arp function calls

1038
00:36:57,359 --> 00:36:58,720
transmit

1039
00:36:58,720 --> 00:37:01,119
and if you were using the same lock in

1040
00:37:01,119 --> 00:37:02,560
transmit and receive

1041
00:37:02,560 --> 00:37:08,160
you know you would get a deadlock

1042
00:37:08,160 --> 00:37:13,430
okay i see thank you

1043
00:37:13,440 --> 00:37:16,160
and that's sort of okay and so basically

1044
00:37:16,160 --> 00:37:17,280
there's two solutions to this

1045
00:37:17,280 --> 00:37:20,320
you know one is to use recursive blocks

1046
00:37:20,320 --> 00:37:23,760
other solution was no locks in

1047
00:37:23,760 --> 00:37:26,800
receive or you know

1048
00:37:26,800 --> 00:37:31,030
have two locks

1049
00:37:31,040 --> 00:37:34,829
all three of them are totally reasonable

1050
00:37:34,839 --> 00:37:36,960
solutions

1051
00:37:36,960 --> 00:37:39,599
any questions about this would there be

1052
00:37:39,599 --> 00:37:40,880
a reason to have a lock

1053
00:37:40,880 --> 00:37:44,160
around uh receive at all no in this

1054
00:37:44,160 --> 00:37:45,200
particular case there's no

1055
00:37:45,200 --> 00:37:49,589
reason to have walk at all

1056
00:37:49,599 --> 00:37:51,920
what would be okay could we think of a

1057
00:37:51,920 --> 00:37:53,680
situation where you would want

1058
00:37:53,680 --> 00:37:55,119
a receive lock would it be like if you

1059
00:37:55,119 --> 00:37:57,119
had two network cards

1060
00:37:57,119 --> 00:38:00,160
or something yeah or uh

1061
00:38:00,160 --> 00:38:03,040
you'd like if you remember in the uart

1062
00:38:03,040 --> 00:38:04,000
code

1063
00:38:04,000 --> 00:38:07,520
uh okay so the the main

1064
00:38:07,520 --> 00:38:09,359
a common reason why you might want to

1065
00:38:09,359 --> 00:38:11,520
have a locking shared is because the

1066
00:38:11,520 --> 00:38:14,400
bottom half and the top half share data

1067
00:38:14,400 --> 00:38:17,109
structures

1068
00:38:17,119 --> 00:38:18,880
so for example the receive and the

1069
00:38:18,880 --> 00:38:20,720
transmit might uh manipulate the same

1070
00:38:20,720 --> 00:38:22,000
shared data structures

1071
00:38:22,000 --> 00:38:23,680
at that point you need a key you need a

1072
00:38:23,680 --> 00:38:25,280
lock and so for example you remember

1073
00:38:25,280 --> 00:38:27,359
from the console driver

1074
00:38:27,359 --> 00:38:31,200
they shared a queue and so the receive

1075
00:38:31,200 --> 00:38:33,440
handler needed to get a cue and needed

1076
00:38:33,440 --> 00:38:34,960
to get the lock to actually get access

1077
00:38:34,960 --> 00:38:39,270
to that view

1078
00:38:39,280 --> 00:38:42,480
does that answer your question

1079
00:38:42,480 --> 00:38:45,520
yeah thanks and so this brings me up

1080
00:38:45,520 --> 00:38:46,720
with a second sort of point that i

1081
00:38:46,720 --> 00:38:48,240
wanted to make

1082
00:38:48,240 --> 00:38:52,160
uh that the uh let me actually draw a

1083
00:38:52,160 --> 00:38:53,359
new picture because it gets a little bit

1084
00:38:53,359 --> 00:38:54,320
crowded

1085
00:38:54,320 --> 00:38:56,240
um so we think about the bottom half

1086
00:38:56,240 --> 00:39:00,560
again in the top half

1087
00:39:00,560 --> 00:39:01,599
so here's the bottom there's a little

1088
00:39:01,599 --> 00:39:03,760
bit abstract but you know this may be

1089
00:39:03,760 --> 00:39:05,520
helpful

1090
00:39:05,520 --> 00:39:09,839
um in much typically in much softer

1091
00:39:09,839 --> 00:39:12,800
uh driver shopper the bottom half

1092
00:39:12,800 --> 00:39:14,079
basically doesn't really

1093
00:39:14,079 --> 00:39:17,440
call in to the top half at all

1094
00:39:17,440 --> 00:39:18,960
so for example if you go back and you

1095
00:39:18,960 --> 00:39:21,440
look at the console code

1096
00:39:21,440 --> 00:39:23,839
this sequence of the sequence cannot

1097
00:39:23,839 --> 00:39:24,800
happen there and

1098
00:39:24,800 --> 00:39:26,320
the reason doesn't happen is because the

1099
00:39:26,320 --> 00:39:27,599
bottom half typically there's very

1100
00:39:27,599 --> 00:39:28,400
little work

1101
00:39:28,400 --> 00:39:29,839
you know the only thing it does maybe is

1102
00:39:29,839 --> 00:39:31,440
you know grab the packet and stick the

1103
00:39:31,440 --> 00:39:33,920
packet on the queue

1104
00:39:33,920 --> 00:39:35,920
and then at some point later you know

1105
00:39:35,920 --> 00:39:38,000
the the

1106
00:39:38,000 --> 00:39:39,440
top half you know there's a separate

1107
00:39:39,440 --> 00:39:41,040
thread that they're in the top half that

1108
00:39:41,040 --> 00:39:42,320
basically looks at that queue and then

1109
00:39:42,320 --> 00:39:43,920
grabs packets out of the queue and then

1110
00:39:43,920 --> 00:39:46,400
keeps on doing whatever needs to be done

1111
00:39:46,400 --> 00:39:46,960
now for

1112
00:39:46,960 --> 00:39:50,160
simplicity uh in this for simplicity and

1113
00:39:50,160 --> 00:39:51,920
you know to reduce the amount of code

1114
00:39:51,920 --> 00:39:53,359
that's not the structure that this

1115
00:39:53,359 --> 00:39:55,280
particular driver follows you know this

1116
00:39:55,280 --> 00:39:57,200
driver once in a while may actually call

1117
00:39:57,200 --> 00:39:58,560
up in you know

1118
00:39:58,560 --> 00:40:01,200
and call up actually sometimes this

1119
00:40:01,200 --> 00:40:02,960
structure is followed by the driver but

1120
00:40:02,960 --> 00:40:04,480
you know once a while it can actually go

1121
00:40:04,480 --> 00:40:05,680
into the top half

1122
00:40:05,680 --> 00:40:15,109
and come back out into the bottom half

1123
00:40:15,119 --> 00:40:23,109
any questions about this

1124
00:40:23,119 --> 00:40:26,000
okay so that's sort of i guess software

1125
00:40:26,000 --> 00:40:26,880
concurrency

1126
00:40:26,880 --> 00:40:28,880
uh and we'll come back to it more later

1127
00:40:28,880 --> 00:40:30,319
if we look at the code in a little bit

1128
00:40:30,319 --> 00:40:31,440
more detail

1129
00:40:31,440 --> 00:40:33,040
uh we'll talk a little bit about the

1130
00:40:33,040 --> 00:40:37,510
rings

1131
00:40:37,520 --> 00:40:38,880
and so basically you know the way to

1132
00:40:38,880 --> 00:40:42,079
think about it you know there's a

1133
00:40:42,079 --> 00:40:45,520
ring uh there's two rings you know one

1134
00:40:45,520 --> 00:40:47,520
for receiving and one for sending

1135
00:40:47,520 --> 00:40:50,880
the tx rx both live in

1136
00:40:50,880 --> 00:40:54,400
uh ram and you know they're manipulated

1137
00:40:54,400 --> 00:40:57,520
uh by you know code running on the uh

1138
00:40:57,520 --> 00:40:58,560
risk five course

1139
00:40:58,560 --> 00:41:01,599
and by you know the network card itself

1140
00:41:01,599 --> 00:41:02,960
and so there has to be some protocol

1141
00:41:02,960 --> 00:41:06,000
between the network card and uh

1142
00:41:06,000 --> 00:41:08,640
the risk five course uh about you know

1143
00:41:08,640 --> 00:41:10,000
who gets to look at what

1144
00:41:10,000 --> 00:41:12,880
and so the way and this is a very common

1145
00:41:12,880 --> 00:41:14,880
organization in hardware devices

1146
00:41:14,880 --> 00:41:16,400
uh the way that typically is done you

1147
00:41:16,400 --> 00:41:17,760
know there are sort of like let's look

1148
00:41:17,760 --> 00:41:18,640
at the transmit queue

1149
00:41:18,640 --> 00:41:20,480
there's basically a queue of some fixed

1150
00:41:20,480 --> 00:41:21,839
size structures descriptors

1151
00:41:21,839 --> 00:41:24,319
as we'll look at in a second these are

1152
00:41:24,319 --> 00:41:29,349
the descriptors

1153
00:41:29,359 --> 00:41:32,160
and the organization or the coordination

1154
00:41:32,160 --> 00:41:32,960
that is actually

1155
00:41:32,960 --> 00:41:36,560
uh that's happening between the

1156
00:41:36,560 --> 00:41:39,359
the driver and the network card is in

1157
00:41:39,359 --> 00:41:41,680
consumer

1158
00:41:41,680 --> 00:41:45,190
producer

1159
00:41:45,200 --> 00:41:48,240
coordination and uh basically you know

1160
00:41:48,240 --> 00:41:49,680
one way to think about it you know there

1161
00:41:49,680 --> 00:41:50,560
is a

1162
00:41:50,560 --> 00:41:52,480
uh if this is the transmit queue you

1163
00:41:52,480 --> 00:41:53,760
know there's maybe there's a head

1164
00:41:53,760 --> 00:41:56,550
pointer

1165
00:41:56,560 --> 00:42:00,470
there's a tail pointer

1166
00:42:00,480 --> 00:42:03,040
and you know this the tail pointer is

1167
00:42:03,040 --> 00:42:05,440
controlled by the software

1168
00:42:05,440 --> 00:42:06,960
and so the software looks at the tail

1169
00:42:06,960 --> 00:42:08,880
pointer and if it wants to sit in

1170
00:42:08,880 --> 00:42:10,319
a minute and send another packet you

1171
00:42:10,319 --> 00:42:12,400
know it sticks it you know in

1172
00:42:12,400 --> 00:42:14,480
uh the ring at the location of t plus

1173
00:42:14,480 --> 00:42:16,400
one and then moves up you know the tail

1174
00:42:16,400 --> 00:42:19,200
point in that direction

1175
00:42:19,200 --> 00:42:21,280
and the head pointer is basically

1176
00:42:21,280 --> 00:42:23,520
controlled by the hardware

1177
00:42:23,520 --> 00:42:26,560
so tail by software head by

1178
00:42:26,560 --> 00:42:28,240
hardware and then basically the you know

1179
00:42:28,240 --> 00:42:29,760
the hardware basically looks at the head

1180
00:42:29,760 --> 00:42:31,119
and then this is the first packet that

1181
00:42:31,119 --> 00:42:32,000
is going to be sent

1182
00:42:32,000 --> 00:42:33,200
you know and there's a little bit of

1183
00:42:33,200 --> 00:42:35,119
information in the descriptor or enough

1184
00:42:35,119 --> 00:42:36,640
information in the descriptor

1185
00:42:36,640 --> 00:42:38,400
for the network card to look at it and

1186
00:42:38,400 --> 00:42:40,160
say like ah this is the bytes that i

1187
00:42:40,160 --> 00:42:41,040
need to

1188
00:42:41,040 --> 00:42:44,960
move on to the uh move on to the cable

1189
00:42:44,960 --> 00:42:46,800
and once it is done you know it moves

1190
00:42:46,800 --> 00:42:48,800
the head pointer in that direction you

1191
00:42:48,800 --> 00:42:50,000
know once it consumed

1192
00:42:50,000 --> 00:42:51,760
you know one of the packets out of the

1193
00:42:51,760 --> 00:42:53,520
transmission tube

1194
00:42:53,520 --> 00:42:55,440
and one way to think about it is that

1195
00:42:55,440 --> 00:42:56,720
all the

1196
00:42:56,720 --> 00:43:00,000
descriptors between here

1197
00:43:00,000 --> 00:43:03,280
you know between the tail and so all the

1198
00:43:03,280 --> 00:43:04,160
things that are actually

1199
00:43:04,160 --> 00:43:07,760
being filled in so like the tails moved

1200
00:43:07,760 --> 00:43:12,400
up maybe to here

1201
00:43:12,400 --> 00:43:13,760
you know all the packets that are all

1202
00:43:13,760 --> 00:43:15,599
the descriptor entries that are actually

1203
00:43:15,599 --> 00:43:16,560
filled in

1204
00:43:16,560 --> 00:43:18,720
the way you think about them is they're

1205
00:43:18,720 --> 00:43:20,000
sort of owned by the hardware they're

1206
00:43:20,000 --> 00:43:21,680
owned by the network card

1207
00:43:21,680 --> 00:43:23,839
the network card is allowed to read them

1208
00:43:23,839 --> 00:43:26,240
you know do things with them uh but the

1209
00:43:26,240 --> 00:43:28,000
software in the software is not allowed

1210
00:43:28,000 --> 00:43:29,119
to you know do anything

1211
00:43:29,119 --> 00:43:30,720
with that curriculum if given the

1212
00:43:30,720 --> 00:43:32,319
software would be scribbling

1213
00:43:32,319 --> 00:43:35,359
over these descriptors uh

1214
00:43:35,359 --> 00:43:37,119
while they really sort of owned by the

1215
00:43:37,119 --> 00:43:38,960
hardware desk by their network card

1216
00:43:38,960 --> 00:43:41,040
that would change the data that the

1217
00:43:41,040 --> 00:43:42,160
network card sees

1218
00:43:42,160 --> 00:43:45,359
and so that'd be pretty undesirable uh

1219
00:43:45,359 --> 00:43:47,680
and so the protocol basically is that

1220
00:43:47,680 --> 00:43:49,440
like once you know the software moves

1221
00:43:49,440 --> 00:43:51,200
the tail point or one up

1222
00:43:51,200 --> 00:43:53,119
then you know that point you know what

1223
00:43:53,119 --> 00:43:55,119
it just moved into the network queue in

1224
00:43:55,119 --> 00:43:56,079
the transmission queue

1225
00:43:56,079 --> 00:43:58,079
is now owned by the hardware and it will

1226
00:43:58,079 --> 00:43:59,280
stick in you know

1227
00:43:59,280 --> 00:44:01,119
it will be uh owned by the hardware

1228
00:44:01,119 --> 00:44:03,119
until you know it has been sent

1229
00:44:03,119 --> 00:44:05,040
and basically until the head pointer

1230
00:44:05,040 --> 00:44:06,839
moves past you know to that particular

1231
00:44:06,839 --> 00:44:09,760
structure

1232
00:44:09,760 --> 00:44:18,790
does that make sense

1233
00:44:18,800 --> 00:44:20,319
good and for the transmission basically

1234
00:44:20,319 --> 00:44:22,720
it's the same story you know there's a

1235
00:44:22,720 --> 00:44:25,520
you know there's a head pointer you know

1236
00:44:25,520 --> 00:44:28,630
you know that's basically

1237
00:44:28,640 --> 00:44:30,960
that's controlled by the hardware and

1238
00:44:30,960 --> 00:44:32,079
there's a tail pointer

1239
00:44:32,079 --> 00:44:35,040
that is controlled by sort of is the

1240
00:44:35,040 --> 00:44:37,359
software pointer

1241
00:44:37,359 --> 00:44:40,880
and the basically the packets in between

1242
00:44:40,880 --> 00:44:44,160
are the packets that actually uh uh

1243
00:44:44,160 --> 00:44:47,200
are have been received you know by the

1244
00:44:47,200 --> 00:44:47,839
hardware

1245
00:44:47,839 --> 00:44:50,880
and um uh

1246
00:44:50,880 --> 00:44:52,800
and you know by inspecting the tail

1247
00:44:52,800 --> 00:44:54,000
pointer and the software can see if

1248
00:44:54,000 --> 00:44:55,359
there's actually a new packet you know

1249
00:44:55,359 --> 00:44:56,880
that is ready to be

1250
00:44:56,880 --> 00:44:58,720
uh consumed and if it's ready to be

1251
00:44:58,720 --> 00:45:00,560
consumed the heart will indicate that

1252
00:45:00,560 --> 00:45:02,480
by setting that dd bit in the status

1253
00:45:02,480 --> 00:45:04,160
field and so when the

1254
00:45:04,160 --> 00:45:05,680
dd bit is set you know the hardened

1255
00:45:05,680 --> 00:45:07,200
software sheets are good you know this

1256
00:45:07,200 --> 00:45:08,800
packet you know the hardware is done

1257
00:45:08,800 --> 00:45:09,520
with it

1258
00:45:09,520 --> 00:45:12,079
and so it can take it out and move the

1259
00:45:12,079 --> 00:45:14,800
tail pointer one up

1260
00:45:14,800 --> 00:45:16,240
and so there's sort of this give and

1261
00:45:16,240 --> 00:45:19,359
take between

1262
00:45:19,359 --> 00:45:22,079
the driver and our hardware to actually

1263
00:45:22,079 --> 00:45:22,880
coordinate

1264
00:45:22,880 --> 00:45:27,270
that they don't trip over each other

1265
00:45:27,280 --> 00:45:31,270
any question about the

1266
00:45:31,280 --> 00:45:34,870
rings

1267
00:45:34,880 --> 00:45:39,119
um is this like is this like a universal

1268
00:45:39,119 --> 00:45:42,720
way to kind of uh implement like hues or

1269
00:45:42,720 --> 00:45:44,319
any kind of communication between two

1270
00:45:44,319 --> 00:45:46,240
things that have shared memory

1271
00:45:46,240 --> 00:45:48,160
yeah there's a pretty uh certainly also

1272
00:45:48,160 --> 00:45:49,680
in the software you see this but

1273
00:45:49,680 --> 00:45:51,440
many hardware devices play this sort of

1274
00:45:51,440 --> 00:45:53,280
trick

1275
00:45:53,280 --> 00:45:56,160
where uh there's a sort of producer

1276
00:45:56,160 --> 00:45:58,400
consumer style

1277
00:45:58,400 --> 00:45:59,760
coordination between the heart rate and

1278
00:45:59,760 --> 00:46:05,190
soccer

1279
00:46:05,200 --> 00:46:08,319
so yeah it's a very common structure

1280
00:46:08,319 --> 00:46:10,400
maybe one or two questions uh that we

1281
00:46:10,400 --> 00:46:11,359
can ask about it

1282
00:46:11,359 --> 00:46:13,119
like why is there actually even a queue

1283
00:46:13,119 --> 00:46:14,800
now why is there a ring

1284
00:46:14,800 --> 00:46:16,319
okay the reason there's a ring correct

1285
00:46:16,319 --> 00:46:17,839
because the queue wraps

1286
00:46:17,839 --> 00:46:20,240
queue wraps around to make it fix size

1287
00:46:20,240 --> 00:46:21,599
but

1288
00:46:21,599 --> 00:46:23,920
you know why why not uh you know have a

1289
00:46:23,920 --> 00:46:24,960
cure one entry

1290
00:46:24,960 --> 00:46:28,079
one entry

1291
00:46:28,079 --> 00:46:30,079
almost like the uart if you remember the

1292
00:46:30,079 --> 00:46:31,280
uart uh

1293
00:46:31,280 --> 00:46:33,040
driver and controller there's basically

1294
00:46:33,040 --> 00:46:34,400
only one register

1295
00:46:34,400 --> 00:46:35,839
you know to send the byte and there's

1296
00:46:35,839 --> 00:46:38,880
another registered receiver byte

1297
00:46:38,880 --> 00:46:41,520
and so why have you know why go for this

1298
00:46:41,520 --> 00:46:42,000
complicated

1299
00:46:42,000 --> 00:46:43,520
scheme if you could have yourself a

1300
00:46:43,520 --> 00:46:44,720
single register and then you could

1301
00:46:44,720 --> 00:46:46,480
basically say you know

1302
00:46:46,480 --> 00:46:48,400
hardware this register is now ready send

1303
00:46:48,400 --> 00:46:50,800
it and then you just wait until

1304
00:46:50,800 --> 00:46:55,270
the it's done

1305
00:46:55,280 --> 00:46:59,040
to allow for when there are bursts of

1306
00:46:59,040 --> 00:47:02,880
packets yeah yeah exactly

1307
00:47:02,880 --> 00:47:04,720
you know the network interface or the

1308
00:47:04,720 --> 00:47:07,200
network uh card or cable is pretty high

1309
00:47:07,200 --> 00:47:08,400
performance in fact it's very high

1310
00:47:08,400 --> 00:47:10,000
performance correct on gigabits

1311
00:47:10,000 --> 00:47:13,280
per second and so uh

1312
00:47:13,280 --> 00:47:14,960
it can be hard for the core or the

1313
00:47:14,960 --> 00:47:16,400
processor to actually keep up with it so

1314
00:47:16,400 --> 00:47:18,079
you would like to give it a whole bunch

1315
00:47:18,079 --> 00:47:19,440
of packets you know the networks or the

1316
00:47:19,440 --> 00:47:20,319
network cards can

1317
00:47:20,319 --> 00:47:22,000
chunk along and all send them out at

1318
00:47:22,000 --> 00:47:24,400
high speed and similarly you know in

1319
00:47:24,400 --> 00:47:25,839
reception you might get a burst of

1320
00:47:25,839 --> 00:47:27,280
packets coming in

1321
00:47:27,280 --> 00:47:29,359
and you want to place them in the queue

1322
00:47:29,359 --> 00:47:30,800
and then you know the operating system

1323
00:47:30,800 --> 00:47:33,280
can start them processing the queue

1324
00:47:33,280 --> 00:47:39,599
right and so this is a common

1325
00:47:39,599 --> 00:47:40,960
this is the reason that these cues are

1326
00:47:40,960 --> 00:47:43,990
common

1327
00:47:44,000 --> 00:47:48,710
to handle bursts

1328
00:47:48,720 --> 00:47:51,119
what happens if the cues fall like on

1329
00:47:51,119 --> 00:47:58,950
reception

1330
00:47:58,960 --> 00:48:02,559
i think the the document mentioned that

1331
00:48:02,559 --> 00:48:04,160
it does some form of a

1332
00:48:04,160 --> 00:48:07,440
drop tale scheme yeah

1333
00:48:07,440 --> 00:48:09,680
the the the the yeah basically the packs

1334
00:48:09,680 --> 00:48:11,119
get dropped

1335
00:48:11,119 --> 00:48:13,520
so any future incoming packets if the

1336
00:48:13,520 --> 00:48:15,119
queue is full the the packets

1337
00:48:15,119 --> 00:48:17,119
uh there's no room anymore in the wrong

1338
00:48:17,119 --> 00:48:18,800
the network card can't do anything with

1339
00:48:18,800 --> 00:48:20,079
that correctly and so the only

1340
00:48:20,079 --> 00:48:22,880
option it actually has is to basically

1341
00:48:22,880 --> 00:48:23,920
delete the packet

1342
00:48:23,920 --> 00:48:26,160
or not add it to the ring and therefore

1343
00:48:26,160 --> 00:48:27,760
disappears

1344
00:48:27,760 --> 00:48:29,440
and so one reason of packet loss

1345
00:48:29,440 --> 00:48:31,920
sometimes is that

1346
00:48:31,920 --> 00:48:33,680
an operating system is overloaded you

1347
00:48:33,680 --> 00:48:35,119
know with packet can't keep up

1348
00:48:35,119 --> 00:48:37,760
and the ring fills and then you know the

1349
00:48:37,760 --> 00:48:41,030
packets get dropped

1350
00:48:41,040 --> 00:48:42,640
now higher level software of course may

1351
00:48:42,640 --> 00:48:44,480
like a tcp connection might

1352
00:48:44,480 --> 00:48:48,000
retransmit those packets but this is one

1353
00:48:48,000 --> 00:48:52,630
reason why packets can get dropped

1354
00:48:52,640 --> 00:48:54,079
so even if the hardware sort of works

1355
00:48:54,079 --> 00:48:56,160
all perfectly fine

1356
00:48:56,160 --> 00:48:57,839
you know because of this burstiness you

1357
00:48:57,839 --> 00:48:59,200
know it can't happen that pacco section

1358
00:48:59,200 --> 00:49:01,119
might get dropped

1359
00:49:01,119 --> 00:49:06,950
so you had a really really big burst

1360
00:49:06,960 --> 00:49:10,240
um the head and um tail pointers they're

1361
00:49:10,240 --> 00:49:11,920
all software abstractions right

1362
00:49:11,920 --> 00:49:14,880
of the queue ah okay so these are

1363
00:49:14,880 --> 00:49:16,640
actually turns out that those are uh

1364
00:49:16,640 --> 00:49:18,640
these control registers right so there's

1365
00:49:18,640 --> 00:49:20,559
a controller register for the

1366
00:49:20,559 --> 00:49:22,640
hardware head pointer as a control

1367
00:49:22,640 --> 00:49:24,240
register for the

1368
00:49:24,240 --> 00:49:26,079
basically you know detail pointer

1369
00:49:26,079 --> 00:49:27,280
there's no really distinction between

1370
00:49:27,280 --> 00:49:28,000
hardware software

1371
00:49:28,000 --> 00:49:29,440
basically the driver knows about the

1372
00:49:29,440 --> 00:49:30,880
tail pointer and it knows about the

1373
00:49:30,880 --> 00:49:32,800
hardware knows about the tail pointer

1374
00:49:32,800 --> 00:49:36,000
and the head pointer and these are basic

1375
00:49:36,000 --> 00:49:37,680
controller registers

1376
00:49:37,680 --> 00:49:39,520
right okay yeah and we'll see in the

1377
00:49:39,520 --> 00:49:42,720
code in seconds how that shows up

1378
00:49:42,720 --> 00:49:46,240
make sure if you go back to our uh maybe

1379
00:49:46,240 --> 00:49:47,920
let's see if we have this picture still

1380
00:49:47,920 --> 00:49:49,839
here you know here's the that

1381
00:49:49,839 --> 00:49:51,839
earlier picture that we looked at and

1382
00:49:51,839 --> 00:49:52,880
you know here's

1383
00:49:52,880 --> 00:49:54,640
controller register that holds the head

1384
00:49:54,640 --> 00:49:56,400
and here the control register and holds

1385
00:49:56,400 --> 00:49:56,960
the tail

1386
00:49:56,960 --> 00:49:58,559
and of course there's one for both

1387
00:49:58,559 --> 00:50:00,000
reception and one for

1388
00:50:00,000 --> 00:50:04,309
sending

1389
00:50:04,319 --> 00:50:09,190
okay

1390
00:50:09,200 --> 00:50:12,319
let's go back here okay so

1391
00:50:12,319 --> 00:50:13,359
let's talk a little bit about the

1392
00:50:13,359 --> 00:50:16,559
descriptors and so the

1393
00:50:16,559 --> 00:50:18,720
descriptors are defined by the hardware

1394
00:50:18,720 --> 00:50:20,960
and so the hardware says like here's how

1395
00:50:20,960 --> 00:50:22,640
a descriptor should look like and your

1396
00:50:22,640 --> 00:50:23,359
driver

1397
00:50:23,359 --> 00:50:25,440
you know these are the bits you can fill

1398
00:50:25,440 --> 00:50:26,880
in and if you fill in that bit

1399
00:50:26,880 --> 00:50:29,280
that tells me the following all right

1400
00:50:29,280 --> 00:50:30,880
and so here's the

1401
00:50:30,880 --> 00:50:34,319
uh two um descriptors that are important

1402
00:50:34,319 --> 00:50:37,359
you know here's the uh

1403
00:50:37,359 --> 00:50:41,280
receive descriptor rx and here's the tx

1404
00:50:41,280 --> 00:50:44,000
one of the tx descriptors so let's look

1405
00:50:44,000 --> 00:50:44,640
a little bit

1406
00:50:44,640 --> 00:50:48,800
uh yeah let's look a little bit

1407
00:50:48,800 --> 00:50:51,760
um probably the most important part is

1408
00:50:51,760 --> 00:50:52,240
this

1409
00:50:52,240 --> 00:50:55,599
address and that is the address that the

1410
00:50:55,599 --> 00:50:56,960
software filled in to say

1411
00:50:56,960 --> 00:50:59,200
like where they should where the car to

1412
00:50:59,200 --> 00:51:00,800
dump you know the packet you know where

1413
00:51:00,800 --> 00:51:01,440
in ram

1414
00:51:01,440 --> 00:51:04,800
should the driver

1415
00:51:04,800 --> 00:51:06,880
or where should the network card put the

1416
00:51:06,880 --> 00:51:08,400
data that it receives

1417
00:51:08,400 --> 00:51:10,960
into ram so it's the address or the

1418
00:51:10,960 --> 00:51:13,680
reception buffer if you will

1419
00:51:13,680 --> 00:51:17,030
um

1420
00:51:17,040 --> 00:51:18,240
and then you know probably the most

1421
00:51:18,240 --> 00:51:21,440
important part in

1422
00:51:21,440 --> 00:51:24,559
is the status field as you've seen

1423
00:51:24,559 --> 00:51:26,559
so when the driver basically still

1424
00:51:26,559 --> 00:51:28,319
continues to look sort of at the tail

1425
00:51:28,319 --> 00:51:30,559
and sees if there's a new packet has

1426
00:51:30,559 --> 00:51:31,680
been received

1427
00:51:31,680 --> 00:51:33,040
and the way it tells whether there's a

1428
00:51:33,040 --> 00:51:35,760
new package received is is that the dd

1429
00:51:35,760 --> 00:51:36,160
bit

1430
00:51:36,160 --> 00:51:40,559
correct is set uh by the hardware

1431
00:51:40,559 --> 00:51:43,760
uh and you know the shaded areas are

1432
00:51:43,760 --> 00:51:46,319
the fields of the packet descriptor of

1433
00:51:46,319 --> 00:51:47,920
the the

1434
00:51:47,920 --> 00:51:49,920
uh receive descriptor that actually the

1435
00:51:49,920 --> 00:51:51,040
hardware fills in

1436
00:51:51,040 --> 00:51:53,280
and the white you know the non-shaded

1437
00:51:53,280 --> 00:51:54,480
ones are the fields that are actually

1438
00:51:54,480 --> 00:51:55,119
shaded in

1439
00:51:55,119 --> 00:51:57,760
are filled in by the software again here

1440
00:51:57,760 --> 00:51:59,760
we see this clear distinction about

1441
00:51:59,760 --> 00:52:01,440
some things are owned by software some

1442
00:52:01,440 --> 00:52:03,280
things are owned by

1443
00:52:03,280 --> 00:52:08,710
uh by the hardware

1444
00:52:08,720 --> 00:52:12,480
okay and this there's a similar you know

1445
00:52:12,480 --> 00:52:14,240
descriptor very similar descriptor that

1446
00:52:14,240 --> 00:52:15,680
looks uh

1447
00:52:15,680 --> 00:52:17,280
that's the hardwood scripter for the

1448
00:52:17,280 --> 00:52:19,040
transmission it has

1449
00:52:19,040 --> 00:52:21,119
an address and that address of course is

1450
00:52:21,119 --> 00:52:22,400
the address

1451
00:52:22,400 --> 00:52:24,800
where the data is in memory that needs

1452
00:52:24,800 --> 00:52:25,839
to be sent

1453
00:52:25,839 --> 00:52:27,200
and then it has a bunch of you know it

1454
00:52:27,200 --> 00:52:29,040
has a command field

1455
00:52:29,040 --> 00:52:30,960
and here's how the software tells the

1456
00:52:30,960 --> 00:52:32,640
driver tells the network card

1457
00:52:32,640 --> 00:52:33,920
this is what you should do with this

1458
00:52:33,920 --> 00:52:35,440
particular packet or you know this is

1459
00:52:35,440 --> 00:52:36,640
what you should know about this

1460
00:52:36,640 --> 00:52:38,240
particular packet

1461
00:52:38,240 --> 00:52:41,119
and so one thing yeah we i think we fill

1462
00:52:41,119 --> 00:52:41,839
in two pack

1463
00:52:41,839 --> 00:52:44,319
two things we call the aeop that says

1464
00:52:44,319 --> 00:52:45,440
you know the

1465
00:52:45,440 --> 00:52:47,359
end of packet and that basically tells

1466
00:52:47,359 --> 00:52:50,240
the driver this is the last descriptor

1467
00:52:50,240 --> 00:52:52,640
of a particular packet and now it can

1468
00:52:52,640 --> 00:52:53,839
you know send off

1469
00:52:53,839 --> 00:52:55,359
you know whatever data that's in these

1470
00:52:55,359 --> 00:52:56,880
descriptors

1471
00:52:56,880 --> 00:53:00,800
um and i think we set the

1472
00:53:00,800 --> 00:53:04,000
uh response in a requested

1473
00:53:04,000 --> 00:53:08,880
uh command bit uh or rs i think it is

1474
00:53:08,880 --> 00:53:11,920
uh basically tells the network card when

1475
00:53:11,920 --> 00:53:13,280
you're done

1476
00:53:13,280 --> 00:53:18,630
transmitting this thing you know set the

1477
00:53:18,640 --> 00:53:19,920
said a bit that it actually has been

1478
00:53:19,920 --> 00:53:22,400
transmitted we'll see in a second how

1479
00:53:22,400 --> 00:53:22,720
that

1480
00:53:22,720 --> 00:53:32,150
how that shows up any questions

1481
00:53:32,160 --> 00:53:34,400
so one one thing to keep in mind you

1482
00:53:34,400 --> 00:53:35,599
know with these structures these are

1483
00:53:35,599 --> 00:53:37,040
defined by the hardware right like so

1484
00:53:37,040 --> 00:53:38,800
the hardware the software has no control

1485
00:53:38,800 --> 00:53:39,839
over their structure

1486
00:53:39,839 --> 00:53:41,760
you know they're just literally defined

1487
00:53:41,760 --> 00:53:44,880
by the hardware or by the network card

1488
00:53:44,880 --> 00:53:47,440
okay let's look at a little bit of code

1489
00:53:47,440 --> 00:53:48,079
uh

1490
00:53:48,079 --> 00:53:50,559
and see uh what the solution looks like

1491
00:53:50,559 --> 00:53:52,079
and we'll look at a couple of

1492
00:53:52,079 --> 00:53:53,520
issues that we haven't looked at yet you

1493
00:53:53,520 --> 00:53:57,040
know the mbofs of the issues of

1494
00:53:57,040 --> 00:53:58,480
doing transmission and the issues during

1495
00:53:58,480 --> 00:54:00,480
receiving

1496
00:54:00,480 --> 00:54:01,920
and this should be presumably all well

1497
00:54:01,920 --> 00:54:03,760
familiar with to you given the fact that

1498
00:54:03,760 --> 00:54:04,480
you

1499
00:54:04,480 --> 00:54:08,790
just finished the lab

1500
00:54:08,800 --> 00:54:12,160
okay so here just to go go to the top

1501
00:54:12,160 --> 00:54:15,599
uh here's the transmit ring uh

1502
00:54:15,599 --> 00:54:17,839
and that's basically the ring of

1503
00:54:17,839 --> 00:54:19,280
descriptors you know that we

1504
00:54:19,280 --> 00:54:21,359
drew off in the last you know couple

1505
00:54:21,359 --> 00:54:22,559
slides

1506
00:54:22,559 --> 00:54:24,000
there's a separate you know we talked

1507
00:54:24,000 --> 00:54:25,680
briefly about this there's a separate

1508
00:54:25,680 --> 00:54:29,200
uh basically ring of emboss but that in

1509
00:54:29,200 --> 00:54:30,480
that ring is completely

1510
00:54:30,480 --> 00:54:33,359
you know a software or driver only

1511
00:54:33,359 --> 00:54:34,559
abstraction

1512
00:54:34,559 --> 00:54:38,160
uh the hardware uh this is defined by

1513
00:54:38,160 --> 00:54:39,599
the this structure or the

1514
00:54:39,599 --> 00:54:42,240
is defined by the hardware right then if

1515
00:54:42,240 --> 00:54:43,440
you look at

1516
00:54:43,440 --> 00:55:01,109
oops

1517
00:55:01,119 --> 00:55:04,880
uh you look at the definitions quick

1518
00:55:04,880 --> 00:55:06,720
here's the struct you know tx desk

1519
00:55:06,720 --> 00:55:08,400
and that corresponds you know to the c

1520
00:55:08,400 --> 00:55:10,400
version of exactly the structure that

1521
00:55:10,400 --> 00:55:11,760
actually was defined by the hardware you

1522
00:55:11,760 --> 00:55:13,440
know the 64-bit

1523
00:55:13,440 --> 00:55:14,960
address you know the length field the

1524
00:55:14,960 --> 00:55:17,839
cso byte the command byte the status

1525
00:55:17,839 --> 00:55:20,559
byte the ccs byte and then you know to

1526
00:55:20,559 --> 00:55:23,200
a word for special and there's a similar

1527
00:55:23,200 --> 00:55:24,559
ring that you know is literally defined

1528
00:55:24,559 --> 00:55:25,680
by the hardware

1529
00:55:25,680 --> 00:55:26,880
or similar descriptor and receive

1530
00:55:26,880 --> 00:55:28,400
descriptors as defined by hardware and

1531
00:55:28,400 --> 00:55:29,440
those we just have c

1532
00:55:29,440 --> 00:55:31,599
decorations corresponding to these

1533
00:55:31,599 --> 00:55:34,799
hardware structures

1534
00:55:34,799 --> 00:55:37,839
all right let's look at transmit

1535
00:55:37,839 --> 00:55:40,400
uh so mirrors that's the sort of staff

1536
00:55:40,400 --> 00:55:42,400
solution for transmit

1537
00:55:42,400 --> 00:55:44,640
uh you know acquires a lock and the

1538
00:55:44,640 --> 00:55:46,000
reason we as we said before that it

1539
00:55:46,000 --> 00:55:47,280
needed lock is because multiple

1540
00:55:47,280 --> 00:55:48,799
functions or multiple threads kernel

1541
00:55:48,799 --> 00:55:50,640
threats might call

1542
00:55:50,640 --> 00:55:53,920
transmits at the same time and then

1543
00:55:53,920 --> 00:55:56,000
it looks at the tail you know to see if

1544
00:55:56,000 --> 00:55:58,240
there's any uh

1545
00:55:58,240 --> 00:56:00,240
if there's room to actually send a new

1546
00:56:00,240 --> 00:56:02,319
uh packet because you know the

1547
00:56:02,319 --> 00:56:05,280
network hardware got behind and all the

1548
00:56:05,280 --> 00:56:06,720
descriptors actually are being

1549
00:56:06,720 --> 00:56:10,079
in use and so the way it checks uh

1550
00:56:10,079 --> 00:56:12,799
where actually the descriptor is in uh

1551
00:56:12,799 --> 00:56:13,760
in use is by

1552
00:56:13,760 --> 00:56:17,040
uh checking whether the dd bit uh

1553
00:56:17,040 --> 00:56:20,160
is not set

1554
00:56:20,160 --> 00:56:25,510
uh and if it is set then

1555
00:56:25,520 --> 00:56:29,119
if it's not set then it returns uh

1556
00:56:29,119 --> 00:56:30,799
immediately not sending the packet at

1557
00:56:30,799 --> 00:56:32,400
all and in the other case

1558
00:56:32,400 --> 00:56:34,000
gonna actually keeps on going and

1559
00:56:34,000 --> 00:56:39,670
actually will send the end buff

1560
00:56:39,680 --> 00:56:41,920
so if there's still an m buff in this

1561
00:56:41,920 --> 00:56:44,000
position in the txm nbox that means

1562
00:56:44,000 --> 00:56:45,760
uh this is an m buffer a while back you

1563
00:56:45,760 --> 00:56:47,599
know we free that m buff because we're

1564
00:56:47,599 --> 00:56:49,440
going to actually stick in a new m buff

1565
00:56:49,440 --> 00:56:51,680
into this descriptor and we just need to

1566
00:56:51,680 --> 00:56:53,520
remember which you know mbot we stuck in

1567
00:56:53,520 --> 00:56:54,559
that descriptor

1568
00:56:54,559 --> 00:56:56,480
and so the way we do that is by keeping

1569
00:56:56,480 --> 00:56:59,760
that in the txm buffs

1570
00:56:59,760 --> 00:57:02,799
and then we fill in the descriptor and

1571
00:57:02,799 --> 00:57:04,079
so the first thing we're filling is the

1572
00:57:04,079 --> 00:57:06,000
head and we fill in

1573
00:57:06,000 --> 00:57:09,520
we put in the address the start

1574
00:57:09,520 --> 00:57:13,440
of the first header in the end buff

1575
00:57:13,440 --> 00:57:16,160
then put the length set the status to

1576
00:57:16,160 --> 00:57:17,040
zero

1577
00:57:17,040 --> 00:57:18,960
put the command field in place by

1578
00:57:18,960 --> 00:57:20,640
sending both the rs

1579
00:57:20,640 --> 00:57:22,720
and the eop bit as well i discussed the

1580
00:57:22,720 --> 00:57:23,760
second

1581
00:57:23,760 --> 00:57:27,520
and um and then basically

1582
00:57:27,520 --> 00:57:29,040
we synchronize to make actually sure

1583
00:57:29,040 --> 00:57:30,799
that there's no reordering of

1584
00:57:30,799 --> 00:57:33,200
you know that all these instructions are

1585
00:57:33,200 --> 00:57:33,839
performed

1586
00:57:33,839 --> 00:57:36,400
before the next instruction and what the

1587
00:57:36,400 --> 00:57:37,680
next instruction does it actually

1588
00:57:37,680 --> 00:57:39,040
updates the tail pointer

1589
00:57:39,040 --> 00:57:40,960
and so the adapter updates the tail

1590
00:57:40,960 --> 00:57:43,119
pointer and the steel pointer correct is

1591
00:57:43,119 --> 00:57:45,760
a control register in the network card

1592
00:57:45,760 --> 00:57:47,599
and so basically when we update the tail

1593
00:57:47,599 --> 00:57:48,240
pointer

1594
00:57:48,240 --> 00:57:50,480
the network card knows ah something

1595
00:57:50,480 --> 00:57:51,359
changed

1596
00:57:51,359 --> 00:57:54,480
and it's going to read you know the data

1597
00:57:54,480 --> 00:57:55,040
at that

1598
00:57:55,040 --> 00:57:57,839
uh descriptor um and it's going to

1599
00:57:57,839 --> 00:57:59,200
basically read that these fields where

1600
00:57:59,200 --> 00:58:00,240
we just filled in

1601
00:58:00,240 --> 00:58:02,079
so we're going to make absolutely sure

1602
00:58:02,079 --> 00:58:03,440
that all these

1603
00:58:03,440 --> 00:58:05,440
you know writes all these stores are

1604
00:58:05,440 --> 00:58:06,880
materialized in memory

1605
00:58:06,880 --> 00:58:09,200
before the network card actually reads

1606
00:58:09,200 --> 00:58:10,640
them and so this is why the sync

1607
00:58:10,640 --> 00:58:13,589
synchronizes there

1608
00:58:13,599 --> 00:58:14,880
and then we release about a lock and

1609
00:58:14,880 --> 00:58:16,079
that's basically all we have to do you

1610
00:58:16,079 --> 00:58:20,710
know transmitter packet

1611
00:58:20,720 --> 00:58:22,960
can you explain the sync synchronize

1612
00:58:22,960 --> 00:58:24,240
again like

1613
00:58:24,240 --> 00:58:27,280
what yeah i'm having to do this

1614
00:58:27,280 --> 00:58:28,960
it's mostly a memory ordering

1615
00:58:28,960 --> 00:58:30,559
technicality correct like compilers are

1616
00:58:30,559 --> 00:58:32,640
free to reorder instructions

1617
00:58:32,640 --> 00:58:35,359
uh the uh the rights might actually sit

1618
00:58:35,359 --> 00:58:36,480
in the

1619
00:58:36,480 --> 00:58:39,839
l1 cache or the l12 cache and

1620
00:58:39,839 --> 00:58:41,440
basically the synchronize is sort of a

1621
00:58:41,440 --> 00:58:43,920
memory fence uh that you know tells the

1622
00:58:43,920 --> 00:58:45,440
hardware and the compiler

1623
00:58:45,440 --> 00:58:47,440
please don't move any instructions

1624
00:58:47,440 --> 00:58:50,960
across this barrier and make sure that

1625
00:58:50,960 --> 00:58:52,640
all the data that you know

1626
00:58:52,640 --> 00:58:54,960
all the stores before this barrier are

1627
00:58:54,960 --> 00:58:55,839
actually actually

1628
00:58:55,839 --> 00:58:59,200
materialized in ram and the reason that

1629
00:58:59,200 --> 00:58:59,839
it's important

1630
00:58:59,839 --> 00:59:02,640
is because the you know go back to our

1631
00:59:02,640 --> 00:59:07,190
picture for a little while ago

1632
00:59:07,200 --> 00:59:10,640
all the way back here

1633
00:59:10,640 --> 00:59:13,119
actually both you know the risk five

1634
00:59:13,119 --> 00:59:15,040
cores that render the driver code you

1635
00:59:15,040 --> 00:59:16,240
know basically put values

1636
00:59:16,240 --> 00:59:18,000
here in round correct but you know those

1637
00:59:18,000 --> 00:59:19,680
values are reversing the l1 cache and

1638
00:59:19,680 --> 00:59:20,960
the l2 cache

1639
00:59:20,960 --> 00:59:22,480
and the memory flash nothing sure is

1640
00:59:22,480 --> 00:59:24,079
that they actually show up in the ram

1641
00:59:24,079 --> 00:59:25,760
this is important because as soon as we

1642
00:59:25,760 --> 00:59:27,599
update the tail pointer the e1000 is

1643
00:59:27,599 --> 00:59:28,880
going to look in ram for these two

1644
00:59:28,880 --> 00:59:30,960
descriptors

1645
00:59:30,960 --> 00:59:32,640
and we've got to make sure that all the

1646
00:59:32,640 --> 00:59:34,799
you know fields are indeed set

1647
00:59:34,799 --> 00:59:40,309
otherwise it would read state of values

1648
00:59:40,319 --> 00:59:46,319
does that make sense no thank you

1649
00:59:46,319 --> 01:00:00,559
um so why do mbos exist

1650
01:00:00,559 --> 01:00:02,400
why have this sort of separate structure

1651
01:00:02,400 --> 01:00:06,150
of you know why have these two

1652
01:00:06,160 --> 01:00:09,520
sort of corresponding structures

1653
01:00:09,520 --> 01:00:12,720
so i guess part of it is it's all

1654
01:00:12,720 --> 01:00:15,200
nice and well if the driver needs to

1655
01:00:15,200 --> 01:00:16,000
talk to

1656
01:00:16,000 --> 01:00:18,559
the hardware about where things are but

1657
01:00:18,559 --> 01:00:19,920
at the end of the day we do need to

1658
01:00:19,920 --> 01:00:21,520
store the packet to hand off to the

1659
01:00:21,520 --> 01:00:24,000
network stack somehow

1660
01:00:24,000 --> 01:00:26,720
yeah exactly you know so one way to

1661
01:00:26,720 --> 01:00:28,079
think about it is that the you know the

1662
01:00:28,079 --> 01:00:29,440
m buffers are completely an os

1663
01:00:29,440 --> 01:00:30,079
extraction

1664
01:00:30,079 --> 01:00:32,079
nothing to do with really the network

1665
01:00:32,079 --> 01:00:34,240
card at all and it's there because like

1666
01:00:34,240 --> 01:00:34,640
you know

1667
01:00:34,640 --> 01:00:38,400
if um at some point you know the

1668
01:00:38,400 --> 01:00:40,160
maybe receive a packet you know we hand

1669
01:00:40,160 --> 01:00:41,599
it off to the network stack and the

1670
01:00:41,599 --> 01:00:42,480
network stack now

1671
01:00:42,480 --> 01:00:44,480
sticks on some queue so that when later

1672
01:00:44,480 --> 01:00:46,319
a user process calls read you internet

1673
01:00:46,319 --> 01:00:49,119
actually can read it and in the meantime

1674
01:00:49,119 --> 01:00:50,720
we need to have some structure that sort

1675
01:00:50,720 --> 01:00:51,760
of holds that data

1676
01:00:51,760 --> 01:00:53,280
that we actually received and that's

1677
01:00:53,280 --> 01:01:01,270
exactly what those inbox structures are

1678
01:01:01,280 --> 01:01:04,799
sorry can you talk about the

1679
01:01:04,799 --> 01:01:08,160
like how how do you use the linked list

1680
01:01:08,160 --> 01:01:10,400
structure in your code because i was

1681
01:01:10,400 --> 01:01:11,599
trying to

1682
01:01:11,599 --> 01:01:14,240
to understand it and to track it down

1683
01:01:14,240 --> 01:01:14,640
and

1684
01:01:14,640 --> 01:01:17,920
it seems like there is some push

1685
01:01:17,920 --> 01:01:21,920
tail or push head but i don't ever

1686
01:01:21,920 --> 01:01:25,440
call it in my code oh it might be

1687
01:01:25,440 --> 01:01:30,069
it might be in the net dot c file

1688
01:01:30,079 --> 01:01:31,920
well the network c file is a file that

1689
01:01:31,920 --> 01:01:39,670
we gave you to you okay

1690
01:01:39,680 --> 01:01:42,960
and where you're thinking um

1691
01:01:42,960 --> 01:01:46,640
if you look for something like

1692
01:01:46,640 --> 01:01:50,839
um pull pull pop i think pop

1693
01:01:50,839 --> 01:01:54,309
um

1694
01:01:54,319 --> 01:01:56,960
yeah so this is this is the only place

1695
01:01:56,960 --> 01:01:57,359
where

1696
01:01:57,359 --> 01:02:00,240
it looks like it does things with the

1697
01:02:00,240 --> 01:02:00,960
linked list

1698
01:02:00,960 --> 01:02:04,240
structure of m buff

1699
01:02:04,240 --> 01:02:06,960
and if you don't ever call this function

1700
01:02:06,960 --> 01:02:07,599
or

1701
01:02:07,599 --> 01:02:10,240
the push tail you basically just treat

1702
01:02:10,240 --> 01:02:11,039
the m buff

1703
01:02:11,039 --> 01:02:14,640
as an array of

1704
01:02:14,640 --> 01:02:17,680
like however many characters

1705
01:02:17,680 --> 01:02:21,359
so so why is mbuff there

1706
01:02:21,359 --> 01:02:25,990
because here

1707
01:02:26,000 --> 01:02:28,799
when you receive a udp packet so the udp

1708
01:02:28,799 --> 01:02:30,400
packet comes in from the network card

1709
01:02:30,400 --> 01:02:32,960
it goes into the network stack then the

1710
01:02:32,960 --> 01:02:34,559
udp packet

1711
01:02:34,559 --> 01:02:36,720
the m-buff for that udp that holds that

1712
01:02:36,720 --> 01:02:38,319
uh udv packet

1713
01:02:38,319 --> 01:02:39,839
is actually stuck in the queue right

1714
01:02:39,839 --> 01:02:42,079
here

1715
01:02:42,079 --> 01:02:47,430
on the socket for the receiver

1716
01:02:47,440 --> 01:02:49,119
and so this is the reason that you can

1717
01:02:49,119 --> 01:02:54,309
have cues with m buffs

1718
01:02:54,319 --> 01:02:55,520
and the reason it's stuck in the queue

1719
01:02:55,520 --> 01:02:56,880
they are correct is because you know who

1720
01:02:56,880 --> 01:02:58,400
knows you know the user process that's

1721
01:02:58,400 --> 01:02:59,039
going to read

1722
01:02:59,039 --> 01:03:01,119
you know from this particular socket you

1723
01:03:01,119 --> 01:03:02,640
know might be doing something else

1724
01:03:02,640 --> 01:03:04,079
and at some point later you know it's

1725
01:03:04,079 --> 01:03:05,200
going to call the read system call and

1726
01:03:05,200 --> 01:03:06,400
then the read system call is going to

1727
01:03:06,400 --> 01:03:06,960
remove

1728
01:03:06,960 --> 01:03:11,670
you know that the inbox from that socket

1729
01:03:11,680 --> 01:03:15,280
and so the point of each socket can have

1730
01:03:15,280 --> 01:03:16,319
a list

1731
01:03:16,319 --> 01:03:22,000
of end buffs for reset for reception

1732
01:03:22,000 --> 01:03:25,750
i see thank you

1733
01:03:25,760 --> 01:03:28,240
okay let's go back to the driver so

1734
01:03:28,240 --> 01:03:28,960
another

1735
01:03:28,960 --> 01:03:32,390
transmit

1736
01:03:32,400 --> 01:03:34,960
so then receive is you know almost

1737
01:03:34,960 --> 01:03:36,160
similar

1738
01:03:36,160 --> 01:03:38,880
not that much different uh you know

1739
01:03:38,880 --> 01:03:39,520
basically

1740
01:03:39,520 --> 01:03:41,680
you read the tail pointer from the

1741
01:03:41,680 --> 01:03:43,599
network card

1742
01:03:43,599 --> 01:03:45,599
you see if there actually is a packet

1743
01:03:45,599 --> 01:03:46,720
and

1744
01:03:46,720 --> 01:03:50,240
if there's a packet then the dd field

1745
01:03:50,240 --> 01:03:53,920
would be set if the dd field is not set

1746
01:03:53,920 --> 01:03:55,680
then we know there's no packet and so

1747
01:03:55,680 --> 01:03:57,440
we're done

1748
01:03:57,440 --> 01:04:02,150
if it is set then we're going to read it

1749
01:04:02,160 --> 01:04:06,640
and read the length you know and when we

1750
01:04:06,640 --> 01:04:09,200
and then we call and netrx you know do

1751
01:04:09,200 --> 01:04:12,640
the up call into the higher level stack

1752
01:04:12,640 --> 01:04:16,319
and when we're done you know we're

1753
01:04:16,319 --> 01:04:19,280
basically free up you know that entry uh

1754
01:04:19,280 --> 01:04:20,960
so that the driver can use it to

1755
01:04:20,960 --> 01:04:23,280
actually receive more packets in it

1756
01:04:23,280 --> 01:04:25,599
and the real crucial operation there is

1757
01:04:25,599 --> 01:04:27,039
correct and we bump up basically the

1758
01:04:27,039 --> 01:04:29,039
tail you know to tell the driver

1759
01:04:29,039 --> 01:04:30,799
okay you know we're done with it you can

1760
01:04:30,799 --> 01:04:32,400
use it again you know it's yours again

1761
01:04:32,400 --> 01:04:35,750
that slot

1762
01:04:35,760 --> 01:04:37,039
and so maybe the most interesting

1763
01:04:37,039 --> 01:04:39,039
question is and the number of

1764
01:04:39,039 --> 01:04:40,559
question you have you asked us you know

1765
01:04:40,559 --> 01:04:45,510
why is the wild there

1766
01:04:45,520 --> 01:04:48,240
why is this in a loop don't you get an

1767
01:04:48,240 --> 01:04:49,680
interrupt and then you know you grab the

1768
01:04:49,680 --> 01:04:51,200
one pack and then you'll be done or like

1769
01:04:51,200 --> 01:04:52,880
a number of people that actually

1770
01:04:52,880 --> 01:04:54,880
forgot the while loop first you know

1771
01:04:54,880 --> 01:04:56,480
notice that basically at some point you

1772
01:04:56,480 --> 01:04:57,119
don't receive

1773
01:04:57,119 --> 01:05:02,789
packets anymore during net tests

1774
01:05:02,799 --> 01:05:05,200
is it because you would like to transmit

1775
01:05:05,200 --> 01:05:06,960
as many packets that are ready as

1776
01:05:06,960 --> 01:05:09,200
possible with only one interrupt so that

1777
01:05:09,200 --> 01:05:10,480
you can um

1778
01:05:10,480 --> 01:05:12,240
kind of amortize the cost of the

1779
01:05:12,240 --> 01:05:13,760
interrupt

1780
01:05:13,760 --> 01:05:15,599
yeah this is this is absolutely part of

1781
01:05:15,599 --> 01:05:17,680
it you know you get through the

1782
01:05:17,680 --> 01:05:19,280
let's first talk about you know what the

1783
01:05:19,280 --> 01:05:20,880
the root cause you have is right

1784
01:05:20,880 --> 01:05:23,440
right the uh if the number you know the

1785
01:05:23,440 --> 01:05:25,359
burst of packets comes in

1786
01:05:25,359 --> 01:05:27,680
and the network card will generate you

1787
01:05:27,680 --> 01:05:28,880
know the interrupt

1788
01:05:28,880 --> 01:05:30,640
but more packets are coming in and so it

1789
01:05:30,640 --> 01:05:32,079
will just you know put them in the

1790
01:05:32,079 --> 01:05:33,680
three descriptors right that it actually

1791
01:05:33,680 --> 01:05:36,720
can use uh i can't generate more

1792
01:05:36,720 --> 01:05:37,680
interrupts because it's already

1793
01:05:37,680 --> 01:05:39,200
generated in the rut

1794
01:05:39,200 --> 01:05:41,599
and at some point you know the uh you

1795
01:05:41,599 --> 01:05:43,039
know whatever the processor you know

1796
01:05:43,039 --> 01:05:43,520
maybe

1797
01:05:43,520 --> 01:05:45,440
like we were the core was just in a

1798
01:05:45,440 --> 01:05:46,799
section of code that turned off

1799
01:05:46,799 --> 01:05:47,839
interrupts because it was doing

1800
01:05:47,839 --> 01:05:48,880
something atomic

1801
01:05:48,880 --> 01:05:50,079
so at the end of it you know there's a

1802
01:05:50,079 --> 01:05:51,680
releasing from lock that actually turns

1803
01:05:51,680 --> 01:05:52,480
interrupts or not

1804
01:05:52,480 --> 01:05:54,559
at that point in time then basically the

1805
01:05:54,559 --> 01:05:55,839
uh receive

1806
01:05:55,839 --> 01:05:57,280
handler is the interrupt handler is

1807
01:05:57,280 --> 01:05:59,200
going to run right but between that

1808
01:05:59,200 --> 01:06:00,880
period when like that first packet comes

1809
01:06:00,880 --> 01:06:02,400
in and before the receive handler runs

1810
01:06:02,400 --> 01:06:03,359
there's a whole bunch of other packets

1811
01:06:03,359 --> 01:06:04,319
might have come

1812
01:06:04,319 --> 01:06:07,440
it could have come could have come in

1813
01:06:07,440 --> 01:06:09,760
uh and so if we don't run in the while

1814
01:06:09,760 --> 01:06:12,400
loop we'll leave those packets

1815
01:06:12,400 --> 01:06:14,720
uh we'll we'll grab the first one and

1816
01:06:14,720 --> 01:06:15,599
we'll grab the other

1817
01:06:15,599 --> 01:06:17,280
and the later ones are just stick there

1818
01:06:17,280 --> 01:06:18,880
in the queue right they're just sitting

1819
01:06:18,880 --> 01:06:20,640
there in that ring

1820
01:06:20,640 --> 01:06:22,559
now if a subsequent interrupt would come

1821
01:06:22,559 --> 01:06:24,319
in we'll grab the next one

1822
01:06:24,319 --> 01:06:26,720
uh but like the tests you know what they

1823
01:06:26,720 --> 01:06:27,359
do they

1824
01:06:27,359 --> 01:06:29,599
run their udb packets you know so they

1825
01:06:29,599 --> 01:06:30,640
send off a whole bunch

1826
01:06:30,640 --> 01:06:32,960
like one of the tests since like 10 uh

1827
01:06:32,960 --> 01:06:34,720
ping requests in parallel

1828
01:06:34,720 --> 01:06:36,400
you know the 10 responses come in

1829
01:06:36,400 --> 01:06:38,559
parallel back you know correct

1830
01:06:38,559 --> 01:06:41,359
uh the first one receives generates an

1831
01:06:41,359 --> 01:06:42,000
interrupt

1832
01:06:42,000 --> 01:06:45,359
the other nine go into the queue uh

1833
01:06:45,359 --> 01:06:47,119
the higher level software you know

1834
01:06:47,119 --> 01:06:48,799
reached the first one

1835
01:06:48,799 --> 01:06:50,880
uh and then you know returns just like

1836
01:06:50,880 --> 01:06:52,400
it's done and at that point

1837
01:06:52,400 --> 01:06:54,000
nothing happens anymore because the

1838
01:06:54,000 --> 01:06:55,760
receiver is waiting for more receive

1839
01:06:55,760 --> 01:06:56,319
packets

1840
01:06:56,319 --> 01:06:57,599
they happen to be there they're sitting

1841
01:06:57,599 --> 01:07:00,559
in the ring uh except you know you know

1842
01:07:00,559 --> 01:07:01,839
the receive didn't do them in a while

1843
01:07:01,839 --> 01:07:05,670
loop and so it didn't pick them up

1844
01:07:05,680 --> 01:07:13,029
does that make sense

1845
01:07:13,039 --> 01:07:15,119
so for example if the test programs

1846
01:07:15,119 --> 01:07:16,240
would have sent one

1847
01:07:16,240 --> 01:07:19,200
request waited for response one request

1848
01:07:19,200 --> 01:07:20,720
waited for response

1849
01:07:20,720 --> 01:07:22,880
then you would never notice that you

1850
01:07:22,880 --> 01:07:24,480
need to do the while loop

1851
01:07:24,480 --> 01:07:26,400
uh it is because like there's a burst of

1852
01:07:26,400 --> 01:07:28,400
responses might come back

1853
01:07:28,400 --> 01:07:30,400
and that only generate together one

1854
01:07:30,400 --> 01:07:34,870
interrupt

1855
01:07:34,880 --> 01:07:36,960
any questions about that how about this

1856
01:07:36,960 --> 01:07:38,079
i have a question

1857
01:07:38,079 --> 01:07:41,119
uh so for example if instead of a

1858
01:07:41,119 --> 01:07:44,079
while one uh we would have a for loop

1859
01:07:44,079 --> 01:07:45,520
that just goes through the whole cue

1860
01:07:45,520 --> 01:07:46,480
that would also

1861
01:07:46,480 --> 01:07:50,240
be wrong for the same reason um

1862
01:07:50,240 --> 01:07:51,839
no as long as we skip all the ones that

1863
01:07:51,839 --> 01:07:54,559
have the dd not set

1864
01:07:54,559 --> 01:07:56,319
okay should we should only well we

1865
01:07:56,319 --> 01:07:57,520
should only look at packets that

1866
01:07:57,520 --> 01:07:57,920
actually

1867
01:07:57,920 --> 01:07:59,760
uh we should only look at the tail

1868
01:07:59,760 --> 01:08:02,160
pointer

1869
01:08:02,160 --> 01:08:03,760
but you know in principle you could just

1870
01:08:03,760 --> 01:08:05,839
scan the whole cue and i guess we'll

1871
01:08:05,839 --> 01:08:07,359
look at the dd packets

1872
01:08:07,359 --> 01:08:09,680
and let it see if the dd bit is set and

1873
01:08:09,680 --> 01:08:11,119
that might work i don't know i

1874
01:08:11,119 --> 01:08:16,239
haven't tried that okay but isn't the

1875
01:08:16,239 --> 01:08:20,000
device able to put more m buffs in the

1876
01:08:20,000 --> 01:08:20,960
receive

1877
01:08:20,960 --> 01:08:24,880
um after we read stale

1878
01:08:24,880 --> 01:08:29,030
yes yeah yeah yeah

1879
01:08:29,040 --> 01:08:42,149
okay and we have to

1880
01:08:42,159 --> 01:08:43,679
it's very dangerous like this proposal

1881
01:08:43,679 --> 01:08:45,440
of like sort of looking around and you

1882
01:08:45,440 --> 01:08:46,000
know seeing

1883
01:08:46,000 --> 01:08:48,080
the db be the set because you know you

1884
01:08:48,080 --> 01:08:49,679
know really what we should do we should

1885
01:08:49,679 --> 01:08:50,480
not look at

1886
01:08:50,480 --> 01:08:52,080
uh buffers that really are controlled by

1887
01:08:52,080 --> 01:08:54,400
the driver or by the hardware

1888
01:08:54,400 --> 01:08:55,759
and only look at buffers that are

1889
01:08:55,759 --> 01:08:58,159
actually available to us to the software

1890
01:08:58,159 --> 01:09:00,799
and which is indicated by the dd bit and

1891
01:09:00,799 --> 01:09:03,920
basically by looking at the tail pointer

1892
01:09:03,920 --> 01:09:05,759
because basically anything owned between

1893
01:09:05,759 --> 01:09:07,839
the tail and the head is owned by the

1894
01:09:07,839 --> 01:09:13,269
hardware

1895
01:09:13,279 --> 01:09:15,759
going back to the um mbuff like the

1896
01:09:15,759 --> 01:09:17,520
reason we need the mbuff

1897
01:09:17,520 --> 01:09:20,319
why do we need uh the other information

1898
01:09:20,319 --> 01:09:21,040
in the buffer

1899
01:09:21,040 --> 01:09:24,480
like the uh care array um

1900
01:09:24,480 --> 01:09:28,630
i think it's called the backing store

1901
01:09:28,640 --> 01:09:40,470
i think it's in net.h

1902
01:09:40,480 --> 01:09:42,480
so we need we need the buff field

1903
01:09:42,480 --> 01:09:43,679
correct because that actually contains

1904
01:09:43,679 --> 01:09:46,709
the data

1905
01:09:46,719 --> 01:09:48,719
i thought the head contained a pointer

1906
01:09:48,719 --> 01:09:50,480
to the data yeah yeah yeah okay but the

1907
01:09:50,480 --> 01:09:52,080
buff actually is the actual you know

1908
01:09:52,080 --> 01:09:54,080
allocate space you know to hold packets

1909
01:09:54,080 --> 01:09:54,800
correct

1910
01:09:54,800 --> 01:09:57,280
and then head you know points into buff

1911
01:09:57,280 --> 01:10:01,430
to basically the start of the packet

1912
01:10:01,440 --> 01:10:05,440
okay okay and this is the m-buffs this

1913
01:10:05,440 --> 01:10:06,239
is uh

1914
01:10:06,239 --> 01:10:08,480
okay so a little bit more context here

1915
01:10:08,480 --> 01:10:10,159
mbox is a structure that you see in a

1916
01:10:10,159 --> 01:10:12,159
lot of network stacks so you look in the

1917
01:10:12,159 --> 01:10:13,600
linux kernel and you'll see a structure

1918
01:10:13,600 --> 01:10:14,960
similar like this and it's typically

1919
01:10:14,960 --> 01:10:16,159
called mbuffs

1920
01:10:16,159 --> 01:10:19,520
and so we have to um we could have

1921
01:10:19,520 --> 01:10:21,280
simplified this structure quite a bit if

1922
01:10:21,280 --> 01:10:22,239
we wanted to

1923
01:10:22,239 --> 01:10:24,080
uh and maybe in subsequent years we

1924
01:10:24,080 --> 01:10:25,840
should uh but this is sort of the

1925
01:10:25,840 --> 01:10:26,560
standard way

1926
01:10:26,560 --> 01:10:29,280
in which packets are represented in

1927
01:10:29,280 --> 01:10:39,350
operating system kernels

1928
01:10:39,360 --> 01:10:48,870
okay any further questions about this

1929
01:10:48,880 --> 01:10:51,920
um so i have a choice now

1930
01:10:51,920 --> 01:10:54,000
uh there's a couple more things that i

1931
01:10:54,000 --> 01:10:56,800
could say about the network driver

1932
01:10:56,800 --> 01:10:58,239
but then i won't have any time to talk

1933
01:10:58,239 --> 01:11:00,880
about nmap uh i could also talk a little

1934
01:11:00,880 --> 01:11:01,920
bit about map

1935
01:11:01,920 --> 01:11:05,280
and then and stop here uh in terms of

1936
01:11:05,280 --> 01:11:09,590
talking to network driver

1937
01:11:09,600 --> 01:11:24,709
any preferences

1938
01:11:24,719 --> 01:11:31,270
no preferences

1939
01:11:31,280 --> 01:11:33,199
let me talk a little bit about map

1940
01:11:33,199 --> 01:11:34,800
because there was a question that came

1941
01:11:34,800 --> 01:11:36,320
up a couple times

1942
01:11:36,320 --> 01:11:39,520
and that might be worth addressing

1943
01:11:39,520 --> 01:11:43,120
uh uh it's almost more a question about

1944
01:11:43,120 --> 01:11:46,560
you know why map exists than

1945
01:11:46,560 --> 01:11:49,600
uh you know actually how to implement it

1946
01:11:49,600 --> 01:11:52,080
uh so there's no real objections which

1947
01:11:52,080 --> 01:11:53,120
it sounds different

1948
01:11:53,120 --> 01:11:56,640
let me talk a little bit more about map

1949
01:11:56,640 --> 01:11:58,560
so this is your last chance to ask any

1950
01:11:58,560 --> 01:11:59,920
questions about the network driver

1951
01:11:59,920 --> 01:12:06,790
until the end of class

1952
01:12:06,800 --> 01:12:10,000
okay um let's

1953
01:12:10,000 --> 01:12:18,540
talk about inbox map

1954
01:12:18,550 --> 01:12:20,840
[Music]

1955
01:12:20,840 --> 01:12:23,679
uh

1956
01:12:23,679 --> 01:12:28,550
okay

1957
01:12:28,560 --> 01:12:32,000
okay so the the question really relates

1958
01:12:32,000 --> 01:12:33,920
to sort of the file system api

1959
01:12:33,920 --> 01:12:36,320
and so yeah the file system has a

1960
01:12:36,320 --> 01:12:37,360
reasonable broad

1961
01:12:37,360 --> 01:12:40,159
api you have supporting directories

1962
01:12:40,159 --> 01:12:41,280
symbolic links

1963
01:12:41,280 --> 01:12:43,360
hard links etc etc but presumably the

1964
01:12:43,360 --> 01:12:45,600
main the main part of it is the

1965
01:12:45,600 --> 01:12:47,760
the file api correct and the file api

1966
01:12:47,760 --> 01:12:49,679
you know is hopefully well familiar to

1967
01:12:49,679 --> 01:12:50,880
you by now

1968
01:12:50,880 --> 01:12:55,030
and you can open a file

1969
01:12:55,040 --> 01:12:57,360
with you know some permissions and once

1970
01:12:57,360 --> 01:12:58,880
you have opened the file

1971
01:12:58,880 --> 01:13:02,840
you know you can read you know from the

1972
01:13:02,840 --> 01:13:04,560
file

1973
01:13:04,560 --> 01:13:08,880
yeah into a buffer create some data

1974
01:13:08,880 --> 01:13:11,840
um and you can write you know to the

1975
01:13:11,840 --> 01:13:14,950
file

1976
01:13:14,960 --> 01:13:16,960
you know whatever file script or above

1977
01:13:16,960 --> 01:13:18,320
you know laying

1978
01:13:18,320 --> 01:13:22,560
so let's say we uh and then we can close

1979
01:13:22,560 --> 01:13:25,520
you know the file script now let's say

1980
01:13:25,520 --> 01:13:27,120
we want to write an application

1981
01:13:27,120 --> 01:13:30,159
and you can think about the you know

1982
01:13:30,159 --> 01:13:30,560
maybe

1983
01:13:30,560 --> 01:13:32,560
as the file as uh you know the file's

1984
01:13:32,560 --> 01:13:33,600
normally in

1985
01:13:33,600 --> 01:13:36,080
an array of bytes uh but like maybe this

1986
01:13:36,080 --> 01:13:37,600
application has you know sort of

1987
01:13:37,600 --> 01:13:39,360
it's an array of trucks that are stored

1988
01:13:39,360 --> 01:13:40,800
in it and so

1989
01:13:40,800 --> 01:13:42,159
uh and let's say the application wants

1990
01:13:42,159 --> 01:13:44,159
to update this truck so you know we have

1991
01:13:44,159 --> 01:13:44,840
to file

1992
01:13:44,840 --> 01:13:47,440
correct here's our file and sort of

1993
01:13:47,440 --> 01:13:49,199
divide it in

1994
01:13:49,199 --> 01:13:50,960
you know structs you know whatever zero

1995
01:13:50,960 --> 01:13:52,719
to you know here's the file length

1996
01:13:52,719 --> 01:13:55,840
and you know we uh maybe like in the

1997
01:13:55,840 --> 01:13:56,400
middle

1998
01:13:56,400 --> 01:13:58,320
you know let's have a structure maybe 16

1999
01:13:58,320 --> 01:14:00,000
bytes or something and you know we want

2000
01:14:00,000 --> 01:14:01,920
to like update one of these

2001
01:14:01,920 --> 01:14:03,280
but maybe we want to update the first

2002
01:14:03,280 --> 01:14:05,590
one

2003
01:14:05,600 --> 01:14:06,800
and so in the way we could do that

2004
01:14:06,800 --> 01:14:08,719
correctly if we read and we open the

2005
01:14:08,719 --> 01:14:09,280
file

2006
01:14:09,280 --> 01:14:11,360
we read you know the first you know

2007
01:14:11,360 --> 01:14:13,520
whatever 16 bytes

2008
01:14:13,520 --> 01:14:16,400
that correspond to this you know we you

2009
01:14:16,400 --> 01:14:17,040
know let's say

2010
01:14:17,040 --> 01:14:20,000
update you know the first you know field

2011
01:14:20,000 --> 01:14:20,560
or struct

2012
01:14:20,560 --> 01:14:22,159
in the third byte of that struct you

2013
01:14:22,159 --> 01:14:23,840
know to be one

2014
01:14:23,840 --> 01:14:27,280
and then we call right to basically

2015
01:14:27,280 --> 01:14:28,000
write it back

2016
01:14:28,000 --> 01:14:30,239
and then we close the file so if this

2017
01:14:30,239 --> 01:14:31,840
when is the write happens where does it

2018
01:14:31,840 --> 01:14:41,110
actually write

2019
01:14:41,120 --> 01:14:43,920
so we have set the this memory above to

2020
01:14:43,920 --> 01:14:46,080
one we're going to will this

2021
01:14:46,080 --> 01:14:52,149
first byte change to one

2022
01:14:52,159 --> 01:15:08,390
if we call right

2023
01:15:08,400 --> 01:15:09,760
so remember the file script has an

2024
01:15:09,760 --> 01:15:13,360
offshore associated with it correct

2025
01:15:13,360 --> 01:15:15,920
and you know reads read pushes that

2026
01:15:15,920 --> 01:15:17,040
offset you know forward

2027
01:15:17,040 --> 01:15:19,199
in this case if we're at red 16 bytes no

2028
01:15:19,199 --> 01:15:20,480
the offset goes from

2029
01:15:20,480 --> 01:15:27,430
0 to 16. and so where does wright write

2030
01:15:27,440 --> 01:15:30,800
as you notice there's no offset argument

2031
01:15:30,800 --> 01:15:31,679
in the right

2032
01:15:31,679 --> 01:15:37,189
system call so where does it write

2033
01:15:37,199 --> 01:15:41,040
len you know we'll write len bytes and

2034
01:15:41,040 --> 01:15:41,760
which offset

2035
01:15:41,760 --> 01:15:45,280
in the file presumably at land exactly

2036
01:15:45,280 --> 01:15:46,800
at 16 right

2037
01:15:46,800 --> 01:15:49,679
yes it will right here so which so this

2038
01:15:49,679 --> 01:15:50,480
byte will change

2039
01:15:50,480 --> 01:15:54,070
to one correct

2040
01:15:54,080 --> 01:15:57,199
not the actual thing that we were

2041
01:15:57,199 --> 01:15:59,840
actually trying to modify

2042
01:15:59,840 --> 01:16:03,120
does that make sense so the way you

2043
01:16:03,120 --> 01:16:04,560
would written this application it turns

2044
01:16:04,560 --> 01:16:05,440
out there's one

2045
01:16:05,440 --> 01:16:06,880
system call that we didn't really talk

2046
01:16:06,880 --> 01:16:08,800
much about at all but every operating

2047
01:16:08,800 --> 01:16:10,480
system unit operating system has a call

2048
01:16:10,480 --> 01:16:10,880
to call

2049
01:16:10,880 --> 01:16:14,080
a system call called lseq

2050
01:16:14,080 --> 01:16:16,400
and l6 allows you basically to change

2051
01:16:16,400 --> 01:16:17,199
the offset

2052
01:16:17,199 --> 01:16:19,920
to some position and so in this

2053
01:16:19,920 --> 01:16:22,320
particular case we wanted to

2054
01:16:22,320 --> 01:16:23,520
have the effect that we're going to

2055
01:16:23,520 --> 01:16:26,000
write this struct and not that one

2056
01:16:26,000 --> 01:16:28,159
then we would have set like you know lc

2057
01:16:28,159 --> 01:16:29,440
you know zero you know basically

2058
01:16:29,440 --> 01:16:31,679
resetting the offset to actually

2059
01:16:31,679 --> 01:16:35,360
uh the zero and so then this right we're

2060
01:16:35,360 --> 01:16:38,320
actually so here now offset is zero

2061
01:16:38,320 --> 01:16:39,840
and then this right actually you know

2062
01:16:39,840 --> 01:16:41,920
would write actually at the first

2063
01:16:41,920 --> 01:16:51,590
16 bytes does that make sense

2064
01:16:51,600 --> 01:16:52,880
so this is slightly inconvenient

2065
01:16:52,880 --> 01:16:54,560
correctly if you think about this you

2066
01:16:54,560 --> 01:16:55,920
know like you look at this interface you

2067
01:16:55,920 --> 01:16:56,960
know there's actually quite a bit of

2068
01:16:56,960 --> 01:16:57,840
stuff going on

2069
01:16:57,840 --> 01:16:59,520
you know you gotta open you gotta read

2070
01:16:59,520 --> 01:17:00,719
it you know you're gonna seek it and

2071
01:17:00,719 --> 01:17:00,960
then

2072
01:17:00,960 --> 01:17:03,920
going to write it and so one reason that

2073
01:17:03,920 --> 01:17:06,640
map is popular

2074
01:17:06,640 --> 01:17:09,679
is you can sort of avoid uh you know

2075
01:17:09,679 --> 01:17:12,239
these complications because if you would

2076
01:17:12,239 --> 01:17:12,880
write this

2077
01:17:12,880 --> 01:17:16,000
using map you know we do fd is open

2078
01:17:16,000 --> 01:17:20,950
and we open the file as before

2079
01:17:20,960 --> 01:17:26,070
and then uh you know we just call map

2080
01:17:26,080 --> 01:17:27,280
it's going to be like whatever our

2081
01:17:27,280 --> 01:17:30,000
struct let's say our structure's h

2082
01:17:30,000 --> 01:17:33,199
uh you know blah blah blah you know

2083
01:17:33,199 --> 01:17:34,159
whatever

2084
01:17:34,159 --> 01:17:37,199
some link for the file uh

2085
01:17:37,199 --> 01:17:40,630
you know read

2086
01:17:40,640 --> 01:17:44,159
write permissions uh

2087
01:17:44,159 --> 01:17:48,070
you know map shared

2088
01:17:48,080 --> 01:17:52,080
and then file descriptor comma zero

2089
01:17:52,080 --> 01:17:54,960
and then uh so now so basically with

2090
01:17:54,960 --> 01:17:56,560
this dot correct we're in mapping you

2091
01:17:56,560 --> 01:17:58,560
know the file f

2092
01:17:58,560 --> 01:18:01,840
at the location h you know in memory uh

2093
01:18:01,840 --> 01:18:04,000
now we can just like say h you know

2094
01:18:04,000 --> 01:18:06,000
whatever first byte

2095
01:18:06,000 --> 01:18:09,600
is zero or one as we did before and then

2096
01:18:09,600 --> 01:18:10,960
you know at some point you know we can

2097
01:18:10,960 --> 01:18:16,390
unmap

2098
01:18:16,400 --> 01:18:20,630
you know the unmapped uh

2099
01:18:20,640 --> 01:18:22,400
h right and so if we think about this

2100
01:18:22,400 --> 01:18:24,239
okay so we look in memory

2101
01:18:24,239 --> 01:18:25,679
we're looking at this from the

2102
01:18:25,679 --> 01:18:27,600
perspective of the file you know what

2103
01:18:27,600 --> 01:18:29,360
this does correct because literally did

2104
01:18:29,360 --> 01:18:31,040
is basically got a pointer

2105
01:18:31,040 --> 01:18:33,360
you know to this h and you can just

2106
01:18:33,360 --> 01:18:35,840
update here you know that thing to one

2107
01:18:35,840 --> 01:18:39,120
and be done with it right and so if we

2108
01:18:39,120 --> 01:18:39,679
sort of

2109
01:18:39,679 --> 01:18:41,520
need to manipulate you know file

2110
01:18:41,520 --> 01:18:43,199
structure you know data structures that

2111
01:18:43,199 --> 01:18:44,960
sit inside of a file

2112
01:18:44,960 --> 01:18:46,719
uh this map interface is much more

2113
01:18:46,719 --> 01:18:48,000
convenient

2114
01:18:48,000 --> 01:18:50,320
than you know this previous interface

2115
01:18:50,320 --> 01:18:51,840
where you know we have to read

2116
01:18:51,840 --> 01:18:54,159
you know we manipulated the memory you

2117
01:18:54,159 --> 01:18:55,679
know we you know seek back

2118
01:18:55,679 --> 01:18:56,640
and then we actually write the

2119
01:18:56,640 --> 01:18:58,960
information uh and in this particular

2120
01:18:58,960 --> 01:19:00,960
case you know we really can think about

2121
01:19:00,960 --> 01:19:03,360
the file as being an array of bytes you

2122
01:19:03,360 --> 01:19:04,159
know that we can

2123
01:19:04,159 --> 01:19:06,080
write willy-nilly without actually

2124
01:19:06,080 --> 01:19:12,310
having to navigate or jump around

2125
01:19:12,320 --> 01:19:14,800
do people see what the advantage of the

2126
01:19:14,800 --> 01:19:23,910
nmap interface is

2127
01:19:23,920 --> 01:19:28,229
any questions about this

2128
01:19:28,239 --> 01:19:31,920
do any big storage systems uh use uh

2129
01:19:31,920 --> 01:19:34,080
this like i don't know like databases do

2130
01:19:34,080 --> 01:19:35,199
they use this a lot

2131
01:19:35,199 --> 01:19:38,800
or not really they use this a lot yeah

2132
01:19:38,800 --> 01:19:40,320
i think a lot of applications will use

2133
01:19:40,320 --> 01:19:42,000
map because for

2134
01:19:42,000 --> 01:19:43,600
these kinds of things like a database

2135
01:19:43,600 --> 01:19:47,590
it's much more convenient

2136
01:19:47,600 --> 01:19:49,120
than this this interface this interface

2137
01:19:49,120 --> 01:19:50,480
is great correct if you need to read

2138
01:19:50,480 --> 01:19:51,679
from standard input

2139
01:19:51,679 --> 01:19:53,520
and there's a stream of bytes coming in

2140
01:19:53,520 --> 01:19:54,960
you just read you read you read and then

2141
01:19:54,960 --> 01:19:56,560
you produce some output on some other

2142
01:19:56,560 --> 01:20:00,000
uh stream that interface

2143
01:20:00,000 --> 01:20:02,080
that interface is very suitable for here

2144
01:20:02,080 --> 01:20:03,600
you don't have to update offset you know

2145
01:20:03,600 --> 01:20:04,400
you read you can

2146
01:20:04,400 --> 01:20:06,000
offset immediately update you read again

2147
01:20:06,000 --> 01:20:07,280
you read a little bit further et cetera

2148
01:20:07,280 --> 01:20:07,840
et cetera

2149
01:20:07,840 --> 01:20:09,120
so it's really good for sort of the

2150
01:20:09,120 --> 01:20:12,159
stream-oriented uh inputs

2151
01:20:12,159 --> 01:20:13,760
uh well this is really good you know if

2152
01:20:13,760 --> 01:20:16,239
the file has for the data structure

2153
01:20:16,239 --> 01:20:19,280
uh and you just want to sort of

2154
01:20:19,280 --> 01:20:21,840
update bits and pieces of the file and

2155
01:20:21,840 --> 01:20:22,480
you know

2156
01:20:22,480 --> 01:20:32,159
arbitrary locations

2157
01:20:32,159 --> 01:20:36,390
okay um

2158
01:20:36,400 --> 01:20:39,280
let's see um so i'm going to start i'm

2159
01:20:39,280 --> 01:20:40,400
i'm

2160
01:20:40,400 --> 01:20:45,440
about to run out of time um so let me

2161
01:20:45,440 --> 01:20:47,440
stop here hopefully this one one sort of

2162
01:20:47,440 --> 01:20:48,639
tidbit about mmap

2163
01:20:48,639 --> 01:20:52,000
you know as uh useful to uh to know uh

2164
01:20:52,000 --> 01:20:54,719
and uh tells you why you know that sort

2165
01:20:54,719 --> 01:20:55,040
of

2166
01:20:55,040 --> 01:21:00,080
is a popular scheme

2167
01:21:00,080 --> 01:21:03,040
uh let's see uh so i i think for that

2168
01:21:03,040 --> 01:21:04,480
actually you know we were

2169
01:21:04,480 --> 01:21:06,080
basically we come to the the end of this

2170
01:21:06,080 --> 01:21:08,719
lecture and i guess the end of

2171
01:21:08,719 --> 01:21:12,550
uh

2172
01:21:12,560 --> 01:21:16,000
the end of success 6s081

2173
01:21:16,000 --> 01:21:18,800
and so again you know if you have not

2174
01:21:18,800 --> 01:21:19,679
filled out the

2175
01:21:19,679 --> 01:21:24,080
uh feedback survey you know uh please uh

2176
01:21:24,080 --> 01:21:26,480
do so you know we really appreciate if

2177
01:21:26,480 --> 01:21:29,199
you fill out the subject evaluation

2178
01:21:29,199 --> 01:21:32,960
and again i want to thank you for

2179
01:21:32,960 --> 01:21:34,800
you know your attention again it is a

2180
01:21:34,800 --> 01:21:36,239
strange semester uh

2181
01:21:36,239 --> 01:21:37,840
i wish i could have met you all in

2182
01:21:37,840 --> 01:21:39,440
person and

2183
01:21:39,440 --> 01:21:42,239
talk to you in person either class or

2184
01:21:42,239 --> 01:21:44,239
before class or after class

2185
01:21:44,239 --> 01:21:47,840
uh and unfortunately that

2186
01:21:47,840 --> 01:21:50,960
hasn't happened uh but i hope you you

2187
01:21:50,960 --> 01:21:53,440
got quite a bit of out of uh son one and

2188
01:21:53,440 --> 01:21:55,199
uh certainly with the staff thank you

2189
01:21:55,199 --> 01:21:56,880
for the engagement

2190
01:21:56,880 --> 01:21:58,560
you guys have been wonderful this

2191
01:21:58,560 --> 01:22:01,199
semester so with that

2192
01:22:01,199 --> 01:22:03,920
thank you and if you have any questions

2193
01:22:03,920 --> 01:22:06,480
please hang on hang around

2194
01:22:06,480 --> 01:22:09,920
but i'm sure some of you have deadlines

2195
01:22:09,920 --> 01:22:11,760
i want to say on behalf of the

2196
01:22:11,760 --> 01:22:14,960
tas as well we've really enjoyed um all

2197
01:22:14,960 --> 01:22:16,239
the time we spent with you guys in

2198
01:22:16,239 --> 01:22:18,159
office hours and doing check-offs and

2199
01:22:18,159 --> 01:22:19,360
this is the first semester where we've

2200
01:22:19,360 --> 01:22:20,960
done check-offs and i think david and i

2201
01:22:20,960 --> 01:22:21,920
both

2202
01:22:21,920 --> 01:22:23,760
found it a really enjoyable process and

2203
01:22:23,760 --> 01:22:25,679
you know hopefully we were able to

2204
01:22:25,679 --> 01:22:27,440
help you guys out and have some good

2205
01:22:27,440 --> 01:22:28,960
conversations as well so

2206
01:22:28,960 --> 01:22:30,480
thanks for making it a great semester

2207
01:22:30,480 --> 01:22:32,639
and adjusting on the fly with us with

2208
01:22:32,639 --> 01:22:34,080
all of the uh

2209
01:22:34,080 --> 01:22:36,000
remote learning problems we've you know

2210
01:22:36,000 --> 01:22:38,080
run into and had to deal with it's been

2211
01:22:38,080 --> 01:22:39,440
an absolute pleasure to eating this

2212
01:22:39,440 --> 01:22:46,229
course

2213
01:22:46,239 --> 01:22:49,520
any further questions or you know again

2214
01:22:49,520 --> 01:23:00,470
feel free to hang around

2215
01:23:00,480 --> 01:23:03,840
oh um i had a question

2216
01:23:03,840 --> 01:23:07,199
so it's it's oh yeah thank you so much

2217
01:23:07,199 --> 01:23:08,080
for the class i

2218
01:23:08,080 --> 01:23:09,520
really like the class it's the best

2219
01:23:09,520 --> 01:23:11,679
class this semester um

2220
01:23:11,679 --> 01:23:14,880
i wanted to ask about the interrupts

2221
01:23:14,880 --> 01:23:18,000
the receive interrupts how does the how

2222
01:23:18,000 --> 01:23:20,000
does the hardware knows

2223
01:23:20,000 --> 01:23:24,320
when when the software has finished

2224
01:23:24,320 --> 01:23:26,800
handling the previous interrupt to not

2225
01:23:26,800 --> 01:23:28,880
issue another one

2226
01:23:28,880 --> 01:23:33,679
because there's multiple steps

2227
01:23:33,679 --> 01:23:36,960
one is you know if you're looking

2228
01:23:36,960 --> 01:23:40,470
uh

2229
01:23:40,480 --> 01:23:43,840
you want thousands at the bottom we

2230
01:23:43,840 --> 01:23:46,239
re-enable interrupts or we tell the card

2231
01:23:46,239 --> 01:23:47,520
you know we're ready to receive for the

2232
01:23:47,520 --> 01:23:49,040
interrupts

2233
01:23:49,040 --> 01:23:50,960
so that's how we think that will tell

2234
01:23:50,960 --> 01:23:52,639
the car to generate interrupts

2235
01:23:52,639 --> 01:23:53,840
of course at this point interrupts

2236
01:23:53,840 --> 01:23:55,600
actually not really turned on and we

2237
01:23:55,600 --> 01:23:56,960
just tells the card you can generate

2238
01:23:56,960 --> 01:23:58,239
interrupts again

2239
01:23:58,239 --> 01:24:00,639
uh the interrupts get turned on correct

2240
01:24:00,639 --> 01:24:01,679
like you know by

2241
01:24:01,679 --> 01:24:02,960
you know these functions you know

2242
01:24:02,960 --> 01:24:04,880
interrupt enable

2243
01:24:04,880 --> 01:24:06,400
and at that point if you turn on the

2244
01:24:06,400 --> 01:24:08,320
internet or able if this interrupt if

2245
01:24:08,320 --> 01:24:08,639
this

2246
01:24:08,639 --> 01:24:10,800
this field was set plus you know at the

2247
01:24:10,800 --> 01:24:12,560
point where you turn on interrupt enable

2248
01:24:12,560 --> 01:24:13,600
and actually interrupt

2249
01:24:13,600 --> 01:24:16,960
might happen again right i forgot about

2250
01:24:16,960 --> 01:24:18,560
this register thank you so much

2251
01:24:18,560 --> 01:24:21,840
yeah it's like one instruction

2252
01:24:21,840 --> 01:24:25,830
easy to miss

2253
01:24:25,840 --> 01:24:30,320
any other questions

2254
01:24:30,320 --> 01:24:36,629
all right thank you all thank you okay

2255
01:24:36,639 --> 01:24:40,800
thank you thank you

2256
01:24:40,800 --> 01:24:48,390
thank you so much

